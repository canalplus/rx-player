!function webpackUniversalModuleDefinition(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.RxPlayer = factory() : root.RxPlayer = factory();
}(window, function() {
    /******/
    return function(modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/
        /******/ // The require function
        /******/        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) 
            /******/ return installedModules[moduleId].exports;
            /******/
            /******/ // Create a new module (and put it into the cache)
            /******/            var module = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: !1,
                /******/ exports: {}
                /******/            };
            /******/
            /******/ // Execute the module function
            /******/            
            /******/
            /******/ // Return the exports of the module
            /******/ return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            /******/
            /******/ // Flag the module as loaded
            /******/ module.l = !0, module.exports;
            /******/        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/        
        /******/
        /******/
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__.m = modules, 
        /******/
        /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules, 
        /******/
        /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ __webpack_require__.o(exports, name) || 
            /******/ Object.defineProperty(exports, name, {
                enumerable: !0,
                get: getter
            })
            /******/;
        }, 
        /******/
        /******/ // define __esModule on exports
        /******/ __webpack_require__.r = function(exports) {
            /******/ "undefined" != typeof Symbol && Symbol.toStringTag && 
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            })
            /******/ , Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }, 
        /******/
        /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/ __webpack_require__.t = function(value, mode) {
            /******/ if (
            /******/ 1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
            /******/            if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
            /******/            var ns = Object.create(null);
            /******/            
            /******/ if (__webpack_require__.r(ns), 
            /******/ Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key];
            }.bind(null, key));
            /******/            return ns;
            /******/        }, 
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module) {
            /******/ var getter = module && module.__esModule ? 
            /******/ function getDefault() {
                return module.default;
            } : 
            /******/ function getModuleExports() {
                return module;
            };
            /******/            
            /******/ return __webpack_require__.d(getter, "a", getter), getter;
            /******/        }, 
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, 
        /******/
        /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 173);
        /******/    }
    /************************************************************************/
    /******/ ([ 
    /* 0 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/noop.ts
                var noop = __webpack_require__(28), logger = new (
        /* */
        function() {
            function Logger() {
                this.error = noop.a, this.warn = noop.a, this.info = noop.a, this.debug = noop.a, 
                this.LEVELS = {
                    NONE: 0,
                    ERROR: 1,
                    WARNING: 2,
                    INFO: 3,
                    DEBUG: 4
                }, this.currentLevel = "NONE";
            }
            /**
   * @param {string} levelStr
   */            var _proto = Logger.prototype;
            return _proto.setLevel = function setLevel(levelStr) {
                var level, foundLevel = this.LEVELS[levelStr];
                this.currentLevel = foundLevel ? (
                // levelStr is a ILoggerLevel
                level = foundLevel, levelStr) : (
                // either 0 or not found
                level = 0, "NONE")
                /* tslint:disable no-invalid-this */
                /* tslint:disable no-console */ , this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop.a, 
                this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop.a, 
                this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop.a, this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop.a;
            }
            /**
   * @returns {string}
   */ , _proto.getLevel = function getLevel() {
                return this.currentLevel;
            }, Logger;
        }())();
        // CONCATENATED MODULE: ./src/utils/logger.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        __webpack_exports__.a = logger;
    }, 
    /* 1 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "p", function() {
            return strToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return bytesToStr;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return bytesToUTF16Str;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return hexToBytes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return bytesToHex;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return concat;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return be2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return be3toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return be4toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return be8toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() {
            return le2toi;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() {
            return le4toi;
        }), 
        /* unused harmony export le8toi */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return itobe2;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() {
            return itobe4;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() {
            return itobe8;
        }), 
        /* unused harmony export itole2 */
        /* unused harmony export itole4 */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return guidToUuid;
        });
        /* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert a simple string to an Uint8Array containing the corresponding
 * UTF-8 code units.
 * /!\ its implementation favors simplicity and performance over accuracy.
 * Each character having a code unit higher than 255 in UTF-16 will be
 * truncated (real value % 256).
 * Please take that into consideration when calling this function.
 * @param {string} str
 * @returns {Uint8Array}
 */        function strToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len), i = 0; i < len; i++) arr[i] = 255 & str.charCodeAt(i);
            return arr;
        }
        /**
 * construct string from the code units given
 * @param {Uint16Array|Uint8Array} bytes
 * @returns {string}
 */        function bytesToStr(bytes) {
            // NOTE: ugly I know, but TS is problematic here (you can try)
            return String.fromCharCode.apply(null, bytes);
        }
        /**
 * construct string from the code units given.
 * Only use every other byte for each UTF-16 character.
 * @param {Uint8Array} bytes
 * @returns {string}
 */        function bytesToUTF16Str(bytes) {
            for (var str = "", len = bytes.length, i = 0; i < len; i += 2) str += String.fromCharCode(bytes[i]);
            return str;
        }
        /**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */        function hexToBytes(str) {
            for (var len = str.length, arr = new Uint8Array(len / 2), i = 0, j = 0; i < len; i += 2, 
            j++) arr[j] = 255 & parseInt(str.substring(i, i + 2), 16);
            return arr;
        }
        /**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */        function bytesToHex(bytes, sep) {
            void 0 === sep && (sep = "");
            for (var hex = "", i = 0; i < bytes.byteLength; i++) hex += (bytes[i] >>> 4).toString(16), 
            hex += (15 & bytes[i]).toString(16), sep.length && i < bytes.byteLength - 1 && (hex += sep);
            return hex;
        }
        /**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */        function concat() {
            for (var arg, l = arguments.length, i = -1, len = 0; ++i < l; ) len += "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? arg : arg.length;
            var arr = new Uint8Array(len), offset = 0;
            for (i = -1; ++i < l; ) "number" == typeof (arg = i < 0 || arguments.length <= i ? void 0 : arguments[i]) ? offset += arg : 0 < arg.length && (arr.set(arg, offset), 
            offset += arg.length);
            return arr;
        }
        /**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be2toi(bytes, offset) {
            return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
        }
        /**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be3toi(bytes, offset) {
            return 65536 * bytes[offset + 0] + 256 * bytes[offset + 1] + bytes[offset + 2];
        }
        /**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be4toi(bytes, offset) {
            return 16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3];
        }
        /**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function be8toi(bytes, offset) {
            return 4294967296 * (16777216 * bytes[offset + 0] + 65536 * bytes[offset + 1] + 256 * bytes[offset + 2] + bytes[offset + 3]) + 16777216 * bytes[offset + 4] + 65536 * bytes[offset + 5] + 256 * bytes[offset + 6] + bytes[offset + 7];
        }
        /**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe2(num) {
            return new Uint8Array([ num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe4(num) {
            return new Uint8Array([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, 255 & num ]);
        }
        /**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */        function itobe8(num) {
            var l = num % 4294967296, h = (num - l) / 4294967296;
            return new Uint8Array([ h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l ]);
        }
        /**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le2toi(bytes, offset) {
            return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
        }
        /**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        function le4toi(bytes, offset) {
            return bytes[offset + 0] + 256 * bytes[offset + 1] + 65536 * bytes[offset + 2] + 16777216 * bytes[offset + 3];
        }
        /**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */        
        /**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
        function guidToUuid(uuid) {
            Object(_assert__WEBPACK_IMPORTED_MODULE_0__.b)(16 === uuid.length, "UUID length should be 16");
            var buf = strToBytes(uuid), p1A = buf[0], p1B = buf[1], p1C = buf[2], p1D = buf[3], p2A = buf[4], p2B = buf[5], p3A = buf[6], p3B = buf[7], p4 = buf.subarray(8, 10), p5 = buf.subarray(10, 16), ord = new Uint8Array(16);
            return ord[0] = p1D, ord[1] = p1C, ord[2] = p1B, ord[3] = p1A, // swap32 BE -> LE
            ord[4] = p2B, ord[5] = p2A, // swap16 BE -> LE
            ord[6] = p3B, ord[7] = p3A, // swap16 BE -> LE
            ord.set(p4, 8), ord.set(p5, 10), bytesToHex(ord);
        }
        /***/    }, 
    /* 2 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return __extends;
        });
        /* unused harmony export __assign */
        /* unused harmony export __rest */
        /* unused harmony export __decorate */
        /* unused harmony export __param */
        /* unused harmony export __metadata */
        /* unused harmony export __awaiter */
        /* unused harmony export __generator */
        /* unused harmony export __exportStar */
        /* unused harmony export __values */
        /* unused harmony export __read */
        /* unused harmony export __spread */
        /* unused harmony export __spreadArrays */
        /* unused harmony export __await */
        /* unused harmony export __asyncGenerator */
        /* unused harmony export __asyncDelegator */
        /* unused harmony export __asyncValues */
        /* unused harmony export __makeTemplateObject */
        /* unused harmony export __importStar */
        /* unused harmony export __importDefault */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        /* global Reflect, Promise */
        var extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            })(d, b);
        };
        function __extends(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        }
    }, 
    /* 3 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
        /* harmony default export */        __webpack_exports__.a = {
            /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
            DEFAULT_UNMUTED_VOLUME: .1,
            /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
            DEFAULT_REQUEST_TIMEOUT: 3e4,
            /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
            DEFAULT_TEXT_TRACK_MODE: "native",
            /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
            DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",
            /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
            DEFAULT_AUTO_PLAY: !1,
            /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
            DEFAULT_SHOW_NATIVE_SUBTITLE: !0,
            /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
            DEFAULT_STOP_AT_END: !0,
            /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
            DEFAULT_WANTED_BUFFER_AHEAD: 30,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_AHEAD: Infinity,
            /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
            DEFAULT_MAX_BUFFER_BEHIND: Infinity,
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_AHEAD: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
            MAXIMUM_MAX_BUFFER_BEHIND: {
                text: 18e3
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
            DEFAULT_INITIAL_BITRATES: {
                audio: 0,
                video: 0,
                other: 0
            },
            /* tslint:disable no-object-literal-type-assertion */
            /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
            DEFAULT_MAX_BITRATES: {
                audio: Infinity,
                video: Infinity,
                other: Infinity
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
            INACTIVITY_DELAY: 6e4,
            /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
            DEFAULT_THROTTLE_WHEN_HIDDEN: !1,
            /**
   * If true, if the video is considered in a "hidden" state for a delay specified by
   * the INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
            DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: !1,
            /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
            DEFAULT_LIMIT_VIDEO_WIDTH: !1,
            /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
            DEFAULT_LIVE_GAP: {
                DEFAULT: 10,
                LOW_LATENCY: 3
            },
            /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
            BUFFER_DISCONTINUITY_THRESHOLD: 1,
            /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
            BITRATE_REBUFFERING_RATIO: 1.5,
            /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
            BUFFER_GC_GAPS: {
                /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
                CALM: 240,
                /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
                BEEFY: 30
            },
            /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
            /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
            /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
            DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
            /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            INITIAL_BACKOFF_DELAY_BASE: {
                REGULAR: 200,
                LOW_LATENCY: 50
            },
            /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
            MAX_BACKOFF_DELAY_BASE: {
                REGULAR: 3e3,
                LOW_LATENCY: 1e3
            },
            /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
            SAMPLING_INTERVAL_MEDIASOURCE: 1e3,
            /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
   * @type {Number}
   */
            SAMPLING_INTERVAL_LOW_LATENCY: 250,
            /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
            SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
            /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
            ABR_MINIMUM_TOTAL_BYTES: 15e4,
            /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
            ABR_MINIMUM_CHUNK_SIZE: 16e3,
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Object}
   */
            ABR_STARVATION_FACTOR: {
                DEFAULT: .72,
                LOW_LATENCY: .64
            },
            /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Object}
   */
            ABR_REGULAR_FACTOR: {
                DEFAULT: .9,
                LOW_LATENCY: .9
            },
            /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Object}
   */
            ABR_STARVATION_GAP: {
                DEFAULT: 5,
                LOW_LATENCY: 5
            },
            OUT_OF_STARVATION_GAP: {
                DEFAULT: 7,
                LOW_LATENCY: 7
            },
            /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
            ABR_STARVATION_DURATION_DELTA: .1,
            /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_FAST_EMA: 2,
            /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
            ABR_SLOW_EMA: 10,
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
            RESUME_GAP_AFTER_SEEKING: {
                DEFAULT: 1.5,
                LOW_LATENCY: .5
            },
            /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
            RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
                DEFAULT: .5,
                LOW_LATENCY: .5
            },
            /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
            RESUME_GAP_AFTER_BUFFERING: {
                DEFAULT: 5,
                LOW_LATENCY: .5
            },
            /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
            STALL_GAP: {
                DEFAULT: .5,
                LOW_LATENCY: .2
            },
            /**
   * Maximum authorized difference between what we calculated to be the
   * beginning or end of the segment in the SourceBuffer and what we
   * actually are noticing now.
   *
   * If the segment seems to have removed more than this size in seconds, we
   * will infer that the segment has been garbage collected and we might try to
   * re-download it.
   * @type {Number}
   */
            MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: .15,
            /**
   * The maximum authorized difference, in seconds, between the real buffered
   * time of a given chunk and what the segment information of the Manifest
   * tells us.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments).
   * @type {Number}
   */
            MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: .4,
            /**
   * The maximum authorized difference, in seconds, between the duration a
   * segment should have according to the Manifest and the actual duration it
   * seems to have once pushed to the SourceBuffer.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments). This last point
   * could lead to unnecessary segment re-downloading.
   * @type {Number}
   */
            MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: .3,
            /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
            MINIMUM_SEGMENT_SIZE: .005,
            /**
   * Append windows allow to filter media data from segments if they are outside
   * a given limit.
   * Coded frames with presentation timestamp within this range are allowed to
   * be appended to the SourceBuffer while coded frames outside this range are
   * filtered out.
   *
   * Those are often set to be the start and end of the "Period" the segment is
   * in.
   * However, we noticed that some browsers were too aggressive when the exact
   * limits were set: more data than needed was removed, often leading to
   * discontinuities.
   *
   * Those securities are added to the set windows (substracted from the window
   * start and added to the window end) to avoid those problems.
   * @type {Object}
   */
            APPEND_WINDOW_SECURITIES: {
                START: .2,
                END: .1
            },
            /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
            MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
            /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is above
   * the padding described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the padding too low would increase the risk of re-bufferings.
   *
   * Keeping the padding too high would delay visible quality increase.
   *
   * @type {Object}
   */
            BUFFER_PADDING: {
                audio: 1,
                video: 3,
                other: 1
            },
            /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
            SEGMENT_PRIORITIES_STEPS: [ 6, 14 ],
            /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
            EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [ "HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO" ],
            /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
            /* tslint:disable no-object-literal-type-assertion */
            EME_KEY_SYSTEMS: {
                clearkey: [ "webkit-org.w3.clearkey", "org.w3.clearkey" ],
                widevine: [ "com.widevine.alpha" ],
                playready: [ "com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready" ]
            },
            /* tslint:enable no-object-literal-type-assertion */
            /**
   * When we detect that the local Manifest might be out-of-sync with the
   * server's one, we schedule a Manifest refresh.
   * However, as this "unsynchronization" is only a theory and as we do not want
   * to send too many Manifest requests, we keep a delay between the last
   * Manifest refresh done and that one.
   * This value indicates which delay we want. Note that the Manifest could
   * still be refreshed before this delay for other reasons.
   * @type {Number}
   */
            OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3e3,
            /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
            EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
            /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
            FORCED_ENDED_THRESHOLD: .001,
            /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
            ADAPTATION_SWITCH_BUFFER_PADDINGS: {
                video: {
                    before: .5,
                    after: 1
                },
                audio: {
                    before: .5,
                    after: 2
                },
                text: {
                    before: 0,
                    after: 0
                },
                image: {
                    before: 0,
                    after: 0
                }
            },
            /**
   * Interval, in milliseconds, at which we should manually flush
   * SourceBuffers.
   * Some browsers (happened with firefox 66) sometimes "forget" to send us
   * `update` or `updateend` events.
   * In that case, we're completely unable to continue the queue here and
   * stay locked in a waiting state.
   * This interval is here to check at regular intervals if the underlying
   * SourceBuffer is currently updating.
   * @type {Number}
   */
            SOURCE_BUFFER_FLUSHING_INTERVAL: 2e3
        };
    }, 
    /* 4 */ 
    /* 5 */ , 
    /* 6 */
    /***/ , 
    /* 6 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
                var event_listeners = __webpack_require__(46), next_tick = __webpack_require__(65), next_tick_default = /* */ __webpack_require__.n(next_tick), event_emitter = __webpack_require__(38);
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                // CONCATENATED MODULE: ./src/compat/index.ts
        /* concated harmony reexport events */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return event_listeners;
        }), 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO TO REMOVE
        // CONCATENATED MODULE: ./src/compat/patch_webkit_source_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // TODO This is the last ugly side-effect here.
        // Either remove it or find the best way to implement that
        function patchWebkitSourceBuffer() {
            // old WebKit SourceBuffer implementation,
            // where a synchronous append is used instead of appendBuffer
            if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {
                var sourceBufferWebkitProto = window.WebKitSourceBuffer.prototype;
                for (var fnName in event_emitter.a.prototype) event_emitter.a.prototype.hasOwnProperty(fnName) && (sourceBufferWebkitProto[fnName] = event_emitter.a.prototype[fnName]);
                sourceBufferWebkitProto._listeners = [], sourceBufferWebkitProto.__emitUpdate = function(eventName, val) {
                    var _this = this;
                    next_tick_default()(function() {
                        /* tslint:disable no-invalid-this */
                        _this.trigger(eventName, val), _this.updating = !1, _this.trigger("updateend");
                    });
                }, sourceBufferWebkitProto.appendBuffer = function(data) {
                    /* tslint:disable no-invalid-this */
                    if (this.updating) throw new Error("updating");
                    this.trigger("updatestart"), this.updating = !0;
                    try {
                        this.append(data);
                    } catch (error) {
                        return void this.__emitUpdate("error", error);
                    }
                    this.__emitUpdate("update");
                };
            }
        }();
    }, 
    /* 7 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscriber;
        });
        /* unused harmony export SafeSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54), _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66), _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39), _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58), Subscriber = /* */ function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, 
                _this.isStopped = !1, arguments.length) {
                  case 0:
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        destinationOrNext instanceof Subscriber ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, 
                        (_this.destination = destinationOrNext).add(_this)) : (_this.syncErrorThrowable = !0, 
                        _this.destination = new SafeSubscriber(_this, destinationOrNext));
                        break;
                    }

                  default:
                    _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                }
                return _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subscriber, _super), Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a] = function() {
                return this;
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value);
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this));
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value);
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe();
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe();
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parentOrParents = this._parentOrParents;
                return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, 
                this._parentOrParents = _parentOrParents, this;
            }, Subscriber;
        }(_Subscription__WEBPACK_IMPORTED_MODULE_3__.a), SafeSubscriber = /* */ function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__.a && (context = Object.create(observerOrNext), 
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, 
                _this._next = next, _this._error = error, _this._complete = complete, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber, useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._error, err) : this.__tryOrUnsub(this._error, err), 
                    this.unsubscribe(); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context);
                        };
                        _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, wrappedComplete) : this.__tryOrUnsub(wrappedComplete), 
                        this.unsubscribe();
                    } else this.unsubscribe();
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err);
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), 
                    !0);
                }
                return !1;
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }, SafeSubscriber;
        }(Subscriber);
        /* harmony import */    }, 
    /* 8 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
                var Subscriber = __webpack_require__(7);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
        /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */        function canReportError(observer) {
            for (;observer; ) {
                var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
                if (closed_1 || isStopped) return !1;
                observer = destination && destination instanceof Subscriber.a ? destination : null;
            }
            return !0;
        }
        //# sourceMappingURL=canReportError.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
                var rxSubscriber = __webpack_require__(66), Observer = __webpack_require__(79);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
        function toSubscriber(nextOrObserver, error, complete) {
            if (nextOrObserver) {
                if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]();
            }
            return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a);
        }
        //# sourceMappingURL=toSubscriber.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
                var observable = __webpack_require__(48), noop = __webpack_require__(43);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
                function pipeFromArray(fns) {
            return fns ? 1 === fns.length ? fns[0] : function piped(input) {
                return fns.reduce(function(prev, fn) {
                    return fn(prev);
                }, input);
            } : noop.a;
        }
        //# sourceMappingURL=pipe.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
                var config = __webpack_require__(39);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Observable_Observable;
        });
        /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
        var Observable_Observable = /* */ function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe);
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable();
                return observable.source = this, observable.operator = operator, observable;
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator, sink = toSubscriber(observerOrNext, error, complete);
                if (operator ? sink.add(operator.call(sink, this.source)) : sink.add(this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink;
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink);
                } catch (err) {
                    config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), 
                    canReportError(sink) ? sink.error(err) : console.warn(err);
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe(function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe();
                        }
                    }, reject, resolve);
                });
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber);
            }, Observable.prototype[observable.a] = function() {
                return this;
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : pipeFromArray(operations)(this);
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new (promiseCtor = getPromiseCtor(promiseCtor))(function(resolve, reject) {
                    var value;
                    _this.subscribe(function(x) {
                        return value = x;
                    }, function(err) {
                        return reject(err);
                    }, function() {
                        return resolve(value);
                    });
                });
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe);
            }, Observable;
        }();
        function getPromiseCtor(promiseCtor) {
            if (!(promiseCtor = promiseCtor || (config.a.Promise || Promise))) throw new Error("no Promise impl found");
            return promiseCtor;
        }
        //# sourceMappingURL=Observable.js.map
        /***/    }, 
    /* 9 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
        function arrayFind(arr, predicate, thisArg) {
            if ("function" == typeof Array.prototype.find) 
            /* tslint:disable ban */
            return arr.find(predicate, thisArg);
            /* tslint:enable ban */            for (var len = arr.length >>> 0, i = 0; i < len; i++) {
                var val = arr[i];
                if (predicate.call(thisArg, val, i, arr)) return val;
            }
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayFind;
        });
    }, 
    /* 10 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */
        /**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */        
        /* harmony default export */ __webpack_exports__.a = {
            transports: {},
            imageBuffer: null,
            imageParser: null,
            nativeTextTracksBuffer: null,
            nativeTextTracksParsers: {},
            htmlTextTracksBuffer: null,
            htmlTextTracksParsers: {},
            emeManager: null,
            directfile: null
        };
    }, 
    /* 11 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/
        /* eslint-disable no-unused-vars */        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        module.exports = function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                                var test1 = new String("abc");
 // eslint-disable-line no-new-wrappers
                                if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                if ("0123456789" !== Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                }).join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, 
    /* 12 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
        function arrayIncludes(arr, searchElement, fromIndex) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof Array.prototype.includes) 
            /* tslint:enable no-unbound-method */
            /* tslint:disable ban */
            return arr.includes(searchElement, fromIndex);
            /* tslint:enable ban */            var len = arr.length >>> 0;
            if (0 == len) return !1;
            for (var n = 0 | fromIndex, k = 0 <= n ? Math.min(n, len - 1) : Math.max(len + n, 0), areTheSame = function areTheSame(x, y) {
                return x === y || // Viva las JavaScriptas!
                "number" == typeof x && "number" == typeof y && isNaN(x) && isNaN(y);
            }; k < len; ) {
                if (areTheSame(arr[k], searchElement)) return !0;
                k++;
            }
            return !1;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return arrayIncludes;
        });
    }, 
    /* 13 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // byte-range
        /**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} maxPosition
 * @returns {Number}
 */
        function calculateRepeat(element, nextElement, maxPosition) {
            var segmentEnd, repeatCount = element.repeatCount;
            return 0 <= repeatCount ? repeatCount : (segmentEnd = null != nextElement ? nextElement.start : null != maxPosition ? maxPosition : Number.MAX_VALUE, 
            Math.ceil((segmentEnd - element.start) / element.duration) - 1);
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
                }
        /**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */        function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
            var start = segment.start, duration = segment.duration;
            return duration <= 0 ? start : start + (calculateRepeat(segment, nextSegment, maxPosition) + 1) * duration;
        }
        /**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */        function toIndexTime(time, indexOptions) {
            return time * indexOptions.timescale + indexOptions.indexTimeOffset;
        }
        /**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */        function fromIndexTime(time, indexOptions) {
            return (time - indexOptions.indexTimeOffset) / indexOptions.timescale;
        }
        /**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function getTimescaledRange(start, duration, timescale) {
            return [ start * timescale, (start + duration) * timescale ];
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return calculateRepeat;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getIndexSegmentEnd;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return toIndexTime;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return fromIndexTime;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTimescaledRange;
        });
    }, 
    /* 14 */ 
    /* 15 */
    /***/ , 
    /* 15 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return convertToRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return excludeFromRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getInnerAndOuterTimeRanges;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getLeftSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return getNextRangeGap;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return getPlayedSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return getRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return getSizeOfRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return insertInto;
        }), 
        /* unused harmony export isAfter */
        /* unused harmony export isBefore */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() {
            return isTimeInRange;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() {
            return keepRangeIntersection;
        });
        /* unused harmony export mergeContiguousRanges */
        /* unused harmony export removeEmptyRanges */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
        // Factor for rounding errors
        var EPSILON = 1 / 60;
        /**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */        function nearlyEqual(a, b) {
            return Math.abs(a - b) < EPSILON;
        }
        /**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */        function createRangeUnion(range1, range2) {
            return {
                start: Math.min(range1.start, range2.start),
                end: Math.max(range1.end, range2.end)
            };
        }
        /**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function removeEmptyRanges(ranges) {
            for (var index = 0; index < ranges.length; index++) {
                var range = ranges[index];
                range.start === range.end && ranges.splice(index++, 1);
            }
            return ranges;
        }
        /**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */        function mergeContiguousRanges(ranges) {
            for (var index = 1; index < ranges.length; index++) {
                var prevRange = ranges[index - 1], currRange = ranges[index];
                if (areRangesNearlyContiguous(prevRange, currRange)) {
                    var unionRange = createRangeUnion(prevRange, currRange);
                    ranges.splice(--index, 2, unionRange);
                }
            }
            return ranges;
        }
        /**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        
        /**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
        function isBefore(range1, range2) {
            return range1.end <= range2.start;
        }
        /**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */        function isTimeInRange(_ref, time) {
            var start = _ref.start, end = _ref.end;
            return start <= time && time < end;
        }
        /**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesOverlapping(range1, range2) {
            return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
        }
        /**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */        function areRangesNearlyContiguous(range1, range2) {
            return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
        }
        /**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */        function convertToRanges(timeRanges) {
            for (var ranges = [], i = 0; i < timeRanges.length; i++) ranges.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return ranges;
        }
        /**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */        function getRange(timeRanges, time) {
            for (var i = timeRanges.length - 1; 0 <= i; i--) {
                var start = timeRanges.start(i);
                if (start <= time) {
                    var end = timeRanges.end(i);
                    if (time < end) return {
                        start: start,
                        end: end
                    };
                }
            }
            return null;
        }
        /**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */        function getNextRangeGap(timeRanges, time) {
            for (var len = timeRanges.length, i = 0; i < len; i++) {
                var start = timeRanges.start(i);
                if (time < start) return start - time;
            }
            return Infinity;
        }
        /**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */        function getInnerAndOuterTimeRanges(timeRanges, time) {
            for (var innerRange = null, outerRanges = [], i = 0; i < timeRanges.length; i++) {
                var start = timeRanges.start(i), end = timeRanges.end(i);
                time < start || end <= time ? outerRanges.push({
                    start: start,
                    end: end
                }) : innerRange = {
                    start: start,
                    end: end
                };
            }
            return {
                outerRanges: outerRanges,
                innerRange: innerRange
            };
        }
        /**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - range.start : 0;
        }
        /**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getPlayedSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? currentTime - range.start : 0;
        }
        /**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */        function getLeftSizeOfRange(timeRanges, currentTime) {
            var range = getRange(timeRanges, currentTime);
            return range ? range.end - currentTime : Infinity;
        }
        /**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */        function insertInto(ranges, rangeToAddArg) {
            if (rangeToAddArg.start === rangeToAddArg.end) return ranges;
            for (var rangeToAdd = rangeToAddArg, index = 0 // For each present range check if we need to:
            // - In case we are overlapping or contiguous:
            //   - if added range has the same bitrate as the overlapped or
            //     contiguous one, we can merge themcurrentRange
            //   - if added range has a different bitrate we need to insert it
            //     in place
            // - Need to insert in place, we we are completely, not overlapping
            //   and not contiguous in between two ranges.
            ; index < ranges.length; index++) {
                var range = ranges[index], overlapping = areRangesOverlapping(rangeToAdd, range), contiguous = areRangesNearlyContiguous(rangeToAdd, range);
                // We assume ranges are ordered and two ranges can not be
                // completely overlapping.
                if (overlapping || contiguous) rangeToAdd = createRangeUnion(rangeToAdd, range), 
                ranges.splice(index--, 1); else 
                // Check the case for which there is no more to do
                if (0 === index) {
                    if (isBefore(rangeToAdd, ranges[0])) 
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                } else if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) 
                // We are exactly after the current previous range, and
                // before the current range, while not overlapping with none
                // of them. Insert here.
                break;
            }
 // Now that we are sure we don't overlap with any range, just add it.
                        return ranges.splice(index, 0, rangeToAdd), mergeContiguousRanges(removeEmptyRanges(ranges));
        }
        /**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */        function findOverlappingRanges(range, ranges) {
            for (var resultingRanges = [], i = 0; i < ranges.length; i++) areRangesOverlapping(range, ranges[i]) && resultingRanges.push(ranges[i]);
            return resultingRanges;
        }
        /**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */        function keepRangeIntersection(ranges1, ranges2) {
            for (var result = [], i = 0; i < ranges1.length; i++) {
                var range = ranges1[i], overlappingRanges = findOverlappingRanges(range, ranges2);
                if (overlappingRanges.length) for (var j = 0; j < overlappingRanges.length; j++) {
                    var overlappingRange = overlappingRanges[j];
                    result.push({
                        start: Math.max(range.start, overlappingRange.start),
                        end: Math.min(range.end, overlappingRange.end)
                    });
                }
            }
            return result;
        }
        /**
 * Exclude from the `baseRanges` everything that is in `rangesToExclude`.
 * Example:
 *
 * Let's say we have the following base ranges:
 *       |==========|        |===============| |======|    |==========|
 *
 * From which we want to "exclude" the following ranges:
 *          |=========| |==|        |===|  |=====|
 *
 * We will obtain the first ranges from which we remove the second ranges:
 * -----------------------------------------------------------------------
 *       |==========|        |===============| |======|    |==========|
 *          |=========| |==|        |===|  |=====|
 * _______________________________________________________________________
 *                                     |
 *                                     |
 *                                     V
 * -----------------------------------------------------------------------
 *       |==|                |======|   |==|     |====|    |==========|
 * -----------------------------------------------------------------------
 *
 * @param {Array.<Object} baseRanges
 * @param {Array.<Object} rangesToExclude
 * @return {Array.<Object>}
 */        function excludeFromRanges(baseRanges, rangesToExclude) {
            // For every range in `baseRanges`, find overlapping ranges with
            // `rangesToExclude` and remove them.
            for (var result = [], i = 0; i < baseRanges.length; i++) {
                var range = baseRanges[i], intersections = [], overlappingRanges = findOverlappingRanges(range, rangesToExclude);
                if (overlappingRanges.length) for (var j = 0; j < overlappingRanges.length; j++) {
                    var overlappingRange = overlappingRanges[j];
                    intersections.push({
                        start: Math.max(range.start, overlappingRange.start),
                        end: Math.min(range.end, overlappingRange.end)
                    });
                }
                if (0 === intersections.length) result.push(range); else for (var lastStart = range.start, _j = 0; _j < overlappingRanges.length; _j++) overlappingRanges[_j].start > lastStart && result.push({
                    start: lastStart,
                    end: overlappingRanges[_j].start
                }), lastStart = overlappingRanges[_j].end;
            }
            return result;
        }
        /***/    }, 
    /* 16 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(47), isObject = __webpack_require__(91), isFunction = __webpack_require__(54), UnsubscriptionError = /* */ function() {
            function UnsubscriptionErrorImpl(errors) {
                return Error.call(this), this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
                    return i + 1 + ") " + err.toString();
                }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = errors, this;
            }
            return UnsubscriptionErrorImpl.prototype = /* */ Object.create(Error.prototype), 
            UnsubscriptionErrorImpl;
        }();
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
                //# sourceMappingURL=UnsubscriptionError.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subscription_Subscription;
        });
        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
        var Subscription_Subscription = /* */ function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parentOrParents = null, this._subscriptions = null, unsubscribe && (this._unsubscribe = unsubscribe);
            }
            return Subscription.prototype.unsubscribe = function() {
                var errors;
                if (!this.closed) {
                    var _parentOrParents = this._parentOrParents, _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
                    if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, 
                    _parentOrParents instanceof Subscription) _parentOrParents.remove(this); else if (null !== _parentOrParents) for (var index = 0; index < _parentOrParents.length; ++index) {
                        _parentOrParents[index].remove(this);
                    }
                    if (Object(isFunction.a)(_unsubscribe)) try {
                        _unsubscribe.call(this);
                    } catch (e) {
                        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [ e ];
                    }
                    if (Object(isArray.a)(_subscriptions)) {
                        index = -1;
                        for (var len = _subscriptions.length; ++index < len; ) {
                            var sub = _subscriptions[index];
                            if (Object(isObject.a)(sub)) try {
                                sub.unsubscribe();
                            } catch (e) {
                                errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e);
                            }
                        }
                    }
                    if (errors) throw new UnsubscriptionError(errors);
                }
            }, Subscription.prototype.add = function(teardown) {
                var subscription = teardown;
                if (!teardown) return Subscription.EMPTY;
                switch (typeof teardown) {
                  case "function":
                    subscription = new Subscription(teardown);

                  case "object":
                    if (subscription === this || subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                    if (this.closed) return subscription.unsubscribe(), subscription;
                    if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        (subscription = new Subscription())._subscriptions = [ tmp ];
                    }
                    break;

                  default:
                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                }
                var _parentOrParents = subscription._parentOrParents;
                if (null === _parentOrParents) subscription._parentOrParents = this; else if (_parentOrParents instanceof Subscription) {
                    if (_parentOrParents === this) return subscription;
                    subscription._parentOrParents = [ _parentOrParents, this ];
                } else {
                    if (-1 !== _parentOrParents.indexOf(this)) return subscription;
                    _parentOrParents.push(this);
                }
                var subscriptions = this._subscriptions;
                return null === subscriptions ? this._subscriptions = [ subscription ] : subscriptions.push(subscription), 
                subscription;
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription);
                    -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                }
            }, Subscription.EMPTY = function(empty) {
                return empty.closed = !0, empty;
            }(new Subscription()), Subscription;
        }();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce(function(errs, err) {
                return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
            }, []);
        }
        //# sourceMappingURL=Subscription.js.map
        /***/    }, 
    /* 17 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
        /* harmony import */        
        /* harmony default export */ __webpack_exports__.a = 
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function castToObservable(value) {
            if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__.a) return value;
            if (value && "function" == typeof value.subscribe) {
                var valObsLike = value;
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                    var sub = valObsLike.subscribe(function(val) {
                        obs.next(val);
                    }, function(err) {
                        obs.error(err);
                    }, function() {
                        obs.complete();
                    });
                    return function() {
                        sub && sub.dispose ? sub.dispose() : sub && sub.unsubscribe && sub.unsubscribe();
                    };
                });
            }
            return value && "function" == typeof value.then ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(value) : Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(value);
        };
    }, 
    /* 18 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(8), config = __webpack_require__(3), request_error = __webpack_require__(127), DEFAULT_REQUEST_TIMEOUT = config.a.DEFAULT_REQUEST_TIMEOUT;
        // EXTERNAL MODULE: ./src/config.ts
                /**
 * @param {string} data
 * @returns {Object|null}
 */
        function toJSONForIE(data) {
            try {
                return JSON.parse(data);
            } catch (e) {
                return null;
            }
        }
        function request_xhr(options) {
            var requestOptions = {
                url: options.url,
                headers: options.headers,
                responseType: null == options.responseType ? "json" : options.responseType,
                timeout: null == options.timeout ? DEFAULT_REQUEST_TIMEOUT : options.timeout
            };
            return new Observable.a(function(obs) {
                var url = requestOptions.url, headers = requestOptions.headers, responseType = requestOptions.responseType, timeout = requestOptions.timeout, xhr = new XMLHttpRequest();
                if (xhr.open("GET", url, !0), 0 <= timeout && (xhr.timeout = timeout), xhr.responseType = responseType, 
                "document" === xhr.responseType && xhr.overrideMimeType("text/xml"), headers) {
                    var _headers = headers;
                    for (var key in _headers) _headers.hasOwnProperty(key) && xhr.setRequestHeader(key, _headers[key]);
                }
                var sendingTime = performance.now();
                return xhr.onerror = function onXHRError() {
                    obs.error(new request_error.a(url, xhr.status, "ERROR_EVENT", xhr));
                }, xhr.ontimeout = function onXHRTimeout() {
                    obs.error(new request_error.a(url, xhr.status, "TIMEOUT", xhr));
                }, !0 === options.sendProgressEvents && (xhr.onprogress = function onXHRProgress(event) {
                    var currentTime = performance.now();
                    obs.next({
                        type: "progress",
                        value: {
                            url: url,
                            duration: currentTime - sendingTime,
                            sendingTime: sendingTime,
                            currentTime: currentTime,
                            size: event.loaded,
                            totalSize: event.total
                        }
                    });
                }), xhr.onload = function onXHRLoad(event) {
                    if (4 === xhr.readyState) if (200 <= xhr.status && xhr.status < 300) {
                        var responseData, receivedTime = performance.now(), totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total, status = xhr.status, loadedResponseType = xhr.responseType, _url = xhr.responseURL || url;
                        if (null == (
                        // IE bug where response is string with responseType json
                        responseData = "json" === loadedResponseType ? "string" !== xhr.response ? xhr.response : toJSONForIE(xhr.responseText) : xhr.response)) return void obs.error(new request_error.a(url, xhr.status, "PARSE_ERROR", xhr));
                        obs.next({
                            type: "data-loaded",
                            value: {
                                status: status,
                                url: _url,
                                responseType: loadedResponseType,
                                sendingTime: sendingTime,
                                receivedTime: receivedTime,
                                duration: receivedTime - sendingTime,
                                size: totalSize,
                                responseData: responseData
                            }
                        }), obs.complete();
                    } else obs.error(new request_error.a(url, xhr.status, "ERROR_HTTP_CODE", xhr));
                }, xhr.send(), function() {
                    xhr && 4 !== xhr.readyState && xhr.abort();
                };
            });
        }
        /* harmony default export */        __webpack_exports__.a = request_xhr;
        // CONCATENATED MODULE: ./src/utils/request/index.ts
        /* unused concated harmony import xhr */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */    }, 
    /* 19 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return warnOnce;
        });
        /* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12), WARNED_MESSAGES = [];
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */
        function warnOnce(message) {
            Object(_array_includes__WEBPACK_IMPORTED_MODULE_0__.a)(WARNED_MESSAGES, message) || (
            /* tslint:disable no-console */
            console.warn(message), 
            /* tslint:enable no-console */
            WARNED_MESSAGES.push(message));
        }
        /***/    }, 
    /* 20 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return isIE11;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isIEOrEdge;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFirefox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isSafari;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return isSamsungBrowser;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // true on IE11
        // false on Edge and other IEs/browsers.
        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode, isIEOrEdge = "Microsoft Internet Explorer" === navigator.appName || "Netscape" === navigator.appName && /(Trident|Edge)\//.test(navigator.userAgent), isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), isSamsungBrowser = /SamsungBrowser/.test(navigator.userAgent), isSafari = /Safari/i.test(navigator.userAgent);
 // true for IE / Edge
        }, 
    /* 21 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return REGXP_PERCENT_VALUES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return REGXP_TIME_COLON;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return REGXP_TIME_COLON_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() {
            return REGXP_TIME_COLON_MS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() {
            return REGXP_TIME_FRAMES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() {
            return REGXP_TIME_HMS;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() {
            return REGXP_TIME_TICK;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return REGXP_4_HEX_COLOR;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return REGXP_8_HEX_COLOR;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
        var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/, REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/, REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/, REGXP_TIME_TICK = /^(\d*\.?\d*)t$/, REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/, REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/, REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/, REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
 // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
        }, 
    /* 22 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return HTMLElement_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return MediaKeys_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return MediaSource_;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return READY_STATES;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() {
            return VTTCue_;
        });
        /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53), _should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92), win = window, HTMLElement_ = win.HTMLElement, VTTCue_ = win.VTTCue || win.TextTrackCue, MediaSource_ = win.MediaSource || win.MozMediaSource || win.WebKitMediaSource || win.MSMediaSource, MediaKeys_ = function() {
            return Object(_should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_1__.a)() ? win.WebKitMediaKeys : win.MediaKeys || win.MSMediaKeys || win.MozMediaKeys || win.WebKitMediaKeys || 
            /* */
            function() {
                return function _class() {
                    function noMediaKeys() {
                        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found in the current browser.");
                    }
                    this.create = noMediaKeys, this.createSession = noMediaKeys, this.isTypeSupported = noMediaKeys, 
                    this.setServerCertificate = noMediaKeys;
                };
            }();
        }(), READY_STATES = {
            HAVE_NOTHING: 0,
            HAVE_METADATA: 1,
            HAVE_CURRENT_DATA: 2,
            HAVE_FUTURE_DATA: 3,
            HAVE_ENOUGH_DATA: 4
        };
        /* harmony import */    }, 
    /* 23 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return of;
        });
        /* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62), _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
        /* harmony import */        
        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
        function of() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            var scheduler = args[args.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? (args.pop(), 
            Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(args, scheduler)) : Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args);
        }
        //# sourceMappingURL=of.js.map
        /***/    }, 
    /* 24 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToResult;
        });
        /* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49), _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118), _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
        /* harmony import */        
        /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
            if (void 0 === destination && (destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.a(outerSubscriber, outerValue, outerIndex)), 
            !destination.closed) return result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.a ? result.subscribe(destination) : Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.a)(result)(destination);
        }
        //# sourceMappingURL=subscribeToResult.js.map
        /***/    }, 
    /* 25 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OuterSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), OuterSubscriber = /* */ function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error);
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete();
            }, OuterSubscriber;
        }(__webpack_require__(7).a);
        /* harmony import */    }, 
    /* 26 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct a "loaded" event.
 * @returns {Object}
 */        var INIT_EVENTS = {
            loaded: function loaded() {
                return {
                    type: "loaded",
                    value: !0
                };
            }
            /**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */ ,
            manifestReady: 
            /**
 * Construct a "manifestReady" event.
 * @param {Object} abrManager
 * @param {Object} manifest
 * @returns {Object}
 */
            function manifestReady(manifest) {
                return {
                    type: "manifestReady",
                    value: {
                        manifest: manifest
                    }
                };
            }
            /**
 * Construct a "speedChanged" event.
 * @param {Number} speed
 * @returns {Object}
 */ ,
            nullRepresentation: 
            /**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */
            function nullRepresentation(type, period) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        representation: null,
                        period: period
                    }
                };
            }
            /**
 * Construct a "warning" event.
 * @param {Error} value
 * @returns {Object}
 */ ,
            reloadingMediaSource: function reloadingMediaSource() {
                return {
                    type: "reloading-media-source",
                    value: void 0
                };
            },
            speedChanged: function speedChanged(speed) {
                return {
                    type: "speedChanged",
                    value: speed
                };
            },
            stalled: function stalled(stalling) {
                return {
                    type: "stalled",
                    value: stalling
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        };
        /* harmony default export */        __webpack_exports__.a = INIT_EVENTS;
    }, 
    /* 27 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert given buffer to a 32bit integer hash
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
        function hashBuffer(buffer) {
            for (var hash = 0, i = 0; i < buffer.length; i++) hash = (hash << 5) - hash + buffer[i], 
            hash &= hash;
            return hash;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hashBuffer;
        });
    }, 
    /* 28 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */
        /* tslint:disable:no-empty */
        /* harmony default export */        __webpack_exports__.a = function() {};
    }, 
    /* 29 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var pinkie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(159), pinkie__WEBPACK_IMPORTED_MODULE_0___default = /* */ __webpack_require__.n(pinkie__WEBPACK_IMPORTED_MODULE_0__);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ __webpack_exports__.a = "function" == typeof Promise ? Promise : pinkie__WEBPACK_IMPORTED_MODULE_0___default.a;
    }, 
    /* 30 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(9), array_includes = __webpack_require__(12);
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                // CONCATENATED MODULE: ./src/utils/starts_with.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
        function startsWith(completeString, searchString, position) {
            /* tslint:disable no-unbound-method */
            if ("function" == typeof String.prototype.startsWith) 
            /* tslint:enable no-unbound-method */
            /* tslint:disable ban */
            return completeString.startsWith(searchString, position);
            /* tslint:enable ban */            var initialPosition = "number" == typeof position ? Math.max(position, 0) : 0;
            return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
        function getStylingAttributes(attributes, nodes, styles, regions) {
            for (var currentStyle = {}, leftAttributes = attributes.slice(), i = 0; i <= nodes.length - 1; i++) {
                var node = nodes[i];
                if (node) {
                    var _ret = function() {
                        var styleID = void 0, regionID = void 0;
                        // 1. the style is directly set on a "tts:" attribute
                        if (node.nodeType === Node.ELEMENT_NODE) for (var element = node, j = 0; j <= element.attributes.length - 1; j++) {
                            var attribute = element.attributes[j], name = attribute.name;
                            if ("style" === name) styleID = attribute.value; else if ("region" === name) regionID = attribute.value; else {
                                var nameWithoutTTS = name.substring(4);
                                if (Object(array_includes.a)(leftAttributes, nameWithoutTTS) && (currentStyle[nameWithoutTTS] = attribute.value, 
                                leftAttributes.splice(j, 1), !leftAttributes.length)) return {
                                    v: currentStyle
                                };
                            }
                        }
 // 2. the style is referenced on a "style" attribute
                                                if (styleID) {
                            var style = Object(array_find.a)(styles, function(x) {
                                return x.id === styleID;
                            });
                            if (style) for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
                                var _attribute = leftAttributes[_j];
                                if (!currentStyle[_attribute] && style.style[_attribute]) {
                                    if (currentStyle[_attribute] = style.style[_attribute], leftAttributes.splice(_j, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j--;
                                }
                            }
                        }
 // 3. the node reference a region (which can have a value for the
                        //    corresponding style)
                                                if (regionID) {
                            var region = Object(array_find.a)(regions, function(x) {
                                return x.id === regionID;
                            });
                            if (region) for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
                                var _attribute2 = leftAttributes[_j2];
                                if (!currentStyle[_attribute2] && region.style[_attribute2]) {
                                    if (currentStyle[_attribute2] = region.style[_attribute2], leftAttributes.splice(_j2, 1), 
                                    !leftAttributes.length) return {
                                        v: currentStyle
                                    };
                                    _j2--;
                                }
                            }
                        }
                    }();
                    if ("object" == typeof _ret) return _ret.v;
                }
            }
            return currentStyle;
        }
        /**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */        function getStylingFromElement(node) {
            if (node.nodeType !== Node.ELEMENT_NODE) return {};
            for (var element = node, currentStyle = {}, i = 0; i <= element.attributes.length - 1; i++) {
                var styleAttribute = element.attributes[i];
                if (startsWith(styleAttribute.name, "tts")) currentStyle[styleAttribute.name.substring(4)] = styleAttribute.value;
            }
            return currentStyle;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStylingAttributes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getStylingFromElement;
        });
    }, 
    /* 31 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return assert;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return assertInterface;
        });
        /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(206);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */        function assert(assertion, message) {
            if (!assertion) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a(message || "invalid assertion");
        }
        /**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */        function assertInterface(o, iface, name) {
            for (var k in void 0 === name && (name = "object"), assert(null != o, name + " should be an object"), 
            iface) iface.hasOwnProperty(k) && 
            /* tslint:disable:max-line-length */
            assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
        }
        /***/    }, 
    /* 32 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryCatch;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */        function tryCatch(func, args) {
            try {
                return func(args);
            } catch (e) {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(e);
            }
        }
        /***/    }, 
    /* 33 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return ErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return NetworkErrorTypes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ErrorCodes;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var ErrorTypes = {
            NETWORK_ERROR: "NETWORK_ERROR",
            MEDIA_ERROR: "MEDIA_ERROR",
            ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
            OTHER_ERROR: "OTHER_ERROR"
        }, NetworkErrorTypes = {
            TIMEOUT: "TIMEOUT",
            ERROR_EVENT: "ERROR_EVENT",
            ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
            PARSE_ERROR: "PARSE_ERROR"
        }, ErrorCodes = {
            PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
            PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
            INTEGRITY_ERROR: "INTEGRITY_ERROR",
            MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
            MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
            MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
            MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
            MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
            MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
            MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
            CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
            KEY_ERROR: "KEY_ERROR",
            KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
            KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
            KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
            KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
            KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
            INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
            INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
            INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
            LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
            MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
            BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
            BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
            BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
            MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
            MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
            MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
            MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
            MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
            MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
            MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
            MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
            MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
            MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
            NONE: "NONE"
        };
    }, 
    /* 34 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return map;
        });
        /* unused harmony export MapOperator */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function map(project, thisArg) {
            return function mapOperation(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        var MapOperator = /* */ function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            }, MapOperator;
        }(), MapSubscriber = /* */ function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, MapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 35 */ 
    /* 36 */
    /***/ , 
    /* 36 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Store the MediaKeys infos attached to a media element.
                var currentMediaState = new WeakMap();
        /* harmony default export */        __webpack_exports__.a = {
            /**
   * Update MediaKeys infos set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} state
   */
            setState: function setState(mediaElement, state) {
                currentMediaState.set(mediaElement, state);
            },
            /**
   * Get MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @returns {Object}
   */
            getState: function getState(mediaElement) {
                return currentMediaState.get(mediaElement) || null;
            },
            /**
   * Remove MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   */
            clearState: function clearState(mediaElement) {
                currentMediaState.set(mediaElement, null);
            }
        };
    }, 
    /* 37 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return resolveURL;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeBaseURL;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Scheme part of an url (e.g. "http://").
        var schemeRe = /^(?:[a-z]+:)?\/\//i, selfDirRe = /\/\.{1,2}\//;
 // Captures "/../" or "/./".
                /**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
        function _normalizeUrl(url) {
            // fast path if no ./ or ../ are present in the url
            if (!selfDirRe.test(url)) return url;
            for (var newUrl = [], oldUrl = url.split("/"), i = 0, l = oldUrl.length; i < l; i++) if (".." === oldUrl[i]) newUrl.pop(); else {
                if ("." === oldUrl[i]) continue;
                newUrl.push(oldUrl[i]);
            }
            return newUrl.join("/");
        }
        /**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */        function resolveURL() {
            var len = arguments.length;
            if (0 === len) return "";
            for (var base = "", i = 0; i < len; i++) {
                var part = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                "string" == typeof part && "" !== part && (base = schemeRe.test(part) ? part : (
                // trim if begins with "/"
                "/" === part[0] && (part = part.substring(1)), // trim if ends with "/"
                "/" === base[base.length - 1] && (base = base.substring(0, base.length - 1)), base + "/" + part));
            }
            return _normalizeUrl(base);
        }
        /**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */        function normalizeBaseURL(url) {
            var slash = url.lastIndexOf("/");
            return 0 <= slash ? url.substring(0, slash + 1) : url;
        }
        /***/    }, 
    /* 38 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EventEmitter;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return fromEvent;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), EventEmitter = 
        /* */
        function() {
            function EventEmitter() {
                this._listeners = {};
            }
            /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */            var _proto = EventEmitter.prototype;
            return _proto.addEventListener = function addEventListener(evt, fn) {
                var listeners = this._listeners[evt];
                listeners ? listeners.push(fn) : this._listeners[evt] = [ fn ];
            }
            /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */ , _proto.removeEventListener = function removeEventListener(evt, fn) {
                if (null != evt) {
                    var listeners = this._listeners[evt];
                    if (listeners) if (null != fn) {
                        var index = listeners.indexOf(fn);
                        ~index && listeners.splice(index, 1), listeners.length || delete this._listeners[evt];
                    } else delete this._listeners[evt];
                } else this._listeners = {};
            }
            /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */ , _proto.trigger = function trigger(evt, arg) {
                var listeners = this._listeners[evt];
                listeners && listeners.slice().forEach(function(listener) {
                    try {
                        listener(arg);
                    } catch (e) {
                        _log__WEBPACK_IMPORTED_MODULE_1__.a.error(e, e.stack);
                    }
                });
            }, EventEmitter;
        }();
        /* harmony import */        
        /**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */
        function fromEvent(target, eventName) {
            return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                function handler(event) {
                    obs.next(event);
                }
                return target.addEventListener(eventName, handler), function() {
                    target.removeEventListener(eventName, handler);
                };
            });
        }
        /***/    }, 
    /* 39 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return config;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var _enable_super_gross_mode_that_will_cause_bad_things = !1, config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                value && /* */ new Error().stack;
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
    }, 
    /* 40 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return async;
        });
        /* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78), async = /* */ new (__webpack_require__(77).a)(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.a);
        /* harmony import */    }, 
    /* 41 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return SubjectSubscriber;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return Subject;
        });
        /* unused harmony export AnonymousSubject */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8), _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7), _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16), _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51), _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(66), SubjectSubscriber = /* */ function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscriber, _super), SubjectSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.a), Subject = /* */ function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, 
                _this.thrownError = null, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subject, _super), Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__.a] = function() {
                return new SubjectSubscriber(this);
            }, Subject.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                return subject.operator = operator, subject;
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                if (!this.isStopped) for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value);
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0;
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0;
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null;
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return _super.prototype._trySubscribe.call(this, subscriber);
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a();
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : this.isStopped ? (subscriber.complete(), 
                _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : (this.observers.push(subscriber), 
                new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.a(this, subscriber));
            }, Subject.prototype.asObservable = function() {
                var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__.a();
                return observable.source = this, observable;
            }, Subject.create = function(destination, source) {
                return new AnonymousSubject(destination, source);
            }, Subject;
        }(_Observable__WEBPACK_IMPORTED_MODULE_1__.a), AnonymousSubject = /* */ function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value);
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err);
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete();
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY;
            }, AnonymousSubject;
        }(Subject);
        /* harmony import */    }, 
    /* 42 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
        function byteRange(_ref) {
            var start = _ref[0], end = _ref[1];
            return Infinity === end ? "bytes=" + +start + "-" : "bytes=" + +start + "-" + +end;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return byteRange;
        });
    }, 
    /* 43 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function noop() {}
        //# sourceMappingURL=noop.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return noop;
        });
    }, 
    /* 44 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMap;
        });
        /* unused harmony export MergeMapOperator */
        /* unused harmony export MergeMapSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
        function mergeMap(project, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
                return source.pipe(mergeMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }, concurrent));
            } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
                return source.lift(new MergeMapOperator(project, concurrent));
            });
        }
        var MergeMapOperator = /* */ function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, 
                this.concurrent = concurrent;
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            }, MergeMapOperator;
        }(), MergeMapSubscriber = /* */ function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, 
                _this.buffer = [], _this.active = 0, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }, MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a)(this, ish, value, index, innerSubscriber);
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), 
                this.unsubscribe();
            }, MergeMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
                var buffer = this.buffer;
                this.remove(innerSub), this.active--, 0 < buffer.length ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }, MergeMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a);
    }, 
    /* 45 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        //# sourceMappingURL=isScheduler.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isScheduler;
        });
    }, 
    /* 46 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
        var fromEvent = __webpack_require__(204), Observable = __webpack_require__(8), noop = __webpack_require__(43), NEVER = /* */ new Observable.a(noop.a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                //# sourceMappingURL=never.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(81), defer = __webpack_require__(82), of = __webpack_require__(23), combineLatest = __webpack_require__(213), interval = __webpack_require__(214), map = __webpack_require__(34), startWith = __webpack_require__(205), distinctUntilChanged = __webpack_require__(164), switchMap = __webpack_require__(125), tslib_es6 = __webpack_require__(2), scheduler_async = __webpack_require__(40), isDate = __webpack_require__(97), Subscriber = __webpack_require__(7), Notification = __webpack_require__(70);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/delay.js
        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
        function delay_delay(delay, scheduler) {
            void 0 === scheduler && (scheduler = scheduler_async.a);
            var delayFor = Object(isDate.a)(delay) ? +delay - scheduler.now() : Math.abs(delay);
            return function(source) {
                return source.lift(new DelayOperator(delayFor, scheduler));
            };
        }
        var DelayOperator = /* */ function() {
            function DelayOperator(delay, scheduler) {
                this.delay = delay, this.scheduler = scheduler;
            }
            return DelayOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new delay_DelaySubscriber(subscriber, this.delay, this.scheduler));
            }, DelayOperator;
        }(), delay_DelaySubscriber = /* */ function(_super) {
            function DelaySubscriber(destination, delay, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.delay = delay, _this.scheduler = scheduler, _this.queue = [], _this.active = !1, 
                _this.errored = !1, _this;
            }
            return tslib_es6.a(DelaySubscriber, _super), DelaySubscriber.dispatch = function(state) {
                for (var source = state.source, queue = source.queue, scheduler = state.scheduler, destination = state.destination; 0 < queue.length && queue[0].time - scheduler.now() <= 0; ) queue.shift().notification.observe(destination);
                if (0 < queue.length) {
                    var delay_1 = Math.max(0, queue[0].time - scheduler.now());
                    this.schedule(state, delay_1);
                } else this.unsubscribe(), source.active = !1;
            }, DelaySubscriber.prototype._schedule = function(scheduler) {
                this.active = !0, this.destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
                    source: this,
                    destination: this.destination,
                    scheduler: scheduler
                }));
            }, DelaySubscriber.prototype.scheduleNotification = function(notification) {
                if (!0 !== this.errored) {
                    var scheduler = this.scheduler, message = new DelayMessage(scheduler.now() + this.delay, notification);
                    this.queue.push(message), !1 === this.active && this._schedule(scheduler);
                }
            }, DelaySubscriber.prototype._next = function(value) {
                this.scheduleNotification(Notification.a.createNext(value));
            }, DelaySubscriber.prototype._error = function(err) {
                this.errored = !0, this.queue = [], this.destination.error(err), this.unsubscribe();
            }, DelaySubscriber.prototype._complete = function() {
                this.scheduleNotification(Notification.a.createComplete()), this.unsubscribe();
            }, DelaySubscriber;
        }(Subscriber.a), DelayMessage = /* */ function() {
            return function DelayMessage(time, notification) {
                this.time = time, this.notification = notification;
            };
        }(), mapTo = __webpack_require__(165), OuterSubscriber = __webpack_require__(25), subscribeToResult = __webpack_require__(24), defaultThrottleConfig = {
            leading: !0,
            trailing: !1
        };
        OuterSubscriber.a;
        //# sourceMappingURL=throttle.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttleTime.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
        function throttleTime(duration, scheduler, config) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), void 0 === config && (config = defaultThrottleConfig), 
            function(source) {
                return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
            };
        }
        var ThrottleTimeOperator = /* */ function() {
            function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
                this.duration = duration, this.scheduler = scheduler, this.leading = leading, this.trailing = trailing;
            }
            return ThrottleTimeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new throttleTime_ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
            }, ThrottleTimeOperator;
        }(), throttleTime_ThrottleTimeSubscriber = /* */ function(_super) {
            function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
                var _this = _super.call(this, destination) || this;
                return _this.duration = duration, _this.scheduler = scheduler, _this.leading = leading, 
                _this.trailing = trailing, _this._hasTrailingValue = !1, _this._trailingValue = null, 
                _this;
            }
            return tslib_es6.a(ThrottleTimeSubscriber, _super), ThrottleTimeSubscriber.prototype._next = function(value) {
                this.throttled ? this.trailing && (this._trailingValue = value, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
                    subscriber: this
                })), this.leading ? this.destination.next(value) : this.trailing && (this._trailingValue = value, 
                this._hasTrailingValue = !0));
            }, ThrottleTimeSubscriber.prototype._complete = function() {
                this._hasTrailingValue && this.destination.next(this._trailingValue), this.destination.complete();
            }, ThrottleTimeSubscriber.prototype.clearThrottle = function() {
                var throttled = this.throttled;
                throttled && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), 
                this._trailingValue = null, this._hasTrailingValue = !1), throttled.unsubscribe(), 
                this.remove(throttled), this.throttled = null);
            }, ThrottleTimeSubscriber;
        }(Subscriber.a);
        function dispatchNext(arg) {
            arg.subscriber.clearThrottle();
        }
        //# sourceMappingURL=throttleTime.js.map
        // EXTERNAL MODULE: ./src/config.ts
                var src_config = __webpack_require__(3), browser_compatibility_types = __webpack_require__(22);
        // EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
                // CONCATENATED MODULE: ./src/compat/event_listeners.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onPictureInPictureEvent$", function() {
            return onPictureInPictureEvent$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActive", function() {
            return isActive;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVideoVisible", function() {
            return isVideoVisible;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "videoWidth$", function() {
            return videoWidth$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onPlayPause$", function() {
            return event_listeners_onPlayPause$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onTextTrackChanges$", function() {
            return event_listeners_onTextTrackChanges$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onLoadedMetadata$", function() {
            return onLoadedMetadata$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSeeking$", function() {
            return onSeeking$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSeeked$", function() {
            return onSeeked$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onEnded$", function() {
            return onEnded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onTimeUpdate$", function() {
            return onTimeUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFullscreenChange$", function() {
            return onFullscreenChange$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSourceOpen$", function() {
            return onSourceOpen$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onUpdate$", function() {
            return onUpdate$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onRemoveSourceBuffers$", function() {
            return onRemoveSourceBuffers$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onEncrypted$", function() {
            return onEncrypted$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyMessage$", function() {
            return onKeyMessage$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyAdded$", function() {
            return onKeyAdded$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyError$", function() {
            return onKeyError$;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onKeyStatusesChange$", function() {
            return onKeyStatusesChange$;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
        var BROWSER_PREFIXES = [ "", "webkit", "moz", "ms" ], INACTIVITY_DELAY = src_config.a.INACTIVITY_DELAY, pixelRatio = window.devicePixelRatio || 1;
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
        function isEventSupported(element, eventNameSuffix) {
            var clone = document.createElement(element.tagName), eventName = "on" + eventNameSuffix;
            return eventName in clone || (clone.setAttribute(eventName, "return;"), "function" == typeof clone[eventName]);
        }
        /**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */        function findSupportedEvent(element, eventNames) {
            return eventNames.filter(function(name) {
                return isEventSupported(element, name);
            })[0];
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */        function eventPrefixed(eventNames, prefixes) {
            return eventNames.reduce(function(parent, name) {
                return parent.concat((prefixes || BROWSER_PREFIXES).map(function(p) {
                    return p + name;
                }));
            }, []);
        }
        /**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */        function compatibleListener(eventNames, prefixes) {
            var mem, prefixedEvents = eventPrefixed(eventNames, prefixes);
            return function(element) {
                // if the element is a HTMLElement we can detect
                // the supported event, and memoize it in `mem`
                return element instanceof browser_compatibility_types.a ? (void 0 === mem && (mem = findSupportedEvent(element, prefixedEvents)), 
                mem ? Object(fromEvent.a)(element, mem) : NEVER) : merge.a.apply(void 0, prefixedEvents.map(function(eventName) {
                    return Object(fromEvent.a)(element, eventName);
                }));
 // otherwise, we need to listen to all the events
                // and merge them into one observable sequence
                        };
        }
        /**
 * Returns an observable:
 *   - emitting true when the document is visible
 *   - emitting false when the document is hidden
 * @returns {Observable}
 */        function visibilityChange() {
            var prefix, doc = document;
            null != doc.hidden ? prefix = "" : null != doc.mozHidden ? prefix = "moz" : null != doc.msHidden ? prefix = "ms" : null != doc.webkitHidden && (prefix = "webkit");
            var hidden = prefix ? prefix + "Hidden" : "hidden", visibilityChangeEvent = prefix ? prefix + "visibilitychange" : "visibilitychange";
            return Object(defer.a)(function() {
                var isHidden = document[hidden];
                return Object(fromEvent.a)(document, visibilityChangeEvent).pipe(Object(map.a)(function() {
                    return !document[hidden];
                }), Object(startWith.a)(!isHidden), Object(distinctUntilChanged.a)());
            });
        }
        /**
 * @returns {Observable}
 */        function videoSizeChange() {
            return Object(fromEvent.a)(window, "resize");
        }
        /**
 * Emit `true` if the page is considered active.
 * `false` when considered inactive.
 * Emit the original value on subscription.
 * @returns {Observable}
 */        function isActive() {
            return visibilityChange().pipe(Object(switchMap.a)(function(x) {
                return x ? Object(of.a)(x) : Object(of.a)(x).pipe(delay_delay(INACTIVITY_DELAY));
            }));
        }
        /**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */        function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
            var width = pipWindow.width, calcWidth = pipWindow.height / (mediaElement.clientHeight / mediaElement.clientWidth);
            return Math.min(width, calcWidth);
        }
        /**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function onPictureInPictureEvent$(mediaElement) {
            return Object(defer.a)(function() {
                if (mediaElement.webkitSupportsPresentationMode && "function" == typeof mediaElement.webkitSetPresentationMode) {
                    var isWebKitPIPEnabled = "picture-in-picture" === mediaElement.webkitPresentationMode;
                    return Object(fromEvent.a)(mediaElement, "webkitpresentationmodechanged").pipe(Object(map.a)(function() {
                        return {
                            isEnabled: "picture-in-picture" === mediaElement.webkitPresentationMode,
                            pipWindow: null
                        };
                    }), Object(startWith.a)({
                        isEnabled: isWebKitPIPEnabled,
                        pipWindow: null
                    }));
                }
                var initialState = {
                    isEnabled: document.pictureInPictureElement && document.pictureInPictureElement === mediaElement,
                    pipWindow: null
                };
                return Object(merge.a)(Object(fromEvent.a)(mediaElement, "enterpictureinpicture").pipe(Object(map.a)(function(evt) {
                    return {
                        isEnabled: !0,
                        pipWindow: evt.pictureInPictureWindow
                    };
                })), Object(fromEvent.a)(mediaElement, "leavepictureinpicture").pipe(Object(mapTo.a)({
                    isEnabled: !1,
                    pipWindow: null
                }))).pipe(Object(startWith.a)(initialState));
            });
        }
        /**
 * Returns `true` when video is considered as visible (the page is visible and/or
 * the Picture-In-Picture is activated). Returns `false` otherwise.
 * @param {Observable} pip$
 * @returns {Observable}
 */        function isVideoVisible(pip$) {
            return Object(combineLatest.a)([ visibilityChange(), pip$ ]).pipe(Object(switchMap.a)(function(_ref) {
                var isVisible = _ref[0];
                return _ref[1].isEnabled || isVisible ? Object(of.a)(!0) : Object(of.a)(!1).pipe(delay_delay(INACTIVITY_DELAY));
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function videoWidth$(mediaElement, pip$) {
            return Object(combineLatest.a)([ pip$, Object(interval.a)(2e4).pipe(Object(startWith.a)(null)), videoSizeChange().pipe(throttleTime(500), Object(startWith.a)(null)) ]).pipe(Object(switchMap.a)(function(_ref2) {
                var pip = _ref2[0];
                if (pip.isEnabled) {
                    if (null == pip.pipWindow) return Object(of.a)(Infinity);
                    var pipWindow = pip.pipWindow, firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow);
                    // RxJS typing issue (for the "as any")
                    return Object(fromEvent.a)(pipWindow, "resize").pipe(Object(startWith.a)(firstWidth * pixelRatio), Object(map.a)(function() {
                        return getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio;
                    }));
                }
                return Object(of.a)(mediaElement.clientWidth * pixelRatio);
            }), Object(distinctUntilChanged.a)());
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        var onLoadedMetadata$ = compatibleListener([ "loadedmetadata" ]), onSeeking$ = compatibleListener([ "seeking" ]), onSeeked$ = compatibleListener([ "seeked" ]), onEnded$ = compatibleListener([ "ended" ]), onTimeUpdate$ = compatibleListener([ "timeupdate" ]), onFullscreenChange$ = compatibleListener([ "fullscreenchange", "FullscreenChange" ], // On IE11, fullscreen change events is called MSFullscreenChange
        BROWSER_PREFIXES.concat("MS")), event_listeners_onPlayPause$ = function onPlayPause$(mediaElement) {
            return Object(merge.a)(compatibleListener([ "play" ])(mediaElement), compatibleListener([ "pause" ])(mediaElement));
        }, event_listeners_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
            return Object(merge.a)(compatibleListener([ "addtrack" ])(textTrackList), compatibleListener([ "removetrack" ])(textTrackList));
        }, onSourceOpen$ = compatibleListener([ "sourceopen", "webkitsourceopen" ]), onUpdate$ = compatibleListener([ "update" ]), onRemoveSourceBuffers$ = compatibleListener([ "onremovesourcebuffer" ]), onEncrypted$ = compatibleListener([ "encrypted", "needkey" ]), onKeyMessage$ = compatibleListener([ "keymessage", "message" ]), onKeyAdded$ = compatibleListener([ "keyadded", "ready" ]), onKeyError$ = compatibleListener([ "keyerror", "error" ]), onKeyStatusesChange$ = compatibleListener([ "keystatuseschange" ]);
        /**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */    }, 
    /* 47 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArray = /* */ function() {
            return Array.isArray || function(x) {
                return x && "number" == typeof x.length;
            };
        }();
        //# sourceMappingURL=isArray.js.map
        /***/    }, 
    /* 48 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return observable;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var observable = /* */ function() {
            return "function" == typeof Symbol && Symbol.observable || "@@observable";
        }();
        //# sourceMappingURL=observable.js.map
        /***/    }, 
    /* 49 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return InnerSubscriber;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), InnerSubscriber = /* */ function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, 
                _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }, InnerSubscriber;
        }(__webpack_require__(7).a);
        /* harmony import */    }, 
    /* 50 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */
        function idGenerator() {
            var lastID = 0;
            return function generateNewId() {
                return "" + lastID++;
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return idGenerator;
        });
    }, 
    /* 51 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ObjectUnsubscribedError;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var ObjectUnsubscribedError = /* */ function() {
            function ObjectUnsubscribedErrorImpl() {
                return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", 
                this;
            }
            return ObjectUnsubscribedErrorImpl.prototype = /* */ Object.create(Error.prototype), 
            ObjectUnsubscribedErrorImpl;
        }();
    }, 
    /* 52 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} tt
 * @returns {Element}
 */
        function getBodyNode(tt) {
            return tt.getElementsByTagName("body")[0];
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getStyleNodes(tt) {
            return tt.getElementsByTagName("style");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getRegionNodes(tt) {
            return tt.getElementsByTagName("region");
        }
        /**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */        function getTextNodes(tt) {
            return tt.getElementsByTagName("p");
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBodyNode;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getStyleNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getRegionNodes;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTextNodes;
        });
    }, 
    /* 53 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return MediaError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */        var MediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
            function MediaError(code, reason) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), MediaError.prototype), _this.name = "MediaError", 
                _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.MEDIA_ERROR, _this.code = code, 
                _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, reason), 
                _this.fatal = !1, _this;
            }
            return _inheritsLoose(MediaError, _Error), MediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 54 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isFunction(x) {
            return "function" == typeof x;
        }
        //# sourceMappingURL=isFunction.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isFunction;
        });
    }, 
    /* 55 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EMPTY;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return empty;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), EMPTY = /* */ new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
            return subscriber.complete();
        });
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }
        function emptyScheduled(scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(function() {
                    return subscriber.complete();
                });
            });
        }
        //# sourceMappingURL=empty.js.map
        /***/    }, 
    /* 56 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
        function getFirstLineAfterHeader(linified) {
            for (var i = 0; i < linified.length; ) {
                if ("" === linified[i]) return i + 1;
                i++;
            }
            return i;
        }
        /**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfStyleBlock(lines, index) {
            return !!lines[index] && /^STYLE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "STYLe". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfNoteBlock(lines, index) {
            return !!lines[index] && /^NOTE( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "NOTE". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */        function isStartOfRegionBlock(lines, index) {
            return !!lines[index] && /^REGION( .*)?$/g.test(lines[index]) && (// A cue identifer can also contain "REGION". Check that we have no timings
            // on the second line
            !lines[index + 1] || lines[index + 1].indexOf("--\x3e") < 0);
        }
        /**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */        function isStartOfCueBlock(lines, index) {
            // checked cases:
            //   - empty lines
            //   - start of a comment
            //   - start of a region
            //   - start of a style
            // Anything else whose first or second line is a timestamp line is a cue.
            var firstLine = lines[index];
            if (!firstLine || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) return !1;
            if (0 <= firstLine.indexOf("--\x3e")) return !0;
            var secondLine = lines[index + 1];
            return !!secondLine && 0 <= secondLine.indexOf("--\x3e");
        }
        /**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */        function findEndOfCueBlock(linified, startOfCueBlock) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (var firstEmptyLineIndex = startOfCueBlock + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getFirstLineAfterHeader;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return isStartOfCueBlock;
        }), 
        /* unused harmony export isStartOfNoteBlock */
        /* unused harmony export isStartOfRegionBlock */
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return isStartOfStyleBlock;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return findEndOfCueBlock;
        });
    }, 
    /* 57 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(8), subscribeTo = __webpack_require__(118), Subscription = __webpack_require__(16), symbol_observable = __webpack_require__(48);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
        function scheduleObservable(input, scheduler) {
            return new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    var observable = input[symbol_observable.a]();
                    sub.add(observable.subscribe({
                        next: function(value) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.next(value);
                            }));
                        },
                        error: function(err) {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.error(err);
                            }));
                        },
                        complete: function() {
                            sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }
                    }));
                })), sub;
            });
        }
        //# sourceMappingURL=scheduleObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
        /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */        function schedulePromise(input, scheduler) {
            return new Observable.a(function(subscriber) {
                var sub = new Subscription.a();
                return sub.add(scheduler.schedule(function() {
                    return input.then(function(value) {
                        sub.add(scheduler.schedule(function() {
                            subscriber.next(value), sub.add(scheduler.schedule(function() {
                                return subscriber.complete();
                            }));
                        }));
                    }, function(err) {
                        sub.add(scheduler.schedule(function() {
                            return subscriber.error(err);
                        }));
                    });
                })), sub;
            });
        }
        //# sourceMappingURL=schedulePromise.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
                var scheduleArray = __webpack_require__(72), symbol_iterator = __webpack_require__(61);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
        function scheduleIterable(input, scheduler) {
            if (!input) throw new Error("Iterable cannot be null");
            return new Observable.a(function(subscriber) {
                var iterator, sub = new Subscription.a();
                return sub.add(function() {
                    iterator && "function" == typeof iterator.return && iterator.return();
                }), sub.add(scheduler.schedule(function() {
                    iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule(function() {
                        if (!subscriber.closed) {
                            var value, done;
                            try {
                                var result = iterator.next();
                                value = result.value, done = result.done;
                            } catch (err) {
                                return void subscriber.error(err);
                            }
                            done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                        }
                    }));
                })), sub;
            });
        }
        //# sourceMappingURL=scheduleIterable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */        function isInteropObservable(input) {
            return input && "function" == typeof input[symbol_observable.a];
        }
        //# sourceMappingURL=isInteropObservable.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
                var isPromise = __webpack_require__(96), isArrayLike = __webpack_require__(94);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
        function isIterable(input) {
            return input && "function" == typeof input[symbol_iterator.a];
        }
        //# sourceMappingURL=isIterable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
        /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */        function scheduled(input, scheduler) {
            if (null != input) {
                if (isInteropObservable(input)) return scheduleObservable(input, scheduler);
                if (Object(isPromise.a)(input)) return schedulePromise(input, scheduler);
                if (Object(isArrayLike.a)(input)) return Object(scheduleArray.a)(input, scheduler);
                if (isIterable(input) || "string" == typeof input) return scheduleIterable(input, scheduler);
            }
            throw new TypeError((null !== input && typeof input || input) + " is not observable");
        }
        //# sourceMappingURL=scheduled.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
        function from(input, scheduler) {
            return scheduler ? scheduled(input, scheduler) : input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input));
        }
        //# sourceMappingURL=from.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return from;
        });
    }, 
    /* 58 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function hostReportError(err) {
            setTimeout(function() {
                throw err;
            }, 0);
        }
        //# sourceMappingURL=hostReportError.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hostReportError;
        });
    }, 
    /* 59 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwError;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */        function throwError(error, scheduler) {
            return scheduler ? new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return scheduler.schedule(dispatch, 0, {
                    error: error,
                    subscriber: subscriber
                });
            }) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.error(error);
            });
        }
        function dispatch(_a) {
            var error = _a.error;
            _a.subscriber.error(error);
        }
        //# sourceMappingURL=throwError.js.map
        /***/    }, 
    /* 60 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
        function errorMessage(name, code, reason) {
            return name + " (" + code + ") " + reason;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return errorMessage;
        });
    }, 
    /* 61 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export getSymbolIterator */
        /* harmony export (binding) */        
        /* unused harmony export $$iterator */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }
        __webpack_require__.d(__webpack_exports__, "a", function() {
            return iterator;
        });
        var iterator = /* */ getSymbolIterator();
    }, 
    /* 62 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromArray;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95), _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
        function fromArray(input, scheduler) {
            return scheduler ? Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(input, scheduler) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(input));
        }
        //# sourceMappingURL=fromArray.js.map
        /***/    }, 
    /* 63 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return findCompleteBox;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */        function findCompleteBox(buf, wantedName) {
            for (var len = buf.length, i = 0; i + 8 < len; ) {
                var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i);
                if (size <= 0) return -1;
                if (Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 4) === wantedName) return i + size <= len ? i : -1;
                i += size;
            }
            return -1;
        }
        /***/    }, 
    /* 64 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return OtherError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @class OtherError
 * @extends Error
 */        var OtherError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
            function OtherError(code, reason) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), OtherError.prototype), _this.name = "OtherError", 
                _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.OTHER_ERROR, _this.code = code, 
                _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, reason), 
                _this.fatal = !1, _this;
            }
            return _inheritsLoose(OtherError, _Error), OtherError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 65 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var callable, byObserver;
        callable = function(fn) {
            if ("function" != typeof fn) throw new TypeError(fn + " is not a function");
            return fn;
        }, byObserver = function(Observer) {
            var queue, currentQueue, node = document.createTextNode(""), i = 0;
            return new Observer(function() {
                var callback;
                if (queue) currentQueue && (queue = currentQueue.concat(queue)); else {
                    if (!currentQueue) return;
                    queue = currentQueue;
                }
                if (currentQueue = queue, queue = null, "function" == typeof currentQueue) return callback = currentQueue, 
                currentQueue = null, void callback();
                // Invoke other batch, to handle leftover callbacks in case of crash
                for (node.data = i = ++i % 2; currentQueue; ) callback = currentQueue.shift(), currentQueue.length || (currentQueue = null), 
                callback();
            }).observe(node, {
                characterData: !0
            }), function(fn) {
                callable(fn), queue ? "function" == typeof queue ? queue = [ queue, fn ] : queue.push(fn) : (queue = fn, 
                node.data = i = ++i % 2);
            };
        }, module.exports = function() {
            // Node.js
            if ("object" == typeof process && process && "function" == typeof process.nextTick) return process.nextTick;
            // MutationObserver
                        if ("object" == typeof document && document) {
                if ("function" == typeof MutationObserver) return byObserver(MutationObserver);
                if ("function" == typeof WebKitMutationObserver) return byObserver(WebKitMutationObserver);
            }
            // W3C Draft
            // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
                        return "function" == typeof setImmediate ? function(cb) {
                setImmediate(callable(cb));
            } : 
            // Wide available standard
            "function" == typeof setTimeout || "object" == typeof setTimeout ? function(cb) {
                setTimeout(callable(cb), 0);
            } : null;
        }();
    }, 
    /* 66 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return rxSubscriber;
        });
        /* unused harmony export $$rxSubscriber */
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var rxSubscriber = /* */ function() {
            return "function" == typeof Symbol ? /* */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* */ Math.random();
        }();
    }, 
    /* 67 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isNumeric;
        });
        /* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */        function isNumeric(val) {
            return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(val) && 0 <= val - parseFloat(val) + 1;
        }
        //# sourceMappingURL=isNumeric.js.map
        /***/    }, 
    /* 68 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SimpleSet;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple hash-based set.
 * @class SimpleSet
 */
        var SimpleSet = 
        /* */
        function() {
            function SimpleSet() {
                this._hashes = {};
            }
            /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */            var _proto = SimpleSet.prototype;
            return _proto.add = function add(x) {
                this._hashes[x] = !0;
            }
            /**
   * Remove an hash entry from the set.
   * Do not have any effect on already-removed or inexistant hashes
   * @param {string|number} x
   */ , _proto.remove = function remove(x) {
                delete this._hashes[x];
            }
            /**
   * Test if the given hash has an entry in the set.
   * @param {string|number} x
   * @returns {boolean}
   */ , _proto.test = function test(x) {
                return !!this._hashes[x];
            }
            /**
   * Returns true if there's currently no hash in this set.
   * @returns {boolean}
   */ , _proto.isEmpty = function isEmpty() {
                return !Object.keys(this._hashes).length;
            }, SimpleSet;
        }();
        /***/    }, 
    /* 69 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return checkISOBMFFIntegrity;
        });
        /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64), _find_complete_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} buffer
 * @param {boolean} isInit
 * @returns {Array}
 */
        function checkISOBMFFIntegrity(buffer, isInit) {
            if (isInit) {
                if (Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__.a)(buffer, 1718909296
                /* ftyp */) < 0) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("INTEGRITY_ERROR", "Incomplete `ftyp` box");
                if (Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__.a)(buffer, 1836019574
                /* moov */) < 0) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("INTEGRITY_ERROR", "Incomplete `moov` box");
            } else {
                if (Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__.a)(buffer, 1836019558
                /* moof */) < 0) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("INTEGRITY_ERROR", "Incomplete `moof` box");
                if (Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__.a)(buffer, 1835295092
                /* mdat */) < 0) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("INTEGRITY_ERROR", "Incomplete `mdat` box");
            }
        }
        /***/    }, 
    /* 70 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export NotificationKind */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return Notification;
        });
        /* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55), _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59);
        /* harmony import */        var Notification = /* */ function() {
            function Notification(kind, value, error) {
                this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
            }
            return Notification.prototype.observe = function(observer) {
                switch (this.kind) {
                  case "N":
                    return observer.next && observer.next(this.value);

                  case "E":
                    return observer.error && observer.error(this.error);

                  case "C":
                    return observer.complete && observer.complete();
                }
            }, Notification.prototype.do = function(next, error, complete) {
                switch (this.kind) {
                  case "N":
                    return next && next(this.value);

                  case "E":
                    return error && error(this.error);

                  case "C":
                    return complete && complete();
                }
            }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
                return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
            }, Notification.prototype.toObservable = function() {
                switch (this.kind) {
                  case "N":
                    return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__.a)(this.value);

                  case "E":
                    return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__.a)(this.error);

                  case "C":
                    return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__.b)();
                }
                throw new Error("unexpected notification kind value");
            }, Notification.createNext = function(value) {
                return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
            }, Notification.createError = function(err) {
                return new Notification("E", void 0, err);
            }, Notification.createComplete = function() {
                return Notification.completeNotification;
            }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        }();
        //# sourceMappingURL=Notification.js.map
        /***/    }, 
    /* 71 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getBox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getBoxContent;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getBoxOffsets;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getUuidContent;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */        function getBoxContent(buf, boxName) {
            var offsets = getBoxOffsets(buf, boxName);
            return null != offsets ? buf.subarray(offsets[0] + 8, offsets[1]) : null;
        }
        /**
 * Returns an ISOBMFF box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */        function getBox(buf, boxName) {
            var offsets = getBoxOffsets(buf, boxName);
            return null != offsets ? buf.subarray(offsets[0], offsets[1]) : null;
        }
        /**
 * Returns start and end offset for a given box.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {Array.<number>|null}
 */        function getBoxOffsets(buf, boxName) {
            for (var name, l = buf.length, i = 0, size = 0; i + 8 < l; ) {
                if (size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i), name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 4), 
                size <= 0) throw new Error("ISOBMFF: Size out of range");
                if (name === boxName) break;
                i += size;
            }
            return i < l ? [ i, i + size ] : null;
        }
        /**
 * Gives the content of a specific UUID with its attached ID
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */        function getUuidContent(buf, id1, id2, id3, id4) {
            for (var len, l = buf.length, i = 0; i < l; i += len) if (len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i), 
            1970628964
            /* === "uuid" */ === Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 4) && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 8) === id1 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 12) === id2 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 16) === id3 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(buf, i + 20) === id4) return buf.subarray(i + 24, i + len);
        }
        /***/    }, 
    /* 72 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return scheduleArray;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
        function scheduleArray(input, scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a(), i = 0;
                return sub.add(scheduler.schedule(function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                })), sub;
            });
        }
        //# sourceMappingURL=scheduleArray.js.map
        /***/    }, 
    /* 73 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */        var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        __webpack_exports__.a = _normalize__WEBPACK_IMPORTED_MODULE_0__.a;
    }, 
    /* 74 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export objectValues */
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */        
        /* tslint:disable no-unbound-method */
        /* harmony default export */ __webpack_exports__.a = "function" == typeof Object.values ? Object.values : function objectValues(o) {
            return Object.keys(o).map(function(k) {
                return o[k];
            });
        };
    }, 
    /* 75 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
        function getParentElementsByTagName(element, tagName) {
            if (!(element.parentNode instanceof Element)) return [];
            return function constructArray(_element) {
                var elements = [];
                _element.tagName.toLowerCase() === tagName.toLowerCase() && elements.push(_element);
                var parentNode = _element.parentNode;
                return parentNode instanceof Element && elements.push.apply(elements, constructArray(parentNode)), 
                elements;
            }(element.parentNode);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParentElementsByTagName;
        });
    }, 
    /* 76 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                var next_tick = __webpack_require__(65), next_tick_default = /* */ __webpack_require__.n(next_tick), of = __webpack_require__(23), event_emitter = __webpack_require__(38), rx_try_catch = __webpack_require__(32), ranges = __webpack_require__(15), time_ranges_ManualTimeRanges = 
        /* */
        function() {
            function ManualTimeRanges() {
                this._ranges = [], this.length = 0;
            }
            var _proto = ManualTimeRanges.prototype;
            return _proto.insert = function insert(start, end) {
                Object(ranges.i)(this._ranges, {
                    start: start,
                    end: end
                }), this.length = this._ranges.length;
            }, _proto.remove = function remove(start, end) {
                var rangesToIntersect = [];
                0 < start && rangesToIntersect.push({
                    start: 0,
                    end: start
                }), end < Infinity && rangesToIntersect.push({
                    start: end,
                    end: Infinity
                }), this._ranges = Object(ranges.k)(this._ranges, rangesToIntersect), this.length = this._ranges.length;
            }, _proto.start = function start(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].start;
            }, _proto.end = function end(index) {
                if (index >= this._ranges.length) throw new Error("INDEX_SIZE_ERROR");
                return this._ranges[index].end;
            }, ManualTimeRanges;
        }();
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */        
        // CONCATENATED MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return abstract_source_buffer_AbstractSourceBuffer;
        });
        var abstract_source_buffer_AbstractSourceBuffer = 
        /* */
        function(_EventEmitter) {
            function AbstractSourceBuffer() {
                var _this;
                return (_this = _EventEmitter.call(this) || this).updating = !1, _this.readyState = "opened", 
                _this.buffered = new time_ranges_ManualTimeRanges(), _this.timestampOffset = 0, 
                _this.appendWindowStart = 0, _this.appendWindowEnd = Infinity, _this;
            }
            /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append a segment to the
   * buffer.
   * @param {*} data
   */            _inheritsLoose(AbstractSourceBuffer, _EventEmitter);
            var _proto = AbstractSourceBuffer.prototype;
            return _proto.appendBuffer = function appendBuffer(data) {
                var _this2 = this;
                this._lock(function() {
                    return _this2._append(data);
                });
            }
            /**
   * Mimic the SourceBuffer _remove_ method: remove buffered segments.
   * @param {Number} from
   * @param {Number} to
   */ , _proto.remove = function remove(from, to) {
                var _this3 = this;
                this._lock(function() {
                    return _this3._remove(from, to);
                });
            }
            /**
   * Mimic the SourceBuffer _abort_ method.
   */ , _proto.abort = function abort() {
                this.updating = !1, this.readyState = "closed", this._abort();
            }
            /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */ , _proto._lock = function _lock(func) {
                var _this4 = this;
                if (this.updating) throw new Error("SourceBuffer: SourceBuffer already updating.");
                this.updating = !0, this.trigger("updatestart", void 0), Object(rx_try_catch.a)(function() {
                    return func(), Object(of.a)(void 0);
                }, void 0).subscribe(function() {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("update", void 0), _this4.trigger("updateend", void 0);
                    });
                }, function(e) {
                    return next_tick_default()(function() {
                        _this4.updating = !1, _this4.trigger("error", e), _this4.trigger("updateend", void 0);
                    });
                });
            }, AbstractSourceBuffer;
        }(event_emitter.a);
        /***/    }, 
    /* 77 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Scheduler = /* */ function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, 
                this.now = now;
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay);
            }, Scheduler.now = function() {
                return Date.now();
            }, Scheduler;
        }();
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
                //# sourceMappingURL=Scheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncScheduler_AsyncScheduler;
        });
        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
        var AsyncScheduler_AsyncScheduler = /* */ function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now();
                }) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this;
            }
            return tslib_es6.a(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state);
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action); else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break;
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (;action = actions.shift(); ) action.unsubscribe();
                        throw error;
                    }
                }
            }, AsyncScheduler;
        }(Scheduler);
        //# sourceMappingURL=AsyncScheduler.js.map
        /***/    }, 
    /* 78 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Action_Action = /* */ function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this;
            }
            return tslib_es6.a(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this;
            }, Action;
        }(__webpack_require__(16).a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
                //# sourceMappingURL=Action.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return AsyncAction_AsyncAction;
        });
        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
        var AsyncAction_AsyncAction = /* */ function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this;
            }
            return tslib_es6.a(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay);
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }, AsyncAction;
        }(Action_Action);
        //# sourceMappingURL=AsyncAction.js.map
        /***/    }, 
    /* 79 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return empty;
        });
        /* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39), _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58), empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
            },
            complete: function() {}
        };
        /* harmony import */    }, 
    /* 80 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return EncryptedMediaError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */        var EncryptedMediaError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {string} reason
   * @Param {Boolean} fatal
   */
            function EncryptedMediaError(code, reason) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), EncryptedMediaError.prototype), 
                _this.name = "EncryptedMediaError", _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.ENCRYPTED_MEDIA_ERROR, 
                _this.code = code, _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, reason), 
                _this.fatal = !1, _this;
            }
            return _inheritsLoose(EncryptedMediaError, _Error), EncryptedMediaError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 81 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return merge;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45), _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93), _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
        function merge() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), 
            1 < observables.length && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler));
        }
        //# sourceMappingURL=merge.js.map
        /***/    }, 
    /* 82 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return defer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function defer(observableFactory) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__.a)(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)()).subscribe(subscriber);
            });
        }
        //# sourceMappingURL=defer.js.map
        /***/    }, 
    /* 83 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return fetchIsSupported;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(127), _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33), _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
        /* harmony import */        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
                var info = gen[key](arg), value = info.value;
            } catch (error) {
                return void reject(error);
            }
            info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
            return function() {
                var self = this, args = arguments;
                return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self, args);
                    function _next(value) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                });
            };
        }
        /*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_REQUEST_TIMEOUT = _config__WEBPACK_IMPORTED_MODULE_1__.a.DEFAULT_REQUEST_TIMEOUT, _Headers = "function" == typeof Headers ? Headers : null, _AbortController = "function" == typeof AbortController ? AbortController : null;
        /**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */
        function fetchIsSupported() {
            return !(!window.fetch || null == _AbortController || null == _Headers);
        }
        /* harmony default export */        __webpack_exports__.a = function fetchRequest(options) {
            var headers;
            if (null != options.headers) if (null == _Headers) headers = options.headers; else {
                headers = new _Headers();
                for (var headerNames = Object.keys(options.headers), i = 0; i < headerNames.length; i++) {
                    var headerName = headerNames[i];
                    headers.append(headerName, options.headers[headerName]);
                }
            }
            return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(obs) {
                _log__WEBPACK_IMPORTED_MODULE_4__.a.debug("Fetch: Called with URL", options.url);
                var hasAborted = !1, timeouted = !1, isDone = !1, sendingTime = performance.now(), abortController = null != _AbortController ? new _AbortController() : null;
                /**
     * Abort current fetchRequest by triggering AbortController signal.
     * @returns {void}
     */
                function abortRequest() {
                    if (!isDone) {
                        if (abortController) return abortController.abort();
                        _log__WEBPACK_IMPORTED_MODULE_4__.a.warn("Fetch: AbortController API not available.");
                    }
                }
                var requestTimeout = null == options.timeout ? DEFAULT_REQUEST_TIMEOUT : options.timeout, timeout = window.setTimeout(function() {
                    timeouted = !0, abortRequest();
                }, requestTimeout);
                return fetch(options.url, {
                    headers: headers,
                    method: "GET",
                    signal: abortController ? abortController.signal : void 0
                }).then(function(response) {
                    if (null != timeout && clearTimeout(timeout), 300 <= response.status) return _log__WEBPACK_IMPORTED_MODULE_4__.a.warn("Fetch: Request HTTP Error", response), 
                    void obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_3__.c.ERROR_HTTP_CODE));
                    if (null != response.body) {
                        var contentLengthHeader = response.headers.get("Content-Length"), contentLength = null == contentLengthHeader || isNaN(+contentLengthHeader) ? void 0 : +contentLengthHeader, reader = response.body.getReader(), size = 0;
                        return readBufferAndSendEvents();
                    }
                    function readBufferAndSendEvents() {
                        return _readBufferAndSendEvents.apply(this, arguments);
                    }
                    function _readBufferAndSendEvents() {
                        return (_readBufferAndSendEvents = _asyncToGenerator(
                        /* */
                        regeneratorRuntime.mark(function _callee() {
                            var data, currentTime, dataChunk, receivedTime, duration;
                            return regeneratorRuntime.wrap(function _callee$(_context) {
                                for (;;) switch (_context.prev = _context.next) {
                                  case 0:
                                    return _context.next = 2, reader.read();

                                  case 2:
                                    if ((data = _context.sent).done || null == data.value) {
                                        _context.next = 11;
                                        break;
                                    }
                                    return size += data.value.byteLength, currentTime = performance.now(), dataChunk = {
                                        type: "data-chunk",
                                        value: {
                                            url: response.url,
                                            currentTime: currentTime,
                                            duration: currentTime - sendingTime,
                                            sendingTime: sendingTime,
                                            chunkSize: data.value.byteLength,
                                            chunk: data.value.buffer,
                                            size: size,
                                            totalSize: contentLength
                                        }
                                    }, obs.next(dataChunk), _context.abrupt("return", readBufferAndSendEvents());

                                  case 11:
                                    data.done && (receivedTime = performance.now(), duration = receivedTime - sendingTime, 
                                    isDone = !0, obs.next({
                                        type: "data-complete",
                                        value: {
                                            duration: duration,
                                            receivedTime: receivedTime,
                                            sendingTime: sendingTime,
                                            size: size,
                                            status: response.status,
                                            url: response.url
                                        }
                                    }), obs.complete());

                                  case 12:
                                  case "end":
                                    return _context.stop();
                                }
                            }, _callee);
                        }))).apply(this, arguments);
                    }
                    obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_3__.c.PARSE_ERROR));
                }).catch(function(err) {
                    if (hasAborted) _log__WEBPACK_IMPORTED_MODULE_4__.a.debug("Fetch: Request aborted."); else {
                        if (timeouted) return _log__WEBPACK_IMPORTED_MODULE_4__.a.warn("Fetch: Request timeouted."), 
                        void obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_3__.c.TIMEOUT));
                        _log__WEBPACK_IMPORTED_MODULE_4__.a.warn("Fetch: Request Error", err && err.toString()), 
                        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__.a(options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_3__.c.ERROR_EVENT));
                    }
                }), function() {
                    hasAborted = !0, abortRequest();
                };
            });
        };
    }, 
    /* 84 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return clearElementSrc;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _browser_detection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Clear element's src attribute.
 *
 * On IE11, element.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use element.removeAttr("src").
 * @param {HTMLMediaElement} element
 */
        function clearElementSrc(element) {
            if (_browser_detection__WEBPACK_IMPORTED_MODULE_1__.a) {
                for (var textTracks = element.textTracks, i = 0; i < textTracks.length; i++) textTracks[i].mode = "disabled";
                if (element.hasChildNodes()) for (var childNodes = element.childNodes, j = childNodes.length - 1; 0 <= j; j--) if ("track" === childNodes[j].nodeName) try {
                    element.removeChild(childNodes[j]);
                } catch (err) {
                    _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Could not remove text track child from element.");
                }
            }
            element.src = "", element.removeAttribute("src");
        }
        /***/    }, 
    /* 85 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                var log = __webpack_require__(0), array_find = __webpack_require__(9), event_emitter = __webpack_require__(38), id_generator = __webpack_require__(50), warn_once = __webpack_require__(19), media_error = __webpack_require__(53), array_includes = __webpack_require__(12), utils_languages = __webpack_require__(73);
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                /**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        /* harmony default export */ var uniq = "function" == typeof window.Set ? 
        /**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        function uniqFromSet(arr) {
            return Array.from(new Set(arr));
        } : 
        // CONCATENATED MODULE: ./src/utils/uniq.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
        function uniqFromFilter(arr) {
            return arr.filter(function(val, i, self) {
                return self.indexOf(val) === i;
            });
        }, is_codec_supported = __webpack_require__(144);
        // EXTERNAL MODULE: ./src/compat/is_codec_supported.ts
                // CONCATENATED MODULE: ./src/manifest/filter_supported_representations.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Only keep Representations for which the codec is currently supported.
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */
        function filterSupportedRepresentations(adaptationType, representations) {
            return "audio" === adaptationType || "video" === adaptationType ? representations.filter(function(representation) {
                return Object(is_codec_supported.a)(getCodec(representation));
            }) : representations;
        }
        /**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */        function getCodec(representation) {
            var _representation$codec = representation.codecs, codecs = void 0 === _representation$codec ? "" : _representation$codec, _representation$mimeT = representation.mimeType;
            return (void 0 === _representation$mimeT ? "" : _representation$mimeT) + ';codecs="' + codecs + '"';
        }
        // CONCATENATED MODULE: ./src/manifest/representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalized Representation structure.
 * @class Representation
 */        var manifest_representation = 
        /* */
        function() {
            /**
   * @param {Object} args
   */
            function Representation(args) {
                this.id = args.id, this.bitrate = args.bitrate, this.codec = args.codecs, null != args.height && (this.height = args.height), 
                null != args.width && (this.width = args.width), null != args.mimeType && (this.mimeType = args.mimeType), 
                args.contentProtections && (this.contentProtections = args.contentProtections), 
                args.frameRate && (this.frameRate = args.frameRate), this.index = args.index;
            }
            /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */            return Representation.prototype.getMimeTypeString = function getMimeTypeString() {
                return this.mimeType + ';codecs="' + this.codec + '"';
            }, Representation;
        }(), SUPPORTED_ADAPTATIONS_TYPE = [ "audio", "video", "text", "image" ];
        /* harmony default export */        function isSupportedAdaptationType(adaptationType) {
            return Object(array_includes.a)(SUPPORTED_ADAPTATIONS_TYPE, adaptationType);
        }
        /**
 * Normalized Adaptation structure.
 * An Adaptation describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */        var adaptation_Adaptation = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} parsedAdaptation
   * @param {Object|undefined} [options]
   */
            function Adaptation(parsedAdaptation, options) {
                var _this = this;
                void 0 === options && (options = {});
                var _options = options, representationFilter = _options.representationFilter, isManuallyAdded = _options.isManuallyAdded;
                if (this.parsingErrors = [], this.id = parsedAdaptation.id, !isSupportedAdaptationType(parsedAdaptation.type)) throw log.a.info("Manifest: Not supported adaptation type", parsedAdaptation.type), 
                new media_error.a("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", '"' + parsedAdaptation.type + '" is not a valid Adaptation type.');
                this.type = parsedAdaptation.type;
                var hadRepresentations = !!parsedAdaptation.representations.length, argsRepresentations = filterSupportedRepresentations(parsedAdaptation.type, parsedAdaptation.representations);
                if (hadRepresentations && 0 === argsRepresentations.length) {
                    log.a.warn("Incompatible codecs for adaptation", parsedAdaptation);
                    var error = new media_error.a("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.");
                    this.parsingErrors.push(error);
                }
                null != parsedAdaptation.language && (this.language = parsedAdaptation.language, 
                this.normalizedLanguage = Object(utils_languages.a)(parsedAdaptation.language)), 
                null != parsedAdaptation.closedCaption && (this.isClosedCaption = parsedAdaptation.closedCaption), 
                null != parsedAdaptation.audioDescription && (this.isAudioDescription = parsedAdaptation.audioDescription), 
                this.representations = argsRepresentations.map(function(representation) {
                    return new manifest_representation(representation);
                }).sort(function(a, b) {
                    return a.bitrate - b.bitrate;
                }).filter(function(representation) {
                    return null == representationFilter || representationFilter(representation, {
                        bufferType: _this.type,
                        language: _this.language,
                        normalizedLanguage: _this.normalizedLanguage,
                        isClosedCaption: _this.isClosedCaption,
                        isAudioDescription: _this.isAudioDescription
                    });
                }), // for manuallyAdded adaptations (not in the manifest)
                this.manuallyAdded = !!isManuallyAdded;
            }
            /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */            var _proto = Adaptation.prototype;
            return _proto.getAvailableBitrates = function getAvailableBitrates() {
                var bitrates = this.representations.map(function(r) {
                    return r.bitrate;
                });
                return uniq(bitrates);
            }
            /**
   * Returns the Representation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */ , _proto.getRepresentation = function getRepresentation(wantedId) {
                return Object(array_find.a)(this.representations, function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, Adaptation;
        }(), object_values = __webpack_require__(74), period_Period = 
        /* */
        function() {
            /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
            function Period(args, representationFilter) {
                var _this = this;
                if (this.parsingErrors = [], this.id = args.id, this.adaptations = Object.keys(args.adaptations).reduce(function(acc, type) {
                    var adaptationsForType = args.adaptations[type];
                    if (!adaptationsForType) return acc;
                    var filteredAdaptations = adaptationsForType.map(function(adaptation) {
                        var _this$parsingErrors, newAdaptation = null;
                        try {
                            newAdaptation = new adaptation_Adaptation(adaptation, {
                                representationFilter: representationFilter
                            });
                        } catch (err) {
                            if ("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE" === err.code) return _this.parsingErrors.push(err), 
                            null;
                            throw err;
                        }
                        return (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, newAdaptation.parsingErrors), 
                        newAdaptation;
                    }).filter(function(adaptation) {
                        return null != adaptation && 0 < adaptation.representations.length;
                    });
                    if (0 === filteredAdaptations.length && 0 < adaptationsForType.length && ("video" === type || "audio" === type)) throw new media_error.a("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
                    return filteredAdaptations.length && (acc[type] = filteredAdaptations), acc;
                }, {}), !this.adaptations.video && !this.adaptations.audio) throw new media_error.a("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
                this.duration = args.duration, this.start = args.start, null != this.duration && null != this.start && (this.end = this.start + this.duration);
            }
            /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */            var _proto = Period.prototype;
            return _proto.getAdaptations = function getAdaptations() {
                var adaptationsByType = this.adaptations;
                return Object(object_values.a)(adaptationsByType).reduce(function(acc, adaptations) {
                    // Note: the second case cannot happen. TS is just being dumb here
                    return null != adaptations ? acc.concat(adaptations) : acc;
                }, []);
            }
            /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period for a
   * given type.
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */ , _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                return this.adaptations[adaptationType] || [];
            }
            /**
   * Returns the Adaptation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */ , _proto.getAdaptation = function getAdaptation(wantedId) {
                return Object(array_find.a)(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
            }, Period;
        }(), static_StaticRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} infos
   */
            function StaticRepresentationIndex(infos) {
                this._mediaURL = infos.media;
            }
            /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */            var _proto = StaticRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return null;
            }
            /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments() {
                return [ {
                    id: "0",
                    isInit: !1,
                    number: 0,
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: 1,
                    mediaURL: this._mediaURL
                } ];
            }
            /**
   * Returns first position in index.
   * @returns {undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                /* tslint:enable return-undefined */}
            /**
   * Returns last position in index.
   * @returns {undefined}
   */ , _proto.getLastPosition = function getLastPosition() {}
            /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * Returns true as a static file should never need lose availability.
   * @returns {Boolean}
   */ , _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
                return !0;
            }
            /**
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
                return !1;
            }
            /**
   * @returns {Boolean}
   */ , _proto.isFinished = function isFinished() {
                return !0;
            }, _proto._addSegments = function _addSegments() {
                log.a.warn("Tried add Segments to a static RepresentationIndex");
            }, _proto._update = function _update() {
                log.a.warn("Tried to update a static RepresentationIndex");
            }, StaticRepresentationIndex;
        }();
        // EXTERNAL MODULE: ./src/utils/object_values.ts
                // CONCATENATED MODULE: ./src/manifest/update_period_in_place.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */
        function updatePeriodInPlace(oldPeriod, newPeriod) {
            oldPeriod.start = newPeriod.start, oldPeriod.end = newPeriod.end, oldPeriod.duration = newPeriod.duration;
            for (var oldAdaptations = oldPeriod.getAdaptations(), newAdaptations = newPeriod.getAdaptations(), _loop = function _loop(j) {
                var oldAdaptation = oldAdaptations[j], newAdaptation = Object(array_find.a)(newAdaptations, function(a) {
                    return a.id === oldAdaptation.id;
                });
                if (newAdaptation) for (var oldRepresentations = oldAdaptations[j].representations, newRepresentations = newAdaptation.representations, _loop2 = function _loop2(k) {
                    var oldRepresentation = oldRepresentations[k], newRepresentation = Object(array_find.a)(newRepresentations, function(representation) {
                        return representation.id === oldRepresentation.id;
                    });
                    newRepresentation ? oldRepresentation.index._update(newRepresentation.index) : log.a.warn('Manifest: Representation "' + oldRepresentations[k].id + '" not found when merging.');
                }, k = 0; k < oldRepresentations.length; k++) _loop2(k); else log.a.warn('Manifest: Adaptation "' + oldAdaptations[j].id + '" not found when merging.');
            }, j = 0; j < oldAdaptations.length; j++) _loop(j);
        }
        // CONCATENATED MODULE: ./src/manifest/update_periods.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */        function updatePeriods(oldPeriods, newPeriods) {
            // Example :
            //
            // old periods : [p0] [p2] [pX] [pF]
            // new periods : [p1] [p2] [pM] [pX] [pU]
            //
            // The `for` loop will remove old periods and replace new ones
            // between the common periods between the two, in the old periods array.
            //
            // - Step 1 : Handle common period p2
            //    - the p0 is removed the p2
            //    - the p1 is added before the p2
            //
            //                   First unhandled period index
            //                             |
            //                             v
            //    old periods : [p1] [p2] [pX] [pF]
            //    new periods : [p1] [p2] [pM] [pX] [pU]
            //
            // - Step 2 : Handle common period pX
            //    - the pM is added before the pX
            //
            //                              First unhandled period index
            //                                        |
            //                                        v
            // old periods : [p1]  [p2]  [pM]  [pX]  [pF]
            // new periods : [p1]  [p2]  [pM]  [pX]  [pU]
            for (var firstUnhandledPeriodIdx = 0, i = 0; i < newPeriods.length; i++) {
                for (var newPeriod = newPeriods[i], j = firstUnhandledPeriodIdx, oldPeriod = oldPeriods[j]; null != oldPeriod && oldPeriod.id !== newPeriod.id; ) oldPeriod = oldPeriods[++j];
                if (null != oldPeriod) {
                    updatePeriodInPlace(oldPeriod, newPeriod);
                    var periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
                    oldPeriods.splice.apply(oldPeriods, [ j, 0 ].concat(periodsToInclude)), firstUnhandledPeriodIdx = i + 1;
                }
            }
            if (firstUnhandledPeriodIdx > oldPeriods.length) log.a.error("Manifest: error when updating Periods"); else {
                // At this point, the first unhandled period index refers to the first
                // position from which :
                // - there are only undesired periods in old periods array.
                // - there only new wanted periods in new periods array.
                //
                //                              First unhandled period index
                //                                        |
                //                                        v
                // old periods : [p1]  [p2]  [pM]  [pX]  [pF (undesired)]
                // new periods : [p1]  [p2]  [pM]  [pX]  [pU (wanted)]
                //
                // final array (old periods array) : [p1]  [p2]  [pM]  [pX]  [pU]
                firstUnhandledPeriodIdx < oldPeriods.length && oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
                var remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);
                0 < remainingNewPeriods.length && oldPeriods.push.apply(oldPeriods, remainingNewPeriods);
            }
        }
        // CONCATENATED MODULE: ./src/manifest/manifest.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateNewId = Object(id_generator.a)(), manifest_Manifest = 
        /* */
        function(_EventEmitter) {
            /**
   * @param {Object} args
   */
            function Manifest(args, options) {
                var _this;
                _this = _EventEmitter.call(this) || this;
                var _options$supplementar = options.supplementaryTextTracks, supplementaryTextTracks = void 0 === _options$supplementar ? [] : _options$supplementar, _options$supplementar2 = options.supplementaryImageTracks, supplementaryImageTracks = void 0 === _options$supplementar2 ? [] : _options$supplementar2, representationFilter = options.representationFilter;
                return _this.parsingErrors = [], _this.id = args.id, _this.transport = args.transportType, 
                _this._clockOffset = args.clockOffset, _this.periods = args.periods.map(function(period) {
                    var _this$parsingErrors, parsedPeriod = new period_Period(period, representationFilter);
                    return (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, parsedPeriod.parsingErrors), 
                    parsedPeriod;
                }).sort(function(a, b) {
                    return a.start - b.start;
                }), 
                /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */
                /* tslint:disable:deprecation */
                _this.adaptations = _this.periods[0] && _this.periods[0].adaptations || {}, 
                /* tslint:enable:deprecation */
                _this.minimumTime = args.minimumTime, _this.isLive = args.isLive, _this.uris = args.uris || [], 
                _this.lifetime = args.lifetime, _this.suggestedPresentationDelay = args.suggestedPresentationDelay, 
                _this.availabilityStartTime = args.availabilityStartTime, _this.maximumTime = args.maximumTime, 
                _this.baseURL = args.baseURL, args.isLive || null != args.duration || log.a.warn("Manifest: non live content and duration is null."), 
                _this._duration = args.duration, supplementaryImageTracks.length && _this.addSupplementaryImageAdaptations(supplementaryImageTracks), 
                supplementaryTextTracks.length && _this.addSupplementaryTextAdaptations(supplementaryTextTracks), 
                _this;
            }
            /**
   * Returns Period encountered at the given time.
   * Returns undefined if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Period|undefined}
   */            _inheritsLoose(Manifest, _EventEmitter);
            var _proto = Manifest.prototype;
            return _proto.getPeriodForTime = function getPeriodForTime(time) {
                return Object(array_find.a)(this.periods, function(period) {
                    return time >= period.start && (null == period.end || period.end > time);
                });
            }
            /**
   * Returns period coming just after a given period.
   * Returns undefined if not found.
   * @param {Period} period
   * @returns {Period|null}
   */ , _proto.getPeriodAfter = function getPeriodAfter(period) {
                var endOfPeriod = period.end;
                return null == endOfPeriod ? null : Object(array_find.a)(this.periods, function(_period) {
                    return null == _period.end || endOfPeriod < _period.end;
                }) || null;
            }
            /**
   * Returns the duration of the whole content described by that Manifest.
   * @returns {Number}
   */ , _proto.getDuration = function getDuration() {
                return this._duration;
            }
            /**
   * Returns the most important URL from which the Manifest can be refreshed.
   * @returns {string|undefined}
   */ , _proto.getUrl = function getUrl() {
                return this.uris[0];
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptations = function getAdaptations() {
                Object(warn_once.a)("manifest.getAdaptations() is deprecated. Please use manifest.period[].getAdaptations() instead");
                var firstPeriod = this.periods[0];
                if (!firstPeriod) return [];
                var adaptationsByType = firstPeriod.adaptations, adaptationsList = [];
                for (var adaptationType in adaptationsByType) if (adaptationsByType.hasOwnProperty(adaptationType)) {
                    var adaptations = adaptationsByType[adaptationType];
                    adaptationsList.push.apply(adaptationsList, adaptations);
                }
                return adaptationsList;
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
                Object(warn_once.a)("manifest.getAdaptationsForType(type) is deprecated. Please use manifest.period[].getAdaptationsForType(type) instead");
                var firstPeriod = this.periods[0];
                return firstPeriod && firstPeriod.adaptations[adaptationType] || [];
            }
            /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */ , _proto.getAdaptation = function getAdaptation(wantedId) {
                /* tslint:disable:deprecation */
                return Object(warn_once.a)("manifest.getAdaptation(id) is deprecated. Please use manifest.period[].getAdaptation(id) instead"), 
                Object(array_find.a)(this.getAdaptations(), function(_ref) {
                    var id = _ref.id;
                    return wantedId === id;
                });
                /* tslint:enable:deprecation */            }
            /**
   * Update the current manifest properties
   * @param {Object} Manifest
   */ , _proto.update = function update(newManifest) {
                this._duration = newManifest.getDuration(), 
                /* tslint:disable:deprecation */
                this.adaptations = newManifest.adaptations, 
                /* tslint:enable:deprecation */
                this.availabilityStartTime = newManifest.availabilityStartTime, this.baseURL = newManifest.baseURL, 
                this.id = newManifest.id, this.isLive = newManifest.isLive, this.lifetime = newManifest.lifetime, 
                this.maximumTime = newManifest.maximumTime, this.minimumTime = newManifest.minimumTime, 
                this.parsingErrors = newManifest.parsingErrors, this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay, 
                this.transport = newManifest.transport, this.uris = newManifest.uris, updatePeriods(this.periods, newManifest.periods), 
                this.trigger("manifestUpdate", null);
            }
            /**
   * Get minimum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */ , _proto.getMinimumPosition = function getMinimumPosition() {
                var minimumTime = this.minimumTime;
                if (null == minimumTime) return 0;
                if (!minimumTime.isContinuous) return minimumTime.value;
                var timeDiff = performance.now() - minimumTime.time;
                return minimumTime.value + timeDiff / 1e3;
            }
            /**
   * Get maximum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */ , _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this.isLive) {
                    var duration = this.getDuration();
                    return null == duration ? Infinity : duration;
                }
                var maximumTime = this.maximumTime;
                if (null == maximumTime) {
                    var ast = this.availabilityStartTime || 0;
                    return null == this._clockOffset ? Date.now() / 1e3 - ast : (performance.now() + this._clockOffset) / 1e3 - ast;
                }
                if (!maximumTime.isContinuous) return maximumTime.value;
                var timeDiff = performance.now() - maximumTime.time;
                return maximumTime.value + timeDiff / 1e3;
            }
            /**
   * If true, this Manifest is currently synchronized with the server's clock.
   * @returns {Boolean}
   */ , _proto.getClockOffset = function getClockOffset() {
                return this._clockOffset;
            }
            /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} imageTracks
   */ , _proto.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(imageTracks) {
                var _this2 = this, newImageTracks = (Array.isArray(imageTracks) ? imageTracks : [ imageTracks ]).map(function(_ref2) {
                    var _this2$parsingErrors, mimeType = _ref2.mimeType, url = _ref2.url, adaptationID = "gen-image-ada-" + generateNewId(), representationID = "gen-image-rep-" + generateNewId(), newAdaptation = new adaptation_Adaptation({
                        id: adaptationID,
                        type: "image",
                        representations: [ {
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            index: new static_StaticRepresentationIndex({
                                media: url
                            })
                        } ]
                    }, {
                        isManuallyAdded: !0
                    });
                    return (_this2$parsingErrors = _this2.parsingErrors).push.apply(_this2$parsingErrors, newAdaptation.parsingErrors), 
                    newAdaptation;
                });
                if (newImageTracks.length && this.periods.length) {
                    var adaptations = this.periods[0].adaptations;
                    adaptations.image = adaptations.image ? adaptations.image.concat(newImageTracks) : newImageTracks;
                }
            }
            /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} textTracks
   */ , _proto.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(textTracks) {
                var _this3 = this, newTextAdaptations = (Array.isArray(textTracks) ? textTracks : [ textTracks ]).reduce(function(allSubs, _ref3) {
                    var mimeType = _ref3.mimeType, codecs = _ref3.codecs, url = _ref3.url, language = _ref3.language, languages = _ref3.languages, closedCaption = _ref3.closedCaption, langsToMapOn = language ? [ language ] : languages || [];
                    return allSubs.concat(langsToMapOn.map(function(_language) {
                        var _this3$parsingErrors, adaptationID = "gen-text-ada-" + generateNewId(), representationID = "gen-text-rep-" + generateNewId(), newAdaptation = new adaptation_Adaptation({
                            id: adaptationID,
                            type: "text",
                            language: _language,
                            closedCaption: closedCaption,
                            representations: [ {
                                bitrate: 0,
                                id: representationID,
                                mimeType: mimeType,
                                codecs: codecs,
                                index: new static_StaticRepresentationIndex({
                                    media: url
                                })
                            } ]
                        }, {
                            isManuallyAdded: !0
                        });
                        return (_this3$parsingErrors = _this3.parsingErrors).push.apply(_this3$parsingErrors, newAdaptation.parsingErrors), 
                        newAdaptation;
                    }));
                }, []);
                if (newTextAdaptations.length && this.periods.length) {
                    var adaptations = this.periods[0].adaptations;
                    adaptations.text = adaptations.text ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
                }
            }, Manifest;
        }(event_emitter.a);
        /**
 * Normalized Manifest structure.
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth or DASH).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a live manifest of when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 * @class Manifest
 */        __webpack_exports__.a = manifest_Manifest;
    }, 
    /* 86 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>}originalArray
 * @param {Function}fn
 */
        function flatMap(originalArray, fn) {
            /* tslint:disable no-unbound-method */
            return "function" == typeof Array.prototype.flatMap ? originalArray.flatMap(fn) : originalArray.reduce(function(acc, arg) {
                var r = fn(arg);
                return Array.isArray(r) ? [].concat(acc, r) : [].concat(acc, [ r ]);
            }, []);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return flatMap;
        });
    }, 
    /* 87 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Subject = __webpack_require__(41), Observable = __webpack_require__(8), Subscriber = __webpack_require__(7), Subscription = __webpack_require__(16), refCount = __webpack_require__(113), ConnectableObservable_ConnectableObservable = /* */ function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, 
                _this._isComplete = !1, _this;
            }
            return tslib_es6.a(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a()).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed && (this._connection = null, connection = Subscription.a.EMPTY)), 
                connection;
            }, ConnectableObservable.prototype.refCount = function() {
                return Object(refCount.a)()(this);
            }, ConnectableObservable;
        }(Observable.a), connectableObservableDescriptor = /* */ function() {
            var connectableProto = ConnectableObservable_ConnectableObservable.prototype;
            return {
                operator: {
                    value: null
                },
                _refCount: {
                    value: 0,
                    writable: !0
                },
                _subject: {
                    value: null,
                    writable: !0
                },
                _connection: {
                    value: null,
                    writable: !0
                },
                _subscribe: {
                    value: connectableProto._subscribe
                },
                _isComplete: {
                    value: connectableProto._isComplete,
                    writable: !0
                },
                getSubject: {
                    value: connectableProto.getSubject
                },
                connect: {
                    value: connectableProto.connect
                },
                refCount: {
                    value: connectableProto.refCount
                }
            };
        }(), ConnectableObservable_ConnectableSubscriber = /* */ function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib_es6.a(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err);
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this);
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }, ConnectableSubscriber;
        }(Subject.b);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                Subscriber.a;
        /* unused harmony export MulticastOperator */
        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
        function multicast(subjectOrSubjectFactory, selector) {
            return function multicastOperatorFunction(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function subjectFactory() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        //# sourceMappingURL=ConnectableObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return multicast;
        });
        var MulticastOperator = /* */ function() {
            function MulticastOperator(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            return MulticastOperator.prototype.call = function(subscriber, source) {
                var selector = this.selector, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }, MulticastOperator;
        }();
        //# sourceMappingURL=multicast.js.map
        /***/    }, 
    /* 88 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), nextHandle = 1, tasksByHandle = {};
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        function runIfPresent(handle) {
            var cb = tasksByHandle[handle];
            cb && cb();
        }
        var Immediate_setImmediate = function(cb) {
            var handle = nextHandle++;
            return tasksByHandle[handle] = cb, Promise.resolve().then(function() {
                return runIfPresent(handle);
            }), handle;
        }, Immediate_clearImmediate = function(handle) {
            delete tasksByHandle[handle];
        }, AsapAction_AsapAction = /* */ function(_super) {
            function AsapAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(AsapAction, _super), AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && 0 < delay ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : (scheduler.actions.push(this), 
                scheduler.scheduled || (scheduler.scheduled = Immediate_setImmediate(scheduler.flush.bind(scheduler, null))));
            }, AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && 0 < delay || null === delay && 0 < this.delay) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
                0 === scheduler.actions.length && (Immediate_clearImmediate(id), scheduler.scheduled = void 0);
            }, AsapAction;
        }(__webpack_require__(78).a), AsapScheduler_AsapScheduler = /* */ function(_super) {
            function AsapScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(AsapScheduler, _super), AsapScheduler.prototype.flush = function(action) {
                this.active = !0, this.scheduled = void 0;
                var error, actions = this.actions, index = -1, count = actions.length;
                action = action || actions.shift();
                do {
                    if (error = action.execute(action.state, action.delay)) break;
                } while (++index < count && (action = actions.shift()));
                if (this.active = !1, error) {
                    for (;++index < count && (action = actions.shift()); ) action.unsubscribe();
                    throw error;
                }
            }, AsapScheduler;
        }(__webpack_require__(77).a);
        //# sourceMappingURL=Immediate.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
                //# sourceMappingURL=AsapScheduler.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return asap;
        });
        /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
        var asap = /* */ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);
        //# sourceMappingURL=asap.js.map
        /***/    }, 
    /* 89 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */
        function requestFullscreen(element) {
            if (!isFullscreen()) {
                var elt = element;
                elt.requestFullscreen ? 
                /* tslint:disable no-floating-promises */
                elt.requestFullscreen() : elt.msRequestFullscreen ? elt.msRequestFullscreen() : elt.mozRequestFullScreen ? elt.mozRequestFullScreen() : elt.webkitRequestFullscreen && elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
        /**
 * Exit fullscreen if an element is currently in fullscreen.
 */        function exitFullscreen() {
            if (isFullscreen()) {
                var doc = document;
                doc.exitFullscreen ? 
                /* tslint:disable no-floating-promises */
                doc.exitFullscreen() : doc.msExitFullscreen ? doc.msExitFullscreen() : doc.mozCancelFullScreen ? doc.mozCancelFullScreen() : doc.webkitExitFullscreen && doc.webkitExitFullscreen();
            }
        }
        /**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */        function isFullscreen() {
            var doc = document;
            return !!(doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "c", function() {
            return requestFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return exitFullscreen;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return isFullscreen;
        });
    }, 
    /* 90 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */        var ISO_639_1_to_ISO_639_3 = {
            aa: "aar",
            ab: "abk",
            ae: "ave",
            af: "afr",
            ak: "aka",
            am: "amh",
            an: "arg",
            ar: "ara",
            as: "asm",
            av: "ava",
            ay: "aym",
            az: "aze",
            ba: "bak",
            be: "bel",
            bg: "bul",
            bi: "bis",
            bm: "bam",
            bn: "ben",
            bo: "bod",
            br: "bre",
            bs: "bos",
            ca: "cat",
            ce: "che",
            ch: "cha",
            co: "cos",
            cr: "cre",
            cs: "ces",
            cu: "chu",
            // Old Slavonic, Old Bulgarian
            cv: "chv",
            cy: "cym",
            da: "dan",
            de: "deu",
            dv: "div",
            dz: "dzo",
            ee: "ewe",
            el: "ell",
            en: "eng",
            eo: "epo",
            es: "spa",
            et: "est",
            eu: "eus",
            fa: "fas",
            ff: "ful",
            fi: "fin",
            fj: "fij",
            fo: "fao",
            fr: "fra",
            fy: "fry",
            ga: "gle",
            gd: "gla",
            gl: "glg",
            gn: "grn",
            gu: "guj",
            gv: "glv",
            ha: "hau",
            he: "heb",
            hi: "hin",
            ho: "hmo",
            hr: "hrv",
            ht: "hat",
            hu: "hun",
            hy: "hye",
            hz: "her",
            ia: "ina",
            id: "ind",
            ie: "ile",
            ig: "ibo",
            ii: "iii",
            ik: "ipk",
            io: "ido",
            is: "isl",
            it: "ita",
            iu: "iku",
            ja: "jpn",
            jv: "jav",
            ka: "kat",
            kg: "kon",
            ki: "kik",
            kj: "kua",
            kk: "kaz",
            kl: "kal",
            km: "khm",
            kn: "kan",
            ko: "kor",
            kr: "kau",
            ks: "kas",
            ku: "kur",
            kv: "kom",
            kw: "cor",
            ky: "kir",
            la: "lat",
            lb: "ltz",
            lg: "lug",
            li: "lim",
            ln: "lin",
            lo: "lao",
            lt: "lit",
            lu: "lub",
            lv: "lav",
            mg: "mlg",
            mh: "mah",
            mi: "mri",
            mk: "mkd",
            ml: "mal",
            mn: "mon",
            mr: "mar",
            ms: "msa",
            mt: "mlt",
            my: "mya",
            na: "nau",
            nb: "nob",
            nd: "nde",
            ne: "nep",
            ng: "ndo",
            nl: "nld",
            nn: "nno",
            no: "nor",
            nr: "nbl",
            nv: "nav",
            ny: "nya",
            oc: "oci",
            oj: "oji",
            om: "orm",
            or: "ori",
            os: "oss",
            pa: "pan",
            pi: "pli",
            pl: "pol",
            ps: "pus",
            pt: "por",
            qu: "que",
            rm: "roh",
            rn: "run",
            ro: "ron",
            ru: "rus",
            rw: "kin",
            sa: "san",
            sc: "srd",
            sd: "snd",
            se: "sme",
            sg: "sag",
            si: "sin",
            sk: "slk",
            sl: "slv",
            sm: "smo",
            sn: "sna",
            so: "som",
            sq: "sqi",
            sr: "srp",
            ss: "ssw",
            st: "sot",
            su: "sun",
            sv: "swe",
            sw: "swa",
            ta: "tam",
            te: "tel",
            tg: "tgk",
            th: "tha",
            ti: "tir",
            tk: "tuk",
            tl: "tgl",
            tn: "tsn",
            to: "ton",
            tr: "tur",
            ts: "tso",
            tt: "tat",
            tw: "twi",
            ty: "tah",
            ug: "uig",
            uk: "ukr",
            ur: "urd",
            uz: "uzb",
            ve: "ven",
            vi: "vie",
            vo: "vol",
            wa: "wln",
            wo: "wol",
            xh: "xho",
            yi: "yid",
            yo: "yor",
            za: "zha",
            zh: "zho",
            zu: "zul"
        }, ISO_639_2_to_ISO_639_3 = {
            alb: "sqi",
            arm: "hye",
            baq: "eus",
            bur: "mya",
            chi: "zho",
            cze: "ces",
            dut: "nld",
            fre: "fra",
            geo: "kat",
            ger: "deu",
            gre: "ell",
            ice: "isl",
            mac: "mkd",
            mao: "mri",
            may: "msa",
            per: "fas",
            slo: "slk",
            rum: "ron",
            tib: "bod",
            wel: "cym"
        };
        /* harmony default export */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
        function normalizeLanguage(_language) {
            if (null == _language || "" === _language) return "";
            var normalizedBase = normalizeBase(("" + _language).toLowerCase().split("-")[0]);
            return normalizedBase || _language;
        }
        /**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */        function normalizeBase(base) {
            var result;
            switch (base.length) {
              case 2:
                result = ISO_639_1_to_ISO_639_3[base];
                break;

              case 3:
                result = ISO_639_2_to_ISO_639_3[base];
            }
            return result;
        }
        /**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeTextTrack(_language) {
            return null == _language ? _language : (closedCaption = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.closedCaption), {
                language: language,
                closedCaption: closedCaption,
                normalized: normalizeLanguage(language)
            });
            var language, closedCaption;
        }
        /**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */        function normalizeAudioTrack(_language) {
            return null == _language ? _language : (audioDescription = "string" == typeof _language ? (language = _language, 
            !1) : (language = _language.language, !!_language.audioDescription), {
                language: language,
                audioDescription: audioDescription,
                normalized: normalizeLanguage(language)
            });
            var language, audioDescription;
        }
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/languages/normalize.ts
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return normalizeAudioTrack;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return normalizeTextTrack;
        });
        __webpack_exports__.a = normalizeLanguage;
        /***/    }, 
    /* 91 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isObject(x) {
            return null !== x && "object" == typeof x;
        }
        //# sourceMappingURL=isObject.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isObject;
        });
    }, 
    /* 92 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldUseWebKitMediaKeys;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // On Safari 12.1, it seems that since fairplay CDM implementation
        // within the browser is not standard with EME w3c current spec, the
        // requestMediaKeySystemAccess API doesn't resolve positively, even
        // if the drm (fairplay in most cases) is supported.
                function shouldUseWebKitMediaKeys() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.d && null != window.WebKitMediaKeys;
        }
        /***/    }, 
    /* 93 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeAll;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44), _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(157);
        /* harmony import */        
        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
        function mergeAll(concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.a, concurrent);
        }
        //# sourceMappingURL=mergeAll.js.map
        /***/    }, 
    /* 94 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isArrayLike;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArrayLike = function(x) {
            return x && "number" == typeof x.length && "function" != typeof x;
        };
        //# sourceMappingURL=isArrayLike.js.map
        /***/    }, 
    /* 95 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeToArray;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var subscribeToArray = function(array) {
            return function(subscriber) {
                for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
                subscriber.complete();
            };
        };
        //# sourceMappingURL=subscribeToArray.js.map
        /***/    }, 
    /* 96 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isPromise(value) {
            return !!value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        //# sourceMappingURL=isPromise.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPromise;
        });
    }, 
    /* 97 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isDate(value) {
            return value instanceof Date && !isNaN(+value);
        }
        //# sourceMappingURL=isDate.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isDate;
        });
    }, 
    /* 98 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return SubjectSubscription;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), SubjectSubscription = /* */ function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject, observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber);
                        -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
                    }
                }
            }, SubjectSubscription;
        }(__webpack_require__(16).a);
        /* harmony import */    }, 
    /* 99 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return PSSH_TO_INTEGER;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1), PSSH_TO_INTEGER = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.c)(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.p)("pssh"), 0);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // The way "pssh" will be written in ISOBMFF files
        }, 
    /* 100 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getFuzzedDelay;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        var FUZZ_FACTOR = .3;
        /**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */        function getFuzzedDelay(retryDelay) {
            return retryDelay * (1 + (2 * Math.random() - 1) * FUZZ_FACTOR);
 // Max 1.3 Min 0.7
                }
        /***/    }, 
    /* 101 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return disposeMediaKeys;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(169), _compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(208), _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0), _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
        function disposeMediaKeys(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__.a.getState(mediaElement);
                if (!currentState) return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(null);
                _log__WEBPACK_IMPORTED_MODULE_4__.a.debug("EME: Disposing of the current MediaKeys");
                var sessionsStore = currentState.sessionsStore;
                return _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__.a.clearState(mediaElement), 
                sessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(Object(_compat__WEBPACK_IMPORTED_MODULE_3__.a)(mediaElement, null)));
            });
        }
        /***/    }, 
    /* 102 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURL of the segment.
 * @param {Object} segment
 * @param {Array.<Object>} timescale
 * @param {number} timeline
 * @returns {Boolean|undefined}
 */
        function isSegmentStillAvailable(segment, timeline, timescale, indexTimeOffset) {
            if (timescale === segment.timescale) {
                for (var i = 0; i < timeline.length; i++) {
                    var tSegment = timeline[i], tSegmentTime = tSegment.start - indexTimeOffset;
                    if (tSegmentTime > segment.time) return !1;
                    if (tSegmentTime === segment.time) 
                    // there should be only one here
                    return tSegment.duration === segment.duration && (null == tSegment.range ? null == segment.range : null != segment.range && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1]);
                    // tSegment.start < segment.time
                    if (0 <= tSegment.repeatCount && null != tSegment.duration) {
                        var repeat = (tSegmentTime - tSegment.start) / tSegment.duration - 1;
                        return repeat % 1 == 0 && repeat <= tSegment.repeatCount;
                    }
                }
                return !1;
            }
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isSegmentStillAvailable;
        });
    }, 
    /* 103 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number}
 */
        function clearTimelineFromPosition(timeline, firstAvailablePosition) {
            for (;0 < timeline.length; ) {
                var firstElt = timeline[0];
                if (firstElt.start >= firstAvailablePosition) return;
 // all clear
                                if (firstElt.repeatCount <= 0) timeline.shift(); else {
                    // we have a segment repetition
                    var nextElt = timeline[1];
                    if (null != nextElt && nextElt.start <= firstAvailablePosition) timeline.shift(); else {
                        // no next segment or next segment is available
                        if (firstElt.duration <= 0) return;
                        for (var nextStart = firstElt.start + firstElt.duration, nextRepeat = 1; nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount; ) nextStart += firstElt.duration, 
                        nextRepeat++;
                        if (!(nextRepeat > firstElt.repeatCount)) {
                            // some repetitions start after and some before
                            var newRepeat = firstElt.repeatCount - nextRepeat;
                            return firstElt.start = nextStart, void (firstElt.repeatCount = newRepeat);
                        }
                        // every start is before
                        timeline.shift();
                    }
                }
            }
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return clearTimelineFromPosition;
        });
    }, 
    /* 104 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return checkManifestIDs;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
        function checkManifestIDs(manifest) {
            var periodIDS = [];
            manifest.periods.forEach(function(period) {
                var periodID = period.id;
                if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(periodIDS, periodID)) {
                    _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two periods with the same ID found. Updating.");
                    var newID = periodID + "-dup";
                    period.id = newID, checkManifestIDs(manifest), periodIDS.push(newID);
                } else periodIDS.push(periodID);
                var adaptations = period.adaptations, adaptationIDs = [];
                Object.keys(adaptations).forEach(function(type) {
                    (adaptations[type] || []).forEach(function(adaptation) {
                        var adaptationID = adaptation.id;
                        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(adaptationIDs, adaptationID)) {
                            _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two adaptations with the same ID found. Updating.", adaptationID);
                            var _newID = adaptationID + "-dup";
                            adaptation.id = _newID, checkManifestIDs(manifest), adaptationIDs.push(_newID);
                        } else adaptationIDs.push(adaptationID);
                        var representationIDs = [];
                        adaptation.representations.forEach(function(representation) {
                            var representationID = representation.id;
                            if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__.a)(representationIDs, representationID)) {
                                _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Two representations with the same ID found. Updating.", representationID);
                                var _newID2 = representationID + "-dup";
                                representation.id = _newID2, checkManifestIDs(manifest), representationIDs.push(_newID2);
                            } else representationIDs.push(representationID);
                        });
                    });
                });
            });
        }
        /***/    }, 
    /* 105 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
        function stringFromCharCode(args) {
            for (var ret = "", i = 0; i < args.length; i += 16e3) {
                var subArray = args.subarray(i, i + 16e3);
 // NOTE: ugly I know, but TS is problematic here (you can try)
                                ret += String.fromCharCode.apply(null, subArray);
            }
            return ret;
        }
        /**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */        function stringFromUTF8(data) {
            if (!data) return "";
            var uint8 = new Uint8Array(data);
 // If present, strip off the UTF-8 BOM.
                        239 === uint8[0] && 187 === uint8[1] && 191 === uint8[2] && (uint8 = uint8.subarray(3));
 // http://stackoverflow.com/a/13691499
                        var utf8 = stringFromCharCode(uint8), escaped = escape(utf8);
 // This converts each character in the string to an escape sequence.  If the
            // character is in the ASCII range, it is not converted; otherwise it is
            // converted to a URI escape sequence.
            // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
            // TODO "escape" is deprecated, provide a ponyfill?
                        // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
            // correct character.
            // Example: "g#%E3%82%AC" -> "g#"
            return decodeURIComponent(escaped);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return stringFromUTF8;
        });
    }, 
    /* 106 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
        /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */        function getCueBlocks(linified, headerOffset) {
            for (var cueBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__.c)(linified, i)) {
                var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__.a)(linified, i);
                cueBlocks.push(linified.slice(i, endOfCue)), i = endOfCue;
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return cueBlocks;
        }
        /***/    }, 
    /* 107 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return makeCue;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */
        function makeCue(startTime, endTime, payload) {
            if (!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__.e) throw new Error("VTT cues not supported in your target");
            return endTime <= startTime ? (
            // IE/Edge will throw in this case.
            // See issue #501
            _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Compat: Invalid cue times: " + startTime + " - " + endTime), 
            null) : new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__.e(startTime, endTime, payload);
        }
        /***/    }, 
    /* 108 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
        function getParameters(tt) {
            var parsedFrameRate = tt.getAttribute("ttp:frameRate"), parsedSubFrameRate = tt.getAttribute("ttp:subFramRate"), parsedTickRate = tt.getAttribute("ttp:tickRate"), parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier"), parsedSpaceStyle = tt.getAttribute("xml:space");
            if (parsedSpaceStyle && "default" !== parsedSpaceStyle && "preserve" !== parsedSpaceStyle) throw new Error("Invalid spacing style");
            var nbFrameRate = Number(parsedFrameRate) || 30, nbSubFrameRate = Number(parsedSubFrameRate) || 1, nbTickRate = Number(parsedTickRate) || 0, tickRate = nbTickRate, frameRate = nbFrameRate, subFrameRate = null != nbSubFrameRate ? nbSubFrameRate : 1, spaceStyle = parsedSpaceStyle || "default";
            if (0 === nbTickRate && (tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1), 
            parsedFrameRateMultiplier) {
                var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
                if (multiplierResults) frameRate = nbFrameRate * (Number(multiplierResults[1]) / Number(multiplierResults[2]));
            }
            return {
                tickRate: tickRate,
                frameRate: frameRate,
                subFrameRate: subFrameRate,
                spaceStyle: spaceStyle
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getParameters;
        });
    }, 
    /* 109 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return seekAndLoadOnMediaEvents;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(124), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(168), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(128), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(165), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(207), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(138), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(167), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44), _compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(110), _compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(132), _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(133), _log__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Emit once a "can-play" message as soon as the clock$ anounce that the content
 * can begin to be played.
 *
 * Warn you if the metadata is not yet loaded metadata by emitting a
 * "not-loaded-metadata" message first.
 * @param {Observable} clock$
 * @returns {Observable}
 */
        function canPlay(clock$, mediaElement) {
            var isLoaded$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(tick) {
                var seeking = tick.seeking, stalled = tick.stalled, readyState = tick.readyState, currentRange = tick.currentRange;
                return !seeking && null == stalled && (4 === readyState || 3 === readyState && null != currentRange) && (!Object(_compat__WEBPACK_IMPORTED_MODULE_9__.a)() || 0 < mediaElement.duration);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)("can-play"));
            return Object(_compat__WEBPACK_IMPORTED_MODULE_9__.a)() && 0 === mediaElement.duration ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("not-loaded-metadata"), isLoaded$) : isLoaded$;
        }
        /**
 * Try to play content then handle autoplay errors.
 * @param {HTMLMediaElement} - mediaElement
 * @returns {Observable}
 */        function autoPlay$(mediaElement) {
            return Object(_compat__WEBPACK_IMPORTED_MODULE_10__.a)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)("autoplay"), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(function(error) {
                if (error instanceof Error && "NotAllowedError" === error.name) 
                // auto-play was probably prevented.
                return _log__WEBPACK_IMPORTED_MODULE_12__.a.warn("Init: Media element can't play. It may be due to browser auto-play policies."), 
                Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("autoplay-blocked");
                throw error;
            }));
        }
        /**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {number|Function} startTime - Initial starting position. As seconds
 * or as a function returning seconds.
 * @param {boolean} autoPlay - Whether the player should auto-play
 * @returns {object}
 */        function seekAndLoadOnMediaEvents(clock$, mediaElement, startTime, mustAutoPlay) {
            var seek$ = Object(_compat__WEBPACK_IMPORTED_MODULE_11__.a)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function() {
                _log__WEBPACK_IMPORTED_MODULE_12__.a.info("Init: Set initial time", startTime), 
                mediaElement.currentTime = "function" == typeof startTime ? startTime() : startTime;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)({
                refCount: !0
            })), load$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(function() {
                return canPlay(clock$, mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function() {
                    return _log__WEBPACK_IMPORTED_MODULE_12__.a.info("Init: Can begin to play content");
                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(function(evt) {
                    return "can-play" === evt ? mustAutoPlay ? autoPlay$(mediaElement) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)("loaded") : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(evt);
                }));
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)({
                refCount: !0
            }));
            return {
                seek$: seek$,
                load$: load$
            };
        }
        /***/    }, 
    /* 110 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldValidateMetadata;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */        function shouldValidateMetadata() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.e;
        }
        /***/    }, 
    /* 111 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ArgumentOutOfRangeError;
        });
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var ArgumentOutOfRangeError = /* */ function() {
            function ArgumentOutOfRangeErrorImpl() {
                return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", 
                this;
            }
            return ArgumentOutOfRangeErrorImpl.prototype = /* */ Object.create(Error.prototype), 
            ArgumentOutOfRangeErrorImpl;
        }();
    }, 
    /* 112 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createEMEManager;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34), _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6), _compat___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(134), _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(80), _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10), _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0), onEncrypted$ = _compat___WEBPACK_IMPORTED_MODULE_3__.a.onEncrypted$;
        /* harmony import */        
        /**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @returns {Observable}
 */
        function createEMEManager(mediaElement, keySystems) {
            return null == _features__WEBPACK_IMPORTED_MODULE_6__.a.emeManager ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Encrypted event but EME feature not activated"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "EME feature not activated.");
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            })) : keySystems && keySystems.length ? Object(_compat___WEBPACK_IMPORTED_MODULE_4__.a)() ? (_log__WEBPACK_IMPORTED_MODULE_7__.a.debug("Init: Creating EMEManager"), 
            _features__WEBPACK_IMPORTED_MODULE_6__.a.emeManager(mediaElement, keySystems)) : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Encrypted event but no EME API available"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "Encryption APIs not found.");
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            })) : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                throw _log__WEBPACK_IMPORTED_MODULE_7__.a.error("Init: Ciphered media and no keySystem passed"), 
                new _errors__WEBPACK_IMPORTED_MODULE_5__.a("MEDIA_IS_ENCRYPTED_ERROR", "Media is encrypted and no `keySystems` given");
            })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                type: "eme-disabled"
            }));
        }
        /***/    }, 
    /* 113 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return refCount;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function refCount() {
            return function refCountOperatorFunction(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        var RefCountOperator = /* */ function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable;
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }, RefCountOperator;
        }(), RefCountSubscriber = /* */ function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null; else if (connectable._refCount = refCount - 1, 
                    1 < refCount) this.connection = null; else {
                        var connection = this.connection, sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
                    }
                } else this.connection = null;
            }, RefCountSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 114 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return throwOnMediaError;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(204), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44), _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @see MediaError
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function throwOnMediaError(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(mediaElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(function() {
                switch (mediaElement.error && mediaElement.error.code) {
                  case 1:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_ABORTED", "The fetching of the associated resource was aborted by the user's request.");

                  case 2:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_NETWORK", "A network error occurred which prevented the media from being successfully fetched");

                  case 3:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_DECODE", "An error occurred while trying to decode the media resource");

                  case 4:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_SRC_NOT_SUPPORTED", "The media resource has been found to be unsuitable.");

                  default:
                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.a("MEDIA_ERR_UNKNOWN", "The HTMLMediaElement errored due to an unknown reason.");
                }
            }));
        }
        /***/    }, 
    /* 115 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return updatePlaybackRate;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(205), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(164), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(125), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(138), _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$
 * @param {Object} options - Contains the following properties:
 *   - pauseWhenStalled {Boolean|undefined} - true if the player
 *     stalling should lead to a pause until it un-stalls. True by default.
 * @returns {Observable}
 */
        function updatePlaybackRate(mediaElement, speed$, clock$, _ref) {
            var _ref$pauseWhenStalled = _ref.pauseWhenStalled;
            return (void 0 === _ref$pauseWhenStalled || _ref$pauseWhenStalled ? clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(timing) {
                return !!timing.stalled;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(!1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()) : Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(!1)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(function(shouldForcePause) {
                return shouldForcePause ? Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(function() {
                    return _log__WEBPACK_IMPORTED_MODULE_7__.a.info("Init: Pause playback to build buffer"), 
                    mediaElement.playbackRate = 0, Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(0);
                }) : speed$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(function(speed) {
                    _log__WEBPACK_IMPORTED_MODULE_7__.a.info("Init: Resume playback speed", speed), 
                    mediaElement.playbackRate = speed;
                }));
            }));
        }
        /***/    }, 
    /* 116 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getStalledEvents;
        });
        /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(170), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(164);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} clock$
 * @returns {Observable}
 */
        function getStalledEvents(clock$) {
            return clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.a)(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(function(tick) {
                return tick.stalled;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(function(wasStalled, isStalled) {
                return !wasStalled && !isStalled || !!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason;
            }));
        }
        /***/    }, 
    /* 117 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the received EME-related event indicate that we can begin to
 * load the content.
 * @param {Object} emeEvent
 * @returns {Boolean}
 */
        function isEMEReadyEvent(emeEvent) {
            return "eme-disabled" === emeEvent.type || "attached-media-keys" === emeEvent.type || "created-media-keys" === emeEvent.type && !0 === emeEvent.value.keySystemOptions.disableMediaKeysAttachmentLock;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isEMEReadyEvent;
        });
    }, 
    /* 118 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
                function subscribeToPromise(promise) {
            return function(subscriber) {
                return promise.then(function(value) {
                    subscriber.closed || (subscriber.next(value), subscriber.complete());
                }, function(err) {
                    return subscriber.error(err);
                }).then(null, hostReportError.a), subscriber;
            };
        }
        function subscribeToIterable(iterable) {
            return function(subscriber) {
                for (var iterator = iterable[symbol_iterator.a](); ;) {
                    var item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(function() {
                    iterator.return && iterator.return();
                }), subscriber;
            };
        }
        function subscribeToObservable(obj) {
            return function(subscriber) {
                var obs = obj[observable.a]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            };
        }
        var subscribeToArray = __webpack_require__(95), hostReportError = __webpack_require__(58), symbol_iterator = __webpack_require__(61), observable = __webpack_require__(48), isArrayLike = __webpack_require__(94), isPromise = __webpack_require__(96), isObject = __webpack_require__(91);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/hostReportError.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeTo;
        });
        /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
        var subscribeTo = function(result) {
            if (result && "function" == typeof result[observable.a]) return subscribeToObservable(result);
            if (Object(isArrayLike.a)(result)) return Object(subscribeToArray.a)(result);
            if (Object(isPromise.a)(result)) return subscribeToPromise(result);
            if (result && "function" == typeof result[symbol_iterator.a]) return subscribeToIterable(result);
            var value = Object(isObject.a)(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
        };
        //# sourceMappingURL=subscribeTo.js.map
        /***/    }, 
    /* 119 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */        function findEndOfCueBlock(linified, startIndex) {
            // continue incrementing i until either:
            //   - an empty line
            //   - the end
            for (var firstEmptyLineIndex = startIndex + 1; linified[firstEmptyLineIndex]; ) firstEmptyLineIndex++;
            return firstEmptyLineIndex;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
        function getCueBlocks(linified) {
            for (var cueBlocks = [], i = 0; i < linified.length; i++) if (linified[i]) {
                var endOfCue = findEndOfCueBlock(linified, i), cueBlockCandidate = linified.slice(i, endOfCue);
                0 < cueBlockCandidate.length && (1 === cueBlockCandidate.length ? 0 <= cueBlockCandidate[0].indexOf("--\x3e") && cueBlocks.push(cueBlockCandidate) : (0 <= cueBlockCandidate[1].indexOf("--\x3e") || 0 <= cueBlockCandidate[0].indexOf("--\x3e")) && cueBlocks.push(cueBlockCandidate)), 
                i = endOfCue;
            }
            return cueBlocks;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCueBlocks;
        });
    }, 
    /* 120 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":");
            if (splittedTS[2]) {
                var hours = parseInt(splittedTS[0], 10), minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[2].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
        function parseCueBlock(cueLines, timeOffset) {
            if (0 === cueLines.length) return null;
            var startTimeString, endTimeString, payload = [];
            // normally in srt, the timing is at second position.
            // We still authorize to put it in the first position for resilience
            if (cueLines[1] && cueLines[1].indexOf("--\x3e")) {
                var _cueLines$1$split$map = cueLines[1].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$1$split$map[0], endTimeString = _cueLines$1$split$map[1], 
                payload = cueLines.slice(2, cueLines.length);
            }
            if (!startTimeString || !endTimeString) {
                // Try to see if we find them in the first position
                var _cueLines$0$split$map = cueLines[0].split("--\x3e").map(function(s) {
                    return s.trim();
                });
                startTimeString = _cueLines$0$split$map[0], endTimeString = _cueLines$0$split$map[1], 
                payload = cueLines.slice(1, cueLines.length);
            }
            if (!startTimeString || !endTimeString) 
            // if the time is still not found, exit
            return null;
            var start = parseTimestamp(startTimeString), end = parseTimestamp(endTimeString);
            return null == start || null == end ? null : {
                start: start + timeOffset,
                end: end + timeOffset,
                payload: payload
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 121 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
                var request = __webpack_require__(18), Observable = __webpack_require__(8);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                // CONCATENATED MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
            return function(args) {
                return new Observable.a(function(obs) {
                    var url = args.url, timeAPIsDelta = Date.now() - performance.now(), hasFinished = !1, hasFallbacked = !1, abort = customManifestLoader(url, {
                        reject: function reject(err) {
                            hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            if (!hasFallbacked) {
                                hasFinished = !0;
                                var receivedTime = null != _args.receivingTime ? _args.receivingTime - timeAPIsDelta : void 0, sendingTime = null != _args.sendingTime ? _args.sendingTime - timeAPIsDelta : void 0;
                                obs.next({
                                    type: "data-loaded",
                                    value: {
                                        responseData: _args.data,
                                        size: _args.size,
                                        duration: _args.duration,
                                        url: _args.url,
                                        receivedTime: receivedTime,
                                        sendingTime: sendingTime
                                    }
                                }), obs.complete();
                            }
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, fallbackManifestLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                });
            };
        }
        // CONCATENATED MODULE: ./src/transports/utils/document_manifest_loader.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @returns {Observable}
 */
        function regularManifestLoader(_ref) {
            var url = _ref.url;
            if (null == url) throw new Error("Cannot perform HTTP(s) request. URL not known");
            return Object(request.a)({
                url: url,
                responseType: "document"
            });
        }
        /**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */        function generateManifestLoader(_ref2) {
            var customManifestLoader = _ref2.customManifestLoader;
            return null == customManifestLoader ? regularManifestLoader : callCustomManifestLoader(customManifestLoader, regularManifestLoader);
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return generateManifestLoader;
        });
    }, 
    /* 122 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */        function parseTimestamp(timestampString) {
            var splittedTS = timestampString.split(":").reverse();
            if (splittedTS[2] || splittedTS[1]) {
                var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0, minutes = parseInt(splittedTS[1], 10), seconds = parseFloat(splittedTS[0].replace(",", "."));
                if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
                return 60 * hours * 60 + 60 * minutes + seconds;
            }
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
        function parseSettings(settingsString) {
            return settingsString.split(/ |\t/).reduce(function(acc, setting) {
                var splittedSetting = setting.split(":");
                return 2 === splittedSetting.length && (acc[splittedSetting[0]] = splittedSetting[1]), 
                acc;
            }, {});
        }
        /**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */        function parseTimeAndSettings(timeString) {
            /**
   * RegExp for the timestamps + settings line.
   *
   * Capture groups:
   *   1 -> start timestamp
   *   2 -> end timestamp
   *   3 - settings
   * @type {RegExp}
   */
            var matches = timeString.match(/^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/);
            if (!matches) return null;
            var start = parseTimestamp(matches[1]), end = parseTimestamp(matches[2]);
            return null == start || null == end ? null : {
                start: start,
                end: end,
                settings: parseSettings(matches[3])
            };
        }
        /**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */        function parseCueBlock(cueLines, timeOffset) {
            var timeString, payload, header, timingRegexp = /-->/;
            if (timingRegexp.test(cueLines[0])) timeString = cueLines[0], payload = cueLines.slice(1, cueLines.length); else {
                if (!timingRegexp.test(cueLines[1])) 
                // not a cue
                return null;
                header = cueLines[0], timeString = cueLines[1], payload = cueLines.slice(2, cueLines.length);
            }
            var timeAndSettings = parseTimeAndSettings(timeString);
            return timeAndSettings ? {
                start: timeAndSettings.start + timeOffset,
                end: timeAndSettings.end + timeOffset,
                settings: timeAndSettings.settings,
                payload: payload,
                header: header
            } : null;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseCueBlock;
        });
    }, 
    /* 123 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
                var regexps = __webpack_require__(21);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */        
        /**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
        function parseFramesTime(ttParams, text) {
            // 75f or 75.5f
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.g.exec(text);
            return Number(results[1]) / ttParams.frameRate;
        }
        /**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseTickTime(ttParams, text) {
            // 50t or 50.5t
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.i.exec(text);
            return Number(results[1]) / ttParams.tickRate;
        }
        /**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */        function parseColonTimeWithFrames(ttParams, text) {
            // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
            // (We cast as we're sure the regexp is respected here)
            var results = regexps.e.exec(text), hours = Number(results[1]), minutes = Number(results[2]), seconds = Number(results[3]), frames = Number(results[4]);
            return (seconds += (frames += (Number(results[5]) || 0) / ttParams.subFrameRate) / ttParams.frameRate) + 60 * minutes + 3600 * hours;
        }
        /**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */        function parseTimeFromRegExp(regex, text) {
            var results = regex.exec(text);
            if (null === results || "" === results[0]) return null;
 // This capture is optional, but will still be in the array as undefined,
            // default to 0.
                        var hours = Number(results[1]) || 0, minutes = Number(results[2]) || 0, seconds = Number(results[3]) || 0;
            return (Number(results[4]) || 0) / 1e3 + seconds + 60 * minutes + 3600 * hours;
        }
        /* harmony default export */        var time_parsing = function parseTime(text, ttParams) {
            return regexps.e.test(text) ? parseColonTimeWithFrames(ttParams, text) : regexps.d.test(text) ? parseTimeFromRegExp(regexps.d, text) : regexps.f.test(text) ? parseTimeFromRegExp(regexps.f, text) : regexps.g.test(text) ? parseFramesTime(ttParams, text) : regexps.i.test(text) ? parseTickTime(ttParams, text) : regexps.h.test(text) ? parseTimeFromRegExp(regexps.h, text) : void 0;
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
        function getTimeDelimiters(element, ttParams) {
            var beginAttr = element.getAttribute("begin"), durationAttr = element.getAttribute("dur"), endAttr = element.getAttribute("end"), start = beginAttr ? time_parsing(beginAttr, ttParams) : null, duration = durationAttr ? time_parsing(durationAttr, ttParams) : null, parsedEnd = endAttr ? time_parsing(endAttr, ttParams) : null;
            if (null == start || null == parsedEnd && null == duration) throw new Error("Invalid text cue");
 // Huh? Is TypeScript that dumb here?
                        return {
                start: start,
                end: null == parsedEnd ? start + duration : parsedEnd
            };
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getTimeDelimiters;
        });
    }, 
    /* 124 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concat;
        });
        /* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23), _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(158);
        /* harmony import */        
        /** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
        function concat() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__.a)()(_of__WEBPACK_IMPORTED_MODULE_0__.a.apply(void 0, observables));
        }
        //# sourceMappingURL=concat.js.map
        /***/    }, 
    /* 125 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24), _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34), _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? function(source) {
                return source.pipe(switchMap(function(a, i) {
                    return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new SwitchMapOperator(project));
            };
        }
        var SwitchMapOperator = /* */ function() {
            function SwitchMapOperator(project) {
                this.project = project;
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            }, SwitchMapOperator;
        }(), SwitchMapSubscriber = /* */ function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }, SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, value, index, innerSubscriber);
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this), 
                this.unsubscribe();
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = null;
            }, SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.innerSubscription = null, this.isStopped && _super.prototype._complete.call(this);
            }, SwitchMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, SwitchMapSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 126 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "c", function() {
            return getTRAF;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getMDAT;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDIA;
        });
        /* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getTRAF(buffer) {
            var moof = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buffer, 1836019558
            /* moof */);
            return moof ? Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(moof, 1953653094
            /* traf */) : null;
        }
        /**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDAT(buf) {
            return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buf, 1835295092
            /* "mdat" */);
        }
        /**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */        function getMDIA(buf) {
            var moov = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(buf, 1836019574
            /* moov */);
            if (!moov) return null;
            var trak = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(moov, 1953653099
            /* "trak" */);
            return trak ? Object(_get_box__WEBPACK_IMPORTED_MODULE_0__.b)(trak, 1835297121
            /* "mdia" */) : null;
        }
        /***/    }, 
    /* 127 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return RequestError;
        });
        var RequestError = 
        /* */
        function(_Error) {
            /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
            function RequestError(url, status, type, xhr) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), RequestError.prototype), _this.name = "RequestError", 
                _this.url = url, _this.xhr = xhr, _this.status = status, _this.type = type, _this.message = type, 
                _this;
            }
            return _inheritsLoose(RequestError, _Error), RequestError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 128 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return take;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(111), _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function take(count) {
            return function(source) {
                return 0 === count ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__.b)() : source.lift(new TakeOperator(count));
            };
        }
        var TakeOperator = /* */ function() {
            function TakeOperator(total) {
                if (this.total = total, this.total < 0) throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.a();
            }
            return TakeOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TakeSubscriber(subscriber, this.total));
            }, TakeOperator;
        }(), TakeSubscriber = /* */ function(_super) {
            function TakeSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeSubscriber, _super), TakeSubscriber.prototype._next = function(value) {
                var total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }, TakeSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 129 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        function isFunction(fn) {
            return "function" == typeof fn && "[object Function]" === toStr.call(fn);
        }
        function defineProperty(object, name, value, predicate) {
            name in object && (!isFunction(predicate) || !predicate()) || (supportsDescriptors ? origDefineProperty(object, name, {
                configurable: !0,
                enumerable: !1,
                value: value,
                writable: !0
            }) : object[name] = value);
        }
        function defineProperties(object, map) {
            var predicates = 2 < arguments.length ? arguments[2] : {}, props = keys(map);
            hasSymbols && (props = concat.call(props, Object.getOwnPropertySymbols(map)));
            for (var i = 0; i < props.length; i += 1) defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
        var keys = __webpack_require__(148), hasSymbols = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), toStr = Object.prototype.toString, concat = Array.prototype.concat, origDefineProperty = Object.defineProperty, supportsDescriptors = origDefineProperty && function() {
            var obj = {};
            try {
                // eslint-disable-next-line no-unused-vars, no-restricted-syntax
                for (var _ in origDefineProperty(obj, "x", {
                    enumerable: !1,
                    value: obj
                }), obj) // jscs:ignore disallowUnusedVariables
                return !1;
                return obj.x === obj;
            } catch (e) {
                /* this is IE 8. */
                return !1;
            }
        }();
        defineProperties.supportsDescriptors = !!supportsDescriptors, module.exports = defineProperties;
    }, 
    /* 130 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldUnsetMediaKeys;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */        function shouldUnsetMediaKeys() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.b;
        }
        /***/    }, 
    /* 131 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return setElementSrc$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), _clear_element_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */
        function setElementSrc$(mediaElement, url) {
            return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(function(observer) {
                return _log__WEBPACK_IMPORTED_MODULE_1__.a.info("Setting URL to Element", url, mediaElement), 
                mediaElement.src = url, observer.next(void 0), function() {
                    Object(_clear_element_src__WEBPACK_IMPORTED_MODULE_2__.a)(mediaElement);
                };
            });
        }
        /***/    }, 
    /* 132 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return play$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82), _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17), _utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function play$(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                // mediaElement.play is not always a Promise. In the improbable case it
                // throws, I prefer still to catch to return the error wrapped in an
                // Observable
                return Object(_utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__.a)(function() {
                    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__.a)(mediaElement.play());
                }, void 0);
            });
        }
        /***/    }, 
    /* 133 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return whenLoadedMetadata$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(128), _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22), _event_listeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function whenLoadedMetadata$(mediaElement) {
            return mediaElement.readyState >= _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__.d.HAVE_METADATA ? Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(null) : Object(_event_listeners__WEBPACK_IMPORTED_MODULE_3__.onLoadedMetadata$)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(1));
        }
        /***/    }, 
    /* 134 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return hasEMEAPIs;
        });
        /* harmony import */ var _eme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */        function hasEMEAPIs() {
            return "function" == typeof _eme__WEBPACK_IMPORTED_MODULE_0__.c;
        }
        /***/    }, 
    /* 135 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createSession;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return requestMediaKeySystemAccess;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(166), _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1), _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17), _utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(38), _utils_promise__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(29), _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(22), _browser_detection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(20), _event_listeners__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(46), _should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(92), _custom_key_system_access__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(136);
        /* harmony import */        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var requestMediaKeySystemAccess = null;
        var createSession = function createMediaKeysSession(mediaKeys, sessionType) {
            return mediaKeys.createSession(sessionType);
        }, CustomMediaKeys = 
        /* */
        function() {
            function CustomMediaKeys() {}
            var _proto = CustomMediaKeys.prototype;
            return _proto._setVideo = function _setVideo() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.createSession = function createSession() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, _proto.setServerCertificate = function setServerCertificate() {
                throw new Error("MediaKeys is not implemented in your browser");
            }, CustomMediaKeys;
        }();
 // Default CustomMediaKeys implementation
                /**
 * Since Safari 12.1, EME APIs are available without webkit prefix.
 * However, it seems that since fairplay CDM implementation within the browser is not
 * standard with EME w3c current spec, the requestMediaKeySystemAccess API doesn't resolve
 * positively, even if the drm (fairplay in most cases) is supported.
 *
 * Therefore, we prefer not to use requestMediaKeySystemAccess on Safari when webkit API
 * is available.
 */
        if (navigator.requestMediaKeySystemAccess && !Object(_should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_12__.a)()) requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
            return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__.a)(navigator.requestMediaKeySystemAccess(a, b));
        }; else {
            // Wrap "MediaKeys.prototype.update" form an event based system to a
            // Promise based function.
            var wrapUpdate = function wrapUpdate(memUpdate) {
                return function(license, sessionId) {
                    var _this = this;
                    return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve, reject) {
                        try {
                            memUpdate.call(_this, license, sessionId || ""), resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                };
            }, isOldWebkitMediaElement = function isOldWebkitMediaElement(element) {
                return "function" == typeof element.webkitGenerateKeyRequest;
            };
            /**
   * Returns true if the given media element has old webkit methods
   * corresponding to the IOldWebkitHTMLMediaElement interface.
   * @param {HTMLMediaElement} element
   * @returns {Boolean}
   */            // This is for Chrome with unprefixed EME api
            if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
                var WebkitMediaKeySession = 
                /* */
                function(_EventEmitter) {
                    function WebkitMediaKeySession(mediaElement, keySystem) {
                        var _this2;
                        return (_this2 = _EventEmitter.call(this) || this)._closeSession$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(), 
                        _this2._vid = mediaElement, _this2._key = keySystem, _this2.sessionId = "", _this2.closed = new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            _this2._closeSession$.subscribe(resolve);
                        }), _this2.keyStatuses = new Map(), _this2.expiration = NaN, Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyMessage$(mediaElement), _event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyAdded$(mediaElement), _event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyError$(mediaElement)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(_this2._closeSession$)).subscribe(function(evt) {
                            return _this2.trigger(evt.type, evt);
                        }), _this2.update = wrapUpdate(function(license, sessionId) {
                            if (!isOldWebkitMediaElement(_this2._vid)) throw new Error("impossible to add a new key");
                            if (0 <= _this2._key.indexOf("clearkey")) {
                                var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license, json = JSON.parse(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__.f)(licenseTypedArray)), key = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__.p)(atob(json.keys[0].k)), kid = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__.p)(atob(json.keys[0].kid));
                                _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
                            } else _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
                            _this2.sessionId = sessionId;
                        }), _this2;
                    }
                    _inheritsLoose(WebkitMediaKeySession, _EventEmitter);
                    var _proto2 = WebkitMediaKeySession.prototype;
                    return _proto2.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this3 = this;
                        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            if (!isOldWebkitMediaElement(_this3._vid)) throw new Error("impossible to generate a key request");
                            _this3._vid.webkitGenerateKeyRequest(_this3._key, initData), resolve();
                        });
                    }, _proto2.close = function close() {
                        var _this4 = this;
                        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            _this4._closeSession$.next(), _this4._closeSession$.complete(), resolve();
                        });
                    }, _proto2.load = function load() {
                        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a.resolve(!1);
                    }, _proto2.remove = function remove() {
                        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a.resolve();
                    }, WebkitMediaKeySession;
                }(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__.a);
                CustomMediaKeys = 
                /* */
                function() {
                    function CustomMediaKeys(keySystem) {
                        this.ks_ = keySystem;
                    }
                    var _proto3 = CustomMediaKeys.prototype;
                    return _proto3._setVideo = function _setVideo(vid) {
                        this._vid = vid;
                    }, _proto3.createSession = function createSession() {
                        if (!this._vid) throw new Error("Video not attached to the MediaKeys");
                        return new WebkitMediaKeySession(this._vid, this.ks_);
                    }, _proto3.setServerCertificate = function setServerCertificate() {
                        throw new Error("Server certificate is not implemented in your browser");
                    }, CustomMediaKeys;
                }();
                var isTypeSupported = function isTypeSupported(keyType) {
                    // get any <video> element from the DOM or create one
                    // and try the `canPlayType` method
                    var videoElement = document.querySelector("video") || document.createElement("video");
                    return !(!videoElement || !videoElement.canPlayType) && !!videoElement.canPlayType("video/mp4", keyType);
                };
                requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                    if (!isTypeSupported(keyType)) return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(void 0);
                    for (var i = 0; i < keySystemConfigurations.length; i++) {
                        var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState, supported = !0;
                        if (supported = (supported = (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(initDataType) {
                            return "cenc" === initDataType;
                        })[0])) && (!sessionTypes || sessionTypes.filter(function(sessionType) {
                            return "temporary" === sessionType;
                        }).length === sessionTypes.length)) && "required" !== distinctiveIdentifier) && "required" !== persistentState) {
                            var keySystemConfigurationResponse = {
                                videoCapabilities: videoCapabilities,
                                audioCapabilities: audioCapabilities,
                                initDataTypes: [ "cenc" ],
                                sessionTypes: [ "temporary" ],
                                distinctiveIdentifier: "not-allowed",
                                persistentState: "not-allowed"
                            };
                            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(new _custom_key_system_access__WEBPACK_IMPORTED_MODULE_13__.a(keyType, new CustomMediaKeys(keyType), keySystemConfigurationResponse));
                        }
                    }
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(void 0);
                };
            } else if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b && _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b.prototype && "function" == typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b.isTypeSupported && (requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
                // TODO Why TS Do not understand that isTypeSupported exists here?
                if (!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b.isTypeSupported(keyType)) return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(void 0);
                for (var i = 0; i < keySystemConfigurations.length; i++) {
                    var keySystemConfiguration = keySystemConfigurations[i], videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, supported = !0;
                    if (supported = (supported = supported && (!initDataTypes || !!initDataTypes.filter(function(idt) {
                        return "cenc" === idt;
                    })[0])) && "required" !== distinctiveIdentifier) {
                        var keySystemConfigurationResponse = {
                            videoCapabilities: videoCapabilities,
                            audioCapabilities: audioCapabilities,
                            initDataTypes: [ "cenc" ],
                            distinctiveIdentifier: "not-allowed",
                            persistentState: "required",
                            sessionTypes: [ "temporary", "persistent-license" ]
                        };
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(new _custom_key_system_access__WEBPACK_IMPORTED_MODULE_13__.a(keyType, new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b(keyType), keySystemConfigurationResponse));
                    }
                }
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(void 0);
            }, _browser_detection__WEBPACK_IMPORTED_MODULE_10__.b && "function" == typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__.b.prototype.createSession)) {
                var IE11MediaKeySession = 
                /* */
                function(_EventEmitter2) {
                    function IE11MediaKeySession(mk) {
                        var _this5;
                        return (_this5 = _EventEmitter2.call(this) || this).sessionId = "", _this5.expiration = NaN, 
                        _this5.keyStatuses = new Map(), _this5._mk = mk, _this5._closeSession$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(), 
                        _this5.closed = new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            _this5._closeSession$.subscribe(resolve);
                        }), _this5.update = wrapUpdate(function(license, sessionId) {
                            if (!_this5._ss) throw new Error("MediaKeySession not set");
                            _this5._ss.update(license, sessionId), _this5.sessionId = sessionId;
                        }), _this5;
                    }
                    _inheritsLoose(IE11MediaKeySession, _EventEmitter2);
                    var _proto4 = IE11MediaKeySession.prototype;
                    return _proto4.generateRequest = function generateRequest(_initDataType, initData) {
                        var _this6 = this;
                        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            _this6._ss = _this6._mk.createSession("video/mp4", initData), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyMessage$(_this6._ss), _event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyAdded$(_this6._ss), _event_listeners__WEBPACK_IMPORTED_MODULE_11__.onKeyError$(_this6._ss)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(_this6._closeSession$)).subscribe(function(evt) {
                                return _this6.trigger(evt.type, evt);
                            }), resolve();
                        });
                    }, _proto4.close = function close() {
                        var _this7 = this;
                        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a(function(resolve) {
                            _this7._ss && (
                            /* tslint:disable no-floating-promises */
                            _this7._ss.close(), 
                            /* tslint:enable no-floating-promises */
                            _this7._ss = void 0), _this7._closeSession$.next(), _this7._closeSession$.complete(), 
                            resolve();
                        });
                    }, _proto4.load = function load() {
                        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a.resolve(!1);
                    }, _proto4.remove = function remove() {
                        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__.a.resolve();
                    }, IE11MediaKeySession;
                }(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__.a);
                createSession = function createIE11MediaKeySession(mediaKeys) {
                    return new IE11MediaKeySession(mediaKeys);
                };
            }
        }
        /* harmony default export */        __webpack_exports__.b = CustomMediaKeys;
    }, 
    /* 136 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return CustomMediaKeySystemAccess;
        });
        /* harmony import */ var _utils_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */        var CustomMediaKeySystemAccess = 
        /* */
        function() {
            /**
   * @param {string} _keyType - type of key system (e.g. "widevine" or
   * "com.widevine.alpha").
   * @param {Object} _mediaKeys - MediaKeys implementation
   * @param {Object} _configuration - Configuration accepted for this
   * MediaKeySystemAccess.
   */
            function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
                this._keyType = _keyType, this._mediaKeys = _mediaKeys, this._configuration = _configuration;
            }
            /**
   * @returns {string} - current key system type (e.g. "widevine" or
   * "com.widevine.alpha").
   */            var _proto = CustomMediaKeySystemAccess.prototype;
            /**
   * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
   * MediaKeySystemAccess. Never rejects.
   */            return _proto.createMediaKeys = function createMediaKeys() {
                var _this = this;
                return new _utils_promise__WEBPACK_IMPORTED_MODULE_0__.a(function(res) {
                    return res(_this._mediaKeys);
                });
            }
            /**
   * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
   */ , _proto.getConfiguration = function getConfiguration() {
                return this._configuration;
            }, _createClass(CustomMediaKeySystemAccess, [ {
                key: "keySystem",
                get: function get() {
                    return this._keyType;
                }
            } ]), CustomMediaKeySystemAccess;
        }();
        /***/    }, 
    /* 137 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return ignoreElements;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function ignoreElements() {
            return function ignoreElementsOperatorFunction(source) {
                return source.lift(new IgnoreElementsOperator());
            };
        }
        var IgnoreElementsOperator = /* */ function() {
            function IgnoreElementsOperator() {}
            return IgnoreElementsOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new IgnoreElementsSubscriber(subscriber));
            }, IgnoreElementsOperator;
        }(), IgnoreElementsSubscriber = /* */ function(_super) {
            function IgnoreElementsSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(IgnoreElementsSubscriber, _super), IgnoreElementsSubscriber.prototype._next = function(unused) {}, 
            IgnoreElementsSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 138 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tap;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7), _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43), _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
        function tap(nextOrObserver, error, complete) {
            return function tapOperatorFunction(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        var DoOperator = /* */ function() {
            function DoOperator(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            return DoOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }, DoOperator;
        }(), TapSubscriber = /* */ function(_super) {
            function TapSubscriber(destination, observerOrNext, error, complete) {
                var _this = _super.call(this, destination) || this;
                return _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.a)(observerOrNext) ? (_this._context = _this)._tapNext = observerOrNext : observerOrNext && (_this._context = observerOrNext, 
                _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a, 
                _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__.a), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TapSubscriber, _super), TapSubscriber.prototype._next = function(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }, TapSubscriber.prototype._error = function(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }, TapSubscriber.prototype._complete = function() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }, TapSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 139 */ 
    /* 140 */
    /***/ , 
    /* 140 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shouldRenewMediaKeys;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */        function shouldRenewMediaKeys() {
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.b;
        }
        /***/    }, 
    /* 141 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return clearEMESession;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(137), _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(130), _dispose_media_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101), _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @returns {Observable}
 */
        function clearEMESession(mediaElement) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                if (Object(_compat___WEBPACK_IMPORTED_MODULE_3__.a)()) return Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_4__.a)(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)());
                var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__.a.getState(mediaElement);
                return currentState && currentState.keySystemOptions.closeSessionsOnStop ? currentState.sessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)()) : rxjs__WEBPACK_IMPORTED_MODULE_1__.a;
            });
        }
        /***/    }, 
    /* 142 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return disposeEME;
        });
        /* harmony import */ var _utils_noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28), _dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Free up all ressources taken by the EME management.
 */
        function disposeEME(mediaElement) {
            Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__.a)(mediaElement).subscribe(_utils_noop__WEBPACK_IMPORTED_MODULE_0__.a);
        }
        /***/    }, 
    /* 143 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getCurrentKeySystem;
        });
        /* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the name of the current key system used.
 * @param {HTMLMediaElement} mediaElement
 * @returns {string}
 */        function getCurrentKeySystem(mediaElement) {
            var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__.a.getState(mediaElement);
            return currentState && currentState.keySystemOptions.type;
        }
        /***/    }, 
    /* 144 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isCodecSupported;
        });
        /* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */        function isCodecSupported(codec) {
            return !!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c && (
            /* tslint:disable no-unbound-method */
            "function" != typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c.isTypeSupported || _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__.c.isTypeSupported(codec));
        }
        /***/    }, 
    /* 145 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return canPatchISOBMFFSegment;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */        function canPatchISOBMFFSegment() {
            return !_browser_detection__WEBPACK_IMPORTED_MODULE_0__.c;
        }
        /***/    }, 
    /* 146 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return addTextTrack;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */        function addTextTrack(mediaElement, hidden) {
            var track, trackElement;
            if (_browser_detection__WEBPACK_IMPORTED_MODULE_0__.c) {
                var tracksLength = mediaElement.textTracks.length;
                (track = 0 < tracksLength ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack("subtitles")).mode = hidden ? track.HIDDEN : track.SHOWING;
            } else trackElement = document.createElement("track"), mediaElement.appendChild(trackElement), 
            track = trackElement.track, trackElement.kind = "subtitles", track.mode = hidden ? "hidden" : "showing";
            return {
                track: track,
                trackElement: trackElement
            };
        }
        /***/    }, 
    /* 147 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
        function isVTTCue(cue) {
            return "function" == typeof window.VTTCue && cue instanceof window.VTTCue;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isVTTCue;
        });
    }, 
    /* 148 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var slice = Array.prototype.slice, isArgs = __webpack_require__(149), origKeys = Object.keys, keysShim = origKeys ? function keys(o) {
            return origKeys(o);
        } : __webpack_require__(184), originalKeys = Object.keys;
        keysShim.shim = function shimObjectKeys() {
            Object.keys ? function() {
                // Safari 5.0 bug
                var args = Object.keys(arguments);
                return args && args.length === arguments.length;
            }(1, 2) || (Object.keys = function keys(object) {
                // eslint-disable-line func-name-matching
                return isArgs(object) ? originalKeys(slice.call(object)) : originalKeys(object);
            }) : Object.keys = keysShim;
            return Object.keys || keysShim;
        }, module.exports = keysShim;
    }, 
    /* 149 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var toStr = Object.prototype.toString;
        module.exports = function isArguments(value) {
            var str = toStr.call(value), isArgs = "[object Arguments]" === str;
            return isArgs = isArgs || "[object Array]" !== str && null !== value && "object" == typeof value && "number" == typeof value.length && 0 <= value.length && "[object Function]" === toStr.call(value.callee);
        };
    }, 
    /* 150 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var toObject = Object, TypeErr = TypeError;
        module.exports = function flags() {
            if (null != this && this !== toObject(this)) throw new TypeErr("RegExp.prototype.flags getter called on non-object");
            var result = "";
            return this.global && (result += "g"), this.ignoreCase && (result += "i"), this.multiline && (result += "m"), 
            this.dotAll && (result += "s"), this.unicode && (result += "u"), this.sticky && (result += "y"), 
            result;
        };
    }, 
    /* 151 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var implementation = __webpack_require__(150), supportsDescriptors = __webpack_require__(129).supportsDescriptors, gOPD = Object.getOwnPropertyDescriptor, TypeErr = TypeError;
        module.exports = function getPolyfill() {
            if (!supportsDescriptors) throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
            if ("gim" === /a/gim.flags) {
                var descriptor = gOPD(RegExp.prototype, "flags");
                if (descriptor && "function" == typeof descriptor.get && "boolean" == typeof /a/.dotAll) return descriptor.get;
            }
            return implementation;
        };
    }, 
    /* 152 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
        function isOffline() {
            /* tslint:disable no-boolean-literal-compare */
            return !1 === navigator.onLine;
            /* tslint:enable no-boolean-literal-compare */        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isOffline;
        });
    }, 
    /* 153 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */
        function areSameContent(content1, content2) {
            return content1.segment.id === content2.segment.id && content1.representation.id === content2.representation.id && content1.adaptation.id === content2.adaptation.id && content1.period.id === content2.period.id;
        }
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return areSameContent;
        });
    }, 
    /* 154 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return tryToChangeSourceBufferType;
        });
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */        function tryToChangeSourceBufferType(sourceBuffer, codec) {
            if ("function" != typeof sourceBuffer.changeType) return !1;
            try {
                sourceBuffer.changeType(codec);
            } catch (e) {
                return _log__WEBPACK_IMPORTED_MODULE_0__.a.warn("Could not call 'changeType' on the given SourceBuffer:", e), 
                !1;
            }
            return !0;
        }
        /***/    }, 
    /* 155 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return isPlaybackStuck;
        });
        /* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */        function isPlaybackStuck(time, currentRange, state, isStalled) {
            // freeze threshold in seconds
            return _browser_detection__WEBPACK_IMPORTED_MODULE_0__.a && isStalled && "timeupdate" === state && !!currentRange && 10 < currentRange.end - time;
        }
        /***/    }, 
    /* 156 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/core/eme/clear_eme_session.ts
        var clear_eme_session = __webpack_require__(141), dispose_eme = __webpack_require__(142), combineLatest = __webpack_require__(213), empty = __webpack_require__(55), merge = __webpack_require__(81), concat = __webpack_require__(124), of = __webpack_require__(23), shareReplay = __webpack_require__(167), filter = __webpack_require__(168), tap = __webpack_require__(138), map = __webpack_require__(34), mergeMap = __webpack_require__(44), catchError = __webpack_require__(207), ignoreElements = __webpack_require__(137), compat = __webpack_require__(6), get_init_data = __webpack_require__(215), generate_key_request = __webpack_require__(216), encrypted_media_error = __webpack_require__(80), log = __webpack_require__(0), defer = __webpack_require__(82), config = __webpack_require__(3), array_includes = __webpack_require__(12), cast_to_observable = __webpack_require__(17);
        // EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
                // CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */
        function isSessionUsable(loadedSession) {
            if ("" === loadedSession.sessionId) return !1;
            var keyStatusesMap = loadedSession.keyStatuses, keyStatuses = [];
            return keyStatusesMap.forEach(function(keyStatus) {
                keyStatuses.push(keyStatus);
            }), 0 < keyStatuses.length && !Object(array_includes.a)(keyStatuses, "expired") && !Object(array_includes.a)(keyStatuses, "internal-error") && (log.a.debug("EME: Reuse loaded session", loadedSession.sessionId), 
            !0);
        }
        // CONCATENATED MODULE: ./src/core/eme/create_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */        function loadPersistentSession(sessionId, session) {
            return Object(defer.a)(function() {
                return log.a.debug("EME: Load persisted session", sessionId), Object(cast_to_observable.a)(session.load(sessionId));
            });
        }
        /**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function create_session_createSession(initData, initDataType, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage, sessionTypes = mediaKeySystemAccess.getConfiguration().sessionTypes, hasPersistence = sessionTypes && Object(array_includes.a)(sessionTypes, "persistent-license"), sessionType = hasPersistence && sessionStorage && keySystemOptions.persistentLicense ? "persistent-license" : "temporary";
                log.a.debug("EME: Create a new " + sessionType + " session");
                var session = sessionsStore.createSession(initData, initDataType, sessionType);
 // Re-check for Dumb typescript. Equivalent to `sessionType === "temporary"`.
                                if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                var storedEntry = sessionStorage.get(initData, initDataType);
                if (!storedEntry) return Object(of.a)({
                    type: "created-session",
                    value: {
                        mediaKeySession: session,
                        sessionType: sessionType
                    }
                });
                /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */                function recreatePersistentSession() {
                    return log.a.info("EME: Removing previous persistent session."), null !== sessionStorage.get(initData, initDataType) && sessionStorage.delete(initData, initDataType), 
                    sessionsStore.deleteAndCloseSession(session).pipe(Object(map.a)(function() {
                        return {
                            type: "created-session",
                            value: {
                                mediaKeySession: sessionsStore.createSession(initData, initDataType, sessionType),
                                sessionType: sessionType
                            }
                        };
                    }));
                }
                return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap.a)(function(hasLoadedSession) {
                    return hasLoadedSession ? hasLoadedSession && isSessionUsable(session) ? (sessionStorage.add(initData, initDataType, session), 
                    log.a.info("EME: Succeeded to load persistent session."), Object(of.a)({
                        type: "loaded-persistent-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    })) : (// Unusable persistent session: recreate a new session from scratch.
                    log.a.warn("EME: Previous persistent session not usable anymore."), recreatePersistentSession()) : (log.a.warn("EME: No data stored for the loaded session"), 
                    sessionStorage.delete(initData, initDataType), Object(of.a)({
                        type: "created-session",
                        value: {
                            mediaKeySession: session,
                            sessionType: sessionType
                        }
                    }));
                }), Object(catchError.a)(function() {
                    return log.a.warn("EME: Unable to load persistent session."), recreatePersistentSession();
                }));
            });
        }
        // CONCATENATED MODULE: ./src/core/eme/get_session.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_SESSIONS = config.a.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
        /**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, recuperate a previous session and returns it or load
 * a persistent session.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */        function getSession(encryptedEvent, mediaKeysInfos) {
            return Object(defer.a)(function() {
                var initDataType = encryptedEvent.type, initData = encryptedEvent.data, previousLoadedSession = null, sessionsStore = mediaKeysInfos.sessionsStore, entry = sessionsStore.get(initData, initDataType);
 // possible previous loaded session with the same initialization data
                                if (null != entry) {
                    if (isSessionUsable(previousLoadedSession = entry.session)) return log.a.debug("EME: Reuse loaded session", previousLoadedSession.sessionId), 
                    Object(of.a)({
                        type: "loaded-open-session",
                        value: {
                            mediaKeySession: previousLoadedSession,
                            sessionType: entry.sessionType,
                            initData: initData,
                            initDataType: initDataType
                        }
                    });
                    mediaKeysInfos.sessionStorage && mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
                }
                return (previousLoadedSession ? sessionsStore.deleteAndCloseSession(previousLoadedSession) : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    var cleaningOldSessions$ = [], entries = sessionsStore.getAll().slice();
                    if (0 < MAX_SESSIONS && MAX_SESSIONS <= entries.length) for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) cleaningOldSessions$.push(sessionsStore.deleteAndCloseSession(entries[i].session));
                    return Object(concat.a)(merge.a.apply(void 0, cleaningOldSessions$).pipe(Object(ignoreElements.a)()), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                        return {
                            type: evt.type,
                            value: {
                                mediaKeySession: evt.value.mediaKeySession,
                                sessionType: evt.value.sessionType,
                                initData: initData,
                                initDataType: initDataType
                            }
                        };
                    })));
                }));
            });
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
                var mapTo = __webpack_require__(165), set_media_keys = __webpack_require__(208), media_keys_infos_store = __webpack_require__(36);
        // EXTERNAL MODULE: ./src/compat/eme/set_media_keys.ts
                // CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
        function attachMediaKeys(mediaKeysInfos, mediaElement) {
            return Object(defer.a)(function() {
                var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore, previousState = media_keys_infos_store.a.getState(mediaElement);
                return media_keys_infos_store.a.setState(mediaElement, {
                    keySystemOptions: keySystemOptions,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore
                }), (previousState && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : Object(of.a)(null)).pipe(Object(mergeMap.a)(function() {
                    return mediaElement.mediaKeys === mediaKeys ? Object(of.a)(null) : (log.a.debug("EME: Setting MediaKeys"), 
                    Object(set_media_keys.a)(mediaElement, mediaKeys));
                }));
            });
        }
        // EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
                var rx_try_catch = __webpack_require__(32), Observable = __webpack_require__(8), should_renew_media_keys = __webpack_require__(140), custom_media_keys = __webpack_require__(135), flat_map = __webpack_require__(86), EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config.a.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config.a.EME_KEY_SYSTEMS;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                /**
 * @param {Array.<Object>} keySystems
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */
        function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
            var mksConfiguration = currentKeySystemAccess.getConfiguration();
            if (Object(should_renew_media_keys.a)() || !mksConfiguration) return null;
            var firstCompatibleOption = keySystems.filter(function(ks) {
                // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
                return ks.type === currentKeySystemOptions.type && ((!ks.persistentLicense || "required" === mksConfiguration.persistentState) && (!ks.distinctiveIdentifierRequired || "required" === mksConfiguration.distinctiveIdentifier));
            })[0];
            return firstCompatibleOption ? {
                keySystemOptions: firstCompatibleOption,
                keySystemAccess: currentKeySystemAccess
            } : null;
        }
        /**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */        function findKeySystemCanonicalName(ksType) {
            for (var _i = 0, _Object$keys = Object.keys(EME_KEY_SYSTEMS); _i < _Object$keys.length; _i++) {
                var ksName = _Object$keys[_i];
                if (Object(array_includes.a)(EME_KEY_SYSTEMS[ksName], ksType)) return ksName;
            }
        }
        /**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */        function buildKeySystemConfigurations(ksName, keySystem) {
            var sessionTypes = [ "temporary" ], persistentState = "optional", distinctiveIdentifier = "optional";
            keySystem.persistentLicense && (persistentState = "required", sessionTypes.push("persistent-license")), 
            keySystem.persistentStateRequired && (persistentState = "required"), keySystem.distinctiveIdentifierRequired && (distinctiveIdentifier = "required");
            // Set robustness, in order of consideration:
            //   1. the user specified its own robustnesses
            //   2. a "widevine" key system is used, in that case set the default widevine
            //      robustnesses as defined in the config
            //   3. set an undefined robustness
            var videoRobustnesses = keySystem.videoRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []), audioRobustnesses = keySystem.audioRobustnesses || ("widevine" === ksName ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
            // TODO Re-test with a set contentType but an undefined robustness on the
            // STBs on which this problem was found.
            //
            // add another with no {audio,video}Capabilities for some legacy browsers.
            // As of today's spec, this should return NotSupported but the first
            // candidate configuration should be good, so we should have no downside
            // doing that.
            // initDataTypes: ["cenc"],
            // videoCapabilities: undefined,
            // audioCapabilities: undefined,
            // distinctiveIdentifier,
            // persistentState,
            // sessionTypes,
            return videoRobustnesses.length || videoRobustnesses.push(void 0), audioRobustnesses.length || audioRobustnesses.push(void 0), 
            [ {
                initDataTypes: [ "cenc" ],
                videoCapabilities: Object(flat_map.a)(videoRobustnesses, function(robustness) {
                    return [ {
                        contentType: 'video/mp4;codecs="avc1.4d401e"',
                        robustness: robustness
                    }, {
                        contentType: 'video/mp4;codecs="avc1.42e01e"',
                        robustness: robustness
                    }, {
                        contentType: 'video/webm;codecs="vp8"',
                        robustness: robustness
                    } ];
                }),
                audioCapabilities: Object(flat_map.a)(audioRobustnesses, function(robustness) {
                    return [ {
                        contentType: 'audio/mp4;codecs="mp4a.40.2"',
                        robustness: robustness
                    }, {
                        contentType: "audio/webm;codecs=opus",
                        robustness: robustness
                    } ];
                }),
                distinctiveIdentifier: distinctiveIdentifier,
                persistentState: persistentState,
                sessionTypes: sessionTypes
            } ];
        }
        /**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */        function getMediaKeySystemAccess(mediaElement, keySystemsConfigs) {
            return Object(defer.a)(function() {
                var currentState = media_keys_infos_store.a.getState(mediaElement);
                if (currentState) {
                    // Fast way to find a compatible keySystem if the currently loaded
                    // one as exactly the same compatibility options.
                    var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
                    if (cachedKeySystemAccess) return log.a.debug("EME: Found cached compatible keySystem", cachedKeySystemAccess), 
                    Object(of.a)({
                        type: "reuse-media-key-system-access",
                        value: {
                            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                            options: cachedKeySystemAccess.keySystemOptions
                        }
                    });
                }
                /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */                var keySystemsType = keySystemsConfigs.reduce(function(arr, keySystemOptions) {
                    var ksType, managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
                    null != managedRDNs ? ksType = managedRDNs.map(function(keyType) {
                        return {
                            keyName: keySystemOptions.type,
                            keyType: keyType,
                            keySystemOptions: keySystemOptions
                        };
                    }) : ksType = [ {
                        keyName: findKeySystemCanonicalName(keySystemOptions.type) || "",
                        keyType: keySystemOptions.type,
                        keySystemOptions: keySystemOptions
                    } ];
                    return arr.concat(ksType);
                }, []);
                return new Observable.a(function(obs) {
                    var sub, disposed = !1;
                    /**
       * Test the key system as defined in keySystemsType[index].
       * @param {Number} index
       */
                    return function testKeySystem(index) {
                        // completely quit the loop if unsubscribed
                        if (!disposed) // if we iterated over the whole keySystemsType Array, quit on error
                        if (index >= keySystemsType.length) obs.error(new encrypted_media_error.a("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your wanted configuration has been found in the current browser.")); else {
                            var _keySystemsType$index = keySystemsType[index], keyName = _keySystemsType$index.keyName, keyType = _keySystemsType$index.keyType, keySystemOptions = _keySystemsType$index.keySystemOptions, keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
                            if (log.a.debug("EME: Request keysystem access " + keyType + "," + (index + 1) + " of " + keySystemsType.length, keySystemConfigurations), 
                            null == custom_media_keys.c) throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
                            sub = Object(custom_media_keys.c)(keyType, keySystemConfigurations).subscribe(function(keySystemAccess) {
                                log.a.info("EME: Found compatible keysystem", keyType, keySystemConfigurations), 
                                obs.next({
                                    type: "create-media-key-system-access",
                                    value: {
                                        options: keySystemOptions,
                                        mediaKeySystemAccess: keySystemAccess
                                    }
                                }), obs.complete();
                            }, function() {
                                log.a.debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations), 
                                sub = null, testKeySystem(index + 1);
                            });
                        }
                    }(0), function() {
                        disposed = !0, sub && sub.unsubscribe();
                    };
                });
            });
        }
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(9), hash_buffer = __webpack_require__(27), open_sessions_store_MediaKeySessionsStore = 
        /* */
        function() {
            function MediaKeySessionsStore(mediaKeys) {
                this._mediaKeys = mediaKeys, this._entries = [];
            }
            /**
   * @returns {Array.<Object>}
   */            var _proto = MediaKeySessionsStore.prototype;
            return _proto.getAll = function getAll() {
                return this._entries.map(function(entry) {
                    return {
                        session: entry.session,
                        sessionType: entry.sessionType
                    };
                });
            }
            /**
   * Returns an entry in this cache with the initData and initDataType given.
   * null if no such session is stored.
   *
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */ , _proto.get = function get(initData, initDataType) {
                var initDataHash = Object(hash_buffer.a)(initData), foundEntry = Object(array_find.a)(this._entries, function(entry) {
                    return entry.initData === initDataHash && entry.initDataType === initDataType;
                });
                return foundEntry ? {
                    session: foundEntry.session,
                    sessionType: foundEntry.sessionType
                } : null;
            }
            /**
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {string} sessionType
   * @returns {MediaKeySession}
   * @throws {EncryptedMediaError}
   */ , _proto.createSession = function createSession(initData, initDataType, sessionType) {
                var _this = this;
                if (this.get(initData, initDataType)) throw new encrypted_media_error.a("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.");
                var session = Object(custom_media_keys.a)(this._mediaKeys, sessionType), entry = {
                    session: session,
                    sessionType: sessionType,
                    initData: Object(hash_buffer.a)(initData),
                    initDataType: initDataType
                };
                return null !== session.closed && session.closed.then(function() {
                    _this._delete(session);
                }).catch(function(e) {
                    log.a.warn("EME-MKSS: session.closed rejected: " + e);
                }), log.a.debug("EME-MKSS: Add session", entry), this._entries.push(entry), session;
            }
            /**
   * Close a MediaKeySession and remove its entry if it's found in the store.
   * @param {MediaKeySession} session
   * @returns {Observable}
   */ , _proto.deleteAndCloseSession = function deleteAndCloseSession(session) {
                var _this2 = this;
                return Object(defer.a)(function() {
                    return _this2._delete(session), log.a.debug("EME-MKSS: Close session", session), 
                    Object(cast_to_observable.a)(session.close()).pipe(Object(catchError.a)(function() {
                        return Object(of.a)(null);
                    }));
                });
            }
            /**
   * Close all sessions in this store.
   * Emit null when done
   * @returns {Observable}
   */ , _proto.closeAllSessions = function closeAllSessions() {
                var _this3 = this;
                return Object(defer.a)(function() {
                    var previousEntries = _this3._entries;
                    _this3._entries = [];
                    // clean completely the cache first
                    var disposed = previousEntries.map(function(entry) {
                        return _this3.deleteAndCloseSession(entry.session);
                    });
                    return Object(concat.a)(merge.a.apply(void 0, disposed).pipe(Object(ignoreElements.a)()), Object(of.a)(null));
                });
            }
            /**
   * Remove a MediaKeySession from the Cache, without closing it.
   * Returns the entry if found, null otherwise.
   * @param {MediaKeySession} session
   * @returns {number} - index of the session in the cache. -1 of not found.
   */ , _proto._delete = function _delete(session) {
                var entry = Object(array_find.a)(this._entries, function(e) {
                    return e.session === session;
                });
                if (!entry) return -1;
                log.a.debug("EME-MKSS: delete session", entry);
                var idx = this._entries.indexOf(entry);
                return this._entries.splice(idx, 1), idx;
            }, MediaKeySessionsStore;
        }(), assert = __webpack_require__(31);
        // EXTERNAL MODULE: ./src/utils/hash_buffer.ts
                // CONCATENATED MODULE: ./src/core/eme/utils/persisted_session_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function checkStorage(storage) {
            Object(assert.a)(storage, {
                save: "function",
                load: "function"
            }, "licenseStorage");
        }
        /**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */        var persisted_session_store_PersistedSessionsStore = 
        /* */
        function() {
            /**
   * @param {Object} storage
   */
            function PersistedSessionsStore(storage) {
                checkStorage(storage), this._entries = [], this._storage = storage;
                try {
                    this._entries = this._storage.load(), Array.isArray(this._entries) || (this._entries = []);
                } catch (e) {
                    log.a.warn("EME-PSS: Could not get entries from license storage", e), this.dispose();
                }
            }
            /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */            var _proto = PersistedSessionsStore.prototype;
            return _proto.get = function get(initData, initDataType) {
                var hash = Object(hash_buffer.a)(initData);
                return Object(array_find.a)(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                }) || null;
            }
            /**
   * Add a new entry in the storage.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */ , _proto.add = function add(initData, initDataType, session) {
                var sessionId = session && session.sessionId;
                if (sessionId) {
                    var currentEntry = this.get(initData, initDataType);
                    currentEntry && currentEntry.sessionId === sessionId || (currentEntry && 
                    // currentEntry has a different sessionId
                    this.delete(initData, initDataType), log.a.info("EME-PSS: Add new session", sessionId, session), 
                    this._entries.push({
                        sessionId: sessionId,
                        initData: Object(hash_buffer.a)(initData),
                        initDataType: initDataType
                    }), this._save());
                }
            }
            /**
   * Delete entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   */ , _proto.delete = function _delete(initData, initDataType) {
                var hash = Object(hash_buffer.a)(initData), entry = Object(array_find.a)(this._entries, function(e) {
                    return e.initData === hash && e.initDataType === initDataType;
                });
                if (entry) {
                    log.a.warn("EME-PSS: Delete session from store", entry);
                    var idx = this._entries.indexOf(entry);
                    this._entries.splice(idx, 1), this._save();
                }
            }
            /**
   * Delete all saved entries.
   */ , _proto.dispose = function dispose() {
                this._entries = [], this._save();
            }
            /**
   * Use the given storage to store the current entries.
   */ , _proto._save = function _save() {
                try {
                    this._storage.save(this._entries);
                } catch (e) {
                    log.a.warn("EME-PSS: Could not save licenses in localStorage");
                }
            }, PersistedSessionsStore;
        }();
        // CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */        function createSessionStorage(keySystemOptions) {
            if (!keySystemOptions.persistentLicense) return null;
            var licenseStorage = keySystemOptions.licenseStorage;
            if (!licenseStorage) throw new encrypted_media_error.a("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
            return log.a.info("EME: Set the given license storage"), new persisted_session_store_PersistedSessionsStore(licenseStorage);
        }
        /**
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */        function getMediaKeysInfos(mediaElement, keySystemsConfigs) {
            return getMediaKeySystemAccess(mediaElement, keySystemsConfigs).pipe(Object(mergeMap.a)(function(evt) {
                var _evt$value = evt.value, options = _evt$value.options, mediaKeySystemAccess = _evt$value.mediaKeySystemAccess, currentState = media_keys_infos_store.a.getState(mediaElement), sessionStorage = createSessionStorage(options);
                if (null == currentState || "reuse-media-key-system-access" !== evt.type) return log.a.debug("EME: Calling createMediaKeys on the MediaKeySystemAccess"), 
                Object(rx_try_catch.a)(function() {
                    return Object(cast_to_observable.a)(mediaKeySystemAccess.createMediaKeys());
                }, void 0).pipe(Object(catchError.a)(function(error) {
                    var message = error instanceof Error ? error.message : "Unknown error when creating MediaKeys.";
                    throw new encrypted_media_error.a("CREATE_MEDIA_KEYS_ERROR", message);
                }), Object(map.a)(function(mediaKeys) {
                    return {
                        mediaKeys: mediaKeys,
                        sessionsStore: new open_sessions_store_MediaKeySessionsStore(mediaKeys),
                        mediaKeySystemAccess: mediaKeySystemAccess,
                        keySystemOptions: options,
                        sessionStorage: sessionStorage
                    };
                }));
                var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;
                return Object(of.a)({
                    mediaKeys: mediaKeys,
                    sessionsStore: sessionsStore,
                    mediaKeySystemAccess: mediaKeySystemAccess,
                    keySystemOptions: options,
                    sessionStorage: sessionStorage
                });
            }));
        }
        // CONCATENATED MODULE: ./src/core/eme/init_media_keys.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */        function initMediaKeys(mediaElement, keySystemsConfigs) {
            return getMediaKeysInfos(mediaElement, keySystemsConfigs).pipe(Object(mergeMap.a)(function(mediaKeysInfos) {
                return Object(concat.a)(Object(of.a)({
                    type: "created-media-keys",
                    value: mediaKeysInfos
                }), attachMediaKeys(mediaKeysInfos, mediaElement).pipe(Object(mapTo.a)({
                    type: "attached-media-keys",
                    value: mediaKeysInfos
                })));
            }));
        }
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */        var TimeoutError = /* */ function() {
            function TimeoutErrorImpl() {
                return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", 
                this;
            }
            return TimeoutErrorImpl.prototype = /* */ Object.create(Error.prototype), TimeoutErrorImpl;
        }(), Subject = __webpack_require__(41), identity = __webpack_require__(157), scheduler_async = __webpack_require__(40), tslib_es6 = __webpack_require__(2), isDate = __webpack_require__(97), OuterSubscriber = __webpack_require__(25), subscribeToResult = __webpack_require__(24);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function timeoutWith(due, withObservable, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), function(source) {
                var absoluteTimeout = Object(isDate.a)(due), waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
                return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
            };
        }
        var TimeoutWithOperator = /* */ function() {
            function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
                this.waitFor = waitFor, this.absoluteTimeout = absoluteTimeout, this.withObservable = withObservable, 
                this.scheduler = scheduler;
            }
            return TimeoutWithOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
            }, TimeoutWithOperator;
        }(), timeoutWith_TimeoutWithSubscriber = /* */ function(_super) {
            function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
                var _this = _super.call(this, destination) || this;
                return _this.absoluteTimeout = absoluteTimeout, _this.waitFor = waitFor, _this.withObservable = withObservable, 
                _this.scheduler = scheduler, _this.action = null, _this.scheduleTimeout(), _this;
            }
            return tslib_es6.a(TimeoutWithSubscriber, _super), TimeoutWithSubscriber.dispatchTimeout = function(subscriber) {
                var withObservable = subscriber.withObservable;
                subscriber._unsubscribeAndRecycle(), subscriber.add(Object(subscribeToResult.a)(subscriber, withObservable));
            }, TimeoutWithSubscriber.prototype.scheduleTimeout = function() {
                var action = this.action;
                action ? this.action = action.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }, TimeoutWithSubscriber.prototype._next = function(value) {
                this.absoluteTimeout || this.scheduleTimeout(), _super.prototype._next.call(this, value);
            }, TimeoutWithSubscriber.prototype._unsubscribe = function() {
                this.action = null, this.scheduler = null, this.withObservable = null;
            }, TimeoutWithSubscriber;
        }(OuterSubscriber.a), throwError = __webpack_require__(59);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
        function timeout(due, scheduler) {
            return void 0 === scheduler && (scheduler = scheduler_async.a), timeoutWith(due, Object(throwError.a)(new TimeoutError()), scheduler);
        }
        //# sourceMappingURL=timeout.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function concatMap(project, resultSelector) {
            return Object(mergeMap.a)(project, resultSelector, 1);
        }
        //# sourceMappingURL=concatMap.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
                var startWith = __webpack_require__(205), takeUntil = __webpack_require__(166), timer = __webpack_require__(217), get_fuzzed_delay = __webpack_require__(100);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
                // CONCATENATED MODULE: ./src/utils/rx-retry_with_backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
        function retryObsWithBackoff(obs$, options) {
            var baseDelay = options.baseDelay, maxDelay = options.maxDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, onRetry = options.onRetry, retryCount = 0;
            return obs$.pipe(Object(catchError.a)(function(error, source) {
                if (null != shouldRetry && !shouldRetry(error) || retryCount++ >= totalRetry) throw error;
                onRetry && onRetry(error, retryCount);
                var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay), fuzzedDelay = Object(get_fuzzed_delay.a)(delay);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return source;
                }));
            }));
        }
        // CONCATENATED MODULE: ./src/core/eme/check_key_statuses.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var KEY_STATUSES = {
            EXPIRED: "expired",
            INTERNAL_ERROR: "internal-error",
            OUTPUT_RESTRICTED: "output-restricted"
        };
        /**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} keySystem - Configuration. Used to known on which situations
 * we can fallback.
 * @returns {Array} - Warnings to send.
 */        function checkKeyStatuses(session, keySystem) {
            var warnings = [];
            return session.keyStatuses.forEach(function(_arg1, _arg2) {
                // Hack present because the order of the arguments has changed in spec
                // and is not the same between some versions of Edge and Chrome.
                var keyStatus = function() {
                    return "string" == typeof _arg1 ? _arg1 : _arg2;
                }();
                switch (keyStatus) {
                  case KEY_STATUSES.EXPIRED:
                    var error = new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "A decryption key expired");
                    if (!1 !== keySystem.throwOnLicenseExpiration) throw error;
                    warnings.push({
                        type: "warning",
                        value: error
                    });
                    break;

                  case KEY_STATUSES.OUTPUT_RESTRICTED:
                  case KEY_STATUSES.INTERNAL_ERROR:
                    throw new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been encountered: " + keyStatus);
                }
            }), warnings;
        }
        // CONCATENATED MODULE: ./src/core/eme/session_events_listener.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var onKeyError$ = compat.a.onKeyError$, onKeyMessage$ = compat.a.onKeyMessage$, onKeyStatusesChange$ = compat.a.onKeyStatusesChange$;
        /**
 * @param {Error|Object} error
 * @returns {Error|Object}
 */        function formatGetLicenseError(error) {
            if (error instanceof TimeoutError) return new encrypted_media_error.a("KEY_LOAD_TIMEOUT", "The license server took too much time to respond.");
            var err = new encrypted_media_error.a("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");
            return null != error && error.message && (err.message = error.message), err;
        }
        /**
 * listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystem - The key system configuration.
 * @returns {Observable}
 */        function SessionEventsListener(session, keySystem) {
            function getKeyStatusesEvents() {
                var warnings = checkKeyStatuses(session, keySystem);
                return of.a.apply(void 0, warnings);
            }
            log.a.debug("EME: Binding session events", session);
            var sessionWarningSubject$ = new Subject.a(), _keySystem$getLicense = keySystem.getLicenseConfig, getLicenseConfig = void 0 === _keySystem$getLicense ? {} : _keySystem$getLicense, getLicenseRetryOptions = {
                totalRetry: null != getLicenseConfig.retry ? getLicenseConfig.retry : 2,
                baseDelay: 200,
                maxDelay: 3e3,
                shouldRetry: function shouldRetry(error) {
                    return error instanceof TimeoutError || null == error || !0 !== error.noRetry;
                },
                onRetry: function onRetry(error) {
                    return sessionWarningSubject$.next({
                        type: "warning",
                        value: formatGetLicenseError(error)
                    });
                }
            }, keyErrors = onKeyError$(session).pipe(Object(map.a)(function(error) {
                throw new encrypted_media_error.a("KEY_ERROR", error.type);
            })), keyStatusesChanges = onKeyStatusesChange$(session).pipe(Object(mergeMap.a)(function(keyStatusesEvent) {
                log.a.debug("EME: keystatuseschange event", session, keyStatusesEvent);
                var keyStatusesEvents$ = getKeyStatusesEvents(), handledKeyStatusesChange$ = Object(rx_try_catch.a)(function() {
                    return keySystem && keySystem.onKeyStatusesChange ? Object(cast_to_observable.a)(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : empty.a;
                }, void 0).pipe(Object(map.a)(function(licenseObject) {
                    return {
                        type: "key-status-change-handled",
                        value: {
                            session: session,
                            license: licenseObject
                        }
                    };
                }), Object(catchError.a)(function(error) {
                    var err = new encrypted_media_error.a("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");
                    throw null != error && error.message && (err.message = error.message), err;
                }));
                return Object(concat.a)(keyStatusesEvents$, handledKeyStatusesChange$);
            })), keyMessages$ = onKeyMessage$(session).pipe(Object(mergeMap.a)(function(messageEvent) {
                var message = new Uint8Array(messageEvent.message), messageType = messageEvent.messageType || "license-request";
                return log.a.debug("EME: Event message type " + messageType, session, messageEvent), 
                retryObsWithBackoff(Object(defer.a)(function() {
                    var getLicense = keySystem.getLicense(message, messageType), getLicenseTimeout = null != getLicenseConfig.timeout ? getLicenseConfig.timeout : 1e4;
                    return Object(cast_to_observable.a)(getLicense).pipe(0 <= getLicenseTimeout ? timeout(getLicenseTimeout) : identity.a
                    /* noop */);
                }), getLicenseRetryOptions).pipe(Object(map.a)(function(licenseObject) {
                    return {
                        type: "key-message-handled",
                        value: {
                            session: session,
                            license: licenseObject
                        }
                    };
                }), Object(catchError.a)(function(err) {
                    throw formatGetLicenseError(err);
                }));
            })), sessionUpdates = Object(merge.a)(keyMessages$, keyStatusesChanges).pipe(concatMap(function(evt) {
                if ("key-message-handled" !== evt.type && "key-status-change-handled" !== evt.type) return Object(of.a)(evt);
                var license = evt.value.license;
                return null == license ? (log.a.info("EME: No license given, skipping session.update"), 
                Object(of.a)(evt)) : (log.a.debug("EME: Update session", evt), Object(cast_to_observable.a)(session.update(license)).pipe(Object(catchError.a)(function(error) {
                    var reason = error instanceof Error ? error.toString() : "`session.update` failed";
                    throw new encrypted_media_error.a("KEY_UPDATE_ERROR", reason);
                }), Object(mapTo.a)({
                    type: "session-updated",
                    value: {
                        session: session,
                        license: license
                    }
                }), Object(startWith.a)(evt)));
            })), sessionEvents = Object(merge.a)(getKeyStatusesEvents(), sessionUpdates, keyErrors, sessionWarningSubject$);
            return session.closed ? sessionEvents.pipe(Object(takeUntil.a)(Object(cast_to_observable.a)(session.closed))) : sessionEvents;
        }
        // CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function setServerCertificate(mediaKeys, serverCertificate) {
            return Object(defer.a)(function() {
                return Object(cast_to_observable.a)(mediaKeys.setServerCertificate(serverCertificate)).pipe(Object(catchError.a)(function(error) {
                    log.a.warn("EME: mediaKeys.setServerCertificate returned an error", error);
                    var reason = error instanceof Error ? error.toString() : "`setServerCertificate` error";
                    throw new encrypted_media_error.a("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
                }));
            });
        }
        /**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */        function trySettingServerCertificate(mediaKeys, serverCertificate) {
            return "function" == typeof mediaKeys.setServerCertificate ? (log.a.debug("EME: Setting server certificate on the MediaKeys"), 
            setServerCertificate(mediaKeys, serverCertificate).pipe(Object(ignoreElements.a)(), Object(catchError.a)(function(error) {
                return Object(of.a)({
                    type: "warning",
                    value: error
                });
            }))) : (log.a.warn("EME: Could not set the server certificate. mediaKeys.setServerCertificate is not a function"), 
            empty.a);
        }
        // EXTERNAL MODULE: ./src/utils/simple_set.ts
                var simple_set = __webpack_require__(68), init_data_store_InitDataStore = 
        /* */
        function() {
            function InitDataStore() {
                this._namedTypeData = {}, this._unnamedTypeData = new simple_set.a();
            }
            /**
   * Returns true if this instance has the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */            var _proto = InitDataStore.prototype;
            return _proto.has = function has(initData, initDataType) {
                return initDataType ? !!this._namedTypeData[initDataType] && this._namedTypeData[initDataType].test(Object(hash_buffer.a)(initData)) : this._unnamedTypeData.test(Object(hash_buffer.a)(initData));
            }
            /**
   * Add initialization data to this memory.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   */ , _proto.add = function add(initData, initDataType) {
                this.has(initData, initDataType) || (initDataType ? (this._namedTypeData[initDataType] || (this._namedTypeData[initDataType] = new simple_set.a()), 
                this._namedTypeData[initDataType].add(Object(hash_buffer.a)(initData))) : this._unnamedTypeData.add(Object(hash_buffer.a)(initData)));
            }
            /**
   * Remove the initialization data from this memory.
   * Returns true if this instance had the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */ , _proto.remove = function remove(initData, initDataType) {
                if (initDataType) {
                    if (!this._namedTypeData[initDataType]) return !1;
                    var _hashed = Object(hash_buffer.a)(initData), simpleSet = this._namedTypeData[initDataType];
                    return !!simpleSet.test(_hashed) && (simpleSet.remove(_hashed), !0);
                }
                var hashed = Object(hash_buffer.a)(initData);
                return !!this._unnamedTypeData.test(hashed) && (this._unnamedTypeData.remove(hashed), 
                !0);
            }, InitDataStore;
        }(), onEncrypted$ = compat.a.onEncrypted$;
        // CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */        
        // EXTERNAL MODULE: ./src/core/eme/get_current_key_system.ts
        var get_current_key_system = __webpack_require__(143);
        // CONCATENATED MODULE: ./src/core/eme/index.ts
        /* concated harmony reexport clearEMESession */        __webpack_require__.d(__webpack_exports__, "clearEMESession", function() {
            return clear_eme_session.a;
        }), 
        /* concated harmony reexport disposeEME */ __webpack_require__.d(__webpack_exports__, "disposeEME", function() {
            return dispose_eme.a;
        }), 
        /* concated harmony reexport getCurrentKeySystem */ __webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() {
            return get_current_key_system.a;
        });
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = 
        /**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
 * associated to a MediaKeys object
 * @param {Array.<Object>} keySystems - key system configuration
 * @returns {Observable}
 */
        function EMEManager(mediaElement, keySystemsConfigs) {
            log.a.debug("EME: Starting EMEManager logic.");
            // Keep track of all initialization data handled here.
            // This is to avoid handling multiple times the same encrypted events.
            var handledInitData = new init_data_store_InitDataStore(), mediaKeysInfos$ = initMediaKeys(mediaElement, keySystemsConfigs).pipe(Object(shareReplay.a)()), attachedMediaKeys$ = mediaKeysInfos$.pipe(Object(filter.a)(function(evt) {
                return "attached-media-keys" === evt.type;
            })), encryptedEvents$ = onEncrypted$(mediaElement).pipe(Object(tap.a)(function(evt) {
                log.a.debug("EME: Encrypted event received from media element.", evt);
            }), Object(map.a)(function(evt) {
                var _getInitData = Object(get_init_data.a)(evt), initData = _getInitData.initData;
                return {
                    type: _getInitData.initDataType,
                    data: initData
                };
            })), bindSession$ = Object(combineLatest.a)([ encryptedEvents$, attachedMediaKeys$ ]).pipe(
            /* Attach server certificate and create/reuse MediaKeySession */
            Object(mergeMap.a)(function(_ref, i) {
                var encryptedEvent = _ref[0], mediaKeysInfos = _ref[1].value, keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeys = mediaKeysInfos.mediaKeys, serverCertificate = keySystemOptions.serverCertificate, initDataType = encryptedEvent.type, initData = encryptedEvent.data;
                if (handledInitData.has(initData, initDataType)) return log.a.debug("EME: Init data already received. Skipping it."), 
                empty.a;
 // Already handled, quit
                                handledInitData.add(initData, initDataType);
                var session$ = getSession(encryptedEvent, mediaKeysInfos).pipe(Object(map.a)(function(evt) {
                    return {
                        type: evt.type,
                        value: {
                            initData: evt.value.initData,
                            initDataType: evt.value.initDataType,
                            mediaKeySession: evt.value.mediaKeySession,
                            sessionType: evt.value.sessionType,
                            keySystemOptions: mediaKeysInfos.keySystemOptions,
                            sessionStorage: mediaKeysInfos.sessionStorage
                        }
                    };
                }));
                return 0 === i ? Object(merge.a)(null != serverCertificate ? Object(concat.a)(trySettingServerCertificate(mediaKeys, serverCertificate), session$) : session$) : session$;
            }), 
            /* Trigger license request and manage MediaKeySession events */
            Object(mergeMap.a)(function(sessionInfosEvt) {
                if ("warning" === sessionInfosEvt.type) return Object(of.a)(sessionInfosEvt);
                var _sessionInfosEvt$valu = sessionInfosEvt.value, initData = _sessionInfosEvt$valu.initData, initDataType = _sessionInfosEvt$valu.initDataType, mediaKeySession = _sessionInfosEvt$valu.mediaKeySession, sessionType = _sessionInfosEvt$valu.sessionType, keySystemOptions = _sessionInfosEvt$valu.keySystemOptions, sessionStorage = _sessionInfosEvt$valu.sessionStorage, generateRequest$ = "created-session" !== sessionInfosEvt.type ? empty.a : Object(generate_key_request.a)(mediaKeySession, initData, initDataType).pipe(Object(tap.a)(function() {
                    "persistent-license" === sessionType && null != sessionStorage && sessionStorage.add(initData, initDataType, mediaKeySession);
                }), Object(catchError.a)(function(error) {
                    throw new encrypted_media_error.a("KEY_GENERATE_REQUEST_ERROR", error instanceof Error ? error.toString() : "Unknown error");
                }), Object(ignoreElements.a)());
                return Object(merge.a)(SessionEventsListener(mediaKeySession, keySystemOptions), generateRequest$);
            }));
 // store the mediaKeys when ready
                        return Object(merge.a)(mediaKeysInfos$, bindSession$);
        };
        /***/    }, 
    /* 157 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function identity(x) {
            return x;
        }
        //# sourceMappingURL=identity.js.map
        /***/        __webpack_require__.d(__webpack_exports__, "a", function() {
            return identity;
        });
    }, 
    /* 158 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return concatAll;
        });
        /* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);
        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */        function concatAll() {
            return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
        }
        //# sourceMappingURL=concatAll.js.map
        /***/    }, 
    /* 159 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */        
        /* WEBPACK VAR INJECTION */ (function(global) {
            function NOOP() {}
            var asyncTimer, PENDING = "pending", SETTLED = "settled", FULFILLED = "fulfilled", REJECTED = "rejected", isNode = void 0 !== global && void 0 !== global.process && "function" == typeof global.process.emit, asyncSetTimer = "undefined" == typeof setImmediate ? setTimeout : setImmediate, asyncQueue = [];
            function asyncFlush() {
                // run promise callbacks
                for (var i = 0; i < asyncQueue.length; i++) asyncQueue[i][0](asyncQueue[i][1]);
                // reset async asyncQueue
                                asyncTimer = !(asyncQueue = []);
            }
            function asyncCall(callback, arg) {
                asyncQueue.push([ callback, arg ]), asyncTimer || (asyncTimer = !0, asyncSetTimer(asyncFlush, 0));
            }
            function invokeResolver(resolver, promise) {
                function rejectPromise(reason) {
                    reject(promise, reason);
                }
                try {
                    resolver(function resolvePromise(value) {
                        resolve(promise, value);
                    }, rejectPromise);
                } catch (e) {
                    rejectPromise(e);
                }
            }
            function invokeCallback(subscriber) {
                var owner = subscriber.owner, settled = owner._state, value = owner._data, callback = subscriber[settled], promise = subscriber.then;
                if ("function" == typeof callback) {
                    settled = FULFILLED;
                    try {
                        value = callback(value);
                    } catch (e) {
                        reject(promise, e);
                    }
                }
                handleThenable(promise, value) || (settled === FULFILLED && resolve(promise, value), 
                settled === REJECTED && reject(promise, value));
            }
            function handleThenable(promise, value) {
                var resolved;
                try {
                    if (promise === value) throw new TypeError("A promises callback cannot return that same promise.");
                    if (value && ("function" == typeof value || "object" == typeof value)) {
                        // then should be retrieved only once
                        var then = value.then;
                        if ("function" == typeof then) return then.call(value, function(val) {
                            resolved || (resolved = !0, value === val ? fulfill(promise, val) : resolve(promise, val));
                        }, function(reason) {
                            resolved || (resolved = !0, reject(promise, reason));
                        }), !0;
                    }
                } catch (e) {
                    return resolved || reject(promise, e), !0;
                }
                return !1;
            }
            function resolve(promise, value) {
                promise !== value && handleThenable(promise, value) || fulfill(promise, value);
            }
            function fulfill(promise, value) {
                promise._state === PENDING && (promise._state = SETTLED, promise._data = value, 
                asyncCall(publishFulfillment, promise));
            }
            function reject(promise, reason) {
                promise._state === PENDING && (promise._state = SETTLED, promise._data = reason, 
                asyncCall(publishRejection, promise));
            }
            function publish(promise) {
                promise._then = promise._then.forEach(invokeCallback);
            }
            function publishFulfillment(promise) {
                promise._state = FULFILLED, publish(promise);
            }
            function publishRejection(promise) {
                promise._state = REJECTED, publish(promise), !promise._handled && isNode && global.process.emit("unhandledRejection", promise._data, promise);
            }
            function notifyRejectionHandled(promise) {
                global.process.emit("rejectionHandled", promise);
            }
            /**
 * @class
 */            function Promise(resolver) {
                if ("function" != typeof resolver) throw new TypeError("Promise resolver " + resolver + " is not a function");
                if (this instanceof Promise == !1) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                this._then = [], invokeResolver(resolver, this);
            }
            Promise.prototype = {
                constructor: Promise,
                _state: PENDING,
                _then: null,
                _data: void 0,
                _handled: !1,
                then: function(onFulfillment, onRejection) {
                    var subscriber = {
                        owner: this,
                        then: new this.constructor(NOOP),
                        fulfilled: onFulfillment,
                        rejected: onRejection
                    };
                    return !onRejection && !onFulfillment || this._handled || (this._handled = !0, this._state === REJECTED && isNode && asyncCall(notifyRejectionHandled, this)), 
                    this._state === FULFILLED || this._state === REJECTED ? 
                    // already resolved, call callback async
                    asyncCall(invokeCallback, subscriber) : 
                    // subscribe
                    this._then.push(subscriber), subscriber.then;
                },
                catch: function(onRejection) {
                    return this.then(null, onRejection);
                }
            }, Promise.all = function(promises) {
                if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.all().");
                return new Promise(function(resolve, reject) {
                    var results = [], remaining = 0;
                    function resolver(index) {
                        return remaining++, function(value) {
                            results[index] = value, --remaining || resolve(results);
                        };
                    }
                    for (var promise, i = 0; i < promises.length; i++) (promise = promises[i]) && "function" == typeof promise.then ? promise.then(resolver(i), reject) : results[i] = promise;
                    remaining || resolve(results);
                });
            }, Promise.race = function(promises) {
                if (!Array.isArray(promises)) throw new TypeError("You must pass an array to Promise.race().");
                return new Promise(function(resolve, reject) {
                    for (var promise, i = 0; i < promises.length; i++) (promise = promises[i]) && "function" == typeof promise.then ? promise.then(resolve, reject) : resolve(promise);
                });
            }, Promise.resolve = function(value) {
                return value && "object" == typeof value && value.constructor === Promise ? value : new Promise(function(resolve) {
                    resolve(value);
                });
            }, Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason);
                });
            }, module.exports = Promise;
        }).call(this, __webpack_require__(176))
        /***/;
    }, 
    /* 160 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return NetworkError;
        });
        /* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33), _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
        /* harmony import */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */        var NetworkError = 
        /* */
        function(_Error) {
            /**
   * @param {string} code
   * @param {Error} options
   * @param {Boolean} fatal
   */
            function NetworkError(code, options) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), NetworkError.prototype), _this.name = "NetworkError", 
                _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__.b.NETWORK_ERROR, _this.xhr = void 0 === options.xhr ? null : options.xhr, 
                _this.url = options.url, _this.status = options.status, _this.errorType = options.type, 
                _this.code = code, _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__.a)(_this.name, _this.code, options.message), 
                _this.fatal = !1, _this;
            }
            /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */            return _inheritsLoose(NetworkError, _Error), NetworkError.prototype.isHttpError = function isHttpError(httpErrorCode) {
                return this.errorType === _error_codes__WEBPACK_IMPORTED_MODULE_0__.c.ERROR_HTTP_CODE && this.status === httpErrorCode;
            }, NetworkError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 161 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return createBox;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() {
            return createBoxWithChildren;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1), boxNamesMem = {};
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */        
        /**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
        function boxName(str) {
            if (boxNamesMem[str]) return boxNamesMem[str];
            var nameInBytes = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.p)(str);
            return boxNamesMem[str] = nameInBytes;
        }
        /**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */        function createBox(name, buff) {
            var len = buff.length + 8;
            return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.h)(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.l)(len), boxName(name), buff);
        }
        /**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */        function createBoxWithChildren(name, children) {
            return createBox(name, _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.h.apply(void 0, children));
        }
        /***/    }, 
    /* 162 */
    /***/ function(module, exports, __webpack_require__) {
        var objectKeys = __webpack_require__(148), isArguments = __webpack_require__(185), is = __webpack_require__(186), isRegex = __webpack_require__(187), flags = __webpack_require__(191), isDate = __webpack_require__(193), getTime = Date.prototype.getTime;
        function deepEqual(actual, expected, options) {
            var opts = options || {};
            // 7.1. All identical values are equivalent, as determined by ===.
                        return !(opts.strict ? !is(actual, expected) : actual !== expected) || (
            // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
            !actual || !expected || "object" != typeof actual && "object" != typeof expected ? opts.strict ? is(actual, expected) : actual == expected : objEquiv(actual, expected, opts));
        }
        function isUndefinedOrNull(value) {
            return null == value;
        }
        function isBuffer(x) {
            return !(!x || "object" != typeof x || "number" != typeof x.length) && ("function" == typeof x.copy && "function" == typeof x.slice && !(0 < x.length && "number" != typeof x[0]));
        }
        function objEquiv(a, b, opts) {
            /* eslint max-statements: [2, 50] */
            var i, key;
            if (typeof a != typeof b) return !1;
            if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return !1;
            // an identical 'prototype' property.
                        if (a.prototype !== b.prototype) return !1;
            if (isArguments(a) !== isArguments(b)) return !1;
            var aIsRegex = isRegex(a), bIsRegex = isRegex(b);
            if (aIsRegex !== bIsRegex) return !1;
            if (aIsRegex || bIsRegex) return a.source === b.source && flags(a) === flags(b);
            if (isDate(a) && isDate(b)) return getTime.call(a) === getTime.call(b);
            var aIsBuffer = isBuffer(a), bIsBuffer = isBuffer(b);
            if (aIsBuffer !== bIsBuffer) return !1;
            if (aIsBuffer || bIsBuffer) {
                // && would work too, because both are true or both false here
                if (a.length !== b.length) return !1;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                return !0;
            }
            if (typeof a != typeof b) return !1;
            try {
                var ka = objectKeys(a), kb = objectKeys(b);
            } catch (e) {
                // happens when one is a string literal and the other isn't
                return !1;
            }
            // having the same number of owned properties (keys incorporates hasOwnProperty)
                        if (ka.length !== kb.length) return !1;
            // the same set of keys (although not necessarily the same order),
                        // ~~~cheap key test
            for (ka.sort(), kb.sort(), i = ka.length - 1; 0 <= i; i--) if (ka[i] != kb[i]) return !1;
            // equivalent values for every corresponding key, and ~~~possibly expensive deep test
                        for (i = ka.length - 1; 0 <= i; i--) if (!deepEqual(a[key = ka[i]], b[key], opts)) return !1;
            return !0;
        }
        module.exports = deepEqual;
    }, 
    /* 163 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Subject = __webpack_require__(41), QueueAction_QueueAction = /* */ function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this;
            }
            return tslib_es6.a(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), 0 < delay ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, 
                this.state = state, this.scheduler.flush(this), this);
            }, QueueAction.prototype.execute = function(state, delay) {
                return 0 < delay || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && 0 < delay || null === delay && 0 < this.delay ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this);
            }, QueueAction;
        }(__webpack_require__(78).a), queue = /* */ new (/* */ function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return tslib_es6.a(QueueScheduler, _super), QueueScheduler;
        }(__webpack_require__(77).a))(QueueAction_QueueAction), Subscription = __webpack_require__(16), Subscriber = __webpack_require__(7), Notification = __webpack_require__(70);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
                var observeOn_ObserveOnSubscriber = /* */ function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this;
            }
            return tslib_es6.a(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                var notification = arg.notification, destination = arg.destination;
                notification.observe(destination), this.unsubscribe();
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification.a.createNext(value));
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification.a.createError(err)), this.unsubscribe();
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification.a.createComplete()), this.unsubscribe();
            }, ObserveOnSubscriber;
        }(Subscriber.a), ObserveOnMessage = /* */ function() {
            return function ObserveOnMessage(notification, destination) {
                this.notification = notification, this.destination = destination;
            };
        }(), ObjectUnsubscribedError = __webpack_require__(51), SubjectSubscription = __webpack_require__(98);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return ReplaySubject_ReplaySubject;
        });
        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
        var ReplaySubject_ReplaySubject = /* */ function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, 
                _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, 
                _this;
            }
            return tslib_es6.a(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                var _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                _super.prototype.next.call(this, value);
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                if (subscription = this.isStopped || this.hasError ? Subscription.a.EMPTY : (this.observers.push(subscriber), 
                new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler)), 
                _infiniteTimeWindow) for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now();
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return _bufferSize < eventsCount && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                0 < spliceCount && _events.splice(0, spliceCount), _events;
            }, ReplaySubject;
        }(Subject.a), ReplayEvent = /* */ function() {
            return function ReplayEvent(time, value) {
                this.time = time, this.value = value;
            };
        }();
    }, 
    /* 164 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return distinctUntilChanged;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function distinctUntilChanged(compare, keySelector) {
            return function(source) {
                return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
            };
        }
        var DistinctUntilChangedOperator = /* */ function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            return DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }, DistinctUntilChangedOperator;
        }(), DistinctUntilChangedSubscriber = /* */ function(_super) {
            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
                var _this = _super.call(this, destination) || this;
                return _this.keySelector = keySelector, _this.hasKey = !1, "function" == typeof compare && (_this.compare = compare), 
                _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(DistinctUntilChangedSubscriber, _super), 
            DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
                return x === y;
            }, DistinctUntilChangedSubscriber.prototype._next = function(value) {
                var key;
                try {
                    var keySelector = this.keySelector;
                    key = keySelector ? keySelector(value) : value;
                } catch (err) {
                    return this.destination.error(err);
                }
                var result = !1;
                if (this.hasKey) try {
                    result = (0, this.compare)(this.key, key);
                } catch (err) {
                    return this.destination.error(err);
                } else this.hasKey = !0;
                result || (this.key = key, this.destination.next(value));
            }, DistinctUntilChangedSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 165 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mapTo;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function mapTo(value) {
            return function(source) {
                return source.lift(new MapToOperator(value));
            };
        }
        var MapToOperator = /* */ function() {
            function MapToOperator(value) {
                this.value = value;
            }
            return MapToOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapToSubscriber(subscriber, this.value));
            }, MapToOperator;
        }(), MapToSubscriber = /* */ function(_super) {
            function MapToSubscriber(destination, value) {
                var _this = _super.call(this, destination) || this;
                return _this.value = value, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapToSubscriber, _super), MapToSubscriber.prototype._next = function(x) {
                this.destination.next(this.value);
            }, MapToSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 166 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return takeUntil;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function takeUntil(notifier) {
            return function(source) {
                return source.lift(new TakeUntilOperator(notifier));
            };
        }
        var TakeUntilOperator = /* */ function() {
            function TakeUntilOperator(notifier) {
                this.notifier = notifier;
            }
            return TakeUntilOperator.prototype.call = function(subscriber, source) {
                var takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }, TakeUntilOperator;
        }(), TakeUntilSubscriber = /* */ function(_super) {
            function TakeUntilSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.seenValue = !1, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(TakeUntilSubscriber, _super), TakeUntilSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.seenValue = !0, this.complete();
            }, TakeUntilSubscriber.prototype.notifyComplete = function() {}, TakeUntilSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 167 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return shareReplay;
        });
        /* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(163);
        /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */        function shareReplay(configOrBufferSize, windowTime, scheduler) {
            var config;
            return config = configOrBufferSize && "object" == typeof configOrBufferSize ? configOrBufferSize : {
                bufferSize: configOrBufferSize,
                windowTime: windowTime,
                refCount: !1,
                scheduler: scheduler
            }, function(source) {
                return source.lift(shareReplayOperator(config));
            };
        }
        function shareReplayOperator(_a) {
            var subject, subscription, _b = _a.bufferSize, bufferSize = void 0 === _b ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = void 0 === _c ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler, refCount = 0, hasError = !1, isComplete = !1;
            return function shareReplayOperation(source) {
                refCount++, subject && !hasError || (hasError = !1, subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.a(bufferSize, windowTime, scheduler), 
                subscription = source.subscribe({
                    next: function(value) {
                        subject.next(value);
                    },
                    error: function(err) {
                        hasError = !0, subject.error(err);
                    },
                    complete: function() {
                        isComplete = !0, subject.complete();
                    }
                }));
                var innerSub = subject.subscribe(this);
                this.add(function() {
                    refCount--, innerSub.unsubscribe(), subscription && !isComplete && useRefCount && 0 === refCount && (subscription.unsubscribe(), 
                    subject = subscription = void 0);
                });
            };
        }
        //# sourceMappingURL=shareReplay.js.map
        /***/    }, 
    /* 168 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return filter;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function filter(predicate, thisArg) {
            return function filterOperatorFunction(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        var FilterOperator = /* */ function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }, FilterOperator;
        }(), FilterSubscriber = /* */ function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }, FilterSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 169 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return mergeMapTo;
        });
        /* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */        function mergeMapTo(innerObservable, resultSelector, concurrent) {
            return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector, concurrent) : ("number" == typeof resultSelector && (concurrent = resultSelector), 
            Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, concurrent));
        }
        //# sourceMappingURL=mergeMapTo.js.map
        /***/    }, 
    /* 170 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return share;
        });
        /* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87), _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113), _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
        /* harmony import */        
        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
        function shareSubjectFactory() {
            return new _Subject__WEBPACK_IMPORTED_MODULE_2__.a();
        }
        function share() {
            return function(source) {
                return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__.a)(shareSubjectFactory)(source));
            };
        }
        //# sourceMappingURL=share.js.map
        /***/    }, 
    /* 171 */ 
    /* 172 */ , 
    /* 173 */
    /***/ , 
    /* 173 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // ugly but working webpack workaround to be able to import the library in
        // CommonJS mode.
        // TODO investigate
        /* tslint:disable no-var-requires */        module.exports = __webpack_require__(194).default;
    }, 
    /* 174 */ 
    /* 175 */ , 
    /* 176 */
    /***/ , 
    /* 176 */
    /***/ function(module, exports) {
        var g;
        // This works in non-strict mode
                g = function() {
            return this;
        }();
        try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
        } catch (e) {
            // This works if the window reference is available
            "object" == typeof window && (g = window);
        }
        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}
                module.exports = g;
    }, 
    /* 177 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * @param {UInt8Array} buf
 * @returns {Object}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseBif(buf) {
            var pos = 0, length = buf.length, fileFormat = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 8)), minorVersion = buf[pos += 8], majorVersion = buf[pos += 1], patchVersion = buf[pos += 1], increVersion = buf[pos += 1];
            pos += 1;
            var version = [ minorVersion, majorVersion, patchVersion, increVersion ].join("."), imageCount = buf[pos] + Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos + 1);
            pos += 4;
            var timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
            pos += 4;
            var format = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.f)(buf.subarray(pos, pos + 4));
            pos += 4;
            var width = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos);
            pos += 2;
            var height = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.n)(buf, pos), aspectRatio = [ buf[pos += 2], buf[pos + 1] ].join(":"), isVod = 1 === buf[pos += 2];
            pos += 1, // bytes 0x1F to 0x40 is unused data for now
            pos = 64;
            var currentImage, thumbs = [], currentTs = 0;
            if (!imageCount) throw new Error("bif: no images to parse");
            for (;pos < length; ) {
                var currentImageIndex = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                pos += 4;
                var currentImageOffset = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.o)(buf, pos);
                if (pos += 4, currentImage) {
                    var index = currentImage.index, duration = timescale, ts = currentTs, data = buf.subarray(currentImage.offset, currentImageOffset);
                    thumbs.push({
                        index: index,
                        duration: duration,
                        ts: ts,
                        data: data
                    }), currentTs += timescale;
                }
                if (4294967295 === currentImageIndex) break;
                currentImage = {
                    index: currentImageIndex,
                    offset: currentImageOffset
                };
            }
            return {
                fileFormat: fileFormat,
                version: version,
                imageCount: imageCount,
                timescale: timescale,
                format: format,
                width: width,
                height: height,
                aspectRatio: aspectRatio,
                isVod: isVod,
                thumbs: thumbs
            };
        };
    }, 
    /* 178 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getPlayReadyKIDFromPrivateData;
        });
        /* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */        function getPlayReadyKIDFromPrivateData(data) {
            var xmlLength = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.n)(data, 8), xml = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.g)(data.subarray(10, xmlLength + 10)), kidElement = new DOMParser().parseFromString(xml, "application/xml").querySelector("KID");
            if (!kidElement) throw new Error("Cannot parse PlayReady private data: invalid XML");
            var kid = kidElement.textContent || "";
            return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__.i)(atob(kid)).toLowerCase();
        }
        /***/    }, 
    /* 179 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(107), _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /* harmony import */        
        /**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
        function createCuesFromArray(cuesArray) {
            for (var nativeCues = [], i = 0; i < cuesArray.length; i++) {
                var _cuesArray$i = cuesArray[i], start = _cuesArray$i.start, end = _cuesArray$i.end, text = _cuesArray$i.text;
                if (text && null != end) {
                    var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__.a)(start, end, text);
                    null != cue && nativeCues.push(cue);
                }
            }
            return nativeCues;
        }
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(BR, "\n").replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return createCuesFromArray(subs);
            function appendToSubs(lines, start) {
                for (var m, i = lines.length; 0 <= --i; ) if (m = lines[i].match(PARAG)) {
                    var _m = m, kl = _m[1], txt = _m[2];
                    klass === kl && ("&nbsp;" === txt ? subs[subs.length - 1].end = start : subs.push({
                        text: decodeEntities(txt),
                        start: start + timeOffset
                    }));
                }
            }
        };
    }, 
    /* 180 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToVTTCues;
        });
        /* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(107), _get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119), _parse_cue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(120);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // srt to VTTCue parser, Done for fun.
        // Heavily inspired from the WebVTT implementation
        /**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parseSRTStringToVTTCues(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_2__.a)(cueBlocks[i], timeOffset);
                if (cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    nativeCue && cues.push(nativeCue);
                }
            }
            return cues;
        }
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__.a)(start, end, text);
        }
        /***/    }, 
    /* 181 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31), HTML_ENTITIES = /&#([0-9]+);/g, BR = /<br>/gi, STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i, PARAG = /\s*<p class=([^>]+)>(.*)/i, START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
        //   - the text, start and end times are correctly parsed.
        //   - only text for the given language is parsed.
        //   - only the CSS style associated to the P element is set.
        //   - we should be safe for any XSS.
        // The language indicated to the parser should be present in the CSS and the
        // corresponding Class should be on the P elements. If we fail to find the
        // language in a "lang" property of a CSS class, the parser will throw.
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */        
        /**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
        function getClassNameByLang(str) {
            for (var m, ruleRe = /\.(\S+)\s*{([^}]*)}/gi, langs = {}; m = ruleRe.exec(str); ) {
                var name = m[1], lang = getCSSProperty(m[2], "lang");
                null != name && null != lang && (langs[lang] = name);
            }
            return langs;
        }
        /**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */        function getPCSSRules(str) {
            var rule = /p\s*{([^}]*)}/gi.exec(str);
            return rule ? rule[1] : "";
        }
        /**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */        function getCSSProperty(str, name) {
            var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
            return matches ? matches[1] : null;
        }
        /**
 * @param {string} text
 * @returns {string}
 */        function decodeEntities(text) {
            return text.replace(HTML_ENTITIES, function(_, $1) {
                return String.fromCharCode($1);
            });
        }
        /**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */        
        /* harmony default export */ __webpack_exports__.default = function parseSami(smi, timeOffset, lang) {
            var up, to, syncOpen = /<sync[ >]/gi, syncClose = /<sync[ >]|<\/body>/gi, subs = [], styleMatches = smi.match(STYLE), css = styleMatches ? styleMatches[1] : "";
            // FIXME Is that wanted?
            // previously written as let to = SyncClose.exec(smi); but never used
            syncClose.exec(smi);
            var langs = getClassNameByLang(css), pCSS = getPCSSRules(css), klass = lang && langs[lang];
            for (Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__.b)(!!klass, "sami: could not find lang " + lang + " in CSS"); up = syncOpen.exec(smi), 
            to = syncClose.exec(smi), up || to; ) {
                if (!up || !to || up.index >= to.index) throw new Error("parse error");
                var str = smi.slice(up.index, to.index), tim = str.match(START);
                if (!tim) throw new Error("parse error (sync time attribute)");
                var start = +tim[1];
                if (isNaN(start)) throw new Error("parse error (sync time attribute NaN)");
                appendToSubs(str.split("\n"), start / 1e3);
            }
            return subs;
            function appendToSubs(lines, start) {
                for (var i = lines.length; 0 <= --i; ) {
                    var paragraphInfos = lines[i].match(PARAG);
                    if (paragraphInfos) {
                        var className = paragraphInfos[1], txt = paragraphInfos[2];
                        if (klass === className) if ("&nbsp;" === txt) subs[subs.length - 1].end = start; else {
                            var wrapperEl = document.createElement("DIV");
                            wrapperEl.className = "rxp-texttrack-region";
                            var divEl = document.createElement("DIV");
                            divEl.className = "rxp-texttrack-div", divEl.style.position = "absolute", divEl.style.bottom = "0", 
                            divEl.style.width = "100%", divEl.style.color = "#fff", divEl.style.textShadow = "-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000";
                            var pEl = document.createElement("div");
                            pEl.className = "rxp-texttrack-p", pCSS && (pEl.style.cssText = pCSS);
                            for (var textEls = txt.split(BR), j = 0; j < textEls.length; j++) {
                                j && pEl.appendChild(document.createElement("BR"));
                                var spanEl = document.createElement("SPAN");
                                spanEl.className = "rxp-texttrack-span", spanEl.textContent = decodeEntities(textEls[j]), 
                                pEl.appendChild(spanEl);
                            }
                            divEl.appendChild(pEl), wrapperEl.appendChild(divEl), subs.push({
                                element: wrapperEl,
                                start: start + timeOffset,
                                end: -1
                            });
                        }
                    }
                }
            }
        };
    }, 
    /* 182 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return parseSRTStringToHTML;
        });
        /* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119), _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Parse SRT subtitles into HTML.
        // Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
        // of tags.
        /**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
        function parseSRTStringToHTML(srtStr, timeOffset) {
            for (
            // Even if srt only authorize CRLF, we will also take LF or CR as line
            // terminators for resilience
            var lines = srtStr.split(/\r\n|\n|\r/), cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__.a)(lines), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_1__.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject);
                    null != htmlCue && cues.push(htmlCue);
                }
            }
            return cues;
        }
        /**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */        function toHTML(cueObj) {
            var start = cueObj.start, end = cueObj.end, payload = cueObj.payload, pEl = document.createElement("div");
            pEl.className = "rxp-texttrack-p", pEl.style.fontSize = "28px", pEl.style.position = "absolute", 
            pEl.style.bottom = "5%", pEl.style.width = "100%", pEl.style.textAlign = "center", 
            pEl.style.color = "#fff", pEl.style.textShadow = "-1px -1px 2px #000,1px -1px 2px #000,-1px 1px 2px #000,1px 1px 2px #000";
            for (var i = 0; i < payload.length; i++) {
                i && pEl.appendChild(document.createElement("br"));
                var span = generateSpansFromSRTText(payload[i]);
                pEl.appendChild(span);
            }
            return {
                start: start,
                end: end,
                element: pEl
            };
        }
        /**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */        function generateSpansFromSRTText(text) {
            var secureDiv = document.createElement("div");
            secureDiv.innerHTML = text;
            return function _loop(node) {
                var childNodes = node.childNodes, span = document.createElement("span");
                span.className = "rxp-texttrack-span";
                for (var i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        for (var linifiedText = currentNode.wholeText.split("\n"), line = 0; line < linifiedText.length; line++) if (line && span.appendChild(document.createElement("br")), 
                        0 < linifiedText[line].length) {
                            var textNode = document.createTextNode(linifiedText[line]);
                            span.appendChild(textNode);
                        }
                    } else if ("B" === currentNode.nodeName) {
                        var spanChild = _loop(currentNode);
                        spanChild.style.fontWeight = "bold", span.appendChild(spanChild);
                    } else if ("I" === currentNode.nodeName) {
                        var _spanChild = _loop(currentNode);
                        _spanChild.style.fontStyle = "italic", span.appendChild(_spanChild);
                    } else if ("U" === currentNode.nodeName) {
                        var _spanChild2 = _loop(currentNode);
                        _spanChild2.style.textDecoration = "underline", span.appendChild(_spanChild2);
                    } else if ("FONT" === currentNode.nodeName && null != currentNode.color) {
                        // TODO loop through attributes to find color?
                        var _spanChild3 = _loop(currentNode);
                        _spanChild3.style.color = currentNode.color, span.appendChild(_spanChild3);
                    } else {
                        var _spanChild4 = _loop(currentNode);
                        span.appendChild(_spanChild4);
                    }
                }
                return span;
            }(secureDiv);
        }
        /***/    }, 
    /* 183 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() {
            return initializeDirectfileContent;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(170), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(168), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(128), rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(169), rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(137), _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(84), _compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(131), _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(53), _log__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(0), _create_eme_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(112), _events_generators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(26), _get_stalled_events__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(116), _initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(109), _is_eme_ready__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(117), _throw_on_media_error__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(114), _update_playback_rate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(115);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */
        function getDirectFileInitialTime(mediaElement, startAt) {
            if (!startAt) return 0;
            if (null != startAt.position) return startAt.position;
            if (null != startAt.wallClockTime) return startAt.wallClockTime;
            if (null != startAt.fromFirstPosition) return startAt.fromFirstPosition;
            var duration = mediaElement.duration;
            if (!duration || !isFinite(duration)) return _log__WEBPACK_IMPORTED_MODULE_14__.a.warn("startAt.fromLastPosition set but no known duration, beginning at 0."), 
            0;
            if (startAt.fromLastPosition) return Math.max(0, duration + startAt.fromLastPosition);
            if (null == startAt.percentage) return 0;
            var percentage = startAt.percentage;
            return 100 <= percentage ? duration : percentage <= 0 ? 0 : duration * (+percentage / 100);
        }
        /**
 * Launch a content in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */        function initializeDirectfileContent(_ref) {
            var autoPlay = _ref.autoPlay, clock$ = _ref.clock$, keySystems = _ref.keySystems, mediaElement = _ref.mediaElement, speed$ = _ref.speed$, startAt = _ref.startAt, url = _ref.url;
            if (Object(_compat__WEBPACK_IMPORTED_MODULE_11__.a)(mediaElement), null == url) throw new Error("No URL for a DirectFile content");
 // Start everything! (Just put the URL in the element's src).
                        var linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_12__.a)(mediaElement, url);
            _log__WEBPACK_IMPORTED_MODULE_14__.a.debug("Init: Calculating initial time");
            function initialTime() {
                return getDirectFileInitialTime(mediaElement, startAt);
            }
            _log__WEBPACK_IMPORTED_MODULE_14__.a.debug("Init: Initial time calculated:", initialTime);
            var _seekAndLoadOnMediaEv = Object(_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__.a)(clock$, mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, emeManager$ = linkURL$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function() {
                return Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_15__.a)(mediaElement, keySystems);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(rxjs__WEBPACK_IMPORTED_MODULE_0__.a), // multiple Observables here are based on this one
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)()), mediaError$ = Object(_throw_on_media_error__WEBPACK_IMPORTED_MODULE_20__.a)(mediaElement), playbackRate$ = Object(_update_playback_rate__WEBPACK_IMPORTED_MODULE_21__.a)(mediaElement, speed$, clock$, {
                pauseWhenStalled: !0
            }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.speedChanged)), stalled$ = Object(_get_stalled_events__WEBPACK_IMPORTED_MODULE_17__.a)(clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.stalled)), loadedEvent$ = emeManager$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)(_is_eme_ready__WEBPACK_IMPORTED_MODULE_19__.a), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(load$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(function(evt) {
                if ("autoplay-blocked" === evt) {
                    var error = new _errors__WEBPACK_IMPORTED_MODULE_13__.a("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: your browser does not allow it.");
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.warning(error), _events_generators__WEBPACK_IMPORTED_MODULE_16__.a.loaded());
                }
                if ("not-loaded-metadata" !== evt) return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.loaded());
                var _error = new _errors__WEBPACK_IMPORTED_MODULE_13__.a("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser falsely announced having loaded the content.");
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(_events_generators__WEBPACK_IMPORTED_MODULE_16__.a.warning(_error));
            })), initialSeek$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)());
 // Create EME Manager, an observable which will manage every EME-related
            // issue.
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(loadedEvent$, initialSeek$, emeManager$, mediaError$, playbackRate$, stalled$);
        }
        /***/    }, 
    /* 184 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var keysShim;
        if (!Object.keys) {
            // modified from https://github.com/es-shims/es5-shim
            var has = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, isArgs = __webpack_require__(149), isEnumerable = Object.prototype.propertyIsEnumerable, hasDontEnumBug = !isEnumerable.call({
                toString: null
            }, "toString"), hasProtoEnumBug = isEnumerable.call(function() {}, "prototype"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], equalsConstructorPrototype = function(o) {
                var ctor = o.constructor;
                return ctor && ctor.prototype === o;
            }, excludedKeys = {
                $applicationCache: !0,
                $console: !0,
                $external: !0,
                $frame: !0,
                $frameElement: !0,
                $frames: !0,
                $innerHeight: !0,
                $innerWidth: !0,
                $onmozfullscreenchange: !0,
                $onmozfullscreenerror: !0,
                $outerHeight: !0,
                $outerWidth: !0,
                $pageXOffset: !0,
                $pageYOffset: !0,
                $parent: !0,
                $scrollLeft: !0,
                $scrollTop: !0,
                $scrollX: !0,
                $scrollY: !0,
                $self: !0,
                $webkitIndexedDB: !0,
                $webkitStorageInfo: !0,
                $window: !0
            }, hasAutomationEqualityBug = function() {
                /* global window */
                if ("undefined" == typeof window) return !1;
                for (var k in window) try {
                    if (!excludedKeys["$" + k] && has.call(window, k) && null !== window[k] && "object" == typeof window[k]) try {
                        equalsConstructorPrototype(window[k]);
                    } catch (e) {
                        return !0;
                    }
                } catch (e) {
                    return !0;
                }
                return !1;
            }(), equalsConstructorPrototypeIfNotBuggy = function(o) {
                /* global window */
                if ("undefined" == typeof window || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
                try {
                    return equalsConstructorPrototype(o);
                } catch (e) {
                    return !1;
                }
            };
            keysShim = function keys(object) {
                var isObject = null !== object && "object" == typeof object, isFunction = "[object Function]" === toStr.call(object), isArguments = isArgs(object), isString = isObject && "[object String]" === toStr.call(object), theKeys = [];
                if (!isObject && !isFunction && !isArguments) throw new TypeError("Object.keys called on a non-object");
                var skipProto = hasProtoEnumBug && isFunction;
                if (isString && 0 < object.length && !has.call(object, 0)) for (var i = 0; i < object.length; ++i) theKeys.push(String(i));
                if (isArguments && 0 < object.length) for (var j = 0; j < object.length; ++j) theKeys.push(String(j)); else for (var name in object) skipProto && "prototype" === name || !has.call(object, name) || theKeys.push(String(name));
                if (hasDontEnumBug) for (var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object), k = 0; k < dontEnums.length; ++k) skipConstructor && "constructor" === dontEnums[k] || !has.call(object, dontEnums[k]) || theKeys.push(dontEnums[k]);
                return theKeys;
            };
        }
        module.exports = keysShim;
    }, 
    /* 185 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        function isStandardArguments(value) {
            return !(hasToStringTag && value && "object" == typeof value && Symbol.toStringTag in value) && "[object Arguments]" === toStr.call(value);
        }
        function isLegacyArguments(value) {
            return !!isStandardArguments(value) || null !== value && "object" == typeof value && "number" == typeof value.length && 0 <= value.length && "[object Array]" !== toStr.call(value) && "[object Function]" === toStr.call(value.callee);
        }
        var hasToStringTag = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, toStr = Object.prototype.toString, supportsStandardArguments = function() {
            return isStandardArguments(arguments);
        }();
        isStandardArguments.isLegacyArguments = isLegacyArguments, // for tests
        module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }, 
    /* 186 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */        function NumberIsNaN(value) {
            return value != value;
        }
        module.exports = function is(a, b) {
            return 0 === a && 0 === b ? 1 / a == 1 / b : a === b || !(!NumberIsNaN(a) || !NumberIsNaN(b));
        };
    }, 
    /* 187 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        function tryRegexExecCall(value) {
            try {
                var lastIndex = value.lastIndex;
                return value.lastIndex = 0, regexExec.call(value), !0;
            } catch (e) {
                return !1;
            } finally {
                value.lastIndex = lastIndex;
            }
        }
        var has = __webpack_require__(188), regexExec = RegExp.prototype.exec, gOPD = Object.getOwnPropertyDescriptor, toStr = Object.prototype.toString, hasToStringTag = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
        module.exports = function isRegex(value) {
            if (!value || "object" != typeof value) return !1;
            if (!hasToStringTag) return "[object RegExp]" === toStr.call(value);
            var descriptor = gOPD(value, "lastIndex");
            return !(!descriptor || !has(descriptor, "value")) && tryRegexExecCall(value);
        };
    }, 
    /* 188 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__(189);
        module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }, 
    /* 189 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var implementation = __webpack_require__(190);
        module.exports = Function.prototype.bind || implementation;
    }, 
    /* 190 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        /* eslint no-invalid-this: 1 */        var slice = Array.prototype.slice, toStr = Object.prototype.toString;
        module.exports = function bind(that) {
            var target = this;
            if ("function" != typeof target || "[object Function]" !== toStr.call(target)) throw new TypeError("Function.prototype.bind called on incompatible " + target);
            for (var bound, args = slice.call(arguments, 1), boundLength = Math.max(0, target.length - args.length), boundArgs = [], i = 0; i < boundLength; i++) boundArgs.push("$" + i);
            if (bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(function() {
                if (this instanceof bound) {
                    var result = target.apply(this, args.concat(slice.call(arguments)));
                    return Object(result) === result ? result : this;
                }
                return target.apply(that, args.concat(slice.call(arguments)));
            }), target.prototype) {
                var Empty = function Empty() {};
                Empty.prototype = target.prototype, bound.prototype = new Empty(), Empty.prototype = null;
            }
            return bound;
        };
    }, 
    /* 191 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var define = __webpack_require__(129), implementation = __webpack_require__(150), getPolyfill = __webpack_require__(151), shim = __webpack_require__(192), flagsBound = Function.call.bind(implementation);
        define(flagsBound, {
            getPolyfill: getPolyfill,
            implementation: implementation,
            shim: shim
        }), module.exports = flagsBound;
    }, 
    /* 192 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        var supportsDescriptors = __webpack_require__(129).supportsDescriptors, getPolyfill = __webpack_require__(151), gOPD = Object.getOwnPropertyDescriptor, defineProperty = Object.defineProperty, TypeErr = TypeError, getProto = Object.getPrototypeOf, regex = /a/;
        module.exports = function shimFlags() {
            if (!supportsDescriptors || !getProto) throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
            var polyfill = getPolyfill(), proto = getProto(regex), descriptor = gOPD(proto, "flags");
            return descriptor && descriptor.get === polyfill || defineProperty(proto, "flags", {
                configurable: !0,
                enumerable: !1,
                get: polyfill
            }), polyfill;
        };
    }, 
    /* 193 */
    /***/ function(module, exports, __webpack_require__) {
        "use strict";
        function tryDateObject(value) {
            try {
                return getDay.call(value), !0;
            } catch (e) {
                return !1;
            }
        }
        var getDay = Date.prototype.getDay, toStr = Object.prototype.toString, hasToStringTag = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
        module.exports = function isDateObject(value) {
            return "object" == typeof value && null !== value && (hasToStringTag ? tryDateObject(value) : "[object Date]" === toStr.call(value));
        };
    }, 
    /* 194 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/deep-equal/index.js
        var deep_equal = __webpack_require__(162), deep_equal_default = /* */ __webpack_require__.n(deep_equal), object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), Subject = __webpack_require__(41), ReplaySubject = __webpack_require__(163), tslib_es6 = __webpack_require__(2), ObjectUnsubscribedError = __webpack_require__(51), BehaviorSubject_BehaviorSubject = /* */ function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this;
            }
            return tslib_es6.a(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue();
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError.a();
                return this._value;
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
            }, BehaviorSubject;
        }(Subject.a), merge = __webpack_require__(81), empty = __webpack_require__(55), combineLatest = __webpack_require__(213), concat = __webpack_require__(124), of = __webpack_require__(23), takeUntil = __webpack_require__(166), map = __webpack_require__(34), distinctUntilChanged = __webpack_require__(164), take = __webpack_require__(128), multicast = __webpack_require__(87);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
        function publish(selector) {
            return selector ? Object(multicast.a)(function() {
                return new Subject.a();
            }, selector) : Object(multicast.a)(new Subject.a());
        }
        //# sourceMappingURL=publish.js.map
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
                var filter = __webpack_require__(168), share = __webpack_require__(170), startWith = __webpack_require__(205), mapTo = __webpack_require__(165), Subscriber = __webpack_require__(7);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function skipWhile(predicate) {
            return function(source) {
                return source.lift(new SkipWhileOperator(predicate));
            };
        }
        var SkipWhileOperator = /* */ function() {
            function SkipWhileOperator(predicate) {
                this.predicate = predicate;
            }
            return SkipWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new skipWhile_SkipWhileSubscriber(subscriber, this.predicate));
            }, SkipWhileOperator;
        }(), skipWhile_SkipWhileSubscriber = /* */ function(_super) {
            function SkipWhileSubscriber(destination, predicate) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.skipping = !0, _this.index = 0, _this;
            }
            return tslib_es6.a(SkipWhileSubscriber, _super), SkipWhileSubscriber.prototype._next = function(value) {
                var destination = this.destination;
                this.skipping && this.tryCallPredicate(value), this.skipping || destination.next(value);
            }, SkipWhileSubscriber.prototype.tryCallPredicate = function(value) {
                try {
                    var result = this.predicate(value, this.index++);
                    this.skipping = Boolean(result);
                } catch (err) {
                    this.destination.error(err);
                }
            }, SkipWhileSubscriber;
        }(Subscriber.a), switchMapTo = __webpack_require__(220), mergeMapTo = __webpack_require__(169), catchError = __webpack_require__(207), config = __webpack_require__(3), log = __webpack_require__(0), event_emitter = __webpack_require__(38), noop = __webpack_require__(28), promise = __webpack_require__(29), ranges = __webpack_require__(15), warn_once = __webpack_require__(19), compat = __webpack_require__(6), fullscreen = __webpack_require__(89), media_error = __webpack_require__(53), encrypted_media_error = __webpack_require__(80), error_codes = __webpack_require__(33), network_error = __webpack_require__(160), other_error = __webpack_require__(64);
        // CONCATENATED MODULE: ./src/errors/is_known_error.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */
        function isKnownError(error) {
            return (error instanceof encrypted_media_error.a || error instanceof media_error.a || error instanceof other_error.a || error instanceof network_error.a) && 0 <= Object.keys(error_codes.b).indexOf(error.type);
        }
        // CONCATENATED MODULE: ./src/errors/format_error.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */        function formatError(error, _ref) {
            var defaultCode = _ref.defaultCode, defaultReason = _ref.defaultReason;
            if (isKnownError(error)) return error;
            var reason = error instanceof Error ? error.toString() : defaultReason;
            return new other_error.a(defaultCode, reason);
        }
        // EXTERNAL MODULE: ./src/features/index.ts
                var features = __webpack_require__(10), dispose_eme = __webpack_require__(142), get_current_key_system = __webpack_require__(143), clear_eme_session = __webpack_require__(141), asap = __webpack_require__(88), timer = __webpack_require__(217), mergeMap = __webpack_require__(44), subscribeOn = __webpack_require__(209), switchMap = __webpack_require__(125), tap = __webpack_require__(138), ignoreElements = __webpack_require__(137), Subscription = __webpack_require__(16);
        // EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
        function finalize(callback) {
            return function(source) {
                return source.lift(new FinallyOperator(callback));
            };
        }
        var FinallyOperator = /* */ function() {
            function FinallyOperator(callback) {
                this.callback = callback;
            }
            return FinallyOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
            }, FinallyOperator;
        }(), finalize_FinallySubscriber = /* */ function(_super) {
            function FinallySubscriber(destination, callback) {
                var _this = _super.call(this, destination) || this;
                return _this.add(new Subscription.a(callback)), _this;
            }
            return tslib_es6.a(FinallySubscriber, _super), FinallySubscriber;
        }(Subscriber.a), Observable = __webpack_require__(8);
        // CONCATENATED MODULE: ./src/utils/rx-throttle.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function throttle(func) {
            var isPending = !1;
            return function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return new Observable.a(function(obs) {
                    if (!isPending) {
                        isPending = !0;
                        var funcSubscription = func.apply(void 0, args).subscribe(function(i) {
                            obs.next(i);
                        }, function(e) {
                            isPending = !1, obs.error(e);
                        }, function() {
                            isPending = !1, obs.complete();
                        });
                        return function() {
                            funcSubscription.unsubscribe(), isPending = !1;
                        };
                    }
                    obs.complete();
                });
            };
        }
        // CONCATENATED MODULE: ./src/core/abr/ewma.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */        var EWMA = 
        /* */
        function() {
            /**
   * @param {number} halfLife
   */
            function EWMA(halfLife) {
                // (half-life = log(1/2) / log(Decay Factor)
                this._alpha = Math.exp(Math.log(.5) / halfLife), this._lastEstimate = 0, this._totalWeight = 0;
            }
            /**
   * @param {number} weight
   * @param {number} value
   */            var _proto = EWMA.prototype;
            return _proto.addSample = function addSample(weight, value) {
                var adjAlpha = Math.pow(this._alpha, weight), newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
                isNaN(newEstimate) || (this._lastEstimate = newEstimate, this._totalWeight += weight);
            }
            /**
   * @returns {number} value
   */ , _proto.getEstimate = function getEstimate() {
                var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
                return this._lastEstimate / zeroFactor;
            }, EWMA;
        }(), ABR_MINIMUM_TOTAL_BYTES = config.a.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config.a.ABR_MINIMUM_CHUNK_SIZE, ABR_FAST_EMA = config.a.ABR_FAST_EMA, ABR_SLOW_EMA = config.a.ABR_SLOW_EMA, bandwidth_estimator_BandwidthEstimator = 
        /* */
        function() {
            function BandwidthEstimator() {
                /**
     * A fast-moving average.
     * @private
     */
                this._fastEWMA = new EWMA(ABR_FAST_EMA), 
                /**
     * A slow-moving average.
     * @private
     */
                this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                /**
     * Number of bytes sampled.
     * @private
     */
                this._bytesSampled = 0;
            }
            /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */            var _proto = BandwidthEstimator.prototype;
            return _proto.addSample = function addSample(durationInMs, numberOfBytes) {
                if (!(numberOfBytes < ABR_MINIMUM_CHUNK_SIZE)) {
                    var bandwidth = 8e3 * numberOfBytes / durationInMs, weight = durationInMs / 1e3;
                    this._bytesSampled += numberOfBytes, this._fastEWMA.addSample(weight, bandwidth), 
                    this._slowEWMA.addSample(weight, bandwidth);
                }
            }
            /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */ , _proto.getEstimate = function getEstimate() {
                if (!(this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES)) // Take the minimum of these two estimates.  This should have the effect of
                // adapting down quickly, but up more slowly.
                return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
            }
            /**
   * Reset the bandwidth estimation.
   */ , _proto.reset = function reset() {
                this._fastEWMA = new EWMA(ABR_FAST_EMA), this._slowEWMA = new EWMA(ABR_SLOW_EMA), 
                this._bytesSampled = 0;
            }, BandwidthEstimator;
        }();
        // CONCATENATED MODULE: ./src/core/abr/bandwidth_estimator.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./src/core/abr/create_filters.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Observable that merge several throttling Observables into one.
 * @param {Observable} limitWidth$ - Emit the width at which the chosen
 * Representation should be limited.
 * @param {Observable} throttleBitrate$ - Emit the maximum bitrate authorized.
 * @param {Observable} throttle$ - Also emit the maximum bitrate authorized.
 * Here for legacy reasons.
 * @returns {Observable}
 */
        function createFilters(limitWidth$, throttleBitrate$, throttle$) {
            var deviceEventsArray = [];
            // Emit restrictions on the pools of available representations to choose
            // from.
            return limitWidth$ && deviceEventsArray.push(limitWidth$.pipe(Object(map.a)(function(width) {
                return {
                    width: width
                };
            }))), throttle$ && deviceEventsArray.push(throttle$.pipe(Object(map.a)(function(bitrate) {
                return {
                    bitrate: bitrate
                };
            }))), throttleBitrate$ && deviceEventsArray.push(throttleBitrate$.pipe(Object(map.a)(function(bitrate) {
                return {
                    bitrate: bitrate
                };
            }))), deviceEventsArray.length ? Object(combineLatest.a)(deviceEventsArray).pipe(Object(map.a)(function(args) {
                return object_assign_default.a.apply(void 0, [ {} ].concat(args));
            })) : Object(of.a)({});
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
                var defer = __webpack_require__(82), OuterSubscriber = __webpack_require__(25), subscribeToResult = __webpack_require__(24);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function withLatestFrom() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return function(source) {
                var project;
                "function" == typeof args[args.length - 1] && (project = args.pop());
                var observables = args;
                return source.lift(new WithLatestFromOperator(observables, project));
            };
        }
        var WithLatestFromOperator = /* */ function() {
            function WithLatestFromOperator(observables, project) {
                this.observables = observables, this.project = project;
            }
            return WithLatestFromOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new withLatestFrom_WithLatestFromSubscriber(subscriber, this.observables, this.project));
            }, WithLatestFromOperator;
        }(), withLatestFrom_WithLatestFromSubscriber = /* */ function(_super) {
            function WithLatestFromSubscriber(destination, observables, project) {
                var _this = _super.call(this, destination) || this;
                _this.observables = observables, _this.project = project, _this.toRespond = [];
                var len = observables.length;
                _this.values = new Array(len);
                for (var i = 0; i < len; i++) _this.toRespond.push(i);
                for (i = 0; i < len; i++) {
                    var observable = observables[i];
                    _this.add(Object(subscribeToResult.a)(_this, observable, observable, i));
                }
                return _this;
            }
            return tslib_es6.a(WithLatestFromSubscriber, _super), WithLatestFromSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.values[outerIndex] = innerValue;
                var toRespond = this.toRespond;
                if (0 < toRespond.length) {
                    var found = toRespond.indexOf(outerIndex);
                    -1 !== found && toRespond.splice(found, 1);
                }
            }, WithLatestFromSubscriber.prototype.notifyComplete = function() {}, WithLatestFromSubscriber.prototype._next = function(value) {
                if (0 === this.toRespond.length) {
                    var args = [ value ].concat(this.values);
                    this.project ? this._tryProject(args) : this.destination.next(args);
                }
            }, WithLatestFromSubscriber.prototype._tryProject = function(args) {
                var result;
                try {
                    result = this.project.apply(this, args);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, WithLatestFromSubscriber;
        }(OuterSubscriber.a);
        //# sourceMappingURL=withLatestFrom.js.map
        // CONCATENATED MODULE: ./src/core/abr/get_buffer_levels.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return "Buffer Levels" which are steps of available buffers from which we
 * are normally able switch safely to the next available bitrate.
 * (Following an algorithm close to BOLA)
 * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in
 * ascending order.
 * @returns {Array.<number>}
 */
        function getBufferLevels(bitrates) {
            var logs = bitrates.map(function(b) {
                return Math.log(b / bitrates[0]);
            }), utilities = logs.map(function(l) {
                return l - logs[0] + 1;
            }), gp = (utilities[utilities.length - 1] - 1) / (2 * bitrates.length + 10), Vp = 1 / gp;
            return bitrates.map(function(_, i) {
                return minBufferLevelForBitrate(i);
            });
            /**
   * Get minimum buffer we should keep ahead to pick this bitrate.
   * @param {number} index
   * @returns {number}
   */            function minBufferLevelForBitrate(index) {
                if (0 === index) return 0;
                var boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
                return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] - bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) + 4;
            }
        }
        // CONCATENATED MODULE: ./src/utils/array_find_index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */        function arrayFindIndex(arr, predicate, thisArg) {
            if ("function" == typeof Array.prototype.findIndex) 
            /* tslint:disable ban */
            return arr.findIndex(predicate, thisArg);
            /* tslint:enable ban */            for (var len = arr.length >>> 0, i = 0; i < len; i++) if (predicate.call(thisArg, arr[i], i, arr)) return i;
            return -1;
        }
        // CONCATENATED MODULE: ./src/core/abr/get_estimate_from_buffer_levels.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * From the buffer gap, choose a representation.
 * @param {Object} clockTick
 * @param {Array.<Number>} bitrates
 * @param {Array.<Number>} bufferLevels
 * @returns {Object|undefined}
 */        function getEstimateFromBufferLevels(clockTick, bitrates, bufferLevels) {
            var bufferGap = clockTick.bufferGap, currentBitrate = clockTick.currentBitrate, currentScore = clockTick.currentScore, speed = clockTick.speed;
            if (null == currentBitrate) return bitrates[0];
            var scaledScore, currentBitrateIndex = arrayFindIndex(bitrates, function(b) {
                return b === currentBitrate;
            });
            if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) return log.a.error("ABR: Current Bitrate not found in the calculated levels"), 
            bitrates[0];
            if (null != currentScore && (scaledScore = 0 === speed ? currentScore : currentScore / speed), 
            null != scaledScore && 1 < scaledScore) {
                var currentBufferLevel = bufferLevels[currentBitrateIndex], nextIndex = function() {
                    for (var i = currentBitrateIndex + 1; i < bufferLevels.length; i++) if (bufferLevels[i] > currentBufferLevel) return i;
                }();
                if (null != nextIndex) if (bufferLevels[nextIndex] <= bufferGap) return bitrates[nextIndex];
            }
            if ((null == scaledScore || scaledScore < 1.15) && bufferGap < bufferLevels[currentBitrateIndex]) {
                for (var i = currentBitrateIndex - 1; 0 <= i; i--) if (bitrates[i] < currentBitrate) return bitrates[i];
                return currentBitrate;
            }
            return currentBitrate;
        }
        // CONCATENATED MODULE: ./src/core/abr/buffer_based_chooser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Choose a bitrate based on the currently available buffer.
 *
 * This algorithm is based on the deviation of the BOLA algorithm.
 * It is a hybrid solution that also relies on a given bitrate's
 * "maintainability".
 * Each time a chunk is downloaded, from the ratio between the chunk duration
 * and chunk's request time, we can assume that the representation is
 * "maintanable" or not.
 * If so, we may switch to a better quality, or conversely to a worse quality.
 *
 * @param {Observable} update$
 * @param {Array.<number>} bitrates
 * @returns {Observable}
 */        function BufferBasedChooser(update$, bitrates) {
            var levelsMap = getBufferLevels(bitrates);
            return log.a.debug("ABR: Steps for buffer based chooser.", levelsMap.map(function(l, i) {
                return {
                    bufferLevel: l,
                    bitrate: bitrates[i]
                };
            })), update$.pipe(Object(map.a)(function(clockTick) {
                return getEstimateFromBufferLevels(clockTick, bitrates, levelsMap);
            }));
        }
        // CONCATENATED MODULE: ./src/core/abr/filter_by_bitrate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */        function filterByBitrate(representations, bitrate) {
            var firstSuperiorBitrate = arrayFindIndex(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === firstSuperiorBitrate ? representations : representations.slice(0, firstSuperiorBitrate);
        }
        // EXTERNAL MODULE: ./src/utils/array_find.ts
                var array_find = __webpack_require__(9);
        // CONCATENATED MODULE: ./src/core/abr/filter_by_width.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */        function filterByWidth(representations, width) {
            var sortedRepsByWidth = representations.slice().sort(function(a, b) {
                return (a.width || 0) - (b.width || 0);
            }), repWithMaxWidth = Object(array_find.a)(sortedRepsByWidth, function(representation) {
                return (representation.width || 0) >= width;
            });
            if (repWithMaxWidth) {
                var maxWidth = repWithMaxWidth.width || 0;
                return representations.filter(function(representation) {
                    return (representation.width || 0) <= maxWidth;
                });
            }
            return representations;
        }
        // CONCATENATED MODULE: ./src/core/abr/from_bitrate_ceil.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation|undefined}
 */        function fromBitrateCeil(representations, bitrate) {
            var tooHighIndex = arrayFindIndex(representations, function(representation) {
                return representation.bitrate > bitrate;
            });
            return -1 === tooHighIndex ? representations[representations.length - 1] : representations[tooHighIndex - 1];
        }
        // CONCATENATED MODULE: ./src/core/abr/network_analyzer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ABR_REGULAR_FACTOR = config.a.ABR_REGULAR_FACTOR, ABR_STARVATION_DURATION_DELTA = config.a.ABR_STARVATION_DURATION_DELTA, ABR_STARVATION_FACTOR = config.a.ABR_STARVATION_FACTOR, ABR_STARVATION_GAP = config.a.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config.a.OUT_OF_STARVATION_GAP;
        /**
 * Get the pending request starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {IRequestInfo|undefined}
 */        function getConcernedRequest(requests, neededPosition) {
            for (var i = 0; i < requests.length; i++) {
                var request = requests[i];
                if (0 < request.duration) if (neededPosition < request.time + request.duration && -.3 < neededPosition - request.time) return request;
            }
        }
        /**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */        function estimateRequestBandwidth(request) {
            if (!(request.progress.length < 2)) {
                for (// try to infer quickly the current bitrate based on the
                // progress events
                var ewma1 = new EWMA(2), progress = request.progress, i = 1; i < progress.length; i++) {
                    var bytesDownloaded = progress[i].size - progress[i - 1].size, timeElapsed = progress[i].timestamp - progress[i - 1].timestamp, reqBitrate = 8 * bytesDownloaded / (timeElapsed / 1e3);
                    ewma1.addSample(timeElapsed / 1e3, reqBitrate);
                }
                return ewma1.getEstimate();
            }
        }
        /**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */        function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
            var remainingData = 8 * (lastProgressEvent.totalSize - lastProgressEvent.size);
            return Math.max(remainingData / bandwidthEstimate, 0);
        }
        /**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} clock - Information on the current playback.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimation emitted.
 * @returns {Number|undefined}
 */        function estimateStarvationModeBitrate(pendingRequests, clock, currentRepresentation, lastEstimatedBitrate) {
            var concernedRequest = getConcernedRequest(pendingRequests, clock.currentTime + clock.bufferGap);
            if (concernedRequest) {
                var chunkDuration = concernedRequest.duration, now = performance.now(), lastProgressEvent = concernedRequest.progress ? concernedRequest.progress[concernedRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
                if (null != lastProgressEvent && null != bandwidthEstimate) {
                    var remainingTime = 1.2 * estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
 // if this remaining time is reliable and is not enough to avoid buffering
                                        if ((now - lastProgressEvent.timestamp) / 1e3 <= remainingTime && remainingTime > clock.bufferGap / clock.speed) return bandwidthEstimate;
                }
                var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1e3;
                if (!(null == currentRepresentation || requestElapsedTime <= (1.5 * chunkDuration + 1) / clock.speed)) {
                    // calculate a reduced bitrate from the current one
                    var reducedBitrate = .7 * currentRepresentation.bitrate;
                    return null == lastEstimatedBitrate || reducedBitrate < lastEstimatedBitrate ? reducedBitrate : void 0;
                }
            }
        }
        /**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} clock
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @returns {boolean}
 */        function shouldDirectlySwitchToLowBitrate(clock, requests, abrStarvationGap) {
            var nextNeededPosition = clock.currentTime + clock.bufferGap, nextNeededRequest = Object(array_find.a)(requests, function(r) {
                return r.time + r.duration > nextNeededPosition;
            });
            if (!nextNeededRequest) return !0;
            var now = performance.now(), lastProgressEvent = nextNeededRequest.progress ? nextNeededRequest.progress[nextNeededRequest.progress.length - 1] : null, bandwidthEstimate = estimateRequestBandwidth(nextNeededRequest);
            if (null == lastProgressEvent || null == bandwidthEstimate) return !0;
            var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
            return !((now - lastProgressEvent.timestamp) / 1e3 <= 1.2 * remainingTime && remainingTime < clock.bufferGap / clock.speed + abrStarvationGap);
        }
        /**
 * Analyze the current network conditions and give a bandwidth estimate as well
 * as a maximum bitrate a Representation should be.
 * @class NetworkAnalyzer
 */        var network_analyzer_NetworkAnalyzer = 
        /* */
        function() {
            function NetworkAnalyzer(initialBitrate, lowLatencyMode) {
                this._initialBitrate = initialBitrate, this._inStarvationMode = !1, this._config = lowLatencyMode ? {
                    starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
                    outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
                    starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
                    regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY
                } : {
                    starvationGap: ABR_STARVATION_GAP.DEFAULT,
                    outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
                    starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
                    regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT
                };
            }
            var _proto = NetworkAnalyzer.prototype;
            return _proto.getBandwidthEstimate = function getBandwidthEstimate(clockTick, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
                var newBitrateCeil, bandwidthEstimate, localConf = this._config, bufferGap = clockTick.bufferGap, currentTime = clockTick.currentTime, duration = clockTick.duration;
 // bitrate ceil for the chosen Representation
                                // check if should get in/out of starvation mode
                return isNaN(duration) || bufferGap + currentTime < duration - ABR_STARVATION_DURATION_DELTA ? !this._inStarvationMode && bufferGap <= localConf.starvationGap ? (log.a.info("ABR: enter starvation mode."), 
                this._inStarvationMode = !0) : this._inStarvationMode && bufferGap >= localConf.outOfStarvationGap && (log.a.info("ABR: exit starvation mode."), 
                this._inStarvationMode = !1) : this._inStarvationMode && (log.a.info("ABR: exit starvation mode."), 
                this._inStarvationMode = !1), // If in starvation mode, check if a quick new estimate can be done
                // from the last requests.
                // If so, cancel previous estimations and replace it by the new one
                this._inStarvationMode && null != (bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, clockTick, currentRepresentation, lastEstimatedBitrate)) && (log.a.info("ABR: starvation mode emergency estimate:", bandwidthEstimate), 
                bandwidthEstimator.reset(), newBitrateCeil = null == currentRepresentation ? bandwidthEstimate : Math.min(bandwidthEstimate, currentRepresentation.bitrate)), 
                // if newBitrateCeil is not yet defined, do the normal estimation
                null == newBitrateCeil && (newBitrateCeil = null != (bandwidthEstimate = bandwidthEstimator.getEstimate()) ? bandwidthEstimate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor) : null != lastEstimatedBitrate ? lastEstimatedBitrate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor) : this._initialBitrate), 
                1 < clockTick.speed && (newBitrateCeil /= clockTick.speed), {
                    bandwidthEstimate: bandwidthEstimate,
                    bitrateChosen: newBitrateCeil
                };
            }
            /**
   * For a given wanted bitrate, tells if should switch urgently.
   * @param {number} bitrate
   * @param {Object} clockTick
   * @returns {boolean}
   */ , _proto.isUrgent = function isUrgent(bitrate, currentRepresentation, currentRequests, clockTick) {
                return null == currentRepresentation || bitrate !== currentRepresentation.bitrate && (bitrate > currentRepresentation.bitrate ? !this._inStarvationMode : shouldDirectlySwitchToLowBitrate(clockTick, currentRequests, this._config.starvationGap));
            }, NetworkAnalyzer;
        }(), object_values = __webpack_require__(74), pending_requests_store_PendingRequestsStore = 
        /* */
        function() {
            function PendingRequestsStore() {
                this._currentRequests = {};
            }
            /**
   * Add information about a new pending request.
   * @param {string} id
   * @param {Object} payload
   */            var _proto = PendingRequestsStore.prototype;
            return _proto.add = function add(payload) {
                var id = payload.id, time = payload.time, duration = payload.duration, requestTimestamp = payload.requestTimestamp;
                this._currentRequests[id] ? log.a.warn("ABR: request already added.") : this._currentRequests[id] = {
                    time: time,
                    duration: duration,
                    requestTimestamp: requestTimestamp,
                    progress: []
                };
            }
            /**
   * Notify of the progress of a currently pending request.
   * @param {Object} progress
   */ , _proto.addProgress = function addProgress(progress) {
                var request = this._currentRequests[progress.id];
                request ? request.progress.push(progress) : log.a.warn("ABR: progress for a request not added");
            }
            /**
   * Remove a request previously set as pending.
   * @param {string} id
   */ , _proto.remove = function remove(id) {
                this._currentRequests[id] || log.a.warn("ABR: can't remove unknown request"), delete this._currentRequests[id];
            }
            /**
   * Returns information about all pending requests, in segment's chronological
   * order.
   * @returns {Array.<Object>}
   */ , _proto.getRequests = function getRequests() {
                return Object(object_values.a)(this._currentRequests).filter(function(x) {
                    return null != x;
                }).sort();
            }, PendingRequestsStore;
        }(), representation_score_calculator_RepresentationScoreCalculator = 
        /* */
        function() {
            function RepresentationScoreCalculator() {
                this._currentRepresentationData = null, this._lastRepresentationWithGoodScore = null;
            }
            /**
   * Add new sample data.
   * @param {Representation} representation
   * @param {number} requestDuration - duration taken for doing the request for
   * the whole segment.
   * @param {number} segmentDuration - media duration of the whole segment, in
   * seconds.
   */            var _proto = RepresentationScoreCalculator.prototype;
            return _proto.addSample = function addSample(representation, requestDuration, segmentDuration) {
                var currentEWMA, ratio = segmentDuration / requestDuration, oldEwma = this._getEWMA(representation);
                null != oldEwma ? (currentEWMA = oldEwma).addSample(requestDuration, ratio) : ((currentEWMA = new EWMA(5)).addSample(requestDuration, ratio), 
                this._currentRepresentationData = {
                    representation: representation,
                    ewma: currentEWMA
                }), 1 < currentEWMA.getEstimate() && this._lastRepresentationWithGoodScore !== representation && (log.a.debug("ABR: New last stable representation", representation), 
                this._lastRepresentationWithGoodScore = representation);
            }
            /**
   * Get score estimate for the given Representation.
   * undefined if no estimate is available.
   * @param {Representation} representation
   * @returns {number|undefined}
   */ , _proto.getEstimate = function getEstimate(representation) {
                var ewma = this._getEWMA(representation);
                if (null != ewma) return ewma.getEstimate();
            }
            /**
   * Returns last Representation which had reached a score superior to 1.
   * This Representation is the last known one which could be maintained.
   * Useful to know if a current guess is higher than what you should
   * normally be able to play.
   * `null` if no Representation ever reach that score.
   * @returns {Representation|null}
   */ , _proto.getLastStableRepresentation = function getLastStableRepresentation() {
                return this._lastRepresentationWithGoodScore;
            }
            /**
   * Returns EWMA for the given Representation.
   * null if no EWMA is currently stored for it.
   * @param {Representation} representation
   * @returns {EWMA|null}
   */ , _proto._getEWMA = function _getEWMA(representation) {
                return null != this._currentRepresentationData && this._currentRepresentationData.representation.id === representation.id ? this._currentRepresentationData.ewma : null;
            }, RepresentationScoreCalculator;
        }();
        // EXTERNAL MODULE: ./src/utils/object_values.ts
                // CONCATENATED MODULE: ./src/core/abr/representation_estimator.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * _Can_ contain each of the following properties:
 *   - bitrate {Number} - max bitrate authorized (included).
 *   - width {Number} - max width authorized (included).
 * @returns {Array.<Representation>}
 */
        function getFilteredRepresentations(representations, filters) {
            var _representations = representations;
            return null != filters.bitrate && (_representations = filterByBitrate(_representations, filters.bitrate)), 
            null != filters.width && (_representations = filterByWidth(_representations, filters.width)), 
            _representations;
        }
        /**
 * Emit the estimated bitrate and best Representation according to the current
 * network and buffer situation.
 * @param {Object} args
 * @returns {Observable}
 */        function RepresentationEstimator(_ref) {
            var bandwidthEstimator = _ref.bandwidthEstimator, bufferEvents$ = _ref.bufferEvents$, clock$ = _ref.clock$, filters$ = _ref.filters$, initialBitrate = _ref.initialBitrate, lowLatencyMode = _ref.lowLatencyMode, manualBitrate$ = _ref.manualBitrate$, maxAutoBitrate$ = _ref.maxAutoBitrate$, representations = _ref.representations, scoreCalculator = new representation_score_calculator_RepresentationScoreCalculator(), networkAnalyzer = new network_analyzer_NetworkAnalyzer(initialBitrate || 0, lowLatencyMode), requestsStore = new pending_requests_store_PendingRequestsStore();
            /**
   * Callback to call when new metrics arrive.
   * @param {Object} value
   */
            function onMetric(value) {
                var duration = value.duration, size = value.size, content = value.content;
 // calculate bandwidth
                                bandwidthEstimator.addSample(duration, size);
                // calculate "maintainability score"
                var segment = content.segment;
                if (null != segment.duration) {
                    var requestDuration = duration / 1e3, segmentDuration = segment.duration / segment.timescale, representation = content.representation;
                    scoreCalculator.addSample(representation, requestDuration, segmentDuration);
                }
            }
            var metrics$ = bufferEvents$.pipe(Object(filter.a)(function(e) {
                return "metrics" === e.type;
            }), Object(tap.a)(function(_ref2) {
                return onMetric(_ref2.value);
            }), Object(ignoreElements.a)()), requests$ = bufferEvents$.pipe(Object(tap.a)(function(evt) {
                switch (evt.type) {
                  case "requestBegin":
                    requestsStore.add(evt.value);
                    break;

                  case "requestEnd":
                    requestsStore.remove(evt.value.id);
                    break;

                  case "progress":
                    requestsStore.addProgress(evt.value);
                }
            }), Object(ignoreElements.a)()), currentRepresentation$ = bufferEvents$.pipe(Object(filter.a)(function(e) {
                return "representationChange" === e.type;
            }), Object(map.a)(function(e) {
                return e.value.representation;
            }), Object(startWith.a)(null)), estimate$ = Object(defer.a)(function() {
                if (!representations.length) throw new Error("ABRManager: no representation choice given");
                return 1 === representations.length ? Object(of.a)({
                    bitrate: void 0,
                    representation: representations[0],
                    manual: !1,
                    urgent: !0,
                    knownStableBitrate: void 0
                }) : manualBitrate$.pipe(Object(switchMap.a)(function(manualBitrate) {
                    if (0 <= manualBitrate) 
                    // -- MANUAL mode --
                    return Object(of.a)({
                        representation: fromBitrateCeil(representations, manualBitrate) || representations[0],
                        bitrate: void 0,
                        knownStableBitrate: void 0,
                        manual: !0,
                        urgent: !0
                    });
 // -- AUTO mode --
                                        var lastEstimatedBitrate, forceBandwidthMode = !0, bufferBasedEstimation$ = BufferBasedChooser(bufferEvents$.pipe(Object(filter.a)(function(e) {
                        return "added-segment" === e.type;
                    }), withLatestFrom(clock$), Object(map.a)(function(_ref3) {
                        var evtValue = _ref3[0].value, _ref3$ = _ref3[1], speed = _ref3$.speed, currentTime = _ref3$.currentTime, timeRanges = evtValue.buffered, bufferGap = Object(ranges.d)(timeRanges, currentTime), representation = evtValue.content.representation, currentScore = scoreCalculator.getEstimate(representation);
                        return {
                            bufferGap: bufferGap,
                            currentBitrate: representation.bitrate,
                            currentScore: currentScore,
                            speed: speed
                        };
                    })), representations.map(function(r) {
                        return r.bitrate;
                    })).pipe(Object(startWith.a)(void 0));
                    return Object(combineLatest.a)([ clock$, maxAutoBitrate$, filters$, bufferBasedEstimation$ ]).pipe(withLatestFrom(currentRepresentation$), Object(map.a)(function(_ref4) {
                        var _ref4$ = _ref4[0], clock = _ref4$[0], maxAutoBitrate = _ref4$[1], filters = _ref4$[2], bufferBasedBitrate = _ref4$[3], currentRepresentation = _ref4[1], _representations = getFilteredRepresentations(representations, filters), requests = requestsStore.getRequests(), _networkAnalyzer$getB = networkAnalyzer.getBandwidthEstimate(clock, bandwidthEstimator, currentRepresentation, requests, lastEstimatedBitrate), bandwidthEstimate = _networkAnalyzer$getB.bandwidthEstimate, bitrateChosen = _networkAnalyzer$getB.bitrateChosen;
                        lastEstimatedBitrate = bandwidthEstimate;
                        var stableRepresentation = scoreCalculator.getLastStableRepresentation(), knownStableBitrate = null == stableRepresentation ? void 0 : stableRepresentation.bitrate / (0 < clock.speed ? clock.speed : 1), bufferGap = clock.bufferGap;
                        !forceBandwidthMode && bufferGap <= 5 ? forceBandwidthMode = !0 : forceBandwidthMode && Number.isFinite(bufferGap) && 10 < bufferGap && (forceBandwidthMode = !1);
                        var chosenRepFromBandwidth = fromBitrateCeil(_representations, Math.min(bitrateChosen, maxAutoBitrate)) || _representations[0] || representations[0];
                        if (forceBandwidthMode) return log.a.debug("ABR: Choosing representation with bandwith estimation.", chosenRepFromBandwidth), 
                        {
                            bitrate: bandwidthEstimate,
                            representation: chosenRepFromBandwidth,
                            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
                            manual: !1,
                            knownStableBitrate: knownStableBitrate
                        };
                        if (null == bufferBasedBitrate || chosenRepFromBandwidth.bitrate >= bufferBasedBitrate) return log.a.debug("ABR: Choosing representation with bandwith estimation.", chosenRepFromBandwidth), 
                        {
                            bitrate: bandwidthEstimate,
                            representation: chosenRepFromBandwidth,
                            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
                            manual: !1,
                            knownStableBitrate: knownStableBitrate
                        };
                        var chosenRepresentation = fromBitrateCeil(_representations, Math.min(bufferBasedBitrate, maxAutoBitrate)) || _representations[0] || representations[0];
                        return bufferBasedBitrate <= maxAutoBitrate && log.a.debug("ABR: Choosing representation with buffer based bitrate ceiling.", chosenRepresentation), 
                        {
                            bitrate: bandwidthEstimate,
                            representation: chosenRepresentation,
                            urgent: networkAnalyzer.isUrgent(bufferBasedBitrate, currentRepresentation, requests, clock),
                            manual: !1,
                            knownStableBitrate: knownStableBitrate
                        };
                    }));
                }));
            });
            return Object(merge.a)(metrics$, requests$, estimate$);
        }
        // CONCATENATED MODULE: ./src/core/abr/abr_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Adaptive BitRate Manager.
 *
 * Select the right Representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */        var abr = 
        /* */
        function() {
            /**
   * @param {Object} options
   */
            function ABRManager(options) {
                this._manualBitrates = options.manualBitrates || {}, this._maxAutoBitrates = options.maxAutoBitrates || {}, 
                this._initialBitrates = options.initialBitrates || {}, this._throttlers = options.throttlers || {}, 
                this._bandwidthEstimators = {}, this._lowLatencyMode = options.lowLatencyMode;
            }
            /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Array.<Representation>|undefined} representations
   * @param {Observable<Object>} clock$
   * @param {Observable<Object>} bufferEvents$
   * @returns {Observable}
   */            var _proto = ABRManager.prototype;
            return _proto.get$ = function get$(type, representations, clock$, bufferEvents$) {
                void 0 === representations && (representations = []);
                var bandwidthEstimator = this._getBandwidthEstimator(type), manualBitrate$ = this._manualBitrates[type] || Object(of.a)(-1), maxAutoBitrate$ = this._maxAutoBitrates[type] || Object(of.a)(Infinity), initialBitrate = this._initialBitrates[type] || 0;
                return RepresentationEstimator({
                    bandwidthEstimator: bandwidthEstimator,
                    bufferEvents$: bufferEvents$,
                    clock$: clock$,
                    filters$: createFilters(this._throttlers.limitWidth[type], this._throttlers.throttleBitrate[type], this._throttlers.throttle[type]),
                    initialBitrate: initialBitrate,
                    manualBitrate$: manualBitrate$,
                    maxAutoBitrate$: maxAutoBitrate$,
                    representations: representations,
                    lowLatencyMode: this._lowLatencyMode
                });
            }
            /**
   * @param {string} bufferType
   * @returns {Object}
   */ , _proto._getBandwidthEstimator = function _getBandwidthEstimator(bufferType) {
                var originalBandwidthEstimator = this._bandwidthEstimators[bufferType];
                if (null != originalBandwidthEstimator) return originalBandwidthEstimator;
                log.a.debug("ABR: Creating new BandwidthEstimator for ", bufferType);
                var bandwidthEstimator = new bandwidth_estimator_BandwidthEstimator();
                return this._bandwidthEstimators[bufferType] = bandwidthEstimator;
            }, ABRManager;
        }(), rx_try_catch = __webpack_require__(32), is_offline = __webpack_require__(152), request_error = __webpack_require__(127), get_fuzzed_delay = __webpack_require__(100);
        // CONCATENATED MODULE: ./src/core/abr/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/core/pipelines/utils/backoff.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */
        function shouldRetry(error) {
            return error instanceof request_error.a ? error.type === error_codes.c.ERROR_HTTP_CODE ? 500 <= error.status || 404 === error.status || 415 === error.status || // some CDN seems to use that code when
            // requesting low-latency segments too much
            // in advance
            412 === error.status : error.type === error_codes.c.TIMEOUT || error.type === error_codes.c.ERROR_EVENT : isKnownError(error) && "INTEGRITY_ERROR" === error.code;
        }
        /**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */        function isOfflineRequestError(error) {
            return error.type === error_codes.c.ERROR_EVENT && Object(is_offline.a)();
        }
        /**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable} obs$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */        function backoff(obs$, options) {
            var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, retryCount = 0, ERROR_TYPES_REGULAR = 1, ERROR_TYPES_OFFLINE = 2, lastError = 0;
            return obs$.pipe(Object(map.a)(function(res) {
                return {
                    type: "response",
                    value: res
                };
            }), Object(catchError.a)(function(error, source) {
                if (!shouldRetry(error)) throw error;
                var currentError = error instanceof request_error.a && isOfflineRequestError(error) ? ERROR_TYPES_OFFLINE : ERROR_TYPES_REGULAR;
                if (currentError !== lastError && (retryCount = 0, lastError = currentError), ++retryCount > (currentError === ERROR_TYPES_OFFLINE ? maxRetryOffline : maxRetryRegular)) throw error;
                var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay), fuzzedDelay = Object(get_fuzzed_delay.a)(delay);
                return Object(timer.a)(fuzzedDelay).pipe(Object(mergeMap.a)(function() {
                    return source;
                }), Object(startWith.a)({
                    type: "retry",
                    value: error
                }));
            }));
        }
        // CONCATENATED MODULE: ./src/core/pipelines/utils/error_selector.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */        function errorSelector(error) {
            return error instanceof request_error.a ? new network_error.a("PIPELINE_LOAD_ERROR", error) : formatError(error, {
                defaultCode: "PIPELINE_LOAD_ERROR",
                defaultReason: "Unknown error when fetching the Manifest"
            });
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/create_manifest_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns function allowing to download the Manifest through a resolver ->
 * loader pipeline.
 *
 * The function returned takes the loader's data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - The fetched data (type "response").
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * @param {Object} manifestPipeline
 * @param {Object} options
 * @returns {Function}
 */        function createManifestLoader(manifestPipeline, options) {
            var maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline, loader = manifestPipeline.loader, resolver = null != manifestPipeline.resolver ? manifestPipeline.resolver : 
            /* tslint:disable deprecation */
            of.a, backoffOptions = {
                baseDelay: options.baseDelay,
                maxDelay: options.maxDelay,
                maxRetryRegular: maxRetry,
                maxRetryOffline: maxRetryOffline
            };
            /**
   * Call the transport's resolver - if it exists - with the given data.
   *
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */
            function callResolver(resolverArgument) {
                return Object(rx_try_catch.a)(resolver, resolverArgument).pipe().pipe(Object(catchError.a)(function(error) {
                    throw errorSelector(error);
                }));
            }
            /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */            function loadData(loaderArgument) {
                return backoff(Object(rx_try_catch.a)(loader, loaderArgument), backoffOptions).pipe(Object(catchError.a)(function(error) {
                    throw errorSelector(error);
                }), Object(map.a)(function(evt) {
                    return "response" === evt.type ? evt.value : {
                        type: "warning",
                        value: errorSelector(evt.value)
                    };
                }));
            }
            /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */            return function startPipeline(loaderArgs) {
                return callResolver(loaderArgs).pipe(Object(mergeMap.a)(function(resolverResponse) {
                    return loadData(resolverResponse).pipe(Object(mergeMap.a)(function(arg) {
                        if ("warning" === arg.type) return Object(of.a)(arg);
                        var value = arg.value;
                        return Object(of.a)({
                            type: "response",
                            value: {
                                responseData: value.responseData,
                                url: value.url,
                                sendingTime: value.sendingTime,
                                receivedTime: value.receivedTime
                            }
                        });
                    }));
                }));
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/parse_manifest_pipeline_options.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var DEFAULT_MAX_MANIFEST_REQUEST_RETRY = config.a.DEFAULT_MAX_MANIFEST_REQUEST_RETRY, DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR, INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE;
        /**
 * Parse config to replace missing manifest pipeline options.
 * @param {Object} manifestPipelineOptions
 * @returns {Object}
 */        function parseManifestPipelineOptions(_ref) {
            var manifestRetry = _ref.manifestRetry, offlineRetry = _ref.offlineRetry, lowLatencyMode = _ref.lowLatencyMode;
            return {
                baseDelay: lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR,
                maxDelay: lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR,
                maxRetry: null != manifestRetry ? manifestRetry : DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
                maxRetryOffline: null != offlineRetry ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
                lowLatencyMode: lowLatencyMode
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/create_manifest_pipeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(pipelines, options, warning$);
 * manifestPipeline.fetch(manifestURL)
 *  .mergeMap((evt) => {
 *    if (evt.type !== "response") { // Might also receive warning events
 *      return EMPTY;
 *    }
 *    return manifestPipeline.parse(evt.value);
 *  }).subscribe(({ manifest }) => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} pipelines
 * @param {Subject} pipelineOptions
 * @param {Subject} warning$
 * @returns {Function}
 */        
        // CONCATENATED MODULE: ./src/core/pipelines/manifest/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var pipelines_manifest = function createManifestPipeline(pipelines, pipelineOptions, warning$) {
            var parsedOptions = parseManifestPipelineOptions(pipelineOptions), loader = createManifestLoader(pipelines.manifest, parsedOptions), parser = pipelines.manifest.parser;
            /**
   * Allow the parser to schedule a new request.
   * @param {Object} transportPipeline
   * @param {Object} options
   * @returns {Function}
   */
            function scheduleRequest(request) {
                var backoffOptions = {
                    baseDelay: parsedOptions.baseDelay,
                    maxDelay: parsedOptions.maxDelay,
                    maxRetryRegular: parsedOptions.maxRetry,
                    maxRetryOffline: parsedOptions.maxRetryOffline
                };
                return backoff(Object(rx_try_catch.a)(request, void 0), backoffOptions).pipe(Object(mergeMap.a)(function(evt) {
                    return "retry" === evt.type ? (warning$.next(errorSelector(evt.value)), empty.a) : Object(of.a)(evt.value);
                }), Object(catchError.a)(function(error) {
                    throw errorSelector(error);
                }));
            }
            return {
                /**
     * Fetch the manifest corresponding to the URL given.
     * @param {string} url - URL of the manifest
     * @returns {Observable}
     */
                fetch: function fetch(url) {
                    return loader({
                        url: url
                    }).pipe(Object(tap.a)(function(arg) {
                        "warning" === arg.type && warning$.next(arg.value);
                    }), Object(filter.a)(function(arg) {
                        return "response" === arg.type;
                    }));
                },
                /**
     * Fetch the manifest corresponding to the URL given.
     * @param {Object} value - The Manifest document to parse.
     * @param {string} [url] - URL of the manifest
     * @param {number} [externalClockOffset]
     * @returns {Observable}
     */
                parse: function parse(value, fetchedURL, externalClockOffset) {
                    var sendingTime = value.sendingTime;
                    return parser({
                        response: value,
                        url: fetchedURL,
                        externalClockOffset: externalClockOffset,
                        scheduleRequest: scheduleRequest
                    }).pipe(Object(catchError.a)(function(error) {
                        throw formatError(error, {
                            defaultCode: "PIPELINE_PARSE_ERROR",
                            defaultReason: "Unknown error when parsing the Manifest"
                        });
                    }), Object(map.a)(function(_ref) {
                        for (var manifest = _ref.manifest, warnings = manifest.parsingErrors, i = 0; i < warnings.length; i++) warning$.next(warnings[i]);
 // TODO not through warning$
                                                return {
                            manifest: manifest,
                            sendingTime: sendingTime
                        };
                    }));
                }
            };
        }, array_includes = __webpack_require__(12), initialization_segment_cache = 
        /* */
        function() {
            function InitializationSegmentCache() {
                this._cache = new WeakMap();
            }
            /**
   * @param {Object} obj
   * @param {*} response
   */            var _proto = InitializationSegmentCache.prototype;
            return _proto.add = function add(_ref, response) {
                var representation = _ref.representation;
                _ref.segment.isInit && this._cache.set(representation, response);
            }
            /**
   * @param {Object} obj
   * @returns {*} response
   */ , _proto.get = function get(_ref2) {
                var representation = _ref2.representation;
                if (_ref2.segment.isInit) {
                    var value = this._cache.get(representation);
                    if (null != value) return value;
                }
                return null;
            }, InitializationSegmentCache;
        }(), get_segment_pipeline_options_DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR, DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE = config.a.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE, get_segment_pipeline_options_INITIAL_BACKOFF_DELAY_BASE = config.a.INITIAL_BACKOFF_DELAY_BASE, get_segment_pipeline_options_MAX_BACKOFF_DELAY_BASE = config.a.MAX_BACKOFF_DELAY_BASE;
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                /**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */
        function parseSegmentPipelineOptions(bufferType, _ref) {
            var segmentRetry = _ref.segmentRetry, offlineRetry = _ref.offlineRetry, lowLatencyMode = _ref.lowLatencyMode;
            return {
                cache: Object(array_includes.a)([ "audio", "video" ], bufferType) ? new initialization_segment_cache() : void 0,
                maxRetry: "image" === bufferType ? 0 : null != segmentRetry ? segmentRetry : get_segment_pipeline_options_DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
                maxRetryOffline: null != offlineRetry ? offlineRetry : DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE,
                initialBackoffDelay: lowLatencyMode ? get_segment_pipeline_options_INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_pipeline_options_INITIAL_BACKOFF_DELAY_BASE.REGULAR,
                maximumBackoffDelay: lowLatencyMode ? get_segment_pipeline_options_MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_pipeline_options_MAX_BACKOFF_DELAY_BASE.REGULAR
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritized_segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */        function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
            return {
                /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
                createRequest: function createRequest(content, priority) {
                    return void 0 === priority && (priority = 0), prioritizer.create(fetcher(content), priority);
                },
                /**
     * Update the priority of a pending request, created through createRequest.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
                updatePriority: function updatePriority(observable, priority) {
                    prioritizer.updatePriority(observable, priority);
                }
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/prioritizer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */        var prioritizer_ObservablePrioritizer = 
        /* */
        function() {
            function ObservablePrioritizer() {
                this._pendingPriority = null, this._numberOfPendingObservables = 0, this._queue = [];
            }
            /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */            var _proto = ObservablePrioritizer.prototype;
            return _proto.create = function create(obs, priority) {
                var _this = this, pObs$ = Object(defer.a)(function() {
                    if (null == _this._pendingPriority || _this._pendingPriority >= priority) 
                    // Update the priority and start immediately the Observable
                    return _this._pendingPriority = priority, _this._startObservable(obs);
                    var trigger = new Subject.a();
                    return _this._queue.push({
                        observable: pObs$,
                        priority: priority,
                        trigger: trigger
                    }), trigger.pipe(Object(mergeMap.a)(function() {
                        return _this._startObservable(obs);
                    }));
                });
                return pObs$;
            }
            /**
   * Update the priority of an Observable created through the create method.
   *
   * Note that this will only have an effect on Observable which are not yet
   * started.
   * This means it will only have an effect on:
   *   - unsubscribed Observables
   *   - Observables waiting for Observables with an higher priority to
   *     finish
   *
   * @param {Observable} obs
   * @param {number} priority
   */ , _proto.updatePriority = function updatePriority(obs, priority) {
                var index = arrayFindIndex(this._queue, function(elt) {
                    return elt.observable === obs;
                });
                if (!(index < 0)) {
                    var queueElement = this._queue[index];
                    queueElement.priority = priority, (null == this._pendingPriority || this._pendingPriority >= priority) && (this._queue.splice(index, 1), 
                    queueElement.trigger.next(), queueElement.trigger.complete());
                }
            }, _proto._startObservable = function _startObservable(obs) {
                var _this2 = this;
                return this._numberOfPendingObservables++, obs.pipe(finalize(function onObservableFinish() {
                    if (_this2._numberOfPendingObservables--, !(0 < _this2._numberOfPendingObservables) && (_this2._pendingPriority = null, 
                    0 !== _this2._queue.length)) {
                        _this2._pendingPriority = _this2._queue.reduce(function(acc, elt) {
                            return null == acc || acc > elt.priority ? elt.priority : acc;
                        }, null);
                        for (var i = 0; i < _this2._queue.length; i++) {
                            var elt = _this2._queue[i];
                            elt.priority === _this2._pendingPriority && (_this2._queue.splice(i, 1), i--, elt.trigger.next(), 
                            elt.trigger.complete());
                        }
                    }
                }));
            }, ObservablePrioritizer;
        }(), id_generator = __webpack_require__(50), assertion_error = __webpack_require__(206);
        // EXTERNAL MODULE: ./src/utils/id_generator.ts
                // CONCATENATED MODULE: ./src/utils/assert_unreachable.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function assertUnreachable() {
            throw new assertion_error.a("Unreachable path taken");
        }
        // EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
                var cast_to_observable = __webpack_require__(17);
        // CONCATENATED MODULE: ./src/core/pipelines/segment/create_segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns function allowing to download the wanted data through the loader.
 *
 * (The data can be for example: audio and video segments, text,
 * images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This event emits the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This event contains information about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - Lastly, with the fetched data (type "response").
 *
 *
 * Each of these but "warning" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * Type parameters:
 *   - T: type of the data emitted
 *
 * @param {Object} segmentPipeline
 * @param {Object} options
 * @returns {Function}
 */        function createSegmentLoader(loader, options) {
            var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline, backoffOptions = {
                baseDelay: options.initialBackoffDelay,
                maxDelay: options.maximumBackoffDelay,
                maxRetryRegular: maxRetry,
                maxRetryOffline: maxRetryOffline
            };
 // Backoff options given to the backoff retry done with the loader function.
                        /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */
            function loadData(loaderArgument) {
                /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
                function startLoaderWithBackoff() {
                    var request$ = backoff(Object(rx_try_catch.a)(loader, loaderArgument), backoffOptions).pipe(Object(catchError.a)(function(error) {
                        throw errorSelector(error);
                    }), Object(map.a)(function(evt) {
                        if ("retry" === evt.type) return {
                            type: "warning",
                            value: errorSelector(evt.value)
                        };
                        var response = evt.value;
                        return "data-loaded" === response.type && null != cache && cache.add(loaderArgument, response.value), 
                        evt.value;
                    }));
                    return Object(concat.a)(Object(of.a)({
                        type: "request",
                        value: loaderArgument
                    }), request$);
                }
                var dataFromCache = null != cache ? cache.get(loaderArgument) : null;
                return null != dataFromCache ? Object(cast_to_observable.a)(dataFromCache).pipe(Object(map.a)(function(response) {
                    return {
                        type: "cache",
                        value: response
                    };
                }), Object(catchError.a)(startLoaderWithBackoff)) : startLoaderWithBackoff();
            }
            /**
   * Load the corresponding data.
   * @param {Object} pipelineInputData
   * @returns {Observable}
   */            return function startPipeline(pipelineInputData) {
                return loadData(pipelineInputData).pipe(Object(mergeMap.a)(function(arg) {
                    var metrics$ = "data-chunk-complete" === arg.type || "data-loaded" === arg.type ? Object(of.a)({
                        type: "metrics",
                        value: {
                            size: arg.value.size,
                            duration: arg.value.duration
                        }
                    }) : empty.a;
 // "cache": data taken from cache by the pipeline
                    // "data-created": the data is available but no request has been done
                    // "data-loaded": data received through a request
                                        switch (arg.type) {
                      case "warning":
                        return Object(of.a)(arg);

                      case "cache":
                      case "data-created":
                      case "data-loaded":
                        var chunck$ = Object(of.a)({
                            type: "data",
                            value: object_assign_default()({}, pipelineInputData, {
                                responseData: arg.value.responseData
                            })
                        });
                        return Object(concat.a)(chunck$, metrics$);

                      case "request":
                      case "progress":
                        return Object(of.a)(arg);

                      case "data-chunk":
                        return Object(of.a)({
                            type: "chunk",
                            value: object_assign_default()({}, pipelineInputData, {
                                responseData: arg.value.responseData
                            })
                        });

                      case "data-chunk-complete":
                        var _complete$ = Object(of.a)({
                            type: "chunk-complete",
                            value: null
                        });
                        return Object(concat.a)(_complete$, metrics$);
                    }
                    return assertUnreachable();
                }));
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/segment_fetcher.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateRequestID = Object(id_generator.a)();
        /**
 * Create a function which will fetch segments.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} requests$
 * @param {Object} options
 * @returns {Function}
 */        function createSegmentFetcher(bufferType, transport, requests$, options) {
            var segmentLoader = createSegmentLoader(transport[bufferType].loader, options), segmentParser = transport[bufferType].parser;
            // deal with it
            /**
   * Process a pipeline observable to adapt it to the the rest of the code:
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {string} pipelineType
   * @param {Observable} pipeline$
   * @returns {Observable}
   */
            return function fetchSegment(content) {
                var id = generateRequestID(), requestBeginSent = !1;
                return segmentLoader(content).pipe(Object(tap.a)(function(arg) {
                    switch (arg.type) {
                      case "metrics":
                        var value = arg.value, size = value.size, duration = value.duration;
                        // unwrapping for TS
                        // format it for ABR Handling
                        null != size && null != duration && requests$.next({
                            type: "metrics",
                            value: {
                                size: size,
                                duration: duration,
                                content: content
                            }
                        });
                        break;

                      case "request":
                        var _value = arg.value, segment = _value && _value.segment;
 // format it for ABR Handling
                                                if (null == segment || null == segment.duration) return;
                        requestBeginSent = !0;
                        var _duration = segment.duration / segment.timescale, time = segment.time / segment.timescale;
                        requests$.next({
                            type: "requestBegin",
                            value: {
                                duration: _duration,
                                time: time,
                                requestTimestamp: performance.now(),
                                id: id
                            }
                        });
                        break;

                      case "progress":
                        var _value2 = arg.value;
                        null != _value2.totalSize && _value2.size < _value2.totalSize && requests$.next({
                            type: "progress",
                            value: {
                                duration: _value2.duration,
                                size: _value2.size,
                                totalSize: _value2.totalSize,
                                timestamp: performance.now(),
                                id: id
                            }
                        });
                    }
                }), finalize(function() {
                    requestBeginSent && requests$.next({
                        type: "requestEnd",
                        value: {
                            id: id
                        }
                    });
                }), Object(filter.a)(function(e) {
                    return "warning" === e.type || "chunk" === e.type || "chunk-complete" === e.type || "data" === e.type;
                }), Object(mergeMap.a)(function(evt) {
                    if ("warning" === evt.type) return Object(of.a)(evt);
                    if ("chunk-complete" === evt.type) return Object(of.a)({
                        type: "chunk-complete"
                    });
                    var isChunked = "chunk" === evt.type, data = {
                        type: "chunk",
                        /**
         * Parse the loaded data.
         * @param {Object} [init]
         * @returns {Observable}
         */
                        parse: function parse(init) {
                            var response = {
                                data: evt.value.responseData,
                                isChunked: isChunked
                            };
                            return segmentParser({
                                response: response,
                                init: init,
                                content: content
                            }).pipe(Object(catchError.a)(function(error) {
                                throw formatError(error, {
                                    defaultCode: "PIPELINE_PARSE_ERROR",
                                    defaultReason: "Unknown parsing error"
                                });
                            }));
                        }
                    };
                    return isChunked ? Object(of.a)(data) : Object(concat.a)(Object(of.a)(data), Object(of.a)({
                        type: "chunk-complete"
                    }));
                }), Object(share.a)());
            };
        }
        // CONCATENATED MODULE: ./src/core/pipelines/segment/segment_pipelines_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Interact with the networking pipelines to download segments with the right
 * priority.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * // 1 - create the manager
 * const segmentPipelinesManager = new SegmentPipelinesManager(transport);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * pipeline.createRequest(myContent, 1)
 *
 *   // 4 - parse it
 *   .pipe(
 *     filter(evt => evt.type === "response"),
 *     mergeMap(response => response.parse());
 *   )
 *
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */        var pipelines_segment = 
        /* */
        function() {
            /**
   * @param {Object} transport
   */
            function SegmentPipelinesManager(transport, options) {
                this._transport = transport, this._prioritizer = new prioritizer_ObservablePrioritizer(), 
                this._pipelineOptions = options;
            }
            /**
   * Create a segment pipeline, allowing to easily perform segment requests.
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Object}
   */            return SegmentPipelinesManager.prototype.createPipeline = function createPipeline(bufferType, requests$) {
                var options = parseSegmentPipelineOptions(bufferType, this._pipelineOptions), segmentFetcher = createSegmentFetcher(bufferType, this._transport, requests$, options);
                return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
            }, SegmentPipelinesManager;
        }(), create_eme_manager = __webpack_require__(112), clear_element_src = __webpack_require__(84), browser_compatibility_types = __webpack_require__(22), onSourceOpen$ = compat.a.onSourceOpen$;
        // CONCATENATED MODULE: ./src/core/pipelines/segment/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        /**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */
        function setDurationToMediaSource(mediaSource, duration) {
            var newDuration = Infinity === duration ? Number.MAX_VALUE : duration;
            mediaSource.duration !== newDuration && (log.a.info("Init: Setting duration", newDuration), 
            mediaSource.duration = newDuration);
        }
        /**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null|undefined} mediaSource
 * @param {string|null|undefined} mediaSourceURL
 */        function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
            if (mediaSource && "closed" !== mediaSource.readyState) {
                for (var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers, i = sourceBuffers.length - 1; 0 <= i; i--) {
                    var sourceBuffer = sourceBuffers[i];
                    try {
                        "open" === readyState && (log.a.info("Init: Removing SourceBuffer from mediaSource", sourceBuffer), 
                        sourceBuffer.abort()), mediaSource.removeSourceBuffer(sourceBuffer);
                    } catch (e) {
                        log.a.warn("Init: Error while disposing SourceBuffer", e);
                    }
                }
                sourceBuffers.length && log.a.warn("Init: Not all SourceBuffers could have been removed.");
            }
            if (Object(clear_element_src.a)(mediaElement), mediaSourceURL) try {
                log.a.debug("Init: Revoking previous URL"), URL.revokeObjectURL(mediaSourceURL);
            } catch (e) {
                log.a.warn("Init: Error while revoking the media source URL", e);
            }
        }
        /**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource sourceBuffers
 * and customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function createMediaSource(mediaElement) {
            return new Observable.a(function(observer) {
                if (!browser_compatibility_types.c) throw new media_error.a("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
 // make sure the media has been correctly reset
                                resetMediaSource(mediaElement, null, mediaElement.src || null), 
                log.a.info("Init: Creating MediaSource");
                var mediaSource = new browser_compatibility_types.c(), objectURL = URL.createObjectURL(mediaSource);
                return log.a.info("Init: Attaching MediaSource URL to the media element", objectURL), 
                mediaElement.src = objectURL, observer.next(mediaSource), function() {
                    resetMediaSource(mediaElement, mediaSource, objectURL);
                };
            });
        }
        /**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */        function openMediaSource(mediaElement) {
            return createMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(mediaSource) {
                return onSourceOpen$(mediaSource).pipe(Object(take.a)(1), Object(mapTo.a)(mediaSource));
            }));
        }
        // EXTERNAL MODULE: ./src/core/init/events_generators.ts
                var events_generators = __webpack_require__(26), DEFAULT_LIVE_GAP = config.a.DEFAULT_LIVE_GAP;
        // CONCATENATED MODULE: ./src/core/init/get_initial_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest information
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */
        function getInitialTime(manifest, lowLatencyMode, startAt) {
            if (log.a.debug("Init: calculating initial time"), startAt) {
                var min = manifest.getMinimumPosition(), max = manifest.getMaximumPosition();
                if (null != startAt.position) return log.a.debug("Init: using startAt.minimumPosition"), 
                Math.max(Math.min(startAt.position, max), min);
                if (null != startAt.wallClockTime) {
                    log.a.debug("Init: using startAt.wallClockTime");
                    var position = manifest.isLive ? startAt.wallClockTime - (manifest.availabilityStartTime || 0) : startAt.wallClockTime;
                    return Math.max(Math.min(position, max), min);
                }
                if (null != startAt.fromFirstPosition) {
                    log.a.debug("Init: using startAt.fromFirstPosition");
                    var fromFirstPosition = startAt.fromFirstPosition;
                    return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);
                }
                if (null != startAt.fromLastPosition) {
                    log.a.debug("Init: using startAt.fromLastPosition");
                    var fromLastPosition = startAt.fromLastPosition;
                    return 0 <= fromLastPosition ? max : Math.max(min, max + fromLastPosition);
                }
                if (null != startAt.percentage) {
                    log.a.debug("Init: using startAt.percentage");
                    var percentage = startAt.percentage;
                    return 100 < percentage ? max : percentage < 0 ? min : min + (max - min) * (+percentage / 100);
                }
            }
            var minimumPosition = manifest.getMinimumPosition();
            if (manifest.isLive) {
                var liveTime, sgp = manifest.suggestedPresentationDelay, clockOffset = manifest.getClockOffset(), maximumPosition = manifest.getMaximumPosition();
                if (null == clockOffset) log.a.info("Init: no clock offset found for a live content, starting close to maximum available position"), 
                liveTime = maximumPosition; else {
                    log.a.info("Init: clock offset found for a live content, checking if we can start close to it");
                    var ast = manifest.availabilityStartTime || 0, clockRelativeLiveTime = (performance.now() + clockOffset) / 1e3 - ast;
                    liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
                }
                if (log.a.debug("Init: " + liveTime + " defined as the live time, applying a live gap of " + sgp), 
                null != sgp) return Math.max(liveTime - sgp, minimumPosition);
                var defaultStartingPos = liveTime - (lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT);
                return Math.max(defaultStartingPos, minimumPosition);
            }
            return log.a.info("Init: starting at the minimum available position:", minimumPosition), 
            minimumPosition;
        }
        // EXTERNAL MODULE: ./src/core/init/is_eme_ready.ts
                var is_eme_ready = __webpack_require__(117), InnerSubscriber = __webpack_require__(49), from = __webpack_require__(57);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function exhaustMap(project, resultSelector) {
            return resultSelector ? function(source) {
                return source.pipe(exhaustMap(function(a, i) {
                    return Object(from.a)(project(a, i)).pipe(Object(map.a)(function(b, ii) {
                        return resultSelector(a, b, i, ii);
                    }));
                }));
            } : function(source) {
                return source.lift(new ExhaustMapOperator(project));
            };
        }
        var ExhaustMapOperator = /* */ function() {
            function ExhaustMapOperator(project) {
                this.project = project;
            }
            return ExhaustMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
            }, ExhaustMapOperator;
        }(), exhaustMap_ExhaustMapSubscriber = /* */ function(_super) {
            function ExhaustMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.hasSubscription = !1, _this.hasCompleted = !1, 
                _this.index = 0, _this;
            }
            return tslib_es6.a(ExhaustMapSubscriber, _super), ExhaustMapSubscriber.prototype._next = function(value) {
                this.hasSubscription || this.tryNext(value);
            }, ExhaustMapSubscriber.prototype.tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.hasSubscription = !0, this._innerSub(result, value, index);
            }, ExhaustMapSubscriber.prototype._innerSub = function(result, value, index) {
                var innerSubscriber = new InnerSubscriber.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(subscribeToResult.a)(this, result, value, index, innerSubscriber);
            }, ExhaustMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
            }, ExhaustMapSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }, ExhaustMapSubscriber.prototype.notifyError = function(err) {
                this.destination.error(err);
            }, ExhaustMapSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.remove(innerSub), this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
            }, ExhaustMapSubscriber;
        }(OuterSubscriber.a), sorted_list_SortedList = 
        /* */
        function() {
            /**
   * @param {Function} sortingFunction
   */
            function SortedList(sortingFunction) {
                this._array = [], this._sortingFn = sortingFunction;
            }
            /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */            var _proto = SortedList.prototype;
            return _proto.add = function add() {
                for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) elements[_key] = arguments[_key];
                elements.sort(this._sortingFn);
                for (var j = 0, i = 0; i < elements.length; i++) {
                    for (var element = elements[i], inserted = !1; !inserted && j < this._array.length; ) this._sortingFn(element, this._array[j]) < 0 ? (this._array.splice(j, 0, element), 
                    inserted = !0) : j++;
                    inserted || this._array.push(element);
                }
            }
            /**
   * Returns the current length of the list.
   * @returns {number}
   */ , _proto.length = function length() {
                return this._array.length;
            }
            /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */ , _proto.get = function get(index) {
                if (index < 0 || index >= this._array.length) throw new Error("Invalid index.");
                return this._array[index];
            }
            /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */ , _proto.findFirst = function findFirst(fn) {
                return Object(array_find.a)(this._array, fn);
            }
            /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */ , _proto.has = function has(element) {
                return Object(array_includes.a)(this._array, element);
            }
            /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */ , _proto.removeElement = function removeElement(element) {
                var indexOf = this._array.indexOf(element);
                if (0 <= indexOf) return this._array.splice(indexOf, 1), indexOf;
            }
            /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */ , _proto.head = function head() {
                return this._array[0];
            }
            /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */ , _proto.last = function last() {
                return this._array[this._array.length - 1];
            }
            /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */ , _proto.shift = function shift() {
                return this._array.shift();
            }
            /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */ , _proto.pop = function pop() {
                return this._array.pop();
            }, SortedList;
        }(), WeakMapMemory = 
        /* */
        function() {
            /**
   * @param {Function}
   */
            function WeakMapMemory(fn) {
                this._weakMap = new WeakMap(), this._fn = fn;
            }
            /**
   * @param {Object} obj
   * @returns {*}
   */            var _proto = WeakMapMemory.prototype;
            return _proto.get = function get(obj) {
                var fromMemory = this._weakMap.get(obj);
                if (void 0 !== fromMemory) return fromMemory;
                var newElement = this._fn(obj);
                return this._weakMap.set(obj, newElement), newElement;
            }
            /**
   * @param {Object} obj
   */ , _proto.destroy = function destroy(obj) {
                this._weakMap.delete(obj);
            }, WeakMapMemory;
        }(), concatAll = __webpack_require__(158);
        // CONCATENATED MODULE: ./src/core/source_buffers/garbage_collector.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
        function BufferGarbageCollector(_ref) {
            var queuedSourceBuffer = _ref.queuedSourceBuffer, clock$ = _ref.clock$, maxBufferBehind$ = _ref.maxBufferBehind$, maxBufferAhead$ = _ref.maxBufferAhead$;
            return Object(combineLatest.a)([ clock$, maxBufferBehind$, maxBufferAhead$ ]).pipe(Object(mergeMap.a)(function(_ref2) {
                var currentTime = _ref2[0], maxBufferBehind = _ref2[1], maxBufferAhead = _ref2[2];
                return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
            }));
        }
        /**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */        function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
            if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) return empty.a;
            var cleanedupRanges = [], _getInnerAndOuterTime = Object(ranges.c)(qSourceBuffer.getBufferedRanges(), position), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges;
            return function collectBufferBehind() {
                if (isFinite(maxBufferBehind)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position - maxBufferBehind >= outerRange.end ? cleanedupRanges.push(outerRange) : position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end && cleanedupRanges.push({
                            start: outerRange.start,
                            end: position - maxBufferBehind
                        });
                    }
                    innerRange && position - maxBufferBehind > innerRange.start && cleanedupRanges.push({
                        start: innerRange.start,
                        end: position - maxBufferBehind
                    });
                }
            }(), function collectBufferAhead() {
                if (isFinite(maxBufferAhead)) {
                    // begin from the oldest
                    for (var i = 0; i < outerRanges.length; i++) {
                        var outerRange = outerRanges[i];
                        position + maxBufferAhead <= outerRange.start ? cleanedupRanges.push(outerRange) : position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start && cleanedupRanges.push({
                            start: position + maxBufferAhead,
                            end: outerRange.end
                        });
                    }
                    innerRange && position + maxBufferAhead < innerRange.end && cleanedupRanges.push({
                        start: position + maxBufferAhead,
                        end: innerRange.end
                    });
                }
            }(), Object(from.a)(cleanedupRanges.map(function(range) {
                return log.a.debug("GC: cleaning range from SourceBuffer", range), qSourceBuffer.removeBuffer(range.start, range.end);
            })).pipe(Object(concatAll.a)(), Object(ignoreElements.a)());
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                var observable_interval = __webpack_require__(214), fromEvent = __webpack_require__(204), change_source_buffer_type = __webpack_require__(154), are_same_content = __webpack_require__(153);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
                // CONCATENATED MODULE: ./src/utils/take_first_set.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        function takeFirstSet() {
            for (var i = 0, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            for (var len = args.length; i < len; ) {
                var arg = args[i];
                if (null != arg) return arg;
                i++;
            }
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/segment_inventory.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = config.a.MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE = config.a.MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE, segment_inventory_SegmentInventory = 
        /* */
        function() {
            function SegmentInventory() {
                this.inventory = [];
            }
            /**
   * Reset the whole inventory.
   */            var _proto = SegmentInventory.prototype;
            return _proto.reset = function reset() {
                this.inventory.length = 0;
            }
            /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given (coming from the SourceBuffer).
   * @param {TimeRanges}
   */ , _proto.synchronizeBuffered = function synchronizeBuffered(buffered) {
                for (var inventory = this.inventory, inventoryIndex = 0, thisSegment = inventory[0], rangesLength = buffered.length, i = 0; i < rangesLength; i++) {
                    if (void 0 === thisSegment) 
                    // we arrived at the end of our inventory
                    return;
 // take the i'nth contiguous buffered TimeRange
                                        var rangeStart = buffered.start(i), rangeEnd = buffered.end(i);
                    if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) log.a.warn("SI: skipped TimeRange when synchronizing because it was too small", rangeStart, rangeEnd); else {
                        // keep track of that number
                        // Find the first segment either within this TimeRange or completely past
                        // it:
                        // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the
                        // start of that range.
                        for (var indexBefore = inventoryIndex; void 0 !== thisSegment && takeFirstSet(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE; ) thisSegment = inventory[++inventoryIndex];
 // Contains infos about the last garbage-collected segment before
                        // `thisSegment`.
                                                var lastDeletedSegmentInfos = {
                            end: -1,
                            precizeEnd: !1
                        }, numberOfSegmentToDelete = inventoryIndex - indexBefore;
 // remove garbage-collected segments
                        // (not in that TimeRange nor in the previous one)
                                                if (0 < numberOfSegmentToDelete) {
                            var lastDeletedSegment = // last garbage-collected segment
                            inventory[indexBefore + numberOfSegmentToDelete - 1];
                            lastDeletedSegmentInfos.end = takeFirstSet(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end), 
                            lastDeletedSegmentInfos.precizeEnd = lastDeletedSegment.precizeEnd, log.a.debug("SI: " + numberOfSegmentToDelete + " segments GCed."), 
                            inventory.splice(indexBefore, numberOfSegmentToDelete), inventoryIndex = indexBefore;
                        }
                        if (void 0 === thisSegment) return;
 // If the current segment is actually completely outside that range (it
                        // is contained in one of the next one), skip that part.
                                                if (rangeEnd - takeFirstSet(thisSegment.bufferedStart, thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
                            if (guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos), 
                            inventoryIndex === inventory.length - 1) return void guessBufferedEndFromRangeEnd(thisSegment, rangeEnd);
                            for (// Make contiguous until first segment outside that range
                            var thisSegmentStart = takeFirstSet((thisSegment = inventory[++inventoryIndex]).bufferedStart, thisSegment.start), thisSegmentEnd = takeFirstSet(thisSegment.bufferedEnd, thisSegment.end), nextRangeStart = i < rangesLength - 1 ? buffered.start(i + 1) : void 0; void 0 !== thisSegment && MINIMUM_SEGMENT_SIZE <= rangeEnd - thisSegmentStart && (void 0 === nextRangeStart || thisSegmentEnd - nextRangeStart <= rangeEnd - thisSegmentStart); ) {
                                var prevSegment = inventory[inventoryIndex - 1];
 // those segments are contiguous, we have no way to infer their real
                                // end
                                                                void 0 === prevSegment.bufferedEnd && (prevSegment.bufferedEnd = thisSegment.precizeStart ? thisSegment.start : prevSegment.end, 
                                log.a.debug("SI: calculating buffered end of contiguous segment", prevSegment.bufferedEnd, prevSegment.end)), 
                                thisSegment.bufferedStart = prevSegment.bufferedEnd, void 0 !== (thisSegment = inventory[++inventoryIndex]) && (thisSegmentStart = takeFirstSet(thisSegment.bufferedStart, thisSegment.start), 
                                thisSegmentEnd = takeFirstSet(thisSegment.bufferedEnd, thisSegment.end));
                            }
                        }
 // update the bufferedEnd of the last segment in that range
                                                var lastSegmentInRange = inventory[inventoryIndex - 1];
                        void 0 !== lastSegmentInRange && guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd);
                    }
                }
 // if we still have segments left, they are not affiliated to any range.
                // They might have been garbage collected, delete them from here.
                                thisSegment && (log.a.debug("SI: last segments have been GCed", inventoryIndex, inventory.length), 
                inventory.splice(inventoryIndex, inventory.length - inventoryIndex));
            }
            /**
   * Add a new segment in the inventory.
   *
   * Note: As new segments can "replace" partially or completely old ones, we
   * have to perform a complex logic and might update previously added segments.
   *
   * @param {Object} chunkInformation
   */ , _proto.insertChunk = function insertChunk(_ref) {
                var period = _ref.period, adaptation = _ref.adaptation, representation = _ref.representation, segment = _ref.segment, start = _ref.start, end = _ref.end;
                if (!segment.isInit) if (end <= start) log.a.warn("SI: Invalid chunked inserted: starts before it ends", start, end); else {
                    // begin by the end as in most use cases this will be faster
                    for (var inventory = this.inventory, newSegment = {
                        partiallyPushed: !0,
                        estimatedStart: start,
                        start: start,
                        end: end,
                        precizeStart: !1,
                        precizeEnd: !1,
                        bufferedStart: void 0,
                        bufferedEnd: void 0,
                        infos: {
                            segment: segment,
                            period: period,
                            adaptation: adaptation,
                            representation: representation
                        }
                    }, i = inventory.length - 1; 0 <= i; i--) {
                        var segmentI = inventory[i];
                        if (segmentI.start <= start) {
                            if (segmentI.end <= start) {
                                // Go to segment immediately after newSegment
                                for (
                                // our segment is after, push it after this one
                                //
                                // Case 1:
                                //   prevSegment  : |------|
                                //   newSegment   :        |======|
                                //   ===>         : |------|======|
                                //
                                // Case 2:
                                //   prevSegment  : |------|
                                //   newSegment   :          |======|
                                //   ===>         : |------| |======|
                                log.a.debug("SI: Pushing segment strictly after previous one."), this.inventory.splice(i + 1, 0, newSegment), 
                                i += 2; i < inventory.length && inventory[i].start < newSegment.end; ) {
                                    if (inventory[i].end > newSegment.end) 
                                    // The next segment ends after newSegment.
                                    // Mutate the next segment.
                                    //
                                    // Case 1:
                                    //   prevSegment  : |------|
                                    //   newSegment   :        |======|
                                    //   nextSegment  :            |----|
                                    //   ===>         : |------|======|-|
                                    return log.a.debug("SI: Segment pushed updates the start of the next one"), inventory[i].start = newSegment.end, 
                                    inventory[i].bufferedStart = void 0, void (inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd);
 // The next segment was completely contained in newSegment.
                                    // Remove it.
                                    //
                                    // Case 1:
                                    //   prevSegment  : |------|
                                    //   newSegment   :        |======|
                                    //   nextSegment  :          |---|
                                    //   ===>         : |------|======|
                                    //
                                    // Case 2:
                                    //   prevSegment  : |------|
                                    //   newSegment   :        |======|
                                    //   nextSegment  :          |----|
                                    //   ===>         : |------|======|
                                                                        log.a.debug("SI: Segment pushed removes the next one"), 
                                    inventory.splice(i, 1);
                                }
                                return;
                            }
                            if (segmentI.start === start) {
                                if (segmentI.end <= end) {
                                    // Go to segment immediately after newSegment
                                    for (
                                    // In those cases, replace
                                    //
                                    // Case 1:
                                    //  prevSegment  : |-------|
                                    //  newSegment   : |=======|
                                    //  ===>         : |=======|
                                    //
                                    // Case 2:
                                    //  prevSegment  : |-------|
                                    //  newSegment   : |==========|
                                    //  ===>         : |==========|
                                    log.a.debug("SI: Segment pushed replace another one"), this.inventory.splice(i, 1, newSegment), 
                                    i += 1; i < inventory.length && inventory[i].start < newSegment.end; ) {
                                        if (inventory[i].end > newSegment.end) 
                                        // The next segment ends after newSegment.
                                        // Mutate the next segment.
                                        //
                                        // Case 1:
                                        //   newSegment   : |======|
                                        //   nextSegment  :      |----|
                                        //   ===>         : |======|--|
                                        return log.a.debug("SI: Segment pushed updates the start of the next one"), inventory[i].start = newSegment.end, 
                                        inventory[i].bufferedStart = void 0, void (inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd);
 // The next segment was completely contained in newSegment.
                                        // Remove it.
                                        //
                                        // Case 1:
                                        //   newSegment   : |======|
                                        //   nextSegment  :   |---|
                                        //   ===>         : |======|
                                        //
                                        // Case 2:
                                        //   newSegment   : |======|
                                        //   nextSegment  :   |----|
                                        //   ===>         : |======|
                                                                                log.a.debug("SI: Segment pushed removes the next one"), 
                                        inventory.splice(i, 1);
                                    }
                                    return;
                                }
                                // The previous segment starts at the same time and finishes
                                // after the new segment.
                                // Update the start of the previous segment and put the new
                                // segment before.
                                //
                                // Case 1:
                                //  prevSegment  : |------------|
                                //  newSegment   : |==========|
                                //  ===>         : |==========|-|
                                return log.a.debug("SI: Segment pushed ends before another with the same start"), 
                                inventory.splice(i, 0, newSegment), segmentI.start = newSegment.end, segmentI.bufferedStart = void 0, 
                                void (segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd);
                            }
                            if (segmentI.end <= newSegment.end) {
                                // Go to segment immediately after newSegment
                                for (
                                // our segment has a "complex" relation with this one,
                                // update the old one end and add this one after it.
                                //
                                // Case 1:
                                //  prevSegment  : |-------|
                                //  newSegment   :    |======|
                                //  ===>         : |--|======|
                                //
                                // Case 2:
                                //  prevSegment  : |-------|
                                //  newSegment   :    |====|
                                //  ===>         : |--|====|
                                log.a.debug("SI: Segment pushed updates end of previous one"), this.inventory.splice(i + 1, 0, newSegment), 
                                segmentI.end = newSegment.start, segmentI.bufferedEnd = void 0, segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart, 
                                i += 2; i < inventory.length && inventory[i].start < newSegment.end; ) {
                                    if (inventory[i].end > newSegment.end) 
                                    // The next segment ends after newSegment.
                                    // Mutate the next segment.
                                    //
                                    // Case 1:
                                    //   newSegment   : |======|
                                    //   nextSegment  :      |----|
                                    //   ===>         : |======|--|
                                    return log.a.debug("SI: Segment pushed updates the start of the next one"), inventory[i].start = newSegment.end, 
                                    inventory[i].bufferedStart = void 0, void (inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd);
 // The next segment was completely contained in newSegment.
                                    // Remove it.
                                    //
                                    // Case 1:
                                    //   newSegment   : |======|
                                    //   nextSegment  :   |---|
                                    //   ===>         : |======|
                                    //
                                    // Case 2:
                                    //   newSegment   : |======|
                                    //   nextSegment  :   |----|
                                    //   ===>         : |======|
                                                                        log.a.debug("SI: Segment pushed removes the next one"), 
                                    inventory.splice(i, 1);
                                }
                                return;
                            }
                            // The previous segment completely recovers the new segment.
                            // Split the previous segment into two segments, before and after
                            // the new segment.
                            //
                            // Case 1:
                            //  prevSegment  : |---------|
                            //  newSegment   :    |====|
                            //  ===>         : |--|====|-|
                            log.a.debug("SI: Segment pushed is contained in a previous one");
                            var nextSegment = {
                                partiallyPushed: segmentI.partiallyPushed,
                                start: newSegment.end,
                                end: segmentI.end,
                                precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,
                                precizeEnd: segmentI.precizeEnd,
                                bufferedStart: void 0,
                                bufferedEnd: segmentI.end,
                                infos: segmentI.infos
                            };
                            return segmentI.end = newSegment.start, segmentI.bufferedEnd = void 0, segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart, 
                            inventory.splice(i + 1, 0, newSegment), void inventory.splice(i + 2, 0, nextSegment);
                        }
                    }
 // if we got here, we are the first segment
                    // check bounds of the previous first segment
                                        var firstSegment = this.inventory[0];
                    if (!firstSegment) 
                    // we do not have any segment yet
                    return log.a.debug("SI: Segment pushed comes after all previous ones"), void this.inventory.push(newSegment);
                    if (!(firstSegment.start >= end)) {
                        if (firstSegment.end <= end) {
                            for (
                            // Our segment is bigger, replace the first
                            //
                            // Case 1:
                            //  firstSegment :   |---|
                            //  newSegment   : |=======|
                            //  ===>         : |=======|
                            //
                            // Case 2:
                            //  firstSegment :   |-----|
                            //  newSegment   : |=======|
                            //  ===>         : |=======|
                            log.a.debug("SI: Segment pushed starts before and completely recovers the previous first one"), 
                            this.inventory.splice(0, 1, newSegment); 1 < inventory.length && inventory[1].start < newSegment.end; ) {
                                if (inventory[1].end > newSegment.end) 
                                // The next segment ends after newSegment.
                                // Mutate the next segment.
                                //
                                // Case 1:
                                //   newSegment   : |======|
                                //   nextSegment  :      |----|
                                //   ===>         : |======|--|
                                return log.a.debug("SI: Segment pushed updates the start of the next one"), inventory[1].start = newSegment.end, 
                                inventory[1].bufferedStart = void 0, void (inventory[1].precizeStart = newSegment.precizeEnd);
 // The next segment was completely contained in newSegment.
                                // Remove it.
                                //
                                // Case 1:
                                //   newSegment   : |======|
                                //   nextSegment  :   |---|
                                //   ===>         : |======|
                                //
                                // Case 2:
                                //   newSegment   : |======|
                                //   nextSegment  :   |----|
                                //   ===>         : |======|
                                                                log.a.debug("SI: Segment pushed removes the next one"), 
                                inventory.splice(1, 1);
                            }
                            return;
                        }
                        // our segment has a "complex" relation with the first one,
                        // update the old one start and add this one before it.
                        //
                        // Case 1:
                        //  firstSegment :    |------|
                        //  newSegment   : |======|
                        //  ===>         : |======|--|
                        return log.a.debug("SI: Segment pushed start of the next one"), firstSegment.start = end, 
                        firstSegment.bufferedStart = void 0, firstSegment.precizeStart = newSegment.precizeEnd, 
                        void this.inventory.splice(0, 0, newSegment);
                    }
                    // our segment is before, put it before
                    //
                    // Case 1:
                    //  firstSegment :      |----|
                    //  newSegment   : |====|
                    //  ===>         : |====|----|
                    //
                    // Case 2:
                    //  firstSegment :        |----|
                    //  newSegment   : |====|
                    //  ===>         : |====| |----|
                    log.a.debug("SI: Segment pushed comes before all previous ones"), this.inventory.splice(0, 0, newSegment);
                }
            }
            /**
   * Indicate that inserted chunks can now be considered as a complete segment.
   * Take in argument the same content than what was given to `insertChunk` for
   * the corresponding chunks.
   * @param {Object} content
   */ , _proto.completeSegment = function completeSegment(content) {
                if (!content.segment.isInit) {
                    for (var inventory = this.inventory, foundIt = !1, i = 0; i < inventory.length; i++) if (Object(are_same_content.a)(inventory[i].infos, content)) {
                        foundIt && log.a.warn("SI: Completed Segment is splitted.", content), foundIt = !0;
                        var firstI = i;
                        for (i += 1; i < inventory.length && Object(are_same_content.a)(inventory[i].infos, content); ) i++;
                        var lastI = i - 1, length = lastI - firstI, lastEnd = inventory[lastI].end, lastBufferedEnd = inventory[lastI].bufferedEnd;
                        0 < length && (this.inventory.splice(firstI + 1, length), i -= length), this.inventory[firstI].partiallyPushed = !1, 
                        this.inventory[firstI].end = lastEnd, this.inventory[firstI].bufferedEnd = lastBufferedEnd;
                    }
                    foundIt || log.a.warn("SI: Completed Segment not found", content);
                }
            }
            /**
   * @returns {Array.<Object>}
   */ , _proto.getInventory = function getInventory() {
                return this.inventory;
            }, SegmentInventory;
        }();
        /**
 * Keep track of every chunk downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN chunks are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentInventory
 */        
        /**
 * Returns `true` if the buffered start of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */
        function bufferedStartLooksCoherent(thisSegment) {
            if (void 0 === thisSegment.bufferedStart || thisSegment.partiallyPushed) return !1;
            var start = thisSegment.start, duration = thisSegment.end - start;
            return Math.abs(start - thisSegment.bufferedStart) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && (void 0 === thisSegment.bufferedEnd || thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
        }
        /**
 * Returns `true` if the buffered end of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */        function bufferedEndLooksCoherent(thisSegment) {
            if (void 0 === thisSegment.bufferedEnd || thisSegment.partiallyPushed) return !1;
            var start = thisSegment.start, end = thisSegment.end, duration = end - start;
            return Math.abs(end - thisSegment.bufferedEnd) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && null != thisSegment.bufferedStart && thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
        }
        /**
 * Evaluate the given buffered Chunk's buffered start from its range's start,
 * considering that this chunk is the first one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} lastDeletedSegmentInfos
 */        function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos) {
            void 0 !== firstSegmentInRange.bufferedStart ? (firstSegmentInRange.bufferedStart < rangeStart && (log.a.debug("SI: Segment partially GCed at the start", firstSegmentInRange.bufferedStart, rangeStart), 
            firstSegmentInRange.bufferedStart = rangeStart), !firstSegmentInRange.precizeStart && bufferedStartLooksCoherent(firstSegmentInRange) && (firstSegmentInRange.start = firstSegmentInRange.bufferedStart, 
            firstSegmentInRange.precizeStart = !0)) : firstSegmentInRange.precizeStart ? (log.a.debug("SI: buffered start is precize start", firstSegmentInRange.start), 
            firstSegmentInRange.bufferedStart = firstSegmentInRange.start) : 0 <= lastDeletedSegmentInfos.end && lastDeletedSegmentInfos.end > rangeStart && (lastDeletedSegmentInfos.precizeEnd || firstSegmentInRange.start - lastDeletedSegmentInfos.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) ? (log.a.debug("SI: buffered start is end of previous segment", rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end), 
            firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end, bufferedStartLooksCoherent(firstSegmentInRange) && (firstSegmentInRange.start = lastDeletedSegmentInfos.end, 
            firstSegmentInRange.precizeStart = !0)) : firstSegmentInRange.start - rangeStart <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE ? (log.a.debug("SI: found true buffered start", rangeStart, firstSegmentInRange.start), 
            firstSegmentInRange.bufferedStart = rangeStart, bufferedStartLooksCoherent(firstSegmentInRange) && (firstSegmentInRange.start = rangeStart, 
            firstSegmentInRange.precizeStart = !0)) : rangeStart < firstSegmentInRange.start ? log.a.debug("SI: range start too far from expected start", rangeStart, firstSegmentInRange.start) : (log.a.debug("SI: Segment appears immediately garbage collected at the start", firstSegmentInRange.bufferedStart, rangeStart), 
            firstSegmentInRange.bufferedStart = rangeStart);
        }
        /**
 * Evaluate the given buffered Chunk's buffered end from its range's end,
 * considering that this chunk is the last one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} infos
 */        function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd) {
            void 0 !== lastSegmentInRange.bufferedEnd ? (lastSegmentInRange.bufferedEnd > rangeEnd && (log.a.debug("SI: Segment partially GCed at the end", lastSegmentInRange.bufferedEnd, rangeEnd), 
            lastSegmentInRange.bufferedEnd = rangeEnd), !lastSegmentInRange.precizeEnd && bufferedEndLooksCoherent(lastSegmentInRange) && (lastSegmentInRange.precizeEnd = !0, 
            lastSegmentInRange.end = rangeEnd)) : lastSegmentInRange.precizeEnd ? (log.a.debug("SI: buffered end is precize end", lastSegmentInRange.end), 
            lastSegmentInRange.bufferedEnd = lastSegmentInRange.end) : rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE ? (log.a.debug("SI: found true buffered end", rangeEnd, lastSegmentInRange.end), 
            lastSegmentInRange.bufferedEnd = rangeEnd, bufferedEndLooksCoherent(lastSegmentInRange) && (lastSegmentInRange.end = rangeEnd, 
            lastSegmentInRange.precizeEnd = !0)) : rangeEnd > lastSegmentInRange.end ? (log.a.debug("SI: range end too far from expected end", rangeEnd, lastSegmentInRange.end), 
            lastSegmentInRange.bufferedEnd = lastSegmentInRange.end, bufferedEndLooksCoherent(lastSegmentInRange) && (lastSegmentInRange.end = rangeEnd, 
            lastSegmentInRange.precizeEnd = !0)) : (log.a.debug("SI: Segment appears immediately garbage collected at the end", lastSegmentInRange.bufferedEnd, rangeEnd), 
            lastSegmentInRange.bufferedEnd = rangeEnd);
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts
                function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SourceBufferAction, APPEND_WINDOW_SECURITIES = config.a.APPEND_WINDOW_SECURITIES, SOURCE_BUFFER_FLUSHING_INTERVAL = config.a.SOURCE_BUFFER_FLUSHING_INTERVAL;
        !function(SourceBufferAction) {
            SourceBufferAction[SourceBufferAction.Push = 0] = "Push", SourceBufferAction[SourceBufferAction.Remove = 1] = "Remove", 
            SourceBufferAction[SourceBufferAction.EndOfSegment = 2] = "EndOfSegment";
        }(SourceBufferAction = SourceBufferAction || {});
        /**
 * Allows to push and remove new Segments to a SourceBuffer in a FIFO queue (not
 * doing so can lead to browser Errors) while keeping an inventory of what has
 * been pushed.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */
        var queued_source_buffer_QueuedSourceBuffer = 
        /* */
        function() {
            /**
   * @constructor
   * @param {string} bufferType
   * @param {string} codec
   * @param {SourceBuffer} sourceBuffer
   */
            function QueuedSourceBuffer(bufferType, codec, sourceBuffer) {
                var _this = this;
                this._destroy$ = new Subject.a(), this.bufferType = bufferType, this._sourceBuffer = sourceBuffer, 
                this._queue = [], this._pendingTask = null, this._lastInitSegment = null, this._currentCodec = codec, 
                this._segmentInventory = new segment_inventory_SegmentInventory(), // Some browsers (happened with firefox 66) sometimes "forget" to send us
                // `update` or `updateend` events.
                // In that case, we're completely unable to continue the queue here and
                // stay locked in a waiting state.
                // This interval is here to check at regular intervals if the underlying
                // SourceBuffer is currently updating.
                Object(observable_interval.a)(SOURCE_BUFFER_FLUSHING_INTERVAL).pipe(Object(tap.a)(function() {
                    return _this._flush();
                }), Object(takeUntil.a)(this._destroy$)).subscribe(), Object(fromEvent.a)(this._sourceBuffer, "error").pipe(Object(tap.a)(function(err) {
                    return _this._onError(err);
                }), Object(takeUntil.a)(this._destroy$)).subscribe(), Object(fromEvent.a)(this._sourceBuffer, "updateend").pipe(Object(tap.a)(function() {
                    return _this._flush();
                }), Object(takeUntil.a)(this._destroy$)).subscribe();
            }
            /**
   * Public access to the SourceBuffer's current codec.
   * @returns {string}
   */            var _proto = QueuedSourceBuffer.prototype;
            /**
   * Push a chunk of the media segment given to the attached SourceBuffer, in a
   * FIFO queue.
   *
   * Once all chunks of a single Segment have been given to `pushChunk`, you
   * should call `endOfSegment` to indicate that the whole Segment has been
   * pushed.
   *
   * Depending on the type of data appended, this might need an associated
   * initialization segment.
   *
   * Such initialization segment will be pushed in the SourceBuffer if the
   * last segment pushed was associated to another initialization segment.
   * This detection is entirely reference-based so make sure that the same
   * initSegment argument given share the same reference.
   *
   * You can disable the usage of initialization segment by setting the
   * `infos.data.initSegment` argument to null.
   *
   * You can also only push an initialization segment by setting the
   * `infos.data.chunk` argument to null.
   *
   * @param {Object} infos
   * @returns {Observable}
   */            return _proto.pushChunk = function pushChunk(infos) {
                return log.a.debug("QSB: receiving order to push data to the SourceBuffer", this.bufferType, infos), 
                this._addToQueue({
                    type: SourceBufferAction.Push,
                    value: infos
                });
            }
            /**
   * Remove buffered data (added to the same FIFO queue than `pushChunk`).
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Observable}
   */ , _proto.removeBuffer = function removeBuffer(start, end) {
                return log.a.debug("QSB: receiving order to remove data from the SourceBuffer", this.bufferType, start, end), 
                this._addToQueue({
                    type: SourceBufferAction.Remove,
                    value: {
                        start: start,
                        end: end
                    }
                });
            }
            /**
   * Indicate that every chunks from a Segment has been given to pushChunk so
   * far.
   * This will update our internal Segment inventory accordingly.
   * The returned Observable will emit and complete successively once the whole
   * segment has been pushed and this indication is acknowledged.
   * @param {Object} infos
   * @returns {Observable}
   */ , _proto.endOfSegment = function endOfSegment(infos) {
                return log.a.debug("QSB: receiving order for validating end of segment", this.bufferType, infos.segment), 
                this._addToQueue({
                    type: SourceBufferAction.EndOfSegment,
                    value: infos
                });
            }
            /**
   * The maintained inventory can fall out of sync from garbage collection or
   * other events.
   *
   * This methods allow to manually trigger a synchronization. It should be
   * called before retrieving Segment information from it (e.g. with
   * `getInventory`).
   */ , _proto.synchronizeInventory = function synchronizeInventory() {
                this._segmentInventory.synchronizeBuffered(this.getBufferedRanges());
            }
            /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */ , _proto.getBufferedRanges = function getBufferedRanges() {
                return this._sourceBuffer.buffered;
            }
            /**
   * Returns the currently buffered data for which the content is known with
   * the corresponding content information.
   * /!\ This data can fall out of sync with the real buffered ranges. Please
   * call `synchronizeInventory` before to make sure it is correctly
   * synchronized.
   * @returns {Array.<Object>}
   */ , _proto.getInventory = function getInventory() {
                return this._segmentInventory.getInventory();
            }
            /**
   * Dispose of the resources used by this QueuedSourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */ , _proto.dispose = function dispose() {
                for (this._destroy$.next(), this._destroy$.complete(), null != this._pendingTask && (this._pendingTask.subject.complete(), 
                this._pendingTask = null); this._queue.length; ) {
                    var nextElement = this._queue.shift();
                    null != nextElement && nextElement.subject.complete();
                }
            }
            /**
   * Abort the linked SourceBuffer.
   * You should call this only if the linked MediaSource is still "open".
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */ , _proto.abort = function abort() {
                this._sourceBuffer.abort();
            }
            /**
   * @private
   * @param {Event} error
   */ , _proto._onError = function _onError(err) {
                var error = err instanceof Error ? err : new Error("An unknown error occured when appending buffer");
                // initialize init segment as a security
                (this._lastInitSegment = null) != this._pendingTask && this._pendingTask.subject.error(error);
            }
            /**
   * When the returned observable is subscribed:
   *   1. Add your action to the queue.
   *   2. Begin the queue if not pending.
   *
   * Cancel queued action on unsubscription.
   * @private
   * @param {Object} action
   * @returns {Observable}
   */ , _proto._addToQueue = function _addToQueue(action) {
                var _this2 = this;
                return new Observable.a(function(obs) {
                    var shouldRestartQueue = 0 === _this2._queue.length && null == _this2._pendingTask, subject = new Subject.a(), queueItem = object_assign_default()({
                        subject: subject
                    }, action);
                    _this2._queue.push(queueItem);
                    var subscription = subject.subscribe(obs);
                    return shouldRestartQueue && _this2._flush(), function() {
                        subscription.unsubscribe();
                        var index = _this2._queue.indexOf(queueItem);
                        0 <= index && _this2._queue.splice(index, 1);
                    };
                });
            }
            /**
   * Perform next task if one.
   * @private
   */ , _proto._flush = function _flush() {
                if (!this._sourceBuffer.updating) {
                    // handle end of previous task if needed
                    if (null != this._pendingTask) {
                        if (this._pendingTask.type !== SourceBufferAction.Push || 0 === this._pendingTask.steps.length) {
                            switch (this._pendingTask.type) {
                              case SourceBufferAction.Push:
                                this._segmentInventory.insertChunk(this._pendingTask.inventoryData);
                                break;

                              case SourceBufferAction.EndOfSegment:
                                this._segmentInventory.completeSegment(this._pendingTask.value);
                                break;

                              case SourceBufferAction.Remove:
                                this.synchronizeInventory();
                            }
                            var subject = this._pendingTask.subject;
                            return this._pendingTask = null, subject.next(), subject.complete(), void (0 < this._queue.length && this._flush());
                        }
                    } else {
                        if (0 === this._queue.length) return; // we have nothing left to do
                        // now handle current task
                                                var newQueueItem = this._queue.shift();
                        if (null == newQueueItem) 
                        // TODO TypeScrypt do not get the previous length check. Find solution /
                        // open issue
                        throw new Error("An item from the QueuedSourceBuffer queue was not defined");
                        if (this._pendingTask = convertQueueItemToTask(newQueueItem), null == this._pendingTask) 
                        // nothing to do, complete and go to next item
                        return newQueueItem.subject.next(), newQueueItem.subject.complete(), void this._flush();
                    }
                    var task = this._pendingTask;
                    try {
                        switch (task.type) {
                          case SourceBufferAction.EndOfSegment:
                            // nothing to do, we will just acknowledge the segment.
                            return log.a.debug("QSB: Acknowledging complete segment", task.value), void this._flush();

                          case SourceBufferAction.Push:
                            var nextStep = task.steps.shift();
                            if (null == nextStep || nextStep.isInit && this._lastInitSegment === nextStep.segmentData) return void this._flush();
                            this._pushSegmentData(nextStep);
                            break;

                          case SourceBufferAction.Remove:
                            var _task$value = task.value, start = _task$value.start, end = _task$value.end;
                            log.a.debug("QSB: removing data from SourceBuffer", this.bufferType, start, end), 
                            this._sourceBuffer.remove(start, end);
                        }
                    } catch (e) {
                        this._onError(e);
                    }
                }
            }
            /**
   * Push given data to the underlying SourceBuffer.
   * /!\ Heavily mutates the private state.
   * @param {Object} task
   */ , _proto._pushSegmentData = function _pushSegmentData(data) {
                var isInit = data.isInit, segmentData = data.segmentData, timestampOffset = data.timestampOffset, appendWindow = data.appendWindow, codec = data.codec;
                this._currentCodec !== codec && (log.a.debug("QSB: updating codec"), Object(change_source_buffer_type.a)(this._sourceBuffer, codec) ? this._currentCodec = codec : log.a.warn("QSB: could not update codec", codec, this._currentCodec));
                if (this._sourceBuffer.timestampOffset !== timestampOffset) {
                    var newTimestampOffset = timestampOffset;
                    log.a.debug("QSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset), 
                    this._sourceBuffer.timestampOffset = newTimestampOffset;
                }
                null == appendWindow[0] ? 0 < this._sourceBuffer.appendWindowStart && (this._sourceBuffer.appendWindowStart = 0) : appendWindow[0] !== this._sourceBuffer.appendWindowStart && (appendWindow[0] >= this._sourceBuffer.appendWindowEnd && (this._sourceBuffer.appendWindowEnd = appendWindow[0] + 1), 
                this._sourceBuffer.appendWindowStart = appendWindow[0]), null == appendWindow[1] ? Infinity !== this._sourceBuffer.appendWindowEnd && (this._sourceBuffer.appendWindowEnd = Infinity) : appendWindow[1] !== this._sourceBuffer.appendWindowEnd && (this._sourceBuffer.appendWindowEnd = appendWindow[1]), 
                log.a.debug("QSB: pushing new data to SourceBuffer", this.bufferType), isInit && (this._lastInitSegment = segmentData), 
                this._sourceBuffer.appendBuffer(segmentData);
            }, _createClass(QueuedSourceBuffer, [ {
                key: "codec",
                get: function get() {
                    return this._currentCodec;
                }
            } ]), QueuedSourceBuffer;
        }();
        /**
 * @param {Object} item
 * @returns {Object|null}
 */        function convertQueueItemToTask(item) {
            switch (item.type) {
              case SourceBufferAction.Push:
                // Push actions with both an init segment and a regular segment need
                // to be separated into two steps
                var steps = [], itemValue = item.value, data = itemValue.data, inventoryInfos = itemValue.inventoryInfos, estimatedDuration = inventoryInfos.estimatedDuration, estimatedStart = inventoryInfos.estimatedStart, segment = inventoryInfos.segment, safeAppendWindow = [ void 0 !== data.appendWindow[0] ? Math.max(0, data.appendWindow[0] - APPEND_WINDOW_SECURITIES.START) : void 0, void 0 !== data.appendWindow[1] ? data.appendWindow[1] + APPEND_WINDOW_SECURITIES.END : void 0 ];
                if (null !== data.initSegment && steps.push({
                    isInit: !0,
                    segmentData: data.initSegment,
                    codec: data.codec,
                    timestampOffset: data.timestampOffset,
                    appendWindow: safeAppendWindow
                }), null !== data.chunk && steps.push({
                    isInit: !1,
                    segmentData: data.chunk,
                    codec: data.codec,
                    timestampOffset: data.timestampOffset,
                    appendWindow: safeAppendWindow
                }), 0 === steps.length) return null;
                var start = void 0 === estimatedStart ? segment.time / segment.timescale : estimatedStart, end = start + (void 0 === estimatedDuration ? segment.duration / segment.timescale : estimatedDuration);
                void 0 !== safeAppendWindow[0] && (start = Math.max(start, safeAppendWindow[0])), 
                void 0 !== safeAppendWindow[1] && (end = Math.min(end, safeAppendWindow[1]));
                var inventoryData = {
                    period: inventoryInfos.period,
                    adaptation: inventoryInfos.adaptation,
                    representation: inventoryInfos.representation,
                    segment: inventoryInfos.segment,
                    start: start,
                    end: end
                };
                return {
                    type: SourceBufferAction.Push,
                    steps: steps,
                    inventoryData: inventoryData,
                    subject: item.subject
                };

              case SourceBufferAction.Remove:
              case SourceBufferAction.EndOfSegment:
                return item;
            }
            return null;
        }
        // CONCATENATED MODULE: ./src/core/source_buffers/source_buffers_store.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var POSSIBLE_BUFFER_TYPES = [ "audio", "video", "text", "image" ];
        /**
 * Get all currently available buffer types.
 * /!\ This list can evolve at runtime depending on feature switching.
 * @returns {Array.<string>}
 */        function getBufferTypes() {
            var bufferTypes = [ "audio", "video" ];
            return null == features.a.nativeTextTracksBuffer && null == features.a.htmlTextTracksBuffer || bufferTypes.push("text"), 
            null != features.a.imageBuffer && bufferTypes.push("image"), bufferTypes;
        }
        /**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one SourceBuffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBuffersStore
 */        var source_buffers_store_SourceBuffersStore = 
        /* */
        function() {
            /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */
            function SourceBuffersStore(mediaElement, mediaSource) {
                this._mediaElement = mediaElement, this._mediaSource = mediaSource, this._initializedSourceBuffers = {};
            }
            /**
   * Returns true if the SourceBuffer is "native" (has to be attached to the
   * mediaSource before playback).
   * @static
   * @param {string} bufferType
   * @returns {Boolean}
   */            SourceBuffersStore.isNative = function isNative(bufferType) {
                return shouldHaveNativeSourceBuffer(bufferType);
            }
            /**
   * Returns the created QueuedSourceBuffer for the given type.
   * Returns null if no QueuedSourceBuffer were created for the given type.
   *
   * @param {string} bufferType
   * @returns {QueuedSourceBuffer|null}
   */;
            var _proto = SourceBuffersStore.prototype;
            return _proto.get = function get(bufferType) {
                return this._initializedSourceBuffers[bufferType] || null;
            }
            /**
   * Creates a new QueuedSourceBuffer for the SourceBuffer type.
   * Reuse an already created one if a QueuedSourceBuffer for the given type
   * already exists.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {QueuedSourceBuffer}
   */ , _proto.createSourceBuffer = function createSourceBuffer(bufferType, codec, options) {
                void 0 === options && (options = {});
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (shouldHaveNativeSourceBuffer(bufferType)) {
                    if (memorizedSourceBuffer) return memorizedSourceBuffer.codec !== codec ? log.a.warn("SB: Reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec) : log.a.info("SB: Reusing native SourceBuffer with codec", codec), 
                    memorizedSourceBuffer;
                    log.a.info("SB: Adding native SourceBuffer with codec", codec);
                    var nativeSourceBuffer = createNativeQueuedSourceBuffer(bufferType, this._mediaSource, codec);
                    return this._initializedSourceBuffers[bufferType] = nativeSourceBuffer;
                }
                if (memorizedSourceBuffer) return log.a.info("SB: Reusing a previous custom SourceBuffer for the type", bufferType), 
                memorizedSourceBuffer;
                if ("text" === bufferType) {
                    var sourceBuffer;
                    if (log.a.info("SB: Creating a new text SourceBuffer with codec", codec), "html" === options.textTrackMode) {
                        if (null == features.a.htmlTextTracksBuffer) throw new Error("HTML Text track feature not activated");
                        sourceBuffer = new features.a.htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
                    } else {
                        if (null == features.a.nativeTextTracksBuffer) throw new Error("Native Text track feature not activated");
                        sourceBuffer = new features.a.nativeTextTracksBuffer(this._mediaElement, !!options.hideNativeSubtitle);
                    }
                    var queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("text", codec, sourceBuffer);
                    return this._initializedSourceBuffers.text = queuedSourceBuffer;
                }
                if ("image" !== bufferType) throw log.a.error("SB: Unknown buffer type:", bufferType), 
                new media_error.a("BUFFER_TYPE_UNKNOWN", "The player wants to create a SourceBuffer of an unknown type.");
                if (null == features.a.imageBuffer) throw new Error("Image buffer feature not activated");
                log.a.info("SB: Creating a new image SourceBuffer with codec", codec);
                var _sourceBuffer = new features.a.imageBuffer(), _queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("image", codec, _sourceBuffer);
                return this._initializedSourceBuffers.image = _queuedSourceBuffer;
            }
            /**
   * Dispose of the active SourceBuffer for the given type.
   * @param {string} bufferType
   */ , _proto.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
                var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];
                if (null != memorizedSourceBuffer) {
                    if (log.a.info("SB: Aborting SourceBuffer", bufferType), memorizedSourceBuffer.dispose(), 
                    !shouldHaveNativeSourceBuffer(bufferType) || "open" === this._mediaSource.readyState) try {
                        memorizedSourceBuffer.abort();
                    } catch (e) {
                        log.a.warn("SB: Failed to abort a " + bufferType + " SourceBuffer:", e);
                    }
                    delete this._initializedSourceBuffers[bufferType];
                } else log.a.warn("SB: Trying to dispose a SourceBuffer that does not exist");
            }
            /**
   * Dispose of all QueuedSourceBuffer created on this SourceBuffersStore.
   */ , _proto.disposeAll = function disposeAll() {
                var _this = this;
                POSSIBLE_BUFFER_TYPES.forEach(function(bufferType) {
                    null != _this.get(bufferType) && _this.disposeSourceBuffer(bufferType);
                });
            }, SourceBuffersStore;
        }();
        /**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */        function createNativeQueuedSourceBuffer(bufferType, mediaSource, codec) {
            var sourceBuffer = mediaSource.addSourceBuffer(codec);
            return new queued_source_buffer_QueuedSourceBuffer(bufferType, codec, sourceBuffer);
        }
        /**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */        function shouldHaveNativeSourceBuffer(bufferType) {
            return "audio" === bufferType || "video" === bufferType;
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
                var scan = __webpack_require__(219);
        // CONCATENATED MODULE: ./src/core/buffers/active_period_emitter.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */
        /**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a RepresentationBuffer associated for every defined BUFFER_TYPES.
 *
 * Emit null if no Period can be considered active currently.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video
 * RepresentationBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer information when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer information when
 * one is removed.
 * @returns {Observable}
 */        function ActivePeriodEmitter(buffers$) {
            var numberOfBuffers = buffers$.length;
            return merge.a.apply(void 0, buffers$).pipe(// not needed to filter, this is an optim
            Object(filter.a)(function(_ref) {
                var type = _ref.type;
                return "periodBufferCleared" === type || "adaptationChange" === type || "representationChange" === type;
            }), Object(scan.a)(function(acc, evt) {
                switch (evt.type) {
                  case "periodBufferCleared":
                    var _evt$value = evt.value, period = _evt$value.period, type = _evt$value.type, currentInfos = acc[period.id];
                    null != currentInfos && currentInfos.buffers.has(type) && (currentInfos.buffers.delete(type), 
                    0 === currentInfos.buffers.size && delete acc[period.id]);
                    break;

                  case "adaptationChange":
                    // `adaptationChange` with a null Adaptation will not lead to a
                    // `representationChange` event
                    if (null != evt.value.adaptation) return acc;

                  case "representationChange":
                    var _evt$value2 = evt.value, _period = _evt$value2.period, _type = _evt$value2.type, _currentInfos = acc[_period.id];
                    if (null == _currentInfos || _currentInfos.buffers.has(_type)) {
                        var bufferSet = new Set();
                        bufferSet.add(_type), acc[_period.id] = {
                            period: _period,
                            buffers: bufferSet
                        };
                    } else _currentInfos.buffers.add(_type);
                }
                return acc;
            }, {}), Object(map.a)(function(list) {
                for (var activePeriodIDs = Object.keys(list), completePeriods = [], i = 0; i < activePeriodIDs.length; i++) {
                    var periodInfos = list[activePeriodIDs[i]];
                    null != periodInfos && periodInfos.buffers.size === numberOfBuffers && completePeriods.push(periodInfos.period);
                }
                return completePeriods.reduce(function(acc, period) {
                    return null == acc ? period : period.start < acc.start ? period : acc;
                }, null);
            }), Object(distinctUntilChanged.a)(function(a, b) {
                return null == a && null == b || null != a && null != b && a.id === b.id;
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffers/are_buffers_complete.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns an Observable which emits ``true`` when all PeriodBuffers given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */        function areBuffersComplete() {
            for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            /**
   * Array of Observables linked to the Array of Buffers which emit:
   *   - true when the corresponding buffer is considered _complete_.
   *   - false when the corresponding buffer is considered _active_.
   * @type {Array.<Observable>}
   */            var isCompleteArray = buffers.map(function(buffer) {
                return buffer.pipe(Object(filter.a)(function(evt) {
                    return "complete-buffer" === evt.type || "active-buffer" === evt.type;
                }), Object(map.a)(function(evt) {
                    return "complete-buffer" === evt.type;
                }), Object(startWith.a)(!1), Object(distinctUntilChanged.a)());
            });
            return Object(combineLatest.a)(isCompleteArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete.every(function(isComplete) {
                    return isComplete;
                });
            }), Object(distinctUntilChanged.a)());
        }
        // CONCATENATED MODULE: ./src/core/buffers/events_generators.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var buffers_events_generators = {
            activeBuffer: function activeBuffer(bufferType) {
                return {
                    type: "active-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            activePeriodChanged: function activePeriodChanged(period) {
                return {
                    type: "activePeriodChanged",
                    value: {
                        period: period
                    }
                };
            },
            adaptationChange: function adaptationChange(bufferType, adaptation, period) {
                return {
                    type: "adaptationChange",
                    value: {
                        type: bufferType,
                        adaptation: adaptation,
                        period: period
                    }
                };
            },
            addedSegment: function addedSegment(content, segment, buffered, segmentData) {
                return {
                    type: "added-segment",
                    value: {
                        content: content,
                        segment: segment,
                        segmentData: segmentData,
                        buffered: buffered
                    }
                };
            },
            bitrateEstimationChange: function bitrateEstimationChange(type, bitrate) {
                return {
                    type: "bitrateEstimationChange",
                    value: {
                        type: type,
                        bitrate: bitrate
                    }
                };
            },
            bufferComplete: function bufferComplete(bufferType) {
                return {
                    type: "complete-buffer",
                    value: {
                        type: bufferType
                    }
                };
            },
            discontinuityEncountered: function discontinuityEncountered(gap, bufferType) {
                return {
                    type: "discontinuity-encountered",
                    value: {
                        bufferType: bufferType,
                        gap: gap
                    }
                };
            },
            endOfStream: function endOfStream() {
                return {
                    type: "end-of-stream",
                    value: void 0
                };
            },
            fullBuffer: function fullBuffer(bufferType) {
                return {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            },
            needsManifestRefresh: function needsManifestRefresh() {
                return {
                    type: "needs-manifest-refresh",
                    value: void 0
                };
            },
            manifestMightBeOufOfSync: function manifestMightBeOufOfSync() {
                return {
                    type: "manifest-might-be-out-of-sync",
                    value: void 0
                };
            },
            needsMediaSourceReload: function needsMediaSourceReload(_ref) {
                return {
                    type: "needs-media-source-reload",
                    value: {
                        currentTime: _ref.currentTime,
                        isPaused: _ref.isPaused
                    }
                };
            },
            periodBufferReady: function periodBufferReady(type, period, adaptation$) {
                return {
                    type: "periodBufferReady",
                    value: {
                        type: type,
                        period: period,
                        adaptation$: adaptation$
                    }
                };
            },
            periodBufferCleared: function periodBufferCleared(type, period) {
                return {
                    type: "periodBufferCleared",
                    value: {
                        type: type,
                        period: period
                    }
                };
            },
            representationChange: function representationChange(type, period, representation) {
                return {
                    type: "representationChange",
                    value: {
                        type: type,
                        period: period,
                        representation: representation
                    }
                };
            },
            resumeStream: function resumeStream() {
                return {
                    type: "resume-stream",
                    value: void 0
                };
            },
            warning: function warning(value) {
                return {
                    type: "warning",
                    value: value
                };
            }
        }, source_buffers = source_buffers_store_SourceBuffersStore;
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/utils/concat_map_latest.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Same as concatMap, but get last emitted value from source instead of unstack
 * inner values.
 * @param {function} callback
 * @returns {function}
 */
        function concatMapLatest(callback) {
            return function(source) {
                return Object(defer.a)(function() {
                    var valuePending, counter = 0, hasValuePending = !1, isExhausting = !1;
                    return source.pipe(Object(mergeMap.a)(function next(value) {
                        return Object(defer.a)(function() {
                            return isExhausting ? (valuePending = value, hasValuePending = !0, empty.a) : (isExhausting = !(hasValuePending = !1), 
                            callback(value, counter++).pipe(Object(tap.a)({
                                complete: function complete() {
                                    return isExhausting = !1;
                                }
                            }), function(s) {
                                return Object(concat.a)(s, Object(defer.a)(function() {
                                    return hasValuePending ? next(valuePending) : empty.a;
                                }));
                            }));
                        });
                    }));
                });
            };
        }
        // EXTERNAL MODULE: ./node_modules/next-tick/index.js
                var next_tick = __webpack_require__(65), next_tick_default = /* */ __webpack_require__.n(next_tick);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function takeWhile(predicate, inclusive) {
            return void 0 === inclusive && (inclusive = !1), function(source) {
                return source.lift(new TakeWhileOperator(predicate, inclusive));
            };
        }
        var TakeWhileOperator = /* */ function() {
            function TakeWhileOperator(predicate, inclusive) {
                this.predicate = predicate, this.inclusive = inclusive;
            }
            return TakeWhileOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
            }, TakeWhileOperator;
        }(), takeWhile_TakeWhileSubscriber = /* */ function(_super) {
            function TakeWhileSubscriber(destination, predicate, inclusive) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.inclusive = inclusive, _this.index = 0, 
                _this;
            }
            return tslib_es6.a(TakeWhileSubscriber, _super), TakeWhileSubscriber.prototype._next = function(value) {
                var result, destination = this.destination;
                try {
                    result = this.predicate(value, this.index++);
                } catch (err) {
                    return void destination.error(err);
                }
                this.nextOrComplete(value, result);
            }, TakeWhileSubscriber.prototype.nextOrComplete = function(value, predicateResult) {
                var destination = this.destination;
                Boolean(predicateResult) ? destination.next(value) : (this.inclusive && destination.next(value), 
                destination.complete());
            }, TakeWhileSubscriber;
        }(Subscriber.a), simple_set = __webpack_require__(68), BITRATE_REBUFFERING_RATIO = config.a.BITRATE_REBUFFERING_RATIO, MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config.a.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, get_needed_segments_MINIMUM_SEGMENT_SIZE = config.a.MINIMUM_SEGMENT_SIZE;
        /**
 * @param {Object} segmentFilterArgument
 * @returns {Array.<Object>}
 */
        function getNeededSegments(_ref) {
            var content = _ref.content, fastSwitchingStep = _ref.fastSwitchingStep, loadedSegmentPendingPush = _ref.loadedSegmentPendingPush, neededRange = _ref.neededRange, segmentInventory = _ref.segmentInventory, possibleSegments = content.representation.index.getSegments(neededRange.start, neededRange.end - neededRange.start), completeSegments = filterGarbageCollectedSegments(getCorrespondingBufferedSegments({
                start: Math.max(neededRange.start - .5, 0),
                end: neededRange.end + .5
            }, segmentInventory).filter(function(bufferedSegment) {
                return !shouldContentBeReplaced(bufferedSegment.infos, content, fastSwitchingStep);
            }), neededRange), roundingError = Math.min(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE);
            // 1 - construct lists of segments possible and actually pushed
                        return possibleSegments.filter(function(segment) {
                if (loadedSegmentPendingPush.test(segment.id)) return !1;
 // we're already pushing it
                                var duration = segment.duration, time = segment.time, timescale = segment.timescale;
                if (segment.isInit || void 0 === duration) return !0;
 // never skip those
                                if (duration / timescale < get_needed_segments_MINIMUM_SEGMENT_SIZE) return !1;
 // too small
                                // check if the segment is already downloaded
                for (var scaledTime = time / timescale, scaledEnd = scaledTime + duration / timescale, i = 0; i < completeSegments.length; i++) {
                    var completeSeg = completeSegments[i], segTime = completeSeg.infos.segment.time, segDuration = completeSeg.infos.segment.duration, segTimeScale = completeSeg.infos.segment.timescale, scaledSegTime = segTime / segTimeScale;
                    if (-roundingError < scaledTime - scaledSegTime && -roundingError < scaledSegTime + segDuration / segTimeScale - scaledEnd) return !1;
 // already downloaded
                                }
 // check if there is an hole in place of the segment currently
                                for (var _i = 0; _i < completeSegments.length; _i++) {
                    var _completeSeg = completeSegments[_i];
                    if (_completeSeg.end > scaledTime) {
                        if (_completeSeg.start > scaledTime + roundingError) return !0;
                        // go through all contiguous segments and take the last one
                        for (var j = _i + 1; j < completeSegments.length - 1 && completeSegments[j - 1].end + roundingError > completeSegments[j].start; ) j++;
                        // index of last contiguous segment
                        return completeSegments[--j].end < scaledEnd + roundingError;
                    }
                }
                return !0;
            });
        }
        /**
 * Returns `true` if segments linked to the given `oldContent` currently present
 * in the buffer should be replaced by segments coming from `currentContent`.
 * @param {Object} oldContent
 * @param {Object} currentContent
 * @param {number} [fastSwitchingStep]
 * @returns {boolean}
 */        function shouldContentBeReplaced(oldContent, currentContent, fastSwitchingStep) {
            if (oldContent.period.id !== currentContent.period.id) return !1;
 // keep segments from another Period by default.
                        if (oldContent.adaptation.id !== currentContent.adaptation.id) return !0;
 // replace segments from another Adaptation
                        var oldContentBitrate = oldContent.representation.bitrate;
            if (void 0 !== fastSwitchingStep) return oldContentBitrate < fastSwitchingStep;
            // only re-load comparatively-poor bitrates for the same Adaptation.
            var bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
            return currentContent.representation.bitrate > bitrateCeil;
        }
        /**
 * Returns an Array which removed the segments from `consideredSegments` which
 * appeared to have been garbage collected.
 * @param {Array.<Object>} consideredSegments
 * @param {Object} neededRange
 * @returns {Array.<Object>}
 */        function filterGarbageCollectedSegments(consideredSegments, neededRange) {
            for (var completeSegments = [], i = 0; i < consideredSegments.length; i++) {
                var segmentStartIsComplete = !0, segmentEndIsComplete = !0, currentSeg = consideredSegments[i], prevSeg = 0 === i ? null : consideredSegments[i - 1], nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];
                void 0 === currentSeg.bufferedStart ? segmentStartIsComplete = !1 : (null === prevSeg || void 0 === prevSeg.bufferedEnd || prevSeg.bufferedEnd !== currentSeg.bufferedStart) && neededRange.start < currentSeg.bufferedStart && currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT && (log.a.info("Buffer: The start of the wanted segment has been garbage collected", currentSeg), 
                segmentStartIsComplete = !1), void 0 === currentSeg.bufferedEnd ? segmentEndIsComplete = !1 : (null === nextSeg || void 0 === nextSeg.bufferedEnd || nextSeg.bufferedEnd !== currentSeg.bufferedStart) && neededRange.end > currentSeg.bufferedEnd && currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT && (log.a.info("Buffer: The end of the wanted segment has been garbage collected", currentSeg), 
                segmentEndIsComplete = !1), segmentStartIsComplete && segmentEndIsComplete && completeSegments.push(currentSeg);
            }
            return completeSegments;
        }
        /**
 * From the given SegmentInventory, filters the buffered Segment Object which
 * overlap with the given range.
 * @param {Object} neededRange
 * @param {Array.<Object>} segmentInventory
 * @returns {Array.<Object>}
 */        function getCorrespondingBufferedSegments(neededRange, segmentInventory) {
            for (var segmentRoundingError = Math.max(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE), minEnd = neededRange.start + segmentRoundingError, maxStart = neededRange.end - segmentRoundingError, overlappingChunks = [], i = segmentInventory.length - 1; 0 <= i; i--) {
                var eltInventory = segmentInventory[i];
                if (!eltInventory.partiallyPushed) {
                    var inventorySegment = eltInventory.infos.segment, eltInventoryStart = inventorySegment.time / inventorySegment.timescale;
                    (minEnd < (null == inventorySegment.duration ? eltInventory.end : eltInventoryStart + inventorySegment.duration / inventorySegment.timescale) && eltInventoryStart < maxStart || eltInventory.end > minEnd && eltInventory.start < maxStart) && overlappingChunks.unshift(eltInventory);
                }
            }
            return overlappingChunks;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_segment_priority.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var SEGMENT_PRIORITIES_STEPS = config.a.SEGMENT_PRIORITIES_STEPS;
        /**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */        function getSegmentPriority(segment, clockTick) {
            for (var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset, distance = segment.time / segment.timescale - currentTime, priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) if (distance < SEGMENT_PRIORITIES_STEPS[priority]) return priority;
            return SEGMENT_PRIORITIES_STEPS.length;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/get_wanted_range.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} tick
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */        function getWantedRange(hardLimits, tick, bufferGoal) {
            var currentTime = tick.currentTime + tick.wantedTimeOffset, boundedLimits = {
                start: Math.max(hardLimits.start || 0, currentTime),
                end: hardLimits.end
            };
            return {
                start: Math.min(boundedLimits.end || Infinity, Math.max(currentTime, boundedLimits.start)),
                end: Math.min(boundedLimits.end || Infinity, Math.max(currentTime + bufferGoal, boundedLimits.start))
            };
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/force_garbage_collection.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var GC_GAP_CALM = config.a.BUFFER_GC_GAPS.CALM, GC_GAP_BEEFY = config.a.BUFFER_GC_GAPS.BEEFY;
        /**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */
        function forceGarbageCollection(timings$, bufferingQueue) {
            // wait for next timing event
            return timings$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(timing) {
                log.a.warn("Buffer: Running garbage collector");
                var buffered = bufferingQueue.getBufferedRanges(), cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
                // more aggressive GC if we could not find any range to clean
                return 0 === cleanedupRanges.length && (cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY)), 
                log.a.debug("Buffer: GC cleaning", cleanedupRanges), Object(from.a)(cleanedupRanges.map(function(_ref) {
                    var start = _ref.start, end = _ref.end;
                    return bufferingQueue.removeBuffer(start, end);
                })).pipe(Object(concatAll.a)());
            }));
        }
        /**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */        function selectGCedRanges(currentTime, buffered, gcGap) {
            // start by trying to remove all ranges that do not contain the
            // current time and respect the gcGap
            // respect the gcGap? FIXME?
            for (var _getInnerAndOuterTime = Object(ranges.c)(buffered, currentTime), innerRange = _getInnerAndOuterTime.innerRange, outerRanges = _getInnerAndOuterTime.outerRanges, cleanedupRanges = [], i = 0; i < outerRanges.length; i++) {
                var outerRange = outerRanges[i];
                currentTime - gcGap < outerRange.end ? cleanedupRanges.push(outerRange) : currentTime + gcGap > outerRange.start && cleanedupRanges.push(outerRange);
            }
 // try to clean up some space in the current range
                        return innerRange && (log.a.debug("Buffer: GC removing part of inner range", cleanedupRanges), 
            currentTime - gcGap > innerRange.start && cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap
            }), currentTime + gcGap < innerRange.end && cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end
            })), cleanedupRanges;
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/push_data.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows any Buffer to push data to a QueuedSourceBuffer.
 */
        /**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */        function pushDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, dataInfos) {
            var append$ = queuedSourceBuffer.pushChunk(dataInfos);
            return append$.pipe(Object(catchError.a)(function(appendError) {
                if (appendError instanceof Error && "QuotaExceededError" === appendError.name) return Object(concat.a)(forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(ignoreElements.a)()), append$).pipe(Object(catchError.a)(function(forcedGCError) {
                    var reason = forcedGCError instanceof Error ? forcedGCError.toString() : "Could not clean the buffer";
 // (weird Typing either due to TypeScript or RxJS bug)
                                        throw new media_error.a("BUFFER_FULL_ERROR", reason);
                }));
                var reason = appendError instanceof Error ? appendError.toString() : "An unknown error happened when pushing content";
                throw new media_error.a("BUFFER_APPEND_ERROR", reason);
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffers/representation/representation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create RepresentationBuffers.
 *
 * A RepresentationBuffer downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */
        /**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can run on the same SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args
 * @returns {Observable}
 */        
        // CONCATENATED MODULE: ./src/core/buffers/representation/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var buffers_representation = function RepresentationBuffer(_ref) {
            var bufferGoal$ = _ref.bufferGoal$, clock$ = _ref.clock$, content = _ref.content, fastSwitchingStep$ = _ref.fastSwitchingStep$, queuedSourceBuffer = _ref.queuedSourceBuffer, segmentFetcher = _ref.segmentFetcher, terminate$ = _ref.terminate$, manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation, codec = representation.getMimeTypeString(), bufferType = adaptation.type, initSegment = representation.index.getInitSegment(), initSegmentObject = null == initSegment ? {
                chunkData: null,
                chunkInfos: null,
                chunkOffset: 0,
                appendWindow: [ void 0, void 0 ]
            } : null, downloadQueue = [], startDownloadingQueue$ = new ReplaySubject.a(1), reCheckNeededSegments$ = new Subject.a(), currentSegmentRequest = null, loadedSegmentPendingPush = new simple_set.a(), status$ = Object(combineLatest.a)([ clock$, bufferGoal$, terminate$.pipe(Object(take.a)(1), Object(mapTo.a)(!0), Object(startWith.a)(!1)), reCheckNeededSegments$.pipe(Object(startWith.a)(void 0)) ]).pipe(withLatestFrom(fastSwitchingStep$), Object(map.a)(function getCurrentStatus(_ref2) {
                var _ref2$ = _ref2[0], timing = _ref2$[0], bufferGoal = _ref2$[1], terminate = _ref2$[2], fastSwitchingStep = _ref2[1];
                queuedSourceBuffer.synchronizeInventory();
                var isFull, neededRange = getWantedRange(period, timing, bufferGoal), discontinuity = timing.stalled ? representation.index.checkDiscontinuity(timing.currentTime) : -1, shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end), segmentInventory = queuedSourceBuffer.getInventory(), neededSegments = getNeededSegments({
                    content: content,
                    fastSwitchingStep: fastSwitchingStep,
                    loadedSegmentPendingPush: loadedSegmentPendingPush,
                    neededRange: neededRange,
                    segmentInventory: segmentInventory
                }).map(function(segment) {
                    return {
                        priority: getSegmentPriority(segment, timing),
                        segment: segment
                    };
                });
                if (null != initSegment && null == initSegmentObject) {
                    // prepend initialization segment
                    var initSegmentPriority = getSegmentPriority(initSegment, timing);
                    neededSegments = [ {
                        segment: initSegment,
                        priority: initSegmentPriority
                    } ].concat(neededSegments);
                }
                // True if the current buffer is full and the one
                // from the next Period can be created
                if (0 < neededSegments.length || null == period.end) 
                // Either we still have segments to download or the current Period is
                // not yet ended: not full
                isFull = !1; else {
                    var lastPosition = representation.index.getLastPosition();
                    if (void 0 === lastPosition) 
                    // We do not know the end of this index.
                    // If we reached the end of the period, check that all segments are
                    // available.
                    isFull = neededRange.end >= period.end && representation.index.isFinished(); else if (null === lastPosition) 
                    // There is no available segment in the index currently. If the index
                    // tells us it has finished generating new segments, we're done.
                    isFull = representation.index.isFinished(); else {
                        // We have a declared end. Check that our range went until the last
                        // position available in the index. If that's the case and we're left
                        // with no segments after filtering them, it means we already have
                        // downloaded the last segments and have nothing left to do: full.
                        var endOfRange = null != period.end ? Math.min(period.end, lastPosition) : lastPosition;
                        isFull = neededRange.end >= endOfRange && representation.index.isFinished();
                    }
                }
                return {
                    discontinuity: discontinuity,
                    isFull: isFull,
                    terminate: terminate,
                    neededSegments: neededSegments,
                    shouldRefreshManifest: shouldRefreshManifest
                };
            }), Object(mergeMap.a)(function handleStatus(status) {
                var neededSegments = status.neededSegments, mostNeededSegment = neededSegments[0];
                if (status.terminate) {
                    if (downloadQueue = [], null == currentSegmentRequest) // complete the downloading queue
                    return log.a.debug("Buffer: no request, terminate.", bufferType), startDownloadingQueue$.complete(), 
                    Object(of.a)({
                        type: "terminated"
                    });
                    if (null == mostNeededSegment || currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) // complete the downloading queue
                    return log.a.debug("Buffer: cancel request and terminate.", bufferType), startDownloadingQueue$.next(), 
                    // interrupt the current request
                    startDownloadingQueue$.complete(), Object(of.a)({
                        type: "terminated"
                    });
                    if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                        var request$ = currentSegmentRequest.request$;
                        segmentFetcher.updatePriority(request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                    }
                    return log.a.debug("Buffer: terminate after request.", bufferType), empty.a;
                }
                var neededActions = [];
                if (1 < status.discontinuity) {
                    var nextTime = status.discontinuity + 1, gap = [ status.discontinuity, nextTime ];
                    neededActions.push(buffers_events_generators.discontinuityEncountered(gap, bufferType));
                }
                if (status.shouldRefreshManifest && neededActions.push(buffers_events_generators.needsManifestRefresh()), 
                null == mostNeededSegment) // (re-)start with an empty queue
                return currentSegmentRequest && log.a.debug("Buffer: interrupt segment request.", bufferType), 
                downloadQueue = [], startDownloadingQueue$.next(), Object(concat.a)(of.a.apply(void 0, neededActions), status.isFull ? Object(of.a)(buffers_events_generators.fullBuffer(bufferType)) : empty.a);
                if (currentSegmentRequest) if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) log.a.debug("Buffer: restart download queue.", bufferType), 
                downloadQueue = neededSegments, startDownloadingQueue$.next(); else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                    log.a.debug("Buffer: update request priority.", bufferType);
                    var _request$ = currentSegmentRequest.request$;
                    segmentFetcher.updatePriority(_request$, mostNeededSegment.priority), currentSegmentRequest.priority = mostNeededSegment.priority;
                } else log.a.debug("Buffer: update downloading queue", bufferType), // Update the previous queue to be all needed segments but the first one,
                // for which a request is already pending
                downloadQueue = neededSegments.slice().splice(1, neededSegments.length); else log.a.debug("Buffer: start downloading queue.", bufferType), 
                downloadQueue = neededSegments, startDownloadingQueue$.next();
                return Object(concat.a)(of.a.apply(void 0, neededActions), Object(of.a)(buffers_events_generators.activeBuffer(bufferType)));
            }), takeWhile(function(e) {
                return "terminated" !== e.type;
            })), bufferQueue$ = startDownloadingQueue$.pipe(Object(switchMap.a)(function() {
                return downloadQueue.length ? loadSegmentsFromQueue() : empty.a;
            }), Object(mergeMap.a)(
            /**
   * React to event from `loadSegmentsFromQueue`.
   * @param {Object} evt
   * @returns {Observable}
   */
            function onLoaderEvent(evt) {
                switch (evt.type) {
                  case "retry":
                    return Object(concat.a)(Object(of.a)({
                        type: "warning",
                        value: evt.value.error
                    }), Object(defer.a)(function() {
                        var retriedSegment = evt.value.segment, index = representation.index;
                        if (!1 === index.isSegmentStillAvailable(retriedSegment)) reCheckNeededSegments$.next(); else if (index.canBeOutOfSyncError(evt.value.error)) return Object(of.a)(buffers_events_generators.manifestMightBeOufOfSync());
                        return empty.a;
                    }));

                  case "parsed-segment":
                    var segment = evt.value.segment;
                    return segment.isInit && (initSegmentObject = evt.value.data), pushSegment(segment, evt.value.data);

                  case "end-of-segment":
                    var _segment = evt.value.segment;
                    return loadedSegmentPendingPush.add(_segment.id), queuedSourceBuffer.endOfSegment(object_assign_default()({
                        segment: _segment
                    }, content)).pipe(Object(ignoreElements.a)(), finalize(function() {
                        loadedSegmentPendingPush.remove(_segment.id);
                    }));
                }
            }
            /**
   * Push a given segment to a QueuedSourceBuffer.
   * @param {Object} segment
   * @param {Object} segmentObject
   * @returns {Observable}
   */));
            return Object(merge.a)(status$, bufferQueue$).pipe(Object(share.a)());
            /**
   * Request every Segment in the ``downloadQueue`` on subscription.
   * Emit the data of a segment when a request succeeded.
   *
   * Important side-effects:
   *   - Mutates `currentSegmentRequest` when doing and finishing a request.
   *   - Will emit from reCheckNeededSegments$ Subject when it's done.
   *
   * Might emit warnings when a request is retried.
   *
   * Throws when the request will not be retried (configuration or un-retryable
   * error).
   * @returns {Observable}
   */            function loadSegmentsFromQueue() {
                var requestNextSegment$ = Object(defer.a)(function() {
                    var currentNeededSegment = downloadQueue.shift();
                    if (null == currentNeededSegment) return next_tick_default()(function() {
                        reCheckNeededSegments$.next();
                    }), empty.a;
                    var segment = currentNeededSegment.segment, priority = currentNeededSegment.priority, context = {
                        manifest: manifest,
                        period: period,
                        adaptation: adaptation,
                        representation: representation,
                        segment: segment
                    }, request$ = segmentFetcher.createRequest(context, priority);
                    currentSegmentRequest = {
                        segment: segment,
                        priority: priority,
                        request$: request$
                    };
                    var response$ = request$.pipe(Object(mergeMap.a)(function(evt) {
                        if ("warning" === evt.type) return Object(of.a)({
                            type: "retry",
                            value: {
                                segment: segment,
                                error: evt.value
                            }
                        });
                        if ("chunk-complete" === evt.type) return currentSegmentRequest = null, Object(of.a)({
                            type: "end-of-segment",
                            value: {
                                segment: segment
                            }
                        });
                        var initInfos = initSegmentObject && initSegmentObject.chunkInfos || void 0;
                        return evt.parse(initInfos).pipe(Object(map.a)(function(data) {
                            return {
                                type: "parsed-segment",
                                value: {
                                    segment: segment,
                                    data: data
                                }
                            };
                        }));
                    }));
                    return Object(concat.a)(response$, requestNextSegment$);
                });
                return requestNextSegment$.pipe(finalize(function() {
                    currentSegmentRequest = null;
                }));
            }
            function pushSegment(segment, _ref3) {
                var chunkInfos = _ref3.chunkInfos, chunkData = _ref3.chunkData, chunkOffset = _ref3.chunkOffset, appendWindow = _ref3.appendWindow;
                return Object(defer.a)(function() {
                    if (null == chunkData) 
                    // no segmentData to add here (for example, a text init segment)
                    // just complete directly without appending anything
                    return empty.a;
                    var estimatedStart, estimatedDuration, data = {
                        initSegment: initSegmentObject && initSegmentObject.chunkData,
                        chunk: segment.isInit ? null : chunkData,
                        timestampOffset: chunkOffset,
                        appendWindow: appendWindow,
                        codec: codec
                    };
                    null !== chunkInfos && (estimatedStart = chunkInfos.time / chunkInfos.timescale, 
                    estimatedDuration = void 0 !== chunkInfos.duration ? chunkInfos.duration / chunkInfos.timescale : void 0);
                    var inventoryInfos = object_assign_default()({
                        segment: segment,
                        estimatedStart: estimatedStart,
                        estimatedDuration: estimatedDuration
                    }, content);
                    return pushDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, {
                        data: data,
                        inventoryInfos: inventoryInfos
                    }).pipe(Object(map.a)(function() {
                        var buffered = queuedSourceBuffer.getBufferedRanges();
                        return buffers_events_generators.addedSegment(content, segment, buffered, chunkData);
                    }));
                });
            }
        };
        // CONCATENATED MODULE: ./src/core/buffers/adaptation/adaptation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file allows to create AdaptationBuffers.
 *
 * An AdaptationBuffer downloads and push segment for a single Adaptation (e.g.
 * a single audio or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates the various RepresentationBuffer, which will
 * download and push segments for a single Representation.
 */
        /**
 * Create new Buffer Observable linked to the given Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * It will emit various events to report its status to the caller.
 *
 * @param {Object} args
 * @returns {Observable}
 */        
        // CONCATENATED MODULE: ./src/core/buffers/adaptation/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var buffers_adaptation = function AdaptationBuffer(_ref) {
            var abrManager = _ref.abrManager, clock$ = _ref.clock$, content = _ref.content, options = _ref.options, queuedSourceBuffer = _ref.queuedSourceBuffer, segmentPipelinesManager = _ref.segmentPipelinesManager, wantedBufferAhead$ = _ref.wantedBufferAhead$, directManualBitrateSwitching = "direct" === options.manualBitrateSwitchingMode, manifest = content.manifest, period = content.period, adaptation = content.adaptation, representations = adaptation.representations, bufferGoalRatioMap = {}, killCurrentBuffer$ = new Subject.a(), terminateCurrentBuffer$ = new Subject.a(), bufferEvents$ = new Subject.a(), requestsEvents$ = new Subject.a(), abrEvents$ = Object(merge.a)(bufferEvents$, requestsEvents$), abr$ = abrManager.get$(adaptation.type, representations, clock$, abrEvents$).pipe(Object(subscribeOn.a)(asap.a), Object(share.a)()), segmentFetcher = segmentPipelinesManager.createPipeline(adaptation.type, requestsEvents$), fastSwitchingStep$ = abr$.pipe(Object(map.a)(function(_ref2) {
                return _ref2.knownStableBitrate;
            }), // always emit the last on subscribe
            Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), Object(startWith.a)(void 0), Object(distinctUntilChanged.a)()), bitrateEstimates$ = abr$.pipe(Object(filter.a)(function(_ref3) {
                return null != _ref3.bitrate;
            }), Object(distinctUntilChanged.a)(function(old, current) {
                return old.bitrate === current.bitrate;
            }), Object(map.a)(function(_ref4) {
                var bitrate = _ref4.bitrate;
                return log.a.debug("Buffer: new " + adaptation.type + " bitrate estimation", bitrate), 
                buffers_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
            })), newRepresentation$ = abr$.pipe(Object(distinctUntilChanged.a)(function(a, b) {
                return a.manual === b.manual && a.representation.id === b.representation.id;
            })), adaptationBuffer$ = Object(merge.a)(newRepresentation$.pipe(concatMapLatest(function(estimate, i) {
                var representation = estimate.representation;
 // A manual bitrate switch might need an immediate feedback.
                // To do that properly, we need to reload the MediaSource
                                if (directManualBitrateSwitching && estimate.manual && 0 !== i) return clock$.pipe(Object(take.a)(1), Object(map.a)(function(t) {
                    return buffers_events_generators.needsMediaSourceReload(t);
                }));
                var representationChange$ = Object(of.a)(buffers_events_generators.representationChange(adaptation.type, period, representation)), representationBuffer$ = createRepresentationBuffer(representation).pipe(Object(takeUntil.a)(killCurrentBuffer$));
                return Object(concat.a)(representationChange$, representationBuffer$).pipe(Object(tap.a)(function(evt) {
                    if ("representationChange" === evt.type || "added-segment" === evt.type) return bufferEvents$.next(evt);
                }));
            })), // NOTE: This operator was put in a merge on purpose. It's a "clever"
            // hack to allow it to be called just *AFTER* the concatMapLatest one.
            newRepresentation$.pipe(Object(map.a)(function(estimation, i) {
                0 !== i && (estimation.urgent ? (log.a.info("Buffer: urgent Representation switch", adaptation.type), 
                // Kill current Buffer immediately. The one just chosen take its place.
                killCurrentBuffer$.next()) : (log.a.info("Buffer: slow Representation switch", adaptation.type), 
                // terminate current Buffer. The last chosen Representation at the time
                // it will be finished will take its place.
                terminateCurrentBuffer$.next()));
            }), Object(ignoreElements.a)()));
            return Object(merge.a)(adaptationBuffer$, bitrateEstimates$);
            /**
   * Create and returns a new RepresentationBuffer Observable, linked to the
   * given Representation.
   * @param {Representation} representation
   * @returns {Observable}
   */            function createRepresentationBuffer(representation) {
                return Object(defer.a)(function() {
                    var oldBufferGoalRatio = bufferGoalRatioMap[representation.id], bufferGoalRatio = null != oldBufferGoalRatio ? oldBufferGoalRatio : 1;
                    bufferGoalRatioMap[representation.id] = bufferGoalRatio;
                    var bufferGoal$ = wantedBufferAhead$.pipe(Object(map.a)(function(wba) {
                        return wba * bufferGoalRatio;
                    }));
                    return log.a.info("Buffer: changing representation", adaptation.type, representation), 
                    buffers_representation({
                        clock$: clock$,
                        content: {
                            representation: representation,
                            adaptation: adaptation,
                            period: period,
                            manifest: manifest
                        },
                        queuedSourceBuffer: queuedSourceBuffer,
                        segmentFetcher: segmentFetcher,
                        terminate$: terminateCurrentBuffer$,
                        bufferGoal$: bufferGoal$,
                        fastSwitchingStep$: fastSwitchingStep$
                    }).pipe(Object(catchError.a)(function(err) {
                        var formattedError = formatError(err, {
                            defaultCode: "NONE",
                            defaultReason: "Unknown `RepresentationBuffer` error"
                        });
                        if ("BUFFER_FULL_ERROR" !== formattedError.code) throw formattedError;
                        var wantedBufferAhead = wantedBufferAhead$.getValue(), lastBufferGoalRatio = bufferGoalRatio;
                        if (lastBufferGoalRatio <= .25 || wantedBufferAhead * lastBufferGoalRatio <= 2) throw formattedError;
                        return bufferGoalRatioMap[representation.id] = lastBufferGoalRatio - .25, createRepresentationBuffer(representation);
                    }));
                });
            }
        };
        // CONCATENATED MODULE: ./src/core/buffers/period/create_empty_adaptation_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create empty AdaptationBuffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */        function creatEmptyAdaptationBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
            var period = content.period;
            return Object(combineLatest.a)([ bufferClock$, wantedBufferAhead$ ]).pipe(Object(filter.a)(function(_ref) {
                var clockTick = _ref[0], wantedBufferAhead = _ref[1];
                return null != period.end && clockTick.currentTime + wantedBufferAhead >= period.end;
            }), Object(map.a)(function() {
                return log.a.debug('Buffer: full "empty" AdaptationBuffer', bufferType), {
                    type: "full-buffer",
                    value: {
                        bufferType: bufferType
                    }
                };
            }));
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/get_adaptation_switch_strategy.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var ADAPTATION_SWITCH_BUFFER_PADDINGS = config.a.ADAPTATION_SWITCH_BUFFER_PADDINGS;
        /**
 * Find out what to do when switching adaptation, based on the current
 * situation.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @param {Object} clockTick
 * @returns {Object}
 */        function getAdaptationSwitchStrategy(queuedSourceBuffer, period, adaptation, clockTick) {
            var buffered = queuedSourceBuffer.getBufferedRanges();
            if (0 === buffered.length) return {
                type: "continue",
                value: void 0
            };
            var bufferedRanges = Object(ranges.a)(buffered), start = period.start, end = period.end || Infinity, intersection = Object(ranges.k)(bufferedRanges, [ {
                start: start,
                end: end
            } ]);
            if (0 === intersection.length) return {
                type: "continue",
                value: void 0
            };
 // remove from that intersection what we know to be the right Adaptation
                        var adaptationInBuffer = getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation), currentTime = clockTick.currentTime;
            if ("video" === adaptation.type && 1 < clockTick.readyState && Object(ranges.j)({
                start: start,
                end: end
            }, currentTime) && adaptationInBuffer.every(function(range) {
                return !Object(ranges.j)(range, currentTime);
            })) return {
                type: "needs-reload",
                value: void 0
            };
            var unwantedData = Object(ranges.b)(intersection, adaptationInBuffer), bufferType = adaptation.type, paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before || 0, paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after || 0, toRemove = Object(ranges.b)(unwantedData, [ {
                start: Math.max(currentTime - paddingBefore, start),
                end: Math.min(currentTime + paddingAfter, end)
            } ]);
            return 0 < toRemove.length ? {
                type: "clean-buffer",
                value: toRemove
            } : {
                type: "continue",
                value: void 0
            };
        }
        /**
 * Returns buffered ranges of what we know correspond to the given `adaptation`
 * in the SourceBuffer.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @returns {Array.<Object>}
 */        function getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation) {
            return queuedSourceBuffer.synchronizeInventory(), queuedSourceBuffer.getInventory().reduce(function(acc, chunk) {
                if (chunk.infos.period.id !== period.id || chunk.infos.adaptation.id !== adaptation.id) return acc;
                var bufferedStart = chunk.bufferedStart, bufferedEnd = chunk.bufferedEnd;
                return void 0 === bufferedStart || void 0 === bufferedEnd || acc.push({
                    start: bufferedStart,
                    end: bufferedEnd
                }), acc;
            }, []);
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/period_buffer.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create single PeriodBuffer Observable:
 *   - Lazily create (or reuse) a SourceBuffer for the given type.
 *   - Create a Buffer linked to an Adaptation each time it changes, to
 *     download and append the corresponding Segments in the SourceBuffer.
 *   - Announce when the Buffer is full or is awaiting new Segments through
 *     events
 * @param {Object} args
 * @returns {Observable}
 */        
        /**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */
        function createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options) {
            var currentQSourceBuffer = sourceBuffersStore.get(bufferType);
            if (null != currentQSourceBuffer) return log.a.info("Buffer: Reusing a previous SourceBuffer for the type", bufferType), 
            currentQSourceBuffer;
            var codec = getFirstDeclaredMimeType(adaptation), sbOptions = "text" === bufferType ? options.textTrackOptions : void 0;
            return sourceBuffersStore.createSourceBuffer(bufferType, codec, sbOptions);
        }
        /**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */        function getFirstDeclaredMimeType(adaptation) {
            var representations = adaptation.representations;
            return representations[0] && representations[0].getMimeTypeString() || "";
        }
        // CONCATENATED MODULE: ./src/core/buffers/period/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        var buffers_period = function PeriodBuffer(_ref) {
            var abrManager = _ref.abrManager, bufferType = _ref.bufferType, clock$ = _ref.clock$, content = _ref.content, garbageCollectors = _ref.garbageCollectors, segmentPipelinesManager = _ref.segmentPipelinesManager, sourceBuffersStore = _ref.sourceBuffersStore, options = _ref.options, wantedBufferAhead$ = _ref.wantedBufferAhead$, period = content.period, adaptation$ = new ReplaySubject.a(1);
            return adaptation$.pipe(Object(switchMap.a)(function(adaptation) {
                if (null == adaptation) {
                    log.a.info("Buffer: Set no " + bufferType + " Adaptation", period);
                    var cleanBuffer$, previousQSourceBuffer = sourceBuffersStore.get(bufferType);
                    return cleanBuffer$ = null != previousQSourceBuffer ? (log.a.info("Buffer: Clearing previous " + bufferType + " SourceBuffer"), 
                    previousQSourceBuffer.removeBuffer(period.start, period.end || Infinity)) : Object(of.a)(null), 
                    Object(concat.a)(cleanBuffer$.pipe(Object(mapTo.a)(buffers_events_generators.adaptationChange(bufferType, null, period))), creatEmptyAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                        period: period
                    }));
                }
                log.a.info("Buffer: Updating " + bufferType + " adaptation", adaptation, period);
                var newBuffer$ = clock$.pipe(Object(take.a)(1), Object(mergeMap.a)(function(tick) {
                    var qSourceBuffer = createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options), strategy = getAdaptationSwitchStrategy(qSourceBuffer, period, adaptation, tick);
                    if ("needs-reload" === strategy.type) return Object(of.a)(buffers_events_generators.needsMediaSourceReload(tick));
                    var cleanBuffer$ = "clean-buffer" === strategy.type ? concat.a.apply(void 0, strategy.value.map(function(_ref2) {
                        var start = _ref2.start, end = _ref2.end;
                        return qSourceBuffer.removeBuffer(start, end);
                    })).pipe(Object(ignoreElements.a)()) : empty.a, bufferGarbageCollector$ = garbageCollectors.get(qSourceBuffer), adaptationBuffer$ = createAdaptationBuffer(adaptation, qSourceBuffer);
                    return Object(concat.a)(cleanBuffer$, Object(merge.a)(adaptationBuffer$, bufferGarbageCollector$));
                }));
                return Object(concat.a)(Object(of.a)(buffers_events_generators.adaptationChange(bufferType, adaptation, period)), newBuffer$);
            }), Object(startWith.a)(buffers_events_generators.periodBufferReady(bufferType, period, adaptation$)));
            /**
   * @param {Object} adaptation
   * @param {Object} qSourceBuffer
   * @returns {Observable}
   */            function createAdaptationBuffer(adaptation, qSourceBuffer) {
                var manifest = content.manifest, adaptationBufferClock$ = clock$.pipe(Object(map.a)(function(tick) {
                    var buffered = qSourceBuffer.getBufferedRanges();
                    return object_assign_default()({}, tick, {
                        bufferGap: Object(ranges.d)(buffered, tick.currentTime)
                    });
                }));
                return buffers_adaptation({
                    abrManager: abrManager,
                    clock$: adaptationBufferClock$,
                    content: {
                        manifest: manifest,
                        period: period,
                        adaptation: adaptation
                    },
                    options: options,
                    queuedSourceBuffer: qSourceBuffer,
                    segmentPipelinesManager: segmentPipelinesManager,
                    wantedBufferAhead$: wantedBufferAhead$
                }).pipe(Object(catchError.a)(function(error) {
                    // non native buffer should not impact the stability of the
                    // player. ie: if a text buffer sends an error, we want to
                    // continue playing without any subtitles
                    if (source_buffers.isNative(bufferType)) throw log.a.error("Buffer: Native " + bufferType + " buffer crashed. Stopping playback.", error), 
                    error;
                    log.a.error("Buffer: Custom " + bufferType + " buffer crashed. Aborting it.", error), 
                    sourceBuffersStore.disposeSourceBuffer(bufferType);
                    var formattedError = formatError(error, {
                        defaultCode: "NONE",
                        defaultReason: "Unknown `AdaptationBuffer` error"
                    });
                    return Object(concat.a)(Object(of.a)(buffers_events_generators.warning(formattedError)), creatEmptyAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
                        period: period
                    }));
                }));
            }
        }, MAXIMUM_MAX_BUFFER_AHEAD = config.a.MAXIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_BEHIND = config.a.MAXIMUM_MAX_BUFFER_BEHIND;
        // CONCATENATED MODULE: ./src/core/buffers/buffer_orchestrator.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./src/core/buffers/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var core_buffers = 
        /**
 * Create and manage the various Buffer Observables needed for the content to
 * play:
 *
 *   - Create or dispose SourceBuffers depending on the chosen Adaptations.
 *
 *   - Push the right segments to those SourceBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit various events to notify of its health and issues
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 * @param {Object} content
 * @param {Observable} clock$ - Emit position information
 * @param {Object} abrManager - Emit bitrate estimation and best Representation
 * to play.
 * @param {Object} sourceBuffersStore - Will be used to lazily create
 * SourceBuffer instances associated with the current content.
 * @param {Object} segmentPipelinesManager - Download segments
 * @param {Object} options
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 */
        function BufferOrchestrator(content, clock$, abrManager, sourceBuffersStore, segmentPipelinesManager, options) {
            var manifest = content.manifest, initialPeriod = content.initialPeriod, maxBufferAhead$ = options.maxBufferAhead$, maxBufferBehind$ = options.maxBufferBehind$, wantedBufferAhead$ = options.wantedBufferAhead$, garbageCollectors = new WeakMapMemory(function(qSourceBuffer) {
                var bufferType = qSourceBuffer.bufferType, defaultMaxBehind = null != MAXIMUM_MAX_BUFFER_BEHIND[bufferType] ? MAXIMUM_MAX_BUFFER_BEHIND[bufferType] : Infinity, defaultMaxAhead = null != MAXIMUM_MAX_BUFFER_AHEAD[bufferType] ? MAXIMUM_MAX_BUFFER_AHEAD[bufferType] : Infinity;
                return BufferGarbageCollector({
                    queuedSourceBuffer: qSourceBuffer,
                    clock$: clock$.pipe(Object(map.a)(function(tick) {
                        return tick.currentTime;
                    })),
                    maxBufferBehind$: maxBufferBehind$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxBehind);
                    })),
                    maxBufferAhead$: maxBufferAhead$.pipe(Object(map.a)(function(val) {
                        return Math.min(val, defaultMaxAhead);
                    }))
                });
            }), outOfManifest$ = clock$.pipe(Object(mergeMap.a)(function(_ref) {
                var currentTime = _ref.currentTime, position = _ref.wantedTimeOffset + currentTime;
                if (position < manifest.getMinimumPosition()) {
                    var warning = new media_error.a("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the earliest time announced in the Manifest.");
                    return Object(of.a)(buffers_events_generators.warning(warning));
                }
                if (position > manifest.getMaximumPosition()) {
                    var _warning = new media_error.a("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest time announced in the Manifest.");
                    return Object(of.a)(buffers_events_generators.warning(_warning));
                }
                return empty.a;
            })), buffersArray = getBufferTypes().map(function(bufferType) {
                return manageEveryBuffers(bufferType, initialPeriod).pipe(Object(subscribeOn.a)(asap.a), Object(share.a)());
            }), activePeriodChanged$ = ActivePeriodEmitter(buffersArray).pipe(Object(filter.a)(function(period) {
                return !!period;
            }), Object(map.a)(function(period) {
                return log.a.info("Buffer: New active period", period), buffers_events_generators.activePeriodChanged(period);
            })), endOfStream$ = areBuffersComplete.apply(void 0, buffersArray).pipe(Object(map.a)(function(areComplete) {
                return areComplete ? buffers_events_generators.endOfStream() : buffers_events_generators.resumeStream();
            }));
            return merge.a.apply(void 0, buffersArray.concat([ activePeriodChanged$, endOfStream$, outOfManifest$ ]));
            /**
   * Manage creation and removal of Buffers for every Periods.
   *
   * Works by creating consecutive buffers through the
   * manageConsecutivePeriodBuffers function, and restarting it when the clock
   * goes out of the bounds of these buffers.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @returns {Observable}
   */            function manageEveryBuffers(bufferType, basePeriod) {
                // Each Period for which there is currently a Buffer, chronologically
                var periodList = new sorted_list_SortedList(function(a, b) {
                    return a.start - b.start;
                }), destroyBuffers$ = new Subject.a(), hasLoadedABuffer = !1;
                // true after the first PeriodBuffer is ready
                /**
     * @param {Object} period
     * @returns {Observable}
     */
                function launchConsecutiveBuffersForPeriod(period) {
                    return manageConsecutivePeriodBuffers(bufferType, period, destroyBuffers$).pipe(Object(tap.a)(function(message) {
                        "periodBufferReady" === message.type ? (hasLoadedABuffer = hasLoadedABuffer || !0, 
                        periodList.add(message.value.period)) : "periodBufferCleared" === message.type && periodList.removeElement(message.value.period);
                    }), Object(share.a)());
                }
                /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */                function isOutOfPeriodList(time) {
                    var head = periodList.head(), last = periodList.last();
                    return null == head || null == last || (head.start > time || (last.end || Infinity) < time);
                }
 // Restart the current buffer when the wanted time is in another period
                // than the ones already considered
                                var restartBuffersWhenOutOfBounds$ = clock$.pipe(Object(filter.a)(function(_ref2) {
                    var currentTime = _ref2.currentTime, wantedTimeOffset = _ref2.wantedTimeOffset;
                    return hasLoadedABuffer && !!manifest.getPeriodForTime(wantedTimeOffset + currentTime) && isOutOfPeriodList(wantedTimeOffset + currentTime);
                }), Object(tap.a)(function(_ref3) {
                    var currentTime = _ref3.currentTime, wantedTimeOffset = _ref3.wantedTimeOffset;
                    log.a.info("Buffer: Current position out of the bounds of the active periods,re-creating buffers.", bufferType, currentTime + wantedTimeOffset), 
                    hasLoadedABuffer = !1, destroyBuffers$.next();
                }), Object(mergeMap.a)(function(_ref4) {
                    var currentTime = _ref4.currentTime, wantedTimeOffset = _ref4.wantedTimeOffset, newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);
                    if (null == newInitialPeriod) throw new media_error.a("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
                    return launchConsecutiveBuffersForPeriod(newInitialPeriod);
                }));
                return Object(merge.a)(launchConsecutiveBuffersForPeriod(basePeriod), restartBuffersWhenOutOfBounds$);
            }
            /**
   * Create lazily consecutive PeriodBuffers:
   *
   * It first creates the PeriodBuffer for `basePeriod` and - once it becomes
   * full - automatically creates the next chronological one.
   * This process repeats until the PeriodBuffer linked to the last Period is
   * full.
   *
   * If an "old" PeriodBuffer becomes active again, it destroys all PeriodBuffer
   * coming after it (from the last chronological one to the first).
   *
   * To clean-up PeriodBuffers, each one of them are also automatically
   * destroyed once the clock anounce a time superior or equal to the end of
   * the concerned Period.
   *
   * A "periodBufferReady" event is sent each times a new PeriodBuffer is
   * created. The first one (for `basePeriod`) should be sent synchronously on
   * subscription.
   *
   * A "periodBufferCleared" event is sent each times a PeriodBuffer is
   * destroyed.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Observable} destroy$ - Emit when/if all created Buffers from this
   * point should be destroyed.
   * @returns {Observable}
   */            function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
                log.a.info("Buffer: Creating new Buffer for", bufferType, basePeriod);
                // Emits the Period of the next Period Buffer when it can be created.
                var createNextPeriodBuffer$ = new Subject.a(), destroyNextBuffers$ = new Subject.a(), endOfCurrentBuffer$ = clock$.pipe(Object(filter.a)(function(_ref5) {
                    var currentTime = _ref5.currentTime, wantedTimeOffset = _ref5.wantedTimeOffset;
                    return !!basePeriod.end && currentTime + wantedTimeOffset >= basePeriod.end;
                })), nextPeriodBuffer$ = createNextPeriodBuffer$.pipe(exhaustMap(function(nextPeriod) {
                    return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
                })), destroyAll$ = destroy$.pipe(Object(take.a)(1), Object(tap.a)(function() {
                    // first complete createNextBuffer$ to allow completion of the
                    // nextPeriodBuffer$ observable once every further Buffers have been
                    // cleared.
                    createNextPeriodBuffer$.complete(), // emit destruction signal to the next Buffer first
                    destroyNextBuffers$.next(), destroyNextBuffers$.complete();
                }), Object(share.a)()), killCurrentBuffer$ = Object(merge.a)(endOfCurrentBuffer$, destroyAll$), periodBuffer$ = buffers_period({
                    abrManager: abrManager,
                    bufferType: bufferType,
                    clock$: clock$,
                    content: {
                        manifest: manifest,
                        period: basePeriod
                    },
                    garbageCollectors: garbageCollectors,
                    segmentPipelinesManager: segmentPipelinesManager,
                    sourceBuffersStore: sourceBuffersStore,
                    options: options,
                    wantedBufferAhead$: wantedBufferAhead$
                }).pipe(Object(mergeMap.a)(function(evt) {
                    var type = evt.type;
                    if ("full-buffer" === type) {
                        var nextPeriod = manifest.getPeriodAfter(basePeriod);
                        if (null == nextPeriod) return Object(of.a)(buffers_events_generators.bufferComplete(bufferType));
                        // current buffer is full, create the next one if not
                        createNextPeriodBuffer$.next(nextPeriod);
                    } else "active-buffer" === type && 
                    // current buffer is active, destroy next buffer if created
                    destroyNextBuffers$.next();
                    return Object(of.a)(evt);
                }), Object(share.a)()), currentBuffer$ = Object(concat.a)(periodBuffer$.pipe(Object(takeUntil.a)(killCurrentBuffer$)), Object(of.a)(buffers_events_generators.periodBufferCleared(bufferType, basePeriod)).pipe(Object(tap.a)(function() {
                    log.a.info("Buffer: Destroying buffer for", bufferType, basePeriod);
                })));
 // Emits when the Buffers for the next Periods should be destroyed, if
                // created.
                                return Object(merge.a)(currentBuffer$, nextPeriodBuffer$, destroyAll$.pipe(Object(ignoreElements.a)()));
            }
        };
        // CONCATENATED MODULE: ./src/core/init/create_buffer_clock.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Create clock Observable for the Buffers part of the code.
 * @param {Observable} initClock$
 * @param {Object} bufferClockArgument
 * @returns {Observable}
 */        function createBufferClock(initClock$, _ref) {
            var autoPlay = _ref.autoPlay, initialPlay$ = _ref.initialPlay$, initialSeek$ = _ref.initialSeek$, manifest = _ref.manifest, speed$ = _ref.speed$, startTime = _ref.startTime, initialPlayPerformed = !1, initialSeekPerformed = !1, updateIsPaused$ = initialPlay$.pipe(Object(tap.a)(function() {
                initialPlayPerformed = !0;
            }), Object(ignoreElements.a)()), updateTimeOffset$ = initialSeek$.pipe(Object(tap.a)(function() {
                initialSeekPerformed = !0;
            }), Object(ignoreElements.a)()), clock$ = Object(combineLatest.a)([ initClock$, speed$ ]).pipe(Object(map.a)(function(_ref2) {
                var tick = _ref2[0], speed = _ref2[1], isLive = manifest.isLive;
                return {
                    currentTime: tick.currentTime,
                    duration: tick.duration,
                    isPaused: initialPlayPerformed ? tick.paused : !autoPlay,
                    isLive: isLive,
                    liveGap: isLive ? manifest.getMaximumPosition() - tick.currentTime : Infinity,
                    readyState: tick.readyState,
                    speed: speed,
                    stalled: tick.stalled,
                    // wantedTimeOffset is an offset to add to the timing's current time to have
                    // the "real" wanted position.
                    // For now, this is seen when the media element has not yet seeked to its
                    // initial position, the currentTime will most probably be 0 where the
                    // effective starting position will be _startTime_.
                    // Thus we initially set a wantedTimeOffset equal to startTime.
                    wantedTimeOffset: initialSeekPerformed ? 0 : startTime - tick.currentTime
                };
            }));
            return Object(merge.a)(updateIsPaused$, updateTimeOffset$, clock$);
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
                var isArray = __webpack_require__(47), fromArray = __webpack_require__(62);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js
                // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function race() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            if (1 === observables.length) {
                if (!Object(isArray.a)(observables[0])) return observables[0];
                observables = observables[0];
            }
            return Object(fromArray.a)(observables, void 0).lift(new RaceOperator());
        }
        var RaceOperator = /* */ function() {
            function RaceOperator() {}
            return RaceOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new race_RaceSubscriber(subscriber));
            }, RaceOperator;
        }(), race_RaceSubscriber = /* */ function(_super) {
            function RaceSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.hasFirst = !1, _this.observables = [], _this.subscriptions = [], _this;
            }
            return tslib_es6.a(RaceSubscriber, _super), RaceSubscriber.prototype._next = function(observable) {
                this.observables.push(observable);
            }, RaceSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (var i = 0; i < len && !this.hasFirst; i++) {
                        var observable = observables[i], subscription = Object(subscribeToResult.a)(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }, RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (var i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }, RaceSubscriber;
        }(OuterSubscriber.a), ArgumentOutOfRangeError = __webpack_require__(111);
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function takeLast(count) {
            return function takeLastOperatorFunction(source) {
                return 0 === count ? Object(empty.b)() : source.lift(new takeLast_TakeLastOperator(count));
            };
        }
        var takeLast_TakeLastOperator = /* */ function() {
            function TakeLastOperator(total) {
                if (this.total = total, this.total < 0) throw new ArgumentOutOfRangeError.a();
            }
            return TakeLastOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
            }, TakeLastOperator;
        }(), takeLast_TakeLastSubscriber = /* */ function(_super) {
            function TakeLastSubscriber(destination, total) {
                var _this = _super.call(this, destination) || this;
                return _this.total = total, _this.ring = new Array(), _this.count = 0, _this;
            }
            return tslib_es6.a(TakeLastSubscriber, _super), TakeLastSubscriber.prototype._next = function(value) {
                var ring = this.ring, total = this.total, count = this.count++;
                ring.length < total ? ring.push(value) : ring[count % total] = value;
            }, TakeLastSubscriber.prototype._complete = function() {
                var destination = this.destination, count = this.count;
                if (0 < count) for (var total = this.count >= this.total ? this.total : this.count, ring = this.ring, i = 0; i < total; i++) {
                    var idx = count++ % total;
                    destination.next(ring[idx]);
                }
                destination.complete();
            }, TakeLastSubscriber;
        }(Subscriber.a), onRemoveSourceBuffers$ = compat.a.onRemoveSourceBuffers$, end_of_stream_onSourceOpen$ = compat.a.onSourceOpen$, onUpdate$ = compat.a.onUpdate$;
        /**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
        function getUpdatingSourceBuffers(sourceBuffers) {
            for (var updatingSourceBuffers = [], i = 0; i < sourceBuffers.length; i++) {
                var SourceBuffer = sourceBuffers[i];
                SourceBuffer.updating && updatingSourceBuffers.push(SourceBuffer);
            }
            return updatingSourceBuffers;
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function triggerEndOfStream(mediaSource) {
            return Object(defer.a)(function() {
                if (log.a.debug("Init: Trying to call endOfStream"), "open" !== mediaSource.readyState) return log.a.debug("Init: MediaSource not open, cancel endOfStream"), 
                Object(of.a)(null);
                var sourceBuffers = mediaSource.sourceBuffers, updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
                if (!updatingSourceBuffers.length) return log.a.info("Init: Triggering end of stream"), 
                mediaSource.endOfStream(), Object(of.a)(null);
                log.a.debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
                var updatedSourceBuffers$ = updatingSourceBuffers.map(function(sourceBuffer) {
                    return onUpdate$(sourceBuffer).pipe(Object(take.a)(1));
                });
                return race(merge.a.apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), onRemoveSourceBuffers$(sourceBuffers).pipe(Object(take.a)(1))).pipe(Object(mergeMap.a)(function() {
                    return triggerEndOfStream(mediaSource);
                }));
            });
        }
        /**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */        function maintainEndOfStream(mediaSource) {
            return end_of_stream_onSourceOpen$(mediaSource).pipe(Object(startWith.a)(null), Object(switchMap.a)(function() {
                return triggerEndOfStream(mediaSource);
            }));
        }
        // EXTERNAL MODULE: ./src/compat/is_playback_stuck.ts
                var is_playback_stuck = __webpack_require__(155), BUFFER_DISCONTINUITY_THRESHOLD = config.a.BUFFER_DISCONTINUITY_THRESHOLD;
        // CONCATENATED MODULE: ./src/core/init/get_discontinuities.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Perform various checks about discontinuity during playback.
 * @param {Observable} clock$
 * @param {Object} manifest
 * @returns {Observable}
 */
        function getDiscontinuities(clock$, manifest) {
            return clock$.pipe(Object(filter.a)(function(_ref) {
                return !!_ref.stalled;
            }), Object(map.a)(function(tick) {
                var buffered = tick.buffered, currentTime = tick.currentTime, currentRange = tick.currentRange, state = tick.state, stalled = tick.stalled, nextBufferRangeGap = Object(ranges.e)(buffered, currentTime);
                // 1: Is it a browser bug? -> force seek at the same current time
                if (Object(is_playback_stuck.a)(currentTime, currentRange, state, !!stalled)) return log.a.warn("Init: After freeze seek", currentTime, currentRange), 
                [ currentTime, currentTime ]; // 2. Is it a short discontinuity in buffer ? -> Seek at the beginning of the
                //                                               next range
                //
                // Discontinuity check in case we are close a buffered range but still
                // calculate a stalled state. This is useful for some
                // implementation that might drop an injected segment, or in
                // case of small discontinuity in the content.
                // 3. Is it a discontinuity between periods ? -> Seek at the beginning of the
                //                                               next period
                                if (nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) return [ currentTime, currentTime + nextBufferRangeGap + 1 / 60 ];
                var currentPeriod = manifest.getPeriodForTime(currentTime);
                if (currentPeriod) {
                    var nextPeriod = manifest.getPeriodAfter(currentPeriod);
                    if (null != currentPeriod && null != currentPeriod.end && null != nextPeriod && currentTime > currentPeriod.end - 1 && currentTime <= nextPeriod.start && nextPeriod.start - currentPeriod.end == 0) return [ currentPeriod.end, nextPeriod.start ];
                }
            }), Object(filter.a)(function(x) {
                return !!x;
            }), Object(distinctUntilChanged.a)());
        }
        // EXTERNAL MODULE: ./src/core/init/get_stalled_events.ts
                var get_stalled_events = __webpack_require__(116);
        // CONCATENATED MODULE: ./src/core/init/handle_discontinuity.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Handle discontinuity against current time and stall status
 * @param {number} seekTo
 * @param {boolean} isStalled
 */        function handleDiscontinuity(seekTo, mediaElement) {
            seekTo < mediaElement.currentTime || (log.a.warn("Init: discontinuity seek", mediaElement.currentTime, seekTo), 
            mediaElement.currentTime = seekTo);
        }
        // EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts
                var initial_seek_and_play = __webpack_require__(109), update_playback_rate = __webpack_require__(115);
        // EXTERNAL MODULE: ./src/core/init/update_playback_rate.ts
                // CONCATENATED MODULE: ./src/core/init/load_on_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} args
 * @returns {Observable}
 */
        function createMediaSourceLoader(_ref) {
            var mediaElement = _ref.mediaElement, manifest = _ref.manifest, clock$ = _ref.clock$, speed$ = _ref.speed$, bufferOptions = _ref.bufferOptions, abrManager = _ref.abrManager, segmentPipelinesManager = _ref.segmentPipelinesManager;
            /**
   * Load the content on the given MediaSource.
   * @param {MediaSource} mediaSource
   * @param {number} initialTime
   * @param {boolean} autoPlay
   */            return function loadContentOnMediaSource(mediaSource, initialTime, autoPlay) {
                // TODO Update the duration if it evolves?
                var duration = manifest.getDuration();
                setDurationToMediaSource(mediaSource, null == duration ? Infinity : duration);
                var initialPeriod = manifest.getPeriodForTime(initialTime);
                if (null == initialPeriod) throw new media_error.a("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.");
 // Creates SourceBuffersStore allowing to create and keep track of a
                // single SourceBuffer per type.
                                var sourceBuffersStore = new source_buffers(mediaElement, mediaSource);
 // Initialize all native source buffers from the first period at the same
                // time.
                // We cannot lazily create native sourcebuffers since the spec does not
                // allow adding them during playback.
                //
                // From https://w3c.github.io/media-source/#methods
                //    For example, a user agent may throw a QuotaExceededError
                //    exception if the media element has reached the HAVE_METADATA
                //    readyState. This can occur if the user agent's media engine
                //    does not support adding more tracks during playback.
                                createNativeSourceBuffersForPeriod(sourceBuffersStore, initialPeriod);
                var _seekAndLoadOnMediaEv = Object(initial_seek_and_play.a)(clock$, mediaElement, initialTime, autoPlay), seek$ = _seekAndLoadOnMediaEv.seek$, load$ = _seekAndLoadOnMediaEv.load$, initialPlay$ = load$.pipe(Object(filter.a)(function(evt) {
                    return "not-loaded-metadata" !== evt;
                })), bufferClock$ = createBufferClock(clock$, {
                    autoPlay: autoPlay,
                    initialPlay$: initialPlay$,
                    initialSeek$: seek$,
                    manifest: manifest,
                    speed$: speed$,
                    startTime: initialTime
                }), cancelEndOfStream$ = new Subject.a(), buffers$ = core_buffers({
                    manifest: manifest,
                    initialPeriod: initialPeriod
                }, bufferClock$, abrManager, sourceBuffersStore, segmentPipelinesManager, bufferOptions).pipe(Object(mergeMap.a)(function(evt) {
                    switch (evt.type) {
                      case "end-of-stream":
                        return log.a.debug("Init: end-of-stream order received."), maintainEndOfStream(mediaSource).pipe(Object(ignoreElements.a)(), Object(takeUntil.a)(cancelEndOfStream$));

                      case "resume-stream":
                        return log.a.debug("Init: resume-stream order received."), cancelEndOfStream$.next(null), 
                        empty.a;

                      case "discontinuity-encountered":
                        var _evt$value = evt.value, bufferType = _evt$value.bufferType, gap = _evt$value.gap;
                        return source_buffers.isNative(bufferType) && handleDiscontinuity(gap[1], mediaElement), 
                        empty.a;

                      default:
                        return Object(of.a)(evt);
                    }
                })), playbackRate$ = Object(update_playback_rate.a)(mediaElement, speed$, clock$, {
                    pauseWhenStalled: !0
                }).pipe(Object(map.a)(events_generators.a.speedChanged)), stalled$ = Object(get_stalled_events.a)(clock$).pipe(Object(map.a)(events_generators.a.stalled)), handledDiscontinuities$ = getDiscontinuities(clock$, manifest).pipe(Object(tap.a)(function(gap) {
                    handleDiscontinuity(gap[1], mediaElement);
                }), Object(ignoreElements.a)()), loadedEvent$ = load$.pipe(Object(mergeMap.a)(function(evt) {
                    if ("autoplay-blocked" === evt) {
                        var error = new media_error.a("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: your browser does not allow it.");
                        return Object(of.a)(events_generators.a.warning(error), events_generators.a.loaded());
                    }
                    if ("not-loaded-metadata" !== evt) return log.a.debug("Init: The current content is loaded."), 
                    Object(of.a)(events_generators.a.loaded());
                    var _error = new media_error.a("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser falsely announced having loaded the content.");
                    return Object(of.a)(events_generators.a.warning(_error));
                }));
                return Object(merge.a)(handledDiscontinuities$, loadedEvent$, playbackRate$, stalled$, buffers$).pipe(finalize(function() {
                    // clean-up every created SourceBuffers
                    sourceBuffersStore.disposeAll();
                }));
            };
        }
        /**
 * Create all native SourceBuffers needed for a given Period.
 *
 * Native Buffers have the particulary to need to be created at the beginning of
 * the content.
 * Custom source buffers (entirely managed in JS) can generally be created and
 * disposed at will during the lifecycle of the content.
 * @param {SourceBuffersStore} sourceBuffersStore
 * @param {Period} period
 */        function createNativeSourceBuffersForPeriod(sourceBuffersStore, period) {
            Object.keys(period.adaptations).forEach(function(bufferType) {
                if (source_buffers.isNative(bufferType)) {
                    var adaptations = period.adaptations[bufferType] || [], representations = null != adaptations && adaptations.length ? adaptations[0].representations : [];
                    if (representations.length) {
                        var codec = representations[0].getMimeTypeString();
                        sourceBuffersStore.createSourceBuffer(bufferType, codec);
                    }
                }
            });
        }
        // CONCATENATED MODULE: ./src/core/init/refresh_manifest.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Refresh the manifest on subscription.
 * @returns {Observable}
 */        function refreshManifest(manifest, fetchManifest) {
            var refreshURL = manifest.getUrl();
            return refreshURL ? fetchManifest(refreshURL, manifest.getClockOffset()).pipe(Object(tap.a)(function(_ref) {
                var newManifest = _ref.manifest;
                manifest.update(newManifest);
            })) : (log.a.warn("Init: Cannot refresh the manifest: no url"), empty.a);
        }
        // EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
                var throw_on_media_error = __webpack_require__(114), OUT_OF_SYNC_MANIFEST_REFRESH_DELAY = config.a.OUT_OF_SYNC_MANIFEST_REFRESH_DELAY;
        // CONCATENATED MODULE: ./src/core/init/initialize_media_source.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        // CONCATENATED MODULE: ./src/core/init/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var core_init = 
        /**
 * Central part of the player.
 *
 * Play a content described by the given Manifest.
 *
 * On subscription:
 *   - Creates the MediaSource and attached sourceBuffers instances.
 *   - download the content's Manifest and handle its refresh logic
 *   - Perform EME management if needed
 *   - get Buffers for each active adaptations.
 *   - give choice of the adaptation to the caller (e.g. to choose a language)
 *   - returns Observable emitting notifications about the content lifecycle.
 * @param {Object} args
 * @returns {Observable}
 */
        function InitializeOnMediaSource(_ref) {
            var adaptiveOptions = _ref.adaptiveOptions, autoPlay = _ref.autoPlay, bufferOptions = _ref.bufferOptions, clock$ = _ref.clock$, keySystems = _ref.keySystems, lowLatencyMode = _ref.lowLatencyMode, mediaElement = _ref.mediaElement, networkConfig = _ref.networkConfig, speed$ = _ref.speed$, startAt = _ref.startAt, textTrackOptions = _ref.textTrackOptions, pipelines = _ref.pipelines, url = _ref.url, warning$ = new Subject.a(), manifestPipelines = pipelines_manifest(pipelines, {
                lowLatencyMode: lowLatencyMode,
                manifestRetry: networkConfig.manifestRetry,
                offlineRetry: networkConfig.offlineRetry
            }, warning$), fetchManifest = throttle(function(manifestURL, externalClockOffset) {
                return manifestPipelines.fetch(manifestURL).pipe(Object(mergeMap.a)(function(response) {
                    return manifestPipelines.parse(response.value, manifestURL, externalClockOffset);
                }), Object(share.a)());
            }), segmentPipelinesManager = new pipelines_segment(pipelines, {
                lowLatencyMode: lowLatencyMode,
                offlineRetry: networkConfig.offlineRetry,
                segmentRetry: networkConfig.segmentRetry
            }), abrManager = new abr(adaptiveOptions), openMediaSource$ = openMediaSource(mediaElement).pipe(Object(subscribeOn.a)(asap.a), // to launch subscriptions only when all
            Object(share.a)()), emeManager$ = openMediaSource$.pipe(Object(mergeMap.a)(function() {
                return Object(create_eme_manager.a)(mediaElement, keySystems);
            }), Object(subscribeOn.a)(asap.a), // to launch subscriptions only when all
            Object(share.a)()), mediaError$ = Object(throw_on_media_error.a)(mediaElement), loadContent$ = Object(combineLatest.a)([ openMediaSource$, fetchManifest(url, void 0), emeManager$.pipe(Object(filter.a)(is_eme_ready.a), Object(take.a)(1)) ]).pipe(Object(mergeMap.a)(function(_ref2) {
                var initialMediaSource = _ref2[0], _ref2$ = _ref2[1], manifest = _ref2$.manifest, sendingTime = _ref2$.sendingTime;
                log.a.debug("Init: Calculating initial time");
                var initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
                log.a.debug("Init: Initial time calculated:", initialTime);
                var mediaSourceLoader = createMediaSourceLoader({
                    mediaElement: mediaElement,
                    manifest: manifest,
                    clock$: clock$,
                    speed$: speed$,
                    abrManager: abrManager,
                    segmentPipelinesManager: segmentPipelinesManager,
                    bufferOptions: object_assign_default()({
                        textTrackOptions: textTrackOptions
                    }, bufferOptions)
                }), recursiveLoad$ = 
                /**
     * Load the content defined by the Manifest in the mediaSource given at the
     * given position and playing status.
     * This function recursively re-call itself when a MediaSource reload is
     * wanted.
     * @param {MediaSource} mediaSource
     * @param {number} position
     * @param {boolean} shouldPlay
     * @returns {Observable}
     */
                function recursivelyLoadOnMediaSource(mediaSource, position, shouldPlay) {
                    var reloadMediaSource$ = new Subject.a();
                    var mediaSourceLoader$ = mediaSourceLoader(mediaSource, position, shouldPlay).pipe(Object(tap.a)(function(evt) {
                        switch (evt.type) {
                          case "needs-manifest-refresh":
                            scheduleManifestRefresh$.next(0);
                            break;

                          case "manifest-might-be-out-of-sync":
                            scheduleManifestRefresh$.next(OUT_OF_SYNC_MANIFEST_REFRESH_DELAY);
                            break;

                          case "needs-media-source-reload":
                            reloadMediaSource$.next(evt.value);
                        }
                    }));
                    var currentLoad$ = mediaSourceLoader$.pipe(Object(takeUntil.a)(reloadMediaSource$));
                    var handleReloads$ = reloadMediaSource$.pipe(Object(switchMap.a)(function(_ref4) {
                        var currentTime = _ref4.currentTime, isPaused = _ref4.isPaused;
                        return openMediaSource(mediaElement).pipe(Object(mergeMap.a)(function(newMS) {
                            return recursivelyLoadOnMediaSource(newMS, currentTime, !isPaused);
                        }), Object(startWith.a)(events_generators.a.reloadingMediaSource()));
                    }));
                    return Object(merge.a)(handleReloads$, currentLoad$);
                }(initialMediaSource, initialTime, autoPlay), manifestRefreshed$ = new ReplaySubject.a(1), scheduleManifestRefresh$ = new Subject.a(), manifestRefresh$ = manifestRefreshed$.pipe(Object(startWith.a)({
                    manifest: manifest,
                    sendingTime: sendingTime
                }), Object(switchMap.a)(function(_ref3) {
                    var newManifest = _ref3.manifest, newSendingTime = _ref3.sendingTime, manualRefresh$ = scheduleManifestRefresh$.pipe(Object(mergeMap.a)(function(delay) {
                        // schedule a Manifest refresh to avoid sending too much request.
                        var timeSinceLastRefresh = null == newSendingTime ? 0 : performance.now() - newSendingTime;
                        return Object(timer.a)(delay - timeSinceLastRefresh);
                    })), autoRefresh$ = function() {
                        if (null == newManifest.lifetime || newManifest.lifetime <= 0) return empty.a;
                        var timeSinceRequest = null == newSendingTime ? 0 : performance.now() - newSendingTime, updateTimeout = 1e3 * newManifest.lifetime - timeSinceRequest;
                        return Object(timer.a)(updateTimeout);
                    }();
                    return Object(merge.a)(autoRefresh$, manualRefresh$).pipe(Object(take.a)(1), Object(mergeMap.a)(function() {
                        return refreshManifest(manifest, fetchManifest);
                    }), Object(tap.a)(function(val) {
                        return manifestRefreshed$.next(val);
                    }), Object(ignoreElements.a)());
                }));
                return Object(merge.a)(manifestRefresh$, recursiveLoad$).pipe(Object(startWith.a)(events_generators.a.manifestReady(manifest)), finalize(function() {
                    manifestRefreshed$.complete(), scheduleManifestRefresh$.complete();
                }));
            }));
            return Object(merge.a)(loadContent$, mediaError$, emeManager$, warning$.pipe(Object(map.a)(events_generators.a.warning)));
        }, refCount = __webpack_require__(113), SAMPLING_INTERVAL_MEDIASOURCE = config.a.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_LOW_LATENCY = config.a.SAMPLING_INTERVAL_LOW_LATENCY, SAMPLING_INTERVAL_NO_MEDIASOURCE = config.a.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config.a.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config.a.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config.a.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config.a.STALL_GAP, SCANNED_MEDIA_ELEMENTS_EVENTS = [ "canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "ratechange" ];
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
                /**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @param {Boolean} lowLatencyMode
 * @returns {Number}
 */
        function getResumeGap(stalled, lowLatencyMode) {
            if (!stalled) return 0;
            var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
            switch (stalled.reason) {
              case "seeking":
                return RESUME_GAP_AFTER_SEEKING[suffix];

              case "not-ready":
                return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];

              default:
                return RESUME_GAP_AFTER_BUFFERING[suffix];
            }
        }
        /**
 * @param {Object} currentRange
 * @param {Number} duration
 * @param {Boolean} lowLatencyMode
 * @returns {Boolean}
 */        function hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode) {
            var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
            return null !== currentRange && duration - currentRange.end <= STALL_GAP[suffix];
        }
        /**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} currentState
 * @returns {Object}
 */        function getMediaInfos(mediaElement, currentState) {
            var buffered = mediaElement.buffered, currentTime = mediaElement.currentTime, duration = mediaElement.duration, ended = mediaElement.ended, paused = mediaElement.paused, playbackRate = mediaElement.playbackRate, readyState = mediaElement.readyState, seeking = mediaElement.seeking;
            return {
                bufferGap: Object(ranges.d)(buffered, currentTime),
                buffered: buffered,
                currentRange: Object(ranges.g)(buffered, currentTime),
                currentTime: currentTime,
                duration: duration,
                ended: ended,
                paused: paused,
                playbackRate: playbackRate,
                readyState: readyState,
                seeking: seeking,
                state: currentState
            };
        }
        /**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Object} options
 * @returns {Object|null}
 */        function getStalledStatus(prevTimings, currentTimings, _ref) {
            var shouldStall, shouldUnstall, reason, withMediaSource = _ref.withMediaSource, lowLatencyMode = _ref.lowLatencyMode, currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended, prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime, fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode), canStall = 1 <= readyState && "loadedmetadata" !== currentState && !prevStalled && !(fullyLoaded || ended);
            return withMediaSource ? canStall && (bufferGap <= (lowLatencyMode ? STALL_GAP.LOW_LATENCY : STALL_GAP.DEFAULT) || Infinity === bufferGap || 1 === readyState) ? shouldStall = !0 : prevStalled && 1 < readyState && (bufferGap < Infinity && bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended) && (shouldUnstall = !0) : canStall && (!paused && "timeupdate" === currentState && "timeupdate" === prevState && currentTime === prevTime || "seeking" === currentState && Infinity === bufferGap) ? shouldStall = !0 : prevStalled && ("seeking" !== currentState && currentTime !== prevTime || "canplay" === currentState || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended)) && (shouldUnstall = !0), 
            shouldUnstall ? null : shouldStall || null !== prevStalled ? (reason = "seeking" === currentState || currentTimings.seeking || null !== prevStalled && "seeking" === prevStalled.reason ? "seeking" : 1 === readyState ? "not-ready" : "buffering", 
            null !== prevStalled && prevStalled.reason === reason ? prevStalled : {
                reason: reason,
                timestamp: performance.now()
            }) : null;
        }
        /**
 * Timings observable.
 *
 * This Observable samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this Observable also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */        
        /* harmony default export */ var api_clock = function createClock(mediaElement, options) {
            return Object(defer.a)(function() {
                var lastTimings = object_assign_default()(getMediaInfos(mediaElement, "init"), {
                    stalled: null
                });
                function getCurrentClockTick(state) {
                    var mediaTimings = getMediaInfos(mediaElement, state), stalledState = getStalledStatus(lastTimings, mediaTimings, options);
                    // /!\ Mutate mediaTimings
                    return object_assign_default()(mediaTimings, {
                        stalled: stalledState
                    });
                }
                var eventObs = SCANNED_MEDIA_ELEMENTS_EVENTS.map(function(eventName) {
                    return Object(fromEvent.a)(mediaElement, eventName).pipe(Object(mapTo.a)(eventName));
                }), interval = options.lowLatencyMode ? SAMPLING_INTERVAL_LOW_LATENCY : options.withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE, interval$ = Object(observable_interval.a)(interval).pipe(Object(mapTo.a)("timeupdate"));
                return merge.a.apply(void 0, [ interval$ ].concat(eventObs)).pipe(Object(map.a)(function(state) {
                    return lastTimings = getCurrentClockTick(state), log.a.debug("API: new clock tick", lastTimings), 
                    lastTimings;
                }), Object(startWith.a)(lastTimings));
            }).pipe(Object(multicast.a)(function() {
                return new ReplaySubject.a(1);
            }), // Always emit the last
            Object(refCount.a)());
        }, FORCED_ENDED_THRESHOLD = config.a.FORCED_ENDED_THRESHOLD, PLAYER_STATES_STOPPED = "STOPPED", PLAYER_STATES_LOADED = "LOADED", PLAYER_STATES_LOADING = "LOADING", PLAYER_STATES_PLAYING = "PLAYING", PLAYER_STATES_PAUSED = "PAUSED", PLAYER_STATES_ENDED = "ENDED", PLAYER_STATES_BUFFERING = "BUFFERING", PLAYER_STATES_SEEKING = "SEEKING", PLAYER_STATES_RELOADING = "RELOADING";
        // CONCATENATED MODULE: ./src/core/api/get_player_state.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */
        function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
            if (mediaElement.ended) return PLAYER_STATES_ENDED;
            if (stalledStatus) {
                // On some old browsers (e.g. Chrome 54), the browser does not
                // emit an 'ended' event in some conditions. Detect if we
                // reached the end by comparing the current position and the
                // duration instead.
                var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
                return null != FORCED_ENDED_THRESHOLD && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD ? PLAYER_STATES_ENDED : "seeking" === stalledStatus.reason ? PLAYER_STATES_SEEKING : PLAYER_STATES_BUFFERING;
            }
            return isPlaying ? PLAYER_STATES_PLAYING : PLAYER_STATES_PAUSED;
        }
        // EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
                var normalize = __webpack_require__(90), DEFAULT_AUTO_PLAY = config.a.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config.a.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config.a.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = config.a.DEFAULT_MANUAL_BITRATE_SWITCHING_MODE, DEFAULT_MAX_BITRATES = config.a.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config.a.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config.a.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config.a.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_STOP_AT_END = config.a.DEFAULT_STOP_AT_END, DEFAULT_TEXT_TRACK_MODE = config.a.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config.a.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN = config.a.DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config.a.DEFAULT_WANTED_BUFFER_AHEAD;
        // CONCATENATED MODULE: ./src/core/api/option_parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */        
        /**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */
        function parseConstructorOptions(options) {
            var maxBufferAhead, maxBufferBehind, wantedBufferAhead, limitVideoWidth, throttleWhenHidden, throttleVideoBitrateWhenHidden, preferredAudioTracks, preferredTextTracks, videoElement, initialVideoBitrate, initialAudioBitrate, maxAudioBitrate, maxVideoBitrate;
            if (null == options.maxBufferAhead) maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD; else if (maxBufferAhead = Number(options.maxBufferAhead), 
            isNaN(maxBufferAhead)) throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
            if (null == options.maxBufferBehind) maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND; else if (maxBufferBehind = Number(options.maxBufferBehind), 
            isNaN(maxBufferBehind)) throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
            if (null == options.wantedBufferAhead) wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD; else if (wantedBufferAhead = Number(options.wantedBufferAhead), 
            isNaN(wantedBufferAhead)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (limitVideoWidth = null == options.limitVideoWidth ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth, 
            // `throttleWhenHidden` and `throttleVideoBitrateWhenHidden` can be in conflict
            // Do not activate the latter if the former is
            throttleVideoBitrateWhenHidden = !(throttleWhenHidden = null != options.throttleWhenHidden ? (Object(warn_once.a)("`throttleWhenHidden` API is deprecated. Consider using `throttleVideoBitrateWhenHidden` instead."), 
            !!options.throttleWhenHidden) : DEFAULT_THROTTLE_WHEN_HIDDEN) && (null == options.throttleVideoBitrateWhenHidden ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN : !!options.throttleVideoBitrateWhenHidden), 
            preferredTextTracks = void 0 !== options.preferredTextTracks ? Array.isArray(options.preferredTextTracks) ? options.preferredTextTracks : (Object(warn_once.a)("Invalid `preferredTextTracks` option, it should be an Array"), 
            []) : [], preferredAudioTracks = void 0 !== options.preferredAudioTracks ? Array.isArray(options.preferredAudioTracks) ? options.preferredAudioTracks : (Object(warn_once.a)("Invalid `preferredAudioTracks` option, it should be an Array"), 
            []) : [], null == options.videoElement) videoElement = document.createElement("video"); else {
                if (!(options.videoElement instanceof HTMLMediaElement)) 
                /* tslint:disable:max-line-length */
                throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
                /* tslint:enable:max-line-length */                videoElement = options.videoElement;
            }
            if (null == options.initialVideoBitrate) initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video; else if (initialVideoBitrate = Number(options.initialVideoBitrate), 
            isNaN(initialVideoBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.initialAudioBitrate) initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio; else if (initialAudioBitrate = Number(options.initialAudioBitrate), 
            isNaN(initialAudioBitrate)) 
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */            if (null == options.maxVideoBitrate) maxVideoBitrate = DEFAULT_MAX_BITRATES.video; else if (maxVideoBitrate = Number(options.maxVideoBitrate), 
            isNaN(maxVideoBitrate)) throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
            if (null == options.maxAudioBitrate) maxAudioBitrate = DEFAULT_MAX_BITRATES.audio; else if (maxAudioBitrate = Number(options.maxAudioBitrate), 
            isNaN(maxAudioBitrate)) throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
            return {
                maxBufferAhead: maxBufferAhead,
                maxBufferBehind: maxBufferBehind,
                limitVideoWidth: limitVideoWidth,
                videoElement: videoElement,
                wantedBufferAhead: wantedBufferAhead,
                throttleWhenHidden: throttleWhenHidden,
                throttleVideoBitrateWhenHidden: throttleVideoBitrateWhenHidden,
                preferredAudioTracks: preferredAudioTracks,
                preferredTextTracks: preferredTextTracks,
                initialAudioBitrate: initialAudioBitrate,
                initialVideoBitrate: initialVideoBitrate,
                maxAudioBitrate: maxAudioBitrate,
                maxVideoBitrate: maxVideoBitrate,
                stopAtEnd: null == options.stopAtEnd ? DEFAULT_STOP_AT_END : !!options.stopAtEnd
            };
        }
        /**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */        function parseLoadVideoOptions(options) {
            var url, transport, keySystems, supplementaryTextTracks, supplementaryImageTracks, textTrackMode, textTrackElement, startAt;
            if (null == options) throw new Error("No option set on loadVideo");
            if (null != options.url) url = String(options.url); else if (null == options.transportOptions || null == options.transportOptions.manifestLoader) throw new Error("No url set on loadVideo");
            if (null == options.transport) throw new Error("No transport set on loadVideo");
            transport = String(options.transport);
            var autoPlay = null == options.autoPlay ? DEFAULT_AUTO_PLAY : !!options.autoPlay;
            if (null == options.keySystems) keySystems = []; else {
                var _iterator = keySystems = Array.isArray(options.keySystems) ? options.keySystems : [ options.keySystems ], _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var keySystem = _ref;
                    if ("string" != typeof keySystem.type || "function" != typeof keySystem.getLicense) throw new Error("Invalid key system given: Missing type string or getLicense callback");
                }
            }
            var transportOptions = options.transportOptions || {};
            if (null == options.supplementaryTextTracks) supplementaryTextTracks = []; else {
                var _iterator2 = supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [ options.supplementaryTextTracks ], _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var supplementaryTextTrack = _ref2;
                    if ("boolean" != typeof supplementaryTextTrack.closedCaption && (supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption), 
                    "string" != typeof supplementaryTextTrack.language || "string" != typeof supplementaryTextTrack.mimeType || "string" != typeof supplementaryTextTrack.url) throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                }
            }
            if (null == options.supplementaryImageTracks) supplementaryImageTracks = []; else {
                var _iterator3 = supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [ options.supplementaryImageTracks ], _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var supplementaryImageTrack = _ref3;
                    if ("string" != typeof supplementaryImageTrack.mimeType || "string" != typeof supplementaryImageTrack.url) throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                }
            }
            if (null == options.textTrackMode) textTrackMode = DEFAULT_TEXT_TRACK_MODE; else {
                if ("native" !== options.textTrackMode && "html" !== options.textTrackMode) throw new Error("Invalid textTrackMode.");
                textTrackMode = options.textTrackMode;
            }
            null != options.defaultAudioTrack && Object(warn_once.a)("The `defaultAudioTrack` loadVideo option is deprecated.\nPlease use the `preferredAudioTracks` constructor option or the`setPreferredAudioTracks` method instead");
            var defaultAudioTrack = Object(normalize.b)(options.defaultAudioTrack);
            null != options.defaultTextTrack && Object(warn_once.a)("The `defaultTextTrack` loadVideo option is deprecated.\nPlease use the `preferredTextTracks` constructor option or the`setPreferredTextTracks` method instead");
            var defaultTextTrack = Object(normalize.c)(options.defaultTextTrack), lowLatencyMode = null != options.lowLatencyMode && !!options.lowLatencyMode, hideNativeSubtitle = null == options.hideNativeSubtitle ? !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle, manualBitrateSwitchingMode = null == options.manualBitrateSwitchingMode ? !DEFAULT_MANUAL_BITRATE_SWITCHING_MODE : options.manualBitrateSwitchingMode;
            if ("html" === textTrackMode) {
                // TODO Better way to express that in TypeScript?
                if (null == options.textTrackElement) throw new Error('You have to provide a textTrackElement in "html" textTrackMode.');
                if (!(options.textTrackElement instanceof HTMLElement)) throw new Error("textTrackElement should be an HTMLElement.");
                textTrackElement = options.textTrackElement;
            } else null != options.textTrackElement && log.a.warn('API: You have set a textTrackElement without being in an "html" textTrackMode. It will be ignored.');
            if (null != options.startAt) 
            // TODO Better way to express that in TypeScript?
            if (options.startAt.wallClockTime instanceof Date) {
                var wallClockTime = options.startAt.wallClockTime.getTime() / 1e3;
                startAt = object_assign_default()({}, options.startAt, {
                    wallClockTime: wallClockTime
                });
            } else startAt = options.startAt;
            // TODO without cast
            /* tslint:disable no-object-literal-type-assertion */
            return {
                autoPlay: autoPlay,
                defaultAudioTrack: defaultAudioTrack,
                defaultTextTrack: defaultTextTrack,
                hideNativeSubtitle: hideNativeSubtitle,
                keySystems: keySystems,
                lowLatencyMode: lowLatencyMode,
                manualBitrateSwitchingMode: manualBitrateSwitchingMode,
                networkConfig: null == options.networkConfig ? {} : {
                    manifestRetry: options.networkConfig.manifestRetry,
                    offlineRetry: options.networkConfig.offlineRetry,
                    segmentRetry: options.networkConfig.segmentRetry
                },
                startAt: startAt,
                supplementaryImageTracks: supplementaryImageTracks,
                supplementaryTextTracks: supplementaryTextTracks,
                textTrackElement: textTrackElement,
                textTrackMode: textTrackMode,
                transport: transport,
                transportOptions: transportOptions,
                url: url
            };
            /* tslint:enable no-object-literal-type-assertion */        }
        // EXTERNAL MODULE: ./src/utils/languages/index.ts
                var languages = __webpack_require__(73);
        // CONCATENATED MODULE: ./src/core/api/track_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function normalizeAudioTracks(tracks) {
            return tracks.map(function(t) {
                return t && {
                    normalized: Object(languages.a)(t.language),
                    audioDescription: t.audioDescription
                };
            });
        }
        function normalizeTextTracks(tracks) {
            return tracks.map(function(t) {
                return t && {
                    normalized: Object(languages.a)(t.language),
                    closedCaption: t.closedCaption
                };
            });
        }
        /**
 * Manage audio and text tracks for all active periods.
 * Chose the audio and text tracks for each period and record this choice.
 * @class TrackManager
 */        var track_manager_TrackManager = 
        /* */
        function() {
            /**
   * @param {BehaviorSubject<Array.<Object|null>>} preferredAudioTracks - Array
   * of audio track preferences
   * @param {BehaviorSubject<Array.<Object|null>>} preferredAudioTracks - Array
   * of text track preferences
   */
            function TrackManager(defaults) {
                var preferredAudioTracks = defaults.preferredAudioTracks, preferredTextTracks = defaults.preferredTextTracks;
                this._periods = new sorted_list_SortedList(function(a, b) {
                    return a.period.start - b.period.start;
                }), this._audioChoiceMemory = new WeakMap(), this._textChoiceMemory = new WeakMap(), 
                this._videoChoiceMemory = new WeakMap(), this._preferredAudioTracks = preferredAudioTracks, 
                this._preferredTextTracks = preferredTextTracks;
            }
            /**
   * Add Subject to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   * @param {Subject.<Object|null>} adaptation$ - A subject through which the
   * choice will be given
   */            var _proto = TrackManager.prototype;
            return _proto.addPeriod = function addPeriod(bufferType, period, adaptation$) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null != periodItem) {
                    if (null != periodItem[bufferType]) return void log.a.warn("TrackManager: " + bufferType + " already added for period", period);
                    periodItem[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    };
                } else {
                    var _this$_periods$add;
                    this._periods.add(((_this$_periods$add = {
                        period: period
                    })[bufferType] = {
                        adaptations: period.adaptations[bufferType] || [],
                        adaptation$: adaptation$
                    }, _this$_periods$add));
                }
            }
            /**
   * Remove Subject to choose an "audio", "video" or "text" Adaptation for a
   * Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   */ , _proto.removePeriod = function removePeriod(bufferType, period) {
                var periodIndex = findPeriodIndex(this._periods, period);
                if (null != periodIndex) {
                    var periodItem = this._periods.get(periodIndex);
                    null != periodItem[bufferType] ? (delete periodItem[bufferType], null == periodItem.audio && null == periodItem.text && null == periodItem.video && this._periods.removeElement(periodItem)) : log.a.warn("TrackManager: " + bufferType + " already removed for period", period);
                } else log.a.warn("TrackManager: " + bufferType + " not found for period", period);
            }, _proto.resetPeriods = function resetPeriods() {
                for (;0 < this._periods.length(); ) this._periods.pop();
            }
            /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */ , _proto.update = function update() {
                this._updateAudioTrackChoices(), this._updateTextTrackChoices(), this._updateVideoTrackChoices();
            }
            /**
   * Emit initial audio Adaptation through the given Subject based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */ , _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredAudioTracks = this._preferredAudioTracks.getValue(), audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                if (null === chosenAudioAdaptation) 
                // If the Period was previously without audio, keep it that way
                audioInfos.adaptation$.next(null); else if (void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) audioInfos.adaptation$.next(chosenAudioAdaptation); // set last one
                 else {
                    // Find the optimal audio Adaptation
                    var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizeAudioTracks(preferredAudioTracks));
                    this._audioChoiceMemory.set(period, optimalAdaptation), audioInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Emit initial text Adaptation through the given Subject based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */ , _proto.setInitialTextTrack = function setInitialTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var preferredTextTracks = this._preferredTextTracks.getValue(), textAdaptations = period.adaptations.text || [], chosenTextAdaptation = this._textChoiceMemory.get(period);
                if (null === chosenTextAdaptation) 
                // If the Period was previously without text, keep it that way
                textInfos.adaptation$.next(null); else if (void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) textInfos.adaptation$.next(chosenTextAdaptation); // set last one
                 else {
                    // Find the optimal text Adaptation
                    var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizeTextTracks(preferredTextTracks));
                    this._textChoiceMemory.set(period, optimalAdaptation), textInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Emit initial video Adaptation through the given Subject based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */ , _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos || !periodItem) throw new Error("TrackManager: Given Period not found.");
                var videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                if (null === chosenVideoAdaptation) 
                // If the Period was previously without video, keep it that way
                videoInfos.adaptation$.next(null); else if (void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) videoInfos.adaptation$.next(chosenVideoAdaptation); // set last one
                 else {
                    var optimalAdaptation = videoAdaptations[0];
                    this._videoChoiceMemory.set(period, optimalAdaptation), videoInfos.adaptation$.next(optimalAdaptation);
                }
            }
            /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */ , _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (!audioInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(audioInfos.adaptations, function(_ref) {
                    return _ref.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Audio Track not found.");
                this._audioChoiceMemory.get(period) !== wantedAdaptation && (this._audioChoiceMemory.set(period, wantedAdaptation), 
                audioInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Set text track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */ , _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(textInfos.adaptations, function(_ref2) {
                    return _ref2.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Text Track not found.");
                this._textChoiceMemory.get(period) !== wantedAdaptation && (this._textChoiceMemory.set(period, wantedAdaptation), 
                textInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Set video track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */ , _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (!videoInfos) throw new Error("LanguageManager: Given Period not found.");
                var wantedAdaptation = Object(array_find.a)(videoInfos.adaptations, function(_ref3) {
                    return _ref3.id === wantedId;
                });
                if (void 0 === wantedAdaptation) throw new Error("Video Track not found.");
                this._videoChoiceMemory.get(period) !== wantedAdaptation && (this._videoChoiceMemory.set(period, wantedAdaptation), 
                videoInfos.adaptation$.next(wantedAdaptation));
            }
            /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */ , _proto.disableTextTrack = function disableTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (!textInfos) throw new Error("TrackManager: Given Period not found.");
                null !== this._textChoiceMemory.get(period) && (this._textChoiceMemory.set(period, null), 
                textInfos.adaptation$.next(null));
            }
            /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The audio track chosen for this Period
   */ , _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.audio)) return null;
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
                return chosenAudioAdaptation ? {
                    language: chosenAudioAdaptation.language || "",
                    normalized: chosenAudioAdaptation.normalizedLanguage || "",
                    audioDescription: !!chosenAudioAdaptation.isAudioDescription,
                    id: chosenAudioAdaptation.id
                } : null;
            }
            /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The text track chosen for this Period
   */ , _proto.getChosenTextTrack = function getChosenTextTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.text)) return null;
                var chosenTextAdaptation = this._textChoiceMemory.get(period);
                return chosenTextAdaptation ? {
                    language: chosenTextAdaptation.language || "",
                    normalized: chosenTextAdaptation.normalizedLanguage || "",
                    closedCaption: !!chosenTextAdaptation.isClosedCaption,
                    id: chosenTextAdaptation.id
                } : null;
            }
            /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The video track chosen for this Period
   */ , _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
                var periodItem = getPeriodItem(this._periods, period);
                if (null == (periodItem && periodItem.video)) return null;
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period);
                return chosenVideoAdaptation ? {
                    id: chosenVideoAdaptation.id,
                    representations: chosenVideoAdaptation.representations.map(parseVideoRepresentation)
                } : null;
            }
            /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */ , _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), audioInfos = periodItem && periodItem.audio;
                if (null == audioInfos) return [];
                var chosenAudioAdaptation = this._audioChoiceMemory.get(period), currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;
                return audioInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        audioDescription: !!adaptation.isAudioDescription,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }
            /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */ , _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), textInfos = periodItem && periodItem.text;
                if (null == textInfos) return [];
                var chosenTextAdaptation = this._textChoiceMemory.get(period), currentId = chosenTextAdaptation && chosenTextAdaptation.id;
                return textInfos.adaptations.map(function(adaptation) {
                    return {
                        language: adaptation.language || "",
                        normalized: adaptation.normalizedLanguage || "",
                        closedCaption: !!adaptation.isClosedCaption,
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id
                    };
                });
            }
            /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */ , _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
                var periodItem = getPeriodItem(this._periods, period), videoInfos = periodItem && periodItem.video;
                if (null == videoInfos) return [];
                var chosenVideoAdaptation = this._videoChoiceMemory.get(period), currentId = chosenVideoAdaptation && chosenVideoAdaptation.id;
                return videoInfos.adaptations.map(function(adaptation) {
                    return {
                        id: adaptation.id,
                        active: null != currentId && currentId === adaptation.id,
                        representations: adaptation.representations.map(parseVideoRepresentation)
                    };
                });
            }, _proto._updateAudioTrackChoices = function _updateAudioTrackChoices() {
                var _this = this, normalizedTracks = normalizeAudioTracks(this._preferredAudioTracks.getValue());
                !function recursiveUpdateAudioTrack(index) {
                    if (!(index >= _this._periods.length())) {
                        var periodItem = _this._periods.get(index);
                        if (null != periodItem.audio) {
                            var period = periodItem.period, audioItem = periodItem.audio, audioAdaptations = period.adaptations.audio || [], chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
                            if (null === chosenAudioAdaptation || void 0 !== chosenAudioAdaptation && Object(array_includes.a)(audioAdaptations, chosenAudioAdaptation)) 
                            // Already best audio for this Buffer, check next one
                            recursiveUpdateAudioTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedTracks);
                                _this._audioChoiceMemory.set(period, optimalAdaptation), audioItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateAudioTrack(0);
                            }
                        } else 
                        // No audio Buffer for this period, check next one
                        recursiveUpdateAudioTrack(index + 1);
                    }
                }(0);
            }, _proto._updateTextTrackChoices = function _updateTextTrackChoices() {
                var _this2 = this, normalizedTracks = normalizeTextTracks(this._preferredTextTracks.getValue());
                !function recursiveUpdateTextTrack(index) {
                    if (!(index >= _this2._periods.length())) {
                        var periodItem = _this2._periods.get(index);
                        if (null != periodItem.text) {
                            var period = periodItem.period, textItem = periodItem.text, textAdaptations = period.adaptations.text || [], chosenTextAdaptation = _this2._textChoiceMemory.get(period);
                            if (null === chosenTextAdaptation || void 0 !== chosenTextAdaptation && Object(array_includes.a)(textAdaptations, chosenTextAdaptation)) 
                            // Already best text for this Buffer, check next one
                            recursiveUpdateTextTrack(index + 1); else {
                                var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedTracks);
                                _this2._textChoiceMemory.set(period, optimalAdaptation), textItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateTextTrack(0);
                            }
                        } else 
                        // No text Buffer for this period, check next one
                        recursiveUpdateTextTrack(index + 1);
                    }
                }(0);
            }, _proto._updateVideoTrackChoices = function _updateVideoTrackChoices() {
                var _this3 = this;
                !function recursiveUpdateVideoTrack(index) {
                    if (!(index >= _this3._periods.length())) {
                        var periodItem = _this3._periods.get(index);
                        if (null != periodItem.video) {
                            var period = periodItem.period, videoItem = periodItem.video, videoAdaptations = period.adaptations.video || [], chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);
                            if (null === chosenVideoAdaptation || void 0 !== chosenVideoAdaptation && Object(array_includes.a)(videoAdaptations, chosenVideoAdaptation)) 
                            // Already best video for this Buffer, check next one
                            recursiveUpdateVideoTrack(index + 1); else {
                                var optimalAdaptation = videoAdaptations[0];
                                _this3._videoChoiceMemory.set(period, optimalAdaptation), videoItem.adaptation$.next(optimalAdaptation), 
                                // previous "next" call could have changed everything, start over
                                recursiveUpdateVideoTrack(0);
                            }
                        } else 
                        // No video Buffer for this period, check next one
                        recursiveUpdateVideoTrack(index + 1);
                    }
                }(0);
            }, TrackManager;
        }();
        /**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
            if (!audioAdaptations.length) return null;
            for (var _loop = function _loop(i) {
                var preferredAudioTrack = preferredAudioTracks[i];
                if (null === preferredAudioTrack) return {
                    v: null
                };
                var foundAdaptation = Object(array_find.a)(audioAdaptations, function(audioAdaptation) {
                    return (audioAdaptation.normalizedLanguage || "") === preferredAudioTrack.normalized && !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredAudioTracks.length; i++) {
                var _ret = _loop(i);
                if ("object" == typeof _ret) return _ret.v;
            }
 // no optimal adaptation, just return the first one
                        return audioAdaptations[0];
        }
        /**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */        function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
            if (!textAdaptations.length) return null;
            for (var _loop2 = function _loop2(i) {
                var preferredTextTrack = preferredTextTracks[i];
                if (null === preferredTextTrack) return {
                    v: null
                };
                var foundAdaptation = Object(array_find.a)(textAdaptations, function(textAdaptation) {
                    return (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized && !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;
                });
                return void 0 !== foundAdaptation ? {
                    v: foundAdaptation
                } : void 0;
            }, i = 0; i < preferredTextTracks.length; i++) {
                var _ret2 = _loop2(i);
                if ("object" == typeof _ret2) return _ret2.v;
            }
 // no optimal adaptation
                        return null;
        }
        function findPeriodIndex(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                if (periods.get(i).period.id === period.id) return i;
            }
        }
        function getPeriodItem(periods, period) {
            for (var i = 0; i < periods.length(); i++) {
                var periodI = periods.get(i);
                if (periodI.period.id === period.id) return periodI;
            }
        }
        /**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */        function parseVideoRepresentation(_ref4) {
            return {
                id: _ref4.id,
                bitrate: _ref4.bitrate,
                frameRate: _ref4.frameRate,
                width: _ref4.width,
                height: _ref4.height,
                codec: _ref4.codec
            };
        }
        // CONCATENATED MODULE: ./src/core/api/public_api.ts
                function public_api_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function public_api_createClass(Constructor, protoProps, staticProps) {
            return protoProps && public_api_defineProperties(Constructor.prototype, protoProps), 
            staticProps && public_api_defineProperties(Constructor, staticProps), Constructor;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */        var DEFAULT_UNMUTED_VOLUME = config.a.DEFAULT_UNMUTED_VOLUME, isActive = compat.a.isActive, isVideoVisible = compat.a.isVideoVisible, onEnded$ = compat.a.onEnded$, onFullscreenChange$ = compat.a.onFullscreenChange$, onPlayPause$ = compat.a.onPlayPause$, onPictureInPictureEvent$ = compat.a.onPictureInPictureEvent$, onSeeking$ = compat.a.onSeeking$, onTextTrackChanges$ = compat.a.onTextTrackChanges$, videoWidth$ = compat.a.videoWidth$, public_api_Player = 
        /* */
        function(_EventEmitter) {
            /**
   * @constructor
   * @param {Object} options
   */
            function Player(options) {
                var _this;
                void 0 === options && (options = {}), _this = _EventEmitter.call(this) || this;
                var _parseConstructorOpti = parseConstructorOptions(options), initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate, initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate, limitVideoWidth = _parseConstructorOpti.limitVideoWidth, maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate, maxBufferAhead = _parseConstructorOpti.maxBufferAhead, maxBufferBehind = _parseConstructorOpti.maxBufferBehind, maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate, preferredAudioTracks = _parseConstructorOpti.preferredAudioTracks, preferredTextTracks = _parseConstructorOpti.preferredTextTracks, throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden, throttleVideoBitrateWhenHidden = _parseConstructorOpti.throttleVideoBitrateWhenHidden, videoElement = _parseConstructorOpti.videoElement, wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead, stopAtEnd = _parseConstructorOpti.stopAtEnd;
 // Workaround to support Firefox autoplay on FF 42.
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
                                return videoElement.preload = "auto", _this.version = 
                /*PLAYER_VERSION*/
                "3.16.1", _this.log = log.a, _this.state = "STOPPED", _this.videoElement = videoElement, 
                _this._priv_destroy$ = new Subject.a(), _this._priv_pictureInPictureEvent$ = new ReplaySubject.a(1), 
                onPictureInPictureEvent$(videoElement).pipe(Object(takeUntil.a)(_this._priv_destroy$)).subscribe(_this._priv_pictureInPictureEvent$), 
                /** @deprecated */
                onFullscreenChange$(videoElement).pipe(Object(takeUntil.a)(_this._priv_destroy$))
                /* tslint:disable deprecation */ .subscribe(function() {
                    return _this.trigger("fullscreenChange", _this.isFullscreen());
                }), 
                /* tslint:enable deprecation */
                /** @deprecated */
                onTextTrackChanges$(videoElement.textTracks).pipe(Object(takeUntil.a)(_this._priv_destroy$), Object(map.a)(function(evt) {
                    for (var target = evt.target, arr = [], i = 0; i < target.length; i++) {
                        var textTrack = target[i];
                        arr.push(textTrack);
                    }
                    return arr;
                }), // We can have two consecutive textTrackChanges with the exact same
                // payload when we perform multiple texttrack operations before the event
                // loop is freed.
                // In that case we only want to fire one time the observable.
                Object(distinctUntilChanged.a)(function(textTracksA, textTracksB) {
                    if (textTracksA.length !== textTracksB.length) return !1;
                    for (var i = 0; i < textTracksA.length; i++) if (textTracksA[i] !== textTracksB[i]) return !1;
                    return !0;
                })).subscribe(function(x) {
                    return _this._priv_onNativeTextTracksNext(x);
                }), _this._priv_playing$ = new ReplaySubject.a(1), _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate), 
                _this._priv_stopCurrentContent$ = new Subject.a(), _this._priv_contentLock$ = new BehaviorSubject_BehaviorSubject(!1), 
                _this._priv_bufferOptions = {
                    wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
                    maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
                    maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
                }, _this._priv_bitrateInfos = {
                    lastBitrates: {
                        audio: initialAudioBitrate,
                        video: initialVideoBitrate
                    },
                    maxAutoBitrates: {
                        audio: new BehaviorSubject_BehaviorSubject(maxAudioBitrate),
                        video: new BehaviorSubject_BehaviorSubject(maxVideoBitrate)
                    },
                    manualBitrates: {
                        audio: new BehaviorSubject_BehaviorSubject(-1),
                        video: new BehaviorSubject_BehaviorSubject(-1)
                    }
                }, _this._priv_throttleWhenHidden = throttleWhenHidden, _this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden, 
                _this._priv_limitVideoWidth = limitVideoWidth, _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME, 
                _this._priv_trackManager = null, _this._priv_currentError = null, _this._priv_contentInfos = null, 
                _this._priv_contentEventsMemory = {}, _this._priv_stopAtEnd = stopAtEnd, _this._priv_setPlayerState(PLAYER_STATES_STOPPED), 
                _this._priv_preferredAudioTracks = new BehaviorSubject_BehaviorSubject(preferredAudioTracks), 
                _this._priv_preferredTextTracks = new BehaviorSubject_BehaviorSubject(preferredTextTracks), 
                _this;
            }
            /**
   * All possible Error types emitted by the RxPlayer.
   * @type {Object}
   */            _inheritsLoose(Player, _EventEmitter);
            var _proto = Player.prototype;
            /**
   * Stop the playback for the current content.
   */            return _proto.stop = function stop() {
                this.state !== PLAYER_STATES_STOPPED && (this._priv_stopCurrentContent$.next(), 
                this._priv_cleanUpCurrentContentState(), this._priv_setPlayerState(PLAYER_STATES_STOPPED));
            }
            /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */ , _proto.dispose = function dispose() {
                // free resources linked to the loaded content
                this.stop(), this.videoElement && 
                // free resources used for EME management
                Object(dispose_eme.a)(this.videoElement), // free Observables linked to the Player instance
                this._priv_destroy$.next(), this._priv_destroy$.complete(), // Complete all subjects
                this._priv_stopCurrentContent$.complete(), this._priv_playing$.complete(), this._priv_speed$.complete(), 
                this._priv_contentLock$.complete(), this._priv_bufferOptions.wantedBufferAhead$.complete(), 
                this._priv_bufferOptions.maxBufferAhead$.complete(), this._priv_bufferOptions.maxBufferBehind$.complete(), 
                this._priv_pictureInPictureEvent$.complete(), this._priv_bitrateInfos.manualBitrates.video.complete(), 
                this._priv_bitrateInfos.manualBitrates.audio.complete(), this._priv_bitrateInfos.maxAutoBitrates.video.complete(), 
                this._priv_bitrateInfos.maxAutoBitrates.audio.complete(), // un-attach video element
                this.videoElement = null;
            }
            /**
   * Load a new video.
   * @param {Object} opts
   * @returns {Observable}
   */ , _proto.loadVideo = function loadVideo(opts) {
                var _this2 = this, options = parseLoadVideoOptions(opts);
                log.a.info("API: Calling loadvideo", options);
                var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, lowLatencyMode = options.lowLatencyMode, manualBitrateSwitchingMode = options.manualBitrateSwitchingMode, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
 // Perform multiple checks on the given options
                                if (!this.videoElement) throw new Error("the attached video element is disposed");
 // now that every check has passed, stop previous content
                                this.stop();
                var isDirectFile = "directfile" === transport;
                this._priv_currentError = null, this._priv_contentInfos = {
                    url: url,
                    isDirectFile: isDirectFile,
                    thumbnails: null,
                    manifest: null,
                    currentPeriod: null,
                    activeAdaptations: null,
                    activeRepresentations: null,
                    initialAudioTrack: defaultAudioTrack,
                    initialTextTrack: defaultTextTrack
                }, // inilialize to false
                this._priv_playing$.next(!1);
                // get every properties used from context for clarity
                var playback$, videoElement = this.videoElement, clock$ = api_clock(videoElement, {
                    withMediaSource: !isDirectFile,
                    lowLatencyMode: lowLatencyMode
                }), contentIsStopped$ = Object(merge.a)(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? onEnded$(videoElement) : empty.a).pipe(Object(take.a)(1));
 // Global clock used for the whole application.
                                if (isDirectFile) {
                    if (null == features.a.directfile) throw new Error("DirectFile feature not activated in your build.");
                    var directfileInit$ = features.a.directfile({
                        autoPlay: autoPlay,
                        clock$: clock$,
                        keySystems: keySystems,
                        mediaElement: videoElement,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        url: url
                    }).pipe(Object(takeUntil.a)(contentIsStopped$));
                    playback$ = publish()(directfileInit$);
                } // Emit an object when the player stalls and null when it unstall
                 else {
                    var transportFn = features.a.transports[transport];
                    if (!transportFn) throw new Error('transport "' + transport + '" not supported');
                    var pipelines = transportFn(object_assign_default()({
                        lowLatencyMode: lowLatencyMode,
                        supplementaryTextTracks: supplementaryTextTracks,
                        supplementaryImageTracks: supplementaryImageTracks
                    }, transportOptions)), adaptiveOptions = {
                        initialBitrates: this._priv_bitrateInfos.lastBitrates,
                        lowLatencyMode: lowLatencyMode,
                        manualBitrates: this._priv_bitrateInfos.manualBitrates,
                        maxAutoBitrates: this._priv_bitrateInfos.maxAutoBitrates,
                        throttlers: {
                            throttle: this._priv_throttleWhenHidden ? {
                                video: isActive().pipe(Object(map.a)(function(active) {
                                    return active ? Infinity : 0;
                                }), Object(takeUntil.a)(this._priv_stopCurrentContent$))
                            } : {},
                            throttleBitrate: this._priv_throttleVideoBitrateWhenHidden ? {
                                video: isVideoVisible(this._priv_pictureInPictureEvent$).pipe(Object(map.a)(function(active) {
                                    return active ? Infinity : 0;
                                }), Object(takeUntil.a)(this._priv_stopCurrentContent$))
                            } : {},
                            limitWidth: this._priv_limitVideoWidth ? {
                                video: videoWidth$(videoElement, this._priv_pictureInPictureEvent$).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$))
                            } : {}
                        }
                    }, textTrackOptions = "native" === options.textTrackMode ? {
                        textTrackMode: "native",
                        hideNativeSubtitle: options.hideNativeSubtitle
                    } : {
                        textTrackMode: "html",
                        textTrackElement: options.textTrackElement
                    }, bufferOptions = object_assign_default()({
                        manualBitrateSwitchingMode: manualBitrateSwitchingMode
                    }, this._priv_bufferOptions), init$ = core_init({
                        adaptiveOptions: adaptiveOptions,
                        autoPlay: autoPlay,
                        bufferOptions: bufferOptions,
                        clock$: clock$,
                        keySystems: keySystems,
                        lowLatencyMode: lowLatencyMode,
                        mediaElement: videoElement,
                        networkConfig: networkConfig,
                        pipelines: pipelines,
                        speed$: this._priv_speed$,
                        startAt: startAt,
                        textTrackOptions: textTrackOptions,
                        url: url
                    }).pipe(Object(takeUntil.a)(contentIsStopped$));
 // Options used by the ABR Manager.
                                        playback$ = publish()(init$);
                }
                var playbackSubscription, stalled$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "stalled" === evt.type;
                }), Object(map.a)(function(x) {
                    return x.value;
                })), loaded$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "loaded" === evt.type;
                }), Object(share.a)()), reloading$ = playback$.pipe(Object(filter.a)(function(evt) {
                    return "reloading-media-source" === evt.type;
                }), Object(share.a)()), endedEvent$ = onEnded$(videoElement), seekingEvent$ = onSeeking$(videoElement), loadedStateUpdates$ = Object(combineLatest.a)([ this._priv_playing$, stalled$.pipe(Object(startWith.a)(null)), endedEvent$.pipe(Object(startWith.a)(null)), seekingEvent$.pipe(Object(startWith.a)(null)) ]).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$), Object(map.a)(function(_ref) {
                    var isPlaying = _ref[0], stalledStatus = _ref[1];
                    return getLoadedContentState(videoElement, isPlaying, stalledStatus);
                })), playerState$ = Object(concat.a)(Object(of.a)(PLAYER_STATES_LOADING), // Begin with LOADING
                // LOADED as soon as the first "loaded" event is sent
                loaded$.pipe(Object(take.a)(1), Object(mapTo.a)(PLAYER_STATES_LOADED)), Object(merge.a)(loadedStateUpdates$.pipe(// From the first reload onward, we enter another dynamic (below)
                Object(takeUntil.a)(reloading$), skipWhile(function(state) {
                    return state === PLAYER_STATES_PAUSED;
                })), // when reloading
                reloading$.pipe(Object(switchMapTo.a)(loaded$.pipe(Object(take.a)(1), // wait for the next loaded event
                Object(mergeMapTo.a)(loadedStateUpdates$), // to update the state as usual
                Object(startWith.a)(PLAYER_STATES_RELOADING)))))).pipe(Object(distinctUntilChanged.a)());
 // Emit when the content is considered "loaded".
                                this._priv_stopCurrentContent$.pipe(Object(take.a)(1)).subscribe(function() {
                    playbackSubscription && playbackSubscription.unsubscribe();
                }), onPlayPause$(videoElement).pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(e) {
                    return _this2._priv_onPlayPauseNext("play" === e.type);
                }, noop.a), clock$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_triggerTimeChange(x);
                }, noop.a), playerState$.pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function(x) {
                    return _this2._priv_setPlayerState(x);
                }, noop.a), playback$.subscribe(function(x) {
                    return _this2._priv_onPlaybackEvent(x);
                }, function(err) {
                    return _this2._priv_onPlaybackError(err);
                }, function() {
                    return _this2._priv_onPlaybackFinished();
                }), // initialize the content only when the lock is inactive
                this._priv_contentLock$.pipe(Object(filter.a)(function(isLocked) {
                    return !isLocked;
                }), Object(take.a)(1), Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                    playbackSubscription = playback$.connect();
                });
            }
            /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null}
   */ , _proto.getError = function getError() {
                return this._priv_currentError;
            }
            /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @returns {Manifest|null}
   */ , _proto.getManifest = function getManifest() {
                return this._priv_contentInfos && this._priv_contentInfos.manifest;
            }
            /**
   * Returns adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */ , _proto.getCurrentAdaptations = function getCurrentAdaptations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn.currentPeriod, activeAdaptations = _this$_priv_contentIn.activeAdaptations;
                return currentPeriod && activeAdaptations && activeAdaptations[currentPeriod.id] || null;
            }
            /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */ , _proto.getCurrentRepresentations = function getCurrentRepresentations() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn2 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn2.currentPeriod, activeRepresentations = _this$_priv_contentIn2.activeRepresentations;
                return currentPeriod && activeRepresentations && activeRepresentations[currentPeriod.id] || null;
            }
            /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null}
   */ , _proto.getVideoElement = function getVideoElement() {
                return this.videoElement;
            }
            /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack}
   */ , _proto.getNativeTextTrack = function getNativeTextTrack() {
                if (Object(warn_once.a)("getNativeTextTrack is deprecated. Please open an issue if you used this API."), 
                !this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return 0 < videoElement.textTracks.length ? videoElement.textTracks[0] : null;
            }
            /**
   * Returns the player's current state.
   * @returns {string}
   */ , _proto.getPlayerState = function getPlayerState() {
                return this.state;
            }
            /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean}
   */ , _proto.isLive = function isLive() {
                if (!this._priv_contentInfos) return !1;
                var _this$_priv_contentIn3 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn3.isDirectFile, manifest = _this$_priv_contentIn3.manifest;
                return !isDirectFile && null != manifest && manifest.isLive;
            }
            /**
   * Returns the url of the content's manifest
   * @returns {string|undefined}
   */ , _proto.getUrl = function getUrl() {
                if (this._priv_contentInfos) {
                    var _this$_priv_contentIn4 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn4.isDirectFile, manifest = _this$_priv_contentIn4.manifest, url = _this$_priv_contentIn4.url;
                    return isDirectFile ? url : null != manifest ? manifest.getUrl() : void 0;
                }
            }
            /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */ , _proto.getVideoDuration = function getVideoDuration() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.duration;
            }
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */ , _proto.getVideoBufferGap = function getVideoBufferGap() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(ranges.d)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */ , _proto.getVideoLoadedTime = function getVideoLoadedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(ranges.h)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */ , _proto.getVideoPlayedTime = function getVideoPlayedTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                return Object(ranges.f)(videoElement.buffered, videoElement.currentTime);
            }
            /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */ , _proto.getWallClockTime = function getWallClockTime() {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) return this.videoElement.currentTime;
                var _this$_priv_contentIn5 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn5.isDirectFile, manifest = _this$_priv_contentIn5.manifest;
                if (isDirectFile) return this.videoElement.currentTime;
                if (null == manifest) return 0;
                var currentTime = this.videoElement.currentTime;
                return this.isLive() ? currentTime + (manifest.availabilityStartTime || 0) : currentTime;
            }
            /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */ , _proto.getPosition = function getPosition() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.currentTime;
            }
            /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */ , _proto.getPlaybackRate = function getPlaybackRate() {
                return this._priv_speed$.getValue();
            }
            /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */ , _proto.setPlaybackRate = function setPlaybackRate(rate) {
                this._priv_speed$.next(rate);
            }
            /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */ , _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn6 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn6.currentPeriod, activeAdaptations = _this$_priv_contentIn6.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations[currentPeriod.id], videoAdaptation = adaptations && adaptations.video;
                return videoAdaptation ? videoAdaptation.getAvailableBitrates() : [];
            }
            /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */ , _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
                if (!this._priv_contentInfos) return [];
                var _this$_priv_contentIn7 = this._priv_contentInfos, currentPeriod = _this$_priv_contentIn7.currentPeriod, activeAdaptations = _this$_priv_contentIn7.activeAdaptations;
                if (!currentPeriod || !activeAdaptations) return [];
                var adaptations = activeAdaptations[currentPeriod.id], audioAdaptation = adaptations && adaptations.audio;
                return audioAdaptation ? audioAdaptation.getAvailableBitrates() : [];
            }
            /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */ , _proto.getManualAudioBitrate = function getManualAudioBitrate() {
                return this._priv_bitrateInfos.manualBitrates.audio.getValue();
            }
            /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */ , _proto.getManualVideoBitrate = function getManualVideoBitrate() {
                return this._priv_bitrateInfos.manualBitrates.video.getValue();
            }
            /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */ , _proto.getVideoBitrate = function getVideoBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.video) return representations.video.bitrate;
            }
            /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */ , _proto.getAudioBitrate = function getAudioBitrate() {
                var representations = this.getCurrentRepresentations();
                if (representations && representations.audio) return representations.audio.bitrate;
            }
            /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */ , _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
                return this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
            }
            /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */ , _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
                return this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
            }
            /**
   * Play/Resume the current video.
   * @returns {Promise}
   */ , _proto.play = function play() {
                var _this3 = this;
                if (!this.videoElement) throw new Error("Disposed player");
                var playPromise = this.videoElement.play();
                /* tslint:disable no-unbound-method */                return null == playPromise || "function" != typeof playPromise.catch ? promise.a.resolve() : playPromise.catch(function(error) {
                    if ("NotAllowedError" === error.name) {
                        var warning = new media_error.a("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());
                        _this3.trigger("warning", warning);
                    }
                    throw error;
                });
            }
            /**
   * Pause the current video.
   */ , _proto.pause = function pause() {
                if (!this.videoElement) throw new Error("Disposed player");
                this.videoElement.pause();
            }
            /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */ , _proto.seekTo = function seekTo(time) {
                if (!this.videoElement) throw new Error("Disposed player");
                if (!this._priv_contentInfos) throw new Error("player: no content loaded");
                var positionWanted, _this$_priv_contentIn8 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn8.isDirectFile, manifest = _this$_priv_contentIn8.manifest;
                if (!isDirectFile && null == manifest) throw new Error("player: the content did not load yet");
                if ("number" == typeof time) positionWanted = time; else if ("object" == typeof time) {
                    var timeObj = time, currentTs = this.videoElement.currentTime;
                    if (null != timeObj.relative) positionWanted = currentTs + timeObj.relative; else if (null != timeObj.position) positionWanted = timeObj.position; else {
                        if (null == timeObj.wallClockTime) throw new Error('invalid time object. You must set one of the following properties: "relative", "position" or "wallClockTime"');
                        positionWanted = isDirectFile || null == manifest ? timeObj.wallClockTime : timeObj.wallClockTime - (manifest.availabilityStartTime || 0);
                    }
                }
                if (void 0 === positionWanted) throw new Error("invalid time given");
                return this.videoElement.currentTime = positionWanted;
            }
            /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */ , _proto.isFullscreen = function isFullscreen() {
                return Object(warn_once.a)("isFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.b)();
            }
            /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */ , _proto.setFullscreen = function setFullscreen(goFull) {
                if (void 0 === goFull && (goFull = !0), Object(warn_once.a)("setFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                !this.videoElement) throw new Error("Disposed player");
                goFull ? Object(fullscreen.c)(this.videoElement) : Object(fullscreen.a)();
            }
            /**
   * Exit from full screen mode.
   * @deprecated
   */ , _proto.exitFullscreen = function exitFullscreen() {
                Object(warn_once.a)("exitFullscreen is deprecated. Fullscreen management should now be managed by the application"), 
                Object(fullscreen.a)();
            }
            /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */ , _proto.getVolume = function getVolume() {
                if (!this.videoElement) throw new Error("Disposed player");
                return this.videoElement.volume;
            }
            /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */ , _proto.setVolume = function setVolume(volume) {
                if (!this.videoElement) throw new Error("Disposed player");
                var videoElement = this.videoElement;
                volume !== videoElement.volume && (videoElement.volume = volume, this.trigger("volumeChange", volume));
            }
            /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */ , _proto.isMute = function isMute() {
                return !this.getVolume();
            }
            /**
   * Set the volume to 0 and save current one for when unmuted.
   */ , _proto.mute = function mute() {
                this._priv_mutedMemory = this.getVolume(), this.setVolume(0);
            }
            /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */ , _proto.unMute = function unMute() {
                0 === this.getVolume() && this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
            }
            /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */ , _proto.setVideoBitrate = function setVideoBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.video.next(btr);
            }
            /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */ , _proto.setAudioBitrate = function setAudioBitrate(btr) {
                this._priv_bitrateInfos.manualBitrates.audio.next(btr);
            }
            /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */ , _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
                this._priv_bitrateInfos.maxAutoBitrates.video.next(btr);
            }
            /**
   * Update the maximum audio bitrate the user can switch to.
   * @param {Number} btr
   */ , _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
                this._priv_bitrateInfos.maxAutoBitrates.audio.next(btr);
            }
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */ , _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
                this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
            }
            /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */ , _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
                this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
            }
            /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */ , _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
                this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
            }
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */ , _proto.getMaxBufferBehind = function getMaxBufferBehind() {
                return this._priv_bufferOptions.maxBufferBehind$.getValue();
            }
            /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */ , _proto.getMaxBufferAhead = function getMaxBufferAhead() {
                return this._priv_bufferOptions.maxBufferAhead$.getValue();
            }
            /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */ , _proto.getWantedBufferAhead = function getWantedBufferAhead() {
                return this._priv_bufferOptions.wantedBufferAhead$.getValue();
            }
            /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */ , _proto.getCurrentKeySystem = function getCurrentKeySystem() {
                if (!this.videoElement) throw new Error("Disposed player");
                return Object(get_current_key_system.a)(this.videoElement);
            }
            /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableAudioTracks(currentPeriod) : [];
            }
            /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableTextTracks = function getAvailableTextTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableTextTracks(currentPeriod) : [];
            }
            /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */ , _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
                if (!this._priv_contentInfos) return [];
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                return this._priv_trackManager && currentPeriod ? this._priv_trackManager.getAvailableVideoTracks(currentPeriod) : [];
            }
            /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */ , _proto.getAudioTrack = function getAudioTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                }
            }
            /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */ , _proto.getTextTrack = function getTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenTextTrack(currentPeriod);
                }
            }
            /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */ , _proto.getVideoTrack = function getVideoTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                }
            }
            /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no audio track.
   */ , _proto.setAudioTrack = function setAudioTrack(audioId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setAudioTrackByID(currentPeriod, audioId);
                } catch (e) {
                    throw new Error("player: unknown audio track");
                }
            }
            /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no text track.
   */ , _proto.setTextTrack = function setTextTrack(textId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setTextTrackByID(currentPeriod, textId);
                } catch (e) {
                    throw new Error("player: unknown text track");
                }
            }
            /**
   * Disable subtitles for the current content.
   */ , _proto.disableTextTrack = function disableTextTrack() {
                if (this._priv_contentInfos) {
                    var currentPeriod = this._priv_contentInfos.currentPeriod;
                    if (this._priv_trackManager && currentPeriod) return this._priv_trackManager.disableTextTrack(currentPeriod);
                }
            }
            /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackManager.
   * @throws Error - the given id is linked to no video track.
   */ , _proto.setVideoTrack = function setVideoTrack(videoId) {
                if (!this._priv_contentInfos) throw new Error("No content loaded");
                var currentPeriod = this._priv_contentInfos.currentPeriod;
                if (!this._priv_trackManager || !currentPeriod) throw new Error("No compatible content launched.");
                try {
                    this._priv_trackManager.setVideoTrackByID(currentPeriod, videoId);
                } catch (e) {
                    throw new Error("player: unknown video track");
                }
            }
            /**
   * Returns the current list of preferred audio tracks, in preference order.
   * @returns {Array.<Object>}
   */ , _proto.getPreferredAudioTracks = function getPreferredAudioTracks() {
                return this._priv_preferredAudioTracks.getValue();
            }
            /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */ , _proto.getPreferredTextTracks = function getPreferredTextTracks() {
                return this._priv_preferredTextTracks.getValue();
            }
            /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} tracks
   */ , _proto.setPreferredAudioTracks = function setPreferredAudioTracks(tracks) {
                if (!Array.isArray(tracks)) throw new Error("Invalid `setPreferredAudioTracks` argument. Should have been an Array.");
                return this._priv_preferredAudioTracks.next(tracks);
            }
            /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   */ , _proto.setPreferredTextTracks = function setPreferredTextTracks(tracks) {
                if (!Array.isArray(tracks)) throw new Error("Invalid `setPreferredTextTracks` argument. Should have been an Array.");
                return this._priv_preferredTextTracks.next(tracks);
            }
            /**
   * @returns {Array.<Object>|null}
   */ , _proto.getImageTrackData = function getImageTrackData() {
                return this._priv_contentInfos && this._priv_contentInfos.thumbnails;
            }
            /**
   * Get minimum seek-able position.
   * @returns {number}
   */ , _proto.getMinimumPosition = function getMinimumPosition() {
                if (!this._priv_contentInfos) return null;
                if (this._priv_contentInfos.isDirectFile) return 0;
                var manifest = this._priv_contentInfos.manifest;
                return null != manifest ? manifest.getMinimumPosition() : null;
            }
            /**
   * Get maximum seek-able position.
   * @returns {number}
   */ , _proto.getMaximumPosition = function getMaximumPosition() {
                if (!this._priv_contentInfos) return null;
                var _this$_priv_contentIn9 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn9.isDirectFile, manifest = _this$_priv_contentIn9.manifest;
                if (isDirectFile) {
                    if (!this.videoElement) throw new Error("Disposed player");
                    return this.videoElement.duration;
                }
                return null != manifest ? manifest.getMaximumPosition() : null;
            }
            /**
   * Reset all state properties relative to a playing content.
   * @private
   */ , _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
                var _this4 = this;
                // lock playback of new contents while cleaning up is pending
                                this._priv_contentLock$.next(!0), this._priv_contentInfos = null, 
                this._priv_trackManager = null, this._priv_contentEventsMemory = {};
                function freeUpContentLock() {
                    _this4._priv_contentLock$.next(!1);
                }
                this.videoElement ? Object(clear_eme_session.a)(this.videoElement).pipe(Object(catchError.a)(function() {
                    return empty.a;
                })).subscribe(noop.a, freeUpContentLock, freeUpContentLock) : freeUpContentLock();
            }
            /**
   * Store and emit new player state (e.g. text track, videoBitrate...).
   * We check for deep equality to avoid emitting 2 consecutive times the same
   * state.
   * @param {string} eventName
   * @param {*} value - its new value
   * @private
   */ , _proto._priv_triggerContentEvent = function _priv_triggerContentEvent(eventName, value) {
                var prev = this._priv_contentEventsMemory[eventName];
                deep_equal_default()(prev, value) || (this._priv_contentEventsMemory[eventName] = value, 
                this.trigger(eventName, value));
            }
            /**
   * Triggered each time the playback Observable emits.
   *
   * React to various events.
   *
   * @param {Object} event - payload emitted
   * @private
   */ , _proto._priv_onPlaybackEvent = function _priv_onPlaybackEvent(event) {
                switch (event.type) {
                  case "activePeriodChanged":
                    this._priv_onActivePeriodChanged(event.value);
                    break;

                  case "periodBufferReady":
                    this._priv_onPeriodBufferReady(event.value);
                    break;

                  case "periodBufferCleared":
                    this._priv_onPeriodBufferCleared(event.value);
                    break;

                  case "reloading-media-source":
                    this._priv_onReloadingMediaSource();
                    break;

                  case "representationChange":
                    this._priv_onRepresentationChange(event.value);
                    break;

                  case "adaptationChange":
                    this._priv_onAdaptationChange(event.value);
                    break;

                  case "bitrateEstimationChange":
                    this._priv_onBitrateEstimationChange(event.value);
                    break;

                  case "manifestReady":
                    this._priv_onManifestReady(event.value);
                    break;

                  case "warning":
                    this._priv_onPlaybackWarning(event.value);
                    break;

                  case "added-segment":
                    if (!this._priv_contentInfos) return void log.a.error("API: Added segment while no content is loaded");
 // Manage image tracks
                    // TODO Better way? Perhaps linked to an ImageSourceBuffer
                    // implementation
                                        var _event$value = event.value, content = _event$value.content, segmentData = _event$value.segmentData;
                    if ("image" === content.adaptation.type && null != segmentData && "bif" === segmentData.type) {
                        var imageData = segmentData.data;
 // TODO merge multiple data from the same track together
                                                this._priv_contentInfos.thumbnails = imageData, this.trigger("imageTrackUpdate", {
                            data: this._priv_contentInfos.thumbnails
                        });
                    }
                }
            }
            /**
   * Triggered when we received a fatal error.
   * Clean-up ressources and signal that the content has stopped on error.
   * @param {Error} error
   * @private
   */ , _proto._priv_onPlaybackError = function _priv_onPlaybackError(error) {
                var formattedError = formatError(error, {
                    defaultCode: "NONE",
                    defaultReason: "An unknown error stopped content playback."
                });
                formattedError.fatal = !0, this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_currentError = formattedError, log.a.error("API: The player stopped because of an error:", error), 
                this._priv_setPlayerState(PLAYER_STATES_STOPPED), // TODO This condition is here because the eventual callback called when the
                // player state is updated can launch a new content, thus the error will not
                // be here anymore, in which case triggering the "error" event is unwanted.
                // This is very ugly though, and we should probable have a better solution
                this._priv_currentError === formattedError && this.trigger("error", formattedError);
            }
            /**
   * Triggered when the playback Observable completes.
   * Clean-up ressources and signal that the content has ended.
   * @private
   */ , _proto._priv_onPlaybackFinished = function _priv_onPlaybackFinished() {
                this._priv_stopCurrentContent$.next(), this._priv_cleanUpCurrentContentState(), 
                this._priv_setPlayerState(PLAYER_STATES_ENDED);
            }
            /**
   * Triggered when we received a warning event during playback.
   * Trigger the right API event.
   * @param {Error} error
   * @private
   */ , _proto._priv_onPlaybackWarning = function _priv_onPlaybackWarning(error) {
                var formattedError = formatError(error, {
                    defaultCode: "NONE",
                    defaultReason: "An unknown error happened."
                });
                log.a.warn("API: Sending warning:", formattedError), this.trigger("warning", formattedError);
            }
            /**
   * Triggered when the Manifest has been loaded for the current content.
   * Initialize various private properties and emit initial event.
   * @param {Object} value
   * @private
   */ , _proto._priv_onManifestReady = function _priv_onManifestReady(_ref2) {
                var _this5 = this, manifest = _ref2.manifest;
                if (this._priv_contentInfos) {
                    this._priv_contentInfos.manifest = manifest;
                    var _this$_priv_contentIn10 = this._priv_contentInfos, initialAudioTrack = _this$_priv_contentIn10.initialAudioTrack, initialTextTrack = _this$_priv_contentIn10.initialTextTrack;
                    this._priv_trackManager = new track_manager_TrackManager({
                        preferredAudioTracks: void 0 === initialAudioTrack ? this._priv_preferredAudioTracks : new BehaviorSubject_BehaviorSubject([ initialAudioTrack ]),
                        preferredTextTracks: void 0 === initialTextTrack ? this._priv_preferredTextTracks : new BehaviorSubject_BehaviorSubject([ initialTextTrack ])
                    }), Object(event_emitter.b)(manifest, "manifestUpdate").pipe(Object(takeUntil.a)(this._priv_stopCurrentContent$)).subscribe(function() {
                        // Update the tracks chosen if it changed
                        _this5._priv_trackManager && _this5._priv_trackManager.update();
                    });
                } else log.a.error("API: The manifest is loaded but no content is.");
            }
            /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} value
   * @private
   */ , _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref3) {
                var period = _ref3.period;
                if (this._priv_contentInfos) {
                    // Emit intial events for the Period
                    if (this._priv_contentInfos.currentPeriod = period, this._priv_triggerContentEvent("periodChange", period), 
                    this._priv_triggerContentEvent("availableAudioTracksChange", this.getAvailableAudioTracks()), 
                    this._priv_triggerContentEvent("availableTextTracksChange", this.getAvailableTextTracks()), 
                    this._priv_triggerContentEvent("availableVideoTracksChange", this.getAvailableVideoTracks()), 
                    this._priv_trackManager) {
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(period), textTrack = this._priv_trackManager.getChosenTextTrack(period), videoTrack = this._priv_trackManager.getChosenVideoTrack(period);
                        this._priv_triggerContentEvent("audioTrackChange", audioTrack), this._priv_triggerContentEvent("textTrackChange", textTrack), 
                        this._priv_triggerContentEvent("videoTrackChange", videoTrack);
                    } else this._priv_triggerContentEvent("audioTrackChange", null), this._priv_triggerContentEvent("textTrackChange", null), 
                    this._priv_triggerContentEvent("videoTrackChange", null);
                    this._priv_triggerContentEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates()), 
                    this._priv_triggerContentEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());
                    var activeAudioRepresentations = this.getCurrentRepresentations();
                    if (activeAudioRepresentations && null != activeAudioRepresentations.audio) {
                        var bitrate = activeAudioRepresentations.audio.bitrate;
                        this._priv_triggerContentEvent("audioBitrateChange", null != bitrate ? bitrate : -1);
                    } else this._priv_triggerContentEvent("audioBitrateChange", -1);
                    var activeVideoRepresentations = this.getCurrentRepresentations();
                    if (activeVideoRepresentations && null != activeVideoRepresentations.video) {
                        var _bitrate = activeVideoRepresentations.video.bitrate;
                        this._priv_triggerContentEvent("videoBitrateChange", null != _bitrate ? _bitrate : -1);
                    } else this._priv_triggerContentEvent("videoBitrateChange", -1);
                } else log.a.error("API: The active period changed but no content is loaded");
            }
            /**
   * Triggered each times a new "PeriodBuffer" is ready.
   * Choose the right Adaptation for the Period and emit it.
   * @param {Object} value
   * @private
   */ , _proto._priv_onPeriodBufferReady = function _priv_onPeriodBufferReady(value) {
                var type = value.type, period = value.period, adaptation$ = value.adaptation$;
                switch (type) {
                  case "video":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialVideoTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new video period"), 
                    adaptation$.next(null));
                    break;

                  case "audio":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialAudioTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  case "text":
                    this._priv_trackManager ? (this._priv_trackManager.addPeriod(type, period, adaptation$), 
                    this._priv_trackManager.setInitialTextTrack(period)) : (log.a.error("API: TrackManager not instanciated for a new " + type + " period"), 
                    adaptation$.next(null));
                    break;

                  default:
                    var adaptations = period.adaptations[type];
                    adaptations && adaptations.length ? adaptation$.next(adaptations[0]) : adaptation$.next(null);
                }
            }
            /**
   * Triggered each times the we "remove" a PeriodBuffer.
   * @param {Object} value
   * @private
   */ , _proto._priv_onPeriodBufferCleared = function _priv_onPeriodBufferCleared(value) {
                var type = value.type, period = value.period;
 // Clean-up track choice from TrackManager
                                switch (type) {
                  case "audio":
                  case "text":
                  case "video":
                    this._priv_trackManager && this._priv_trackManager.removePeriod(type, period);
                }
 // Clean-up stored Representation and Adaptation information
                                if (null != this._priv_contentInfos) {
                    var _this$_priv_contentIn11 = this._priv_contentInfos, activeAdaptations = _this$_priv_contentIn11.activeAdaptations, activeRepresentations = _this$_priv_contentIn11.activeRepresentations;
                    if (activeAdaptations && activeAdaptations[period.id]) {
                        var activePeriodAdaptations = activeAdaptations[period.id];
                        delete activePeriodAdaptations[type], Object.keys(activePeriodAdaptations).length || delete activeAdaptations[period.id];
                    }
                    if (activeRepresentations && activeRepresentations[period.id]) {
                        var activePeriodRepresentations = activeRepresentations[period.id];
                        delete activePeriodRepresentations[type], Object.keys(activePeriodRepresentations).length || delete activeRepresentations[period.id];
                    }
                }
            }
            /**
   * Triggered each time the content is re-loaded on the MediaSource.
   */ , _proto._priv_onReloadingMediaSource = function _priv_onReloadingMediaSource() {
                this._priv_trackManager && this._priv_trackManager.resetPeriods();
            }
            /**
   * Triggered each times a new Adaptation is considered for the current
   * content.
   * Store given Adaptation and emit it if from the current Period.
   * @param {Object} value
   * @private
   */ , _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref4) {
                var type = _ref4.type, adaptation = _ref4.adaptation, period = _ref4.period;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeAdaptations
                    this._priv_contentInfos.activeAdaptations || (this._priv_contentInfos.activeAdaptations = {});
                    var _activeAdaptations$pe, _this$_priv_contentIn12 = this._priv_contentInfos, activeAdaptations = _this$_priv_contentIn12.activeAdaptations, currentPeriod = _this$_priv_contentIn12.currentPeriod, activePeriodAdaptations = activeAdaptations[period.id];
                    if (activePeriodAdaptations) activePeriodAdaptations[type] = adaptation; else activeAdaptations[period.id] = ((_activeAdaptations$pe = {})[type] = adaptation, 
                    _activeAdaptations$pe);
                    if (this._priv_trackManager && null != currentPeriod && null != period && period.id === currentPeriod.id) switch (type) {
                      case "audio":
                        var audioTrack = this._priv_trackManager.getChosenAudioTrack(currentPeriod);
                        this._priv_triggerContentEvent("audioTrackChange", audioTrack), this._priv_triggerContentEvent("availableAudioBitratesChange", this.getAvailableVideoBitrates());
                        break;

                      case "text":
                        var textTrack = this._priv_trackManager.getChosenTextTrack(currentPeriod);
                        this._priv_triggerContentEvent("textTrackChange", textTrack);
                        break;

                      case "video":
                        var videoTrack = this._priv_trackManager.getChosenVideoTrack(currentPeriod);
                        this._priv_triggerContentEvent("videoTrackChange", videoTrack), this._priv_triggerContentEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());
                    }
                } else log.a.error("API: The adaptations changed but no content is loaded");
            }
            /**
   * Triggered each times a new Representation is considered during playback.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} obj
   * @private
   */ , _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref5) {
                var type = _ref5.type, period = _ref5.period, representation = _ref5.representation;
                if (this._priv_contentInfos) {
                    // lazily create this._priv_contentInfos.activeRepresentations
                    this._priv_contentInfos.activeRepresentations || (this._priv_contentInfos.activeRepresentations = {});
                    var _activeRepresentation, _this$_priv_contentIn13 = this._priv_contentInfos, activeRepresentations = _this$_priv_contentIn13.activeRepresentations, currentPeriod = _this$_priv_contentIn13.currentPeriod, activePeriodRepresentations = activeRepresentations[period.id];
                    if (activePeriodRepresentations) activePeriodRepresentations[type] = representation; else activeRepresentations[period.id] = ((_activeRepresentation = {})[type] = representation, 
                    _activeRepresentation);
                    var bitrate = representation && representation.bitrate;
                    null != period && null != currentPeriod && currentPeriod.id === period.id && ("video" === type ? this._priv_triggerContentEvent("videoBitrateChange", null != bitrate ? bitrate : -1) : "audio" === type && this._priv_triggerContentEvent("audioBitrateChange", null != bitrate ? bitrate : -1));
                } else log.a.error("API: The representations changed but no content is loaded");
            }
            /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   * @private
   */ , _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref6) {
                var type = _ref6.type, bitrate = _ref6.bitrate;
                null != bitrate && (this._priv_bitrateInfos.lastBitrates[type] = bitrate), this._priv_triggerContentEvent("bitrateEstimationChange", {
                    type: type,
                    bitrate: bitrate
                });
            }
            /**
   * Triggered each time the videoElement alternates between play and pause.
   *
   * Emit the info through the right Subject.
   *
   * @param {Boolean} isPlaying
   * @private
   */ , _proto._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
                if (!this.videoElement) throw new Error("Disposed player");
                this._priv_playing$.next(isPlaying);
            }
            /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   * @private
   */ , _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
                this.trigger("nativeTextTracksChange", tracks);
            }
            /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   * @private
   */ , _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
                this.state !== newState && (this.state = newState, log.a.info("API: playerStateChange event", newState), 
                this.trigger("playerStateChange", newState));
            }
            /**
   * Triggered each time a new clock tick object is emitted.
   *
   * Trigger the right Player Event
   *
   * @param {Object} clockTick
   * @private
   */ , _proto._priv_triggerTimeChange = function _priv_triggerTimeChange(clockTick) {
                if (this._priv_contentInfos) {
                    if (this.state !== PLAYER_STATES_RELOADING) {
                        var _this$_priv_contentIn14 = this._priv_contentInfos, isDirectFile = _this$_priv_contentIn14.isDirectFile, manifest = _this$_priv_contentIn14.manifest;
                        if ((isDirectFile || null != manifest) && clockTick) {
                            var positionData = {
                                position: clockTick.currentTime,
                                duration: clockTick.duration,
                                playbackRate: clockTick.playbackRate,
                                // TODO fix higher up?
                                bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
                            };
                            null != manifest && manifest.isLive && 0 < clockTick.currentTime && (positionData.wallClockTime = clockTick.currentTime + (manifest.availabilityStartTime || 0), 
                            positionData.liveGap = manifest.getMaximumPosition() - clockTick.currentTime), this.trigger("positionUpdate", positionData);
                        }
                    }
                } else log.a.warn("API: Cannot perform time update: no content loaded.");
            }, public_api_createClass(Player, null, [ {
                key: "ErrorTypes",
                get: function get() {
                    return error_codes.b;
                }
                /**
     * All possible Error codes emitted by the RxPlayer.
     * @type {Object}
     */            }, {
                key: "ErrorCodes",
                get: function get() {
                    return error_codes.a;
                }
                /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     * @type {string}
     */            }, {
                key: "LogLevel",
                get: function get() {
                    return log.a.getLevel();
                },
                set: function set(logLevel) {
                    log.a.setLevel(logLevel);
                }
            } ]), Player;
        }(event_emitter.a);
        public_api_Player.version = 
        /*PLAYER_VERSION*/
        "3.16.1";
        /* harmony default export */ var api = public_api_Player;
        // CONCATENATED MODULE: ./src/core/api/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */
        // set initial features according to environment variables
        !
        // CONCATENATED MODULE: ./src/features/initialize_features.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */
        function initializeFeaturesObject() {
            features.a.emeManager = __webpack_require__(156).default, features.a.imageBuffer = __webpack_require__(202).default, 
            features.a.imageParser = __webpack_require__(177).default, features.a.transports.smooth = __webpack_require__(196).default, 
            features.a.transports.dash = __webpack_require__(195).default, features.a.nativeTextTracksBuffer = __webpack_require__(200).default, 
            features.a.nativeTextTracksParsers.vtt = __webpack_require__(201).default, features.a.nativeTextTracksParsers.ttml = __webpack_require__(203).default, 
            features.a.nativeTextTracksParsers.sami = __webpack_require__(179).default, features.a.nativeTextTracksParsers.srt = __webpack_require__(180).default, 
            features.a.htmlTextTracksBuffer = __webpack_require__(199).default, features.a.htmlTextTracksParsers.sami = __webpack_require__(181).default, 
            features.a.htmlTextTracksParsers.ttml = __webpack_require__(198).default, features.a.htmlTextTracksParsers.srt = __webpack_require__(182).default, 
            features.a.htmlTextTracksParsers.vtt = __webpack_require__(197).default, features.a.directfile = __webpack_require__(183).default;
        }();
        /* harmony default export */ __webpack_exports__.default = api;
        /***/    }, 
    /* 195 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/transports/utils/document_manifest_loader.ts + 1 modules
        var document_manifest_loader = __webpack_require__(121), of = __webpack_require__(23), features = __webpack_require__(10), request = __webpack_require__(18);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
                // CONCATENATED MODULE: ./src/transports/dash/image_pipelines.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} args
 * @returns {Observable}
 */
        function imageLoader(_ref) {
            var segment = _ref.segment;
            if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                type: "data-created",
                value: {
                    responseData: null
                }
            });
            var mediaURL = segment.mediaURL;
            return Object(request.a)({
                url: mediaURL,
                responseType: "arraybuffer",
                sendProgressEvents: !0
            });
        }
        /**
 * @param {Object} args
 * @returns {Observable}
 */        function imageParser(_ref2) {
            var response = _ref2.response, content = _ref2.content, segment = content.segment, period = content.period, data = response.data;
            if (response.isChunked) throw new Error("Image data should not be downloaded in chunks");
 // TODO image Parsing should be more on the sourceBuffer side, no?
                        if (null === data || null == features.a.imageParser) return Object(of.a)({
                chunkData: null,
                chunkInfos: 0 < segment.timescale ? {
                    duration: segment.isInit ? 0 : segment.duration,
                    time: segment.isInit ? -1 : segment.time,
                    timescale: segment.timescale
                } : null,
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            });
            var bifObject = features.a.imageParser(new Uint8Array(data)), thumbsData = bifObject.thumbs;
            return Object(of.a)({
                chunkData: {
                    data: thumbsData,
                    start: 0,
                    end: Number.MAX_VALUE,
                    timescale: 1,
                    type: "bif"
                },
                chunkInfos: {
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: bifObject.timescale
                },
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            });
        }
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
                var object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), combineLatest = __webpack_require__(213), filter = __webpack_require__(168), map = __webpack_require__(34), mergeMap = __webpack_require__(44), src_manifest = __webpack_require__(85), array_find = __webpack_require__(9), id_generator = __webpack_require__(50), resolve_url = __webpack_require__(37), check_manifest_ids = __webpack_require__(104), log = __webpack_require__(0);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_clock_offset.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */
        function getClockOffset(serverClock) {
            var httpOffset = Date.parse(serverClock) - performance.now();
            if (!isNaN(httpOffset)) return httpOffset;
            log.a.warn("DASH Parser: Invalid clock received: ", serverClock);
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_http_utc-timing_url.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */        function getHTTPUTCTimingURL(mpdIR) {
            var UTCTimingHTTP = mpdIR.children.utcTimings.filter(function(utcTiming) {
                return "urn:mpeg:dash:utc:http-iso:2014" === utcTiming.schemeIdUri && null != utcTiming.value;
            });
            return 0 < UTCTimingHTTP.length ? UTCTimingHTTP[0].value : void 0;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_last_time_from_adaptation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */        function getLastPositionFromAdaptation(adaptation) {
            for (var representations = adaptation.representations, min = null, i = 0; i < representations.length; i++) {
                var lastPosition = representations[i].index.getLastPosition();
                if (void 0 === lastPosition) 
                // we cannot tell
                return;
                null !== lastPosition && (min = null == min ? lastPosition : Math.min(min, lastPosition));
            }
            return null === min ? null : min;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_maximum_position.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} manifest
 * @returns {number | undefined}
 */        function getMaximumPosition(manifest) {
            for (var i = manifest.periods.length - 1; 0 <= i; i--) {
                var periodAdaptations = manifest.periods[i].adaptations, firstAudioAdaptationFromPeriod = null == periodAdaptations.audio ? void 0 : periodAdaptations.audio[0], firstVideoAdaptationFromPeriod = null == periodAdaptations.video ? void 0 : periodAdaptations.video[0];
                if (null != firstAudioAdaptationFromPeriod || null != firstVideoAdaptationFromPeriod) {
                    // null == no segment
                    var maximumAudioPosition = null, maximumVideoPosition = null;
                    if (null != firstAudioAdaptationFromPeriod) {
                        var lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);
                        if (void 0 === lastPosition) return;
                        maximumAudioPosition = lastPosition;
                    }
                    if (null != firstVideoAdaptationFromPeriod) {
                        var _lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);
                        if (void 0 === _lastPosition) return;
                        maximumVideoPosition = _lastPosition;
                    }
                    if (null != firstAudioAdaptationFromPeriod && null === maximumAudioPosition || null != firstVideoAdaptationFromPeriod && null === maximumVideoPosition) return void log.a.info("DASH Parser: found Period with no segment. ", "Going to previous one to calculate last position");
                    if (null != maximumVideoPosition) return null != maximumAudioPosition ? Math.min(maximumAudioPosition, maximumVideoPosition) : maximumVideoPosition;
                    if (null != maximumAudioPosition) return maximumAudioPosition;
                }
            }
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_first_time_from_adaptation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns "first time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */        function getFirstPositionFromAdaptation(adaptation) {
            for (var representations = adaptation.representations, max = null, i = 0; i < representations.length; i++) {
                var firstPosition = representations[i].index.getFirstPosition();
                if (void 0 === firstPosition) 
                // we cannot tell
                return;
                null !== firstPosition && (max = null == max ? firstPosition : Math.max(max, firstPosition));
            }
            return null === max ? null : max;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_minimum_position.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} manifest
 * @returns {number | undefined}
 */        function getMinimumPosition(manifest) {
            for (var i = 0; i <= manifest.periods.length - 1; i++) {
                var periodAdaptations = manifest.periods[i].adaptations, firstAudioAdaptationFromPeriod = null == periodAdaptations.audio ? void 0 : periodAdaptations.audio[0], firstVideoAdaptationFromPeriod = null == periodAdaptations.video ? void 0 : periodAdaptations.video[0];
                if (null != firstAudioAdaptationFromPeriod || null != firstVideoAdaptationFromPeriod) {
                    // null == no segment
                    var minimumAudioPosition = null, minimumVideoPosition = null;
                    if (null != firstAudioAdaptationFromPeriod) {
                        var firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);
                        if (void 0 === firstPosition) return;
                        minimumAudioPosition = firstPosition;
                    }
                    if (null != firstVideoAdaptationFromPeriod) {
                        var _firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);
                        if (void 0 === _firstPosition) return;
                        minimumVideoPosition = _firstPosition;
                    }
                    if (null != firstAudioAdaptationFromPeriod && null === minimumAudioPosition || null != firstVideoAdaptationFromPeriod && null === minimumVideoPosition) return void log.a.info("DASH Parser: found Period with no segment. ", "Going to next one to calculate first position");
                    if (null != minimumVideoPosition) return null != minimumAudioPosition ? Math.max(minimumAudioPosition, minimumVideoPosition) : minimumVideoPosition;
                    if (null != minimumAudioPosition) return minimumAudioPosition;
                }
            }
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_minimum_and_maximum_positions.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get presentation live gap from manifest information.
 * @param {Object} manifest
 * @returns {number}
 */        function getMinimumAndMaximumPosition(manifest) {
            if (0 === manifest.periods.length) throw new Error("DASH Parser: no period available for a live content");
            return [ getMinimumPosition(manifest), getMaximumPosition(manifest) ];
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentComponent(root) {
            for (var ret = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    ret.id = attribute.value;
                    break;

                  case "lang":
                    ret.language = attribute.value;
                    break;

                  case "contentType":
                    ret.contentType = attribute.value;
                    break;

                  case "par":
                    ret.par = attribute.value;
                }
            }
            return ret;
        }
        // EXTERNAL MODULE: ./src/utils/byte_parsing.ts
                var byte_parsing = __webpack_require__(1);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @returns {Object}
 */        function parseContentProtection(root) {
            for (var schemeIdUri, value, keyId, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                    break;

                  case "cenc:default_KID":
                    keyId = Object(byte_parsing.j)(attribute.value.replace(/-/g, ""));
                }
            }
            return {
                schemeIdUri: schemeIdUri,
                value: value,
                keyId: keyId
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/utils.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/, rangeRe = /([0-9]+)-([0-9]+)/;
        /**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */
        function parseBoolean(str) {
            return "true" === str;
        }
        /**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */        function parseIntOrBoolean(str) {
            return "true" === str || "false" !== str && parseInt(str, 10);
        }
        /**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */        function parseDateTime(str) {
            return new Date(Date.parse(str)).getTime() / 1e3;
        }
        /**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */        function parseDuration(date) {
            if (!date) return 0;
            var match = iso8601Duration.exec(date);
            if (null == match) throw new Error(date + " is not a valid ISO8601 duration");
            return 365 * parseFloat(match[2] || "0") * 24 * 60 * 60 + 30 * parseFloat(match[4] || "0") * 24 * 60 * 60 + // not precise +
            24 * parseFloat(match[6] || "0") * 60 * 60 + 60 * parseFloat(match[8] || "0") * 60 + 60 * parseFloat(match[10] || "0") + parseFloat(match[12] || "0");
        }
        /**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */        function parseByteRange(str) {
            var match = rangeRe.exec(str);
            return match ? [ +match[1], +match[2] ] : null;
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseScheme(root) {
            for (var schemeIdUri, value, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "schemeIdUri":
                    schemeIdUri = attribute.value;
                    break;

                  case "value":
                    value = attribute.value;
                }
            }
            return {
                schemeIdUri: schemeIdUri,
                value: value
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseInitialization(root) {
            for (var parsedInitialization = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "range":
                    var range = parseByteRange(attribute.value);
                    null == range ? log.a.warn('DASH: invalid range ("' + attribute.value + '")') : parsedInitialization.range = range;
                    break;

                  case "sourceURL":
                    parsedInitialization.media = attribute.value;
                }
            }
            return parsedInitialization;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentBase(root) {
            for (var attributes = {}, segmentBaseChildren = root.childNodes, i = 0; i < segmentBaseChildren.length; i++) if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentBaseChildren[i];
                "Initialization" === currentNode.nodeName && (attributes.initialization = parseInitialization(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.name) {
                  case "timescale":
                    var _timescale = parseInt(attribute.value, 10);
                    isNaN(_timescale) ? log.a.warn('DASH: invalid timescale ("' + attribute.value + '")') : attributes.timescale = _timescale;
                    break;

                  case "presentationTimeOffset":
                    var _presentationTimeOffset = parseFloat(attribute.value);
                    isNaN(_presentationTimeOffset) ? log.a.warn('DASH: invalid presentationTimeOffset ("' + attribute.value + '")') : attributes.presentationTimeOffset = _presentationTimeOffset;
                    break;

                  case "indexRange":
                    attributes.indexRange = parseByteRange(attribute.value) || void 0;
                    break;

                  case "indexRangeExact":
                    attributes.indexRangeExact = parseBoolean(attribute.value);
                    break;

                  case "availabilityTimeOffset":
                    var availabilityTimeOffset = parseFloat(attribute.value);
                    isNaN(availabilityTimeOffset) ? log.a.warn('DASH: invalid availabilityTimeOffset ("' + attribute.value + '")') : attributes.availabilityTimeOffset = availabilityTimeOffset;
                    break;

                  case "availabilityTimeComplete":
                    attributes.availabilityTimeComplete = parseBoolean(attribute.value);
                    break;

                  case "duration":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid duration ("' + attribute.value + '")') : attributes.duration = duration;
                    break;

                  case "startNumber":
                    var startNumber = parseInt(attribute.value, 10);
                    isNaN(startNumber) ? log.a.warn('DASH: invalid startNumber ("' + attribute.value + '")') : attributes.startNumber = startNumber;
                }
            }
            var timescale = null == attributes.timescale ? 1 : attributes.timescale, indexRangeExact = !!attributes.indexRangeExact, availabilityTimeComplete = null == attributes.availabilityTimeComplete || attributes.availabilityTimeComplete;
            return object_assign_default()(attributes, {
                availabilityTimeComplete: availabilityTimeComplete,
                indexRangeExact: indexRangeExact,
                timeline: [],
                timescale: timescale
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentURL(root) {
            for (var parsedSegmentURL = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "media":
                    parsedSegmentURL.media = attribute.value;
                    break;

                  case "indexRange":
                    var indexRange = parseByteRange(attribute.value) || void 0;
                    indexRange ? parsedSegmentURL.indexRange = indexRange : log.a.warn('DASH: invalid indexRange ("' + attribute.value + '")');
                    break;

                  case "index":
                    parsedSegmentURL.index = attribute.value;
                    break;

                  case "mediaRange":
                    var mediaRange = parseByteRange(attribute.value) || void 0;
                    mediaRange ? parsedSegmentURL.mediaRange = mediaRange : log.a.warn('DASH: invalid mediaRange ("' + attribute.value + '")');
                }
            }
            return parsedSegmentURL;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentList(root) {
            for (var base = parseSegmentBase(root), list = [], segmentListChildren = root.childNodes, i = 0; i < segmentListChildren.length; i++) if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = segmentListChildren[i];
                if ("SegmentURL" === currentNode.nodeName) {
                    var segmentURL = parseSegmentURL(currentNode);
                    list.push(segmentURL);
                }
            }
            var baseDuration = base.duration;
            if (null == baseDuration) throw new Error("Invalid SegmentList: no duration");
            return object_assign_default()(base, {
                list: list,
                duration: baseDuration
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/S.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseS(root) {
            for (var parsedS = {}, j = 0; j < root.attributes.length; j++) {
                var attribute = root.attributes[j];
                switch (attribute.name) {
                  case "t":
                    var start = parseInt(attribute.value, 10);
                    isNaN(start) ? log.a.warn('DASH: invalid t ("' + attribute.value + '")') : parsedS.start = start;
                    break;

                  case "d":
                    var duration = parseInt(attribute.value, 10);
                    isNaN(duration) ? log.a.warn('DASH: invalid d ("' + attribute.value + '")') : parsedS.duration = duration;
                    break;

                  case "r":
                    var repeatCount = parseInt(attribute.value, 10);
                    isNaN(repeatCount) ? log.a.warn('DASH: invalid r ("' + attribute.value + '")') : parsedS.repeatCount = repeatCount;
                }
            }
            return parsedS;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} root
 * @returns {Array.<Object>}
 */        function parseSegmentTimeline(root) {
            for (var parsedS = [], timelineChildren = root.childNodes, i = 0; i < timelineChildren.length; i++) if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = timelineChildren[i];
                if ("S" === currentElement.nodeName) {
                    var s = parseS(currentElement);
                    parsedS.push(s);
                }
            }
            return parsedS;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */        function parseInitializationAttribute(attrValue) {
            return {
                media: attrValue
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseSegmentTemplate(root) {
            for (var ret, index, media, bitstreamSwitching, timeline, base = parseSegmentBase(root), i = 0; i < root.childNodes.length; i++) if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = root.childNodes[i];
                "SegmentTimeline" === currentNode.nodeName && (timeline = parseSegmentTimeline(currentNode));
            }
            for (var _i = 0; _i < root.attributes.length; _i++) {
                var attribute = root.attributes[_i];
                switch (attribute.nodeName) {
                  case "initialization":
                    null == base.initialization && (base.initialization = parseInitializationAttribute(attribute.value));
                    break;

                  case "index":
                    index = attribute.value;
                    break;

                  case "media":
                    media = attribute.value;
                    break;

                  case "bitstreamSwitching":
                    bitstreamSwitching = parseBoolean(attribute.value);
                }
            }
            if (null != timeline) ret = object_assign_default()({}, base, {
                indexType: "timeline",
                timeline: timeline
            }); else {
                var segmentDuration = base.duration;
                if (null == segmentDuration) throw new Error("Invalid SegmentTemplate: no duration");
                ret = object_assign_default()({}, base, {
                    indexType: "template",
                    duration: segmentDuration
                });
            }
            return null != index && (ret.index = index), null != media && (ret.media = media), 
            null != bitstreamSwitching && (ret.bitstreamSwitching = bitstreamSwitching), ret;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */        function parseRepresentationChildren(representationChildren) {
            for (var children = {
                baseURL: ""
            }, i = 0; i < representationChildren.length; i++) if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = representationChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                }
            }
            return children;
        }
        /**
 * @param {Element} representationElement
 * @returns {Object}
 */        function parseRepresentationAttributes(representationElement) {
            for (var attributes = {}, i = 0; i < representationElement.attributes.length; i++) {
                var attribute = representationElement.attributes[i];
                switch (attribute.name) {
                  case "audioSamplingRate":
                    attributes.audioSamplingRate = attribute.value;
                    break;

                  case "bandwidth":
                    var bitrate = parseInt(attribute.value, 10);
                    isNaN(bitrate) ? log.a.warn('DASH: invalid bandwidth ("' + attribute.value + '")') : attributes.bitrate = bitrate;
                    break;

                  case "codecs":
                    attributes.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    attributes.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    attributes.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : attributes.height = height;
                    break;

                  case "id":
                    attributes.id = attribute.value;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : attributes.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : attributes.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    attributes.mimeType = attribute.value;
                    break;

                  case "profiles":
                    attributes.profiles = attribute.value;
                    break;

                  case "qualityRanking":
                    var qualityRanking = parseInt(attribute.value, 10);
                    isNaN(qualityRanking) ? log.a.warn('DASH: invalid qualityRanking ("' + attribute.value + '")') : attributes.qualityRanking = qualityRanking;
                    break;

                  case "segmentProfiles":
                    attributes.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : attributes.width = width;
                }
            }
            return attributes;
        }
        function createRepresentationIntermediateRepresentation(representationElement) {
            return {
                children: parseRepresentationChildren(representationElement.childNodes),
                attributes: parseRepresentationAttributes(representationElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parseAdaptationSetChildren(adaptationSetChildren) {
            for (var children = {
                baseURL: "",
                representations: []
            }, contentProtections = [], i = 0; i < adaptationSetChildren.length; i++) if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = adaptationSetChildren[i];
                switch (currentElement.nodeName) {
                  case "Accessibility":
                    children.accessibility = parseScheme(currentElement);
                    break;

                  case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;

                  case "ContentComponent":
                    children.contentComponent = parseContentComponent(currentElement);
                    break;

                  case "Representation":
                    var representation = createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    break;

                  case "Role":
                    null == children.roles ? children.roles = [ parseScheme(currentElement) ] : children.roles.push(parseScheme(currentElement));
                    break;

                  case "SupplementalProperty":
                    null == children.supplementalProperties ? children.supplementalProperties = [ parseScheme(currentElement) ] : children.supplementalProperties.push(parseScheme(currentElement));
                    break;

                  case "SegmentBase":
                    children.segmentBase = parseSegmentBase(currentElement);
                    break;

                  case "SegmentList":
                    children.segmentList = parseSegmentList(currentElement);
                    break;

                  case "SegmentTemplate":
                    children.segmentTemplate = parseSegmentTemplate(currentElement);
                    break;

                  case "ContentProtection":
                    var contentProtection = parseContentProtection(currentElement);
                    contentProtection && contentProtections.push(contentProtection);
 // case "Rating":
                    //   children.rating = currentElement;
                    //   break;
                    // case "Viewpoint":
                    //   children.viewpoint = currentElement;
                    //   break;
                                }
            }
            return contentProtections.length && (children.contentProtections = contentProtections), 
            children;
        }
        function parseAdaptationSetAttributes(root) {
            for (var parsedAdaptation = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    parsedAdaptation.id = attribute.value;
                    break;

                  case "group":
                    var group = parseInt(attribute.value, 10);
                    isNaN(group) ? log.a.warn('DASH: invalid group ("' + attribute.value + '")') : parsedAdaptation.group = group;
                    break;

                  case "lang":
                    parsedAdaptation.language = attribute.value;
                    break;

                  case "contentType":
                    parsedAdaptation.contentType = attribute.value;
                    break;

                  case "par":
                    parsedAdaptation.par = attribute.value;
                    break;

                  case "minBandwidth":
                    var minBitrate = parseInt(attribute.value, 10);
                    isNaN(minBitrate) ? log.a.warn('DASH: invalid minBandwidth ("' + attribute.value + '")') : parsedAdaptation.minBitrate = minBitrate;
                    break;

                  case "maxBandwidth":
                    var maxBitrate = parseInt(attribute.value, 10);
                    isNaN(maxBitrate) ? log.a.warn('DASH: invalid maxBandwidth ("' + attribute.value + '")') : parsedAdaptation.maxBitrate = maxBitrate;
                    break;

                  case "minWidth":
                    var minWidth = parseInt(attribute.value, 10);
                    isNaN(minWidth) ? log.a.warn('DASH: invalid minWidth ("' + attribute.value + '")') : parsedAdaptation.minWidth = minWidth;
                    break;

                  case "maxWidth":
                    var maxWidth = parseInt(attribute.value, 10);
                    isNaN(maxWidth) ? log.a.warn('DASH: invalid maxWidth ("' + attribute.value + '")') : parsedAdaptation.maxWidth = maxWidth;
                    break;

                  case "minHeight":
                    var minHeight = parseInt(attribute.value, 10);
                    isNaN(minHeight) ? log.a.warn('DASH: invalid minHeight ("' + attribute.value + '")') : parsedAdaptation.minHeight = minHeight;
                    break;

                  case "maxHeight":
                    var maxHeight = parseInt(attribute.value, 10);
                    isNaN(maxHeight) ? log.a.warn('DASH: invalid maxHeight ("' + attribute.value + '")') : parsedAdaptation.maxHeight = maxHeight;
                    break;

                  case "minFrameRate":
                    parsedAdaptation.minFrameRate = attribute.value;
                    break;

                  case "maxFrameRate":
                    parsedAdaptation.maxFrameRate = attribute.value;
                    break;

                  case "segmentAlignment":
                    var segmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof segmentAlignment && isNaN(segmentAlignment) ? log.a.warn('DASH: invalid segmentAlignment ("' + attribute.value + '")') : parsedAdaptation.segmentAlignment = segmentAlignment;
                    break;

                  case "subsegmentAlignment":
                    var subsegmentAlignment = parseIntOrBoolean(attribute.value);
                    "number" == typeof subsegmentAlignment && isNaN(subsegmentAlignment) ? log.a.warn('DASH: invalid subsegmentAlignment ("' + attribute.value + '")') : parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
                    break;

                  case "bitstreamSwitching":
                    parsedAdaptation.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "audioSamplingRate":
                    parsedAdaptation.audioSamplingRate = attribute.value;
                    break;

                  case "codecs":
                    parsedAdaptation.codecs = attribute.value;
                    break;

                  case "codingDependency":
                    parsedAdaptation.codingDependency = parseBoolean(attribute.value);
                    break;

                  case "frameRate":
                    parsedAdaptation.frameRate = attribute.value;
                    break;

                  case "height":
                    var height = parseInt(attribute.value, 10);
                    isNaN(height) ? log.a.warn('DASH: invalid height ("' + attribute.value + '")') : parsedAdaptation.height = height;
                    break;

                  case "maxPlayoutRate":
                    var maxPlayoutRate = parseFloat(attribute.value);
                    isNaN(maxPlayoutRate) ? log.a.warn('DASH: invalid maxPlayoutRate ("' + attribute.value + '")') : parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
                    break;

                  case "maximumSAPPeriod":
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    isNaN(maximumSAPPeriod) ? log.a.warn('DASH: invalid maximumSAPPeriod ("' + attribute.value + '")') : parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
                    break;

                  case "mimeType":
                    parsedAdaptation.mimeType = attribute.value;
                    break;

                  case "profiles":
                    parsedAdaptation.profiles = attribute.value;
                    break;

                  case "segmentProfiles":
                    parsedAdaptation.segmentProfiles = attribute.value;
                    break;

                  case "width":
                    var width = parseInt(attribute.value, 10);
                    isNaN(width) ? log.a.warn('DASH: invalid width ("' + attribute.value + '")') : parsedAdaptation.width = width;
                }
            }
            return parsedAdaptation;
        }
        function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
            return {
                children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
                attributes: parseAdaptationSetAttributes(adaptationSetElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */        function parsePeriodChildren(periodChildren) {
            for (var baseURL = "", adaptations = [], i = 0; i < periodChildren.length; i++) if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentElement = periodChildren[i];
                switch (currentElement.nodeName) {
                  case "BaseURL":
                    baseURL = currentElement.textContent || "";
                    break;

                  case "AdaptationSet":
                    var adaptation = createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                }
            }
            return {
                baseURL: baseURL,
                adaptations: adaptations
            };
        }
        /**
 * @param {Element} periodElement
 * @returns {Object}
 */        function parsePeriodAttributes(periodElement) {
            for (var res = {}, i = 0; i < periodElement.attributes.length; i++) {
                var attribute = periodElement.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "start":
                    var tempStart = parseDuration(attribute.value);
                    isNaN(tempStart) ? log.a.warn("DASH: Unrecognized start in the mpd:", attribute.value) : res.start = tempStart;
                    break;

                  case "duration":
                    var tempDuration = parseDuration(attribute.value);
                    isNaN(tempDuration) ? log.a.warn("DASH: Unrecognized duration in the mpd:", attribute.value) : res.duration = tempDuration;
                    break;

                  case "bitstreamSwitching":
                    res.bitstreamSwitching = parseBoolean(attribute.value);
                    break;

                  case "xlink:href":
                    res.xlinkHref = attribute.value;
                    break;

                  case "xlink:actuate":
                    res.xlinkActuate = attribute.value;
                }
            }
            return res;
        }
        function createPeriodIntermediateRepresentation(periodElement) {
            return {
                children: parsePeriodChildren(periodElement.childNodes),
                attributes: parsePeriodAttributes(periodElement)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */        function parseMPDChildren(mpdChildren) {
            for (var baseURL = "", locations = [], periods = [], utcTimings = [], i = 0; i < mpdChildren.length; i++) if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
                var currentNode = mpdChildren[i];
                switch (currentNode.nodeName) {
                  case "BaseURL":
                    baseURL = currentNode.textContent || "";
                    break;

                  case "Location":
                    locations.push(currentNode.textContent || "");
                    break;

                  case "Period":
                    var period = createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                    break;

                  case "UTCTiming":
                    var utcTiming = parseScheme(currentNode);
                    utcTimings.push(utcTiming);
                }
            }
            return {
                baseURL: baseURL,
                locations: locations,
                periods: periods,
                utcTimings: utcTimings
            };
        }
        /**
 * @param {Element} root
 * @returns {Object}
 */        function parseMPDAttributes(root) {
            for (var res = {}, i = 0; i < root.attributes.length; i++) {
                var attribute = root.attributes[i];
                switch (attribute.name) {
                  case "id":
                    res.id = attribute.value;
                    break;

                  case "profiles":
                    res.profiles = attribute.value;
                    break;

                  case "type":
                    res.type = attribute.value;
                    break;

                  case "availabilityStartTime":
                    res.availabilityStartTime = +parseDateTime(attribute.value);
                    break;

                  case "availabilityEndTime":
                    res.availabilityEndTime = +parseDateTime(attribute.value);
                    break;

                  case "publishTime":
                    res.publishTime = +parseDateTime(attribute.value);
                    break;

                  case "mediaPresentationDuration":
                    res.duration = parseDuration(attribute.value);
                    break;

                  case "minimumUpdatePeriod":
                    res.minimumUpdatePeriod = parseDuration(attribute.value);
                    break;

                  case "minBufferTime":
                    res.minBufferTime = parseDuration(attribute.value);
                    break;

                  case "timeShiftBufferDepth":
                    res.timeShiftBufferDepth = parseDuration(attribute.value);
                    break;

                  case "suggestedPresentationDelay":
                    res.suggestedPresentationDelay = parseDuration(attribute.value);
                    break;

                  case "maxSegmentDuration":
                    res.maxSegmentDuration = parseDuration(attribute.value);
                    break;

                  case "maxSubsegmentDuration":
                    res.maxSubsegmentDuration = parseDuration(attribute.value);
                }
            }
            return res;
        }
        function createMPDIntermediateRepresentation(root) {
            return {
                children: parseMPDChildren(root.childNodes),
                attributes: parseMPDAttributes(root)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_availability_start_time.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
            return "dynamic" !== rootAttributes.type ? 0 : null == rootAttributes.availabilityStartTime ? null == referenceDateTime ? 0 : referenceDateTime : rootAttributes.availabilityStartTime;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_duration.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parse_duration_parseDuration(rootAttributes, parsedPeriods) {
            if (null != rootAttributes.duration) return rootAttributes.duration;
            if ("dynamic" !== rootAttributes.type && parsedPeriods.length) {
                var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
                if (null != lastPeriod.end) return lastPeriod.end;
                if (null != lastPeriod.duration) return lastPeriod.start + lastPeriod.duration;
            }
        }
        // EXTERNAL MODULE: ./src/utils/flat_map.ts
                var flat_map = __webpack_require__(86), object_values = __webpack_require__(74);
        // EXTERNAL MODULE: ./src/utils/object_values.ts
                // CONCATENATED MODULE: ./src/parsers/manifest/dash/flatten_overlapping_periods.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */
        function flattenOverlappingPeriods(parsedPeriods) {
            if (0 === parsedPeriods.length) return [];
            for (var flattenedPeriods = [ parsedPeriods[0] ], i = 1; i < parsedPeriods.length; i++) {
                for (var parsedPeriod = parsedPeriods[i], lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1]; null == lastFlattenedPeriod.duration || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start; ) log.a.warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod), 
                lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start, lastFlattenedPeriod.end = parsedPeriod.start, 
                lastFlattenedPeriod.duration <= 0 && (flattenedPeriods.pop(), lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1]);
                flattenedPeriods.push(parsedPeriod);
            }
            return flattenedPeriods;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/get_periods_time_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */        function getPeriodsTimeInformation(periodsIR, manifestInfos) {
            var periodsTimeInformation = [];
            return periodsIR.forEach(function(currentPeriod, i) {
                var periodStart, periodDuration;
                if (null != currentPeriod.attributes.start) periodStart = currentPeriod.attributes.start; else if (0 === i) periodStart = manifestInfos.isDynamic && null != manifestInfos.availabilityStartTime ? manifestInfos.availabilityStartTime : 0; else {
                    // take time information from previous period
                    var prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];
                    if (null == prevPeriodInfos || null == prevPeriodInfos.periodEnd) throw new Error("Missing start time when parsing periods.");
                    periodStart = prevPeriodInfos.periodEnd;
                }
                var nextPeriod = periodsIR[i + 1];
                null != currentPeriod.attributes.duration ? periodDuration = currentPeriod.attributes.duration : i === periodsIR.length - 1 ? periodDuration = manifestInfos.duration : null != nextPeriod.attributes.start && (periodDuration = nextPeriod.attributes.start - periodStart);
                var periodEnd = null != periodDuration ? periodStart + periodDuration : void 0;
                periodsTimeInformation.push({
                    periodStart: periodStart,
                    periodDuration: periodDuration,
                    periodEnd: periodEnd
                });
            }), periodsTimeInformation;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/manifest_bounds_calculator.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * That task can be an hard for live DASH contents: it depends on a
 * `timeShiftBufferDepth` defined in the MPD and on the maximum possible
 * position.
 *
 * The latter can come from either a clock synchronization mechanism or the
 * indexing schemes (e.g. SegmentTemplate, SegmentTimeline etc.) of the last
 * Periods.
 * As such, it might only be known once a large chunk of the MPD has already
 * been parsed.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 *
 * @example
 * ```js
 * const manifestBoundsCalculator = new ManifestBoundsCalculator();
 *
 * // let's imagine a property `index` on a Representation which need to obtain
 * // the last position at any time
 * someRepresentation.index = new TemplateRepresentationIndex({
 *   // ...
 *   manifestBoundsCalculator // for now, `getLastPosition` will return `undefined`
 * });
 *
 * // ...
 * // Let's imagine a function which try to guess the last position based on a
 * // given parsed period
 * const lastPosition = getMaximumBound(somePeriod);
 * if (lastPosition != null) {
 *   const positionTime = performance.now() / 1000;
 *   manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
 *   // `getLastPosition` will now be correctly communicate the last position
 *   // (it returned `undefined` until then).
 * }
 * ```
 * @class ManifestBoundsCalculator
 */        var ManifestBoundsCalculator = 
        /* */
        function() {
            function ManifestBoundsCalculator(args) {
                this._isDynamic = args.isDynamic, this._timeShiftBufferDepth = args.isDynamic && null != args.timeShiftBufferDepth ? args.timeShiftBufferDepth : null;
            }
            /**
   * Set the last position and the position time (the value of `performance.now()`
   * at the time that position was true converted into seconds).
   *
   * @example
   * Example if you trust `Date.now()` to give you a reliable offset:
   * ```js
   * const lastPosition = Date.now();
   * const positionTime = performance.now() / 1000;
   * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
   * ```
   *
   * @param {number} lastPositionOffset
   */            var _proto = ManifestBoundsCalculator.prototype;
            return _proto.setLastPosition = function setLastPosition(lastPosition, positionTime) {
                this._lastPosition = lastPosition, this._positionTime = positionTime;
            }
            /**
   * Returns `true` if the last position and the position time
   * (for live content only) have been comunicated.
   * `false` otherwise.
   * @returns {boolean}
   */ , _proto.lastPositionIsKnown = function lastPositionIsKnown() {
                return this._isDynamic ? null != this._positionTime && null != this._lastPosition : null != this._lastPosition;
            }
            /**
   * Get minimum bound of content.
   * @return {number|undefined}
   */ , _proto.getMinimumBound = function getMinimumBound() {
                if (!this._isDynamic || null === this._timeShiftBufferDepth) return 0;
                var maximumBound = this.getMaximumBound();
                return void 0 !== maximumBound ? maximumBound - this._timeShiftBufferDepth : void 0;
            }
            /**
   * Calculate the current maximum bound by using both the calculated
   * last position and the timeshift buffer depth.
   * `undefined` if the last position has never been communicated.
   * @return {number|undefined}
   */ , _proto.getMaximumBound = function getMaximumBound() {
                return this._isDynamic && null != this._positionTime && null != this._lastPosition ? Math.max(this._lastPosition - this._positionTime + performance.now() / 1e3, 0) : this._lastPosition;
            }, ManifestBoundsCalculator;
        }(), array_includes = __webpack_require__(12), KNOWN_ADAPTATION_TYPES = [ "audio", "video", "text", "image" ], SUPPORTED_TEXT_TYPES = [ "subtitle", "caption" ];
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                /**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
        function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
            function fromMimeType(mimeType, roles) {
                var topLevel = mimeType.split("/")[0];
                return Object(array_includes.a)(KNOWN_ADAPTATION_TYPES, topLevel) ? topLevel : "application/bif" === mimeType ? "image" : "application/ttml+xml" === mimeType ? "text" : // manage DASH-IF mp4-embedded subtitles and metadata
                "application/mp4" === mimeType ? null != roles && null != Object(array_find.a)(roles, function(role) {
                    return "urn:mpeg:dash:role:2011" === role.schemeIdUri && Object(array_includes.a)(SUPPORTED_TEXT_TYPES, role.value);
                }) ? "text" : "metadata" : void 0;
            }
            function fromCodecs(codecs) {
                switch (codecs.substring(0, 3)) {
                  case "avc":
                  case "hev":
                  case "hvc":
                  case "vp8":
                  case "vp9":
                  case "av1":
                    return "video";

                  case "vtt":
                    return "text";

                  case "bif":
                    return "image";
                }
                switch (codecs.substring(0, 4)) {
                  case "mp4a":
                    return "audio";

                  case "wvtt":
                  case "stpp":
                    return "text";
                }
            }
            if (null != adaptationMimeType) {
                var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
                if (null != typeFromMimeType) return typeFromMimeType;
            }
            if (null != adaptationCodecs) {
                var typeFromCodecs = fromCodecs(adaptationCodecs);
                if (null != typeFromCodecs) return typeFromCodecs;
            }
            for (var representationMimeTypes = representations.map(function(representation) {
                return representation.attributes.mimeType;
            }).filter(function(mimeType) {
                return null != mimeType;
            }), representationCodecs = representations.map(function(representation) {
                return representation.attributes.codecs;
            }).filter(function(codecs) {
                return null != codecs;
            }), i = 0; i < representationMimeTypes.length; i++) {
                var representationMimeType = representationMimeTypes[i];
                if (null != representationMimeType) {
                    var _typeFromMimeType = fromMimeType(representationMimeType, adaptationRoles);
                    if (null != _typeFromMimeType) return _typeFromMimeType;
                }
            }
            for (var _i = 0; _i < representationCodecs.length; _i++) {
                var codecs = representationCodecs[_i];
                if (null != codecs) {
                    var _typeFromMimeType2 = fromCodecs(codecs);
                    if (null != _typeFromMimeType2) return _typeFromMimeType2;
                }
            }
            return "unknown";
        }
        // EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
                var index_helpers = __webpack_require__(13);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */        function get_init_segment_getInitSegment(index) {
            var initialization = index.initialization;
            return {
                id: "init",
                isInit: !0,
                time: 0,
                duration: 0,
                range: initialization && initialization.range || void 0,
                indexRange: index.indexRange || void 0,
                mediaURL: initialization ? initialization.mediaURL : null,
                timescale: index.timescale,
                timestampOffset: -index.indexTimeOffset / index.timescale
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/tokens.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */        function padLeftWithZeros(n, l) {
            var nToString = n.toString();
            return nToString.length >= l ? nToString : (new Array(l + 1).join("0") + nToString).slice(-l);
        }
        function processFormatedToken(replacer) {
            return function(_match, _format, widthStr) {
                var width = widthStr ? parseInt(widthStr, 10) : 1;
                return padLeftWithZeros("" + replacer, width);
            };
        }
        /**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function createIndexURL(representationURL, media, id, bitrate) {
            return replaceRepresentationDASHTokens(Object(resolve_url.a)(representationURL, media), id, bitrate);
        }
        /**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */        function replaceRepresentationDASHTokens(path, id, bitrate) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate || 0));
        }
        /**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number} time
 * @param {number} number
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */        function replaceSegmentDASHTokens(path, time, number) {
            return -1 === path.indexOf("$") ? path : path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == number) throw new Error("Segment number not defined in a $Number$ scheme");
                return processFormatedToken(number)(_x, _y, widthStr);
            }).replace(/\$Time(|\%0(\d+)d)\$/g, function(_x, _y, widthStr) {
                if (null == time) throw new Error("Segment time not defined in a $Time$ scheme");
                return processFormatedToken(time)(_x, _y, widthStr);
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_segments_from_timeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */        function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
            var diff = wantedTime - segmentStartTime;
            return 0 < diff ? Math.floor(diff / segmentDuration) : 0;
        }
        /**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @returns {Array.<Object>}
 */        function getSegmentsFromTimeline(index, from, durationWanted, maximumTime) {
            for (var scaledUp = Object(index_helpers.e)(from, index), scaledTo = Object(index_helpers.e)(from + durationWanted, index), timeline = index.timeline, timescale = index.timescale, mediaURL = index.mediaURL, startNumber = index.startNumber, currentNumber = null != startNumber ? startNumber : void 0, segments = [], timelineLength = timeline.length, maxEncounteredDuration = timeline.length && timeline[0].duration || 0, i = 0; i < timelineLength; i++) {
                var timelineItem = timeline[i], duration = timelineItem.duration, start = timelineItem.start, range = timelineItem.range;
                maxEncounteredDuration = Math.max(maxEncounteredDuration, duration);
                for (var repeat = Object(index_helpers.a)(timelineItem, timeline[i + 1], maximumTime), segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp), segmentTime = start + segmentNumberInCurrentRange * duration; segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat; ) {
                    var segmentNumber = null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0, segment = {
                        id: "" + segmentTime,
                        time: segmentTime - index.indexTimeOffset,
                        isInit: !1,
                        range: range,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, segmentTime, segmentNumber),
                        number: segmentNumber,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(segment), segmentTime = start + // update segment number and segment time for the next segment
                    ++segmentNumberInCurrentRange * duration;
                }
                if (scaledTo <= segmentTime) 
                // we reached ``scaledTo``, we're done
                return segments;
                null != currentNumber && (currentNumber += repeat + 1);
            }
            return segments;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */        function _addSegmentInfos(index, segmentInfos) {
            if (segmentInfos.timescale !== index.timescale) {
                var timescale = index.timescale;
                index.timeline.push({
                    start: segmentInfos.time / segmentInfos.timescale * timescale,
                    duration: segmentInfos.duration / segmentInfos.timescale * timescale,
                    repeatCount: segmentInfos.count || 0,
                    range: segmentInfos.range
                });
            } else index.timeline.push({
                start: segmentInfos.time,
                duration: segmentInfos.duration,
                repeatCount: segmentInfos.count || 0,
                range: segmentInfos.range
            });
            return !0;
        }
        /**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 */        var base_BaseRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function BaseRepresentationIndex(index, context) {
                var periodStart = context.periodStart, periodEnd = context.periodEnd, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate, timescale = index.timescale, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * timescale, mediaURL = createIndexURL(representationBaseURL, void 0 !== index.initialization ? index.initialization.media : void 0, representationId, representationBitrate), range = void 0 !== index.initialization ? index.initialization.range : void 0 !== index.indexRange ? [ 0, index.indexRange[0] - 1 ] : void 0;
                this._index = {
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: {
                        mediaURL: mediaURL,
                        range: range
                    },
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: index.timeline,
                    timescale: timescale
                }, this._scaledPeriodEnd = null == periodEnd ? void 0 : Object(index_helpers.e)(periodEnd, this._index);
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = BaseRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return get_init_segment_getInitSegment(this._index);
            }
            /**
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(_up, _to) {
                return getSegmentsFromTimeline(this._index, _up, _to, this._scaledPeriodEnd);
            }
            /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * Returns first position in index.
   * @returns {Number|null}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                var index = this._index;
                return 0 === index.timeline.length ? null : Object(index_helpers.b)(index.timeline[0].start, index);
            }
            /**
   * Returns last position in index.
   * @returns {Number|null}
   */ , _proto.getLastPosition = function getLastPosition() {
                var timeline = this._index.timeline;
                if (0 === timeline.length) return null;
                var lastTimelineElement = timeline[timeline.length - 1], lastTime = Object(index_helpers.c)(lastTimelineElement, null, this._scaledPeriodEnd);
                return Object(index_helpers.b)(lastTime, this._index);
            }
            /**
   * Segments in a segmentBase scheme should stay available.
   * @returns {Boolean|undefined}
   */ , _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
                return !0;
            }
            /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * @param {Array.<Object>} nextSegments
   * @returns {Array.<Object>}
   */ , _proto._addSegments = function _addSegments(nextSegments) {
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i]);
            }
            /**
   * SegmentBase should not be updated.
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
                return !1;
            }
            /**
   * @returns {Boolean}
   */ , _proto.isFinished = function isFinished() {
                return !0;
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }, BaseRepresentationIndex;
        }(), list_ListRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function ListRepresentationIndex(index, context) {
                var periodStart = context.periodStart, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._periodStart = periodStart;
                var indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - periodStart * index.timescale, list = index.list.map(function(lItem) {
                    return {
                        mediaURL: createIndexURL(representationBaseURL, lItem.media, representationId, representationBitrate),
                        mediaRange: lItem.mediaRange
                    };
                });
                this._index = {
                    list: list,
                    timescale: index.timescale,
                    duration: index.duration,
                    indexTimeOffset: indexTimeOffset,
                    indexRange: index.indexRange,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    }
                };
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = ListRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return get_init_segment_getInitSegment(this._index);
            }
            /**
   * @param {Number} fromTime
   * @param {Number} duration
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(fromTime, dur) {
                for (var index = this._index, duration = index.duration, list = index.list, timescale = index.timescale, fromTimeInPeriod = fromTime - this._periodStart, _getTimescaledRange = Object(index_helpers.d)(fromTimeInPeriod, dur, timescale), up = _getTimescaledRange[0], to = _getTimescaledRange[1], scaledStart = this._periodStart * timescale, length = Math.min(list.length - 1, Math.floor(to / duration)), segments = [], i = Math.floor(up / duration); i <= length; ) {
                    var args = {
                        id: "" + i,
                        time: i * duration + scaledStart,
                        isInit: !1,
                        range: list[i].mediaRange,
                        duration: duration,
                        timescale: timescale,
                        mediaURL: list[i].mediaURL,
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args), i++;
                }
                return segments;
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} _fromTime
   * @param {Number} toTime
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
                var _this$_index = this._index, timescale = _this$_index.timescale, duration = _this$_index.duration, list = _this$_index.list, scaledTo = toTime * timescale, i = Math.floor(scaledTo / duration);
                return i < 0 || i >= list.length;
            }
            /**
   * Returns first position in index.
   * @returns {Number}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                return this._periodStart;
            }
            /**
   * Returns last position in index.
   * @returns {Number}
   */ , _proto.getLastPosition = function getLastPosition() {
                var index = this._index, duration = index.duration;
                return index.list.length * duration / index.timescale + this._periodStart;
            }
            /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */ , _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
                if (segment.isInit) return !0;
                var index = this._index, scaledStart = this._periodStart * index.timescale, segmentNb = (segment.timescale !== index.timescale ? segment.time * index.timescale / segment.timescale + scaledStart : segment.time - scaledStart) / index.duration;
                return 0 < segmentNb && segmentNb % 1 == 0;
            }
            /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }
            /**
   * SegmentList should not be updated.
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
                return !1;
            }
            /**
   * @returns {Boolean}
   */ , _proto.isFinished = function isFinished() {
                return !0;
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments() {
                0;
            }, ListRepresentationIndex;
        }(), MINIMUM_SEGMENT_SIZE = __webpack_require__(3).a.MINIMUM_SEGMENT_SIZE, template_TemplateRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TemplateRepresentationIndex(index, context) {
                var timescale = index.timescale, aggressiveMode = context.aggressiveMode, manifestBoundsCalculator = context.manifestBoundsCalculator, isDynamic = context.isDynamic, periodEnd = context.periodEnd, periodStart = context.periodStart, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate;
                this._manifestBoundsCalculator = manifestBoundsCalculator, this._aggressiveMode = aggressiveMode;
                var presentationTimeOffset = null != index.presentationTimeOffset ? index.presentationTimeOffset : 0, indexTimeOffset = presentationTimeOffset - periodStart * timescale;
                this._index = {
                    duration: index.duration,
                    timescale: timescale,
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    presentationTimeOffset: presentationTimeOffset,
                    startNumber: index.startNumber
                }, this._isDynamic = isDynamic, this._periodStart = periodStart, this._relativePeriodEnd = null == periodEnd ? void 0 : periodEnd - periodStart;
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TemplateRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return get_init_segment_getInitSegment(this._index);
            }
            /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(fromTime, dur) {
                var index = this._index, duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, mediaURL = index.mediaURL, scaledStart = this._periodStart * timescale, scaledEnd = null == this._relativePeriodEnd ? void 0 : this._relativePeriodEnd * timescale, upFromPeriodStart = fromTime * timescale - scaledStart, toFromPeriodStart = (fromTime + dur) * timescale - scaledStart, firstSegmentStart = this._getFirstSegmentStart(), lastSegmentStart = this._getLastSegmentStart();
                if (null == firstSegmentStart || null == lastSegmentStart) return [];
                var startPosition = Math.max(firstSegmentStart, upFromPeriodStart), lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);
                if (lastWantedStartPosition + duration <= startPosition) return [];
                for (var segments = [], numberOffset = null == startNumber ? 1 : startNumber, numberIndexedToZero = Math.floor(startPosition / duration), timeFromPeriodStart = numberIndexedToZero * duration // number corresponding to the Period's start
                ; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
                    // To obtain the real number, adds the real number from the Period's start
                    var realNumber = numberIndexedToZero + numberOffset, args = {
                        id: "" + realNumber,
                        number: realNumber,
                        time: timeFromPeriodStart + scaledStart,
                        isInit: !1,
                        duration: null != scaledEnd && scaledEnd < timeFromPeriodStart + duration ? scaledEnd - timeFromPeriodStart : duration,
                        timescale: timescale,
                        mediaURL: replaceSegmentDASHTokens(mediaURL, timeFromPeriodStart + this._index.presentationTimeOffset, realNumber),
                        timestampOffset: -index.indexTimeOffset / timescale
                    };
                    segments.push(args), numberIndexedToZero++;
                }
                return segments;
            }
            /**
   * Returns first possible position in the index.
   * @returns {number|null|undefined}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                var firstSegmentStart = this._getFirstSegmentStart();
                return null == firstSegmentStart ? firstSegmentStart : firstSegmentStart / this._index.timescale + this._periodStart;
            }
            /**
   * Returns last possible position in the index.
   * @returns {number|null}
   */ , _proto.getLastPosition = function getLastPosition() {
                var lastSegmentStart = this._getLastSegmentStart();
                return null == lastSegmentStart ? lastSegmentStart : (lastSegmentStart + this._index.duration) / this._index.timescale + this._periodStart;
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh() {
                return !1;
            }
            /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */ , _proto.checkDiscontinuity = function checkDiscontinuity() {
                return -1;
            }, _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
                if (segment.isInit) return !0;
                if (segment.timescale === this._index.timescale) {
                    var timescale = segment.timescale, timeRelativeToPeriodStart = segment.time - this._periodStart * timescale, firstSegmentStart = this._getFirstSegmentStart(), lastSegmentStart = this._getLastSegmentStart();
                    if (void 0 !== firstSegmentStart && void 0 !== lastSegmentStart) return null !== firstSegmentStart && null !== lastSegmentStart && (!(timeRelativeToPeriodStart < firstSegmentStart) && (!(lastSegmentStart < timeRelativeToPeriodStart || segment.duration !== this._index.duration) && timeRelativeToPeriodStart / this._index.duration % 1 == 0));
                }
            }
            /**
   * SegmentTemplate without a SegmentTimeline should not be updated.
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
                return !1;
            }
            /**
   * @returns {Boolean}
   */ , _proto.isFinished = function isFinished() {
                if (!this._isDynamic) return !0;
                if (null == this._relativePeriodEnd) return !1;
                var timescale = this._index.timescale, lastSegmentStart = this._getLastSegmentStart();
                // As last segment start is null if live time is before
                // current period, consider the index not to be finished.
                return null != lastSegmentStart && lastSegmentStart + this._index.duration + 1 / 60 * timescale >= this._relativePeriodEnd * timescale;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments() {
                log.a.warn("Tried to add Segments to a template RepresentationIndex");
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index, this._aggressiveMode = newIndex._aggressiveMode, 
                this._isDynamic = newIndex._isDynamic, this._periodStart = newIndex._periodStart, 
                this._relativePeriodEnd = newIndex._relativePeriodEnd, this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
            }
            /**
   * Returns the timescaled start of the first segment that should be available,
   * relatively to the start of the Period.
   * @returns {number | null | undefined}
   */ , _proto._getFirstSegmentStart = function _getFirstSegmentStart() {
                if (!this._isDynamic) return 0; // it is the start of the Period
                // 1 - check that this index is already available
                                if (!this._relativePeriodEnd) {
                    // /!\ The scaled max position augments continuously and might not
                    // reflect exactly the real server-side value. As segments are
                    // generated discretely.
                    var maximumBound = this._manifestBoundsCalculator.getMaximumBound();
                    if (void 0 !== maximumBound && maximumBound < this._periodStart) 
                    // Maximum position is before this period.
                    // No segment is yet available here
                    return null;
                }
                var _this$_index = this._index, duration = _this$_index.duration, timescale = _this$_index.timescale, firstPosition = this._manifestBoundsCalculator.getMinimumBound();
                if (void 0 !== firstPosition) {
                    var segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
                    return Math.floor(segmentTime / duration) * duration;
                }
            }
            /**
   * Returns the timescaled start of the last segment that should be available,
   * relatively to the start of the Period.
   * Returns null if live time is before current period.
   * @returns {number|null|undefined}
   */ , _proto._getLastSegmentStart = function _getLastSegmentStart() {
                var _this$_index2 = this._index, duration = _this$_index2.duration, timescale = _this$_index2.timescale;
                if (this._isDynamic) {
                    var lastPos = this._manifestBoundsCalculator.getMaximumBound();
                    if (void 0 === lastPos) return;
                    if (null != this._relativePeriodEnd && this._relativePeriodEnd < lastPos - this._periodStart) {
                        var scaledRelativePeriodEnd = this._relativePeriodEnd * timescale;
                        return scaledRelativePeriodEnd <= 0 ? null : scaledRelativePeriodEnd - duration;
                    }
 // /!\ The scaled last position augments continuously and might not
                    // reflect exactly the real server-side value. As segments are
                    // generated discretely.
                                        var scaledLastPosition = (lastPos - this._periodStart) * timescale;
 // Maximum position is before this period.
                    // No segment is yet available here
                                        if (scaledLastPosition < 0) return null;
                    var numberOfSegmentsAvailable = this._aggressiveMode ? Math.ceil(scaledLastPosition / duration) : Math.floor(scaledLastPosition / duration);
                    return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
                }
                var maximumTime = (this._relativePeriodEnd || 0) * timescale, numberIndexedToZero = Math.ceil(maximumTime / duration) - 1, regularLastSegmentStart = numberIndexedToZero * duration;
                return MINIMUM_SEGMENT_SIZE * timescale < maximumTime - regularLastSegmentStart || 0 == numberIndexedToZero ? regularLastSegmentStart : (numberIndexedToZero - 1) * duration;
            }, TemplateRepresentationIndex;
        }(), network_error = __webpack_require__(160), clear_timeline_from_position = __webpack_require__(103), is_segment_still_available = __webpack_require__(102);
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
        /*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */
        function fromParsedSToIndexSegment(item, previousItem, nextItem, timelineStart) {
            var start = item.start, duration = item.duration, repeatCount = item.repeatCount;
            return null == start && (null == previousItem ? start = timelineStart : null != previousItem.duration && (start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1))), 
            null != duration && !isNaN(duration) || !nextItem || null == nextItem.start || isNaN(nextItem.start) || null == start || isNaN(start) || (duration = nextItem.start - start), 
            null == start || isNaN(start) || null == duration || isNaN(duration) || null != repeatCount && isNaN(repeatCount) ? (log.a.warn('DASH: A "S" Element could not have been parsed.'), 
            null) : {
                start: start,
                duration: duration,
                repeatCount: repeatCount || 0
            };
        }
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = 1 + mid : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        var timeline_TimelineRepresentationIndex = 
        /* */
        function() {
            /**
   * @param {Object} index
   * @param {Object} context
   */
            function TimelineRepresentationIndex(index, context) {
                for (var manifestBoundsCalculator = context.manifestBoundsCalculator, isDynamic = context.isDynamic, representationBaseURL = context.representationBaseURL, representationId = context.representationId, representationBitrate = context.representationBitrate, periodStart = context.periodStart, periodEnd = context.periodEnd, timescale = index.timescale, scaledStart = periodStart * timescale, indexTimeOffset = (null != index.presentationTimeOffset ? index.presentationTimeOffset : 0) - scaledStart, initialTimeline = index.timeline, timeline = [], i = 0; i < initialTimeline.length; i++) {
                    var timelineElement = fromParsedSToIndexSegment(initialTimeline[i], timeline[timeline.length - 1] || null, initialTimeline[i + 1] || null, scaledStart);
                    timelineElement && timeline.push(timelineElement);
                }
                this._manifestBoundsCalculator = manifestBoundsCalculator, this._lastUpdate = null == context.receivedTime ? performance.now() : context.receivedTime, 
                this._isDynamic = isDynamic, this._index = {
                    indexRange: index.indexRange,
                    indexTimeOffset: indexTimeOffset,
                    initialization: index.initialization && {
                        mediaURL: createIndexURL(representationBaseURL, index.initialization.media, representationId, representationBitrate),
                        range: index.initialization.range
                    },
                    mediaURL: createIndexURL(representationBaseURL, index.media, representationId, representationBitrate),
                    startNumber: index.startNumber,
                    timeline: timeline,
                    timescale: timescale
                }, this._scaledPeriodStart = Object(index_helpers.e)(periodStart, this._index), 
                this._scaledPeriodEnd = null == periodEnd ? void 0 : Object(index_helpers.e)(periodEnd, this._index);
            }
            /**
   * Construct init Segment.
   * @returns {Object}
   */            var _proto = TimelineRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return get_init_segment_getInitSegment(this._index);
            }
            /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(from, duration) {
                // first clear timeline if needed
                return this._refreshTimeline(), getSegmentsFromTimeline(this._index, from, duration, this._scaledPeriodEnd);
            }
            /**
   * Returns true if the index should be refreshed.
   * @param {Number} _up
   * @param {Number} to
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(_up, to) {
                if (this._refreshTimeline(), !this._isDynamic) return !1;
                if (0 === this._index.timeline.length) return !0;
                var lastTimelineElt = this._index.timeline[this._index.timeline.length - 1], lastTime = Object(index_helpers.c)(lastTimelineElt, null, this._scaledPeriodEnd);
                if (to * this._index.timescale < lastTime) return !1;
                var lastTheoriticalPosition = this._getTheoriticalLastPosition();
                return null == lastTheoriticalPosition || lastTime < lastTheoriticalPosition;
            }
            /**
   * Returns the starting time, in seconds, of the earliest segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                this._refreshTimeline();
                var index = this._index;
                return 0 === index.timeline.length ? null : Object(index_helpers.b)(index.timeline[0].start, index);
            }
            /**
   * Returns the ending time, in seconds, of the last segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */ , _proto.getLastPosition = function getLastPosition() {
                this._refreshTimeline();
                var timeline = this._index.timeline;
                if (0 === timeline.length) return null;
                var lastTimelineElement = timeline[timeline.length - 1], lastTime = Object(index_helpers.c)(lastTimelineElement, null, this._scaledPeriodEnd);
                return Object(index_helpers.b)(lastTime, this._index);
            }
            /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * Returns false if it is not available anymore.
   * Returns undefined if we cannot know whether it is still available or not.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */ , _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
                if (segment.isInit) return !0;
                this._refreshTimeline();
                var _this$_index = this._index, timeline = _this$_index.timeline, timescale = _this$_index.timescale, indexTimeOffset = _this$_index.indexTimeOffset;
                return Object(is_segment_still_available.a)(segment, timeline, timescale, indexTimeOffset);
            }
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */ , _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                this._refreshTimeline();
                var _this$_index2 = this._index, timeline = _this$_index2.timeline, timescale = _this$_index2.timescale, scaledTime = Object(index_helpers.e)(_time, this._index);
                if (scaledTime <= 0) return -1;
                var segmentIndex = getSegmentIndex(this._index, scaledTime);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var timelineItem = timeline[segmentIndex];
                if (-1 === timelineItem.duration) return -1;
                var nextTimelineItem = timeline[segmentIndex + 1];
                if (null == nextTimelineItem) return -1;
                var rangeUp = timelineItem.start, rangeTo = Object(index_helpers.c)(timelineItem, nextTimelineItem, this._scaledPeriodEnd);
                // Every segments defined in range (from rangeUp to rangeTo) are
                // explicitely contiguous.
                // We want to check that the range end is before the next timeline item
                // start, and that scaled time is in this discontinuity.
                return rangeTo < nextTimelineItem.start && rangeUp <= scaledTime && rangeTo - scaledTime < timescale ? Object(index_helpers.b)(nextTimelineItem.start, this._index) : -1;
            }
            /**
   * @param {Error} error
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
                return !!this._isDynamic && (error instanceof network_error.a && error.isHttpError(404));
            }
            /**
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                this._index = newIndex._index, this._isDynamic = newIndex._isDynamic, this._scaledPeriodStart = newIndex._scaledPeriodStart, 
                this._scaledPeriodEnd = newIndex._scaledPeriodEnd, this._lastUpdate = newIndex._lastUpdate, 
                this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
            }
            /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @param {Array.<Object>} nextSegments
   * @param {Object|undefined} currentSegmentInfos
   * @returns {Array}
   */ , _proto._addSegments = function _addSegments() {
                0;
            }
            /**
   * @returns {Boolean}
   */ , _proto.isFinished = function isFinished() {
                if (!this._isDynamic) return !0;
                var timeline = this._index.timeline;
                if (null == this._scaledPeriodEnd || 0 === timeline.length) return !1;
                var lastTimelineElement = timeline[timeline.length - 1];
                // We can never be truly sure if a SegmentTimeline-based index is finished
                // or not (1 / 60 for possible rounding errors)
                return Object(index_helpers.c)(lastTimelineElement, null, this._scaledPeriodEnd) + 1 / 60 >= this._scaledPeriodEnd;
            }
            /**
   * Clean-up timeline to remove segment information which should not be
   * available due to timeshifting.
   */ , _proto._refreshTimeline = function _refreshTimeline() {
                var firstPosition = this._manifestBoundsCalculator.getMinimumBound();
                if (null != firstPosition) {
                    var scaledFirstPosition = Object(index_helpers.e)(firstPosition, this._index);
                    Object(clear_timeline_from_position.a)(this._index.timeline, scaledFirstPosition);
                }
            }
            /**
   * Returns last position if new segments have the same duration than the
   * current last one.
   * @returns {number}
   */ , _proto._getTheoriticalLastPosition = function _getTheoriticalLastPosition() {
                var index = this._index;
                if (!(index.timeline.length <= 0)) {
                    var lastTimelineElement = index.timeline[index.timeline.length - 1], lastPosition = Object(index_helpers.c)(lastTimelineElement, null, this._scaledPeriodEnd);
                    if (!this._isDynamic) return lastPosition;
                    var lastSegmentDuration = lastTimelineElement.duration, timeDiffTS = (performance.now() - this._lastUpdate) / 1e3 * index.timescale;
                    return timeDiffTS < lastSegmentDuration ? lastPosition : Math.floor(timeDiffTS / lastSegmentDuration) * lastSegmentDuration + lastPosition;
                }
            }, TimelineRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representations.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find and parse RepresentationIndex located in an AdaptationSet node.
 * Returns a generic parsed SegmentTemplate with a single element if not found.
 * @param {Object} adaptation
 * @param {Object} context
 */        function findAdaptationIndex(adaptation, context) {
            var adaptationIndex, adaptationChildren = adaptation.children;
            if (null != adaptationChildren.segmentBase) {
                var segmentBase = adaptationChildren.segmentBase;
                adaptationIndex = new base_BaseRepresentationIndex(segmentBase, context);
            } else if (null != adaptationChildren.segmentList) {
                var segmentList = adaptationChildren.segmentList;
                adaptationIndex = new list_ListRepresentationIndex(segmentList, context);
            } else if (null != adaptationChildren.segmentTemplate) {
                var segmentTemplate = adaptationChildren.segmentTemplate;
                adaptationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
            } else adaptationIndex = new template_TemplateRepresentationIndex({
                duration: Number.MAX_VALUE,
                timescale: 1,
                startNumber: 0,
                initialization: {
                    media: ""
                },
                media: ""
            }, context);
            return adaptationIndex;
        }
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
            return representationsIR.map(function(representation) {
                var representationIndex, baseURL = representation.children.baseURL, representationBaseURL = Object(resolve_url.a)(adaptationInfos.baseURL, baseURL), context = {
                    aggressiveMode: adaptationInfos.aggressiveMode,
                    manifestBoundsCalculator: adaptationInfos.manifestBoundsCalculator,
                    isDynamic: adaptationInfos.isDynamic,
                    periodEnd: adaptationInfos.end,
                    periodStart: adaptationInfos.start,
                    receivedTime: adaptationInfos.receivedTime,
                    representationBaseURL: representationBaseURL,
                    representationBitrate: representation.attributes.bitrate,
                    representationId: representation.attributes.id,
                    timeShiftBufferDepth: adaptationInfos.timeShiftBufferDepth
                };
                if (null != representation.children.segmentBase) {
                    var segmentBase = representation.children.segmentBase;
                    representationIndex = new base_BaseRepresentationIndex(segmentBase, context);
                } else if (null != representation.children.segmentList) {
                    var segmentList = representation.children.segmentList;
                    representationIndex = new list_ListRepresentationIndex(segmentList, context);
                } else if (null != representation.children.segmentTemplate) {
                    var segmentTemplate = representation.children.segmentTemplate;
                    representationIndex = "timeline" === segmentTemplate.indexType ? new timeline_TimelineRepresentationIndex(segmentTemplate, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
                } else representationIndex = findAdaptationIndex(adaptation, context);
 // 4-2-2. Find bitrate
                                // 4-2-3. Set ID
                var codecs, parsedRepresentation = {
                    bitrate: null == representation.attributes.bitrate ? (log.a.warn("DASH: No usable bitrate found in the Representation."), 
                    0) : representation.attributes.bitrate,
                    index: representationIndex,
                    id: null != representation.attributes.id ? representation.attributes.id : representation.attributes.bitrate + (null != representation.attributes.height ? "-" + representation.attributes.height : "") + (null != representation.attributes.width ? "-" + representation.attributes.width : "") + (null != representation.attributes.mimeType ? "-" + representation.attributes.mimeType : "") + (null != representation.attributes.codecs ? "-" + representation.attributes.codecs : "")
                };
 // 4-2-4. Construct Representation Base
                                if (null != representation.attributes.codecs ? codecs = representation.attributes.codecs : null != adaptation.attributes.codecs && (codecs = adaptation.attributes.codecs), 
                null != codecs && (codecs = "mp4a.40.02" === codecs ? "mp4a.40.2" : codecs, parsedRepresentation.codecs = codecs), 
                null != representation.attributes.frameRate ? parsedRepresentation.frameRate = representation.attributes.frameRate : null != adaptation.attributes.frameRate && (parsedRepresentation.frameRate = adaptation.attributes.frameRate), 
                null != representation.attributes.height ? parsedRepresentation.height = representation.attributes.height : null != adaptation.attributes.height && (parsedRepresentation.height = adaptation.attributes.height), 
                null != representation.attributes.mimeType ? parsedRepresentation.mimeType = representation.attributes.mimeType : null != adaptation.attributes.mimeType && (parsedRepresentation.mimeType = adaptation.attributes.mimeType), 
                null != representation.attributes.width ? parsedRepresentation.width = representation.attributes.width : null != adaptation.attributes.width && (parsedRepresentation.width = adaptation.attributes.width), 
                null != adaptation.children.contentProtections) {
                    var contentProtections = adaptation.children.contentProtections.reduce(function(acc, cp) {
                        return null != cp.keyId && acc.push({
                            keyId: cp.keyId
                        }), acc;
                    }, []);
                    0 < contentProtections.length && (parsedRepresentation.contentProtections = contentProtections);
                }
                return parsedRepresentation;
            });
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_adaptation_sets.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isVisuallyImpaired(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "1" === accessibility.value);
        }
        /**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */        function isHardOfHearing(accessibility) {
            return !!accessibility && ("urn:tva:metadata:cs:AudioPurposeCS:2007" === accessibility.schemeIdUri && "2" === accessibility.value);
        }
        /**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */        function getAdaptationID(adaptation, representations, infos) {
            if (adaptation.attributes.id) return adaptation.attributes.id;
            var idString = infos.type;
            return adaptation.attributes.language && (idString += "-" + adaptation.attributes.language), 
            infos.isClosedCaption && (idString += "-cc"), infos.isAudioDescription && (idString += "-ad"), 
            adaptation.attributes.contentType && (idString += "-" + adaptation.attributes.contentType), 
            adaptation.attributes.codecs && (idString += "-" + adaptation.attributes.codecs), 
            adaptation.attributes.mimeType && (idString += "-" + adaptation.attributes.mimeType), 
            adaptation.attributes.frameRate && (idString += "-" + adaptation.attributes.frameRate), 
            idString.length === infos.type.length && (idString += representations.length ? "-" + representations[0].id : "-empty"), 
            "adaptation-" + idString;
        }
        /**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */        function getAdaptationSetSwitchingIDs(adaptation) {
            if (null != adaptation.children.supplementalProperties) for (var supplementalProperties = adaptation.children.supplementalProperties, j = 0; j < supplementalProperties.length; j++) {
                var supplementalProperty = supplementalProperties[j];
                if ("urn:mpeg:dash:adaptation-set-switching:2016" === supplementalProperty.schemeIdUri && null != supplementalProperty.value) return supplementalProperty.value.split(",").map(function(id) {
                    return id.trim();
                }).filter(function(id) {
                    return id;
                });
            }
            return [];
        }
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parseAdaptationSets(adaptationsIR, periodInfos) {
            return adaptationsIR.reduce(function(acc, adaptation) {
                var newID, adaptationChildren = adaptation.children, parsedAdaptations = acc.adaptations, representationsIR = adaptation.children.representations, adaptationInfos = {
                    aggressiveMode: periodInfos.aggressiveMode,
                    baseURL: Object(resolve_url.a)(periodInfos.baseURL, adaptationChildren.baseURL),
                    manifestBoundsCalculator: periodInfos.manifestBoundsCalculator,
                    end: periodInfos.end,
                    isDynamic: periodInfos.isDynamic,
                    receivedTime: periodInfos.receivedTime,
                    start: periodInfos.start,
                    timeShiftBufferDepth: periodInfos.timeShiftBufferDepth
                }, type = inferAdaptationType(representationsIR, adaptation.attributes.mimeType || null, adaptation.attributes.codecs || null, adaptationChildren.roles || null), representations = parseRepresentations(representationsIR, adaptation, adaptationInfos), originalID = adaptation.attributes.id, adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation), roles = adaptationChildren.roles, isMainAdaptation = !!roles && !!Object(array_find.a)(roles, function(role) {
                    return "main" === role.value;
                }) && !!Object(array_find.a)(roles, function(role) {
                    return "urn:mpeg:dash:role:2011" === role.schemeIdUri;
                }), videoMainAdaptation = acc.videoMainAdaptation;
                if ("video" === type && null !== videoMainAdaptation && isMainAdaptation) {
                    var _videoMainAdaptation$;
                    (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, representations), 
                    newID = videoMainAdaptation.id;
                } else {
                    var accessibility = adaptationChildren.accessibility, isClosedCaption = !("text" !== type || null == accessibility || !isHardOfHearing(accessibility)) || void 0, isAudioDescription = !("audio" !== type || null == accessibility || !isVisuallyImpaired(accessibility)) || void 0, parsedAdaptationSet = {
                        id: newID = getAdaptationID(adaptation, representations, {
                            isClosedCaption: isClosedCaption,
                            isAudioDescription: isAudioDescription,
                            type: type
                        }),
                        representations: representations,
                        type: type
                    };
                    null != adaptation.attributes.language && (parsedAdaptationSet.language = adaptation.attributes.language), 
                    null != isClosedCaption && (parsedAdaptationSet.closedCaption = isClosedCaption), 
                    null != isAudioDescription && (parsedAdaptationSet.audioDescription = isAudioDescription);
                    var adaptationsOfTheSameType = parsedAdaptations[type];
                    if (adaptationsOfTheSameType) {
                        for (var mergedInto = null, _loop = function _loop(k) {
                            var id = adaptationSetSwitchingIDs[k], switchingInfos = acc.adaptationSwitchingInfos[id];
                            if (null != switchingInfos && switchingInfos.newID !== newID && Object(array_includes.a)(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
                                var _adaptationToMergeInt, adaptationToMergeInto = Object(array_find.a)(adaptationsOfTheSameType, function(a) {
                                    return a.id === id;
                                });
                                if (null != adaptationToMergeInto && adaptationToMergeInto.audioDescription === parsedAdaptationSet.audioDescription && adaptationToMergeInto.closedCaption === parsedAdaptationSet.closedCaption && adaptationToMergeInto.language === parsedAdaptationSet.language) log.a.info('DASH Parser: merging "switchable" AdaptationSets', originalID, id), 
                                (_adaptationToMergeInt = adaptationToMergeInto.representations).push.apply(_adaptationToMergeInt, parsedAdaptationSet.representations), 
                                mergedInto = adaptationToMergeInto;
                            }
                        }, k = 0 // look if we have to merge this into another Adaptation
                        ; k < adaptationSetSwitchingIDs.length; k++) _loop(k);
                        if (isMainAdaptation && "video" === type) if (null == mergedInto) 
                        // put "main" adaptation as the first
                        adaptationsOfTheSameType.unshift(parsedAdaptationSet), acc.videoMainAdaptation = parsedAdaptationSet; else {
                            // put the resulting adaptation first instead
                            var indexOf = adaptationsOfTheSameType.indexOf(mergedInto);
                            indexOf < 0 ? adaptationsOfTheSameType.unshift(parsedAdaptationSet) : 0 !== indexOf && (adaptationsOfTheSameType.splice(indexOf, 1), 
                            adaptationsOfTheSameType.unshift(mergedInto)), acc.videoMainAdaptation = mergedInto;
                        } else null === mergedInto && adaptationsOfTheSameType.push(parsedAdaptationSet);
                    } else parsedAdaptations[type] = [ parsedAdaptationSet ], isMainAdaptation && "video" === type && (acc.videoMainAdaptation = parsedAdaptationSet);
                }
                return null != originalID && null == acc.adaptationSwitchingInfos[originalID] && (acc.adaptationSwitchingInfos[originalID] = {
                    newID: newID,
                    adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
                }), {
                    adaptations: parsedAdaptations,
                    adaptationSwitchingInfos: acc.adaptationSwitchingInfos,
                    videoMainAdaptation: acc.videoMainAdaptation
                };
            }, {
                adaptations: {},
                videoMainAdaptation: null,
                adaptationSwitchingInfos: {}
            }).adaptations;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_periods.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generatePeriodID = Object(id_generator.a)();
        /**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */        function parsePeriods(periodsIR, manifestInfos) {
            var parsedPeriods = [], periodsTimeInformation = getPeriodsTimeInformation(periodsIR, manifestInfos);
            if (periodsTimeInformation.length !== periodsIR.length) throw new Error("MPD parsing error: the time information are incoherent.");
 // We might to communicate the depth of the Buffer while parsing
                        var isDynamic = manifestInfos.isDynamic, timeShiftBufferDepth = manifestInfos.timeShiftBufferDepth, manifestBoundsCalculator = new ManifestBoundsCalculator({
                isDynamic: isDynamic,
                timeShiftBufferDepth: timeShiftBufferDepth
            });
            isDynamic || null == manifestInfos.duration || manifestBoundsCalculator.setLastPosition(manifestInfos.duration);
 // We parse it in reverse because we might need to deduce the buffer depth from
            // the last Periods' indexes
                        for (var i = periodsIR.length - 1; 0 <= i; i--) {
                var periodIR = periodsIR[i], xlinkInfos = manifestInfos.xlinkInfos.get(periodIR), periodBaseURL = Object(resolve_url.a)(manifestInfos.baseURL, periodIR.children.baseURL), _periodsTimeInformati = periodsTimeInformation[i], periodStart = _periodsTimeInformati.periodStart, periodDuration = _periodsTimeInformati.periodDuration, periodEnd = _periodsTimeInformati.periodEnd, periodID = void 0;
                periodID = null == periodIR.attributes.id ? (log.a.warn("DASH: No usable id found in the Period. Generating one."), 
                "gen-dash-period-" + generatePeriodID()) : periodIR.attributes.id;
                var receivedTime = void 0 !== xlinkInfos ? xlinkInfos.receivedTime : manifestInfos.receivedTime, periodInfos = {
                    aggressiveMode: manifestInfos.aggressiveMode,
                    baseURL: periodBaseURL,
                    manifestBoundsCalculator: manifestBoundsCalculator,
                    end: periodEnd,
                    isDynamic: isDynamic,
                    receivedTime: receivedTime,
                    start: periodStart,
                    timeShiftBufferDepth: timeShiftBufferDepth
                }, adaptations = parseAdaptationSets(periodIR.children.adaptations, periodInfos), parsedPeriod = {
                    id: periodID,
                    start: periodStart,
                    end: periodEnd,
                    duration: periodDuration,
                    adaptations: adaptations
                };
                if (parsedPeriods.unshift(parsedPeriod), !manifestBoundsCalculator.lastPositionIsKnown()) {
                    var lastPosition = getMaximumLastPosition(adaptations);
                    if (isDynamic) if ("number" == typeof lastPosition) {
                        var positionTime = performance.now() / 1e3;
                        manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
                    } else {
                        var guessedLastPositionFromClock = guessLastPositionFromClock(manifestInfos, periodStart);
                        if (void 0 !== guessedLastPositionFromClock) {
                            var guessedLastPosition = guessedLastPositionFromClock[0], guessedPositionTime = guessedLastPositionFromClock[1];
                            manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
                        }
                    } else "number" == typeof lastPosition && manifestBoundsCalculator.setLastPosition(lastPosition);
                }
            }
            if (manifestInfos.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
                // Guess a last time the last position
                var _guessedLastPositionFromClock = guessLastPositionFromClock(manifestInfos, 0);
                if (void 0 !== _guessedLastPositionFromClock) {
                    var _lastPosition = _guessedLastPositionFromClock[0], _positionTime = _guessedLastPositionFromClock[1];
                    manifestBoundsCalculator.setLastPosition(_lastPosition, _positionTime);
                }
            }
            return flattenOverlappingPeriods(parsedPeriods);
        }
        /**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "live" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the live time is
 * in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the live time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} manifestInfos
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */        function guessLastPositionFromClock(manifestInfos, minimumTime) {
            if (null != manifestInfos.clockOffset) {
                var lastPosition = manifestInfos.clockOffset / 1e3 - manifestInfos.availabilityStartTime, positionTime = performance.now() / 1e3, timeInSec = positionTime + lastPosition;
                if (minimumTime <= timeInSec) return [ timeInSec, positionTime ];
            } else {
                var now = Date.now() / 1e3;
                if (minimumTime <= now) return log.a.warn("DASH Parser: no clock synchronization mechanism found. Using the system clock instead."), 
                [ now - manifestInfos.availabilityStartTime, performance.now() / 1e3 ];
            }
        }
        /**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */        function getMaximumLastPosition(adaptationsPerType) {
            for (var maxEncounteredPosition = null, allIndexAreEmpty = !0, adaptationsVal = Object(object_values.a)(adaptationsPerType).filter(function(ada) {
                return null != ada;
            }), allAdaptations = Object(flat_map.a)(adaptationsVal, function(adaptationsForType) {
                return adaptationsForType;
            }), adapIndex = 0; adapIndex < allAdaptations.length; adapIndex++) for (var representations = allAdaptations[adapIndex].representations, repIndex = 0; repIndex < representations.length; repIndex++) {
                var position = representations[repIndex].index.getLastPosition();
                null !== position && (allIndexAreEmpty = !1, "number" == typeof position && (maxEncounteredPosition = null == maxEncounteredPosition ? position : Math.max(maxEncounteredPosition, position)));
            }
            return null != maxEncounteredPosition ? maxEncounteredPosition : allIndexAreEmpty ? null : void 0;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_mpd.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var generateManifestID = Object(id_generator.a)();
        /**
 * @param {Element} root - The MPD root.
 * @param {Object} args
 * @returns {Object}
 */        function parseMPD(root, args) {
            return loadExternalRessourcesAndParse(createMPDIntermediateRepresentation(root), args);
        }
        /**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */        function loadExternalRessourcesAndParse(mpdIR, args, hasLoadedClock) {
            var rootChildren = mpdIR.children, rootAttributes = mpdIR.attributes, xlinkInfos = new WeakMap();
            if (null == args.externalClockOffset) {
                var isDynamic = "dynamic" === rootAttributes.type, directTiming = Object(array_find.a)(rootChildren.utcTimings, function(utcTiming) {
                    return "urn:mpeg:dash:utc:direct:2014" === utcTiming.schemeIdUri && null != utcTiming.value;
                }), clockOffsetFromDirectUTCTiming = null != directTiming && null != directTiming.value ? getClockOffset(directTiming.value) : void 0, clockOffset = null == clockOffsetFromDirectUTCTiming || isNaN(clockOffsetFromDirectUTCTiming) ? void 0 : clockOffsetFromDirectUTCTiming;
                if (null != clockOffset) args.externalClockOffset = clockOffset; else if (isDynamic && !0 !== hasLoadedClock) {
                    var UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);
                    if (null != UTCTimingHTTPURL && 0 < UTCTimingHTTPURL.length) 
                    // TODO fetch UTCTiming and XLinks at the same time
                    return {
                        type: "needs-ressources",
                        value: {
                            ressources: [ UTCTimingHTTPURL ],
                            continue: function continueParsingMPD(loadedRessources) {
                                if (1 !== loadedRessources.length) throw new Error("DASH parser: wrong number of loaded ressources.");
                                return clockOffset = getClockOffset(loadedRessources[0].responseData), args.externalClockOffset = clockOffset, 
                                loadExternalRessourcesAndParse(mpdIR, args, !0);
                            }
                        }
                    };
                }
            }
            for (var xlinksToLoad = [], i = 0; i < rootChildren.periods.length; i++) {
                var _rootChildren$periods = rootChildren.periods[i].attributes, xlinkHref = _rootChildren$periods.xlinkHref, xlinkActuate = _rootChildren$periods.xlinkActuate;
                null != xlinkHref && "onLoad" === xlinkActuate && xlinksToLoad.push({
                    index: i,
                    ressource: xlinkHref
                });
            }
            return 0 === xlinksToLoad.length ? parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos) : {
                type: "needs-ressources",
                value: {
                    ressources: xlinksToLoad.map(function(_ref) {
                        return _ref.ressource;
                    }),
                    continue: function continueParsingMPD(loadedRessources) {
                        if (loadedRessources.length !== xlinksToLoad.length) throw new Error("DASH parser: wrong number of loaded ressources.");
 // Note: It is important to go from the last index to the first index in
                        // the resulting array, as we will potentially add elements to the array
                                                for (var _i = loadedRessources.length - 1; 0 <= _i; _i--) {
                            var _rootChildren$periods2, index = xlinksToLoad[_i].index, _loadedRessources$_i = loadedRessources[_i], xlinkData = _loadedRessources$_i.responseData, receivedTime = _loadedRessources$_i.receivedTime, sendingTime = _loadedRessources$_i.sendingTime, url = _loadedRessources$_i.url, wrappedData = "<root>" + xlinkData + "</root>", dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");
                            if (!dataAsXML || 0 === dataAsXML.children.length) throw new Error("DASH parser: Invalid external ressources");
                            for (var periods = dataAsXML.children[0].children, periodsIR = [], j = 0; j < periods.length; j++) if (periods[j].nodeType === Node.ELEMENT_NODE) {
                                var periodIR = createPeriodIntermediateRepresentation(periods[j]);
                                xlinkInfos.set(periodIR, {
                                    receivedTime: receivedTime,
                                    sendingTime: sendingTime,
                                    url: url
                                }), periodsIR.push(periodIR);
                            }
 // replace original "xlinked" periods by the real deal
                                                        // replace original "xlinked" periods by the real deal
                            (_rootChildren$periods2 = rootChildren.periods).splice.apply(_rootChildren$periods2, [ index, 1 ].concat(periodsIR));
                        }
                        return loadExternalRessourcesAndParse(mpdIR, args);
                    }
                }
            };
        }
        /**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */        function parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos) {
            var rootChildren = mpdIR.children, rootAttributes = mpdIR.attributes, isDynamic = "dynamic" === rootAttributes.type, baseURL = Object(resolve_url.a)(Object(resolve_url.b)(null == args.url ? "" : args.url), rootChildren.baseURL), availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime), timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth, clockOffset = args.externalClockOffset, manifestInfos = {
                aggressiveMode: args.aggressiveMode,
                availabilityStartTime: availabilityStartTime,
                baseURL: baseURL,
                clockOffset: clockOffset,
                duration: rootAttributes.duration,
                isDynamic: isDynamic,
                receivedTime: args.manifestReceivedTime,
                timeShiftBufferDepth: timeShiftBufferDepth,
                xlinkInfos: xlinkInfos
            }, parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos), duration = parse_duration_parseDuration(rootAttributes, parsedPeriods), parsedMPD = {
                availabilityStartTime: availabilityStartTime,
                baseURL: baseURL,
                clockOffset: args.externalClockOffset,
                duration: duration,
                id: null != rootAttributes.id ? rootAttributes.id : "gen-dash-manifest-" + generateManifestID(),
                isLive: isDynamic,
                periods: parsedPeriods,
                suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
                transportType: "dash",
                uris: null == args.url ? rootChildren.locations : [ args.url ].concat(rootChildren.locations)
            };
            // -- add optional fields --
            null != rootAttributes.minimumUpdatePeriod && 0 < rootAttributes.minimumUpdatePeriod && (parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod), 
            Object(check_manifest_ids.a)(parsedMPD);
            var _getMinimumAndMaximum = getMinimumAndMaximumPosition(parsedMPD), minTime = _getMinimumAndMaximum[0], maxTime = _getMinimumAndMaximum[1], now = performance.now();
            return isDynamic ? (null != minTime && (parsedMPD.minimumTime = {
                isContinuous: null != timeShiftBufferDepth,
                value: minTime,
                time: now
            }), null != maxTime && (parsedMPD.maximumTime = {
                isContinuous: !0,
                value: maxTime,
                time: now
            }, null == minTime && (parsedMPD.minimumTime = {
                isContinuous: !0,
                value: maxTime,
                time: now
            }))) : (null != minTime && (parsedMPD.minimumTime = {
                isContinuous: !1,
                value: minTime,
                time: now
            }), null != duration ? parsedMPD.maximumTime = {
                isContinuous: !1,
                value: duration,
                time: now
            } : null != maxTime && (parsedMPD.maximumTime = {
                isContinuous: !1,
                value: maxTime,
                time: now
            })), {
                type: "done",
                value: parsedMPD
            };
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_from_document.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Object} args
 * @returns {Object} - parsed manifest
 */        
        // CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */ var dash = function parseFromDocument(document, args) {
            var root = document.documentElement;
            if (!root || "MPD" !== root.nodeName) throw new Error("DASH Parser: document root should be MPD");
            return parseMPD(root, args);
        };
        // CONCATENATED MODULE: ./src/transports/dash/manifest_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */        function requestStringResource(url) {
            return Object(request.a)({
                url: url,
                responseType: "text"
            }).pipe(Object(filter.a)(function(e) {
                return "data-loaded" === e.type;
            }), Object(map.a)(function(e) {
                return e.value;
            }));
        }
        function generateManifestParser(options) {
            var _aggressiveMode = options.aggressiveMode, lowLatencyMode = options.lowLatencyMode, referenceDateTime = options.referenceDateTime, aggressiveMode = lowLatencyMode ? !1 !== _aggressiveMode : !0 === _aggressiveMode, serverTimeOffset = null != options.serverSyncInfos ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : void 0;
            return function manifestParser(args) {
                var response = args.response, scheduleRequest = args.scheduleRequest, argClockOffset = args.externalClockOffset, loaderURL = args.url, url = null == response.url ? loaderURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : // TODO find a way to check if Document?
                response.responseData;
                return function loadExternalResources(parserResponse) {
                    if ("done" === parserResponse.type) {
                        var manifest = new src_manifest.a(parserResponse.value, options);
                        return Object(of.a)({
                            manifest: manifest,
                            url: url
                        });
                    }
                    var _parserResponse$value = parserResponse.value, ressources = _parserResponse$value.ressources, continueParsing = _parserResponse$value.continue;
                    var externalResources$ = ressources.map(function(resource) {
                        return scheduleRequest(function() {
                            return requestStringResource(resource);
                        });
                    });
                    return Object(combineLatest.a)(externalResources$).pipe(Object(mergeMap.a)(function(loadedResources) {
                        for (var resources = [], i = 0; i < loadedResources.length; i++) {
                            var resource = loadedResources[i];
                            if ("string" != typeof resource.responseData) throw new Error("External DASH resources should only be strings");
 // Normally not needed but TypeScript is just dumb here
                                                        resources.push(object_assign_default()(resource, {
                                responseData: resource.responseData
                            }));
                        }
                        return loadExternalResources(continueParsing(resources));
                    }));
                }(dash(data, {
                    aggressiveMode: aggressiveMode,
                    url: url,
                    referenceDateTime: referenceDateTime,
                    externalClockOffset: null == serverTimeOffset ? argClockOffset : serverTimeOffset
                }));
            };
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(8), tap = __webpack_require__(138), fetch = __webpack_require__(83), warn_once = __webpack_require__(19), byte_range = __webpack_require__(42), check_isobmff_integrity = __webpack_require__(69);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
                // CONCATENATED MODULE: ./src/transports/dash/init_segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} content
 */
        function initSegmentLoader(url, _ref) {
            var segment = _ref.segment;
            if (null == segment.range) return Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                sendProgressEvents: !0
            });
            if (null == segment.indexRange) return Object(request.a)({
                url: url,
                headers: {
                    Range: Object(byte_range.a)(segment.range)
                },
                responseType: "arraybuffer",
                sendProgressEvents: !0
            });
 // range and indexRange are contiguous (99% of the cases)
                        if (segment.range[1] + 1 === segment.indexRange[0]) return Object(request.a)({
                url: url,
                headers: {
                    Range: Object(byte_range.a)([ segment.range[0], segment.indexRange[1] ])
                },
                responseType: "arraybuffer",
                sendProgressEvents: !0
            });
            var rangeRequest$ = Object(request.a)({
                url: url,
                headers: {
                    Range: Object(byte_range.a)(segment.range)
                },
                responseType: "arraybuffer",
                sendProgressEvents: !1
            }), indexRequest$ = Object(request.a)({
                url: url,
                headers: {
                    Range: Object(byte_range.a)(segment.indexRange)
                },
                responseType: "arraybuffer",
                sendProgressEvents: !1
            });
            return Object(combineLatest.a)([ rangeRequest$, indexRequest$ ]).pipe(Object(map.a)(function(_ref2) {
                var initData = _ref2[0], indexData = _ref2[1], data = Object(byte_parsing.h)(new Uint8Array(initData.value.responseData), new Uint8Array(indexData.value.responseData)), sendingTime = Math.min(initData.value.sendingTime, indexData.value.sendingTime), receivedTime = Math.max(initData.value.receivedTime, indexData.value.receivedTime);
                return {
                    type: "data-loaded",
                    value: {
                        url: url,
                        responseData: data,
                        size: initData.value.size + indexData.value.size,
                        duration: receivedTime - sendingTime,
                        sendingTime: sendingTime,
                        receivedTime: receivedTime
                    }
                };
            }));
        }
        // CONCATENATED MODULE: ./src/transports/dash/is_webm_embedded_track.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} representation
 * @returns {boolean}
 */        function isWEBMEmbeddedTrack(representation) {
            return "video/webm" === representation.mimeType || "audio/webm" === representation.mimeType;
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
                var scan = __webpack_require__(219), find_complete_box = __webpack_require__(63);
        // EXTERNAL MODULE: ./src/transports/utils/find_complete_box.ts
                // CONCATENATED MODULE: ./src/transports/dash/extract_complete_chunks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */
        function extractCompleteChunks(buffer) {
            for (var _position = 0, chunks = []; _position < buffer.length; ) {
                var currentBuffer = buffer.subarray(_position, Infinity), moofIndex = Object(find_complete_box.a)(currentBuffer, 1836019558
                /* moof */);
                if (moofIndex < 0) 
                // no moof, not a segment.
                return [ chunks, currentBuffer ];
                var moofEnd = _position + moofIndex + Object(byte_parsing.c)(buffer, moofIndex + _position);
                if (moofEnd > buffer.length) 
                // not a complete moof segment
                return [ chunks, currentBuffer ];
                var mdatIndex = Object(find_complete_box.a)(currentBuffer, 1835295092
                /* mdat */);
                if (mdatIndex < 0) 
                // no mdat, not a segment.
                return [ chunks, currentBuffer ];
                var mdatEnd = _position + mdatIndex + Object(byte_parsing.c)(buffer, mdatIndex + _position);
                if (mdatEnd > buffer.length) 
                // not a complete mdat segment
                return [ chunks, currentBuffer ];
                var maxEnd = Math.max(moofEnd, mdatEnd), chunk = buffer.subarray(_position, maxEnd);
                chunks.push(chunk), _position = maxEnd;
            }
            return [ chunks, null ];
        }
        // CONCATENATED MODULE: ./src/transports/dash/low_latency_segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function lowLatencySegmentLoader(url, args) {
            var segment = args.segment, headers = null != segment.range ? {
                Range: Object(byte_range.a)(segment.range)
            } : void 0;
            return Object(fetch.a)({
                url: url,
                headers: headers
            }).pipe(Object(scan.a)(function(acc, evt) {
                if ("data-complete" === evt.type) return null != acc.partialChunk && log.a.warn("DASH Pipelines: remaining chunk does not belong to any segment"), 
                {
                    event: evt,
                    completeChunks: [],
                    partialChunk: null
                };
                var data = new Uint8Array(evt.value.chunk), _extractCompleteChunk = extractCompleteChunks(null != acc.partialChunk ? Object(byte_parsing.h)(acc.partialChunk, data) : data);
                return {
                    event: evt,
                    completeChunks: _extractCompleteChunk[0],
                    partialChunk: _extractCompleteChunk[1]
                };
            }, {
                event: null,
                completeChunks: [],
                partialChunk: null
            }), Object(mergeMap.a)(function(evt) {
                for (var emitted = [], i = 0; i < evt.completeChunks.length; i++) emitted.push({
                    type: "data-chunk",
                    value: {
                        responseData: evt.completeChunks[i]
                    }
                });
                var event = evt.event;
                if (null != event && "data-chunk" === event.type) {
                    var value = event.value;
                    emitted.push({
                        type: "progress",
                        value: {
                            duration: value.duration,
                            size: value.size,
                            url: value.url,
                            totalSize: value.totalSize
                        }
                    });
                } else if (null != event && "data-complete" === event.type) {
                    var _value = event.value;
                    emitted.push({
                        type: "data-chunk-complete",
                        value: {
                            duration: _value.duration,
                            receivedTime: _value.receivedTime,
                            sendingTime: _value.sendingTime,
                            size: _value.size,
                            status: _value.status,
                            url: _value.url
                        }
                    });
                }
                return of.a.apply(void 0, emitted);
            }));
        }
        // CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(url, args, lowLatencyMode) {
            if (args.segment.isInit) return initSegmentLoader(url, args);
            var isWEBM = isWEBMEmbeddedTrack(args.representation);
            if (lowLatencyMode && !isWEBM) {
                if (Object(fetch.b)()) return lowLatencySegmentLoader(url, args);
                Object(warn_once.a)("DASH: Your browser does not have the fetch API. You will have a higher chance of rebuffering when playing close to the live edge");
            }
            var segment = args.segment;
            return Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                sendProgressEvents: !0,
                headers: null != segment.range ? {
                    Range: Object(byte_range.a)(segment.range)
                } : void 0
            });
        }
        /**
 * Generate a segment loader:
 *   - call a custom SegmentLoader if defined
 *   - call the regular loader if not
 * @param {boolean} lowLatencyMode
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */        function generateSegmentLoader(_ref) {
            var lowLatencyMode = _ref.lowLatencyMode, customSegmentLoader = _ref.segmentLoader;
            return !0 !== _ref.checkMediaSegmentIntegrity ? segmentLoader : function(content) {
                return segmentLoader(content).pipe(Object(tap.a)(function(res) {
                    "data-loaded" !== res.type && "data-chunk" !== res.type || null === res.value.responseData || Object(check_isobmff_integrity.a)(new Uint8Array(res.value.responseData), content.segment.isInit);
                }));
            };
            /**
   * @param {Object} content
   * @returns {Observable}
   */
            function segmentLoader(content) {
                var mediaURL = content.segment.mediaURL;
                if (null == mediaURL) return Object(of.a)({
                    type: "data-created",
                    value: {
                        responseData: null
                    }
                });
                if (lowLatencyMode || null == customSegmentLoader) return regularSegmentLoader(mediaURL, content, lowLatencyMode);
                var args = {
                    adaptation: content.adaptation,
                    manifest: content.manifest,
                    period: content.period,
                    representation: content.representation,
                    segment: content.segment,
                    transport: "dash",
                    url: mediaURL
                };
                return new Observable.a(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "data-loaded",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, // HACK What is TypeScript/RxJS doing here??????
                            /* tslint:disable deprecation */
                            // @ts-ignore
                            regularSegmentLoader(mediaURL, content, lowLatencyMode).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                });
            }
        }
        // EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
                var utils = __webpack_require__(218), SEGMENT_ID = 408125543, INFO_ID = 357149030, TIMECODESCALE_ID = 2807729, DURATION_ID = 17545, CUES_ID = 475249515, CUE_POINT_ID = 187, CUE_TIME_ID = 179, CUE_TRACK_POSITIONS_ID = 183, CUE_CLUSTER_POSITIONS_ID = 241;
        // CONCATENATED MODULE: ./src/parsers/containers/matroska/utils.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        
        /**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */
        function findNextElement(elementID, parents, buffer, _ref) {
            for (var initialOffset = _ref[0], maxOffset = _ref[1], currentOffset = initialOffset; currentOffset < maxOffset; ) {
                var parsedID = getEBMLID(buffer, currentOffset);
                if (null == parsedID) return null;
                var ebmlTagID = parsedID.value, sizeOffset = currentOffset + parsedID.length, parsedValue = getEBMLValue(buffer, sizeOffset);
                if (null == parsedValue) return null;
                var valueOffset = sizeOffset + parsedValue.length, valueEndOffset = valueOffset + parsedValue.value;
                if (ebmlTagID === elementID) return [ valueOffset, valueEndOffset ];
                if (parents.length) for (var i = 0; i < parents.length; i++) {
                    if (ebmlTagID === parents[i]) return findNextElement(elementID, parents.slice(i + 1, parents.length), buffer, [ valueOffset, valueEndOffset ]);
                }
                currentOffset = valueEndOffset;
            }
            return null;
        }
        /**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getTimeCodeScale(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
        }
        /**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */        function getDuration(buffer, initialOffset) {
            var timeCodeScaleOffsets = findNextElement(DURATION_ID, [ SEGMENT_ID, INFO_ID ], buffer, [ initialOffset, buffer.length ]);
            if (null == timeCodeScaleOffsets) return null;
            var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
            return 4 == length ? get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]) : 8 == length ? get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]) : null;
        }
        /**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */        function getSegmentsFromCues(buffer, initialOffset) {
            var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [ initialOffset, buffer.length ]);
            if (null == segmentRange) return null;
            var segmentRangeStart = segmentRange[0], segmentRangeEnd = segmentRange[1], timescale = getTimeCodeScale(buffer, segmentRangeStart);
            if (null == timescale) return null;
            var duration = getDuration(buffer, segmentRangeStart);
            if (null == duration) return null;
            var cuesRange = findNextElement(CUES_ID, [], buffer, [ segmentRangeStart, segmentRangeEnd ]);
            if (null == cuesRange) return null;
            for (var rawInfos = [], currentOffset = cuesRange[0]; currentOffset < cuesRange[1]; ) {
                var cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [ currentOffset, cuesRange[1] ]);
                if (null == cuePointRange) break;
                var cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueTimeRange) return null;
                var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]), cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [ CUE_TRACK_POSITIONS_ID ], buffer, [ cuePointRange[0], cuePointRange[1] ]);
                if (null == cueOffsetRange) return null;
                var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
                rawInfos.push({
                    time: time,
                    rangeStart: rangeStart
                }), currentOffset = cuePointRange[1];
            }
            for (var segments = [], i = 0; i < rawInfos.length; i++) {
                var currentSegment = rawInfos[i];
                i === rawInfos.length - 1 ? segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: 0 === i ? duration : duration - currentSegment.time,
                    range: [ currentSegment.rangeStart, Infinity ]
                }) : segments.push({
                    time: currentSegment.time,
                    count: 0,
                    timescale: timescale,
                    duration: rawInfos[i + 1].time - currentSegment.time,
                    range: [ currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1 ]
                });
            }
            return segments;
        }
        function getLength(buffer, offset) {
            for (var length = 1; length <= 8; length++) if (buffer[offset] >= Math.pow(2, 8 - length)) return length;
        }
        function getEBMLID(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        function getEBMLValue(buffer, offset) {
            var length = getLength(buffer, offset);
            if (null == length) return log.a.warn("webm: unrepresentable length"), null;
            if (offset + length > buffer.length) return log.a.warn("webm: impossible length"), 
            null;
            for (var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, 8 * (length - 1)), i = 1; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return {
                length: length,
                value: value
            };
        }
        /**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_32Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat32(offset);
        }
        /**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */        function get_IEEE754_64Bits(buffer, offset) {
            return new DataView(buffer.buffer).getFloat64(offset);
        }
        function bytesToNumber(buffer, offset, length) {
            for (var value = 0, i = 0; i < length; i++) value = buffer[offset + i] * Math.pow(2, 8 * (length - i - 1)) + value;
            return value;
        }
        // CONCATENATED MODULE: ./src/transports/dash/isobmff_timing_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object|undefined} initInfos
 * @returns {Object}
 */        
        /* harmony default export */ var isobmff_timing_infos = function getISOBMFFTimingInfos(buffer, isChunked, segment, initInfos) {
            var startTime, duration, maxDecodeTimeDelta, segmentDuration, trunDuration = Object(utils.a)(buffer), timescale = initInfos && initInfos.timescale ? initInfos.timescale : segment.timescale, baseDecodeTime = Object(utils.d)(buffer);
            return isChunked ? 
            // when chunked, no mean to know the duration for now
            null == initInfos ? null : baseDecodeTime < 0 ? null : {
                time: baseDecodeTime,
                duration: 0 <= trunDuration ? trunDuration : void 0,
                timescale: initInfos.timescale
            } : (segmentDuration = timescale === segment.timescale ? (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / 4 : .25), 
            segment.duration) : (maxDecodeTimeDelta = Math.min(.9 * timescale, null != segment.duration ? segment.duration / segment.timescale * timescale / 4 : .25), 
            null != segment.duration ? segment.duration / segment.timescale * timescale : void 0), 
            0 <= baseDecodeTime ? (startTime = null != segment.timestampOffset ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime, 
            0 <= trunDuration && (null == segmentDuration || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) && (duration = trunDuration), 
            {
                timescale: timescale,
                time: startTime,
                duration: duration
            }) : null);
 // we could always make a mistake when reading a container.
            // If the estimate is too far from what the segment seems to imply, take
            // the segment infos instead.
                };
        // CONCATENATED MODULE: ./src/transports/dash/segment_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function parser(_ref) {
            var content = _ref.content, response = _ref.response, init = _ref.init, period = content.period, representation = content.representation, segment = content.segment, data = response.data, isChunked = response.isChunked;
            if (null == data) return Object(of.a)({
                chunkData: null,
                chunkInfos: null,
                chunkOffset: 0,
                appendWindow: [ period.start, period.end ]
            });
            var chunkData = data instanceof Uint8Array ? data : new Uint8Array(data), indexRange = segment.indexRange, isWEBM = isWEBMEmbeddedTrack(representation), nextSegments = isWEBM ? getSegmentsFromCues(chunkData, 0) : Object(utils.c)(chunkData, indexRange ? indexRange[0] : 0);
            if (segment.isInit) {
                // it is an initialization segment
                nextSegments && representation.index._addSegments(nextSegments);
                var timescale = isWEBM ? getTimeCodeScale(chunkData, 0) : Object(utils.b)(chunkData), _chunkInfos = null != timescale && 0 < timescale ? {
                    time: 0,
                    duration: 0,
                    timescale: timescale
                } : null;
                return Object(of.a)({
                    chunkData: chunkData,
                    chunkInfos: _chunkInfos,
                    chunkOffset: segment.timestampOffset || 0,
                    appendWindow: [ period.start, period.end ]
                });
            }
            var chunkInfos = isWEBM ? null : // TODO extract from webm
            isobmff_timing_infos(chunkData, isChunked, segment, init), chunkOffset = segment.timestampOffset || 0;
            return Object(of.a)({
                chunkData: chunkData,
                chunkInfos: chunkInfos,
                chunkOffset: chunkOffset,
                appendWindow: [ period.start, period.end ]
            });
        }
        // CONCATENATED MODULE: ./src/transports/dash/is_mp4_embedded_text_track.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */        function isMP4EmbeddedTextTrack(representation) {
            return "application/mp4" === representation.mimeType;
        }
        // CONCATENATED MODULE: ./src/transports/dash/text_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */        function generateTextTrackLoader(_ref) {
            var lowLatencyMode = _ref.lowLatencyMode;
            return !0 !== _ref.checkMediaSegmentIntegrity ? textTrackLoader : function(content) {
                return textTrackLoader(content).pipe(Object(tap.a)(function(res) {
                    "data-loaded" !== res.type && "data-chunk" !== res.type || null === res.value.responseData || "string" == typeof res.value.responseData || Object(check_isobmff_integrity.a)(new Uint8Array(res.value.responseData), content.segment.isInit);
                }));
            };
            /**
   * @param {Object} args
   * @returns {Observable}
   */
            function textTrackLoader(args) {
                var _args$segment = args.segment, mediaURL = _args$segment.mediaURL, range = _args$segment.range;
                if (null == mediaURL) return Object(of.a)({
                    type: "data-created",
                    value: {
                        responseData: null
                    }
                });
                if (args.segment.isInit) return initSegmentLoader(mediaURL, args);
                var isMP4Embedded = isMP4EmbeddedTextTrack(args.representation);
                if (lowLatencyMode && isMP4Embedded) {
                    if (Object(fetch.b)()) return lowLatencySegmentLoader(mediaURL, args);
                    Object(warn_once.a)("DASH: Your browser does not have the fetch API. You will have a higher chance of rebuffering when playing close to the live edge");
                }
 // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
                                var responseType = isMP4Embedded ? "arraybuffer" : "text";
                return Object(request.a)({
                    url: mediaURL,
                    responseType: responseType,
                    headers: range ? {
                        Range: Object(byte_range.a)(range)
                    } : null,
                    sendProgressEvents: !0
                });
            }
        }
        // EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
                var read = __webpack_require__(126), string_from_utf8 = __webpack_require__(105);
        // EXTERNAL MODULE: ./src/utils/string_from_utf8.ts
                // CONCATENATED MODULE: ./src/transports/dash/text_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
        function parseMP4EmbeddedTrack(_ref) {
            var chunkBytes, response = _ref.response, content = _ref.content, init = _ref.init, period = content.period, representation = content.representation, segment = content.segment, isInit = segment.isInit, indexRange = segment.indexRange, language = content.adaptation.language, data = response.data, isChunked = response.isChunked;
            chunkBytes = "string" == typeof data ? Object(byte_parsing.p)(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
            var sidxSegments = Object(utils.c)(chunkBytes, indexRange ? indexRange[0] : 0);
            if (isInit) {
                var mdhdTimescale = Object(utils.b)(chunkBytes), chunkInfos = 0 < mdhdTimescale ? {
                    time: 0,
                    duration: 0,
                    timescale: mdhdTimescale
                } : null;
                return sidxSegments && representation.index._addSegments(sidxSegments), Object(of.a)({
                    chunkData: null,
                    chunkInfos: chunkInfos,
                    chunkOffset: segment.timestampOffset || 0,
                    appendWindow: [ period.start, period.end ]
                });
            }
            // not init
            var startTime, endTime, _chunkInfos = isobmff_timing_infos(chunkBytes, isChunked, segment, init), timescale = 1;
            null == _chunkInfos ? isChunked ? log.a.warn("DASH: Unavailable time data for current text track.") : (endTime = (startTime = segment.time) + segment.duration, 
            timescale = segment.timescale) : (startTime = _chunkInfos.time, null != _chunkInfos.duration ? endTime = startTime + _chunkInfos.duration : isChunked || (endTime = startTime + segment.duration), 
            timescale = _chunkInfos.timescale);
            var type, codec = null == representation.codec ? "" : representation.codec;
            switch (codec.toLowerCase()) {
              case "stpp":
 // stpp === TTML in MP4
                              case "stpp.ttml.im1t":
                type = "ttml";
                break;

              case "wvtt":
                // wvtt === WebVTT in MP4
                type = "vtt";
            }
            if (!type) throw new Error('The codec used for the subtitles "' + codec + '" is not managed yet.');
            var chunkData = {
                data: Object(string_from_utf8.a)(Object(read.a)(chunkBytes)),
                type: type,
                language: language,
                start: startTime,
                end: endTime,
                timescale: timescale
            };
            return Object(of.a)({
                chunkData: chunkData,
                chunkInfos: _chunkInfos,
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            });
        }
        function parsePlainTextTrack(_ref2) {
            var response = _ref2.response, content = _ref2.content, adaptation = content.adaptation, period = content.period, representation = content.representation, segment = content.segment, language = adaptation.language;
            if (segment.isInit) return Object(of.a)({
                chunkData: null,
                chunkInfos: null,
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            });
            var textTrackData, start, end, data = response.data, isChunked = response.isChunked;
            if ("string" != typeof data) {
                var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
                textTrackData = Object(byte_parsing.f)(bytesData);
            } else textTrackData = data;
            var type, timescale = 1;
            isChunked ? log.a.warn("DASH: Unavailable time data for current text track.") : (end = (start = segment.time) + segment.duration, 
            timescale = segment.timescale);
            var _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT;
            switch (representation.mimeType) {
              case "application/ttml+xml":
                type = "ttml";
                break;

              case "application/x-sami":
              case "application/smil":
                type = "sami";
                break;

              case "text/vtt":
                type = "vtt";
            }
            if (!type) {
                var _representation$codec = representation.codec;
                if ("srt" !== (void 0 === _representation$codec ? "" : _representation$codec).toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                type = "srt";
            }
            var chunkData = {
                data: textTrackData,
                type: type,
                language: language,
                start: start,
                end: end,
                timescale: timescale
            };
            return Object(of.a)({
                chunkData: chunkData,
                chunkInfos: null,
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            });
        }
        /**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */        function textTrackParser(_ref3) {
            var response = _ref3.response, content = _ref3.content, init = _ref3.init, period = content.period, representation = content.representation, segment = content.segment, data = response.data, isChunked = response.isChunked;
            return null == data ? Object(of.a)({
                chunkData: null,
                chunkInfos: null,
                chunkOffset: segment.timestampOffset || 0,
                appendWindow: [ period.start, period.end ]
            }) : isMP4EmbeddedTextTrack(representation) ? parseMP4EmbeddedTrack({
                response: {
                    data: data,
                    isChunked: isChunked
                },
                content: content,
                init: init
            }) : parsePlainTextTrack({
                response: {
                    data: data,
                    isChunked: isChunked
                },
                content: content
            });
        }
        // CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
        /* harmony default export */        __webpack_exports__.default = function(options) {
            var manifestLoader = Object(document_manifest_loader.a)({
                customManifestLoader: options.manifestLoader
            }), manifestParser = generateManifestParser(options), segmentLoader = generateSegmentLoader(options);
            return {
                manifest: {
                    loader: manifestLoader,
                    parser: manifestParser
                },
                audio: {
                    loader: segmentLoader,
                    parser: parser
                },
                video: {
                    loader: segmentLoader,
                    parser: parser
                },
                text: {
                    loader: generateTextTrackLoader(options),
                    parser: textTrackParser
                },
                image: {
                    loader: imageLoader,
                    parser: imageParser
                }
            };
        };
        // CONCATENATED MODULE: ./src/transports/dash/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */    }, 
    /* 196 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
        var of = __webpack_require__(23), map = __webpack_require__(34), tap = __webpack_require__(138), features = __webpack_require__(10), log = __webpack_require__(0), src_manifest = __webpack_require__(85), read = __webpack_require__(126), object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), assert = __webpack_require__(31), id_generator = __webpack_require__(50), resolve_url = __webpack_require__(37), check_manifest_ids = __webpack_require__(104);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */
        function getAudioCodecs(fourCC, codecPrivateData) {
            var mpProfile;
            return (mpProfile = "AACH" === fourCC ? 5 : codecPrivateData ? (248 & parseInt(codecPrivateData.substring(0, 2), 16)) >> 3 : 2) ? "mp4a.40." + mpProfile : "";
        }
        /**
 * @param {string} codecPrivateData
 * @returns {string}
 */        function getVideoCodecs(codecPrivateData) {
            // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
            var _ref$ = (/00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [])[1], avcProfile = void 0 === _ref$ ? "" : _ref$;
            return avcProfile && "avc1." + avcProfile;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */        function parseCNodes(nodes) {
            return nodes.reduce(function(timeline, node, i) {
                var dAttr = node.getAttribute("d"), tAttr = node.getAttribute("t"), rAttr = node.getAttribute("r"), repeatCount = rAttr ? +rAttr - 1 : 0, start = tAttr ? +tAttr : void 0, duration = dAttr ? +dAttr : void 0;
                if (0 === i) 
                // first node
                start = start || 0; else {
                    // from second node to the end
                    var prev = timeline[i - 1];
                    if (null == start || isNaN(start)) {
                        if (null == prev.duration || isNaN(prev.duration)) throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
                        start = prev.start + prev.duration * (prev.repeatCount + 1);
                    }
                }
                if (null == duration || isNaN(duration)) {
                    var nextNode = nodes[i + 1];
                    if (!nextNode) return timeline;
                    var nextTAttr = nextNode.getAttribute("t"), nextStart = nextTAttr ? +nextTAttr : null;
                    if (null === nextStart) throw new Error("Can't build index timeline from Smooth Manifest.");
                    duration = nextStart - start;
                }
                return timeline.push({
                    duration: duration,
                    start: start,
                    repeatCount: repeatCount
                }), timeline;
            }, []);
        }
        // EXTERNAL MODULE: ./src/utils/byte_parsing.ts
                var byte_parsing = __webpack_require__(1), playready = __webpack_require__(178);
        // EXTERNAL MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */
        function createWidevineKeySystem(keyIdBytes) {
            return [ {
                systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
                privateData: Object(byte_parsing.h)([ 8, 1, 18, 16 ], keyIdBytes)
            } ];
        }
        /**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */        function parseProtectionNode(protectionNode, keySystemCreator) {
            if (void 0 === keySystemCreator && (keySystemCreator = createWidevineKeySystem), 
            !protectionNode.firstElementChild || "ProtectionHeader" !== protectionNode.firstElementChild.nodeName) throw new Error("Protection should have ProtectionHeader child");
            var header = protectionNode.firstElementChild, privateData = Object(byte_parsing.p)(atob(header.textContent || "")), keyIdHex = Object(playready.a)(privateData), keyIdBytes = Object(byte_parsing.j)(keyIdHex);
            return {
                keyId: keyIdBytes,
                keySystems: [ {
                    systemId: (header.getAttribute("SystemID") || "").toLowerCase().replace(/\{|\}/g, ""),
                    privateData: privateData
                } ].concat(keySystemCreator(keyIdBytes))
            };
        }
        // EXTERNAL MODULE: ./src/errors/network_error.ts
                var network_error = __webpack_require__(160), clear_timeline_from_position = __webpack_require__(103), index_helpers = __webpack_require__(13), is_segment_still_available = __webpack_require__(102);
        // EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
                // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/add_segment_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */
        function _addSegmentInfos(index, newSegment, currentSegment) {
            var scaledCurrentTime, timeline = index.timeline, timescale = index.timescale, last = timeline[timeline.length - 1], scaledNewSegment = newSegment.timescale === timescale ? {
                time: newSegment.time,
                duration: newSegment.duration
            } : {
                time: newSegment.time / newSegment.timescale * timescale,
                duration: newSegment.duration / newSegment.timescale * timescale
            };
            return currentSegment && currentSegment.timescale && (scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale), 
            !(null != scaledCurrentTime && scaledNewSegment.time === scaledCurrentTime) && (scaledNewSegment.time >= Object(index_helpers.c)(last, null) && (
            // if the given timing has a timestamp after the timeline end we
            // just need to push a new element in the timeline, or increase
            // the @r attribute of the last element.
            last.duration === scaledNewSegment.duration ? last.repeatCount++ : index.timeline.push({
                duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0
            }), !0));
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */        function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
            return url.replace(/\{bitrate\}/g, String(bitrate)).replace(/{CustomAttributes}/g, 0 < customAttributes.length ? customAttributes[0] : "");
        }
        /**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */        function replaceSegmentSmoothTokens(url, time) {
            return url.replace(/\{start time\}/g, String(time));
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */        function getSegmentIndex(index, start) {
            for (var timeline = index.timeline, low = 0, high = timeline.length; low < high; ) {
                var mid = low + high >>> 1;
                timeline[mid].start < start ? low = 1 + mid : high = mid;
            }
            return 0 < low ? low - 1 : low;
        }
        /**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */        function getSegmentNumber(start, up, duration) {
            var diff = up - start;
            return 0 < diff ? Math.floor(diff / duration) : 0;
        }
 // interface ISmoothIndex {
        //   presentationTimeOffset? : number;
        //   timescale : number;
        //   media? : string;
        //   timeline : IIndexSegment[];
        //   startNumber? : number;
        // }
        /**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */        function normalizeRange(index, start, duration) {
            var timescale = index.timescale || 1;
            return {
                up: start * timescale,
                to: (start + duration) * timescale
            };
        }
        /**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */        function calculateRepeat(segment, nextSegment) {
            var repeatCount = segment.repeatCount || 0;
 // A negative value of the @r attribute of the S element indicates
            // that the duration indicated in @d attribute repeats until the
            // start of the next S element, the end of the Period or until the
            // next MPD update.
            // TODO Also for SMOOTH????
                        if (null != segment.duration && repeatCount < 0) {
                var repeatEnd = nextSegment ? nextSegment.start : Infinity;
                repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
            }
            return repeatCount;
        }
        /**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */        var representation_index_SmoothRepresentationIndex = 
        /* */
        function() {
            function SmoothRepresentationIndex(index, options) {
                var aggressiveMode = options.aggressiveMode, isLive = options.isLive, segmentPrivateInfos = options.segmentPrivateInfos, estimatedReceivedTime = null == index.manifestReceivedTime ? performance.now() : index.manifestReceivedTime;
                if (this._index = index, this._indexValidityTime = estimatedReceivedTime, this._initSegmentInfos = {
                    bitsPerSample: segmentPrivateInfos.bitsPerSample,
                    channels: segmentPrivateInfos.channels,
                    codecPrivateData: segmentPrivateInfos.codecPrivateData,
                    packetSize: segmentPrivateInfos.packetSize,
                    samplingRate: segmentPrivateInfos.samplingRate,
                    protection: segmentPrivateInfos.protection
                }, this._isAggressiveMode = aggressiveMode, this._isLive = isLive, index.timeline.length) {
                    var lastItem = index.timeline[index.timeline.length - 1], scaledEnd = Object(index_helpers.c)(lastItem, null);
                    if (this._initialScaledLastPosition = scaledEnd, index.isLive) {
                        var scaledReceivedTime = estimatedReceivedTime / 1e3 * index.timescale;
                        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
                    }
                }
            }
            /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */            var _proto = SmoothRepresentationIndex.prototype;
            return _proto.getInitSegment = function getInitSegment() {
                return {
                    id: "init",
                    isInit: !0,
                    time: 0,
                    duration: 0,
                    timescale: this._index.timescale,
                    privateInfos: {
                        smoothInit: this._initSegmentInfos
                    },
                    mediaURL: null
                };
            }
            /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */ , _proto.getSegments = function getSegments(_up, _to) {
                this._refreshTimeline();
                for (var currentNumber, _normalizeRange = normalizeRange(this._index, _up, _to), up = _normalizeRange.up, to = _normalizeRange.to, _this$_index = this._index, timeline = _this$_index.timeline, timescale = _this$_index.timescale, media = _this$_index.media, isAggressive = this._isAggressiveMode, segments = [], timelineLength = timeline.length, maxPosition = null == this._scaledLiveGap ? void 0 : performance.now() / 1e3 * timescale - this._scaledLiveGap, i = 0; i < timelineLength; i++) {
                    for (var segmentRange = timeline[i], duration = segmentRange.duration, start = segmentRange.start, repeat = calculateRepeat(segmentRange, timeline[i + 1]), segmentNumberInCurrentRange = getSegmentNumber(start, up, duration), segmentTime = start + segmentNumberInCurrentRange * duration, timeToAddToCheckMaxPosition = isAggressive ? 0 : duration; segmentTime < to && segmentNumberInCurrentRange <= repeat && (null == maxPosition || segmentTime + timeToAddToCheckMaxPosition <= maxPosition); ) {
                        var segment = {
                            id: "" + segmentTime,
                            time: segmentTime,
                            isInit: !1,
                            duration: duration,
                            timescale: timescale,
                            number: null != currentNumber ? currentNumber + segmentNumberInCurrentRange : void 0,
                            mediaURL: replaceSegmentSmoothTokens(media, segmentTime)
                        };
                        segments.push(segment), segmentTime = start + // update segment number and segment time for the next segment
                        ++segmentNumberInCurrentRange * duration;
                    }
                    if (to <= segmentTime) 
                    // we reached ``to``, we're done
                    return segments;
                    null != currentNumber && (currentNumber += repeat + 1);
                }
                return segments;
            }
            /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */ , _proto.shouldRefresh = function shouldRefresh(up, to) {
                if (this._refreshTimeline(), !this._index.isLive) return !1;
                var _this$_index2 = this._index, timeline = _this$_index2.timeline, timescale = _this$_index2.timescale, lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
                if (!lastSegmentInCurrentTimeline) return !1;
                var repeat = lastSegmentInCurrentTimeline.repeatCount || 0, endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;
                return !(to * timescale < endOfLastSegmentInCurrentTimeline) && (endOfLastSegmentInCurrentTimeline <= up * timescale || lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration < up * timescale);
            }
            /**
   * Returns first position available in the index.
   *
   * @param {Object} index
   * @returns {Number|null}
   */ , _proto.getFirstPosition = function getFirstPosition() {
                this._refreshTimeline();
                var index = this._index;
                return index.timeline.length ? index.timeline[0].start / index.timescale : null;
            }
            /**
   * Returns last position available in the index.
   * @param {Object} index
   * @returns {Number}
   */ , _proto.getLastPosition = function getLastPosition() {
                this._refreshTimeline();
                var index = this._index;
                if (null == this._scaledLiveGap) {
                    var lastTimelineElement = index.timeline[index.timeline.length - 1];
                    return Object(index_helpers.c)(lastTimelineElement, null) / index.timescale;
                }
                for (var i = index.timeline.length - 1; 0 <= i; i--) for (var timelineElt = index.timeline[i], timescaledNow = performance.now() / 1e3 * index.timescale, start = timelineElt.start, duration = timelineElt.duration, j = timelineElt.repeatCount; 0 <= j; j--) {
                    var end = start + duration * (j + 1);
                    if ((this._isAggressiveMode ? end - duration : end) <= timescaledNow - this._scaledLiveGap) return end / index.timescale;
                }
            }
            /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   *
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */ , _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
                this._refreshTimeline();
                var index = this._index, timeline = index.timeline, _index$timescale = index.timescale, timescale = void 0 === _index$timescale ? 1 : _index$timescale, time = _time * timescale;
                if (time <= 0) return -1;
                var segmentIndex = getSegmentIndex(index, time);
                if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) return -1;
                var range = timeline[segmentIndex];
                if (-1 === range.duration) return -1;
                var rangeUp = range.start, rangeTo = Object(index_helpers.c)(range, null), nextRange = timeline[segmentIndex + 1];
                // when we are actually inside the found range and this range has
                // an explicit discontinuity with the next one
                return rangeTo !== nextRange.start && rangeUp <= time && time <= rangeTo && rangeTo - time < timescale ? nextRange.start / timescale : -1;
            }, _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
                if (segment.isInit) return !0;
                this._refreshTimeline();
                var _this$_index3 = this._index, timeline = _this$_index3.timeline, timescale = _this$_index3.timescale;
                return Object(is_segment_still_available.a)(segment, timeline, timescale, 0);
            }
            /**
   * @param {Error} error
   * @returns {Boolean}
   */ , _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
                return !!this._isLive && (error instanceof network_error.a && (error.isHttpError(404) || error.isHttpError(412)));
            }
            /**
   * Update this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more information about new segments and re-add
   * them if that's the case.
   * @param {Object} newIndex
   */ , _proto._update = function _update(newIndex) {
                var oldTimeline = this._index.timeline, newTimeline = newIndex._index.timeline, oldTimescale = this._index.timescale, newTimescale = newIndex._index.timescale;
                if (this._index = newIndex._index, this._initialScaledLastPosition = newIndex._initialScaledLastPosition, 
                this._indexValidityTime = newIndex._indexValidityTime, this._scaledLiveGap = newIndex._scaledLiveGap, 
                oldTimeline.length && newTimeline.length && oldTimescale === newTimescale) {
                    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1], lastNewTimelineElement = newTimeline[newTimeline.length - 1], newEnd = Object(index_helpers.c)(lastNewTimelineElement, null);
                    if (!(Object(index_helpers.c)(lastOldTimelineElement, null) <= newEnd)) for (var i = 0; i < oldTimeline.length; i++) {
                        var oldTimelineRange = oldTimeline[i], oldEnd = Object(index_helpers.c)(oldTimelineRange, null);
                        if (oldEnd === newEnd) 
                        // just add the supplementary segments
                        return void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1)));
                        if (newEnd < oldEnd) {
                            // adjust repeatCount + add supplementary segments
                            if (oldTimelineRange.duration !== lastNewTimelineElement.duration) return;
                            var rangeDuration = newEnd - oldTimelineRange.start;
                            if (0 == rangeDuration) return log.a.warn("Smooth Parser: a discontinuity detected in the previous manifest has been resolved."), 
                            void (this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i)));
                            if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration != 0) return;
                            var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1, relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
                            if (relativeRepeat < 0) return;
                            lastNewTimelineElement.repeatCount += relativeRepeat;
                            var supplementarySegments = oldTimeline.slice(i + 1);
                            return void (this._index.timeline = this._index.timeline.concat(supplementarySegments));
                        }
                    }
                }
            }
            /**
   * @returns {Boolean | undefined}
   */ , _proto.isFinished = function isFinished() {
                return !this._isLive;
            }, _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
                this._refreshTimeline();
                for (var i = 0; i < nextSegments.length; i++) _addSegmentInfos(this._index, nextSegments[i], currentSegment);
            }
            /**
   * Clean-up timeline to remove segment information which should not be
   * available due to the timeshift window
   */ , _proto._refreshTimeline = function _refreshTimeline() {
                // clean segments before time shift buffer depth
                if (null != this._initialScaledLastPosition) {
                    var index = this._index, timeShiftBufferDepth = index.timeShiftBufferDepth, lastPositionEstimate = (performance.now() - this._indexValidityTime) / 1e3 + this._initialScaledLastPosition / index.timescale;
                    if (null != timeShiftBufferDepth) {
                        var minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * index.timescale;
                        Object(clear_timeline_from_position.a)(index.timeline, minimumPosition);
                    }
                }
            }, SmoothRepresentationIndex;
        }();
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */        function parseBoolean(val) {
            return "boolean" == typeof val ? val : "string" == typeof val && "TRUE" === val.toUpperCase();
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */        function reduceChildren(root, fn, init) {
            for (var node = root.firstElementChild, accumulator = init; node; ) accumulator = fn(accumulator, node.nodeName, node), 
            node = node.nextElementSibling;
            return accumulator;
        }
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */        var generateManifestID = Object(id_generator.a)(), DEFAULT_MIME_TYPES = {
            audio: "audio/mp4",
            video: "video/mp4",
            text: "application/ttml+xml"
        }, DEFAULT_CODECS = {
            audio: "mp4a.40.2",
            video: "avc1.4D401E"
        }, MIME_TYPES = {
            AACL: "audio/mp4",
            AVC1: "video/mp4",
            H264: "video/mp4",
            TTML: "application/ttml+xml+mp4"
        };
        /* harmony default export */ var smooth = 
        /**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
        function createSmoothStreamingParser(parserOptions) {
            void 0 === parserOptions && (parserOptions = {});
            var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay, REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1e3, MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 0;
            /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */
            function parseQualityLevel(q, streamType) {
                var customAttributes = reduceChildren(q, function(acc, qName, qNode) {
                    return "CustomAttributes" === qName && acc.push.apply(acc, reduceChildren(qNode, function(cAttrs, cName, cNode) {
                        if ("Attribute" === cName) {
                            var name = cNode.getAttribute("Name"), value = cNode.getAttribute("Value");
                            null !== name && null !== value && cAttrs.push(name + "=" + value);
                        }
                        return cAttrs;
                    }, [])), acc;
                }, []);
                /**
     * @param {string} name
     * @returns {string|undefined}
     */                function getAttribute(name) {
                    var attr = q.getAttribute(name);
                    return null == attr ? void 0 : attr;
                }
                switch (streamType) {
                  case "audio":
                    var audiotag = getAttribute("AudioTag"), bitrate = getAttribute("Bitrate"), bitsPerSample = getAttribute("BitsPerSample"), channels = getAttribute("Channels"), codecPrivateData = getAttribute("CodecPrivateData"), fourCC = getAttribute("FourCC"), packetSize = getAttribute("PacketSize"), samplingRate = getAttribute("SamplingRate");
                    return {
                        audiotag: void 0 !== audiotag ? parseInt(audiotag, 10) : audiotag,
                        bitrate: bitrate && parseInt(bitrate, 10) || 0,
                        bitsPerSample: void 0 !== bitsPerSample ? parseInt(bitsPerSample, 10) : bitsPerSample,
                        channels: void 0 !== channels ? parseInt(channels, 10) : channels,
                        codecPrivateData: codecPrivateData || "",
                        customAttributes: customAttributes,
                        mimeType: void 0 !== fourCC ? MIME_TYPES[fourCC] : fourCC,
                        packetSize: void 0 !== packetSize ? parseInt(packetSize, 10) : packetSize,
                        samplingRate: void 0 !== samplingRate ? parseInt(samplingRate, 10) : samplingRate
                    };

                  case "video":
                    var _bitrate = getAttribute("Bitrate"), _codecPrivateData = getAttribute("CodecPrivateData"), _fourCC = getAttribute("FourCC"), width = getAttribute("MaxWidth"), height = getAttribute("MaxHeight");
                    return {
                        bitrate: _bitrate && parseInt(_bitrate, 10) || 0,
                        customAttributes: customAttributes,
                        mimeType: void 0 !== _fourCC ? MIME_TYPES[_fourCC] : _fourCC,
                        codecPrivateData: _codecPrivateData || "",
                        codecs: getVideoCodecs(_codecPrivateData || ""),
                        width: void 0 !== width ? parseInt(width, 10) : void 0,
                        height: void 0 !== height ? parseInt(height, 10) : void 0
                    };

                  case "text":
                    var _bitrate2 = getAttribute("Bitrate"), _codecPrivateData2 = getAttribute("CodecPrivateData"), _fourCC2 = getAttribute("FourCC");
                    return {
                        bitrate: _bitrate2 && parseInt(_bitrate2, 10) || 0,
                        customAttributes: customAttributes,
                        mimeType: void 0 !== _fourCC2 ? MIME_TYPES[_fourCC2] : _fourCC2,
                        codecPrivateData: _codecPrivateData2 || ""
                    };

                  default:
                    return log.a.error("Smooth Parser: Unrecognized StreamIndex type: " + streamType), 
                    null;
                }
            }
            /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */            function parseAdaptation(args) {
                var root = args.root, timescale = args.timescale, rootURL = args.rootURL, protections = args.protections, timeShiftBufferDepth = args.timeShiftBufferDepth, manifestReceivedTime = args.manifestReceivedTime, isLive = args.isLive, _timescale = root.hasAttribute("Timescale") ? +(root.getAttribute("Timescale") || 0) : timescale, adaptationType = root.getAttribute("Type");
                if (null == adaptationType) throw new Error("StreamIndex without type.");
                var subType = root.getAttribute("Subtype"), language = root.getAttribute("Language"), baseURL = root.getAttribute("Url") || "";
                var _reduceChildren = reduceChildren(root, function(res, _name, node) {
                    switch (_name) {
                      case "QualityLevel":
                        var qualityLevel = parseQualityLevel(node, adaptationType);
                        if (null === qualityLevel) return res;
                        if ("audio" === adaptationType) {
                            var fourCC = node.getAttribute("FourCC") || "";
                            qualityLevel.codecs = getAudioCodecs(fourCC, qualityLevel.codecPrivateData);
                        }
 // filter out video qualityLevels with small bitrates
                                                ("video" !== adaptationType || qualityLevel.bitrate > MIN_REPRESENTATION_BITRATE) && res.qualityLevels.push(qualityLevel);
                        break;

                      case "c":
                        res.cNodes.push(node);
                    }
                    return res;
                }, {
                    qualityLevels: [],
                    cNodes: []
                }), qualityLevels = _reduceChildren.qualityLevels, index = {
                    timeline: parseCNodes(_reduceChildren.cNodes),
                    timescale: _timescale
                };
                // we assume that all qualityLevels have the same
                // codec and mimeType
                Object(assert.b)(0 !== qualityLevels.length, "adaptation should have at least one representation");
                var adaptationID = adaptationType + (language ? "_" + language : ""), representations = qualityLevels.map(function(qualityLevel) {
                    var firstProtection, path = Object(resolve_url.a)(rootURL, baseURL), repIndex = {
                        timeline: index.timeline,
                        timescale: index.timescale,
                        media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate, qualityLevel.customAttributes),
                        isLive: isLive,
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    }, mimeType = qualityLevel.mimeType || DEFAULT_MIME_TYPES[adaptationType], codecs = qualityLevel.codecs || DEFAULT_CODECS[adaptationType], id = adaptationID + "_" + adaptationType + "-" + mimeType + "-" + codecs + "-" + qualityLevel.bitrate, contentProtections = [];
                    protections.length && (firstProtection = protections[0], protections.forEach(function(protection) {
                        var keyId = protection.keyId;
                        protection.keySystems.forEach(function(keySystem) {
                            contentProtections.push({
                                keyId: keyId,
                                systemId: keySystem.systemId
                            });
                        });
                    }));
                    var segmentPrivateInfos = {
                        bitsPerSample: qualityLevel.bitsPerSample,
                        channels: qualityLevel.channels,
                        codecPrivateData: qualityLevel.codecPrivateData || "",
                        packetSize: qualityLevel.packetSize,
                        samplingRate: qualityLevel.samplingRate,
                        // TODO set multiple protections here instead of the first one
                        protection: null != firstProtection ? {
                            keyId: firstProtection.keyId,
                            keySystems: firstProtection.keySystems
                        } : void 0
                    }, representation = object_assign_default()({}, qualityLevel, {
                        index: new representation_index_SmoothRepresentationIndex(repIndex, {
                            aggressiveMode: null != parserOptions.aggressiveMode && parserOptions.aggressiveMode,
                            isLive: isLive,
                            segmentPrivateInfos: segmentPrivateInfos
                        }),
                        mimeType: mimeType,
                        codecs: codecs,
                        id: id
                    });
                    return contentProtections.length && (representation.contentProtections = contentProtections), 
                    representation;
                });
                // TODO(pierre): real ad-insert support
                if ("ADVT" === subType) return null;
                var parsedAdaptation = {
                    id: adaptationID,
                    type: adaptationType,
                    representations: representations,
                    language: null == language ? void 0 : language
                };
                return "text" === adaptationType && "DESC" === subType && (parsedAdaptation.closedCaption = !0), 
                parsedAdaptation;
            }
            return function parseFromDocument(doc, url, manifestReceivedTime) {
                var rootURL = Object(resolve_url.b)(null == url ? "" : url), root = doc.documentElement;
                if (!root || "SmoothStreamingMedia" !== root.nodeName) throw new Error("document root should be SmoothStreamingMedia");
                if (!/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion"))) throw new Error("Version should be 2.0, 2.1 or 2.2");
                var timeShiftBufferDepth, timescale = +(root.getAttribute("Timescale") || 1e7), _reduceChildren2 = reduceChildren(root, function(res, name, node) {
                    switch (name) {
                      case "Protection":
                        res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
                        break;

                      case "StreamIndex":
                        res.adaptationNodes.push(node);
                    }
                    return res;
                }, {
                    adaptationNodes: [],
                    protections: []
                }), protections = _reduceChildren2.protections, adaptationNodes = _reduceChildren2.adaptationNodes, isLive = parseBoolean(root.getAttribute("IsLive"));
                if (isLive) {
                    var dvrWindowLength = root.getAttribute("DVRWindowLength");
                    null == dvrWindowLength || isNaN(+dvrWindowLength) || 0 == +dvrWindowLength || (timeShiftBufferDepth = +dvrWindowLength / timescale);
                }
                var suggestedPresentationDelay, availabilityStartTime, minimumTime, maximumTime, firstTimeReference, lastTimeReference, periodStart, duration, adaptations = adaptationNodes.map(function(node) {
                    return parseAdaptation({
                        root: node,
                        rootURL: rootURL,
                        timescale: timescale,
                        protections: protections,
                        isLive: isLive,
                        timeShiftBufferDepth: timeShiftBufferDepth,
                        manifestReceivedTime: manifestReceivedTime
                    });
                }).filter(function(adaptation) {
                    return null != adaptation;
                }).reduce(function(acc, adaptation) {
                    var type = adaptation.type;
                    return void 0 === acc[type] ? acc[type] = [ adaptation ] : (acc[type] || []).push(adaptation), 
                    acc;
                }, {}), firstVideoAdaptation = adaptations.video ? adaptations.video[0] : void 0, firstAudioAdaptation = adaptations.audio ? adaptations.audio[0] : void 0;
                if (firstVideoAdaptation || firstAudioAdaptation) {
                    var firstTimeReferences = [], lastTimeReferences = [];
                    if (firstVideoAdaptation) {
                        var firstVideoRepresentation = firstVideoAdaptation.representations[0];
                        if (firstVideoRepresentation) {
                            var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition(), lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                            null != firstVideoTimeReference && firstTimeReferences.push(firstVideoTimeReference), 
                            null != lastVideoTimeReference && lastTimeReferences.push(lastVideoTimeReference);
                        }
                    }
                    if (firstAudioAdaptation) {
                        var firstAudioRepresentation = firstAudioAdaptation.representations[0];
                        if (firstAudioRepresentation) {
                            var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition(), lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                            null != firstAudioTimeReference && firstTimeReferences.push(firstAudioTimeReference), 
                            null != lastAudioTimeReference && lastTimeReferences.push(lastAudioTimeReference);
                        }
                    }
                    firstTimeReferences.length && (firstTimeReference = Math.max.apply(Math, firstTimeReferences)), 
                    lastTimeReferences.length && (lastTimeReference = Math.min.apply(Math, lastTimeReferences));
                }
                if (isLive) {
                    periodStart = 0, suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY, availabilityStartTime = REFERENCE_DATE_TIME;
                    var time = performance.now();
                    maximumTime = {
                        isContinuous: !0,
                        value: null != lastTimeReference ? lastTimeReference : Date.now() / 1e3 - availabilityStartTime,
                        time: time
                    }, 
                    // infinite buffer
                    minimumTime = null == timeShiftBufferDepth ? {
                        isContinuous: !1,
                        value: null != firstTimeReference ? firstTimeReference : availabilityStartTime,
                        time: time
                    } : {
                        isContinuous: !0,
                        value: Math.min(maximumTime.value - timeShiftBufferDepth + 5, maximumTime.value),
                        time: time
                    };
                    var manifestDuration = root.getAttribute("Duration");
                    duration = null != manifestDuration && 0 != +manifestDuration ? +manifestDuration / timescale : void 0;
                } else {
                    minimumTime = {
                        isContinuous: !1,
                        value: periodStart = null != firstTimeReference ? firstTimeReference : 0,
                        time: performance.now()
                    };
                    // if non-live and first time reference different than 0. Add first time reference
                    // to duration
                    var _manifestDuration = root.getAttribute("Duration");
                    duration = null != _manifestDuration && 0 != +_manifestDuration ? null == lastTimeReference ? +_manifestDuration / timescale + (firstTimeReference || 0) : lastTimeReference : void 0;
                }
                var periodDuration = null != duration ? duration - periodStart : void 0, manifest = {
                    availabilityStartTime: availabilityStartTime || 0,
                    duration: duration,
                    id: "gen-smooth-manifest-" + generateManifestID(),
                    isLive: isLive,
                    maximumTime: maximumTime,
                    minimumTime: minimumTime,
                    periods: [ {
                        adaptations: adaptations,
                        duration: periodDuration,
                        end: null == periodDuration ? void 0 : periodStart + periodDuration,
                        id: "gen-smooth-period-0",
                        start: periodStart
                    } ],
                    suggestedPresentationDelay: suggestedPresentationDelay,
                    transportType: "smooth",
                    uris: null == url ? [] : [ url ]
                };
                return Object(check_manifest_ids.a)(manifest), manifest;
            };
        }, request = __webpack_require__(18), string_from_utf8 = __webpack_require__(105), warn_once = __webpack_require__(19), check_isobmff_integrity = __webpack_require__(69), document_manifest_loader = __webpack_require__(121), utils = __webpack_require__(218), get_box = __webpack_require__(71);
        // CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /* harmony default export */        
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */
        function parseTfrf(traf) {
            var tfrf = Object(get_box.d)(traf, 3565190898, 3392751253, 2387879627, 2655430559);
            if (!tfrf) return [];
            for (var frags = [], version = tfrf[0], fragCount = tfrf[4], i = 0; i < fragCount; i++) {
                var duration = void 0, time = void 0;
                duration = 1 === version ? (time = Object(byte_parsing.d)(tfrf, 16 * i + 5), Object(byte_parsing.d)(tfrf, 16 * i + 5 + 8)) : (time = Object(byte_parsing.c)(tfrf, 8 * i + 5), 
                Object(byte_parsing.c)(tfrf, 8 * i + 5 + 4)), frags.push({
                    time: time,
                    duration: duration
                });
            }
            return frags;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */        function parseTfxd(traf) {
            var tfxd = Object(get_box.d)(traf, 1830656773, 1121273062, 2162299933, 2952222642);
            if (null != tfxd) return {
                duration: Object(byte_parsing.d)(tfxd, 12),
                time: Object(byte_parsing.d)(tfxd, 4)
            };
        }
        // CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */        function extractTimingsInfos(data, isChunked, segment, isLive) {
            var tfxdSegment, tfrfSegments, nextSegments = [];
            if (isLive) {
                var traf = Object(read.c)(data);
                traf ? (tfrfSegments = parseTfrf(traf), tfxdSegment = parseTfxd(traf)) : log.a.warn("smooth: could not find traf atom");
            }
            if (tfrfSegments) for (var i = 0; i < tfrfSegments.length; i++) nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale
            });
            if (tfxdSegment) return {
                nextSegments: nextSegments,
                chunkInfos: {
                    time: tfxdSegment.time,
                    duration: tfxdSegment.duration,
                    timescale: segment.timescale
                }
            };
            if (isChunked) return {
                nextSegments: nextSegments,
                chunkInfos: null
            };
 // we could always make a mistake when reading a container.
            // If the estimate is too far from what the segment seems to imply, take
            // the segment infos instead.
                        var maxDecodeTimeDelta = Math.min(.9 * segment.timescale, segment.duration / 4), trunDuration = Object(utils.a)(data);
            return {
                nextSegments: nextSegments,
                chunkInfos: 0 <= trunDuration && (null == segment.duration || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta) ? {
                    time: segment.time,
                    duration: trunDuration,
                    timescale: segment.timescale
                } : {
                    time: segment.time,
                    duration: segment.duration,
                    timescale: segment.timescale
                }
            };
        }
        // EXTERNAL MODULE: ./src/parsers/containers/isobmff/create_box.ts
                var create_box = __webpack_require__(161);
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/add_data_offset_flag_in_trun.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Update `trun` box given to add a data offset flag and the corresponding space
 * to set a data offset.
 * Do not do anything if the flag is already set.
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */        function addDataOffsetFlagInTrun(trun) {
            if (1 & trun[11]) return trun;
 // If no dataoffset is present, we add one
                        var newTrun = new Uint8Array(trun.length + 4);
            return newTrun.set(Object(byte_parsing.l)(trun.length + 4), 0), // original length + data_offset size
            newTrun.set(trun.subarray(4, 16), 4), // name + (version + flags) + samplecount
            newTrun[11] = 1 | newTrun[11], // add data_offset flag
            newTrun.set([ 0, 0, 0, 0 ], 16), // add data offset
            newTrun.set(trun.subarray(16, trun.length), 20), newTrun;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */        function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
            return Object(create_box.a)("avc1", Object(byte_parsing.h)(6, // 6 bytes reserved
            Object(byte_parsing.k)(1), 16, // drefIdx + QuickTime reserved, zeroes
            Object(byte_parsing.k)(width), // size 2 w
            Object(byte_parsing.k)(height), // size 2 h
            Object(byte_parsing.k)(hRes), 2, // reso 4 h
            Object(byte_parsing.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
            [ 0, 1, encName.length ], // frame count (default 1)
            Object(byte_parsing.p)(encName), // 1byte len + encoder name str
            31 - encName.length, // + padding
            Object(byte_parsing.k)(colorDepth), // color depth
            [ 255, 255 ], // reserved ones
            avcc));
        }
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */        function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
            return Object(create_box.a)("encv", Object(byte_parsing.h)(6, // 6 bytes reserved
            Object(byte_parsing.k)(1), 16, // drefIdx + QuickTime reserved, zeroes
            Object(byte_parsing.k)(width), // size 2 w
            Object(byte_parsing.k)(height), // size 2 h
            Object(byte_parsing.k)(hRes), 2, // reso 4 h
            Object(byte_parsing.k)(vRes), 6, // reso 4 v + QuickTime reserved, zeroes
            [ 0, 1, encName.length ], // frame count (default 1)
            Object(byte_parsing.p)(encName), // 1byte len + encoder name str
            31 - encName.length, // + padding
            Object(byte_parsing.k)(colorDepth), // color depth
            [ 255, 255 ], // reserved ones
            avcc, // avcc atom,
            sinf));
        }
        /**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */        function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
            return Object(create_box.a)("mp4a", Object(byte_parsing.h)(6, Object(byte_parsing.k)(drefIdx), 8, Object(byte_parsing.k)(channelsCount), Object(byte_parsing.k)(sampleSize), 2, Object(byte_parsing.k)(packetSize), Object(byte_parsing.k)(sampleRate), 2, esds));
        }
        /**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */        function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
            return Object(create_box.a)("enca", Object(byte_parsing.h)(6, Object(byte_parsing.k)(drefIdx), 8, Object(byte_parsing.k)(channelsCount), Object(byte_parsing.k)(sampleSize), 2, Object(byte_parsing.k)(packetSize), Object(byte_parsing.k)(sampleRate), 2, esds, sinf));
        }
        /**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */        function createDREFBox(url) {
            // only one description here... FIXME
            return Object(create_box.a)("dref", Object(byte_parsing.h)(7, [ 1 ], url));
        }
        /**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */        function createFTYPBox(majorBrand, brands) {
            return Object(create_box.a)("ftyp", byte_parsing.h.apply(null, [ Object(byte_parsing.p)(majorBrand), [ 0, 0, 0, 1 ] ].concat(brands.map(byte_parsing.p))));
        }
        /**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */        function createSCHMBox(schemeType, schemeVersion) {
            return Object(create_box.a)("schm", Object(byte_parsing.h)(4, Object(byte_parsing.p)(schemeType), Object(byte_parsing.l)(schemeVersion)));
        }
        /**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */        function createTfdtBox(decodeTime) {
            return Object(create_box.a)("tfdt", Object(byte_parsing.h)([ 1, 0, 0, 0 ], Object(byte_parsing.m)(decodeTime)));
        }
        /**
 * @returns {Uint8Array}
 */        function createVMHDBox() {
            var arr = new Uint8Array(12);
            // QuickTime...
            return arr[3] = 1, Object(create_box.a)("vmhd", arr);
        }
        /**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createTREXBox(trackId) {
            // default sample desc idx = 1
            return Object(create_box.a)("trex", Object(byte_parsing.h)(4, Object(byte_parsing.l)(trackId), [ 0, 0, 0, 1 ], 12));
        }
        /**
 * @param {Number} length
 * @returns {Uint8Array}
 */        function createFreeBox(length) {
            return Object(create_box.a)("free", new Uint8Array(length - 8));
        }
        /**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */        function createESDSBox(stream, codecPrivateData) {
            return Object(create_box.a)("esds", Object(byte_parsing.h)(4, [ 3, 25 ], Object(byte_parsing.k)(stream), [ 0, 4, 17, 64, 21 ], 11, [ 5, 2 ], Object(byte_parsing.j)(codecPrivateData), [ 6, 1, 2 ]));
        }
        /**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */        function createFRMABox(dataFormat) {
            return Object(create_box.a)("frma", Object(byte_parsing.p)(dataFormat));
        }
        /**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */        function createAVCCBox(sps, pps, nalLen) {
            var nal = 2 === nalLen ? 1 : 4 === nalLen ? 3 : 0, h264Profile = sps[1], h264CompatibleProfile = sps[2], h264Level = sps[3];
 // Deduce AVC Profile from SPS
                        return Object(create_box.a)("avcC", Object(byte_parsing.h)([ 1, h264Profile, h264CompatibleProfile, h264Level, 252 | nal, 225 ], Object(byte_parsing.k)(sps.length), sps, [ 1 ], Object(byte_parsing.k)(pps.length), pps));
        }
        /**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */        function createHDLRBox(type) {
            var name, handlerName;
            switch (type) {
              case "video":
                name = "vide", handlerName = "VideoHandler";
                break;

              case "audio":
                name = "soun", handlerName = "SoundHandler";
                break;

              default:
                name = "hint", handlerName = "";
            }
            return Object(create_box.a)("hdlr", Object(byte_parsing.h)(8, Object(byte_parsing.p)(name), 12, Object(byte_parsing.p)(handlerName), 1));
        }
        /**
 * @param {number} timescale
 * @returns {Uint8Array}
 */        function createMDHDBox(timescale) {
            return Object(create_box.a)("mdhd", Object(byte_parsing.h)(12, Object(byte_parsing.l)(timescale), 8));
        }
        /**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createMVHDBox(timescale, trackId) {
            return Object(create_box.a)("mvhd", Object(byte_parsing.h)(12, Object(byte_parsing.l)(timescale), 4, [ 0, 1 ], 2, // we assume rate = 1;
            [ 1, 0 ], 10, // we assume volume = 100%;
            [ 0, 1 ], 14, // default matrix
            [ 0, 1 ], 14, // default matrix
            [ 64, 0, 0, 0 ], 26, Object(byte_parsing.k)(trackId + 1)));
        }
        /**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
 * @returns {Uint8Array}
 */        function createPSSHBox(systemId, privateData, keyIds) {
            void 0 === privateData && (privateData = new Uint8Array(0)), void 0 === keyIds && (keyIds = new Uint8Array(0));
            var version, kidList, _systemId = systemId.replace(/-/g, "");
            if (32 !== _systemId.length) throw new Error("HSS: wrong system id length");
            var kidCount = keyIds.length;
            return kidList = 0 < kidCount ? (version = 1, byte_parsing.h.apply(void 0, [ Object(byte_parsing.l)(kidCount) ].concat(keyIds))) : (version = 0, 
            []), Object(create_box.a)("pssh", Object(byte_parsing.h)([ version, 0, 0, 0 ], Object(byte_parsing.j)(_systemId), kidList, Object(byte_parsing.l)(privateData.length), privateData));
        }
        /**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */        function createSAIOBox(mfhd, tfhd, tfdt, trun) {
            return Object(create_box.a)("saio", Object(byte_parsing.h)(4, [ 0, 0, 0, 1 ], // ??
            Object(byte_parsing.l)(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
        }
        /**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */        function createSAIZBox(sencContent) {
            if (0 === sencContent.length) return Object(create_box.a)("saiz", new Uint8Array(0));
            var flags = Object(byte_parsing.c)(sencContent, 0), entries = Object(byte_parsing.c)(sencContent, 4), arr = new Uint8Array(entries + 9);
            arr.set(Object(byte_parsing.l)(entries), 5);
            for (var pairsCnt, pairsLen, i = 9, j = 8; j < sencContent.length; ) j += 8, // assuming IV is 8 bytes TODO handle 16 bytes IV
            // if we have extradata for each entry
            2 == (2 & flags) ? (pairsLen = 2, j += 6 * (pairsCnt = Object(byte_parsing.a)(sencContent, j)) + 2) : pairsLen = pairsCnt = 0, 
            arr[i] = 6 * pairsCnt + 8 + pairsLen, i++;
            return Object(create_box.a)("saiz", arr);
        }
        /**
 * @returns {Uint8Array}
 */        function createSMHDBox() {
            return Object(create_box.a)("smhd", new Uint8Array(8));
        }
        /**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */        function createSTSDBox(reps) {
            // only one description here... FIXME
            var arrBase = [ 7, [ reps.length ] ];
            return Object(create_box.a)("stsd", byte_parsing.h.apply(void 0, arrBase.concat(reps)));
        }
        /**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */        function createTKHDBox(width, height, trackId) {
            return Object(create_box.a)("tkhd", Object(byte_parsing.h)(Object(byte_parsing.l)(7), 8, // we assume track is enabled,
            // in media and in preview.
            Object(byte_parsing.l)(trackId), 20, // we assume trackId = 1;
            [ 1, 0, 0, 0 ], // we assume volume = 100%;
            [ 0, 1, 0, 0 ], 12, // default matrix
            [ 0, 1, 0, 0 ], 12, // default matrix
            [ 64, 0, 0, 0 ], // ??
            Object(byte_parsing.k)(width), 2, // width (TODO handle fixed)
            Object(byte_parsing.k)(height), 2));
        }
        /**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */        function createTENCBox(algId, ivSize, keyId) {
            return Object(create_box.a)("tenc", Object(byte_parsing.h)(6, [ algId, ivSize ], keyId));
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
            var trafs = [ tfhd, tfdt, trun ];
            return senc && trafs.push(Object(create_box.a)("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun)), 
            Object(create_box.b)("traf", trafs);
        }
        // EXTERNAL MODULE: ./src/compat/can_patch_isobmff.ts
                var can_patch_isobmff = __webpack_require__(145);
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/replace_moof.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Replace a moof in a segment by a new one.
 * @param {Uint8Array} segment
 * @param {Uint8Array} newMoof
 * @param {Array.<number>} moofOffsets
 * @param {number} trunOffsetInMoof
 * @returns {Uint8Array}
 */        function replaceMoofInSegment(segment, newMoof, moofOffsets, trunOffsetInMoof) {
            var oldMoofLength = moofOffsets[1] - moofOffsets[0], moofDelta = newMoof.length - oldMoofLength, mdatOffsets = Object(get_box.c)(segment, 1835295092
            /* "mdat" */);
            if (null == mdatOffsets) throw new Error("Smooth: Invalid ISOBMFF given");
            if (Object(can_patch_isobmff.a)() && (0 == moofDelta || moofDelta <= -8)) 
            // patch trun data_offset
            return newMoof.set(Object(byte_parsing.l)(mdatOffsets[0] + 8), trunOffsetInMoof + 16), 
            segment.set(newMoof, moofOffsets[0]), moofDelta <= -8 && segment.set(createFreeBox(-moofDelta), newMoof.length), 
            segment;
 // patch trun data_offset
                        newMoof.set(Object(byte_parsing.l)(mdatOffsets[0] + moofDelta + 8), trunOffsetInMoof + 16);
            var newSegment = new Uint8Array(segment.length + moofDelta), beforeMoof = segment.subarray(0, moofOffsets[0]), afterMoof = segment.subarray(moofOffsets[1], segment.length);
            return newSegment.set(beforeMoof, 0), newSegment.set(newMoof, beforeMoof.length), 
            newSegment.set(afterMoof, beforeMoof.length + newMoof.length), newSegment;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Patch ISOBMFF Segment downloaded in Smooth Streaming.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */        function patchSegment(segment, decodeTime) {
            var moofOffsets = Object(get_box.c)(segment, 1836019558
            /* moof */);
            if (null == moofOffsets) throw new Error("Smooth: Invalid ISOBMFF given");
            var moofContent = segment.subarray(moofOffsets[0] + 8, moofOffsets[1]), mfhdBox = Object(get_box.a)(moofContent, 1835427940
            /* mfhd */), trafContent = Object(get_box.b)(moofContent, 1953653094
            /* traf */);
            if (null == trafContent || null == mfhdBox) throw new Error("Smooth: Invalid ISOBMFF given");
            var tfhdBox = Object(get_box.a)(trafContent, 1952868452
            /* tfhd */), trunBox = Object(get_box.a)(trafContent, 1953658222
            /* trun */);
            if (null == tfhdBox || null == trunBox) throw new Error("Smooth: Invalid ISOBMFF given");
 // force trackId=1 since trackIds are not always reliable...
                        tfhdBox.set([ 0, 0, 0, 1 ], 12);
            var tfdtBox = createTfdtBox(decodeTime), newTrafBox = createTrafBox(tfhdBox, tfdtBox, addDataOffsetFlagInTrun(trunBox), mfhdBox, Object(get_box.d)(trafContent, 2721664850, 1520127764, 2722393154, 2086964724));
            return replaceMoofInSegment(segment, Object(create_box.b)("moof", [ mfhdBox, newTrafBox ]), moofOffsets, mfhdBox.length + tfhdBox.length + tfdtBox.length + 8
            /* moof size + name */ + 8
            /* traf size + name */);
        }
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                var Observable = __webpack_require__(8), byte_range = __webpack_require__(42);
        // EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
                // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */
        function createMOOVBox(mvhd, mvex, trak, pssList) {
            var children = [ mvhd, mvex, trak ];
            return pssList.forEach(function(pss) {
                var pssh = createPSSHBox(pss.systemId, pss.privateData, pss.keyIds);
                children.push(pssh);
            }), Object(create_box.b)("moov", children);
        }
        /**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
            var stbl = Object(create_box.b)("stbl", [ stsd, Object(create_box.a)("stts", new Uint8Array(8)), Object(create_box.a)("stsc", new Uint8Array(8)), Object(create_box.a)("stsz", new Uint8Array(12)), Object(create_box.a)("stco", new Uint8Array(8)) ]), dref = createDREFBox(Object(create_box.a)("url ", new Uint8Array([ 0, 0, 0, 1 ]))), dinf = Object(create_box.b)("dinf", [ dref ]), minf = Object(create_box.b)("minf", [ mhd, dinf, stbl ]), hdlr = createHDLRBox(type), mdhd = createMDHDBox(timescale), mdia = Object(create_box.b)("mdia", [ mdhd, hdlr, minf ]), tkhd = createTKHDBox(width, height, 1), trak = Object(create_box.b)("trak", [ tkhd, mdia ]), trex = createTREXBox(1), mvex = Object(create_box.b)("mvex", [ trex ]), moov = createMOOVBox(createMVHDBox(timescale, 1), mvex, trak, pssList), ftyp = createFTYPBox("isom", [ "isom", "iso2", "iso6", "avc1", "dash" ]);
            return Object(byte_parsing.h)(ftyp, moov);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */        function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
            var stsd, _pssList = pssList || [], _codecPrivateData$spl = codecPrivateData.split("00000001"), spsHex = _codecPrivateData$spl[1], ppsHex = _codecPrivateData$spl[2], avcc = createAVCCBox(Object(byte_parsing.j)(spsHex), Object(byte_parsing.j)(ppsHex), nalLength);
            if (_pssList.length && null != keyId) {
                var tenc = createTENCBox(1, 8, keyId), schi = Object(create_box.b)("schi", [ tenc ]), schm = createSCHMBox("cenc", 65536), frma = createFRMABox("avc1");
                stsd = createSTSDBox([ createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, Object(create_box.b)("sinf", [ frma, schm, schi ])) ]);
            } else {
                stsd = createSTSDBox([ createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc) ]);
            }
            return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height, _pssList);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */        var SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
        /**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */        function getAacesHeader(type, frequency, chans) {
            var val;
 // TODO : handle Idx = 15...
                        return val = ((val = ((val = (63 & type) << 4) | 31 & SAMPLING_FREQUENCIES.indexOf(frequency)) << 4) | 31 & chans) << 3, 
            Object(byte_parsing.e)(Object(byte_parsing.k)(val));
        }
        // CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */        function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
            void 0 === pssList && (pssList = []);
            var esds = createESDSBox(1, codecPrivateData || getAacesHeader(2, sampleRate, channelsCount));
            return createInitSegment(timescale, "audio", function() {
                if (!pssList.length || null == keyId) return createSTSDBox([ createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds) ]);
                var tenc = createTENCBox(1, 8, keyId), schi = Object(create_box.b)("schi", [ tenc ]), schm = createSCHMBox("cenc", 65536), frma = createFRMABox("mp4a"), sinf = Object(create_box.b)("sinf", [ frma, schm, schi ]);
                return createSTSDBox([ createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) ]);
            }(), createSMHDBox(), 0, 0, pssList);
        }
        // CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */        function regularSegmentLoader(_ref) {
            var headers, url = _ref.url, range = _ref.segment.range;
            return range && (headers = {
                Range: Object(byte_range.a)(range)
            }), Object(request.a)({
                url: url,
                responseType: "arraybuffer",
                headers: headers,
                sendProgressEvents: !0
            });
        }
        /**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */        var segment_loader = function generateSegmentLoader(customSegmentLoader) {
            return function(_ref2) {
                var segment = _ref2.segment, representation = _ref2.representation, adaptation = _ref2.adaptation, period = _ref2.period, manifest = _ref2.manifest;
                if (segment.isInit) {
                    if (!segment.privateInfos || null == segment.privateInfos.smoothInit) throw new Error("Smooth: Invalid segment format");
                    var responseData, smoothInitPrivateInfos = segment.privateInfos.smoothInit, protection = smoothInitPrivateInfos.protection, codecPrivateData = smoothInitPrivateInfos.codecPrivateData || "";
                    switch (adaptation.type) {
                      case "video":
                        responseData = createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                        codecPrivateData, protection && protection.keyId, protection && protection.keySystems);
                        break;

                      case "audio":
                        responseData = createAudioInitSegment(segment.timescale, smoothInitPrivateInfos.channels || 0, smoothInitPrivateInfos.bitsPerSample || 0, smoothInitPrivateInfos.packetSize || 0, smoothInitPrivateInfos.samplingRate || 0, codecPrivateData, protection && protection.keyId, protection && protection.keySystems);
                        break;

                      default:
                        0, responseData = new Uint8Array(0);
                    }
                    return Object(of.a)({
                        type: "data-created",
                        value: {
                            responseData: responseData
                        }
                    });
                }
                if (null == segment.mediaURL) return Object(of.a)({
                    type: "data-created",
                    value: {
                        responseData: null
                    }
                });
                var args = {
                    adaptation: adaptation,
                    manifest: manifest,
                    period: period,
                    representation: representation,
                    segment: segment,
                    transport: "smooth",
                    url: segment.mediaURL
                };
                return customSegmentLoader ? new Observable.a(function(obs) {
                    var hasFinished = !1, hasFallbacked = !1, abort = customSegmentLoader(args, {
                        reject: function reject(err) {
                            void 0 === err && (err = {}), hasFallbacked || (hasFinished = !0, obs.error(err));
                        },
                        resolve: function resolve(_args) {
                            hasFallbacked || (hasFinished = !0, obs.next({
                                type: "data-loaded",
                                value: {
                                    responseData: _args.data,
                                    size: _args.size,
                                    duration: _args.duration
                                }
                            }), obs.complete());
                        },
                        fallback: function fallback() {
                            hasFallbacked = !0, // HACK What is TypeScript/RxJS doing here??????
                            /* tslint:disable deprecation */
                            // @ts-ignore
                            regularSegmentLoader(args).subscribe(obs);
                        }
                    });
                    return function() {
                        hasFinished || hasFallbacked || "function" != typeof abort || abort();
                    };
                }) : regularSegmentLoader(args);
            };
        }, ISM_REG = /(\.isml?)(\?token=\S+)?$/, TOKEN_REG = /\?token=(\S+)/;
        /* harmony default export */        
        /**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */
        function extractISML(doc) {
            return doc.getElementsByTagName("media")[0].getAttribute("src");
        }
        /**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */        function extractToken(url) {
            var tokenMatch = url.match(TOKEN_REG);
            return tokenMatch && tokenMatch[1] || "";
        }
        /**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */        function replaceToken(url, token) {
            return token ? url.replace(TOKEN_REG, "?token=" + token) : url.replace(TOKEN_REG, "");
        }
        /**
 * @param {string} url
 * @returns {string}
 */        function resolveManifest(url) {
            return ISM_REG.test(url) ? (Object(warn_once.a)("Giving a isml URL to loadVideo is deprecated. Please give the Manifest URL directly"), 
            url.replace(ISM_REG, "$1/manifest$2")) : url;
        }
        // CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var WSX_REG = /\.wsx?(\?token=\S+)?/;
        /**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */        function addNextSegments(adaptation, nextSegments, dlSegment) {
            log.a.debug("Smooth Parser: update segments information.");
            for (var representations = adaptation.representations, i = 0; i < representations.length; i++) {
                representations[i].index._addSegments(nextSegments, dlSegment);
            }
        }
        /* harmony default export */        
        /**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
        function isMP4EmbeddedTrack(representation) {
            return !!representation.mimeType && 0 <= representation.mimeType.indexOf("mp4");
        }
        // CONCATENATED MODULE: ./src/transports/smooth/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = function(options) {
            var smoothManifestParser = smooth(options), segmentLoader = segment_loader(options.segmentLoader), manifestLoaderOptions = {
                customManifestLoader: options.manifestLoader
            }, segmentPipeline = {
                loader: function loader(content) {
                    return content.segment.isInit || !0 !== options.checkMediaSegmentIntegrity ? segmentLoader(content) : segmentLoader(content).pipe(Object(tap.a)(function(res) {
                        "data-loaded" !== res.type && "data-chunk" !== res.type || null === res.value.responseData || Object(check_isobmff_integrity.a)(new Uint8Array(res.value.responseData), content.segment.isInit);
                    }));
                },
                parser: function parser(_ref4) {
                    var content = _ref4.content, response = _ref4.response, segment = content.segment, adaptation = content.adaptation, manifest = content.manifest, data = response.data, isChunked = response.isChunked;
                    if (null == data) return Object(of.a)({
                        chunkData: null,
                        chunkInfos: null,
                        chunkOffset: 0,
                        appendWindow: [ void 0, void 0 ]
                    });
                    if (segment.isInit) {
                        // smooth init segments are crafted by hand. Their timescale is the one
                        // from the manifest.
                        var initSegmentInfos = {
                            timescale: segment.timescale,
                            time: 0,
                            duration: 0
                        };
                        return Object(of.a)({
                            chunkData: data,
                            chunkInfos: initSegmentInfos,
                            chunkOffset: 0,
                            appendWindow: [ void 0, void 0 ]
                        });
                    }
                    var responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data), _extractTimingsInfos = extractTimingsInfos(responseBuffer, isChunked, segment, manifest.isLive), nextSegments = _extractTimingsInfos.nextSegments, chunkInfos = _extractTimingsInfos.chunkInfos;
                    if (null == chunkInfos) throw new Error("Smooth Segment without time information");
                    var chunkData = patchSegment(responseBuffer, chunkInfos.time);
                    return nextSegments && addNextSegments(adaptation, nextSegments, chunkInfos), Object(of.a)({
                        chunkData: chunkData,
                        chunkInfos: chunkInfos,
                        chunkOffset: 0,
                        appendWindow: [ void 0, void 0 ]
                    });
                }
            };
            return {
                manifest: {
                    resolver: function resolver(_ref) {
                        var resolving, url = _ref.url;
                        if (null == url) return Object(of.a)({
                            url: void 0
                        });
 // TODO Remove WSX logic
                                                resolving = WSX_REG.test(url) ? (Object(warn_once.a)("Giving WSX URL to loadVideo is deprecated. You should only give Manifest URLs."), 
                        Object(request.a)({
                            url: replaceToken(url, ""),
                            responseType: "document"
                        }).pipe(Object(map.a)(function(_ref2) {
                            var extractedURL = extractISML(_ref2.value.responseData);
                            if (!extractedURL) throw new Error("Invalid ISML");
                            return extractedURL;
                        }))) : Object(of.a)(url);
                        var token = extractToken(url);
                        return resolving.pipe(Object(map.a)(function(_url) {
                            return {
                                url: replaceToken(resolveManifest(_url), token)
                            };
                        }));
                    },
                    loader: Object(document_manifest_loader.a)(manifestLoaderOptions),
                    parser: function parser(_ref3) {
                        var response = _ref3.response, reqURL = _ref3.url, url = null == response.url ? reqURL : response.url, data = "string" == typeof response.responseData ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData, manifestReceivedTime = response.receivedTime, parserResult = smoothManifestParser(data, url, manifestReceivedTime), manifest = new src_manifest.a(parserResult, {
                            representationFilter: options.representationFilter,
                            supplementaryImageTracks: options.supplementaryImageTracks,
                            supplementaryTextTracks: options.supplementaryTextTracks
                        });
                        return Object(of.a)({
                            manifest: manifest,
                            url: url
                        });
                    }
                },
                audio: segmentPipeline,
                video: segmentPipeline,
                text: {
                    loader: function loader(_ref5) {
                        var segment = _ref5.segment, representation = _ref5.representation;
                        if (segment.isInit || null == segment.mediaURL) return Object(of.a)({
                            type: "data-created",
                            value: {
                                responseData: null
                            }
                        });
                        var isMP4 = isMP4EmbeddedTrack(representation);
                        return isMP4 && !0 === options.checkMediaSegmentIntegrity ? Object(request.a)({
                            url: segment.mediaURL,
                            responseType: "arraybuffer",
                            sendProgressEvents: !0
                        }).pipe(Object(tap.a)(function(res) {
                            "data-loaded" === res.type && Object(check_isobmff_integrity.a)(new Uint8Array(res.value.responseData), segment.isInit);
                        })) : Object(request.a)({
                            url: segment.mediaURL,
                            responseType: isMP4 ? "arraybuffer" : "text",
                            sendProgressEvents: !0
                        });
                    },
                    parser: function parser(_ref6) {
                        var nextSegments, content = _ref6.content, response = _ref6.response, manifest = content.manifest, adaptation = content.adaptation, representation = content.representation, segment = content.segment, language = adaptation.language, _representation$mimeT = representation.mimeType, mimeType = void 0 === _representation$mimeT ? "" : _representation$mimeT, _representation$codec = representation.codec, codec = void 0 === _representation$codec ? "" : _representation$codec, data = response.data, isChunked = response.isChunked;
                        if (segment.isInit || null == data) return Object(of.a)({
                            chunkData: null,
                            chunkInfos: null,
                            chunkOffset: 0,
                            appendWindow: [ void 0, void 0 ]
                        });
                        var _sdStart, _sdEnd, _sdData, _sdType, chunkInfos = null, _sdTimescale = 1;
                        if (0 <= mimeType.indexOf("mp4")) {
                            var chunkBytes, timings = extractTimingsInfos(chunkBytes = "string" == typeof data ? Object(byte_parsing.p)(data) : data instanceof Uint8Array ? data : new Uint8Array(data), isChunked, segment, manifest.isLive);
                            nextSegments = timings.nextSegments, null == (chunkInfos = timings.chunkInfos) ? isChunked ? log.a.warn("Smooth: Unavailable time data for current text track.") : (_sdEnd = (_sdStart = segment.time) + segment.duration, 
                            _sdTimescale = segment.timescale) : (_sdStart = chunkInfos.time, _sdEnd = null != chunkInfos.duration ? chunkInfos.time + chunkInfos.duration : void 0, 
                            _sdTimescale = chunkInfos.timescale);
                            var lcCodec = codec.toLowerCase();
                            if ("application/ttml+xml+mp4" === mimeType || "stpp" === lcCodec || "stpp.ttml.im1t" === lcCodec) _sdType = "ttml"; else {
                                if ("wvtt" !== lcCodec) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "vtt";
                            }
                            var mdat = Object(read.a)(chunkBytes);
                            _sdData = Object(string_from_utf8.a)(mdat);
                        } else {
                            var chunkString;
                            if ("string" != typeof data) {
                                var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
                                chunkString = Object(byte_parsing.f)(bytesData);
                            } else chunkString = data;
                            var segmentTime = segment.time || 0;
 // vod is simple WebVTT or TTML text
                                                        switch (_sdEnd = (_sdStart = segmentTime) + segment.duration, 
                            _sdTimescale = segment.timescale, mimeType) {
                              case "application/x-sami":
                              case "application/smil":
                                // TODO SMIL should be its own format, no?
                                _sdType = "sami";
                                break;

                              case "application/ttml+xml":
                                _sdType = "ttml";
                                break;

                              case "text/vtt":
                                _sdType = "vtt";
                            }
                            if (!_sdType) {
                                if ("srt" !== codec.toLowerCase()) throw new Error("could not find a text-track parser for the type " + mimeType);
                                _sdType = "srt";
                            }
                            _sdData = chunkString;
                        }
                        return null != chunkInfos && nextSegments && addNextSegments(adaptation, nextSegments, chunkInfos), 
                        Object(of.a)({
                            chunkData: {
                                type: _sdType,
                                data: _sdData,
                                language: language,
                                timescale: _sdTimescale,
                                start: _sdStart,
                                end: _sdEnd
                            },
                            chunkInfos: chunkInfos,
                            chunkOffset: null == _sdStart ? 0 : _sdStart / _sdTimescale,
                            appendWindow: [ void 0, void 0 ]
                        });
                    }
                },
                image: {
                    loader: function loader(_ref7) {
                        var segment = _ref7.segment;
                        return segment.isInit || null == segment.mediaURL ? Object(of.a)({
                            type: "data-created",
                            value: {
                                responseData: null
                            }
                        }) : Object(request.a)({
                            url: segment.mediaURL,
                            responseType: "arraybuffer",
                            sendProgressEvents: !0
                        });
                    },
                    parser: function parser(_ref8) {
                        var response = _ref8.response, segment = _ref8.content.segment, data = response.data;
                        if (response.isChunked) throw new Error("Image data should not be downloaded in chunks");
 // TODO image Parsing should be more on the sourceBuffer side, no?
                                                if (null === data || null == features.a.imageParser) return Object(of.a)({
                            chunkData: null,
                            chunkInfos: 0 < segment.timescale ? {
                                duration: segment.isInit ? 0 : segment.duration,
                                time: segment.isInit ? 0 : segment.time,
                                timescale: segment.timescale
                            } : null,
                            chunkOffset: 0,
                            appendWindow: [ void 0, void 0 ]
                        });
                        var bifObject = features.a.imageParser(new Uint8Array(data)), thumbsData = bifObject.thumbs;
                        return Object(of.a)({
                            chunkData: {
                                data: thumbsData,
                                start: 0,
                                end: Number.MAX_VALUE,
                                timescale: 1,
                                type: "bif"
                            },
                            chunkInfos: {
                                time: 0,
                                duration: Number.MAX_VALUE,
                                timescale: bifObject.timescale
                            },
                            chunkOffset: 0,
                            appendWindow: [ void 0, void 0 ]
                        });
                    }
                }
            };
        };
        /***/    }, 
    /* 197 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
        var get_cue_blocks = __webpack_require__(106), utils = __webpack_require__(56);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
        function getStyleBlocks(linified, headerOffset) {
            for (var styleBlocks = [], i = headerOffset; i < linified.length; i++) 
            //
            if (Object(utils.d)(linified, i)) {
                var startOfStyleBlock = i;
                // continue incrementing i until either:
                //   - empty line
                //   - end of file
                for (i++; linified[i]; ) i++;
                var styleBlock = linified.slice(startOfStyleBlock, i);
                styleBlocks.push(styleBlock);
            } else if (linified[i]) 
            // continue incrementing i until either:
            //   - empty line
            //   - end
            for (;linified[i]; ) i++;
            return styleBlocks;
        }
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
                var parse_cue_block = __webpack_require__(122), colorMap = {
            white: "#ffffff",
            lime: "#00ff00",
            cyan: "#00ffff",
            red: "#ff0000",
            yellow: "#ffff00",
            magenta: "#ff00ff",
            blue: "#0000ff",
            black: "#000000"
        };
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
        /**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */        function createDefaultStyleElements() {
            return Object.keys(colorMap).reduce(function(result, key) {
                return result[key] = "color: " + colorMap[key] + ";", result["bg_" + key] = "background-color: " + colorMap[key] + ";", 
                result;
            }, {});
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse style element from WebVTT.
 * @param {Array.<Array.<string>>} styleBlocks
 * @return {Object}
 */        function parseStyleBlocks(styleBlocks) {
            var classes = createDefaultStyleElements(), global = "";
            return styleBlocks.forEach(function(styleBlock) {
                if (2 <= styleBlock.length) for (var index = 1; index < styleBlock.length; index++) {
                    var line = styleBlock[index];
                    if (line.match(/::cue {/)) for (line = styleBlock[++index]; line && !line.match(/}/) && 0 !== line.length; ) global += line, 
                    line = styleBlock[++index]; else !function() {
                        for (var classNames = [], cueClassLine = void 0; line && (cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/)); ) classNames.push(cueClassLine[1]), 
                        line = styleBlock[++index];
                        for (var styleContent = ""; line && !line.match(/}/) && 0 !== line.length; ) styleContent += line, 
                        line = styleBlock[++index];
                        classNames.forEach(function(className) {
                            classes[className] ? classes[className] += styleContent : classes[className] = styleContent;
                        });
                    }();
                }
            }), {
                classes: classes,
                global: global
            };
        }
        // EXTERNAL MODULE: ./src/utils/array_includes.ts
                var array_includes = __webpack_require__(12);
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */        function createStyledElement(baseNode, styleElements) {
            var nodeWithStyle, HTMLTags = [ "u", "i", "b" ], mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
            if (Object(array_includes.a)([ "u", "i", "b", "c", "#text" ], mainNodeName)) if ("#text" === mainNodeName) {
                var linifiedText = baseNode.wholeText.split("\n");
                nodeWithStyle = document.createElement("span");
                for (var i = 0; i < linifiedText.length; i++) if (i && nodeWithStyle.appendChild(document.createElement("br")), 
                0 < linifiedText[i].length) {
                    var textNode = document.createTextNode(linifiedText[i]);
                    nodeWithStyle.appendChild(textNode);
                }
            } else {
                var nodeClasses = baseNode.nodeName.toLowerCase().split("."), styleContents = [];
                if (nodeClasses.forEach(function(nodeClass) {
                    styleElements[nodeClass] && styleContents.push(styleElements[nodeClass]);
                }), 0 !== styleContents.length) {
                    // If style must be applied
                    var attr = document.createAttribute("style");
                    styleContents.forEach(function(styleContent) {
                        attr.value += styleContent;
                    });
                    var nameClass = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    (nodeWithStyle = document.createElement(nameClass)).setAttributeNode(attr);
                } else {
                    // If style mustn't be applied. Rebuild element with tag name
                    var elementTag = Object(array_includes.a)(HTMLTags, mainNodeName) ? mainNodeName : "span";
                    nodeWithStyle = document.createElement(elementTag);
                }
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    var child = createStyledElement(baseNode.childNodes[j], styleElements);
                    nodeWithStyle.appendChild(child);
                }
            } else {
                nodeWithStyle = document.createElement("span");
                for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
                    var _child = createStyledElement(baseNode.childNodes[_j], styleElements);
                    nodeWithStyle.appendChild(_child);
                }
            }
            return nodeWithStyle;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */        function convertPayloadToHTML(text, styleElements) {
            for (var filteredText = text.replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "").replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>"), nodes = new DOMParser().parseFromString(filteredText, "text/html").body.childNodes, styledElements = [], i = 0; i < nodes.length; i++) styledElements.push(createStyledElement(nodes[i], styleElements));
            return styledElements;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */        function toHTML(cueObj, styling) {
            var start = cueObj.start, end = cueObj.end, header = cueObj.header, payload = cueObj.payload, region = document.createElement("div"), regionAttr = document.createAttribute("style");
            regionAttr.value = "width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;", 
            region.setAttributeNode(regionAttr);
            // Get content, format and apply style.
            var pElement = document.createElement("p"), pAttr = document.createAttribute("style");
            pAttr.value = "text-align:center", pElement.setAttributeNode(pAttr);
            var spanElement = document.createElement("span"), attr = document.createAttribute("style");
            // set color and background-color default values, as indicated in:
            // https://www.w3.org/TR/webvtt1/#applying-css-properties
            attr.value = "background-color:rgba(0,0,0,0.8);color:white;", spanElement.setAttributeNode(attr);
            var global = styling.global, classes = styling.classes, styles = [ global, header ? classes[header] : void 0 ].filter(function(s) {
                return !!s;
            }).join("");
            return attr.value += styles, spanElement.setAttributeNode(attr), convertPayloadToHTML(payload.join("\n"), classes).forEach(function(element) {
                spanElement.appendChild(element);
            }), region.appendChild(pElement), pElement.appendChild(spanElement), {
                start: start,
                end: end,
                element: region
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseWebVTT(text, timeOffset) {
            var linified = text.split(/\r\n|\n|\r/g), cuesArray = [];
 // CRLF|LF|CR
                        if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) throw new Error("Can't parse WebVTT: Invalid File.");
            for (var firstLineAfterHeader = Object(utils.b)(linified), styleBlocks = getStyleBlocks(linified, firstLineAfterHeader), cueBlocks = Object(get_cue_blocks.a)(linified, firstLineAfterHeader), styles = parseStyleBlocks(styleBlocks), i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(parse_cue_block.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var htmlCue = toHTML(cueObject, styles);
                    cuesArray.push(htmlCue);
                }
            }
            return cuesArray;
        };
        /***/    }, 
    /* 198 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
        var object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), array_find = __webpack_require__(9), get_parameters = __webpack_require__(108), get_parent_elements_by_tag_name = __webpack_require__(75), get_styling = __webpack_require__(30), nodes = __webpack_require__(52), get_time_delimiters = __webpack_require__(123), regexps = __webpack_require__(21);
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
        function generateCSSTextOutline(color, thickness) {
            return "-1px -1px " + thickness + " " + color + ",1px -1px " + thickness + " " + color + ",-1px 1px " + thickness + " " + color + ",1px 1px " + thickness + " " + color;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */        function ttmlColorToCSSColor(color) {
            // TODO check all possible color fomats
            var regRes;
            return null != (regRes = regexps.b.exec(color)) ? "rgba(" + parseInt(regRes[1], 16) + "," + parseInt(regRes[2], 16) + "," + parseInt(regRes[3], 16) + "," + parseInt(regRes[4], 16) / 255 + ")" : null != (regRes = regexps.a.exec(color)) ? "rgba(" + parseInt(regRes[1] + regRes[1], 16) + "," + parseInt(regRes[2] + regRes[2], 16) + "," + parseInt(regRes[3] + regRes[3], 16) + "," + parseInt(regRes[4] + regRes[4], 16) / 255 + ")" : color;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        // Styling which can be applied to <span> from any level upper.
        // Added here as an optimization
                var SPAN_LEVEL_ATTRIBUTES = [ "color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption" ];
 // TODO
        // tts:showBackground (applies to region)
        // tts:zIndex (applies to region)
        /**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */        function applyTextStyle(element, style, shouldTrimWhiteSpace) {
            // applies to span
            var color = style.color;
            color && (element.style.color = ttmlColorToCSSColor(color));
 // applies to body, div, p, region, span
                        var backgroundColor = style.backgroundColor;
            backgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor));
 // applies to span
                        var textOutline = style.textOutline;
            if (textOutline) {
                var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" "), len = outlineData.length;
                if (3 === len) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]), thickness = outlineData[1];
                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
                } else if (color && 1 === len) {
                    var _thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, _thickness);
                } else if (2 === len) {
                    var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
                    // XOR-ing to be sure we get what we have
                    if (isFirstArgAColor !== /^[0-9]/.test(outlineData[0])) if (isFirstArgAColor) {
                        var _outlineColor = ttmlColorToCSSColor(outlineData[0]), _thickness2 = outlineData[1];
                        element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
                    } else if (color) {
                        var _thickness3 = outlineData[0];
                        element.style.textShadow = generateCSSTextOutline(color, _thickness3);
                    }
                }
            }
 // applies to span
                        var textDecoration = style.textDecoration;
            if (textDecoration) switch (textDecoration) {
              case "noUnderline":
              case "noLineThrough":
              case "noOverline":
                element.style.textDecoration = "none";
                break;

              case "lineThrough":
                element.style.textDecoration = "line-through";
                break;

              default:
                element.style.textDecoration = textDecoration;
            }
 // applies to span
                        var fontFamily = style.fontFamily;
            if (fontFamily) switch (fontFamily) {
              case "proportionalSansSerif":
                element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
                break;

                // TODO monospace or sans-serif or font with both?
                              case "monospaceSansSerif":
              case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;

              case "monospaceSerif":
              case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;

                // TODO font with both?
                              case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;

              default:
                element.style.fontFamily = fontFamily;
            }
 // applies to span
                        var fontStyle = style.fontStyle;
            fontStyle && (element.style.fontStyle = fontStyle);
 // applies to span
                        var fontWeight = style.fontWeight;
            fontWeight && (element.style.fontWeight = fontWeight);
 // applies to span
                        var fontSize = style.fontSize;
            fontSize && (
            // TODO Check if formats are always really 1:1
            element.style.fontSize = fontSize);
 // applies to p, span
                        var direction = style.direction;
            direction && (element.style.direction = direction);
 // applies to p, span
                        var unicodeBidi = style.unicodeBidi;
            if (unicodeBidi) switch (unicodeBidi) {
              case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;

              case "embed":
                element.style.unicodeBidi = "embed";
                break;

              default:
                element.style.unicodeBidi = "normal";
            }
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                        // applies to body, div, p, region, span
            var wrapOption = style.wrapOption;
            element.style.whiteSpace = "noWrap" === wrapOption ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
        }
        /**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */        function applyGeneralStyle(element, style) {
            // applies to tt, region
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (element.style.width = results[1] + "%", element.style.height = results[2] + "%");
            }
 // applies to region
                        style.writingMode;
            var overflow = style.overflow;
            element.style.overflow = overflow || "hidden";
            // applies to region
            var padding = style.padding;
            padding && (element.style.padding = padding);
 // applies to region
                        var origin = style.origin;
            if (origin) {
                var resultsPercent = regexps.c.exec(origin);
                null != resultsPercent && (element.style.position = "relative", element.style.left = resultsPercent[1] + "%", 
                element.style.top = resultsPercent[2] + "%");
            }
 // applies to region
                        var displayAlign = style.displayAlign;
            if (element.style.display = "flex", element.style.flexDirection = "column", displayAlign) switch (displayAlign) {
              case "before":
                element.style.justifyContent = "flex-start";
                break;

              case "center":
                element.style.justifyContent = "center";
                break;

              case "after":
                element.style.justifyContent = "flex-end";
            }
 // applies to region
                        var opacity = style.opacity;
            opacity && (element.style.opacity = opacity);
 // applies to body, div, p, region, span
                        var visibility = style.visibility;
            visibility && (element.style.visibility = visibility), "none" === style.display && (element.style.display = "none");
 // applies to body, div, p, region, span
                }
        /**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */        function applyPStyle(element, style) {
            // applies to body, div, p, region, span
            var paragraphBackgroundColor = style.backgroundColor;
            paragraphBackgroundColor && (element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor));
 // applies to p
                        var lineHeight = style.lineHeight;
            lineHeight && (element.style.lineHeight = lineHeight);
 // applies to p
                        var textAlign = style.textAlign;
            if (textAlign) switch (textAlign) {
              case "center":
                element.style.textAlign = "center";
                break;

              case "left":
              case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;

              case "right":
              case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
            }
        }
        /**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */        function createTextElement(el, style, shouldTrimWhiteSpace) {
            var textElement = document.createElement("span"), textContent = el.textContent || "";
            if (shouldTrimWhiteSpace) {
                // 1. Trim leading and trailing whitespace.
                // 2. Collapse multiple spaces into one.
                var trimmed = textContent.trim();
                textContent = trimmed = trimmed.replace(/\s+/g, " ");
            }
            return textElement.innerHTML = textContent, textElement.className = "rxp-texttrack-span", 
            applyTextStyle(textElement, style, shouldTrimWhiteSpace), textElement;
        }
        /**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */        function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
            return function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, elements = [], i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var backgroundColor = Object(get_styling.a)([ "backgroundColor" ], spans, styles, regions).backgroundColor;
                        backgroundColor ? style.backgroundColor = backgroundColor : delete style.backgroundColor;
                        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
                        elements.push(el);
                    } else if ("br" === currentNode.nodeName) {
                        var br = document.createElement("BR");
                        elements.push(br);
                    } else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space"), shouldTrimWhiteSpaceOnSpan = spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent, newStyle = object_assign_default()({}, style, Object(get_styling.a)(SPAN_LEVEL_ATTRIBUTES, [ currentNode ], styles, regions));
                        elements.push.apply(elements, loop(currentNode, newStyle, [ currentNode ].concat(spans), shouldTrimWhiteSpaceOnSpan));
                    }
                }
                return elements;
            }(paragraph, object_assign_default()({}, paragraphStyle), [], shouldTrimWhiteSpace);
        }
        /**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {HTMLElement}
 */        function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
            var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), parentElement = document.createElement("DIV");
            if (parentElement.className = "rxp-texttrack-region", applyGeneralStyle(parentElement, paragraphStyle), 
            body) {
                // applies to body, div, p, region, span
                var bodyBackgroundColor = Object(get_styling.a)([ "backgroundColor" ], [].concat(divs, [ body ]), styles, regions).bodyBackgroundColor;
                bodyBackgroundColor && (parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor));
            }
            var pElement = document.createElement("p");
            pElement.className = "rxp-texttrack-p", applyPStyle(pElement, paragraphStyle);
            for (var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace), i = 0; i < textContent.length; i++) pElement.appendChild(textContent[i]);
 // NOTE:
            // The following code is for the inclusion of div elements. This has no
            // advantage for now, and might only with future evolutions.
            // (This is only an indication of what the base of the code could look like).
            // if (divs.length) {
            //   let container = parentElement;
            //   for (let i = divs.length - 1; i >= 0; i--) {
            //     // TODO manage style at div level?
            //     // They are: visibility, display and backgroundColor
            //     // All these do not have any difference if applied to the <p> element
            //     // instead of the div.
            //     // The advantage might only be for multiple <p> elements dispatched
            //     // in multiple div Which we do not manage anyway for now.
            //     const divEl = document.createElement("DIV");
            //     divEl.className = "rxp-texttrack-div";
            //     container.appendChild(divEl);
            //     container = divEl;
            //   }
            //   container.appendChild(pElement);
            //   parentElement.appendChild(container);
            // } else {
            //   parentElement.appendChild(pElement);
            // }
                        return parentElement.appendChild(pElement), parentElement;
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {Object|null}
 */        function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(get_time_delimiters.a)(paragraph, ttParams);
            return {
                start: _getTimeDelimiters.start + offset,
                end: _getTimeDelimiters.end + offset,
                element: createElement(paragraph, body, regions, styles, styleBase, shouldTrimWhiteSpace)
            };
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var STYLE_ATTRIBUTES = [ "backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode" ];
        /**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseTTMLStringToDIV(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), paragraphNodes = Object(nodes.d)(tt), params = Object(get_parameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null !== styleID && 
                        // TODO styles referencing other styles
                        styles.push({
                            id: styleID,
                            style: Object(get_styling.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null !== regionID && function() {
                            var regionStyle = Object(get_styling.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = Object(array_find.a)(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                // TODO Compute corresponding CSS style here (as soon as we now the TTML
                // style) to speed up the process even
                // more.
                                for (var bodyStyle = null !== body ? Object(get_styling.a)(STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(get_styling.a)(STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(get_styling.a)(STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, styles, regions, body, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        };
        /***/    }, 
    /* 199 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
        var merge = __webpack_require__(81), interval = __webpack_require__(214), concat = __webpack_require__(124), of = __webpack_require__(23), Subject = __webpack_require__(41), startWith = __webpack_require__(205), switchMapTo = __webpack_require__(220), mapTo = __webpack_require__(165), takeUntil = __webpack_require__(166), compat = __webpack_require__(6), config = __webpack_require__(3), log = __webpack_require__(0), abstract_source_buffer = __webpack_require__(76), MAX_DELTA_BUFFER_TIME = .2;
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
                /**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
        function areNearlyEqual(a, b) {
            return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
        }
        /**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesBefore(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                if (time < cues[i].end) return cues.slice(0, i);
            }
            return cues.slice();
        }
        /**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */        function getCuesAfter(cues, time) {
            for (var i = 0; i < cues.length; i++) {
                if (cues[i].start > time) return cues.slice(i, cues.length);
            }
            return [];
        }
        /**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */        function removeCuesInfosBetween(cuesInfos, start, end) {
            var end1 = Math.max(cuesInfos.start, start), cues1 = getCuesBefore(cuesInfos.cues, start), cuesInfos1 = {
                start: cuesInfos.start,
                end: end1,
                cues: cues1
            }, start2 = Math.min(end, cuesInfos.end), cues2 = getCuesAfter(cuesInfos.cues, end);
            return [ cuesInfos1, {
                start: start2,
                end: cuesInfos.end,
                cues: cues2
            } ];
        }
        // CONCATENATED MODULE: ./src/custom_source_buffers/text/html/buffer_manager.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */        var buffer_manager_TextBufferManager = 
        /* */
        function() {
            function TextBufferManager() {
                this._cuesBuffer = [];
            }
            /**
   * Get corresponding cue for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */            var _proto = TextBufferManager.prototype;
            return _proto.get = function get(time) {
                // begins at the end as most of the time the player will ask for the last
                // CuesGroup
                for (var cuesBuffer = this._cuesBuffer, i = cuesBuffer.length - 1; 0 <= i; i--) for (var cues = cuesBuffer[i].cues, j = cues.length - 1; 0 <= j; j--) {
                    var cue = cues[j];
                    if (time >= cue.start) return time < cue.end ? cue : void 0;
                }
            }
            /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */ , _proto.remove = function remove(from, _to) {
                for (var to = Math.max(from, _to), cuesBuffer = this._cuesBuffer, len = cuesBuffer.length, i = 0; i < len; i++) if (cuesBuffer[i].end > from) {
                    var startCuesInfos = cuesBuffer[i];
                    if (startCuesInfos.start >= to) 
                    // our cue is strictly after this interval, we have nothing to do
                    return;
 // ``to`` is within this segment
                                        if (startCuesInfos.end >= to) {
                        var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _removeCuesInfosBetwe[0], cuesInfos2 = _removeCuesInfosBetwe[1];
                        return this._cuesBuffer[i] = cuesInfos1, void cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    }
 // Else remove the part of the segment after ``from``, and the concerned
                    // segments after that
                                        startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from), 
                    startCuesInfos.end = Math.max(from, startCuesInfos.start);
                    for (var j = i + 1; j < len; j++) {
                        var endCuesInfos = cuesBuffer[i];
                        if (to <= endCuesInfos.end) 
                        // remove all cues from the start to this one non-included
                        return cuesBuffer.splice(i + 1, j - (i + 1)), void (// if ``to`` is in the middle of the last segment
                        to > endCuesInfos.start && (endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to), 
                        endCuesInfos.start = to));
                    }
                    return void cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
                }
            }
            /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */ , _proto.insert = function insert(cues, start, end) {
                for (var cuesBuffer = this._cuesBuffer, cuesInfosToInsert = {
                    start: start,
                    end: end,
                    cues: cues
                }, i = 0; i < cuesBuffer.length; i++) {
                    var cuesInfos = cuesBuffer[i];
                    if (start < cuesInfos.end) {
                        if (areNearlyEqual(start, cuesInfos.start)) {
                            if (areNearlyEqual(end, cuesInfos.end)) 
                            // exact same segment
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBB|
                            //   Result:          |AAAAA|
                            // Which means:
                            //   1. replace the current cue with ours
                            return void (cuesBuffer[i] = cuesInfosToInsert);
 // our cue goes beyond the current one:
                            //   ours:            |AAAAAAA|
                            //   the current one: |BBBB|
                            //   Result:          |AAAAAAA|
                            // Here we have to delete any cuesInfos which end before ours end,
                            // and see about the following one.
                                                        if (end < cuesInfos.end) 
                            // our cue overlaps with the current one:
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            // Which means:
                            //   1. remove some cues at the start of the current one
                            //   2. update start of current one
                            //   3. add ours before the current one
                            return cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, 
                            void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                            for (;cuesBuffer.splice(i, 1), (cuesInfos = cuesBuffer[i]) && end > cuesInfos.end; ) ;
                            return !cuesInfos || // There is no cue here
                            areNearlyEqual(end, cuesInfos.end) ? 
                            // put in place
                            void (cuesBuffer[i] = cuesInfosToInsert) : (// else -> end < cuesInfos.end (overlapping case)
                            //   ours:            |AAAAA|
                            //   the current one: |BBBBBBBB|
                            //   Result:          |AAAAABBB|
                            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end), cuesInfos.start = end, void cuesBuffer.splice(i, 0, cuesInfosToInsert));
                        }
 // else -> start > cuesInfos.start
                                                if (start < cuesInfos.start) return end < cuesInfos.start || (areNearlyEqual(end, cuesInfos.start) || (// our cue overlaps the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:     |BBBBB|
                        //   Result:          |AAAAAAABB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end)), 
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end), 
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        void cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) 
                        // our cue overlaps the current one:
                        //   ours:              |AAAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |BBAAAAAA|
                        //   - or -
                        //   ours:              |AAAA|
                        //   the current one: |BBBBBB|
                        //   Result:          |BBAAAA|
                        // Which means:
                        //   1. remove some cues at the end of the current one
                        //   2. update end of current one
                        //   3. add ours after current one
                        return cuesInfos.cues = getCuesBefore(cuesInfos.cues, start), cuesInfos.end = start, 
                        void cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
 // else -> end < cuesInfos.end
                        // our cue is in the current one:
                        //   ours:              |AAA|
                        //   the current one: |BBBBBBB|
                        //   Result:          |BBAAABB|
                        // Which means:
                        //   1. split current one in two parts based on our cue.
                        //   2. insert our cue into it.
                                                var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _removeCuesInfosBetwe2[0], cuesInfos2 = _removeCuesInfosBetwe2[1];
                        return this._cuesBuffer[i] = cuesInfos1, cuesBuffer.splice(i + 1, 0, cuesInfosToInsert), 
                        void cuesBuffer.splice(i + 2, 0, cuesInfos2);
                    }
                }
 // no cues group has the end after our current start.
                // These cues should be the last one
                                cuesBuffer.push(cuesInfosToInsert);
            }, TextBufferManager;
        }(), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/custom_source_buffers/text/html/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToElements(type, data, timestampOffset, language) {
            log.a.debug("HTSB: Finding parser for html text tracks:", type);
            var parser = features.a.htmlTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("HTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("HTTB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/custom_source_buffers/text/html/html_text_source_buffer.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */        var onEnded$ = compat.a.onEnded$, onSeeked$ = compat.a.onSeeked$, onSeeking$ = compat.a.onSeeking$, MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config.a.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
        /**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
        function generateClock(videoElement) {
            var seeking$ = onSeeking$(videoElement), seeked$ = onSeeked$(videoElement), ended$ = onEnded$(videoElement), manualRefresh$ = Object(merge.a)(seeked$, ended$), autoRefresh$ = Object(interval.a)(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(startWith.a)(null));
            return manualRefresh$.pipe(Object(startWith.a)(null), Object(switchMapTo.a)(Object(concat.a)(autoRefresh$.pipe(Object(mapTo.a)(!0), Object(takeUntil.a)(seeking$)), Object(of.a)(!1))));
        }
        /**
 * @param {Element} element
 * @param {Element|null} [child]
 */        function safelyRemoveChild(element, child) {
            if (child) try {
                element.removeChild(child);
            } catch (e) {
                log.a.warn("HTSB: Can't remove text track: not in the element.");
            }
        }
        /**
 * SourceBuffer to display TextTracks in the given HTML element.
 * @class HTMLTextSourceBuffer
 */        var html_text_source_buffer_HTMLTextSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
            function HTMLTextSourceBuffer(videoElement, textTrackElement) {
                var _this;
                return log.a.debug("HTSB: Creating html text track SourceBuffer"), (_this = _AbstractSourceBuffer.call(this) || this)._videoElement = videoElement, 
                _this._textTrackElement = textTrackElement, _this._destroy$ = new Subject.a(), _this._buffer = new buffer_manager_TextBufferManager(), 
                _this._currentElement = null, generateClock(_this._videoElement).pipe(Object(takeUntil.a)(_this._destroy$)).subscribe(function(shouldDisplay) {
                    if (!shouldDisplay) return safelyRemoveChild(textTrackElement, _this._currentElement), 
                    void (_this._currentElement = null);
 // to spread the time error, we divide the regular chosen interval.
                    // As the clock is also based on real video events, we cannot just
                    // divide by two the regular interval.
                                        var time = Math.max(_this._videoElement.currentTime - MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2e3, 0), cue = _this._buffer.get(time);
                    if (!cue) return safelyRemoveChild(textTrackElement, _this._currentElement), void (_this._currentElement = null);
                    _this._currentElement !== cue.element && (safelyRemoveChild(textTrackElement, _this._currentElement), 
                    _this._currentElement = cue.element, textTrackElement.appendChild(_this._currentElement));
                }), _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(HTMLTextSourceBuffer, _AbstractSourceBuffer);
            var _proto = HTMLTextSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("HTSB: Appending new html text tracks", data);
                var start, end, timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language, startTime = null != timescaledStart ? timescaledStart / timescale : void 0, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language);
                if (0 !== this.appendWindowStart && Infinity !== this.appendWindowEnd) {
                    for (
                    // Removing before window start
                    var i = 0; i < cues.length && cues[i].end <= this.appendWindowStart; ) i++;
                    for (cues.splice(0, i), i = 0; i < cues.length && cues[i].start < this.appendWindowStart; ) cues[i].start = this.appendWindowStart, 
                    i++;
 // Removing after window end
                                        for (i = cues.length - 1; 0 <= i && cues[i].start >= this.appendWindowEnd; ) i--;
                    for (cues.splice(i, cues.length), i = cues.length - 1; 0 <= i && cues[i].end > this.appendWindowEnd; ) cues[i].end = this.appendWindowEnd, 
                    i--;
                }
                if (null != startTime) start = Math.max(this.appendWindowStart, startTime); else {
                    if (cues.length <= 0) return void log.a.warn("HTSB: Current text tracks have no cues nor start time. Aborting");
                    log.a.warn("HTSB: No start time given. Guessing from cues."), start = cues[0].start;
                }
                if (null != endTime) end = Math.min(this.appendWindowEnd, endTime); else {
                    if (cues.length <= 0) return void log.a.warn("HTSB: Current text tracks have no cues nor end time. Aborting");
                    log.a.warn("HTSB: No end time given. Guessing from cues."), end = cues[cues.length - 1].end;
                }
                end <= start ? log.a.warn("HTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.") : (this._buffer.insert(cues, start, end), 
                this.buffered.insert(start, end));
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.debug("HTSB: Removing html text track data", from, to), this._buffer.remove(from, to), 
                this.buffered.remove(from, to);
            }
            /**
   * Free up ressources from this sourceBuffer
   */ , _proto._abort = function _abort() {
                log.a.debug("HTSB: Aborting html text track SourceBuffer"), this._remove(0, Infinity), 
                this._destroy$.next(), this._destroy$.complete(), safelyRemoveChild(this._textTrackElement, this._currentElement);
            }, HTMLTextSourceBuffer;
        }(abstract_source_buffer.a);
        // CONCATENATED MODULE: ./src/custom_source_buffers/text/html/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = html_text_source_buffer_HTMLTextSourceBuffer;
    }, 
    /* 200 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/add_text_track.ts
        var add_text_track = __webpack_require__(146), log = __webpack_require__(0), browser_detection = __webpack_require__(20);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
                // CONCATENATED MODULE: ./src/compat/remove_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */
        function isActiveCue(track, cue) {
            for (var activeCues = track.activeCues, i = 0; i < activeCues.length; i++) if (activeCues[i] === cue) return !0;
            return !1;
        }
        /**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */        function removeCue(track, cue) {
            // On Firefox, cue doesn't dissapear when it is removed from track. Track
            // should be hidden, and shown again after removing cue, in order to
            // definitely clean the cue.
            if (browser_detection.a && isActiveCue(track, cue)) {
                var trackMode = track.mode;
                track.mode = "hidden";
                try {
                    track.removeCue(cue);
                } catch (err) {
                    log.a.warn("Compat: Could not remove cue from text track.");
                }
                track.mode = trackMode;
            } else try {
                track.removeCue(cue);
            } catch (err) {
                log.a.warn("Compat: Could not remove cue from text track.");
            }
        }
        // EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
                var abstract_source_buffer = __webpack_require__(76), features = __webpack_require__(10);
        // EXTERNAL MODULE: ./src/features/index.ts
                // CONCATENATED MODULE: ./src/custom_source_buffers/text/native/parsers.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
        function parseTextTrackToCues(type, data, timestampOffset, language) {
            log.a.debug("NTSB: Finding parser for native text tracks:", type);
            var parser = features.a.nativeTextTracksParsers[type];
            if (!parser) throw new Error("no parser found for the given text track");
            log.a.debug("NTSB: Parser found, parsing...");
            var parsed = parser(data, timestampOffset, language);
            return log.a.debug("NTSB: Parsed successfully!", parsed), parsed;
        }
        // CONCATENATED MODULE: ./src/custom_source_buffers/text/native/native_text_source_buffer.ts
                function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * SourceBuffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextSourceBuffer
 * @extends AbstractSourceBuffer
 */        var native_text_source_buffer_NativeTextSourceBuffer = 
        /* */
        function(_AbstractSourceBuffer) {
            /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
            function NativeTextSourceBuffer(videoElement, hideNativeSubtitle) {
                var _this;
                log.a.debug("NTSB: Creating native text track SourceBuffer"), _this = _AbstractSourceBuffer.call(this) || this;
                var _addTextTrack = Object(add_text_track.a)(videoElement, hideNativeSubtitle), track = _addTextTrack.track, trackElement = _addTextTrack.trackElement;
                return _this._videoElement = videoElement, _this._track = track, _this._trackElement = trackElement, 
                _this;
            }
            /**
   * Append text tracks.
   * @param {Object} data
   */            _inheritsLoose(NativeTextSourceBuffer, _AbstractSourceBuffer);
            var _proto = NativeTextSourceBuffer.prototype;
            return _proto._append = function _append(data) {
                log.a.debug("NTSB: Appending new native text tracks", data);
                var start, end, timescale = data.timescale, timescaledStart = data.start, timescaledEnd = data.end, dataString = data.data, type = data.type, language = data.language, startTime = null != timescaledStart ? timescaledStart / timescale : void 0, endTime = null != timescaledEnd ? timescaledEnd / timescale : void 0, cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);
                if (0 !== this.appendWindowStart && Infinity !== this.appendWindowEnd) {
                    for (
                    // Removing before window start
                    var i = 0; i < cues.length && cues[i].endTime <= this.appendWindowStart; ) i++;
                    for (cues.splice(0, i), i = 0; i < cues.length && cues[i].startTime < this.appendWindowStart; ) cues[i].startTime = this.appendWindowStart, 
                    i++;
 // Removing after window end
                                        for (i = cues.length - 1; 0 <= i && cues[i].startTime >= this.appendWindowEnd; ) i--;
                    for (cues.splice(i, cues.length), i = cues.length - 1; 0 <= i && cues[i].endTime > this.appendWindowEnd; ) cues[i].endTime = this.appendWindowEnd, 
                    i--;
                }
                if (null != startTime) start = Math.max(this.appendWindowStart, startTime); else {
                    if (cues.length <= 0) return void log.a.warn("NTSB: Current text tracks have no cues nor start time. Aborting");
                    log.a.warn("NTSB: No start time given. Guessing from cues."), start = cues[0].startTime;
                }
                if (null != endTime) end = Math.min(this.appendWindowEnd, endTime); else {
                    if (cues.length <= 0) return void log.a.warn("NTSB: Current text tracks have no cues nor end time. Aborting");
                    log.a.warn("NTSB: No end time given. Guessing from cues."), end = cues[cues.length - 1].endTime;
                }
                if (end <= start) log.a.warn("NTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time."); else if (cues.length <= 0) this.buffered.insert(start, end); else {
                    var firstCue = cues[0], currentCues = this._track.cues;
 // NOTE(compat): cleanup all current cues if the newly added
                    // ones are in the past. this is supposed to fix an issue on
                    // IE/Edge.
                    // TODO Move to compat
                                        0 < currentCues.length && firstCue.startTime < currentCues[currentCues.length - 1].startTime && this._remove(firstCue.startTime, Infinity);
                    for (var _i = 0; _i < cues.length; _i++) this._track.addCue(cues[_i]);
                    this.buffered.insert(start, end);
                }
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.debug("NTSB: Removing native text track data", from, to);
                var track = this._track, cues = track.cues;
                if (null != cues) for (var i = cues.length - 1; 0 <= i; i--) {
                    var cue = cues[i], startTime = cue.startTime, endTime = cue.endTime;
                    from <= startTime && startTime <= to && endTime <= to && removeCue(track, cue);
                }
                this.buffered.remove(from, to);
            }, _proto._abort = function _abort() {
                log.a.debug("NTSB: Aborting native text track SourceBuffer"), this._remove(0, Infinity);
                var _trackElement = this._trackElement, _videoElement = this._videoElement;
                if (_trackElement && _videoElement && _videoElement.hasChildNodes()) try {
                    _videoElement.removeChild(_trackElement);
                } catch (e) {
                    log.a.warn("NTSB: Can't remove track element from the video");
                }
                this._track && (this._track.mode = "disabled"), this._trackElement && (this._trackElement.innerHTML = "");
            }, NativeTextSourceBuffer;
        }(abstract_source_buffer.a);
        // CONCATENATED MODULE: ./src/custom_source_buffers/text/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */        __webpack_exports__.default = native_text_source_buffer_NativeTextSourceBuffer;
    }, 
    /* 201 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
        var is_vtt_cue = __webpack_require__(147), get_cue_blocks = __webpack_require__(106), parse_cue_block = __webpack_require__(122), utils = __webpack_require__(56), array_includes = __webpack_require__(12);
        // EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
                // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */
        function setSettingsOnCue(settings, cue) {
            if (!settings.vertical || "rl" !== settings.vertical && "lr" !== settings.vertical || (cue.vertical = settings.vertical), 
            settings.line) {
                /**
     * Capture groups:
     *   1 -> percentage position
     *   2 -> optional decimals from percentage position
     *   3 -> optional follow-up of the string indicating alignment value
     *   4 -> alignment value
     * @type {RegExp}
     */
                var percentageMatches = settings.line.match(/^(\d+(\.\d+)?)%(,([a-z]+))?/);
                if (percentageMatches) cue.line = Number(percentageMatches[1]), cue.snapToLines = !1, 
                Object(array_includes.a)([ "start", "center", "end" ], percentageMatches[4]) && (cue.lineAlign = percentageMatches[4]); else {
                    /**
       * Capture groups:
       *   1 -> line number
       *   2 -> optional follow-up of the string indicating alignment value
       *   3 -> alignment value
       * @type {RegExp}
       */
                    var lineMatches = settings.line.match(/^(-?\d+)(,([a-z]+))?/);
                    lineMatches && (cue.line = Number(lineMatches[1]), cue.snapToLines = !0, Object(array_includes.a)([ "start", "center", "end" ], lineMatches[3]) && (cue.lineAlign = lineMatches[3]));
                }
            }
            if (settings.position) {
                var positionArr = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/.exec(settings.position);
                if (positionArr && 2 <= positionArr.length) {
                    var position = parseInt(positionArr[1], 10);
                    isNaN(position) || (cue.position = position, null != positionArr[2] && (cue.positionAlign = positionArr[2]));
                }
            }
            settings.size && (cue.size = settings.size), settings.align && Object(array_includes.a)([ "start", "center", "end", "left" ], settings.align) && (cue.align = settings.align);
        }
        // EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
                var make_vtt_cue = __webpack_require__(107);
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */        function toNativeCue(cueObj) {
            var start = cueObj.start, end = cueObj.end, text = cueObj.payload.join("\n");
            return Object(make_vtt_cue.a)(start, end, text);
        }
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        // Simple VTT to ICompatVTTCue parser:
        // Just parse cues and associated settings.
        // Does not take into consideration STYLE and REGION blocks.
        /**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */        
        // CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */ __webpack_exports__.default = function parseVTTStringToVTTCues(vttStr, timeOffset) {
            // WEBVTT authorize CRLF, LF or CR as line terminators
            var lines = vttStr.split(/\r\n|\n|\r/);
            if (!/^WEBVTT($| |\t)/.test(lines[0])) throw new Error("Can't parse WebVTT: Invalid file.");
            for (var firstLineAfterHeader = Object(utils.b)(lines), cueBlocks = Object(get_cue_blocks.a)(lines, firstLineAfterHeader), cues = [], i = 0; i < cueBlocks.length; i++) {
                var cueObject = Object(parse_cue_block.a)(cueBlocks[i], timeOffset);
                if (null != cueObject) {
                    var nativeCue = toNativeCue(cueObject);
                    null != nativeCue && (Object(is_vtt_cue.a)(nativeCue) && setSettingsOnCue(cueObject.settings, nativeCue), 
                    cues.push(nativeCue));
                }
            }
            return cues;
        };
        /***/    }, 
    /* 202 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./src/log.ts + 1 modules
        var log = __webpack_require__(0);
        // EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
                // CONCATENATED MODULE: ./src/custom_source_buffers/image/image_source_buffer.ts
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /**
 * Image SourceBuffer implementation.
 * @class ImageSourceBuffer
 */        var image_source_buffer = 
        /* */
        function(_AbstractSourceBuffer) {
            function ImageSourceBuffer() {
                return _AbstractSourceBuffer.apply(this, arguments) || this;
            }
            _inheritsLoose(ImageSourceBuffer, _AbstractSourceBuffer);
            var _proto = ImageSourceBuffer.prototype;
            /**
   * @param {Object} data
   */            return _proto._append = function _append(data) {
                log.a.debug("ImageSourceBuffer: appending new data.");
                var start = data.start, end = data.end, timescale = data.timescale, timescaledStart = start / timescale, timescaledEnd = null == end ? Number.MAX_VALUE : end / timescale, startTime = Math.max(this.appendWindowStart, timescaledStart), endTime = Math.min(this.appendWindowEnd, timescaledEnd);
                this.buffered.insert(startTime, endTime);
            }
            /**
   * @param {Number} from
   * @param {Number} to
   */ , _proto._remove = function _remove(from, to) {
                log.a.info("ImageSourceBuffer: ignored image data remove order", from, to);
 // TODO once a better strategy for image cleaning has been set (surely done
                // when we will work for live thumbnails), restore this implementation.
                // log.debug("ImageSourceBuffer: removing image data", from, to);
                // this.buffered.remove(from, to);
                        }, _proto._abort = function _abort() {
                log.a.debug("ImageSourceBuffer: aborting image SourceBuffer"), this._remove(0, Infinity);
            }, ImageSourceBuffer;
        }(__webpack_require__(76).a);
        /* harmony default export */        __webpack_exports__.default = image_source_buffer;
    }, 
    /* 203 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        // EXTERNAL MODULE: ./node_modules/object-assign/index.js
        var object_assign = __webpack_require__(11), object_assign_default = /* */ __webpack_require__.n(object_assign), make_vtt_cue = __webpack_require__(107), is_vtt_cue = __webpack_require__(147), array_find = __webpack_require__(9), get_parameters = __webpack_require__(108), get_parent_elements_by_tag_name = __webpack_require__(75), get_styling = __webpack_require__(30), get_time_delimiters = __webpack_require__(123), nodes = __webpack_require__(52), regexps = __webpack_require__(21), WANTED_STYLE_ATTRIBUTES = [ "extent", "writingMode", "origin", "align" ], TEXT_ALIGN_TO_LIGN_ALIGN = {
            left: "start",
            center: "center",
            right: "end",
            start: "start",
            end: "end"
        }, TEXT_ALIGN_TO_POSITION_ALIGN = {
            left: "line-left",
            center: "center",
            right: "line-right"
        };
        /**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {TextTrackCue|null}
 */
        function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params, shouldTrimWhiteSpace) {
            // Disregard empty elements:
            // TTML allows for empty elements like <div></div>.
            // If paragraph has neither time attributes, nor
            // non-whitespace text, don't try to make a cue out of it.
            if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) return null;
            var _getTimeDelimiters = Object(get_time_delimiters.a)(paragraph, params), start = _getTimeDelimiters.start, end = _getTimeDelimiters.end, text = generateTextContent(paragraph, shouldTrimWhiteSpace), cue = Object(make_vtt_cue.a)(start + offset, end + offset, text);
            return cue ? (Object(is_vtt_cue.a)(cue) && addStyle(cue, paragraphStyle), cue) : null;
        }
        /**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */        function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
            /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
            return function loop(node, shouldTrimWhiteSpaceFromParent) {
                for (var childNodes = node.childNodes, text = "", i = 0; i < childNodes.length; i++) {
                    var currentNode = childNodes[i];
                    if ("#text" === currentNode.nodeName) {
                        var textContent = currentNode.textContent || "";
                        if (shouldTrimWhiteSpaceFromParent) {
                            // 1. Trim leading and trailing whitespace.
                            // 2. Collapse multiple spaces into one.
                            var trimmed = textContent.trim();
                            textContent = trimmed = trimmed.replace(/\s+/g, " ");
                        }
 // DOM Parser turns HTML escape caracters into caracters,
                        // that may be misinterpreted by VTTCue API (typically, less-than sign
                        // and greater-than sign can be interpreted as HTML tags signs).
                        // Original escaped caracters must be conserved.
                                                text += textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
                    } else if ("br" === currentNode.nodeName) text += "\n"; else if ("span" === currentNode.nodeName && currentNode.nodeType === Node.ELEMENT_NODE && 0 < currentNode.childNodes.length) {
                        var spaceAttribute = currentNode.getAttribute("xml:space");
                        text += loop(currentNode, spaceAttribute ? "default" === spaceAttribute : shouldTrimWhiteSpaceFromParent);
                    }
                }
                return text;
            }(paragraph, shouldTrimWhiteSpaceForParagraph);
        }
        /**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */        function addStyle(cue, style) {
            var extent = style.extent;
            if (extent) {
                var results = regexps.c.exec(extent);
                null != results && (
                // Use width value of the extent attribute for size.
                // Height value is ignored.
                cue.size = Number(results[1]));
            }
            // let isVerticalText = true;
            switch (style.writingMode) {
              case "tb":
              case "tblr":
                cue.vertical = "lr";
                break;

              case "tbrl":
                cue.vertical = "rl";
            }
            var origin = style.origin;
            if (origin) regexps.c.exec(origin);
            var align = style.align;
            align && ("center" === (cue.align = align) && ("center" !== cue.align && (
            // Workaround for a Chrome bug http://crbug.com/663797
            // Chrome does not support align = "center"
            cue.align = "middle"), cue.position = "auto"), cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "", 
            cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "");
        }
        /* harmony default export */        
        /**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
        function parse_ttml_to_vtt(str, timeOffset) {
            var ret = [], xml = new DOMParser().parseFromString(str, "text/xml");
            if (xml) {
                var tt = xml.getElementsByTagName("tt")[0];
                if (!tt) throw new Error("invalid XML");
                for (var body = Object(nodes.a)(tt), styleNodes = Object(nodes.c)(tt), regionNodes = Object(nodes.b)(tt), paragraphNodes = Object(nodes.d)(tt), params = Object(get_parameters.a)(tt), styles = [], i = 0; i <= styleNodes.length - 1; i++) {
                    // TODO styles referencing other styles
                    var styleNode = styleNodes[i];
                    if (styleNode instanceof Element) {
                        var styleID = styleNode.getAttribute("xml:id");
                        null != styleID && styles.push({
                            id: styleID,
                            style: Object(get_styling.b)(styleNode)
                        });
                    }
                }
 // construct regions array based on the xml as an optimization
                                for (var regions = [], _i = 0; _i <= regionNodes.length - 1; _i++) {
                    var regionNode = regionNodes[_i];
                    if (regionNode instanceof Element) {
                        var regionID = regionNode.getAttribute("xml:id");
                        null != regionID && function() {
                            var regionStyle = Object(get_styling.b)(regionNode), associatedStyle = regionNode.getAttribute("style");
                            if (associatedStyle) {
                                var style = Object(array_find.a)(styles, function(x) {
                                    return x.id === associatedStyle;
                                });
                                style && (regionStyle = object_assign_default()({}, style.style, regionStyle));
                            }
                            regions.push({
                                id: regionID,
                                style: regionStyle
                            });
                        }();
                    }
                }
 // Computing the style takes a lot of ressources.
                // To avoid too much re-computation, let's compute the body style right
                // now and do the rest progressively.
                                for (var bodyStyle = body ? Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [ body ], styles, regions) : Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [], styles, regions), shouldTrimWhiteSpaceOnBody = "default" === (body ? body.getAttribute("xml:space") : void 0) || "default" === params.spaceStyle, _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
                    var paragraph = paragraphNodes[_i2];
                    if (paragraph instanceof Element) {
                        var divs = Object(get_parent_elements_by_tag_name.a)(paragraph, "div"), paragraphStyle = object_assign_default()({}, bodyStyle, Object(get_styling.a)(WANTED_STYLE_ATTRIBUTES, [ paragraph ].concat(divs), styles, regions)), paragraphSpaceAttribute = paragraph.getAttribute("xml:space"), cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params, paragraphSpaceAttribute ? "default" === paragraphSpaceAttribute : shouldTrimWhiteSpaceOnBody);
                        cue && ret.push(cue);
                    }
                }
            }
            return ret;
        }
        __webpack_exports__.default = parse_ttml_to_vtt;
        // CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
        /* harmony default export */    }, 
    /* 204 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromEvent;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54), _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
        /* harmony import */        function fromEvent(target, eventName, options, resultSelector) {
            return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(options) && (resultSelector = options, 
            options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__.a)(function(args) {
                return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            })) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                setupSubscription(target, eventName, function handler(e) {
                    1 < arguments.length ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
                }, subscriber, options);
            });
        }
        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options), unsubscribe = function() {
                    return source_1.removeEventListener(eventName, handler, options);
                };
            } else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler), unsubscribe = function() {
                    return source_2.off(eventName, handler);
                };
            } else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler), unsubscribe = function() {
                    return source_3.removeListener(eventName, handler);
                };
            } else {
                if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                for (var i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
            subscriber.add(unsubscribe);
        }
        function isNodeStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
        }
        function isJQueryStyleEventEmitter(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
        }
        function isEventTarget(sourceObj) {
            return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
        }
        //# sourceMappingURL=fromEvent.js.map
        /***/    }, 
    /* 205 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return startWith;
        });
        /* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(124), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
        /* harmony import */        
        /** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
        function startWith() {
            for (var array = [], _i = 0; _i < arguments.length; _i++) array[_i] = arguments[_i];
            var scheduler = array[array.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(scheduler) ? (array.pop(), 
            function(source) {
                return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(array, source, scheduler);
            }) : function(source) {
                return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(array, source);
            };
        }
        //# sourceMappingURL=startWith.js.map
        /***/    }, 
    /* 206 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map() : void 0;
            return (_wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (null === Class || !_isNativeFunction(Class)) return Class;
                if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class)) return _cache.get(Class);
                    _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class);
            })(Class);
        }
        function isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
                !0;
            } catch (e) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
                var a = [ null ];
                a.push.apply(a, args);
                var instance = new (Function.bind.apply(Parent, a))();
                return Class && _setPrototypeOf(instance, Class.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _setPrototypeOf(o, p) {
            return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                return o.__proto__ = p, o;
            })(o, p);
        }
        function _getPrototypeOf(o) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
        }
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return AssertionError;
        });
        var AssertionError = 
        /* */
        function(_Error) {
            /**
   * @param {string} message
   */
            function AssertionError(message) {
                var _this;
                return _this = _Error.call(this) || this, // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
                Object.setPrototypeOf(_assertThisInitialized(_this), AssertionError.prototype), 
                _this.name = "AssertionError", _this.message = message, _this;
            }
            return _inheritsLoose(AssertionError, _Error), AssertionError;
        }(_wrapNativeSuper(Error));
        /***/    }, 
    /* 207 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return catchError;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function catchError(selector) {
            return function catchErrorOperatorFunction(source) {
                var operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        var CatchOperator = /* */ function() {
            function CatchOperator(selector) {
                this.selector = selector;
            }
            return CatchOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            }, CatchOperator;
        }(), CatchSubscriber = /* */ function(_super) {
            function CatchSubscriber(destination, selector, caught) {
                var _this = _super.call(this, destination) || this;
                return _this.selector = selector, _this.caught = caught, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CatchSubscriber, _super), CatchSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var result = void 0;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void _super.prototype.error.call(this, err2);
                    }
                    this._unsubscribeAndRecycle();
                    var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                    this.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, result, void 0, void 0, innerSubscriber);
                }
            }, CatchSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 208 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return setMediaKeys$;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82), _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17), _custom_media_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(135);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */
        function _setMediaKeys(elt, mediaKeys) {
            return mediaKeys instanceof _custom_media_keys__WEBPACK_IMPORTED_MODULE_2__.b ? mediaKeys._setVideo(elt) : elt.setMediaKeys ? elt.setMediaKeys(mediaKeys) : null !== mediaKeys ? elt.WebkitSetMediaKeys ? elt.WebkitSetMediaKeys(mediaKeys) : elt.mozSetMediaKeys ? elt.mozSetMediaKeys(mediaKeys) : elt.msSetMediaKeys ? elt.msSetMediaKeys(mediaKeys) : void 0 : void 0;
        }
        /**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */        function setMediaKeys$(elt, mediaKeys) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__.a)(_setMediaKeys(elt, mediaKeys));
            });
        }
        /***/    }, 
    /* 209 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
                var tslib_es6 = __webpack_require__(2), Observable = __webpack_require__(8), asap = __webpack_require__(88), isNumeric = __webpack_require__(67), SubscribeOnObservable_SubscribeOnObservable = /* */ function(_super) {
            function SubscribeOnObservable(source, delayTime, scheduler) {
                void 0 === delayTime && (delayTime = 0), void 0 === scheduler && (scheduler = asap.a);
                var _this = _super.call(this) || this;
                return _this.source = source, _this.delayTime = delayTime, _this.scheduler = scheduler, 
                (!Object(isNumeric.a)(delayTime) || delayTime < 0) && (_this.delayTime = 0), scheduler && "function" == typeof scheduler.schedule || (_this.scheduler = asap.a), 
                _this;
            }
            return tslib_es6.a(SubscribeOnObservable, _super), SubscribeOnObservable.create = function(source, delay, scheduler) {
                return void 0 === delay && (delay = 0), void 0 === scheduler && (scheduler = asap.a), 
                new SubscribeOnObservable(source, delay, scheduler);
            }, SubscribeOnObservable.dispatch = function(arg) {
                var source = arg.source, subscriber = arg.subscriber;
                return this.add(source.subscribe(subscriber));
            }, SubscribeOnObservable.prototype._subscribe = function(subscriber) {
                var delay = this.delayTime, source = this.source;
                return this.scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
                    source: source,
                    subscriber: subscriber
                });
            }, SubscribeOnObservable;
        }(Observable.a);
        // EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
                /** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
        function subscribeOn(scheduler, delay) {
            return void 0 === delay && (delay = 0), function subscribeOnOperatorFunction(source) {
                return source.lift(new subscribeOn_SubscribeOnOperator(scheduler, delay));
            };
        }
        //# sourceMappingURL=SubscribeOnObservable.js.map
        // CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return subscribeOn;
        });
        var subscribeOn_SubscribeOnOperator = /* */ function() {
            function SubscribeOnOperator(scheduler, delay) {
                this.scheduler = scheduler, this.delay = delay;
            }
            return SubscribeOnOperator.prototype.call = function(subscriber, source) {
                return new SubscribeOnObservable_SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
            }, SubscribeOnOperator;
        }();
        //# sourceMappingURL=subscribeOn.js.map
        /***/    }, 
    /* 210 */ 
    /* 211 */ , 
    /* 212 */ , 
    /* 213 */
    /***/ , 
    /* 213 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return combineLatest;
        });
        /* unused harmony export CombineLatestOperator */
        /* unused harmony export CombineLatestSubscriber */
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45), _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24), _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62), NONE = {};
        /* harmony import */        function combineLatest() {
            for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
            var resultSelector = null, scheduler = null;
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__.a)(observables[0]) && (observables = observables[0]), 
            Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        var CombineLatestOperator = /* */ function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector;
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            }, CombineLatestOperator;
        }(), CombineLatestSubscriber = /* */ function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], 
                _this.observables = [], _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__.a)(this, observable, observable, i));
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }, CombineLatestSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                var values = this.values, oldVal = values[outerIndex], toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }, CombineLatestSubscriber;
        }(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.a);
    }, 
    /* 214 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return interval;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
        function interval(period, scheduler) {
            return void 0 === period && (period = 0), void 0 === scheduler && (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(period) || period < 0) && (period = 0), 
            scheduler && "function" == typeof scheduler.schedule || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                return subscriber.add(scheduler.schedule(dispatch, period, {
                    subscriber: subscriber,
                    counter: 0,
                    period: period
                })), subscriber;
            });
        }
        function dispatch(state) {
            var subscriber = state.subscriber, counter = state.counter, period = state.period;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        //# sourceMappingURL=interval.js.map
        /***/    }, 
    /* 215 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return getInitData;
        });
        /* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1), _utils_hash_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27), _utils_simple_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68), _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the SourceBuffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Uint8Array} - Initialization data, "cleaned"
 */
        function cleanEncryptedEvent(initData) {
            for (var resInitData = new Uint8Array(), currentHashes = new _utils_simple_set__WEBPACK_IMPORTED_MODULE_4__.a(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_5__.a) return _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: Unrecognized initialization data. Use as is."), 
                initData;
                var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) return _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: Unrecognized initialization data. Use as is."), 
                initData;
                var currentPSSH = initData.subarray(offset, offset + len), currentPSSHHash = Object(_utils_hash_buffer__WEBPACK_IMPORTED_MODULE_3__.a)(currentPSSH);
                currentHashes.test(currentPSSHHash) ? _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: Duplicated PSSH found in initialization data, removing it.") : (currentHashes.add(currentPSSHHash), 
                resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.h)(resInitData, currentPSSH)), 
                offset += len;
            }
            return offset !== initData.length ? (_log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: Unrecognized initialization data. Use as is."), 
            initData) : resInitData;
        }
        /**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */        function getInitData(encryptedEvent) {
            var initData = encryptedEvent.initData;
            if (null == initData) throw new _errors__WEBPACK_IMPORTED_MODULE_0__.a("INVALID_ENCRYPTED_EVENT", "Compat: No init data found on media encrypted event.");
            return {
                initData: cleanEncryptedEvent(new Uint8Array(initData)),
                initDataType: encryptedEvent.initDataType
            };
        }
        /***/    }, 
    /* 216 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* unused harmony export patchInitData */
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return generateKeyRequest;
        });
        /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82), _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0), _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1), _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17), _browser_detection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20), _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99);
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Some browsers have problems when the CENC PSSH box is the first managed PSSH
 * encountered (for the moment just Edge was noted with this behavior).
 *
 * This function tries to move CENC PSSH boxes at the end of the given init
 * data.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */
        function patchInitData(initData) {
            var initialLength = initData.byteLength;
            _log__WEBPACK_IMPORTED_MODULE_1__.a.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
            for (var cencs = new Uint8Array(), resInitData = new Uint8Array(), offset = 0; offset < initData.length; ) {
                if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_5__.a) throw _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
                new Error("Compat: unrecognized initialization data. Cannot patch it.");
                var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(new Uint8Array(initData), offset);
                if (offset + len > initData.length) throw _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
                new Error("Compat: unrecognized initialization data. Cannot patch it.");
                var currentPSSH = initData.subarray(offset, offset + len);
 // yep
                                16 === initData[offset + 12] && 119 === initData[offset + 13] && 239 === initData[offset + 14] && 236 === initData[offset + 15] && 192 === initData[offset + 16] && 178 === initData[offset + 17] && 77 === initData[offset + 18] && 2 === initData[offset + 19] && 172 === initData[offset + 20] && 227 === initData[offset + 21] && 60 === initData[offset + 22] && 30 === initData[offset + 23] && 82 === initData[offset + 24] && 226 === initData[offset + 25] && 251 === initData[offset + 26] && 75 === initData[offset + 27] ? (_log__WEBPACK_IMPORTED_MODULE_1__.a.info("Compat: CENC PSSH found."), 
                cencs = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.h)(cencs, currentPSSH)) : resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.h)(resInitData, currentPSSH), 
                offset += len;
            }
            if (offset !== initData.length) throw _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: unrecognized initialization data. Cannot patch it."), 
            new Error("Compat: unrecognized initialization data. Cannot patch it.");
            if (resInitData.byteLength === initialLength) throw _log__WEBPACK_IMPORTED_MODULE_1__.a.warn("Compat: CENC PSSH not found. Cannot patch it"), 
            new Error("Compat: unrecognized initialization data. Cannot patch it.");
            return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.h)(resInitData, cencs);
        }
        /**
 * Generate a request from session.
 * @param {MediaKeySession}session - MediaKeySession on which the request will
 * be done.
 * @param {Uint8Array}initData - Initialization data given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} initDataType - Initialization data type given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} sessionType - Type of session you want to generate. Consult
 * EME Specification for more information on session types.
 * @returns {Observable} - Emit when done. Errors if fails.
 */        function generateKeyRequest(session, initData, initDataType) {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                var patchedInit;
                if (_log__WEBPACK_IMPORTED_MODULE_1__.a.debug("Compat: Calling generateRequest on the MediaKeySession"), 
                _browser_detection__WEBPACK_IMPORTED_MODULE_4__.c) try {
                    patchedInit = patchInitData(initData);
                } catch (_e) {
                    patchedInit = initData;
                } else patchedInit = initData;
                return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_3__.a)(session.generateRequest(initDataType || "", patchedInit));
            });
        }
        /***/    }, 
    /* 217 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return timer;
        });
        /* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67), _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
        /* harmony import */        
        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function timer(dueTime, periodOrScheduler, scheduler) {
            void 0 === dueTime && (dueTime = 0);
            var period = -1;
            return Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(periodOrScheduler) && (scheduler = periodOrScheduler), 
            Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(scheduler) || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(function(subscriber) {
                var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function dispatch(state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
        //# sourceMappingURL=timer.js.map
        /***/    }, 
    /* 218 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "b", function() {
            return getMDHDTimescale;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() {
            return getTrackFragmentDecodeTime;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() {
            return getDurationFromTrun;
        }), 
        /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() {
            return getSegmentsFromSidx;
        });
        /* unused harmony export patchPssh */
        /* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0), _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_require__(31), 
        __webpack_require__(1)), _read__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_require__(161), 
        __webpack_require__(126));
        /* harmony import */        
        /**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
        /**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found.
 *
 * This function calls log.error in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */
        function findBox(buf, wantedName) {
            for (var len = buf.length, i = 0; i + 8 < len; ) {
                var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, i);
                if (size <= 0) return _log__WEBPACK_IMPORTED_MODULE_0__.a.error("ISOBMFF: size out of range"), 
                -1;
                if (Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, i + 4) === wantedName) return i + size <= len ? i : (_log__WEBPACK_IMPORTED_MODULE_0__.a.error("ISOBMFF: box out of range"), 
                -1);
                i += size;
            }
            return -1;
        }
        /**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */        function getSegmentsFromSidx(buf, initialOffset) {
            var index = findBox(buf, 1936286840
            /* "sidx" */);
            if (-1 === index) return null;
            var offset = initialOffset, size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, index), pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = buf[pos];
            pos += 8;
            var time, timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
            if (pos += 4, 0 === version) time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos), 
            pos += 4, offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos) + size, 
            pos += 4; else {
                if (1 !== version) return null;
                time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(buf, pos), pos += 8, 
                offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(buf, pos) + size, 
                pos += 8;
            }
            var segments = [];
            /* reserved(16) */
            /* reference_count(16) */            pos += 2;
            var count = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.a)(buf, pos);
            for (pos += 2; 0 <= --count; ) {
                /* reference_type(1) */
                /* reference_size(31) */
                /* segment_duration(32) */
                /* sap..(32) */
                var refChunk = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
                pos += 4;
                var refSize = 2147483647 & refChunk;
                // when set to 1 indicates that the reference is to a sidx, else to media
                if (1 == (2147483648 & refChunk) >>> 31) throw new Error("sidx with reference_type `1` not yet implemented");
                var duration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(buf, pos);
                pos += 4, // let sapChunk = be4toi(buf, pos + 8);
                pos += 4, // TODO(pierre): handle sap
                // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
                // let sapType = (sapChunk & 0x70000000) >>> 28;
                // let sapDelta = sapChunk & 0x0FFFFFFF;
                segments.push({
                    time: time,
                    duration: duration,
                    count: 0,
                    timescale: timescale,
                    range: [ offset, offset + refSize - 1 ]
                }), time += duration, offset += refSize;
            }
            return segments;
        }
        /**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getTrackFragmentDecodeTime(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__.c)(buffer);
            if (!traf) return -1;
            var index = findBox(traf, 1952867444
            /* tfdt */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            return pos += 4, 1 < version ? -1 : version ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.d)(traf, pos) : Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos);
        }
        /**
 * @param {Uint8Array} traf
 * @returns {number}
 */        function getDefaultDurationFromTFHDInTRAF(traf) {
            var index = findBox(traf, 1952868452
            /* tfhd */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4 + 
            /* version */
            1, flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.b)(traf, pos);
            return pos += 3, 8 & flags ? (pos += 4, 1 & flags && (pos += 8), 2 & flags && (pos += 4), 
            Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos)) : -1;
        }
        /**
 * @param {Uint8Array} buffer
 * @returns {number}
 */        function getDurationFromTrun(buffer) {
            var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__.c)(buffer);
            if (!traf) return -1;
            var index = findBox(traf, 1953658222
            /* trun */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = traf[pos];
            if (pos += 1, 1 < version) return -1;
            var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.b)(traf, pos);
            pos += 3;
            var hasSampleDuration = 256 & flags, defaultDuration = 0;
            if (!hasSampleDuration && (defaultDuration = getDefaultDurationFromTFHDInTRAF(traf)) < 0) return -1;
            var hasDataOffset = 1 & flags, hasFirstSampleFlags = 4 & flags, hasSampleSize = 512 & flags, hasSampleFlags = 1024 & flags, hasSampleCompositionOffset = 2048 & flags, sampleCounts = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos);
            pos += 4, hasDataOffset && (pos += 4), hasFirstSampleFlags && (pos += 4);
            for (var i = sampleCounts, duration = 0; i--; ) hasSampleDuration ? (duration += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(traf, pos), 
            pos += 4) : duration += defaultDuration, hasSampleSize && (pos += 4), hasSampleFlags && (pos += 4), 
            hasSampleCompositionOffset && (pos += 4);
            return duration;
        }
        /**
 * Get various information from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */        function getMDHDTimescale(buffer) {
            var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_4__.b)(buffer);
            if (!mdia) return -1;
            var index = findBox(mdia, 1835296868
            /* "mdhd" */);
            if (-1 === index) return -1;
            var pos = index + 
            /* size */
            4 + 
            /* name */
            4, version = mdia[pos];
            return pos += 4, 1 === version ? (pos += 16, Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(mdia, pos)) : 0 === version ? (pos += 8, 
            Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__.c)(mdia, pos)) : -1;
        }
        /**
 * Returns a PSSH box from a systemId and private data.
 * @param {Array.<Object>} pssList - The content protections under the form of
 * object containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array}
 */    }, 
    /* 219 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return scan;
        });
        /* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
        /* harmony import */        
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function scan(accumulator, seed) {
            var hasSeed = !1;
            return 2 <= arguments.length && (hasSeed = !0), function scanOperatorFunction(source) {
                return source.lift(new ScanOperator(accumulator, seed, hasSeed));
            };
        }
        var ScanOperator = /* */ function() {
            function ScanOperator(accumulator, seed, hasSeed) {
                void 0 === hasSeed && (hasSeed = !1), this.accumulator = accumulator, this.seed = seed, 
                this.hasSeed = hasSeed;
            }
            return ScanOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
            }, ScanOperator;
        }(), ScanSubscriber = /* */ function(_super) {
            function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
                var _this = _super.call(this, destination) || this;
                return _this.accumulator = accumulator, _this._seed = _seed, _this.hasSeed = hasSeed, 
                _this.index = 0, _this;
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(ScanSubscriber, _super), Object.defineProperty(ScanSubscriber.prototype, "seed", {
                get: function() {
                    return this._seed;
                },
                set: function(value) {
                    this.hasSeed = !0, this._seed = value;
                },
                enumerable: !0,
                configurable: !0
            }), ScanSubscriber.prototype._next = function(value) {
                if (this.hasSeed) return this._tryNext(value);
                this.seed = value, this.destination.next(value);
            }, ScanSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.accumulator(this.seed, value, index);
                } catch (err) {
                    this.destination.error(err);
                }
                this.seed = result, this.destination.next(result);
            }, ScanSubscriber;
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a);
    }, 
    /* 220 */
    /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony export (binding) */        __webpack_require__.d(__webpack_exports__, "a", function() {
            return switchMapTo;
        });
        /* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */        function switchMapTo(innerObservable, resultSelector) {
            return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__.a)(function() {
                return innerObservable;
            });
        }
        //# sourceMappingURL=switchMapTo.js.map
        /***/    }
    /******/ ]);
});