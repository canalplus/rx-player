(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 386);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(18);
var toSubscriber_1 = __webpack_require__(382);
var observable_1 = __webpack_require__(63);
var pipe_1 = __webpack_require__(380);
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __webpack_require__(40);
var LEVELS = {
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFO: 3,
    DEBUG: 4,
};
var currentLevel = Object.keys(LEVELS)[0];
var logger = {
    LEVELS: Object.keys(LEVELS),
    error: noop_1.default,
    warn: noop_1.default,
    info: noop_1.default,
    debug: noop_1.default,
    setLevel: function (levelStr) {
        var level;
        var foundLevel = LEVELS[levelStr];
        if (foundLevel) {
            level = foundLevel;
            currentLevel = levelStr;
        }
        else { // either 0 or not found
            level = 0;
            currentLevel = "NONE";
        }
        /* tslint:disable no-invalid-this */
        this.error = (level >= LEVELS.ERROR) ?
            console.error.bind(console) : noop_1.default;
        this.warn = (level >= LEVELS.WARNING) ?
            console.warn.bind(console) : noop_1.default;
        this.info = (level >= LEVELS.INFO) ?
            console.info.bind(console) : noop_1.default;
        this.debug = (level >= LEVELS.DEBUG) ?
            console.log.bind(console) : noop_1.default;
        /* tslint:enable no-invalid-this */
    },
    getLevel: function () {
        return currentLevel;
    },
};
exports.default = logger;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    /**
     * Volume set on unMute if the volume is set to 0 and either:
     *   - mute has never been called before
     *   - mute has last been called while the volume was already set to 0 (either
     *     via setVolume, or a previous mute call)
     * @type {Number}
     */
    DEFAULT_UNMUTED_VOLUME: 0.1,
    /**
     * Can be either:
     *   - "native": Subtitles are all displayed in a <track> element
     *   - "html": Subtitles are all displayed in a <div> separated from the video
     *     element. Can be useful to display richer TTML subtitles, for example.
     * @type {Object|null}
     */
    // TODO ugly TypeScript workaround. Find better way
    DEFAULT_TEXT_TRACK_MODE: "native",
    /**
     * If set to true, video through loadVideo will auto play by default
     * @type {Boolean}
     */
    DEFAULT_AUTO_PLAY: false,
    /**
     * If set to false, "native" subtitles (in a <track> element) will be hidden
     * by default.
     * @type {Boolean}
     */
    DEFAULT_SHOW_NATIVE_SUBTITLE: true,
    /**
     * Default buffer goal in seconds.
     * Once enough content has been downloaded to fill the buffer up to
     * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
     * content.
     * @type {Number}
     */
    DEFAULT_WANTED_BUFFER_AHEAD: 30,
    /**
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _after_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_AHEAD: Infinity,
    /*
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _before_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_BEHIND: Infinity,
    /**
     * Default bitrate ceils initially set as the first content begins.
     *
     * If no track is found with a bitrate inferior or equal to the
     * bitrate there, the one with the lowest bitrate will be taken instead.
     *
     * Set to 0 for the lowest bitrate, Infinity for the highest.
     *
     * These values are only useful for the first content played, as consecutive
     * play will always take the last set one.
     * @type {Object}
     */
    DEFAULT_INITIAL_BITRATES: {
        audio: 0,
        video: 0,
        other: 0,
    },
    /**
     * Default bitrate ceil initially set to dictate the maximum bitrate the
     * ABR manager can automatically switch to.
     *
     * If no track is found with a quality inferior or equal to the
     * bitrate there, the lowest bitrate will be taken instead.
     *
     * Set to Infinity to discard any limit in the ABR strategy.
     * @type {Object}
     */
    /* tslint:disable no-object-literal-type-assertion */
    DEFAULT_MAX_BITRATES: {
        audio: Infinity,
        video: Infinity,
        other: Infinity,
    },
    /* tslint:enable no-object-literal-type-assertion */
    /**
     * Delay after which, if the page is hidden, the user is considered inactive
     * on the current video.
     *
     * Allow to enforce specific optimizations when the page is not shown.
     * @see DEFAULT_THROTTLE_WHEN_HIDDEN
     * @type {Number}
     */
    INACTIVITY_DELAY: 60 * 1000,
    /**
     * If true, if the player is in a "hidden" state for a delay specified by the
     * INACTIVITY DELAY config property, we throttle automatically to the video
     * representation with the lowest bitrate.
     * @type {Boolean}
     */
    DEFAULT_THROTTLE_WHEN_HIDDEN: false,
    /**
     * If true, the video representations you can switch to in adaptive mode
     * are limited by the video element's width.
     *
     * Basically in that case, we won't switch to a video Representation with
     * a width higher than the current width of the video HTMLElement.
     * @type {Boolean}
     */
    DEFAULT_LIMIT_VIDEO_WIDTH: false,
    /**
     * Default initial live gap considered if no presentation delay has been
     * suggested, in seconds.
     * @type {Number}
     */
    DEFAULT_LIVE_GAP: 10,
    /**
     * Default value for a manifest's suggested presentation delay if not
     * specified in the manifest.
     * @type {Object}
     */
    DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
        SMOOTH: 10,
        DASH: 10,
    },
    /**
     * Maximum time, in seconds, the player should automatically skip when stalled
     * because of a discontinuity in the downloaded range.
     * @type {Number}
     */
    DISCONTINUITY_THRESHOLD: 1,
    /**
     * Ratio used to know if an already loaded segment should be re-buffered.
     * We re-load the given segment if the current one times that ratio is
     * inferior to the new one.
     * @type {Number}
     */
    BITRATE_REBUFFERING_RATIO: 1.5,
    /**
     * Those are used when a "QuotaExceededError" error is received after
     * appending a new segment in the source buffer.
     *
     * This error can arise when the browser's buffer is considered full.
     * In this case, the player goes into manual garbage collection (GC) mode.
     * @type {Object}
     */
    BUFFER_GC_GAPS: {
        /**
         * _Low_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received.
         * In seconds.
         * @type {Number}
         */
        CALM: 240,
        /**
         * _High_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received, if the low one does not clean up any buffer.
         * In seconds.
         * @type {Number}
         */
        BEEFY: 30,
    },
    /**
     * The default number of times a manifest request will be re-performed
     * when loaded/refreshed if the request finishes on an error which
     * justify an retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     *   - if it has a high chance of being due to the user being offline, a
     *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
     * @type Number
     */
    DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
    /**
     * The default number of times a pipeline request will be re-performed when
     * on error which justify a retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     *   - if it has a high chance of being due to the user being offline, a
     *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
     * @type Number
     */
    DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
    /**
     * Under some circonstances, we're able to tell that the user is offline (see
     * the compat files).
     * When this happens, and xhr requests fails due to an error event (you might
     * still be able to perform xhr offline, e.g. on localhost), you might want to
     * retry indefinitely or with a higher number of retry than if the error is
     * due to a CDN problem.
     *
     * A capped exponential backoff will still be used (like for an error code).
     * @type {Number}
     */
    DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
    /**
     * Initial backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * This delay will then grow exponentally by power of twos (200, 400, 800
     * etc.)
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    INITIAL_BACKOFF_DELAY_BASE: 200,
    /**
     * Maximum backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    MAX_BACKOFF_DELAY_BASE: 3000,
    /**
     * Minimum interval at which timeupdate events will be "constructed". This
     * variable is for the "regular" mediasource strategy (that is, not for the
     * directfile API.
     *
     * Those events are the base of various important mechanisms in the player:
     *   - set the clock for the buffer.
     *   - set the clock for the ABR strategy.
     *   - used to trigger positionUpdate events.
     *
     * This common logic is for performance reasons, as we call multiple browser's
     * APIs which are useful for most of these.
     *
     * Keep in mind this is the minimum interval. This logic will also be
     * triggered when various events of the media element are received.
     * @type {Number}
     */
    SAMPLING_INTERVAL_MEDIASOURCE: 1000,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
     * @type {Number}
     */
    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
    /**
     * Minimum number of bytes sampled before we trust the estimate.
     * If we have not sampled much data, our estimate may not be accurate
     * enough to trust.
     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_TOTAL_BYTES: 350e3,
    /**
     * Minimum number of bytes, under which samples are discarded.
     * Our models do not include latency information, so connection startup time
     * (time to first byte) is considered part of the download time.
     * Because of this, we should ignore very small downloads which would cause
     * our estimate to be too low.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_CHUNK_SIZE: 16e3,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is in
     * starvation mode.
     * @type {Number}
     */
    ABR_STARVATION_FACTOR: 0.72,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is not
     * in starvation mode.
     * @type {Number}
     */
    ABR_REGULAR_FACTOR: 0.90,
    /**
     * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
     * current position in its buffer, the ABR manager will go into starvation
     * mode.
     *
     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
     * reached.
     *
     * Under this starvation mode:
     *
     *   - the bandwidth considered will be a little lower than the one estimated
     *
     *   - the time the next important request take will be checked
     *     multiple times to detect when/if it takes too much time.
     *     If the request is considered too long, the bitrate will be hastily
     *     re-calculated from this single request.
     *
     * @type {Number}
     */
    ABR_STARVATION_GAP: 5,
    OUT_OF_STARVATION_GAP: 7,
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * seeking on an unbuffered part of the stream.
     * @type {Number}
     */
    RESUME_GAP_AFTER_SEEKING: 1.5,
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * the player was stalled due to a low readyState.
     * @type {Number}
     */
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA: 0.5,
    /**
     * Number of seconds ahead in the buffer after which playback will resume
     * after the player went through a buffering step.
     * @type {Number}
     */
    RESUME_GAP_AFTER_BUFFERING: 5,
    /**
     * Maximum number of seconds in the buffer based on which a "stalling"
     * strategy will be considered:
     * The player will pause playback to get enough time building a sufficient
     * buffer. This mostly happen when seeking in an unbuffered part or when
     * buffering.
     * @type {Number}
     */
    STALL_GAP: 0.5,
    /**
     * Maximum difference allowed between a segment _announced_ start (what the
     * rx-player infers to be the starting time) and its _real_  current starting
     * time in the source buffer, in seconds, until the segment is considered
     * "incomplete".
     * Same for the ending time announced and its effective end time in the source
     * buffer.
     *
     * If the difference is bigger than this value, the segment will be considered
     * incomplete (e.g. considered as partially garbage-collected) and as such
     * might be re-downloaded.
     *
     * Keeping a too high value might lead to incomplete segments being wrongly
     * considered as complete (and thus not be re-downloaded, this could lead the
     * player to stall).
     * Note that in a worst-case scenario this can happen for the end of a segment
     * and the start of the contiguous segment, leading to a discontinuity two
     * times this value.
     *
     * Keeping a too low value might lead to re-downloading the same segment
     * multiple times (when the start and end times are badly estimated) as they
     * will wrongly believed to be partially garbage-collected.
     *
     * If a segment has a perfect continuity with a previous/following one in the
     * source buffer the start/end of it will not be checked. This allows to limit
     * the number of time this error-prone logic is applied.
     *
     * Note that in most cases, the rx-player's start and end times estimations
     * are __really__ close to what they really are in the sourcebuffer (we
     * usually have a difference in the order of 10^-7), as time information is
     * most of the time directly parsed from the media container.
     *
     * @type {Number}
     */
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.12,
    /**
     * The maximum time, in seconds, the real buffered time in the sourcebuffer
     * can be superior to the time inferred by the rx-player (the "real" buffered
     * start inferior to the inferred start and the "real" buffered end superior
     * to the inferred end).
     * This limit allows to avoid resizing too much downloaded segments because
     * no other segment is linked to a buffered part.
     *
     * Setting a value too high can lead to parts of the source buffer being
     * linked to the wrong segments.
     * Setting a value too low can lead to parts of the source buffer not being
     * linked to the concerned segment.
     * @type {Number}
     */
    MAX_BUFFERED_DISTANCE: 0.1,
    /**
     * Minimum duration in seconds a segment should be into a buffered range to be
     * considered as part of that range.
     * Segments which have less than this amount of time "linked" to a buffered
     * range will be deleted.
     *
     * Setting a value too low can lead in worst-case scenarios to segments being
     * wrongly linked to the next or previous range it is truly linked too (if
     * those ranges are too close).
     *
     * Setting a value too high can lead to part of the buffer not being assigned
     * any segment. It also limits the minimum duration a segment can be.
     *
     * TODO As of now, this limits the minimum size a complete segment can be. A
     * better logic would be to also consider the duration of a segment. Though
     * this logic could lead to bugs with the current code.
     * @type {Number}
     */
    MINIMUM_SEGMENT_SIZE: 0.2,
    /**
     * Maximum interval at which text tracks are refreshed in an "html"
     * textTrackMode.
     *
     * The text tracks are also refreshed on various video events, this interval
     * will only trigger a refresh if none of those events was received during
     * that timespan.
     *
     * Note that if the TextTrack cue did not change between two intervals or
     * events, the DOM won't be refreshed.
     * The TextTrack cues structure is also optimized for fast retrieval.
     * We should thus not have much of a performance impact here if we set a low
     * interval.
     *
     * @type {Number}
     */
    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
    /**
     * The Buffer padding is a time offset from the current time that affects
     * the buffer.
     *
     * Basically, from a given time, if the current buffer gap number (time
     * between the current time and the end of the downloaded buffer) is between
     * the "high" and "low" described here (of the corresponding type), we won't
     * reschedule segments for that range.
     *
     * This is to avoid excessive re-buffering.
     *
     * Keeping the "high"s too low would increase the risk of re-bufferings.
     *
     * Keeping the "high"s too high would delay visible quality increase.
     *
     * @type {Object}
     */
    BUFFER_PADDING: {
        audio: {
            high: 1,
            low: 1,
        },
        video: {
            high: 8,
            low: 2,
        },
        other: {
            high: 1,
            low: 1,
        },
    },
    /**
     * Segments of different types are downloaded by steps:
     *
     *   - first the audio/video/text Segments which are immediately needed
     *
     *   - then once every of those Segments have been downloaded, less-needed
     *     Segments
     *
     *   - then once every of those less-needed Segments have been downloaded,
     *     even less-needed Segments
     *
     *   - etc.
     *
     * This stepped download strategy allows to make a better use of network
     * ressources.
     *
     * For example, if more than sufficient audio buffer has been downloaded but
     * the immediately-needed video Segment is still pending its request, we might
     * be in a situation of rebuffering.
     * In that case, a better strategy would be to make sure every network
     * ressource is allocated for this video Segment before rebuffering happens.
     *
     * This is where those steps become useful.
     *
     * --
     *
     * The numbers defined in this Array describe what the steps are.
     *
     * Each number is linked to a distance from the current playing position, in
     * seconds.
     * Distances which will be used as limit points, from which a new step is
     * reached (see example).
     *
     * Note: You can set an empty array to deactivate the steps feature (every
     * Segments have the same priority).
     *
     * @example
     *
     * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
     * [5, 11, 17, 25]
     *
     * To link each Segments to a corresponding priority (and thus to a specific
     * step), we have to consider the distance d between the current position and
     * the start time of the Segment.
     *
     * We have in our example 5 groups, which correspond to the following possible
     * d values:
     *   1. inferior to 5
     *   2. between 5 and 11
     *   3. between 11 and 17
     *   4. between 17 and 25
     *   5. superior to 25
     *
     * Segments corresponding to a lower-step will need to all be downloaded
     * before Segments of a newer step begin.
     *
     * @type {Array.<Number>}
     */
    SEGMENT_PRIORITIES_STEPS: [6, 14],
    /**
     * Robustnesses used in the {audio,video}Capabilities of the
     * MediaKeySystemConfiguration (EME).
     *
     * Only used for widevine keysystems.
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [
        "HW_SECURE_ALL",
        "HW_SECURE_DECODE",
        "HW_SECURE_CRYPTO",
        "SW_SECURE_DECODE",
        "SW_SECURE_CRYPTO",
    ],
    /**
     * Link canonical key systems names to their respective reverse domain name,
     * used in the EME APIs.
     * This allows to have a simpler API, where users just need to set "widevine"
     * or "playready" as a keySystem.
     * @type {Object}
     */
    /* tslint:disable no-object-literal-type-assertion */
    EME_KEY_SYSTEMS: {
        clearkey: [
            "webkit-org.w3.clearkey",
            "org.w3.clearkey",
        ],
        widevine: [
            "com.widevine.alpha",
        ],
        playready: [
            "com.microsoft.playready",
            "com.chromecast.playready",
            "com.youtube.playready",
        ],
    },
    /* tslint:enable no-object-literal-type-assertion */
    /**
     * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
     * doing superfluous license requests.
     * If this number is reached, any new session creation will close the oldest
     * one.
     * @type {Number}
     */
    EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
    /**
     * The player relies on browser events and properties to update its status to
     * "ENDED".
     *
     * Sadly in some cases, like in Chrome 54, this event is never triggered on
     * some contents probably due to a browser bug.
     *
     * This threshold resolves this issue by forcing the status to "ENDED" when:
     *   1. the player is stalling
     *   2. the absolute difference between current playback time and duration is
     *      under this value
     *
     * If set to null, this workaround is disabled and the player only relies on
     * browser events.
     *
     * @type {Number|null}
     */
    FORCED_ENDED_THRESHOLD: 0.001,
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(66);
var Subscription_1 = __webpack_require__(17);
var Observer_1 = __webpack_require__(115);
var rxSubscriber_1 = __webpack_require__(64);
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AssertionError_1 = __webpack_require__(240);
/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} message - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */
function assert(assertion, message) {
    if (!assertion) {
        throw new AssertionError_1.default(message || "invalid assertion");
    }
}
exports.default = assert;
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */
function assertInterface(o, iface, name) {
    if (name === void 0) { name = "object"; }
    assert(o != null, name + " should be an object");
    for (var k in iface) {
        if (iface.hasOwnProperty(k)) {
            /* tslint:disable:max-line-length */
            assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
            /* tslint:enable:max-line-length */
        }
    }
}
exports.assertInterface = assertInterface;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var eventemitter_1 = __webpack_require__(33);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(56);
var constants_1 = __webpack_require__(55);
exports.isFirefox = constants_1.isFirefox;
exports.isIE = constants_1.isIE;
exports.MediaSource_ = constants_1.MediaSource_;
exports.VTTCue_ = constants_1.VTTCue_;
var events = __webpack_require__(15);
exports.events = events;
var fullscreen_1 = __webpack_require__(239);
exports.exitFullscreen = fullscreen_1.exitFullscreen;
exports.isFullscreen = fullscreen_1.isFullscreen;
exports.requestFullscreen = fullscreen_1.requestFullscreen;
var eme_1 = __webpack_require__(238);
exports.getInitData = eme_1.getInitData;
exports.KeySystemAccess = eme_1.KeySystemAccess;
exports.requestMediaKeySystemAccess = eme_1.requestMediaKeySystemAccess;
exports.setMediaKeys = eme_1.setMediaKeys;
/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */
function isCodecSupported(codec) {
    if (!constants_1.MediaSource_) {
        return false;
    }
    if (typeof constants_1.MediaSource_.isTypeSupported === "function") {
        return constants_1.MediaSource_.isTypeSupported(codec);
    }
    return true;
}
exports.isCodecSupported = isCodecSupported;
/**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */
function hasEMEAPIs() {
    return typeof eme_1.requestMediaKeySystemAccess === "function";
}
exports.hasEMEAPIs = hasEMEAPIs;
/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */
function shouldRenewMediaKeys() {
    return constants_1.isIE;
}
exports.shouldRenewMediaKeys = shouldRenewMediaKeys;
/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */
function shouldUnsetMediaKeys() {
    return constants_1.isIE;
}
exports.shouldUnsetMediaKeys = shouldUnsetMediaKeys;
/**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource}
 * @returns {Observable}
 */
function onSourceOpen$(mediaSource) {
    if (mediaSource.readyState === "open") {
        return Observable_1.Observable.of(null);
    }
    else {
        return events.onSourceOpen$(mediaSource).take(1);
    }
}
exports.onSourceOpen$ = onSourceOpen$;
/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metatada are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function hasLoadedMetadata(mediaElement) {
    if (mediaElement.readyState >= constants_1.READY_STATES.HAVE_METADATA) {
        return Observable_1.Observable.of(undefined);
    }
    else {
        return events.onLoadedMetadata$(mediaElement)
            .take(1)
            .mapTo(undefined);
    }
}
exports.hasLoadedMetadata = hasLoadedMetadata;
/**
 * Returns ane observable emitting a single time, as soon as a play is possible.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function canPlay(mediaElement) {
    if (mediaElement.readyState >= constants_1.READY_STATES.HAVE_ENOUGH_DATA) {
        return Observable_1.Observable.of(undefined);
    }
    else {
        return rx_onEvent_1.default(mediaElement, "canplay")
            .take(1)
            .mapTo(undefined);
    }
}
exports.canPlay = canPlay;
// old WebKit SourceBuffer implementation,
// where a synchronous append is used instead of appendBuffer
if (window.WebKitSourceBuffer &&
    !window.WebKitSourceBuffer.prototype.addEventListener) {
    var sourceBufferWebkitRef = window.WebKitSourceBuffer;
    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;
    for (var fnName in eventemitter_1.default.prototype) {
        if (eventemitter_1.default.prototype.hasOwnProperty(fnName)) {
            sourceBufferWebkitProto[fnName] = eventemitter_1.default.prototype[fnName];
        }
    }
    sourceBufferWebkitProto._listeners = [];
    sourceBufferWebkitProto.__emitUpdate =
        function (eventName, val) {
            var _this = this;
            setTimeout(function () {
                /* tslint:disable no-invalid-this */
                _this.trigger(eventName, val);
                _this.updating = false;
                _this.trigger("updateend");
                /* tslint:enable no-invalid-this */
            }, 0);
        };
    sourceBufferWebkitProto.appendBuffer =
        function (data) {
            /* tslint:disable no-invalid-this */
            if (this.updating) {
                throw new Error("updating");
            }
            this.trigger("updatestart");
            this.updating = true;
            try {
                this.append(data);
            }
            catch (error) {
                this.__emitUpdate("error", error);
                return;
            }
            this.__emitUpdate("update");
            /* tslint:enable no-invalid-this */
        };
}
/**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */
function addTextTrack(mediaElement, hidden) {
    var track;
    var trackElement;
    var kind = "subtitles";
    if (constants_1.isIE) {
        var tracksLength = mediaElement.textTracks.length;
        track = tracksLength > 0 ?
            mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);
        track.mode = hidden ? track.HIDDEN : track.SHOWING;
    }
    else {
        // there is no removeTextTrack method... so we need to reuse old
        // text-tracks objects and clean all its pending cues
        trackElement = document.createElement("track");
        mediaElement.appendChild(trackElement);
        track = trackElement.track;
        trackElement.kind = kind;
        track.mode = hidden ? "hidden" : "showing";
    }
    return { track: track, trackElement: trackElement };
}
exports.addTextTrack = addTextTrack;
/**
 * firefox fix: sometimes the stream can be stalled, even if we are in a
 * buffer.
 *
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {Object} timing
 * @returns {Boolean}
 */
function isPlaybackStuck(time, currentRange, state, isStalled) {
    var FREEZE_THRESHOLD = 10; // freeze threshold in seconds
    return (constants_1.isFirefox && isStalled && state === "timeupdate" &&
        !!currentRange && currentRange.end - time > FREEZE_THRESHOLD);
}
exports.isPlaybackStuck = isPlaybackStuck;
/**
 * Clear element's src attribute.
 *
 * On IE11, element.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use element.removeAttr("src").
 * @param {HTMLMediaElement} element
 */
function clearElementSrc(element) {
    element.src = "";
    element.removeAttribute("src");
}
exports.clearElementSrc = clearElementSrc;
/**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */
function setElementSrc$(mediaElement, url) {
    return Observable_1.Observable.create(function (observer) {
        log_1.default.info("Setting URL to Element", url, mediaElement);
        mediaElement.src = url;
        observer.next(undefined);
        return function () {
            clearElementSrc(mediaElement);
        };
    });
}
exports.setElementSrc$ = setElementSrc$;
/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
    /* tslint:disable no-boolean-literal-compare */
    return navigator.onLine === false;
    /* tslint:enable no-boolean-literal-compare */
}
exports.isOffline = isOffline;
/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {TextTrackCue} or null if the parameters were invalid.
 */
function makeCue(startTime, endTime, payload) {
    if (!constants_1.VTTCue_) {
        throw new Error("VTT cues not supported in your target");
    }
    if (startTime >= endTime) {
        // IE/Edge will throw in this case.
        // See issue #501
        log_1.default.warn("Invalid cue times: " + startTime + " - " + endTime);
        return null;
    }
    return new constants_1.VTTCue_(startTime, endTime, payload);
}
exports.makeCue = makeCue;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(24);
exports.ErrorCodes = constants_1.ErrorCodes;
exports.ErrorTypes = constants_1.ErrorTypes;
exports.RequestErrorTypes = constants_1.RequestErrorTypes;
// Custom Errors
var EncryptedMediaError_1 = __webpack_require__(236);
exports.EncryptedMediaError = EncryptedMediaError_1.default;
var IndexError_1 = __webpack_require__(235);
exports.IndexError = IndexError_1.default;
var MediaError_1 = __webpack_require__(32);
exports.MediaError = MediaError_1.default;
var OtherError_1 = __webpack_require__(234);
exports.OtherError = OtherError_1.default;
var NetworkError_1 = __webpack_require__(233);
exports.NetworkError = NetworkError_1.default;
// Error used for XHRs
var RequestError_1 = __webpack_require__(232);
exports.RequestError = RequestError_1.default;
/**
 * Whether the error given is a CustomError.
 * @param {Error} error
 * @returns {Boolean}
 */
function isKnownError(error) {
    return (!!error &&
        !!error.type &&
        Object.keys(constants_1.ErrorTypes).indexOf(error.type) >= 0);
}
exports.isKnownError = isKnownError;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(17);
var ObjectUnsubscribedError_1 = __webpack_require__(57);
var SubjectSubscription_1 = __webpack_require__(100);
var rxSubscriber_1 = __webpack_require__(64);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function find(array, predicate, context) {
  if (typeof Array.prototype.find === 'function') {
    return array.find(predicate, context);
  }

  context = context || this;
  var length = array.length;
  var i;

  if (typeof predicate !== 'function') {
    throw new TypeError(predicate + ' is not a function');
  }

  for (i = 0; i < length; i++) {
    if (predicate.call(context, array[i], i, array)) {
      return array[i];
    }
  }
}

module.exports = find;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(18);
var isArrayLike_1 = __webpack_require__(114);
var isPromise_1 = __webpack_require__(113);
var isObject_1 = __webpack_require__(116);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(60);
var InnerSubscriber_1 = __webpack_require__(377);
var observable_1 = __webpack_require__(63);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// XML-Schema
/* tslint:disable:max-line-length */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>
/* tslint:enable:max-line-length */
var assert_1 = __webpack_require__(4);
var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
var frameRateRe = /([0-9]+)(\/([0-9]+))?/;
/**
 * Parse MPD string attributes.
 * @param {string} str
 * @returns {string} - the same string
 */
function parseString(str) {
    return str;
}
exports.parseString = parseString;
/**
 * Parse MPD boolean attributes.
 * @param {string}
 * @returns {Boolean}
 */
function parseBoolean(str) {
    return str === "true";
}
exports.parseBoolean = parseBoolean;
/**
 * Parse some MPD attributes.
 * @param {string}
 * @returns {Boolean|Number}
 */
function parseIntOrBoolean(str) {
    if (str === "true") {
        return true;
    }
    if (str === "false") {
        return false;
    }
    return parseInt(str, 10);
}
exports.parseIntOrBoolean = parseIntOrBoolean;
/**
 * Parse MPD date attributes.
 * @param {string}
 * @returns {Date}
 */
function parseDateTime(str) {
    return new Date(Date.parse(str)).getTime() / 1000;
}
exports.parseDateTime = parseDateTime;
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string}
 * @returns {Number}
 */
function parseDuration(date) {
    if (!date) {
        return 0;
    }
    var match = iso8601Duration.exec(date);
    assert_1.default(!!match, date + " is not a valid ISO8601 duration");
    return (parseFloat(match[2] || "0") * 365 * 24 * 60 * 60 +
        parseFloat(match[4] || "0") * 30 * 24 * 60 * 60 + // not precise +
        parseFloat(match[6] || "0") * 24 * 60 * 60 +
        parseFloat(match[8] || "0") * 60 * 60 +
        parseFloat(match[10] || "0") * 60 +
        parseFloat(match[12] || "0"));
}
exports.parseDuration = parseDuration;
/**
 * Parse MPD frame rate attributes.
 * -1 if the frameRate could not be parsed,
 * @param {string} str
 * @returns {Number}
 */
function parseFrameRate(str) {
    var match = frameRateRe.exec(str);
    if (!match) {
        return -1;
    }
    var nom = parseInt(match[1], 10) || 0;
    var den = parseInt(match[2], 10) || 0;
    return den > 0
        ? nom / den
        : nom;
}
exports.parseFrameRate = parseFrameRate;
/**
 * Parse MPD ratio attributes.
 * @param {string} str
 * @returns {string}
 */
function parseRatio(str) {
    return str;
}
exports.parseRatio = parseRatio;
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */
function parseByteRange(str) {
    var match = rangeRe.exec(str);
    if (!match) {
        return null;
    }
    else {
        return [+match[1], +match[2]];
    }
}
exports.parseByteRange = parseByteRange;
/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isVisuallyImpaired(accessibility) {
    if (!accessibility) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === "1");
}
exports.isVisuallyImpaired = isVisuallyImpaired;
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isHardOfHearing(accessibility) {
    if (!accessibility) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === "2");
}
exports.isHardOfHearing = isHardOfHearing;
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseScheme(root) {
    var schemeIdUri;
    var value;
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "schemeIdUri":
                schemeIdUri = attribute.value;
                break;
            case "value":
                value = attribute.value;
                break;
        }
    }
    return {
        schemeIdUri: schemeIdUri,
        value: value,
    };
}
exports.parseScheme = parseScheme;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }, obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }, { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
function arrayIncludes(arr, searchElement, fromIndex) {
    /* tslint:disable no-unbound-method */
    if (typeof Array.prototype.includes === "function") {
        /* tslint:enable no-unbound-method */
        return arr.includes(searchElement, fromIndex);
    }
    var len = arr.length >>> 0;
    if (len === 0) {
        return false;
    }
    var n = fromIndex | 0;
    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
    var areTheSame = function (x, y) {
        return x === y ||
            // Viva las JavaScriptas!
            (typeof x === "number" && typeof y === "number"
                && isNaN(x) && isNaN(y));
    };
    while (k < len) {
        if (areTheSame(arr[k], searchElement)) {
            return true;
        }
        k++;
    }
    return false;
}
exports.default = arrayIncludes;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
__webpack_require__(109);
function castToObservable(value) {
    if (value instanceof Observable_1.Observable) {
        return value;
    }
    if (value && typeof value.subscribe === "function") {
        var valObsLike_1 = value;
        return new Observable_1.Observable(function (obs) {
            var sub = valObsLike_1.subscribe(function (val) { obs.next(val); }, function (err) { obs.error(err); }, function () { obs.complete(); });
            return function () {
                if (sub && sub.dispose) {
                    sub.dispose();
                }
                else if (sub && sub.unsubscribe) {
                    sub.unsubscribe();
                }
            };
        });
    }
    if (value && typeof value.then === "function") {
        return Observable_1.Observable.fromPromise(value);
    }
    return Observable_1.Observable.of(value);
}
exports.default = castToObservable;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
var Observable_1 = __webpack_require__(0);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(56);
var constants_1 = __webpack_require__(55);
var INACTIVITY_DELAY = config_1.default.INACTIVITY_DELAY;
var pixelRatio = window.devicePixelRatio || 1;
/**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
function isEventSupported(element, eventNameSuffix) {
    var clone = document.createElement(element.tagName);
    var eventName = "on" + eventNameSuffix;
    if (eventName in clone) {
        return true;
    }
    else {
        clone.setAttribute(eventName, "return;");
        return typeof clone[eventName] === "function";
    }
}
/**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {Array.<string>} eventNames
 * @returns {string}
 */
function findSupportedEvent(element, eventNames) {
    return eventNames
        .filter(function (name) { return isEventSupported(element, name); })[0];
}
function eventPrefixed(eventNames, prefixes) {
    return eventNames.reduce(function (parent, name) {
        return parent
            .concat((prefixes || constants_1.BROWSER_PREFIXES)
            .map(function (p) { return p + name; }));
    }, []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>} prefixes
 * @returns {Observable}
 */
function compatibleListener(eventNames, prefixes) {
    var mem;
    var prefixedEvents = eventPrefixed(eventNames, prefixes);
    return function (element) {
        // if the element is a HTMLElement we can detect
        // the supported event, and memoize it in `mem`
        if (element instanceof constants_1.HTMLElement_) {
            if (typeof mem === "undefined") {
                mem = findSupportedEvent(element, prefixedEvents);
            }
            if (mem) {
                return Observable_1.Observable.fromEvent(element, mem);
            }
            else {
                if (false) {}
                return Observable_1.Observable.never();
            }
        }
        // otherwise, we need to listen to all the events
        // and merge them into one observable sequence
        return rx_onEvent_1.default(element, prefixedEvents);
    };
}
/**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */
function visibilityChange() {
    var prefix;
    if (document.hidden != null) {
        prefix = "";
    }
    else if (document.mozHidden != null) {
        prefix = "moz";
    }
    else if (document.msHidden != null) {
        prefix = "ms";
    }
    else if (document.webkitHidden != null) {
        prefix = "webkit";
    }
    var hidden = prefix ? prefix + "Hidden" : "hidden";
    var visibilityChangeEvent = prefix + "visibilitychange";
    return rx_onEvent_1.default(document, visibilityChangeEvent)
        .map(function () { return document[hidden]; });
}
function videoSizeChange() {
    return rx_onEvent_1.default(window, "resize");
}
var isVisible = visibilityChange() // emit false when visible
    .filter(function (x) { return !x; });
// Emit true if the visibility changed to hidden since 60s
var isHidden = visibilityChange()
    .debounceTime(INACTIVITY_DELAY)
    .filter(function (x) { return x; });
var isInBackground$ = function () { return Observable_1.Observable.merge(isVisible, isHidden)
    .startWith(false); };
exports.isInBackground$ = isInBackground$;
function videoWidth$(videoElement) {
    return Observable_1.Observable.merge(Observable_1.Observable.interval(20000), videoSizeChange().debounceTime(500))
        .startWith(0) // emit on subscription
        .map(function () { return videoElement.clientWidth * pixelRatio; })
        .distinctUntilChanged();
}
exports.videoWidth$ = videoWidth$;
var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
exports.onLoadedMetadata$ = onLoadedMetadata$;
var onSeeking$ = compatibleListener(["seeking"]);
exports.onSeeking$ = onSeeking$;
var onSeeked$ = compatibleListener(["seeked"]);
exports.onSeeked$ = onSeeked$;
var onEnded$ = compatibleListener(["ended"]);
exports.onEnded$ = onEnded$;
var onTimeUpdate$ = compatibleListener(["timeupdate"]);
exports.onTimeUpdate$ = onTimeUpdate$;
var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], 
// On IE11, fullscreen change events is called MSFullscreenChange
constants_1.BROWSER_PREFIXES.concat("MS"));
exports.onFullscreenChange$ = onFullscreenChange$;
var onPlayPause$ = function (videoElement) {
    return Observable_1.Observable.merge(compatibleListener(["play"])(videoElement), compatibleListener(["pause"])(videoElement));
};
exports.onPlayPause$ = onPlayPause$;
var onTextTrackChanges$ = function (textTrackList) {
    return Observable_1.Observable.merge(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
};
exports.onTextTrackChanges$ = onTextTrackChanges$;
var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
exports.onSourceOpen$ = onSourceOpen$;
var onUpdate$ = compatibleListener(["update"]);
exports.onUpdate$ = onUpdate$;
var onRemoveSourceBuffers$ = compatibleListener(["onremovesourcebuffer"]);
exports.onRemoveSourceBuffers$ = onRemoveSourceBuffers$;
var onEncrypted$ = compatibleListener(["encrypted", "needkey"]);
exports.onEncrypted$ = onEncrypted$;
var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
exports.onKeyMessage$ = onKeyMessage$;
var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
exports.onKeyAdded$ = onKeyAdded$;
var onKeyError$ = compatibleListener(["keyerror", "error"]);
exports.onKeyError$ = onKeyError$;
var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);
exports.onKeyStatusesChange$ = onKeyStatusesChange$;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
var EPSILON = 1 / 60;
/**
 * @param {number} start
 * @param {number} end
 * @returns {Object}
 */
function createRange(start, end) {
    return { start: start, end: end };
}
exports.createRange = createRange;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function nearlyEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */
function createRangeUnion(range1, range2) {
    var start = Math.min(range1.start, range2.start);
    var end = Math.max(range1.end, range2.end);
    return { start: start, end: end };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function removeEmptyRanges(ranges) {
    for (var index = 0; index < ranges.length; index++) {
        var range = ranges[index];
        if (range.start === range.end) {
            ranges.splice(index++, 1);
        }
    }
    return ranges;
}
exports.removeEmptyRanges = removeEmptyRanges;
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function mergeContiguousRanges(ranges) {
    for (var index = 1; index < ranges.length; index++) {
        var prevRange = ranges[index - 1];
        var currRange = ranges[index];
        if (areRangesNearlyContiguous(prevRange, currRange)) {
            var unionRange = createRangeUnion(prevRange, currRange);
            ranges.splice(--index, 2, unionRange);
        }
    }
    return ranges;
}
exports.mergeContiguousRanges = mergeContiguousRanges;
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isAfter(range1, range2) {
    return range1.start >= range2.end;
}
exports.isAfter = isAfter;
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isBefore(range1, range2) {
    return range1.end <= range2.start;
}
exports.isBefore = isBefore;
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */
function isTimeInRange(_a, time) {
    var start = _a.start, end = _a.end;
    return start <= time && time < end;
}
exports.isTimeInRange = isTimeInRange;
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesOverlapping(range1, range2) {
    return isTimeInRange(range1, range2.start) ||
        range1.start < range2.end && range2.end < range1.end ||
        isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesNearlyContiguous(range1, range2) {
    return nearlyEqual(range2.start, range1.end) ||
        nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */
function convertToRanges(timeRanges) {
    var ranges = [];
    for (var i = 0; i < timeRanges.length; i++) {
        ranges.push({
            start: timeRanges.start(i),
            end: timeRanges.end(i),
        });
    }
    return ranges;
}
exports.convertToRanges = convertToRanges;
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */
function getRange(timeRanges, time) {
    for (var i = timeRanges.length - 1; i >= 0; i--) {
        var start = timeRanges.start(i);
        if (time >= start) {
            var end = timeRanges.end(i);
            if (time < end) {
                return {
                    start: start,
                    end: end,
                };
            }
        }
    }
    return null;
}
exports.getRange = getRange;
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */
function getNextRangeGap(timeRanges, time) {
    var len = timeRanges.length;
    for (var i = 0; i < len; i++) {
        var start = timeRanges.start(i);
        if (time < start) {
            return start - time;
        }
    }
    return Infinity;
}
exports.getNextRangeGap = getNextRangeGap;
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */
function getInnerAndOuterTimeRanges(timeRanges, time) {
    var innerRange = null;
    var outerRanges = [];
    for (var i = 0; i < timeRanges.length; i++) {
        var start = timeRanges.start(i);
        var end = timeRanges.end(i);
        if (time < start || time >= end) {
            outerRanges.push({ start: start, end: end });
        }
        else {
            innerRange = { start: start, end: end };
        }
    }
    return { outerRanges: outerRanges, innerRange: innerRange };
}
exports.getInnerAndOuterTimeRanges = getInnerAndOuterTimeRanges;
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? range.end - range.start
        : 0;
}
exports.getSizeOfRange = getSizeOfRange;
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getPlayedSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? currentTime - range.start
        : 0;
}
exports.getPlayedSizeOfRange = getPlayedSizeOfRange;
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getLeftSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? range.end - currentTime
        : Infinity;
}
exports.getLeftSizeOfRange = getLeftSizeOfRange;
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */
function insertInto(ranges, rangeToAddArg) {
    if (rangeToAddArg.start === rangeToAddArg.end) {
        return ranges;
    }
    var rangeToAdd = rangeToAddArg;
    // For each present range check if we need to:
    // - In case we are overlapping or contiguous:
    //   - if added range has the same bitrate as the overlapped or
    //     contiguous one, we can merge themcurrentRange
    //   - if added range has a different bitrate we need to insert it
    //     in place
    // - Need to insert in place, we we are completely, not overlapping
    //   and not contiguous in between two ranges.
    var index = 0;
    for (; index < ranges.length; index++) {
        var range = ranges[index];
        var overlapping = areRangesOverlapping(rangeToAdd, range);
        var contiguous = areRangesNearlyContiguous(rangeToAdd, range);
        // We assume ranges are ordered and two ranges can not be
        // completely overlapping.
        if (overlapping || contiguous) {
            rangeToAdd = createRangeUnion(rangeToAdd, range);
            ranges.splice(index--, 1);
        }
        else {
            // Check the case for which there is no more to do
            if (index === 0) {
                if (isBefore(rangeToAdd, ranges[0])) {
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                }
            }
            else {
                if (isBefore(ranges[index - 1], rangeToAdd)
                    && isBefore(rangeToAdd, range)) {
                    // We are exactly after the current previous range, and
                    // before the current range, while not overlapping with none
                    // of them. Insert here.
                    break;
                }
            }
        }
    }
    // Now that we are sure we don't overlap with any range, just add it.
    ranges.splice(index, 0, rangeToAdd);
    return mergeContiguousRanges(removeEmptyRanges(ranges));
}
exports.insertInto = insertInto;
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Object|null}
 */
function findOverlappingRange(range, ranges) {
    for (var i = 0; i < ranges.length; i++) {
        if (areRangesOverlapping(range, ranges[i])) {
            return ranges[i];
        }
    }
    return null;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * /!\ Mutates the ranges1 array given
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */
function keepRangeIntersection(ranges1, ranges2) {
    for (var i = 0; i < ranges1.length; i++) {
        var range = ranges1[i];
        var overlappingRange = findOverlappingRange(range, ranges2);
        if (!overlappingRange) {
            ranges1.splice(i--, 1);
        }
        else if (overlappingRange.start > range.start) {
            range.start = overlappingRange.start;
        }
        else if (overlappingRange.end < range.end) {
            range.end = overlappingRange.end;
        }
    }
    return ranges1;
}
exports.keepRangeIntersection = keepRangeIntersection;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(28);
var isObject_1 = __webpack_require__(116);
var isFunction_1 = __webpack_require__(66);
var tryCatch_1 = __webpack_require__(65);
var errorObject_1 = __webpack_require__(43);
var UnsubscriptionError_1 = __webpack_require__(381);
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(383)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var _lastId = 0;
/**
 * @returns {string}
 */
function generateNewId() {
    var newId = 0;
    if (_lastId < Number.MAX_VALUE) {
        newId = _lastId + 1;
    }
    _lastId = newId;
    return "" + newId;
}
exports.default = generateNewId;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Scheme part of an url (e.g. "http://").
 */
var schemeRe = /^(?:[a-z]+:)?\/\//i;
/**
 * Captures "/../" or "/./".
 */
var selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
function _normalizeUrl(url) {
    // fast path if no ./ or ../ are present in the url
    if (!selfDirRe.test(url)) {
        return url;
    }
    var newUrl = [];
    var oldUrl = url.split("/");
    for (var i = 0, l = oldUrl.length; i < l; i++) {
        if (oldUrl[i] === "..") {
            newUrl.pop();
        }
        else if (oldUrl[i] === ".") {
            continue;
        }
        else {
            newUrl.push(oldUrl[i]);
        }
    }
    return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */
function resolveURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var len = args.length;
    if (len === 0) {
        return "";
    }
    var base = "";
    for (var i = 0; i < len; i++) {
        var part = args[i];
        if (typeof part !== "string" || part === "") {
            continue;
        }
        if (schemeRe.test(part)) {
            base = part;
        }
        else {
            // trim if begins with "/"
            if (part[0] === "/") {
                part = part.substr(1);
            }
            // trim if ends with "/"
            if (base[base.length - 1] === "/") {
                base = base.substr(0, base.length - 1);
            }
            base = base + "/" + part;
        }
    }
    return _normalizeUrl(base);
}
exports.resolveURL = resolveURL;
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */
function normalizeBaseURL(url) {
    var slash = url.lastIndexOf("/");
    if (slash >= 0) {
        return url.substring(0, slash + 1);
    }
    else {
        return url;
    }
}
exports.normalizeBaseURL = normalizeBaseURL;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
/**
 * Returns Uint8Array from UTF16 string.
 * /!\ Take only the first byte from each UTF16 code.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToBytes(str) {
    var len = str.length;
    var arr = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        arr[i] = str.charCodeAt(i) & 0xFF;
    }
    return arr;
}
exports.strToBytes = strToBytes;
/**
 * construct string from unicode values.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToStr(bytes) {
    return String.fromCharCode.apply(null, bytes);
}
exports.bytesToStr = bytesToStr;
/**
 * construct string from unicode values.
 * Only use every other byte for each UTF-16 character.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToUTF16Str(bytes) {
    var str = "";
    var len = bytes.length;
    for (var i = 0; i < len; i += 2) {
        str += String.fromCharCode(bytes[i]);
    }
    return str;
}
exports.bytesToUTF16Str = bytesToUTF16Str;
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */
function hexToBytes(str) {
    var len = str.length;
    var arr = new Uint8Array(len / 2);
    for (var i = 0, j = 0; i < len; i += 2, j++) {
        arr[j] = parseInt(str.substr(i, 2), 16) & 0xFF;
    }
    return arr;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */
function bytesToHex(bytes, sep) {
    if (sep === void 0) { sep = ""; }
    var hex = "";
    for (var i = 0; i < bytes.byteLength; i++) {
        hex += (bytes[i] >>> 4).toString(16);
        hex += (bytes[i] & 0xF).toString(16);
        if (sep.length && i < bytes.byteLength - 1) {
            hex += sep;
        }
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */
function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var l = args.length;
    var i = -1;
    var len = 0;
    var arg;
    while (++i < l) {
        arg = args[i];
        len += (typeof arg === "number") ? arg : arg.length;
    }
    var arr = new Uint8Array(len);
    var offset = 0;
    i = -1;
    while (++i < l) {
        arg = args[i];
        if (typeof arg === "number") {
            offset += arg;
        }
        else if (arg.length > 0) {
            arr.set(arg, offset);
            offset += arg.length;
        }
    }
    return arr;
}
exports.concat = concat;
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be2toi(bytes, offset) {
    return ((bytes[offset + 0] << 8) +
        (bytes[offset + 1] << 0));
}
exports.be2toi = be2toi;
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be3toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x0010000) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2]));
}
exports.be3toi = be3toi;
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be4toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3]));
}
exports.be4toi = be4toi;
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be8toi(bytes, offset) {
    return (((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3])) * 0x100000000 +
        (bytes[offset + 4] * 0x1000000) +
        (bytes[offset + 5] * 0x0010000) +
        (bytes[offset + 6] * 0x0000100) +
        (bytes[offset + 7]));
}
exports.be8toi = be8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe2(num) {
    return new Uint8Array([
        (num >>> 8) & 0xFF,
        (num) & 0xFF,
    ]);
}
exports.itobe2 = itobe2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe4(num) {
    return new Uint8Array([
        (num >>> 24) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 8) & 0xFF,
        (num) & 0xFF,
    ]);
}
exports.itobe4 = itobe4;
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe8(num) {
    var l = (num % 0x100000000);
    var h = (num - l) / 0x100000000;
    return new Uint8Array([
        (h >>> 24) & 0xFF,
        (h >>> 16) & 0xFF,
        (h >>> 8) & 0xFF,
        (h) & 0xFF,
        (l >>> 24) & 0xFF,
        (l >>> 16) & 0xFF,
        (l >>> 8) & 0xFF,
        (l) & 0xFF,
    ]);
}
exports.itobe8 = itobe8;
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le2toi(bytes, offset) {
    return ((bytes[offset + 0] << 0) +
        (bytes[offset + 1] << 8));
}
exports.le2toi = le2toi;
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le4toi(bytes, offset) {
    return ((bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000));
}
exports.le4toi = le4toi;
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le8toi(bytes, offset) {
    return ((bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000) +
        ((bytes[offset + 4]) +
            (bytes[offset + 5] * 0x0000100) +
            (bytes[offset + 6] * 0x0010000) +
            (bytes[offset + 7] * 0x1000000)) * 0x100000000);
}
exports.le8toi = le8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole2(num) {
    return new Uint8Array([
        (num) & 0xFF,
        (num >>> 8) & 0xFF,
    ]);
}
exports.itole2 = itole2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole4(num) {
    return new Uint8Array([
        (num) & 0xFF,
        (num >>> 8) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 24) & 0xFF,
    ]);
}
exports.itole4 = itole4;
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole8(num) {
    var l = (num % 0x100000000);
    var h = (num - l) / 0x100000000;
    return new Uint8Array([
        (h) & 0xFF,
        (h >>> 8) & 0xFF,
        (h >>> 16) & 0xFF,
        (h >>> 24) & 0xFF,
        (l) & 0xFF,
        (l >>> 8) & 0xFF,
        (l >>> 16) & 0xFF,
        (l >>> 24) & 0xFF,
    ]);
}
exports.itole8 = itole8;
/**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
function guidToUuid(uuid) {
    assert_1.default(uuid.length === 16, "UUID length should be 16");
    var buf = strToBytes(uuid);
    var p1A = buf[0];
    var p1B = buf[1];
    var p1C = buf[2];
    var p1D = buf[3];
    var p2A = buf[4];
    var p2B = buf[5];
    var p3A = buf[6];
    var p3B = buf[7];
    var p4 = buf.subarray(8, 10);
    var p5 = buf.subarray(10, 16);
    var ord = new Uint8Array(16);
    ord[0] = p1D;
    ord[1] = p1C;
    ord[2] = p1B;
    ord[3] = p1A; // swap32 BE -> LE
    ord[4] = p2B;
    ord[5] = p2A; // swap16 BE -> LE
    ord[6] = p3B;
    ord[7] = p3A; // swap16 BE -> LE
    ord.set(p4, 8);
    ord.set(p5, 10);
    return bytesToHex(ord);
}
exports.guidToUuid = guidToUuid;
/**
 * Creates a base-64 encoded ASCII string from a string of binary data, with
 * possible trailing equal sign(s) stripped.
 * @param {string}
 * @returns {string}
 */
function toBase64URL(str) {
    return btoa(str).replace(/\=+$/, "");
}
exports.toBase64URL = toBase64URL;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(61);
var EmptyObservable_1 = __webpack_require__(26);
var isScheduler_1 = __webpack_require__(27);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var DEFAULT_RESPONSE_TYPE = "json";
var DEFAULT_REQUEST_TIMEOUT = 30 * 1000; // TODO move to config?
function toJSONForIE(data) {
    try {
        return JSON.parse(data);
    }
    catch (e) {
        return null;
    }
}
function request(options) {
    var requestOptions = {
        url: options.url,
        body: options.body,
        headers: options.headers,
        method: options.method == null ?
            "GET" : options.method,
        responseType: options.responseType == null ?
            DEFAULT_RESPONSE_TYPE : options.responseType,
        timeout: options.timeout == null ?
            DEFAULT_REQUEST_TIMEOUT : options.timeout,
    };
    return Observable_1.Observable.create(function (obs) {
        var url = requestOptions.url, headers = requestOptions.headers, method = requestOptions.method, responseType = requestOptions.responseType, timeout = requestOptions.timeout, body = requestOptions.body;
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (timeout >= 0) {
            xhr.timeout = timeout;
        }
        xhr.responseType = responseType;
        if (xhr.responseType === "document") {
            xhr.overrideMimeType("text/xml");
        }
        if (headers) {
            var _headers = headers;
            for (var key in _headers) {
                if (_headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, _headers[key]);
                }
            }
        }
        var sentTime = Date.now();
        xhr.onerror = function onXHRError() {
            var errorCode = errors_1.RequestErrorTypes.ERROR_EVENT;
            obs.error(new errors_1.RequestError(xhr, url, errorCode));
        };
        xhr.ontimeout = function onXHRTimeout() {
            var errorCode = errors_1.RequestErrorTypes.TIMEOUT;
            obs.error(new errors_1.RequestError(xhr, url, errorCode));
        };
        if (!options.ignoreProgressEvents) {
            xhr.onprogress = function onXHRProgress(event) {
                var currentTime = Date.now();
                obs.next({
                    type: "progress",
                    value: {
                        url: url,
                        duration: currentTime - sentTime,
                        sentTime: sentTime,
                        currentTime: currentTime,
                        size: event.loaded,
                        totalSize: event.total,
                    },
                });
            };
        }
        // XXX TODO:
        // Waiting for https://github.com/Microsoft/TypeScript/issues/19830
        xhr.onload = function onXHRLoad(event) {
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    var receivedTime = Date.now();
                    var totalSize = event.total;
                    var status_1 = xhr.status;
                    var loadedResponseType = xhr.responseType;
                    var _url = xhr.responseURL || url;
                    var responseData = void 0;
                    if (loadedResponseType === "json") {
                        // IE bug where response is string with responseType json
                        responseData = xhr.response !== "string" ?
                            xhr.response : toJSONForIE(xhr.responseText);
                    }
                    else {
                        responseData = xhr.response;
                    }
                    if (responseData == null) {
                        var errorCode = errors_1.RequestErrorTypes.PARSE_ERROR;
                        obs.error(new errors_1.RequestError(xhr, _url, errorCode));
                        return;
                    }
                    obs.next({
                        type: "response",
                        value: {
                            status: status_1,
                            url: _url,
                            responseType: loadedResponseType,
                            sentTime: sentTime,
                            receivedTime: receivedTime,
                            duration: receivedTime - sentTime,
                            size: totalSize,
                            responseData: responseData,
                        },
                    });
                    obs.complete();
                }
                else {
                    var errorCode = errors_1.RequestErrorTypes.ERROR_HTTP_CODE;
                    obs.error(new errors_1.RequestError(xhr, url, errorCode));
                }
            }
        };
        if (body !== undefined) {
            xhr.send(body);
        }
        else {
            xhr.send();
        }
        return function () {
            if (xhr && xhr.readyState !== 4) {
                xhr.abort();
            }
        };
    });
}
exports.default = request;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorTypes = {
    NETWORK_ERROR: "NETWORK_ERROR",
    MEDIA_ERROR: "MEDIA_ERROR",
    ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
    INDEX_ERROR: "INDEX_ERROR",
    OTHER_ERROR: "OTHER_ERROR",
};
exports.ErrorTypes = ErrorTypes;
var RequestErrorTypes = {
    TIMEOUT: "TIMEOUT",
    ERROR_EVENT: "ERROR_EVENT",
    ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
    PARSE_ERROR: "PARSE_ERROR",
};
exports.RequestErrorTypes = RequestErrorTypes;
var ErrorCodes = {
    PIPELINE_RESOLVE_ERROR: "PIPELINE_RESOLVE_ERROR",
    PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
    PIPELINE_PARSING_ERROR: "PIPELINE_PARSING_ERROR",
    MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
    MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
    MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
    UNAVAILABLE_MEDIA_SOURCE: "UNAVAILABLE_MEDIA_SOURCE",
    MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
    MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
    MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
    KEY_ERROR: "KEY_ERROR",
    KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
    KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
    KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
    KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
    KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
    INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
    LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
    BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
    BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
    BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
    MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
    MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
    MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
    MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
    MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
    MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
    OUT_OF_INDEX_ERROR: "OUT_OF_INDEX_ERROR",
    UNKNOWN_INDEX: "UNKNOWN_INDEX",
    UNKNOWN_ERROR: "UNKNOWN_ERROR",
};
exports.ErrorCodes = ErrorCodes;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncAction_1 = __webpack_require__(107);
var AsyncScheduler_1 = __webpack_require__(106);
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ISO_639_1_to_ISO_639_3_1 = __webpack_require__(225);
var ISO_639_2_to_ISO_639_3_1 = __webpack_require__(224);
/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
function normalize(_language) {
    if (_language == null || _language === "") {
        return "";
    }
    var fields = ("" + _language).toLowerCase().split("-");
    var base = fields[0];
    var normalizedBase = normalizeBase(base);
    if (normalizedBase) {
        fields[0] = normalizedBase;
    }
    return fields.join("-");
}
exports.normalize = normalize;
/**
 * Normalize language into an ISO639-3 format.
 * @param {string} base
 * @returns {string}
 */
function normalizeBase(base) {
    var result;
    switch (base.length) {
        case 2:
            result = ISO_639_1_to_ISO_639_3_1.default[base];
            break;
        case 3:
            result = ISO_639_2_to_ISO_639_3_1.default[base];
            break;
    }
    return result || base;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeTextTrack(_language) {
    if (_language != null) {
        var language = void 0;
        var closedCaption = void 0;
        if (typeof _language === "string") {
            language = _language;
            closedCaption = false;
        }
        else {
            language = _language.language;
            closedCaption = !!_language.closedCaption;
        }
        return {
            language: language,
            closedCaption: closedCaption,
            normalized: normalize(language),
        };
    }
    return _language;
}
exports.normalizeTextTrack = normalizeTextTrack;
/**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeAudioTrack(_language) {
    if (_language != null) {
        var language = void 0;
        var audioDescription = void 0;
        if (typeof _language === "string") {
            language = _language;
            audioDescription = false;
        }
        else {
            language = _language.language;
            audioDescription = !!_language.audioDescription;
        }
        return {
            language: language,
            audioDescription: audioDescription,
            normalized: normalize(language),
        };
    }
    return _language;
}
exports.normalizeAudioTrack = normalizeAudioTrack;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
var bytes_1 = __webpack_require__(21);
var read_1 = __webpack_require__(227);
exports.getMDAT = read_1.getMDAT;
exports.getMDIA = read_1.getMDIA;
exports.getTRAF = read_1.getTRAF;
/**
 * Find the right atom (box) in an isobmff file from its hexa-encoded name.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {Number} - offset where the corresponding box is (starting with its
 * size), 0 if not found.
 */
function findAtom(buf, atomName) {
    var l = buf.length;
    var i = 0;
    var name;
    var size = 0;
    while (i + 8 < l) {
        size = bytes_1.be4toi(buf, i);
        name = bytes_1.be4toi(buf, i + 4);
        assert_1.default(size > 0, "out of range size");
        if (name === atomName) {
            break;
        }
        else {
            i += size;
        }
    }
    if (i >= l) {
        return -1;
    }
    assert_1.default(i + size <= l, "atom out of range");
    return i;
}
/**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */
function parseSidx(buf, initialOffset) {
    var index = findAtom(buf, 0x73696478 /* "sidx" */);
    if (index === -1) {
        return null;
    }
    var offset = initialOffset;
    var size = bytes_1.be4toi(buf, index);
    var pos = index + /* size */ 4 + /* name */ 4;
    /* version(8) */
    /* flags(24) */
    /* reference_ID(32); */
    /* timescale(32); */
    var version = buf[pos];
    pos += 4 + 4;
    var timescale = bytes_1.be4toi(buf, pos);
    pos += 4;
    /* earliest_presentation_time(32 / 64) */
    /* first_offset(32 / 64) */
    var time;
    if (version === 0) {
        time = bytes_1.be4toi(buf, pos);
        pos += 4;
        offset += bytes_1.be4toi(buf, pos) + size;
        pos += 4;
    }
    else if (version === 1) {
        time = bytes_1.be8toi(buf, pos);
        pos += 8;
        offset += bytes_1.be8toi(buf, pos) + size;
        pos += 8;
    }
    else {
        return null;
    }
    var segments = [];
    /* reserved(16) */
    /* reference_count(16) */
    pos += 2;
    var count = bytes_1.be2toi(buf, pos);
    pos += 2;
    while (--count >= 0) {
        /* reference_type(1) */
        /* reference_size(31) */
        /* segment_duration(32) */
        /* sap..(32) */
        var refChunk = bytes_1.be4toi(buf, pos);
        pos += 4;
        var refType = (refChunk & 0x80000000) >>> 31;
        var refSize = (refChunk & 0x7fffffff);
        // when set to 1 indicates that the reference is to a sidx, else to media
        if (refType === 1) {
            throw new Error("not implemented");
        }
        var d = bytes_1.be4toi(buf, pos);
        pos += 4;
        // let sapChunk = be4toi(buf, pos + 8);
        pos += 4;
        // TODO(pierre): handle sap
        // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
        // let sapType = (sapChunk & 0x70000000) >>> 28;
        // let sapDelta = sapChunk & 0x0FFFFFFF;
        segments.push({
            time: time,
            duration: d,
            count: 0,
            timescale: timescale,
            range: [offset, offset + refSize - 1],
        });
        time += d;
        offset += refSize;
    }
    return segments;
}
exports.parseSidx = parseSidx;
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function parseTfdt(buffer) {
    var traf = read_1.getTRAF(buffer);
    if (!traf) {
        return -1;
    }
    var index = findAtom(traf, 0x74666474 /* tfdt */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = traf[pos];
    pos += 4;
    if (version > 1) {
        return -1;
    }
    return version ? bytes_1.be8toi(traf, pos) : bytes_1.be4toi(traf, pos);
}
exports.parseTfdt = parseTfdt;
function getDefaultDurationFromTFHDInTRAF(traf) {
    var index = findAtom(traf, 0x74666864 /* tfhd */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4 + /* version */ 1;
    var flags = bytes_1.be3toi(traf, pos);
    var hasBaseDataOffset = flags & 0x000001;
    var hasSampleDescriptionIndex = flags & 0x000002;
    var hasDefaultSampleDuration = flags & 0x000008;
    if (!hasDefaultSampleDuration) {
        return -1;
    }
    pos += 4;
    if (hasBaseDataOffset) {
        pos += 8;
    }
    if (hasSampleDescriptionIndex) {
        pos += 4;
    }
    var defaultDuration = bytes_1.be4toi(traf, pos);
    return defaultDuration;
}
function getDurationFromTrun(buffer) {
    var traf = read_1.getTRAF(buffer);
    if (!traf) {
        return -1;
    }
    var index = findAtom(traf, 0x7472756e /* tfdt */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = traf[pos];
    pos += 1;
    if (version > 1) {
        return -1;
    }
    var flags = bytes_1.be3toi(traf, pos);
    pos += 3;
    var hasSampleDuration = flags & 0x000100;
    var defaultDuration = 0;
    if (!hasSampleDuration) {
        defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
        if (defaultDuration >= 0) {
            return defaultDuration;
        }
        return -1;
    }
    var hasDataOffset = flags & 0x000001;
    var hasFirstSampleFlags = flags & 0x000004;
    var hasSampleSize = flags & 0x000200;
    var hasSampleFlags = flags & 0x000400;
    var hasSampleCompositionOffset = flags & 0x000800;
    var sampleCounts = bytes_1.be4toi(traf, pos);
    pos += 4;
    if (hasDataOffset) {
        pos += 4;
    }
    if (hasFirstSampleFlags) {
        pos += 4;
    }
    var i = sampleCounts;
    var duration = 0;
    while (i--) {
        if (hasSampleDuration) {
            duration += bytes_1.be4toi(traf, pos);
            pos += 4;
        }
        else {
            duration += defaultDuration;
        }
        if (hasSampleSize) {
            pos += 4;
        }
        if (hasSampleFlags) {
            pos += 4;
        }
        if (hasSampleCompositionOffset) {
            pos += 4;
        }
    }
    return duration;
}
exports.getDurationFromTrun = getDurationFromTrun;
/**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function getMDHDTimescale(buffer) {
    var mdia = read_1.getMDIA(buffer);
    if (!mdia) {
        return -1;
    }
    var index = findAtom(mdia, 0x6d646864 /* "mdhd" */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = mdia[pos];
    pos += 4;
    if (version === 1) {
        pos += 16;
        return bytes_1.be4toi(mdia, pos);
    }
    else if (version === 0) {
        pos += 8;
        return bytes_1.be4toi(mdia, pos);
    }
    else {
        return -1;
    }
}
exports.getMDHDTimescale = getMDHDTimescale;
/**
 * Create a new _Atom_ (isobmff box).
 * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)
 * @param {Uint8Array} buff - The box's content
 */
function Atom(name, buff) {
    var len = buff.length + 8;
    return bytes_1.concat(bytes_1.itobe4(len), bytes_1.strToBytes(name), buff);
}
/**
 * Returns a PSSH Atom from a systemId and private data.
 * @param {Object} args
 * @returns {Uint8Array}
 */
function createPssh(_a) {
    var systemId = _a.systemId, privateData = _a.privateData;
    var _systemId = systemId.replace(/-/g, "");
    assert_1.default(_systemId.length === 32);
    return Atom("pssh", bytes_1.concat(4, // 4 initial zeroed bytes
    bytes_1.hexToBytes(_systemId), bytes_1.itobe4(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the pssList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} pssList - The content protections under the form of
 * objects containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {*}: private data associated.
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */
function patchPssh(buf, pssList) {
    if (!pssList || !pssList.length) {
        return buf;
    }
    var pos = findAtom(buf, 0x6d6f6f76 /* = "moov" */);
    if (pos === -1) {
        return buf;
    }
    var size = bytes_1.be4toi(buf, pos); // size of the "moov" box
    var moov = buf.subarray(pos, pos + size);
    var moovArr = [moov];
    for (var i = 0; i < pssList.length; i++) {
        moovArr.push(createPssh(pssList[i]));
    }
    var newmoov = bytes_1.concat.apply(void 0, moovArr);
    newmoov.set(bytes_1.itobe4(newmoov.length), 0); // overwrite "moov" length
    return bytes_1.concat(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));
}
exports.patchPssh = patchPssh;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
    if (reason == null) {
        return name + " (" + code + ")";
    }
    else if (typeof reason === "string") {
        return name + " (" + code + ") " + reason;
    }
    else {
        var message = reason instanceof Event ? reason.type : reason.message;
        return name + " (" + code + ") " + message;
    }
}
exports.default = errorMessage;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(24);
var errorMessage_1 = __webpack_require__(31);
/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */
var MediaError = /** @class */ (function (_super) {
    __extends(MediaError, _super);
    function MediaError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, MediaError.prototype);
        _this.name = "MediaError";
        _this.type = constants_1.ErrorTypes.MEDIA_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?
            constants_1.ErrorCodes[code] : "";
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return MediaError;
}(Error));
exports.default = MediaError;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._listeners = {};
    }
    /**
     * Register a new callback for an event.
     *
     * @param {string} evt - The event to register a callback to
     * @param {Function} fn - The callback to call as that event is triggered.
     * The callback will take as argument the eventual payload of the event
     * (single argument).
     */
    EventEmitter.prototype.addEventListener = function (evt, fn) {
        var listeners = this._listeners[evt];
        if (!listeners) {
            this._listeners[evt] = [fn];
        }
        else {
            listeners.push(fn);
        }
    };
    /**
     * Unregister callbacks linked to events.
     * @param {string} [evt] - The event for which the callback[s] should be
     * unregistered. Set it to null or undefined to remove all callbacks
     * currently registered (for any event).
     * @param {Function} [fn] - The callback to unregister. If set to null
     * or undefined while the evt argument is set, all callbacks linked to that
     * event will be unregistered.
     */
    EventEmitter.prototype.removeEventListener = function (evt, fn) {
        if (evt == null) {
            this._listeners = {};
            return;
        }
        var listeners = this._listeners[evt];
        if (!listeners) {
            return;
        }
        if (fn == null) {
            delete this._listeners[evt];
            return;
        }
        var index = listeners.indexOf(fn);
        if (~index) {
            listeners.splice(index, 1);
        }
        if (!listeners.length) {
            delete this._listeners[evt];
        }
    };
    /**
     * Trigger every registered callbacks for a given event
     * @param {string} evt - The event to trigger
     * @param {*} arg - The eventual payload for that event. All triggered
     * callbacks will recieve this payload as argument.
     */
    EventEmitter.prototype.trigger = function (evt, arg) {
        var listeners = this._listeners[evt];
        if (!listeners) {
            return;
        }
        listeners.slice().forEach(function (listener) {
            try {
                listener(arg);
            }
            catch (e) {
                log_1.default.error(e, e.stack);
            }
        });
    };
    return EventEmitter;
}());
exports.default = EventEmitter;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function adaptationChange(bufferType, adaptation, period) {
    return {
        type: "adaptationChange",
        value: {
            type: bufferType,
            adaptation: adaptation,
            period: period,
        },
    };
}
function loaded() {
    return {
        type: "loaded",
        value: true,
    };
}
function stalled(stalling) {
    return {
        type: "stalled",
        value: stalling,
    };
}
function manifestReady(abrManager, manifest) {
    return {
        type: "manifestReady",
        value: {
            abrManager: abrManager,
            manifest: manifest,
        },
    };
}
function manifestUpdate(manifest) {
    return {
        type: "manifestUpdate",
        value: {
            manifest: manifest,
        },
    };
}
function speedChanged(speed) {
    return {
        type: "speed",
        value: speed,
    };
}
function activePeriodChanged(period) {
    return {
        type: "activePeriodChanged",
        value: {
            period: period,
        },
    };
}
function nullRepresentation(type, period) {
    return {
        type: "representationChange",
        value: {
            type: type,
            representation: null,
            period: period,
        },
    };
}
function periodBufferReady(type, period, adaptation$) {
    return {
        type: "periodBufferReady",
        value: {
            type: type,
            period: period,
            adaptation$: adaptation$,
        },
    };
}
function periodBufferCleared(type, period) {
    return {
        type: "periodBufferCleared",
        value: {
            type: type,
            period: period,
        },
    };
}
function warning(value) {
    return {
        type: "warning",
        value: value,
    };
}
function endOfStream() {
    return {
        type: "end-of-stream",
        value: undefined,
    };
}
function resumeStream() {
    return {
        type: "resume-stream",
        value: undefined,
    };
}
function bufferComplete(bufferType) {
    return {
        type: "complete-buffer",
        value: {
            type: bufferType,
        },
    };
}
var STREAM_EVENTS = {
    activePeriodChanged: activePeriodChanged,
    adaptationChange: adaptationChange,
    bufferComplete: bufferComplete,
    endOfStream: endOfStream,
    resumeStream: resumeStream,
    loaded: loaded,
    manifestReady: manifestReady,
    manifestUpdate: manifestUpdate,
    nullRepresentation: nullRepresentation,
    periodBufferCleared: periodBufferCleared,
    periodBufferReady: periodBufferReady,
    speedChanged: speedChanged,
    stalled: stalled,
    warning: warning,
};
exports.default = STREAM_EVENTS;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(32);
var log_1 = __webpack_require__(1);
var image_1 = __webpack_require__(158);
var queued_source_buffer_1 = __webpack_require__(156);
exports.QueuedSourceBuffer = queued_source_buffer_1.default;
var text_1 = __webpack_require__(155);
// Array of every SourceBuffer types managed here
exports.BUFFER_TYPES = ["audio", "video", "text", "image"];
/**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one source buffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBufferManager
 */
var SourceBufferManager = /** @class */ (function () {
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {MediaSource} mediaSource
     * @constructor
     */
    function SourceBufferManager(videoElement, mediaSource) {
        this._videoElement = videoElement;
        this._mediaSource = mediaSource;
        this._initializedNativeSourceBuffers = {};
        this._initializedCustomSourceBuffers = {};
    }
    /**
     * Returns true if the source buffer is "native" (has to be attached to the
     * mediaSource at the beginning of the stream.
     * @static
     * @param {string} bufferType
     * @returns {Boolean}
     */
    SourceBufferManager.isNative = function (bufferType) {
        return shouldHaveNativeSourceBuffer(bufferType);
    };
    /**
     * Returns true if a SourceBuffer with the type given has been created with
     * this instance of the SourceBufferManager.
     * @param {string} bufferType
     * @returns {Boolean}
     */
    SourceBufferManager.prototype.has = function (bufferType) {
        if (shouldHaveNativeSourceBuffer(bufferType)) {
            return !!this._initializedNativeSourceBuffers[bufferType];
        }
        return !!this._initializedCustomSourceBuffers[bufferType];
    };
    /**
     * Returns the created QueuedSourceBuffer for the given type.
     * Throws if no QueuedSourceBuffer were created for the given type.
     *
     * @param {string} bufferType
     * @returns {QueuedSourceBuffer}
     */
    SourceBufferManager.prototype.get = function (bufferType) {
        if (shouldHaveNativeSourceBuffer(bufferType)) {
            var sourceBufferInfos = this._initializedNativeSourceBuffers[bufferType];
            if (!sourceBufferInfos) {
                throw new Error("SourceBufferManager: no " + bufferType + " initialized yet");
            }
            return sourceBufferInfos.sourceBuffer;
        }
        else {
            var sourceBufferInfos = this._initializedCustomSourceBuffers[bufferType];
            if (!sourceBufferInfos) {
                throw new Error("SourceBufferManager: no " + bufferType + " initialized yet");
            }
            return sourceBufferInfos.sourceBuffer;
        }
    };
    /**
     * Creates a new QueuedSourceBuffer for the given buffer type.
     * Reuse an already created one if a QueuedSourceBuffer for the given type
     * already exists. TODO Throw or abort old one instead?
     * @param {string} bufferType
     * @param {string} codec
     * @param {Object} [options={}]
     * @returns {QueuedSourceBuffer}
     */
    SourceBufferManager.prototype.createSourceBuffer = function (bufferType, codec, options) {
        if (options === void 0) { options = {}; }
        if (shouldHaveNativeSourceBuffer(bufferType)) {
            var memorizedSourceBuffer = this._initializedNativeSourceBuffers[bufferType];
            if (memorizedSourceBuffer) {
                if (memorizedSourceBuffer.codec !== codec) {
                    log_1.default.warn("reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec);
                }
                else {
                    log_1.default.info("reusing native SourceBuffer with codec", codec);
                }
                return memorizedSourceBuffer.sourceBuffer;
            }
            log_1.default.info("adding native SourceBuffer with codec", codec);
            var nativeSourceBuffer = createNativeQueuedSourceBuffer(this._mediaSource, codec);
            this._initializedNativeSourceBuffers[bufferType] = {
                codec: codec,
                sourceBuffer: nativeSourceBuffer,
            };
            return nativeSourceBuffer;
        }
        var memorizedCustomSourceBuffer = this
            ._initializedCustomSourceBuffers[bufferType];
        if (memorizedCustomSourceBuffer) {
            log_1.default.info("reusing a previous custom SourceBuffer for the type", bufferType);
            return memorizedCustomSourceBuffer.sourceBuffer;
        }
        if (bufferType === "text") {
            log_1.default.info("creating a new text SourceBuffer with codec", codec);
            var sourceBuffer = options.textTrackMode === "html" ?
                new text_1.HTMLTextSourceBuffer(this._videoElement, options.textTrackElement) :
                new text_1.NativeTextSourceBuffer(this._videoElement, options.hideNativeSubtitle);
            var queuedSourceBuffer = new queued_source_buffer_1.default(sourceBuffer);
            this._initializedCustomSourceBuffers.text = {
                codec: codec,
                sourceBuffer: queuedSourceBuffer,
            };
            return queuedSourceBuffer;
        }
        else if (bufferType === "image") {
            log_1.default.info("creating a new image SourceBuffer with codec", codec);
            var sourceBuffer = new image_1.default();
            var queuedSourceBuffer = new queued_source_buffer_1.default(sourceBuffer);
            this._initializedCustomSourceBuffers.image = {
                codec: codec,
                sourceBuffer: queuedSourceBuffer,
            };
            return queuedSourceBuffer;
        }
        log_1.default.error("unknown buffer type:", bufferType);
        throw new MediaError_1.default("BUFFER_TYPE_UNKNOWN", null, true);
    };
    /**
     * Dispose of the active SourceBuffer for the given type.
     * @param {string} bufferType
     */
    SourceBufferManager.prototype.disposeSourceBuffer = function (bufferType) {
        if (shouldHaveNativeSourceBuffer(bufferType)) {
            var memorizedNativeSourceBuffer = this
                ._initializedNativeSourceBuffers[bufferType];
            if (memorizedNativeSourceBuffer == null) {
                return;
            }
            log_1.default.info("aborting native source buffer", bufferType);
            if (this._mediaSource.readyState === "open") {
                try {
                    memorizedNativeSourceBuffer.sourceBuffer.abort();
                }
                catch (e) {
                    log_1.default.warn("failed to abort a SourceBuffer:", e);
                }
            }
            delete this._initializedNativeSourceBuffers[bufferType];
            return;
        }
        else if (bufferType === "text" || bufferType === "image") {
            var memorizedSourceBuffer = this
                ._initializedCustomSourceBuffers[bufferType];
            if (memorizedSourceBuffer == null) {
                return;
            }
            log_1.default.info("aborting custom source buffer", bufferType);
            try {
                memorizedSourceBuffer.sourceBuffer.abort();
            }
            catch (e) {
                log_1.default.warn("failed to abort a SourceBuffer:", e);
            }
            delete this._initializedCustomSourceBuffers[bufferType];
            return;
        }
        log_1.default.error("cannot dispose an unknown buffer type", bufferType);
    };
    /**
     * Dispose of all QueuedSourceBuffer created on this SourceBufferManager.
     */
    SourceBufferManager.prototype.disposeAll = function () {
        var _this = this;
        exports.BUFFER_TYPES.forEach(function (bufferType) {
            if (_this.has(bufferType)) {
                _this.disposeSourceBuffer(bufferType);
            }
        });
    };
    return SourceBufferManager;
}());
exports.default = SourceBufferManager;
/**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */
function createNativeQueuedSourceBuffer(mediaSource, codec) {
    var sourceBuffer = mediaSource.addSourceBuffer(codec);
    return new queued_source_buffer_1.default(sourceBuffer);
}
/**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" source buffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */
function shouldHaveNativeSourceBuffer(bufferType) {
    return bufferType === "audio" || bufferType === "video";
}


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
var Initialization_1 = __webpack_require__(208);
/**
 * TODO Only for SegmentBase not for other types
 * @param {Element} root
 * @returns {Object}
 */
function parseSegmentBase(root) {
    var attributes = {};
    var segmentBaseChildren = root.childNodes;
    for (var i = 0; i < segmentBaseChildren.length; i++) {
        if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentNode = segmentBaseChildren[i];
            if (currentNode.nodeName === "Initialization") {
                attributes.initialization = Initialization_1.default(currentNode);
            }
        }
    }
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "timescale":
                {
                    var _timescale = parseInt(attribute.value, 10);
                    if (isNaN(_timescale)) {
                        log_1.default.warn("DASH: invalid timescale (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.timescale = _timescale;
                    }
                }
                break;
            case "timeShiftBufferDepth":
                {
                    var timeShiftBufferDepth = helpers_1.parseDuration(attribute.value);
                    if (isNaN(timeShiftBufferDepth)) {
                        log_1.default.warn("DASH: invalid timeShiftBufferDepth (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.timeShiftBufferDepth = timeShiftBufferDepth;
                    }
                }
                break;
            case "presentationTimeOffset":
                {
                    var _presentationTimeOffset = parseFloat(attribute.value);
                    if (isNaN(_presentationTimeOffset)) {
                        log_1.default.warn("DASH: invalid presentationTimeOffset (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.presentationTimeOffset = _presentationTimeOffset;
                    }
                }
                break;
            case "indexRange":
                attributes.indexRange = helpers_1.parseByteRange(attribute.value) || undefined;
                break;
            case "indexRangeExact":
                attributes.indexRangeExact = helpers_1.parseBoolean(attribute.value);
                break;
            case "availabilityTimeOffset":
                {
                    var availabilityTimeOffset = parseFloat(attribute.value);
                    if (isNaN(availabilityTimeOffset)) {
                        log_1.default.warn("DASH: invalid availabilityTimeOffset (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.availabilityTimeOffset = availabilityTimeOffset;
                    }
                }
                break;
            case "availabilityTimeComplete":
                attributes.availabilityTimeComplete = helpers_1.parseBoolean(attribute.value);
                break;
            case "duration":
                {
                    var duration = parseInt(attribute.value, 10);
                    if (isNaN(duration)) {
                        log_1.default.warn("DASH: invalid duration (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.duration = duration;
                    }
                }
                break;
            case "startNumber":
                {
                    var startNumber = parseInt(attribute.value, 10);
                    if (isNaN(startNumber)) {
                        log_1.default.warn("DASH: invalid startNumber (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.startNumber = startNumber;
                    }
                }
                break;
        }
    }
    var timescale = attributes.timescale == null ? 1 : attributes.timescale;
    var indexRangeExact = !!attributes.indexRangeExact;
    var availabilityTimeComplete = attributes.availabilityTimeComplete == null ?
        true : attributes.availabilityTimeComplete;
    return objectAssign(attributes, {
        availabilityTimeComplete: availabilityTimeComplete,
        indexRangeExact: indexRangeExact,
        timeline: [],
        timescale: timescale,
    });
}
exports.default = parseSegmentBase;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} seg
 * @param {Object} nextSeg
 * @returns {Number}
 */
function calculateRepeat(seg, nextSeg) {
    var rep = seg.r || 0;
    // A negative value of the @r attribute of the S element indicates
    // that the duration indicated in @d attribute repeats until the
    // start of the next S element, the end of the Period or until the
    // next MPD update.
    if (rep < 0) {
        var repEnd = nextSeg ? nextSeg.ts : Infinity;
        rep = Math.ceil((repEnd - seg.ts) / seg.d) - 1;
    }
    return rep;
}
/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function normalizeRange(index, // TODO
ts, duration) {
    var pto = index.presentationTimeOffset || 0;
    var timescale = index.timescale || 1;
    return {
        up: (ts) * timescale - pto,
        to: (ts + duration) * timescale - pto,
    };
}
exports.normalizeRange = normalizeRange;
/**
 * Get start of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute start time of the range
 */
function getTimelineRangeStart(_a) {
    var ts = _a.ts, d = _a.d, r = _a.r;
    return d === -1 ? ts : ts + r * d;
}
exports.getTimelineRangeStart = getTimelineRangeStart;
/**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute end time of the range
 */
function getTimelineRangeEnd(_a) {
    var ts = _a.ts, d = _a.d, r = _a.r;
    return d === -1 ? ts : ts + (r + 1) * d;
}
exports.getTimelineRangeEnd = getTimelineRangeEnd;
/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @param {Number} index.timescale
 * @param {Object} [index.initialization={}]
 * @param {Array.<Number>|null} [index.initialization.range=null]
 * @param {Array.<Number>|null} [index.initialization.indexRange=null]
 * @param {string} [index.initialization.media]
 * @returns {Object}
 */
function getInitSegment(index) {
    var _a = index.initialization, initialization = _a === void 0 ? {} : _a;
    return {
        id: "init",
        isInit: true,
        time: 0,
        range: initialization.range || undefined,
        indexRange: index.indexRange || undefined,
        media: initialization.media,
        timescale: index.timescale,
    };
}
exports.getInitSegment = getInitSegment;
/**
 * @param {Number} ts
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
function getSegmentNumber(ts, up, duration) {
    var diff = up - ts;
    if (diff > 0) {
        return Math.floor(diff / duration);
    }
    else {
        return 0;
    }
}
function getSegmentsFromTimeline(index, _up, _to) {
    var _a = normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
    var timeline = index.timeline, timescale = index.timescale, media = index.media, startNumber = index.startNumber;
    var currentNumber = startNumber != null ? startNumber : undefined;
    var segments = [];
    var timelineLength = timeline.length;
    // TODO(pierre): use @maxSegmentDuration if possible
    var maxEncounteredDuration = (timeline.length && timeline[0].d) || 0;
    for (var i = 0; i < timelineLength; i++) {
        var segmentRange = timeline[i];
        var d = segmentRange.d, ts = segmentRange.ts, range = segmentRange.range;
        maxEncounteredDuration = Math.max(maxEncounteredDuration, d);
        // live-added segments have @d attribute equals to -1
        if (d < 0) {
            // TODO what? May be to play it safe and avoid adding segments which are
            // not completely generated
            if (ts + maxEncounteredDuration < to) {
                var segment = {
                    id: "" + ts,
                    time: ts,
                    isInit: false,
                    range: range,
                    duration: undefined,
                    timescale: timescale,
                    media: media,
                    number: currentNumber != null ? currentNumber : undefined,
                };
                segments.push(segment);
            }
            return segments;
        }
        var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
        var segmentNumberInCurrentRange = getSegmentNumber(ts, up, d);
        var segmentTime = ts + segmentNumberInCurrentRange * d;
        while (segmentTime < to && segmentNumberInCurrentRange <= repeat) {
            var segment = {
                id: "" + segmentTime,
                time: segmentTime,
                isInit: false,
                range: range,
                duration: d,
                timescale: timescale,
                media: media,
                number: currentNumber != null ?
                    currentNumber + segmentNumberInCurrentRange : undefined,
            };
            segments.push(segment);
            // update segment number and segment time for the next segment
            segmentNumberInCurrentRange++;
            segmentTime = ts + segmentNumberInCurrentRange * d;
        }
        if (segmentTime >= to) {
            // we reached ``to``, we're done
            return segments;
        }
        if (currentNumber != null) {
            currentNumber += repeat + 1;
        }
    }
    return segments;
}
exports.getSegmentsFromTimeline = getSegmentsFromTimeline;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Convert given buffer to a 32bit integer hash
 * @param {Array|TypedArray} buffer
 * @returns {Number}
 */
function hashBuffer(buffer) {
    var hash = 0;
    var char;
    for (var i = 0; i < buffer.length; i++) {
        char = buffer[i];
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}
exports.default = hashBuffer;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(7);
var queue_1 = __webpack_require__(243);
var Subscription_1 = __webpack_require__(17);
var observeOn_1 = __webpack_require__(110);
var ObjectUnsubscribedError_1 = __webpack_require__(57);
var SubjectSubscription_1 = __webpack_require__(100);
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Do nothing, well.
 */
/* tslint:disable:no-empty */
function default_1() { }
exports.default = default_1;
/* tslint:enable:no-empty */


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(27);
var of_1 = __webpack_require__(104);
var from_1 = __webpack_require__(112);
var concatAll_1 = __webpack_require__(102);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ArrayObservable_1 = __webpack_require__(22);
var isScheduler_1 = __webpack_require__(27);
var mergeAll_1 = __webpack_require__(105);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var array_includes_1 = __webpack_require__(13);
/**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeFirst(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */
var SortedList = /** @class */ (function () {
    /**
     * @param {Function} sortingFunction
     */
    function SortedList(sortingFunction) {
        this._array = [];
        this._sortingFn = sortingFunction;
    }
    /**
     * Returns the nth element. Throws if the index does not exist.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @throws Error - Throws if the given index is negative or superior to the
     * array's length.
     * @param {number} index
     * @returns {*}
     */
    SortedList.prototype.get = function (index) {
        if (index < 0 || index >= this._array.length) {
            throw new Error("Invalid index.");
        }
        return this._array[index];
    };
    /**
     * Returns this list as a JS array.
     *
     * /!\ The returned Array shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {Array.<*>}
     */
    SortedList.prototype.unwrap = function () {
        return this._array;
    };
    /**
     * Find the first element corresponding to the given predicate.
     *
     * /!\ The returned element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {Function} fn
     * @returns {*}
     */
    SortedList.prototype.find = function (fn) {
        return arrayFind(this._array, fn);
    };
    /**
     * Returns the index of the given element in the list.
     * -1 if not found.
     * @param {*} element
     * @returns {number}
     */
    SortedList.prototype.indexOf = function (element) {
        return this._array.indexOf(element);
    };
    /**
     * Returns true if the List contains the given element.
     * @param {*} element
     * @returns {Boolean}
     */
    SortedList.prototype.has = function (element) {
        return array_includes_1.default(this._array, element);
    };
    /**
     * Returns the current length of the list.
     * @returns {number}
     */
    SortedList.prototype.length = function () {
        return this._array.length;
    };
    /**
     * Add a new element to the List at the right place for the List to stay
     * sorted.
     *
     * /!\ The added Element will share the same reference than the given
     * argument, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {...*} elements
     */
    SortedList.prototype.add = function () {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        elements.sort(this._sortingFn);
        var j = 0;
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var inserted = false;
            while (!inserted && j < this._array.length) {
                if (this._sortingFn(element, this._array[j]) < 0) {
                    this._array.splice(j, 0, element);
                    inserted = true;
                }
                else {
                    j++;
                }
            }
            if (!inserted) {
                this._array.push(element);
            }
        }
    };
    /**
     * Remove the first occurence of the given element.
     * Returns the index of the removed element. Undefined if not found.
     * @returns {number|undefined}
     */
    SortedList.prototype.removeFirst = function (element) {
        var indexOf = this._array.indexOf(element);
        if (indexOf >= 0) {
            this._array.splice(indexOf, 1);
            return indexOf;
        }
    };
    /**
     * Returns the first element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    SortedList.prototype.head = function () {
        return this._array[0];
    };
    /**
     * Returns the last element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    SortedList.prototype.last = function () {
        return this._array[this._array.length - 1];
    };
    /**
     * Remove the first element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    SortedList.prototype.shift = function () {
        return this._array.shift();
    };
    /**
     * Remove the last element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    SortedList.prototype.pop = function () {
        return this._array.pop();
    };
    /**
     * Returns true if the given element is before the whole list when sorted.
     * As in, it would be the first element is pushed to the sortedList.
     * @param {*} element
     * @returns {boolean}
     */
    SortedList.prototype.isBefore = function (element) {
        if (!this._array.length) {
            return true;
        }
        return this._sortingFn(element, this._array[0]) < 0;
    };
    /**
     * Returns true if the given element is after the whole list when sorted.
     * As in, it would be the last element is pushed to the sortedList.
     * @param {*} element
     * @returns {boolean}
     */
    SortedList.prototype.isAfter = function (element) {
        if (!this._array.length) {
            return true;
        }
        return this._sortingFn(element, this._array[this._array.length - 1]) >= 0;
    };
    /**
     * Returns true if the wrapped Array is well-sorted.
     *
     * You might want to call this function to know if a mutation you've done
     * yourself impacted the order of elements.
     * You can then call the forceSort function to sort the list manually.
     *
     * @example
     * ```js
     * const sortedList = new SortedList((a, b) => a.start - b.start);
     * const element1 = { start: 20 };
     * const element2 = { start: 10 };
     *
     * sortedList.add(element1, element2);
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 20 }]
     * console.log(sortedList.checkSort()); // -> true
     *
     * element2.start = 5; // Mutation impacting the order of elements
     * console.log(sortedList.unwrap()); // -> [{ start: 10 }, { start : 5 }]
     * console.log(sortedList.checkSort()); // -> false
     *
     * sortedList.forceSort();
     * console.log(sortedList.unwrap()); // -> [{ start: 5 }, { start : 10 }]
     * console.log(sortedList.checkSort()); // -> true
     * ```
     * @returns {Boolean}
     */
    SortedList.prototype.checkSort = function () {
        for (var i = 0; i < this._array.length - 1; i++) {
            if (this._sortingFn(this._array[i], this._array[i + 1]) > 0) {
                return false;
            }
        }
        return true;
    };
    /**
     * Force the array to be sorted.
     *
     * You might want to call this function when you're unsure that a mutation
     * you've done yourself impacted the order of the elements in the list.
     */
    SortedList.prototype.forceSort = function () {
        this._array.sort(this._sortingFn);
    };
    return SortedList;
}());
exports.default = SortedList;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
exports.REGXP_TIME_COLON_FRAMES = REGXP_TIME_COLON_FRAMES;
/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;
exports.REGXP_TIME_COLON = REGXP_TIME_COLON;
/**
 * @type {RegExp}
 * @example 01:02:43.0345555 or 02:43.03
 */
var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;
exports.REGXP_TIME_COLON_MS = REGXP_TIME_COLON_MS;
/**
 * @type {RegExp}
 * @example 75f or 75.5f
 */
var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;
exports.REGXP_TIME_FRAMES = REGXP_TIME_FRAMES;
/**
 * @type {RegExp}
 * @example 50t or 50.5t
 */
var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;
exports.REGXP_TIME_TICK = REGXP_TIME_TICK;
/**
 * @type {RegExp}
 * @example 3.45h, 3m or 4.20s
 */
var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;
exports.REGXP_TIME_HMS = REGXP_TIME_HMS;
/**
 * @type {RegExp}
 * @example 50% 10%
 */
var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
exports.REGXP_PERCENT_VALUES = REGXP_PERCENT_VALUES;
var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
exports.REGXP_8_HEX_COLOR = REGXP_8_HEX_COLOR;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
exports.REGXP_4_HEX_COLOR = REGXP_4_HEX_COLOR;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var array_includes_1 = __webpack_require__(13);
var starts_with_1 = __webpack_require__(149);
/**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
function getStylingAttributes(attributes, nodes, styles, regions) {
    var currentStyle = {};
    var leftAttributes = attributes.slice();
    var _loop_1 = function (i) {
        var node = nodes[i];
        if (node) {
            var styleID_1;
            var regionID_1;
            // 1. the style is directly set on a "tts:" attribute
            if (node.nodeType === Node.ELEMENT_NODE) {
                var element = node;
                for (var j = 0; j <= element.attributes.length - 1; j++) {
                    var attribute = element.attributes[j];
                    var name_1 = attribute.name;
                    if (name_1 === "style") {
                        styleID_1 = attribute.value;
                    }
                    else if (name_1 === "region") {
                        regionID_1 = attribute.value;
                    }
                    else {
                        var nameWithoutTTS = name_1.substr(4);
                        if (array_includes_1.default(leftAttributes, nameWithoutTTS)) {
                            currentStyle[nameWithoutTTS] = attribute.value;
                            leftAttributes.splice(j, 1);
                            if (!leftAttributes.length) {
                                return { value: currentStyle };
                            }
                        }
                    }
                }
            }
            // 2. the style is referenced on a "style" attribute
            if (styleID_1) {
                var style = arrayFind(styles, function (x) { return x.id === styleID_1; });
                if (style) {
                    for (var j = 0; j <= leftAttributes.length - 1; j++) {
                        var attribute = leftAttributes[j];
                        if (!currentStyle[attribute]) {
                            if (style.style[attribute]) {
                                currentStyle[attribute] = style.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (!leftAttributes.length) {
                                    return { value: currentStyle };
                                }
                                j--;
                            }
                        }
                    }
                }
            }
            // 3. the node reference a region (which can have a value for the
            //    corresponding style)
            if (regionID_1) {
                var region = arrayFind(regions, function (x) {
                    return x.id === regionID_1;
                });
                if (region) {
                    for (var j = 0; j <= leftAttributes.length - 1; j++) {
                        var attribute = leftAttributes[j];
                        if (!currentStyle[attribute]) {
                            if (region.style[attribute]) {
                                currentStyle[attribute] = region.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (!leftAttributes.length) {
                                    return { value: currentStyle };
                                }
                                j--;
                            }
                        }
                    }
                }
            }
        }
    };
    for (var i = 0; i <= nodes.length - 1; i++) {
        var state_1 = _loop_1(i);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return currentStyle;
}
exports.getStylingAttributes = getStylingAttributes;
/**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */
function getStylingFromElement(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
        return {};
    }
    var element = node;
    var currentStyle = {};
    for (var i = 0; i <= element.attributes.length - 1; i++) {
        var styleAttribute = element.attributes[i];
        if (starts_with_1.default(styleAttribute.name, "tts")) {
            var nameWithoutTTS = styleAttribute.name.substr(4);
            currentStyle[nameWithoutTTS] = styleAttribute.value;
        }
    }
    return currentStyle;
}
exports.getStylingFromElement = getStylingFromElement;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
    if (!(element.parentNode instanceof Element)) {
        return [];
    }
    function constructArray(_element) {
        var elements = [];
        if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
            elements.push(_element);
        }
        var parentNode = _element.parentNode;
        if (parentNode instanceof Element) {
            elements.push.apply(elements, constructArray(parentNode));
        }
        return elements;
    }
    return constructArray(element.parentNode);
}
exports.default = getParentElementsByTagName;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(4);
var eventemitter_1 = __webpack_require__(33);
var rx_tryCatch_1 = __webpack_require__(49);
var time_ranges_1 = __webpack_require__(157);
/**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */
var AbstractSourceBuffer = /** @class */ (function (_super) {
    __extends(AbstractSourceBuffer, _super);
    function AbstractSourceBuffer() {
        var _this = _super.call(this) || this;
        _this.updating = false;
        _this.readyState = "opened";
        _this.buffered = new time_ranges_1.default();
        return _this;
    }
    /**
     * Mimic the SourceBuffer _appendBuffer_ method: Append segment.
     * @param {*} data
     */
    AbstractSourceBuffer.prototype.appendBuffer = function (data) {
        var _this = this;
        this._lock(function () { return _this._append(data); });
    };
    /**
     * Mimic the SourceBuffer _remove_ method: remove segment.
     * @param {Number} from
     * @param {Number} to
     */
    AbstractSourceBuffer.prototype.remove = function (from, to) {
        var _this = this;
        this._lock(function () { return _this._remove(from, to); });
    };
    /**
     * Mimic the SourceBuffer _abort_ method.
     */
    AbstractSourceBuffer.prototype.abort = function () {
        this.remove(0, Infinity);
        this.updating = false;
        this.readyState = "closed";
        this._abort();
    };
    /**
     * Active a lock, execute the given function, unlock when finished (on
     * nextTick).
     * Throws if multiple lock are active at the same time.
     * Also triggers the right events on start, error and end
     * @param {Function} func
     */
    AbstractSourceBuffer.prototype._lock = function (func) {
        var _this = this;
        assert_1.default(!this.updating, "updating");
        this.updating = true;
        this.trigger("updatestart", undefined);
        var result = rx_tryCatch_1.default(function () {
            func();
            return Observable_1.Observable.of(undefined);
        });
        result.subscribe(function () { return setTimeout(function () { _this._unlock("update"); }, 0); }, function (e) { return setTimeout(function () { _this._unlock("error", e); }, 0); });
    };
    /**
     * Free the lock and trigger the right events.
     * @param {string} eventName
     * @param {*} value - value sent with the given event.
     */
    AbstractSourceBuffer.prototype._unlock = function (eventName, value) {
        this.updating = false;
        this.trigger(eventName, value);
        this.trigger("updateend", undefined);
    };
    return AbstractSourceBuffer;
}(eventemitter_1.default));
exports.default = AbstractSourceBuffer;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */
function tryCatch(func, args) {
    try {
        return func(args);
    }
    catch (e) {
        return Observable_1.Observable.throw(e);
    }
}
exports.default = tryCatch;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var _1 = __webpack_require__(5);
var events_1 = __webpack_require__(15);
var errors_1 = __webpack_require__(6);
var assert_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(40);
var attach_media_keys_1 = __webpack_require__(202);
var dispose_media_keys_1 = __webpack_require__(201);
var generate_key_request_1 = __webpack_require__(200);
var get_media_keys_1 = __webpack_require__(199);
var handle_encrypted_event_1 = __webpack_require__(194);
var handle_session_events_1 = __webpack_require__(192);
var media_keys_infos_store_1 = __webpack_require__(189);
var init_data_store_1 = __webpack_require__(188);
var attachedMediaKeysInfos = new media_keys_infos_store_1.default();
/**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @returns {Observable}
 */
function clearEMESession(mediaElement) {
    return Observable_1.Observable.defer(function () {
        if (_1.shouldUnsetMediaKeys()) {
            return dispose_media_keys_1.default(mediaElement, attachedMediaKeysInfos)
                .ignoreElements();
        }
        var currentState = attachedMediaKeysInfos.getState(mediaElement);
        if (currentState && currentState.keySystemOptions.closeSessionsOnStop) {
            return currentState.sessionsStore.closeAllSessions()
                .ignoreElements();
        }
        return Observable_1.Observable.empty();
    });
}
exports.clearEMESession = clearEMESession;
/**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createEME(mediaElement, keySystemsConfigs, errorStream) {
    if (false) {}
    // Keep track of all initialization data handled here.
    // This is to avoid handling multiple times the same encrypted events.
    var handledInitData = new init_data_store_1.default();
    return Observable_1.Observable.combineLatest(events_1.onEncrypted$(mediaElement), get_media_keys_1.default(mediaElement, keySystemsConfigs, attachedMediaKeysInfos, errorStream))
        .mergeMap(function (_a, i) {
        var encryptedEvent = _a[0], mediaKeysInfos = _a[1];
        return Observable_1.Observable.merge(
        // create a new MediaKeySession if needed
        handle_encrypted_event_1.default(encryptedEvent, handledInitData, mediaKeysInfos)
            .map(function (evt) { return ({
            type: evt.type,
            value: {
                initData: evt.value.initData,
                initDataType: evt.value.initDataType,
                mediaKeySession: evt.value.mediaKeySession,
                sessionType: evt.value.sessionType,
                keySystemOptions: mediaKeysInfos.keySystemOptions,
                sessionStorage: mediaKeysInfos.sessionStorage,
            },
        }); }), 
        // attach MediaKeys if we're handling the first event
        i === 0 ?
            attach_media_keys_1.default(mediaKeysInfos, mediaElement, attachedMediaKeysInfos)
                .ignoreElements() :
            Observable_1.Observable.empty());
    })
        .mergeMap(function (handledEncryptedEvent) {
        var _a = handledEncryptedEvent.value, initData = _a.initData, initDataType = _a.initDataType, mediaKeySession = _a.mediaKeySession, sessionType = _a.sessionType, keySystemOptions = _a.keySystemOptions, sessionStorage = _a.sessionStorage;
        return Observable_1.Observable.merge(handle_session_events_1.default(mediaKeySession, keySystemOptions, errorStream), 
        // only perform generate request on new sessions
        handledEncryptedEvent.type === "created-session" ?
            generate_key_request_1.default(mediaKeySession, initData, initDataType)
                .do(function () {
                if (sessionType === "persistent-license" && sessionStorage != null) {
                    sessionStorage.add(initData, initDataType, mediaKeySession);
                }
            }) :
            Observable_1.Observable.empty()).ignoreElements();
    });
}
/**
 * Free up all ressources taken by the EME management.
 */
function disposeEME(mediaElement) {
    dispose_media_keys_1.default(mediaElement, attachedMediaKeysInfos).subscribe(noop_1.default);
}
exports.disposeEME = disposeEME;
/**
 * Returns the name of the current key system used.
 * @returns {string}
 */
function getCurrentKeySystem(mediaElement) {
    var currentState = attachedMediaKeysInfos.getState(mediaElement);
    return currentState && currentState.keySystemOptions.type;
}
exports.getCurrentKeySystem = getCurrentKeySystem;
/**
 * Perform EME management if needed.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function EMEManager(mediaElement, keySystems, errorStream) {
    if (keySystems && keySystems.length) {
        if (!_1.hasEMEAPIs()) {
            return events_1.onEncrypted$(mediaElement).map(function () {
                log_1.default.error("eme: encrypted event but no EME API available");
                throw new errors_1.EncryptedMediaError("MEDIA_IS_ENCRYPTED_ERROR", null, true);
            });
        }
        return createEME(mediaElement, keySystems, errorStream);
    }
    else {
        return events_1.onEncrypted$(mediaElement).map(function () {
            log_1.default.error("eme: ciphered media and no keySystem passed");
            throw new errors_1.EncryptedMediaError("MEDIA_IS_ENCRYPTED_ERROR", null, true);
        });
    }
}
exports.default = EMEManager;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(representation, nextSegments, currentSegment) {
    representation.index._addSegments(nextSegments, currentSegment);
}
exports.addNextSegments = addNextSegments;
/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */
function pad(n, l) {
    var nToString = n.toString();
    if (nToString.length >= l) {
        return nToString;
    }
    var arr = new Array(l + 1).join("0") + nToString;
    return arr.slice(-l);
}
exports.pad = pad;
/**
 * Add formatting when asked in a token (add padding to numbers).
 * @param {string|Number} replacer - the token value
 * @returns {Function} - @see replaceTokens
 */
function processFormatedToken(replacer) {
    return function (_match, _format, widthStr) {
        var width = widthStr ? parseInt(widthStr, 10) : 1;
        return pad("" + replacer, width);
    };
}
exports.processFormatedToken = processFormatedToken;
/**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {Object} segment
 * @param {Representation} representation
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */
function replaceTokens(path, segment, representation) {
    if (path.indexOf("$") === -1) {
        return path;
    }
    else {
        return path
            .replace(/\$\$/g, "$")
            .replace(/\$RepresentationID\$/g, String(representation.id))
            .replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(representation.bitrate))
            .replace(/\$Number(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
            if (segment.number == null) {
                throw new Error("Segment number not defined in a $Number$ scheme");
            }
            return processFormatedToken(segment.number)(_x, _y, widthStr);
        })
            .replace(/\$Time(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
            if (segment.time == null) {
                throw new Error("Segment time not defined in a $Time$ scheme");
            }
            return processFormatedToken(segment.time)(_x, _y, widthStr);
        });
    }
}
exports.replaceTokens = replaceTokens;
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
    return representation.mimeType === "application/mp4";
}
exports.isMP4EmbeddedTrack = isMP4EmbeddedTrack;
/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>}
 * @returns {string}
 */
function byteRange(_a) {
    var start = _a[0], end = _a[1];
    if (!end || end === Infinity) {
        return "bytes=" + (+start) + "-";
    }
    else {
        return "bytes=" + (+start) + "-" + (+end);
    }
}
exports.byteRange = byteRange;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var isobmff_1 = __webpack_require__(30);
var assert_1 = __webpack_require__(4);
var bytes_1 = __webpack_require__(21);
/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */
var SAMPLING_FREQUENCIES = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
];
/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */
var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
function boxName(str) {
    if (boxNamesMem[str]) {
        return boxNamesMem[str];
    }
    var nameInBytes = bytes_1.strToBytes(str);
    boxNamesMem[str] = nameInBytes;
    return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */
function Atom(name, buff) {
    if (false) {}
    var len = buff.length + 8;
    return bytes_1.concat(bytes_1.itobe4(len), boxName(name), buff);
}
/**
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */
function readUuid(buf, id1, id2, id3, id4) {
    var l = buf.length;
    var i = 0;
    var len;
    while (i < l) {
        len = bytes_1.be4toi(buf, i);
        if (bytes_1.be4toi(buf, i + 4) === 0x75756964 /* === "uuid" */ &&
            bytes_1.be4toi(buf, i + 8) === id1 &&
            bytes_1.be4toi(buf, i + 12) === id2 &&
            bytes_1.be4toi(buf, i + 16) === id3 &&
            bytes_1.be4toi(buf, i + 20) === id4) {
            return buf.subarray(i + 24, i + len);
        }
        i += len;
    }
}
var atoms = {
    /**
     * @param {string} name
     * @param {Array.<Uint8Array>} children
     * @returns {Uint8Array}
     */
    mult: function (name, children) {
        return Atom(name, bytes_1.concat.apply(null, children));
    },
    /**
     * @param {string} name - "avc1" or "encv"
     * @param {Number} drefIdx - shall be 1
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes - horizontal resolution, eg 72
     * @param {Number} vRes - horizontal resolution, eg 72
     * @param {string} encDepth
     * @param {Number} colorDepth - eg 24
     * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "encv"
     * @returns {Uint8Array}
     */
    avc1encv: function (name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
        if (false) {}
        return Atom(name, bytes_1.concat(6, // 6 bytes reserved
        bytes_1.itobe2(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes
        bytes_1.itobe2(width), // size 2 w
        bytes_1.itobe2(height), // size 2 h
        bytes_1.itobe2(hRes), 2, // reso 4 h
        bytes_1.itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
        [0, 1, encName.length], // frame count (default 1)
        bytes_1.strToBytes(encName), // 1byte len + encoder name str
        (31 - encName.length), // + padding
        bytes_1.itobe2(colorDepth), // color depth
        [0xFF, 0xFF], // reserved ones
        avcc, // avcc atom,
        name === "encv" ? sinf || [] : []));
    },
    /**
     * @param {Uint8Array} sps
     * @param {Uint8Array} pps
     * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
     * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
     * 1, "68ef3880")
     * @returns {Uint8Array}
     */
    avcc: function (sps, pps, nalLen) {
        var nal = (nalLen === 2) ?
            0x1 : (nalLen === 4) ?
            0x3 : 0x0;
        // Deduce AVC Profile from SPS
        var h264Profile = sps[1];
        var h264CompatibleProfile = sps[2];
        var h264Level = sps[3];
        return Atom("avcC", bytes_1.concat([
            1,
            h264Profile,
            h264CompatibleProfile,
            h264Level,
            (0x3F << 2 | nal),
            (0xE0 | 1),
        ], bytes_1.itobe2(sps.length), sps, [1], bytes_1.itobe2(pps.length), pps));
    },
    /**
     * @param {url} Uint8Array
     * @returns {Uint8Array}
     */
    dref: function (url) {
        // only one description here... FIXME
        return Atom("dref", bytes_1.concat(7, [1], url));
    },
    /**
     * @param {Number} stream
     * @param {string} codecPrivateData - hex string
     * eg: esds(1, 98800, "1190")
     * @returns {Uint8Array}
     */
    esds: function (stream, codecPrivateData) {
        return Atom("esds", bytes_1.concat(4, [0x03, 0x19], bytes_1.itobe2(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], bytes_1.hexToBytes(codecPrivateData), [0x06, 0x01, 0x02]));
    },
    /**
     * @param {string} dataFormat - four letters (eg "avc1")
     * @returns {Uint8Array}
     */
    frma: function (dataFormat) {
        if (false) {}
        return Atom("frma", bytes_1.strToBytes(dataFormat));
    },
    /**
     * @param {Number} length
     * @returns {Uint8Array}
     */
    free: function (length) {
        return Atom("free", new Uint8Array(length - 8));
    },
    /**
     * @param {string} majorBrand
     * @param {Array.<string>} brands
     * @returns {Uint8Array}
     */
    ftyp: function (majorBrand, brands) {
        return Atom("ftyp", bytes_1.concat.apply(null, [
            bytes_1.strToBytes(majorBrand),
            [0, 0, 0, 1],
        ].concat(brands.map(bytes_1.strToBytes))));
    },
    /**
     * @param {string} type - "video" or "audio"
     * @returns {Uint8Array}
     */
    hdlr: function (type) {
        var name;
        var handlerName;
        switch (type) {
            case "video":
                name = "vide";
                handlerName = "VideoHandler";
                break;
            case "audio":
                name = "soun";
                handlerName = "SoundHandler";
                break;
            default:
                name = "hint";
                handlerName = "";
                break;
        }
        return Atom("hdlr", bytes_1.concat(8, bytes_1.strToBytes(name), 12, bytes_1.strToBytes(handlerName), 1 // handler name is C-style string (0 terminated)
        ));
    },
    /**
     * @param {number} timescale
     * @returns {Uint8Array}
     */
    mdhd: function (timescale) {
        return Atom("mdhd", bytes_1.concat(12, bytes_1.itobe4(timescale), 8));
    },
    /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} traf
     * @returns {Uint8Array}
     */
    moof: function (mfhd, traf) {
        return atoms.mult("moof", [mfhd, traf]);
    },
    /**
     * @param {string} name - "mp4a" or "enca"
     * @param {Number} drefIdx
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {Uint8Array} esds - Uint8Array representing the esds atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "enca"
     * @returns {Uint8Array}
     */
    mp4aenca: function (name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
        if (false) {}
        return Atom(name, bytes_1.concat(6, bytes_1.itobe2(drefIdx), 8, bytes_1.itobe2(channelsCount), bytes_1.itobe2(sampleSize), 2, bytes_1.itobe2(packetSize), bytes_1.itobe2(sampleRate), 2, esds, (name === "enca") ? sinf || [] : []));
    },
    /**
     * @param {Number} timescale
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    mvhd: function (timescale, trackId) {
        return Atom("mvhd", bytes_1.concat(12, bytes_1.itobe4(timescale), 4, [0, 1], 2, // we assume rate = 1;
        [1, 0], 10, // we assume volume = 100%;
        [0, 1], 14, // default matrix
        [0, 1], 14, // default matrix
        [64, 0, 0, 0], 26, bytes_1.itobe2(trackId + 1) // next trackId (=trackId + 1);
        ));
    },
    /**
     * @param {string} systemId - Hex string representing the CDM, 16 bytes.
     * @param {Uint8Array} [privateData=[]] - Data associated to protection
     * specific system.
     * @param {[]Uint8Array} keyIds - List of key ids contained in the PSSH
     * @returns {Uint8Array}
     */
    pssh: function (systemId, privateData, keyIds) {
        if (privateData === void 0) { privateData = new Uint8Array(0); }
        if (keyIds === void 0) { keyIds = new Uint8Array(0); }
        var _systemId = systemId.replace(/-/g, "");
        assert_1.default(_systemId.length === 32, "wrong system id length");
        var version;
        var kidList;
        var kidCount = keyIds.length;
        if (kidCount > 0) {
            version = 1;
            kidList = bytes_1.concat.apply(void 0, [bytes_1.itobe4(kidCount)].concat(keyIds));
        }
        else {
            version = 0;
            kidList = [];
        }
        return Atom("pssh", bytes_1.concat([version, 0, 0, 0], bytes_1.hexToBytes(_systemId), kidList, bytes_1.itobe4(privateData.length), privateData));
    },
    /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @returns {Uint8Array}
     */
    saio: function (mfhd, tfhd, tfdt, trun) {
        return Atom("saio", bytes_1.concat(4, [0, 0, 0, 1], // ??
        bytes_1.itobe4(mfhd.length +
            tfhd.length +
            tfdt.length +
            trun.length +
            8 + 8 + 8 + 8)));
    },
    /**
     * @param {Uint8Array} sencData - including 8 bytes flags and entries count
     * @returns {Uint8Array}
     */
    saiz: function (senc) {
        if (senc.length === 0) {
            return Atom("saiz", new Uint8Array(0));
        }
        var flags = bytes_1.be4toi(senc, 0);
        var entries = bytes_1.be4toi(senc, 4);
        var arr = new Uint8Array(entries + 9);
        arr.set(bytes_1.itobe4(entries), 5);
        var i = 9;
        var j = 8;
        var pairsCnt;
        var pairsLen;
        while (j < senc.length) {
            j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
            // if we have extradata for each entry
            if ((flags & 0x2) === 0x2) {
                pairsLen = 2;
                pairsCnt = bytes_1.be2toi(senc, j);
                j += (pairsCnt * 6) + 2;
            }
            else {
                pairsCnt = 0;
                pairsLen = 0;
            }
            arr[i] = pairsCnt * 6 + 8 + pairsLen;
            i++;
        }
        return Atom("saiz", arr);
    },
    /**
     * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
     * @param {Number} schemeVersion - eg 65536
     * @returns {Uint8Array}
     */
    schm: function (schemeType, schemeVersion) {
        if (false) {}
        return Atom("schm", bytes_1.concat(4, bytes_1.strToBytes(schemeType), bytes_1.itobe4(schemeVersion)));
    },
    /**
     * @param {Uint8Array} buf
     * @returns {Uint8Array}
     */
    senc: function (buf) {
        return Atom("senc", buf);
    },
    /**
     * @returns {Uint8Array}
     */
    smhd: function () {
        return Atom("smhd", new Uint8Array(8));
    },
    /**
     * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
     * typically [avc1] or [encv, avc1]
     * @returns {Uint8Array}
     */
    stsd: function (reps) {
        // only one description here... FIXME
        var arrBase = [7, [reps.length]];
        return Atom("stsd", bytes_1.concat.apply(void 0, arrBase.concat(reps)));
    },
    /**
     * @param {Number} width
     * @param {Number} height
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    tkhd: function (width, height, trackId) {
        return Atom("tkhd", bytes_1.concat(bytes_1.itobe4(1 + 2 + 4), 8, // we assume track is enabled,
        // in media and in preview.
        bytes_1.itobe4(trackId), 20, // we assume trackId = 1;
        [1, 0, 0, 0], // we assume volume = 100%;
        [0, 1, 0, 0], 12, // default matrix
        [0, 1, 0, 0], 12, // default matrix
        [64, 0, 0, 0], // ??
        bytes_1.itobe2(width), 2, // width (TODO handle fixed)
        bytes_1.itobe2(height), 2 // height (TODO handle fixed)
        ));
    },
    /**
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    trex: function (trackId) {
        // default sample desc idx = 1
        return Atom("trex", bytes_1.concat(4, bytes_1.itobe4(trackId), [0, 0, 0, 1], 12));
    },
    /**
     * @param {Number} decodeTime
     * @returns {Uint8Array}
     */
    tfdt: function (decodeTime) {
        return Atom("tfdt", bytes_1.concat([1, 0, 0, 0], bytes_1.itobe8(decodeTime)));
    },
    /**
     * @param {Number} algId - eg 1
     * @param {Number} ivSize - eg 8
     * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
     * @returns {Uint8Array}
     */
    tenc: function (algId, ivSize, keyId) {
        if (false) {}
        return Atom("tenc", bytes_1.concat(6, [algId, ivSize], bytes_1.hexToBytes(keyId)));
    },
    /**
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @param {Uint8Array} senc
     * @param {Uint8Array} mfhd
     * @returns {Uint8Array}
     */
    traf: function (tfhd, tfdt, trun, mfhd, senc) {
        var trafs = [tfhd, tfdt, trun];
        if (senc) {
            trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun));
        }
        return atoms.mult("traf", trafs);
    },
    /**
     * @param {Uint8Array} oldtrun
     * @returns {Uint8Array}
     */
    trun: function (oldtrun) {
        var headersLast = oldtrun[11];
        var hasDataOffset = headersLast & 0x01;
        if (hasDataOffset) {
            return oldtrun;
        }
        // If no dataoffset is present, we change the headers and add one
        var trun = new Uint8Array(oldtrun.length + 4);
        trun.set(bytes_1.itobe4(oldtrun.length + 4), 0);
        trun.set(oldtrun.subarray(4, 16), 4); // name + (version + headers) +
        // samplecount
        trun[11] = trun[11] | 0x01; // add data offset header info
        trun.set([0, 0, 0, 0], 16); // data offset
        trun.set(oldtrun.subarray(16, oldtrun.length), 20);
        return trun;
    },
    /**
     * @returns {Uint8Array}
     */
    vmhd: function () {
        var arr = new Uint8Array(12);
        arr[3] = 1; // QuickTime...
        return Atom("vmhd", arr);
    },
};
var reads = {
    /**
     * Extract senc data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    senc: function (traf) {
        return readUuid(traf, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
    },
    /**
     * Extract tfxd data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    tfxd: function (traf) {
        return readUuid(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);
    },
    /**
     * Extract tfrf data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    tfrf: function (traf) {
        return readUuid(traf, 0xD4807EF2, 0XCA394695, 0X8E5426CB, 0X9E46A79F);
    },
};
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
function aacesHeader(type, frequency, chans) {
    var freq = SAMPLING_FREQUENCIES.indexOf(frequency);
    if (false) {}
    var val;
    val = (type & 0x3F) << 0x4;
    val = (val | (freq & 0x1F)) << 0x4;
    val = (val | (chans & 0x1F)) << 0x3;
    return bytes_1.bytesToHex(bytes_1.itobe2(val));
}
/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */
function moovChildren(mvhd, mvex, trak, pssList) {
    var moov = [mvhd, mvex, trak];
    pssList.forEach(function (pss) {
        var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);
        moov.push(pssh);
    });
    return moov;
}
/**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Number} trunoffset
 * @param {Number} dataoffset
 */
function patchTrunDataOffset(segment, trunoffset, dataOffset) {
    // patch trun dataoffset with new moof atom size
    segment.set(bytes_1.itobe4(dataOffset), trunoffset + 16);
}
/**
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */
function createNewSegment(segment, newmoof, oldmoof, trunoffset) {
    var segmentlen = segment.length;
    var newmooflen = newmoof.length;
    var oldmooflen = oldmoof.length;
    var mdat = segment.subarray(oldmooflen, segmentlen);
    var newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));
    newSegment.set(newmoof, 0);
    newSegment.set(mdat, newmooflen);
    patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8);
    return newSegment;
}
/**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */
function patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {
    var free = oldmoof.length - newmoof.length;
    segment.set(newmoof, 0);
    segment.set(atoms.free(free), newmoof.length);
    patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free);
    return segment;
}
/**
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
    var stbl = atoms.mult("stbl", [
        stsd,
        Atom("stts", new Uint8Array(0x08)),
        Atom("stsc", new Uint8Array(0x08)),
        Atom("stsz", new Uint8Array(0x0c)),
        Atom("stco", new Uint8Array(0x08)),
    ]);
    var url = Atom("url ", new Uint8Array([0, 0, 0, 1]));
    var dref = atoms.dref(url);
    var dinf = atoms.mult("dinf", [dref]);
    var minf = atoms.mult("minf", [mhd, dinf, stbl]);
    var hdlr = atoms.hdlr(type);
    var mdhd = atoms.mdhd(timescale); // this one is really important
    var mdia = atoms.mult("mdia", [mdhd, hdlr, minf]);
    var tkhd = atoms.tkhd(width, height, 1);
    var trak = atoms.mult("trak", [tkhd, mdia]);
    var trex = atoms.trex(1);
    var mvex = atoms.mult("mvex", [trex]);
    var mvhd = atoms.mvhd(timescale, 1); // in fact, we don't give a sh** about
    // this value :O
    var moov = atoms.mult("moov", moovChildren(mvhd, mvex, trak, pssList));
    var ftyp = atoms.ftyp("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
    return bytes_1.concat(ftyp, moov);
}
// TODO
exports.default = {
    getMdat: isobmff_1.getMDAT,
    getTraf: isobmff_1.getTRAF,
    /**
     * @param {Uint8Array} traf
     * @returns {Array.<Object>}
     */
    parseTfrf: function (traf) {
        var tfrf = reads.tfrf(traf);
        if (!tfrf) {
            return [];
        }
        var frags = [];
        var version = tfrf[0];
        var fragCount = tfrf[4];
        for (var i = 0; i < fragCount; i++) {
            var duration = void 0;
            var time = void 0;
            if (version === 1) {
                time = bytes_1.be8toi(tfrf, i * 16 + 5);
                duration = bytes_1.be8toi(tfrf, i * 16 + 5 + 8);
            }
            else {
                time = bytes_1.be4toi(tfrf, i * 8 + 5);
                duration = bytes_1.be4toi(tfrf, i * 8 + 5 + 4);
            }
            frags.push({
                time: time,
                duration: duration,
            });
        }
        return frags;
    },
    /**
     * @param {Uint8Array} traf
     * @returns {Object|undefined}
     */
    parseTfxd: function (traf) {
        var tfxd = reads.tfxd(traf);
        if (tfxd) {
            return {
                duration: bytes_1.be8toi(tfxd, 12),
                time: bytes_1.be8toi(tfxd, 4),
            };
        }
    },
    /**
     * Return full video Init segment as Uint8Array
     * @param {Number} timescale - lowest number, this one will be set into mdhd
     * *10000 in mvhd, e.g. 1000
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes
     * @param {Number} vRes
     * @param {Number} nalLength (1, 2 or 4)
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id,
     * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
     * @returns {Uint8Array}
     */
    createVideoInitSegment: function (timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
        var _pssList = pssList || [];
        var _a = codecPrivateData.split("00000001"), spsHex = _a[1], ppsHex = _a[2];
        var sps = bytes_1.hexToBytes(spsHex);
        var pps = bytes_1.hexToBytes(ppsHex);
        // TODO NAL length is forced to 4
        var avcc = atoms.avcc(sps, pps, nalLength);
        var stsd;
        if (!_pssList.length || keyId == null) {
            var avc1 = atoms.avc1encv("avc1", // name
            1, // drefIdx
            width, height, hRes, vRes, "AVC Coding", // encName
            24, // color depth
            avcc);
            stsd = atoms.stsd([avc1]);
        }
        else {
            var tenc = atoms.tenc(1, 8, keyId);
            var schi = atoms.mult("schi", [tenc]);
            var schm = atoms.schm("cenc", 65536);
            var frma = atoms.frma("avc1");
            var sinf = atoms.mult("sinf", [frma, schm, schi]);
            var encv = atoms.avc1encv("encv", 1, width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
            stsd = atoms.stsd([encv]);
        }
        return createInitSegment(timescale, "video", stsd, atoms.vmhd(), width, height, _pssList);
    },
    /**
     * Return full audio Init segment as Uint8Array
     * @param {Number} timescale
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id, 32 chars.
     * eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF"}
     * @returns {Uint8Array}
     */
    createAudioInitSegment: function (timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
        var _pssList = pssList || [];
        var _codecPrivateData = codecPrivateData || aacesHeader(2, sampleRate, channelsCount);
        var esds = atoms.esds(1, _codecPrivateData);
        var stsd;
        if (!_pssList.length || keyId == null) {
            var mp4a = atoms.mp4aenca("mp4a", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);
            stsd = atoms.stsd([mp4a]);
        }
        else {
            var tenc = atoms.tenc(1, 8, keyId);
            var schi = atoms.mult("schi", [tenc]);
            var schm = atoms.schm("cenc", 65536);
            var frma = atoms.frma("mp4a");
            var sinf = atoms.mult("sinf", [frma, schm, schi]);
            var enca = atoms.mp4aenca("enca", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
            stsd = atoms.stsd([enca]);
        }
        return createInitSegment(timescale, "audio", stsd, atoms.smhd(), 0, 0, _pssList);
    },
    /**
     * Add decodeTime info in a segment (tfdt box)
     * @param {Uint8Array} segment
     * @param {Number} decodeTime
     * @return {Uint8Array}
     */
    patchSegment: function (segment, decodeTime) {
        if (false) { var name_1; }
        var oldmoof = segment.subarray(0, bytes_1.be4toi(segment, 0));
        var newtfdt = atoms.tfdt(decodeTime);
        // reads [moof[mfhd|traf[tfhd|trun|..]]]
        var tfdtlen = newtfdt.length;
        var mfhdlen = bytes_1.be4toi(oldmoof, 8);
        var traflen = bytes_1.be4toi(oldmoof, mfhdlen + 8);
        var tfhdlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8);
        var trunlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8 + tfhdlen);
        var oldmfhd = oldmoof.subarray(8, mfhdlen + 8);
        var oldtraf = oldmoof
            .subarray(mfhdlen + 8 + 8, mfhdlen + 8 + 8 + traflen - 8);
        var oldtfhd = oldtraf.subarray(0, tfhdlen);
        var oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);
        // force trackId=1 since trackIds are not always reliable...
        oldtfhd.set([0, 0, 0, 1], 12);
        // TODO fallback?
        var oldsenc = reads.senc(oldtraf);
        // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]
        var newtrun = atoms.trun(oldtrun);
        var newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldmfhd, oldsenc);
        var newmoof = atoms.moof(oldmfhd, newtraf);
        var trunoffset = mfhdlen + 8 + 8 + tfhdlen + tfdtlen;
        // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
        // try to put free atom inside traf children
        if (compat_1.isIE) {
            return createNewSegment(segment, newmoof, oldmoof, trunoffset);
        }
        else {
            if (oldmoof.length - newmoof.length >= 8 /* minimum "free" atom size */) {
                return patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset);
            }
            else {
                return createNewSegment(segment, newmoof, oldmoof, trunoffset);
            }
        }
    },
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function toWallClockTime(position, manifest) {
    return new Date((position + (manifest.availabilityStartTime || 0)) * 1000);
}
exports.toWallClockTime = toWallClockTime;
/**
 * TODO This function should have more of a seekTo kind of name
 * ``fromWallClockTime`` should probably just do:
 * ```js
 * (timeInSeconds, manifest) => {
 *   return timeInSeconds - manifest.availabilityStartTime;
 * };
 * ```
 * It should be the exact opposite of ``toWallClockTime``
 */
function fromWallClockTime(timeInMs, manifest) {
    return normalizeWallClockTime(timeInMs, manifest) / 1000
        - (manifest.availabilityStartTime || 0);
}
exports.fromWallClockTime = fromWallClockTime;
/**
 * TODO This function should have more of a seekTo kind of name
 */
function normalizeWallClockTime(_time, manifest) {
    if (!manifest.isLive) {
        return +_time;
    }
    var spd = manifest.suggestedPresentationDelay || 0;
    var plg = manifest.presentationLiveGap || 0;
    var tsbd = manifest.timeShiftBufferDepth || 0;
    var timeInMs = typeof _time === "number" ?
        _time : +_time;
    var now = Date.now();
    var max = now - (plg + spd) * 1000;
    var min = now - (tsbd) * 1000;
    return Math.max(Math.min(timeInMs, max), min);
}
function getMinimumBufferPosition(manifest) {
    // we have to know both the min and the max to be sure
    var min = getBufferLimits(manifest)[0];
    return min;
}
exports.getMinimumBufferPosition = getMinimumBufferPosition;
/**
 * Get maximum position to which we should be able to construct a buffer.
 * @param {Manifest} manifest
 * @returns {Number}
 */
function getMaximumBufferPosition(manifest) {
    if (!manifest.isLive) {
        return manifest.getDuration();
    }
    var ast = manifest.availabilityStartTime || 0;
    var plg = manifest.presentationLiveGap || 0;
    var now = Date.now() / 1000;
    return now - ast - plg;
}
exports.getMaximumBufferPosition = getMaximumBufferPosition;
function getBufferLimits(manifest) {
    // TODO use RTT for the manifest request + 3 or something
    var BUFFER_DEPTH_SECURITY = 5;
    if (!manifest.isLive) {
        return [manifest.minimumTime || 0, manifest.getDuration()];
    }
    var ast = manifest.availabilityStartTime || 0;
    var plg = manifest.presentationLiveGap || 0;
    var tsbd = manifest.timeShiftBufferDepth || 0;
    var now = Date.now() / 1000;
    var max = now - ast - plg;
    return [
        Math.min(max, Math.max(manifest.minimumTime != null ? manifest.minimumTime : 0, max - tsbd + BUFFER_DEPTH_SECURITY)),
        max,
    ];
}
exports.getBufferLimits = getBufferLimits;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Simple hash-based set.
 * @class SimpleSet
 */
var SimpleSet = /** @class */ (function () {
    function SimpleSet() {
        this._hashes = {};
    }
    /**
     * Add a new hash entry in the set.
     * Do not have any effect on already-added hashes
     * @param {string|number}
     */
    SimpleSet.prototype.add = function (x) {
        this._hashes[x] = true;
    };
    /**
     * Remove an hash entry from the set.
     * Do not have any effect on already-removed or inexistant hashes
     * @param {string|number}
     */
    SimpleSet.prototype.remove = function (x) {
        delete this._hashes[x];
    };
    /**
     * Test if the given hash has an entry in the set.
     * @param {string|number}
     * @returns {boolean}
     */
    SimpleSet.prototype.test = function (x) {
        return !!this._hashes[x];
    };
    /**
     * Returns true if there's currently no hash in this set.
     * @returns {boolean}
     */
    SimpleSet.prototype.isEmpty = function () {
        return !Object.keys(this._hashes).length;
    };
    return SimpleSet;
}());
exports.default = SimpleSet;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(32);
var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
exports.BROWSER_PREFIXES = BROWSER_PREFIXES;
var win = window;
var HTMLElement_ = win.HTMLElement;
exports.HTMLElement_ = HTMLElement_;
var VTTCue_ = win.VTTCue || win.TextTrackCue;
exports.VTTCue_ = VTTCue_;
var MediaSource_ = (win.MediaSource ||
    win.MozMediaSource ||
    win.WebKitMediaSource ||
    win.MSMediaSource);
exports.MediaSource_ = MediaSource_;
var MediaKeys_ = (win.MediaKeys ||
    win.MozMediaKeys ||
    win.WebKitMediaKeys ||
    win.MSMediaKeys);
exports.MediaKeys_ = MediaKeys_;
if (!MediaKeys_) {
    var noMediaKeys_1 = function () {
        throw new MediaError_1.default("MEDIA_KEYS_NOT_SUPPORTED", null, true);
    };
    exports.MediaKeys_ = MediaKeys_ = /** @class */ (function () {
        function class_1() {
            this.create = noMediaKeys_1;
            this.createSession = noMediaKeys_1;
            this.isTypeSupported = noMediaKeys_1;
            this.setServerCertificate = noMediaKeys_1;
        }
        return class_1;
    }());
}
// true for IE / Edge
var isIE = (navigator.appName === "Microsoft Internet Explorer" ||
    navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent));
exports.isIE = isIE;
var isFirefox = (navigator.userAgent.toLowerCase().indexOf("firefox") !== -1);
exports.isFirefox = isFirefox;
var READY_STATES = {
    HAVE_NOTHING: 0,
    HAVE_METADATA: 1,
    HAVE_CURRENT_DATA: 2,
    HAVE_FUTURE_DATA: 3,
    HAVE_ENOUGH_DATA: 4,
};
exports.READY_STATES = READY_STATES;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var eventemitter_1 = __webpack_require__(33);
/**
 * Returns a fromEvent on the given element for the given event(s).
 * @param {Element|Document|Window}
 * @param {Array.<string>|string}
 * @returns {Observable}
 */
function onEvent(elt, evts) {
    if (Array.isArray(evts)) {
        var eventsArray = evts.map(function (evt) { return onEvent(elt, evt); });
        return Observable_1.Observable.merge.apply(Observable_1.Observable, eventsArray);
    }
    else if (elt instanceof eventemitter_1.default) {
        return Observable_1.Observable.create(function (obs) {
            var listener = function (payload) {
                obs.next(payload);
            };
            elt.addEventListener(evts, listener);
            return function () {
                elt.removeEventListener(evts, listener);
            };
        });
    }
    else {
        return Observable_1.Observable.fromEvent(elt, evts);
    }
}
exports.default = onEvent;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ConnectableObservable_1 = __webpack_require__(293);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = __webpack_require__(10);
var OuterSubscriber_1 = __webpack_require__(11);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
    };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(18);
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(18);
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;
//# sourceMappingURL=observable.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(18);
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(43);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file declares constants useful for every API files.
 */
/**
 * Player state dictionnary
 * @type {Object}
 */
exports.PLAYER_STATES = {
    STOPPED: "STOPPED",
    LOADED: "LOADED",
    LOADING: "LOADING",
    PLAYING: "PLAYING",
    PAUSED: "PAUSED",
    ENDED: "ENDED",
    BUFFERING: "BUFFERING",
    SEEKING: "SEEKING",
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
/**
 * Set the initial time given as soon as possible on the video element.
 * Emit "null" when done.
 * @param {HMTLMediaElement} videoElement
 * @param {number|Function} startTime
 * @returns {Observable}
 */
function doInitialSeek(videoElement, startTime) {
    return compat_1.hasLoadedMetadata(videoElement)
        .do(function () {
        log_1.default.info("set initial time", startTime);
        // reset playbackRate to 1 in case we were at 0 (from a stalled
        // retry for instance)
        videoElement.playbackRate = 1;
        videoElement.currentTime = typeof startTime === "function" ?
            startTime() : startTime;
    })
        .share();
}
/**
 * @param {HTMLMediaElement} videoElement
 * @param {boolean} autoPlay
 * @returns {Observable}
 */
function handleCanPlay(videoElement, autoPlay) {
    return compat_1.canPlay(videoElement)
        .do(function () {
        log_1.default.info("canplay event");
        if (autoPlay) {
            /* tslint:disable no-floating-promises */
            videoElement.play();
            /* tslint:enable no-floating-promises */
        }
    })
        .share();
}
/**
 * @param {HTMLMediaElement} videoElement
 * @param {number|Function} startTime
 * @param {boolean} autoPlay
 * @returns {object}
 */
function handleVideoEvents(videoElement, startTime, autoPlay) {
    var initialSeek$ = doInitialSeek(videoElement, startTime);
    var hasHandledCanPlay$ = handleCanPlay(videoElement, autoPlay);
    var loadAndPlay$ = Observable_1.Observable
        .combineLatest(initialSeek$, hasHandledCanPlay$)
        .take(1)
        .mapTo(undefined);
    return {
        initialSeek$: initialSeek$,
        loadAndPlay$: loadAndPlay$,
    };
}
exports.default = handleVideoEvents;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(16);
var DISCONTINUITY_THRESHOLD = config_1.default.DISCONTINUITY_THRESHOLD;
/**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} videoElement
 * @param {Observable} timings$
 * @returns {Observable}
 */
function StallingManager(videoElement, timings$) {
    return timings$
        .do(function (timing) {
        if (!timing.stalled) {
            return;
        }
        // Perform various checks to try to get out of the stalled state:
        //   1. is it a browser bug? -> force seek at the same current time
        //   2. is it a short discontinuity? -> Seek at the beginning of the
        //                                      next range
        var buffered = timing.buffered, currentTime = timing.currentTime;
        var nextRangeGap = ranges_1.getNextRangeGap(buffered, currentTime);
        // Discontinuity check in case we are close a buffer but still
        // calculate a stalled state. This is useful for some
        // implementation that might drop an injected segment, or in
        // case of small discontinuity in the stream.
        if (compat_1.isPlaybackStuck(timing.currentTime, timing.currentRange, timing.state, !!timing.stalled)) {
            log_1.default.warn("after freeze seek", currentTime, timing.currentRange);
            videoElement.currentTime = currentTime;
        }
        else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
            var seekTo = (currentTime + nextRangeGap + 1 / 60);
            log_1.default.warn("discontinuity seek", currentTime, nextRangeGap, seekTo);
            videoElement.currentTime = seekTo;
        }
    })
        .share()
        .map(function (timing) { return timing.stalled; })
        .distinctUntilChanged(function (wasStalled, isStalled) {
        return !wasStalled && !isStalled ||
            (!!wasStalled && !!isStalled && wasStalled.reason === isStalled.reason);
    });
}
exports.default = StallingManager;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} videoElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$
 * @param {Object} options
 * @param {Boolean} [options.pauseWhenStalled=true] - true if the player
 * stalling should lead to a pause until it un-stalls.
 * @returns {Observable}
 */
var speedManager = function (videoElement, speed$, clock$, _a) {
    var _b = _a.pauseWhenStalled, pauseWhenStalled = _b === void 0 ? true : _b;
    var forcePause$;
    if (!pauseWhenStalled) {
        forcePause$ = Observable_1.Observable.of(false);
    }
    else {
        forcePause$ = clock$
            .pairwise()
            .map(function (_a) {
            var prevTiming = _a[0], timing = _a[1];
            var isStalled = timing.stalled;
            var wasStalled = prevTiming.stalled;
            if (!wasStalled !== !isStalled || // xor
                (wasStalled && isStalled && wasStalled.reason !== isStalled.reason)) {
                return !wasStalled;
            }
        })
            .filter(function (val) { return val != null; })
            // TODO2smart4TypeScript. Find better solution eventually
            .startWith(false);
    }
    return forcePause$
        .switchMap(function (shouldForcePause) {
        if (shouldForcePause) {
            return Observable_1.Observable.defer(function () {
                log_1.default.info("pause playback to build buffer");
                videoElement.playbackRate = 0;
                return Observable_1.Observable.of(0);
            });
        }
        return speed$
            .do(function (speed) {
            log_1.default.info("resume playback speed", speed);
            videoElement.playbackRate = speed;
        });
    });
};
exports.default = speedManager;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(32);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(56);
/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the videoElement.
 * @see MediaError
 * @returns {Observable}
 */
function createMediaErrorHandler(videoElement) {
    return rx_onEvent_1.default(videoElement, "error").mergeMap(function () {
        var errorCode = videoElement.error && videoElement.error.code;
        var errorDetail;
        switch (errorCode) {
            case 1:
                errorDetail = "MEDIA_ERR_ABORTED";
                break;
            case 2:
                errorDetail = "MEDIA_ERR_NETWORK";
                break;
            case 3:
                errorDetail = "MEDIA_ERR_DECODE";
                break;
            case 4:
                errorDetail = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                break;
            default:
                errorDetail = "MEDIA_ERR_UNKNOWN";
                break;
        }
        log_1.default.error("stream: video element MEDIA_ERR(" + errorDetail + ")");
        throw new MediaError_1.default(errorDetail, null, true);
    });
}
exports.default = createMediaErrorHandler;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
function getFirstLineAfterHeader(linified) {
    var i = 0;
    while (i < linified.length) {
        if (linified[i] === "") {
            return i + 1;
        }
        i++;
    }
    return i;
}
exports.getFirstLineAfterHeader = getFirstLineAfterHeader;
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfStyleBlock(lines, index) {
    return !!lines[index] && /^STYLE( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "STYLe". Check that we have no timings
        // on the second line
        (!lines[index + 1] || lines[index + 1].indexOf("-->") < 0);
}
exports.isStartOfStyleBlock = isStartOfStyleBlock;
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfNoteBlock(lines, index) {
    return !!lines[index] && /^NOTE( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "NOTE". Check that we have no timings
        // on the second line
        (!lines[index + 1] || lines[index + 1].indexOf("-->") < 0);
}
exports.isStartOfNoteBlock = isStartOfNoteBlock;
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfRegionBlock(lines, index) {
    return !!lines[index] && /^REGION( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "REGION". Check that we have no timings
        // on the second line
        (!lines[index + 1] || lines[index + 1].indexOf("-->") < 0);
}
exports.isStartOfRegionBlock = isStartOfRegionBlock;
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */
function isStartOfCueBlock(lines, index) {
    // checked cases:
    //   - empty lines
    //   - start of a comment
    //   - start of a region
    //   - start of a style
    // Anything else whose first or second line is a timestamp line is a cue.
    var firstLine = lines[index];
    if (!firstLine ||
        isStartOfStyleBlock(lines, index) ||
        isStartOfRegionBlock(lines, index) ||
        isStartOfNoteBlock(lines, index)) {
        return false;
    }
    if (firstLine.indexOf("-->") >= 0) {
        return true;
    }
    var secondLine = lines[index + 1];
    return !!secondLine && secondLine.indexOf("-->") >= 0;
}
exports.isStartOfCueBlock = isStartOfCueBlock;
/**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */
function findEndOfCueBlock(linified, startOfCueBlock) {
    var firstEmptyLineIndex = startOfCueBlock + 1;
    // continue incrementing i until either:
    //   - empty line
    //   - end
    while (linified[firstEmptyLineIndex]) {
        firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
}
exports.findEndOfCueBlock = findEndOfCueBlock;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":");
    if (splittedTS[2]) {
        var hours = parseInt(splittedTS[0], 10);
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[2].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}
exports.default = parseTimestamp;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */
function findEndOfCueBlock(linified, startIndex) {
    var firstEmptyLineIndex = startIndex + 1;
    // continue incrementing i until either:
    //   - an empty line
    //   - the end
    while (linified[firstEmptyLineIndex]) {
        firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
}
exports.default = findEndOfCueBlock;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var time_parsing_1 = __webpack_require__(146);
/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
function getTimeDelimiters(element, ttParams) {
    var beginAttr = element.getAttribute("begin");
    var durationAttr = element.getAttribute("dur");
    var endAttr = element.getAttribute("end");
    var start = beginAttr ? time_parsing_1.default(beginAttr, ttParams) : null;
    var duration = durationAttr ? time_parsing_1.default(durationAttr, ttParams) : null;
    var parsedEnd = endAttr ? time_parsing_1.default(endAttr, ttParams) : null;
    if (start == null || (parsedEnd == null && duration == null)) {
        throw new Error("Invalid text cue");
    }
    // TODO Huh? Is TypeScript that dumb here?
    var end = parsedEnd == null ?
        start + duration : parsedEnd;
    return { start: start, end: end };
}
exports.default = getTimeDelimiters;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
    return tt.getElementsByTagName("body")[0];
}
exports.getBodyNode = getBodyNode;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getStyleNodes(tt) {
    return tt.getElementsByTagName("style");
}
exports.getStyleNodes = getStyleNodes;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getRegionNodes(tt) {
    return tt.getElementsByTagName("region");
}
exports.getRegionNodes = getRegionNodes;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getTextNodes(tt) {
    return tt.getElementsByTagName("p");
}
exports.getTextNodes = getTextNodes;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns global parameters from a TTML Document
 * TODO Missing parameters.
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object} params
 * @returns {Number} params.frameRate
 * @returns {Number} params.subFrameRate
 * @returns {Number} params.tickRate
 * @returns {string} params.spaceStyle
 */
function getParameters(tt) {
    var parsedFrameRate = tt.getAttribute("ttp:frameRate");
    var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
    var parsedTickRate = tt.getAttribute("ttp:tickRate");
    var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
    var parsedSpaceStyle = tt.getAttribute("xml:space");
    if (parsedSpaceStyle && parsedSpaceStyle !== "default" &&
        parsedSpaceStyle !== "preserve") {
        throw new Error("Invalid spacing style");
    }
    var nbFrameRate = Number(parsedFrameRate) || 30;
    var nbSubFrameRate = Number(parsedSubFrameRate) || 1;
    var nbTickRate = Number(parsedTickRate) || 0;
    var tickRate = nbTickRate;
    var frameRate = nbFrameRate;
    var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
    // TypeScript too dumdum here :/
    var spaceStyle = (parsedSpaceStyle || "default");
    if (nbTickRate === 0) {
        tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1;
    }
    if (parsedFrameRateMultiplier) {
        var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
        if (multiplierResults) {
            var numerator = Number(multiplierResults[1]);
            var denominator = Number(multiplierResults[2]);
            var multiplierNum = numerator / denominator;
            frameRate = nbFrameRate * multiplierNum;
        }
    }
    return {
        tickRate: tickRate,
        frameRate: frameRate,
        subFrameRate: subFrameRate,
        spaceStyle: spaceStyle,
    };
}
exports.default = getParameters;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var config_1 = __webpack_require__(2);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
var rx_tryCatch_1 = __webpack_require__(49);
var backoff_1 = __webpack_require__(163);
var MAX_BACKOFF_DELAY_BASE = config_1.default.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config_1.default.INITIAL_BACKOFF_DELAY_BASE;
/**
 * Generate a new error from the infos given.
 * Also attach the pipeline type (audio/manifest...) to the _pipelineType_
 * property of the returned error.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} [fatal=true] - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */
function errorSelector(code, error, fatal) {
    if (fatal === void 0) { fatal = true; }
    if (!errors_1.isKnownError(error)) {
        if (error instanceof errors_1.RequestError) {
            return new errors_1.NetworkError(code, error, fatal);
        }
        return new errors_1.OtherError(code, error, fatal);
    }
    return error;
}
/**
 * TODO All that any casting is ugly
 *
 * Returns function allowing to download the wanted transport object through
 * the resolver -> loader -> parser pipeline.
 *
 * (A transport object can be for example: the manifest, audio and video
 * segments, text, images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This one emit the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This one contains informations about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "error").
 *     With the error as a value.
 *
 *   - Lastly, with the obtained data (type "data" or "cache).
 *
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * @param {Object} transportObject
 * @param {Object} options
 * @returns {Function}
 *
 * Type parameters:
 *   T: Argument given to the Net's loader
 *   U: ResponseType of the request
 *   V: Response given by the Net's parser
 */
function createPipeline(transportPipeline, options) {
    var cache = options.cache, maxRetry = options.maxRetry, maxRetryOffline = options.maxRetryOffline;
    var loader = transportPipeline.loader, parser = transportPipeline.parser;
    // TODO Remove the resolver completely
    var resolver = transportPipeline.resolver != null ?
        transportPipeline.resolver : Observable_1.Observable.of.bind(Observable_1.Observable);
    /**
     * Subject that will emit non-fatal errors.
     */
    var retryErrorSubject = new Subject_1.Subject();
    /**
     * Backoff options given to the backoff retry done with the loader function.
     * @see retryWithBackoff
     */
    var backoffOptions = {
        baseDelay: INITIAL_BACKOFF_DELAY_BASE,
        maxDelay: MAX_BACKOFF_DELAY_BASE,
        maxRetryRegular: maxRetry,
        maxRetryOffline: maxRetryOffline,
        onRetry: function (error) {
            retryErrorSubject
                .next(errorSelector("PIPELINE_LOAD_ERROR", error, false));
        },
    };
    /**
     * Call the transport's resolver - if it exists - with the given data.
     *
     * Throws with the right error if it fails.
     * @param {Object} resolverArgument
     * @returns {Observable}
     */
    function callResolver(resolverArgument) {
        return rx_tryCatch_1.default(resolver, resolverArgument)
            .catch(function (error) {
            throw errorSelector("PIPELINE_RESOLVE_ERROR", error);
        });
    }
    /**
     * Load wanted data:
     *   - get it from cache if present
     *   - call the transport loader - with an exponential backoff - if not
     *
     * @param {Object} loaderArgument - Input given to the loader
     */
    function loadData(loaderArgument) {
        /**
         * Call the Pipeline's loader with an exponential Backoff.
         * @returns {Observable}
         */
        function startLoaderWithBackoff() {
            var request$ = backoff_1.default(rx_tryCatch_1.default(loader, loaderArgument), backoffOptions)
                .catch(function (error) {
                throw errorSelector("PIPELINE_LOAD_ERROR", error);
            })
                .do(function (arg) {
                if (arg.type === "response" && cache) {
                    cache.add(loaderArgument, arg.value);
                }
            });
            return Observable_1.Observable.of({
                type: "request",
                value: loaderArgument,
            }).concat(request$);
        }
        var dataFromCache = cache ? cache.get(loaderArgument) : null;
        if (dataFromCache != null) {
            return castToObservable_1.default(dataFromCache)
                .map(function (response) {
                return {
                    type: "cache",
                    value: response,
                };
            })
                .catch(startLoaderWithBackoff);
        }
        return startLoaderWithBackoff();
    }
    /**
     * Call the transport's parser with the given data.
     *
     * Throws with the right error if it fails.
     * @param {Object} parserArgument
     * @returns {Observable}
     */
    function callParser(parserArgument) {
        return rx_tryCatch_1.default(parser, parserArgument)
            .catch(function (error) {
            throw errorSelector("PIPELINE_PARSING_ERROR", error);
        });
    }
    return function startPipeline(pipelineInputData) {
        var pipeline$ = callResolver(pipelineInputData)
            .mergeMap(function (resolverResponse) {
            return loadData(resolverResponse)
                .mergeMap(function (arg) {
                // "cache": data taken from cache by the pipeline
                // "data": the data is available but no request has been done
                // "response": data received through a request
                switch (arg.type) {
                    case "cache":
                    case "data":
                    case "response":
                        var loaderResponse = arg.value;
                        var loadedDataInfos_1 = objectAssign({ response: loaderResponse }, resolverResponse);
                        // add metrics if a request was made
                        var metrics = arg.type === "response" ?
                            Observable_1.Observable.of({
                                type: "metrics",
                                value: {
                                    size: arg.value.size,
                                    duration: arg.value.duration,
                                },
                            }) : Observable_1.Observable.empty();
                        return metrics
                            .concat(callParser(loadedDataInfos_1)
                            .map(function (parserResponse) {
                            return {
                                type: "data",
                                value: objectAssign({
                                    parsed: parserResponse,
                                }, loadedDataInfos_1),
                            };
                        }));
                    default:
                        return Observable_1.Observable.of(arg);
                }
            });
        })
            .finally(function () { retryErrorSubject.complete(); });
        var retryError$ = retryErrorSubject
            .map(function (error) { return ({
            type: "error",
            value: error,
        }); });
        return Observable_1.Observable.merge(pipeline$, retryError$);
    };
}
exports.default = createPipeline;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var static_1 = __webpack_require__(164);
exports.StaticRepresentationIndex = static_1.default;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var id_1 = __webpack_require__(19);
/**
 * Normalized Representation structure.
 * @class Representation
 */
var Representation = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} [args={}]
     * @param {string|Number} [args.id]
     * @param {Number} args.bitrate
     * @param {string} args.codecs
     * @param {Number} args.height
     * @param {Number} args.width
     * @param {string} args.mimeType
     * @param {Object} args.index
     */
    function Representation(args) {
        var nId = id_1.default();
        this.id = (args.id == null ? nId : args.id);
        this.bitrate = args.bitrate;
        this.codec = args.codecs;
        if (args.height != null) {
            this.height = args.height;
        }
        if (args.width != null) {
            this.width = args.width;
        }
        if (args.mimeType != null) {
            this.mimeType = args.mimeType;
        }
        this.index = args.index;
        this.baseURL = args.baseURL;
    }
    Representation.prototype.getMimeTypeString = function () {
        return this.mimeType + ";codecs=\"" + this.codec + "\"";
    };
    return Representation;
}());
exports.default = Representation;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var objectAssign = __webpack_require__(8);
var id_1 = __webpack_require__(19);
var representation_1 = __webpack_require__(80);
/**
 * Normalized Adaptation structure.
 * @class Adaptation
 */
var Adaptation = /** @class */ (function () {
    /**
     * @constructor
     */
    function Adaptation(args) {
        var _this = this;
        var nId = id_1.default();
        this.id = args.id == null ? nId : "" + args.id;
        this.type = args.type;
        this.representations = Array.isArray(args.representations) ?
            args.representations
                .map(function (r) { return new representation_1.default(objectAssign({ rootId: _this.id }, r)); })
                .sort(function (a, b) { return a.bitrate - b.bitrate; }) : [];
        if (args.language != null) {
            this.language = args.language;
        }
        if (args.normalizedLanguage != null) {
            this.normalizedLanguage = args.normalizedLanguage;
        }
        if (args.closedCaption != null) {
            this.isClosedCaption = args.closedCaption;
        }
        if (args.audioDescription != null) {
            this.isAudioDescription = args.audioDescription;
        }
        // TODO move to DASH's Segment private infos
        if (args.contentProtection != null) {
            this.contentProtection = args.contentProtection;
        }
        // for manuallyAdded adaptations (not in the manifest)
        this.manuallyAdded = !!args.manuallyAdded;
    }
    /**
     * @returns {Array.<Number>}
     */
    Adaptation.prototype.getAvailableBitrates = function () {
        return this.representations
            .map(function (r) { return r.bitrate; });
    };
    /**
     * @param {Number|string} wantedId
     * @returns {Representation}
     */
    Adaptation.prototype.getRepresentation = function (wantedId) {
        return arrayFind(this.representations, function (_a) {
            var id = _a.id;
            return wantedId === id;
        });
    };
    /**
     * @param {Number} bitrate
     * @returns {Representations[]|null}
     */
    Adaptation.prototype.getRepresentationsForBitrate = function (bitrate) {
        return this.representations.filter(function (r) { return r.bitrate === bitrate; }) || null;
    };
    return Adaptation;
}());
exports.default = Adaptation;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var log_1 = __webpack_require__(1);
var create_fake_buffer_1 = __webpack_require__(178);
exports.createFakeBuffer = create_fake_buffer_1.default;
var representation_buffer_1 = __webpack_require__(177);
/**
 * Create Buffers linked to an Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * @example
 * ```js
 * const bufferManager = new AdaptationBufferManager(
 *   abrManager,
 *   abrClock$
 * );
 *
 * const buffer$ = bufferManager.createBuffer(
 *  bufferClock$,
 *  queuedSourceBuffer,
 *  segmentBookkeeper,
 *  segmentFetcher,
 *  wantedBufferAhead$,
 *  { manifest, period, adaptation},
 * );
 * ```
 * @class AdaptationBufferManager
 */
var AdaptationBufferManager = /** @class */ (function () {
    /**
     * @param {ABRManager} abrManager
     * @param {Observable} abrBaseClock$ - Clock at which the ABR manager will
     * estimate the right Representation to play.
     */
    function AdaptationBufferManager(abrManager, abrBaseClock$) {
        this._abrManager = abrManager;
        this._abrBaseClock$ = abrBaseClock$;
    }
    /**
     * Create new Buffer Observable linked to the given Adaptation.
     *
     * This Buffer will download and push segments from a single Adaptation,
     * linked to a single Period.
     * It will emit various events to report its status to the caller.
     *
     * @param {Observable} bufferClock$ - Clock at which the Buffer will check
     * for segments download
     * @param {QueuedSourceBuffer} queuedSourceBuffer - QueuedSourceBuffer used
     * to push segments and know about the current real buffer's health.
     * @param {SegmentBookkeeper} segmentBookkeeper - Used to synchronize and
     * retrieve the Segments currently present in the QueuedSourceBuffer
     * @param {Function} segmentFetcher - Function used to download segments
     * @param {Observable} wantedBufferAhead$ - Emits the buffer goal
     * @param {Object} content - Content to download
     * @returns {Observable}
     */
    AdaptationBufferManager.prototype.createBuffer = function (bufferClock$, queuedSourceBuffer, segmentBookkeeper, segmentFetcher, wantedBufferAhead$, content) {
        var manifest = content.manifest, period = content.period, adaptation = content.adaptation;
        var abr$ = this._getABRForAdaptation(adaptation);
        /**
         * Emit at each bitrate estimate done by the ABRManager
         * @type {Observable}
         */
        var bitrateEstimate$ = abr$
            .filter(function (_a) {
            var bitrate = _a.bitrate;
            return bitrate != null;
        })
            .map(function (_a) {
            var bitrate = _a.bitrate;
            return {
                type: "bitrateEstimationChange",
                value: {
                    type: adaptation.type,
                    bitrate: bitrate,
                },
            };
        });
        /**
         * Emit the chosen representation each time it changes.
         * @type {Observable}
         */
        var representation$ = abr$
            .map(function (abr) { return abr.representation; })
            .distinctUntilChanged(function (a, b) {
            return !a || !b || (a.bitrate === b.bitrate && a.id === b.id);
        });
        /**
         * Emit each times the RepresentationBuffer should be re-initialized:
         *   - Each time the Representation change
         *   - Each time the user seek
         * @type {Observable}
         */
        var shouldSwitchRepresentationBuffer$ = representation$
            .distinctUntilChanged(function (oldRepresentation, newRepresentation) {
            return oldRepresentation.id === newRepresentation.id;
        });
        /**
         * @type {Observable}
         */
        var buffer$ = shouldSwitchRepresentationBuffer$
            .switchMap(function (representation) {
            return Observable_1.Observable.of({
                type: "representationChange",
                value: {
                    type: adaptation.type,
                    period: period,
                    representation: representation,
                },
            }).concat(createRepresentationBuffer(representation));
        });
        return Observable_1.Observable.merge(buffer$, bitrateEstimate$);
        /**
         * Create and returns a new RepresentationBuffer Observable, linked to the
         * given Representation.
         * @param {Representation} representation
         * @returns {Observable}
         */
        function createRepresentationBuffer(representation) {
            log_1.default.info("changing representation", adaptation.type, representation);
            return representation_buffer_1.default({
                clock$: bufferClock$,
                content: {
                    representation: representation,
                    adaptation: adaptation,
                    period: period,
                    manifest: manifest,
                },
                queuedSourceBuffer: queuedSourceBuffer,
                segmentBookkeeper: segmentBookkeeper,
                segmentFetcher: segmentFetcher,
                wantedBufferAhead$: wantedBufferAhead$,
            })
                .catch(function (error) {
                // TODO only for smooth/to Delete?
                // TODO Do it in the stream?
                // for live adaptations, handle 412 errors as precondition-
                // failed errors, ie: we are requesting for segments before they
                // exist
                // (In case of smooth streaming, 412 errors are requests that are
                // performed to early).
                if (!manifest.isLive ||
                    error.type !== errors_1.ErrorTypes.NETWORK_ERROR ||
                    !error.isHttpError(412)) {
                    throw error;
                }
                manifest.updateLiveGap(1); // go back 1s for now
                log_1.default.warn("precondition failed", manifest.presentationLiveGap);
                return Observable_1.Observable.timer(2000)
                    .mergeMap(function () { return createRepresentationBuffer(representation); });
            });
        }
    };
    /**
     * Returns ABR Observable.
     * @param {Object} adaptation
     * @returns {Observable}
     */
    AdaptationBufferManager.prototype._getABRForAdaptation = function (adaptation) {
        var representations = adaptation.representations;
        /**
         * Keep track of the current representation to add informations to the
         * ABR clock.
         * TODO isn't that a little bit ugly?
         * @type {Object|null}
         */
        var currentRepresentation = null;
        var abrClock$ = this._abrBaseClock$
            .map(function (tick) {
            var bitrate;
            var lastIndexPosition;
            if (currentRepresentation) {
                bitrate = currentRepresentation.bitrate;
                if (currentRepresentation.index) {
                    lastIndexPosition =
                        currentRepresentation.index.getLastPosition();
                }
            }
            return objectAssign({
                bitrate: bitrate,
                lastIndexPosition: lastIndexPosition,
            }, tick);
        });
        return this._abrManager.get$(adaptation.type, abrClock$, representations)
            .do(function (_a) {
            var representation = _a.representation;
            currentRepresentation = representation;
        });
    };
    return AdaptationBufferManager;
}());
exports.default = AdaptationBufferManager;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (arr, predicate, ctx) {
	if (typeof Array.prototype.findIndex === 'function') {
		return arr.findIndex(predicate, ctx);
	}

	if (typeof predicate !== 'function') {
		throw new TypeError('predicate must be a function');
	}

	var list = Object(arr);
	var len = list.length;

	if (len === 0) {
		return -1;
	}

	for (var i = 0; i < len; i++) {
		if (predicate.call(ctx, list[i], i, list)) {
			return i;
		}
	}

	return -1;
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
var EWMA = /** @class */ (function () {
    /**
     * @param {number} halfLife
     */
    function EWMA(halfLife) {
        // (half-life = log(1/2) / log(Decay Factor)
        this._alpha = Math.exp(Math.log(0.5) / halfLife);
        this._lastEstimate = 0;
        this._totalWeight = 0;
    }
    /**
     * @param {number} weight
     * @param {number} value
     */
    EWMA.prototype.addSample = function (weight, value) {
        var adjAlpha = Math.pow(this._alpha, weight);
        var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
        if (!isNaN(newEstimate)) {
            this._lastEstimate = newEstimate;
            this._totalWeight += weight;
        }
    };
    /**
     * @returns {number} value
     */
    EWMA.prototype.getEstimate = function () {
        var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
        return this._lastEstimate / zeroFactor;
    };
    return EWMA;
}());
exports.default = EWMA;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */
function getFuzzedDelay(retryDelay) {
    var fuzzingFactor = ((Math.random() * 2) - 1) * FUZZ_FACTOR;
    return retryDelay * (fuzzingFactor + 1.0); // Max 1.3 Min 0.7
}
exports.getFuzzedDelay = getFuzzedDelay;
/**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number} [retryCount=1]
 * @returns {Number}
 */
function getBackedoffDelay(retryDelay, retryCount) {
    if (retryCount === void 0) { retryCount = 1; }
    return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
}
exports.getBackedoffDelay = getBackedoffDelay;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array_includes_1 = __webpack_require__(13);
var log_1 = __webpack_require__(1);
/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */
function isSessionUsable(loadedSession) {
    if (loadedSession.sessionId === "") {
        return false;
    }
    var keyStatusesMap = loadedSession.keyStatuses;
    var keyStatuses = [];
    keyStatusesMap.forEach(function (keyStatus) {
        keyStatuses.push(keyStatus);
    });
    if (keyStatuses.length > 0 &&
        (!array_includes_1.default(keyStatuses, "expired") &&
            !array_includes_1.default(keyStatuses, "internal-error"))) {
        log_1.default.debug("eme: reuse loaded session", loadedSession.sessionId);
        return true;
    }
    return false;
}
exports.default = isSessionUsable;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var helpers_1 = __webpack_require__(12);
var SegmentBase_1 = __webpack_require__(36);
var SegmentTimeline_1 = __webpack_require__(206);
/**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */
function parseInitializationAttribute(attrValue) {
    return { media: attrValue };
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseSegmentTemplate(root) {
    var base = SegmentBase_1.default(root);
    var ret;
    var index;
    var media;
    var bitstreamSwitching;
    var timeline;
    for (var i = 0; i < root.childNodes.length; i++) {
        if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
            var currentNode = root.childNodes[i];
            if (currentNode.nodeName === "SegmentTimeline") {
                timeline = SegmentTimeline_1.default(currentNode);
            }
        }
    }
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.nodeName) {
            case "initialization":
                if (base.initialization == null) {
                    base.initialization = parseInitializationAttribute(attribute.value);
                }
                break;
            case "index":
                index = attribute.value;
                break;
            case "media":
                media = attribute.value;
                break;
            case "bitstreamSwitching":
                bitstreamSwitching = helpers_1.parseBoolean(attribute.value);
                break;
        }
    }
    if (timeline != null) {
        ret = objectAssign({}, base, {
            indexType: "timeline",
            timeline: timeline,
        });
    }
    else {
        var segmentDuration = base.duration;
        if (segmentDuration == null) {
            throw new Error("Invalid SegmentTemplate: no duration");
        }
        ret = objectAssign({}, base, {
            indexType: "template",
            duration: segmentDuration,
        });
    }
    if (index != null) {
        ret.index = index;
    }
    if (media != null) {
        ret.media = media;
    }
    if (bitstreamSwitching != null) {
        ret.bitstreamSwitching = bitstreamSwitching;
    }
    return ret;
}
exports.default = parseSegmentTemplate;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var SegmentBase_1 = __webpack_require__(36);
var SegmentURL_1 = __webpack_require__(207);
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseSegmentList(root) {
    var base = SegmentBase_1.default(root);
    var list = [];
    var segmentListChildren = root.childNodes;
    for (var i = 0; i < segmentListChildren.length; i++) {
        if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentNode = segmentListChildren[i];
            if (currentNode.nodeName === "SegmentURL") {
                var segmentURL = SegmentURL_1.default(currentNode);
                list.push(segmentURL);
            }
        }
    }
    var baseDuration = base.duration;
    if (baseDuration == null) {
        throw new Error("Invalid SegmentList: no duration");
    }
    return objectAssign(base, {
        list: list,
        duration: baseDuration,
    });
}
exports.default = parseSegmentList;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
var isobmff_1 = __webpack_require__(30);
/**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Object} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>} [sidxSegments=[]] - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
    var _sidxSegments = sidxSegments || [];
    var startTime;
    var duration;
    var decodeTime = isobmff_1.parseTfdt(buffer);
    var trunDuration = isobmff_1.getDurationFromTrun(buffer);
    var timescale = initInfos && initInfos.timescale ?
        initInfos.timescale : segment.timescale;
    // we could always make a mistake when reading a container.
    // If the estimate is too far from what the segment seems to imply, take
    // the segment infos instead.
    var maxDecodeTimeDelta;
    // Scaled start time and duration as announced in the segment data
    var segmentDuration;
    var segmentStart;
    if (timescale === segment.timescale) {
        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);
        segmentStart = segment.time;
        segmentDuration = segment.duration;
    }
    else {
        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ?
            ((segment.duration / segment.timescale) * timescale) / 4 : 0.25);
        segmentStart = ((segment.time || 0) / segment.timescale) * timescale;
        segmentDuration = segment.duration != null ?
            (segment.duration / segment.timescale) * timescale : undefined;
    }
    if (decodeTime >= 0) {
        startTime = decodeTime;
    }
    if (trunDuration >= 0 &&
        (segmentDuration == null ||
            Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
        duration = trunDuration;
    }
    if (startTime == null) {
        var sidxStart = _sidxSegments[0].time;
        if (sidxStart >= 0) {
            var sidxTimescale = _sidxSegments[0].timescale;
            startTime = sidxTimescale != null && sidxTimescale !== timescale ?
                (sidxStart / sidxTimescale) * timescale : sidxStart;
        }
        else {
            startTime = segmentStart;
        }
    }
    if (duration == null) {
        if (_sidxSegments.length) {
            var sidxDuration = _sidxSegments.reduce(function (a, b) { return a + (b.duration || 0); }, 0);
            duration = sidxDuration >= 0 ? sidxDuration : segmentDuration;
        }
        else {
            duration = segmentDuration;
        }
    }
    if (false) {}
    return {
        timescale: timescale,
        time: startTime || 0,
        duration: duration || 0,
    };
}
exports.default = getISOBMFFTimingInfos;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ISM_REG = /\.(isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
function byteRange(_a) {
    var start = _a[0], end = _a[1];
    if (!end || end === Infinity) {
        return "bytes=" + (+start) + "-";
    }
    else {
        return "bytes=" + (+start) + "-" + (+end);
    }
}
exports.byteRange = byteRange;
/**
 * TODO Remove this logic completely from the player
 * @returns {string|null}
 */
function extractISML(doc) {
    return doc.getElementsByTagName("media")[0].getAttribute("src");
}
exports.extractISML = extractISML;
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */
function extractToken(url) {
    var tokenMatch = url.match(TOKEN_REG);
    return (tokenMatch && tokenMatch[1]) || "";
}
exports.extractToken = extractToken;
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */
function replaceToken(url, token) {
    if (token) {
        return url.replace(TOKEN_REG, "?token=" + token);
    }
    else {
        return url.replace(TOKEN_REG, "");
    }
}
exports.replaceToken = replaceToken;
/**
 * @param {string} url
 * @returns {string}
 */
function resolveManifest(url) {
    var ismMatch = url.match(ISM_REG);
    if (ismMatch) {
        return url.replace(ismMatch[1], ismMatch[1] + "/manifest");
    }
    else {
        return url;
    }
}
exports.resolveManifest = resolveManifest;
/**
 * @param {string} url
 * @param {Representation} representation
 * @param {Object} segment
 * @returns {string}
 */
function buildSegmentURL(url, representation, segment) {
    return url
        .replace(/\{bitrate\}/g, String(representation.bitrate))
        .replace(/\{start time\}/g, String(segment.time));
}
exports.buildSegmentURL = buildSegmentURL;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var request_1 = __webpack_require__(23);
/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */
function regularManifestLoader(url, ignoreProgressEvents) {
    return request_1.default({
        url: url,
        responseType: "document",
        ignoreProgressEvents: ignoreProgressEvents,
    });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */
var manifestPreLoader = function (options) { return function (url) {
    var customManifestLoader = options.customManifestLoader, ignoreProgressEvents = options.ignoreProgressEvents;
    if (!customManifestLoader) {
        return regularManifestLoader(url, ignoreProgressEvents);
    }
    return Observable_1.Observable.create(function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom manifest loader has a response.
         * @param {Object} args
         * @param {*} args.data - The manifest data
         * @param {Number} args.size - The manifest size
         * @param {Number} args.duration - The duration of the request, in ms
         */
        var resolve = function (_args) {
            if (!hasFallbacked) {
                hasFinished = true;
                obs.next({
                    type: "response",
                    value: {
                        responseData: _args.data,
                        size: _args.size,
                        duration: _args.duration,
                    },
                });
                obs.complete();
            }
        };
        /**
         * Callback triggered when the custom manifest loader fails
         * @param {*} [err={}] - The corresponding error encountered
         */
        var reject = function (err) {
            if (err === void 0) { err = {}; }
            if (!hasFallbacked) {
                hasFinished = true;
                obs.error(err);
            }
        };
        /**
         * Callback triggered when the custom manifest loader wants to fallback to
         * the "regular" implementation
         */
        var fallback = function () {
            hasFallbacked = true;
            regularManifestLoader(url).subscribe(obs);
        };
        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
        var abort = customManifestLoader(url, callbacks);
        return function () {
            if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                abort();
            }
        };
    });
}; };
exports.default = manifestPreLoader;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
function stringFromCharCode(args) {
    var max = 16000;
    var ret = "";
    for (var i = 0; i < args.length; i += max) {
        var subArray = args.subarray(i, i + max);
        ret += String.fromCharCode.apply(null, subArray);
    }
    return ret;
}
exports.stringFromCharCode = stringFromCharCode;
/**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */
function stringFromUTF8(data) {
    if (!data) {
        return "";
    }
    var uint8 = new Uint8Array(data);
    // If present, strip off the UTF-8 BOM.
    if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {
        uint8 = uint8.subarray(3);
    }
    // http://stackoverflow.com/a/13691499
    var utf8 = stringFromCharCode(uint8);
    // This converts each character in the string to an escape sequence.  If the
    // character is in the ASCII range, it is not converted; otherwise it is
    // converted to a URI escape sequence.
    // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
    // TODO "escape" is deprecated, provide a ponyfill?
    var escaped = escape(utf8);
    // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
    // correct character.
    // Example: "g#%E3%82%AC" -> "g#€"
    return decodeURIComponent(escaped);
}
exports.stringFromUTF8 = stringFromUTF8;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var bytes_1 = __webpack_require__(21);
/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */
function parseBif(buf) {
    var pos = 0;
    var length = buf.length;
    var fileFormat = bytes_1.bytesToStr(buf.subarray(pos, pos + 8));
    pos += 8;
    var minorVersion = buf[pos];
    pos += 1;
    var majorVersion = buf[pos];
    pos += 1;
    var patchVersion = buf[pos];
    pos += 1;
    var increVersion = buf[pos];
    pos += 1;
    var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");
    var imageCount = buf[pos] + bytes_1.le4toi(buf, pos + 1);
    pos += 4;
    var timescale = bytes_1.le4toi(buf, pos);
    pos += 4;
    var format = bytes_1.bytesToStr(buf.subarray(pos, pos + 4));
    pos += 4;
    var width = bytes_1.le2toi(buf, pos);
    pos += 2;
    var height = bytes_1.le2toi(buf, pos);
    pos += 2;
    var aspectRatio = [buf[pos], buf[pos + 1]].join(":");
    pos += 2;
    var isVod = buf[pos] === 1;
    pos += 1;
    // bytes 0x1F to 0x40 is unused data for now
    pos = 0x40;
    var thumbs = [];
    var currentImage;
    var currentTs = 0;
    if (!imageCount) {
        throw new Error("bif: no images to parse");
    }
    while (pos < length) {
        var currentImageIndex = bytes_1.le4toi(buf, pos);
        pos += 4;
        var currentImageOffset = bytes_1.le4toi(buf, pos);
        pos += 4;
        if (currentImage) {
            var index = currentImage.index;
            var duration = timescale;
            var ts = currentTs;
            var data = buf.subarray(currentImage.offset, currentImageOffset);
            thumbs.push({ index: index, duration: duration, ts: ts, data: data });
            currentTs += timescale;
        }
        if (currentImageIndex === 0xffffffff) {
            break;
        }
        currentImage = {
            index: currentImageIndex,
            offset: currentImageOffset,
        };
    }
    return {
        fileFormat: fileFormat,
        version: version,
        imageCount: imageCount,
        timescale: timescale,
        format: format,
        width: width,
        height: height,
        aspectRatio: aspectRatio,
        isVod: isVod,
        thumbs: thumbs,
    };
}
exports.default = parseBif;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var bytes_1 = __webpack_require__(21);
var castToObservable_1 = __webpack_require__(14);
var eventemitter_1 = __webpack_require__(33);
var constants_1 = __webpack_require__(55);
var events = __webpack_require__(15);
var keySystemAccess_1 = __webpack_require__(95);
var requestMediaKeySystemAccess;
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;
// Default MockMediaKeys implementation
var MockMediaKeys = /** @class */ (function () {
    function class_1() {
    }
    class_1.prototype._setVideo = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    class_1.prototype.createSession = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    class_1.prototype.setServerCertificate = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    return class_1;
}());
exports.MockMediaKeys = MockMediaKeys;
if (navigator.requestMediaKeySystemAccess) {
    exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (a, b) {
        return castToObservable_1.default(navigator.requestMediaKeySystemAccess(a, b));
    };
}
else {
    // Wrap "MediaKeys.prototype.update" form an event based system to a
    // Promise based function.
    var wrapUpdate_1 = function (memUpdate) {
        return function (license, sessionId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                try {
                    memUpdate.call(_this, license, sessionId);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            });
        };
    };
    // This is for Chrome with unprefixed EME api
    if (HTMLVideoElement.prototype.webkitGenerateKeyRequest) {
        var WebkitMediaKeySession_1 = /** @class */ (function (_super) {
            __extends(WebkitMediaKeySession, _super);
            function WebkitMediaKeySession(video, keySystem) {
                var _this = _super.call(this) || this;
                _this._closeSession$ = new Subject_1.Subject();
                _this._vid = video;
                _this._key = keySystem;
                _this.sessionId = "";
                _this.closed = new Promise(function (resolve) {
                    _this._closeSession$.subscribe(resolve);
                });
                _this.keyStatuses = new Map();
                _this.expiration = NaN;
                Observable_1.Observable.merge(events.onKeyMessage$(video), events.onKeyAdded$(video), events.onKeyError$(video))
                    .takeUntil(_this._closeSession$)
                    .subscribe(function (evt) { return _this.trigger(evt.type, evt); });
                _this.update = wrapUpdate_1(function (license, sessionId) {
                    if (_this._key.indexOf("clearkey") >= 0) {
                        var json = JSON.parse(bytes_1.bytesToStr(license));
                        var key = bytes_1.strToBytes(atob(json.keys[0].k));
                        var kid = bytes_1.strToBytes(atob(json.keys[0].kid));
                        _this._vid.webkitAddKey(_this._key, key, kid, sessionId);
                    }
                    else {
                        _this._vid.webkitAddKey(_this._key, license, null, sessionId);
                    }
                    _this.sessionId = sessionId;
                });
                return _this;
            }
            WebkitMediaKeySession.prototype.generateRequest = function (_initDataType, initData) {
                var _this = this;
                return new Promise(function (resolve) {
                    if (typeof _this._vid.webkitGenerateKeyRequest !== "function") {
                        throw new Error("impossible to generate a key request");
                    }
                    _this._vid.webkitGenerateKeyRequest(_this._key, initData);
                    resolve();
                });
            };
            WebkitMediaKeySession.prototype.close = function () {
                var _this = this;
                return new Promise(function (resolve) {
                    _this._closeSession$.next();
                    _this._closeSession$.complete();
                    resolve();
                });
            };
            WebkitMediaKeySession.prototype.load = function () {
                return Promise.resolve(false);
            };
            WebkitMediaKeySession.prototype.remove = function () {
                return Promise.resolve();
            };
            return WebkitMediaKeySession;
        }(eventemitter_1.default));
        exports.MockMediaKeys = MockMediaKeys = /** @class */ (function () {
            function class_2(keySystem) {
                this.ks_ = keySystem;
            }
            class_2.prototype._setVideo = function (vid) {
                this._vid = vid;
            };
            class_2.prototype.createSession = function ( /* sessionType */) {
                if (!this._vid) {
                    throw new Error("Video not attached to the MediaKeys");
                }
                return new WebkitMediaKeySession_1(this._vid, this.ks_);
            };
            class_2.prototype.setServerCertificate = function () {
                throw new Error("Server certificate is not implemented in your browser");
            };
            return class_2;
        }());
        var isTypeSupported_1 = function (keyType) {
            // get any <video> element from the DOM or create one
            // and try the `canPlayType` method
            var video = document.querySelector("video") ||
                document.createElement("video");
            if (video && video.canPlayType) {
                return !!video.canPlayType("video/mp4", keyType);
            }
            else {
                return false;
            }
        };
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {
            if (!isTypeSupported_1(keyType)) {
                return Observable_1.Observable.throw(undefined);
            }
            for (var i = 0; i < keySystemConfigurations.length; i++) {
                var keySystemConfiguration = keySystemConfigurations[i];
                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState;
                var supported = true;
                supported = supported && (!initDataTypes ||
                    !!initDataTypes.filter(function (initDataType) { return initDataType === "cenc"; })[0]);
                supported = supported && (!sessionTypes ||
                    sessionTypes
                        .filter(function (sessionType) { return sessionType === "temporary"; })
                        .length === sessionTypes.length);
                supported = supported && (distinctiveIdentifier !== "required");
                supported = supported && (persistentState !== "required");
                if (supported) {
                    var keySystemConfigurationResponse = {
                        videoCapabilities: videoCapabilities,
                        audioCapabilities: audioCapabilities,
                        initDataTypes: ["cenc"],
                        sessionTypes: ["temporary"],
                        // TODO TypesScript bug or what? Check and open an issue
                        distinctiveIdentifier: "not-allowed",
                        persistentState: "not-allowed",
                    };
                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));
                }
            }
            return Observable_1.Observable.throw(undefined);
        };
    }
    // This is for IE11
    else if (constants_1.MediaKeys_ &&
        constants_1.MediaKeys_.prototype &&
        typeof constants_1.MediaKeys_.prototype.createSession === "function" &&
        typeof constants_1.MediaKeys_.isTypeSupported === "function") {
        // TODO implement MediaKeySession completely
        var IE11MediaKeySession_1 = /** @class */ (function (_super) {
            __extends(IE11MediaKeySession, _super);
            function IE11MediaKeySession(mk) {
                var _this = _super.call(this) || this;
                _this.sessionId = "";
                _this.expiration = NaN;
                _this.keyStatuses = new Map();
                _this._mk = mk;
                _this._closeSession$ = new Subject_1.Subject();
                _this.closed = new Promise(function (resolve) {
                    _this._closeSession$.subscribe(resolve);
                });
                _this.update = wrapUpdate_1(function (license, sessionId) {
                    if (!_this._ss) {
                        throw new Error("MediaKeySession not set");
                    }
                    _this._ss.update(license, sessionId);
                    _this.sessionId = sessionId;
                });
                return _this;
            }
            IE11MediaKeySession.prototype.generateRequest = function (_initDataType, initData) {
                var _this = this;
                return new Promise(function (resolve) {
                    _this._ss = _this._mk.memCreateSession("video/mp4", initData);
                    Observable_1.Observable.merge(events.onKeyMessage$(_this._ss), events.onKeyAdded$(_this._ss), events.onKeyError$(_this._ss))
                        .takeUntil(_this._closeSession$)
                        .subscribe(function (evt) { return _this.trigger(evt.type, evt); });
                    resolve();
                });
            };
            IE11MediaKeySession.prototype.close = function () {
                var _this = this;
                return new Promise(function (resolve) {
                    if (_this._ss) {
                        /* tslint:disable no-floating-promises */
                        _this._ss.close();
                        /* tslint:enable no-floating-promises */
                        _this._ss = undefined;
                    }
                    _this._closeSession$.next();
                    _this._closeSession$.complete();
                    resolve();
                });
            };
            IE11MediaKeySession.prototype.load = function () {
                return Promise.resolve(false);
            };
            IE11MediaKeySession.prototype.remove = function () {
                return Promise.resolve();
            };
            return IE11MediaKeySession;
        }(eventemitter_1.default));
        // on IE11, each created session needs to be created on a new
        // MediaKeys object
        constants_1.MediaKeys_.prototype.alwaysRenew = true;
        constants_1.MediaKeys_.prototype.memCreateSession = constants_1.MediaKeys_.prototype.createSession;
        constants_1.MediaKeys_.prototype.createSession = function () {
            /* tslint:disable no-invalid-this */
            return new IE11MediaKeySession_1(this);
            /* tslint:enable no-invalid-this */
        };
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {
            // TODO Why TS Do not understand that isTypeSupported exists here?
            if (!constants_1.MediaKeys_.isTypeSupported(keyType)) {
                return Observable_1.Observable.throw(undefined);
            }
            for (var i = 0; i < keySystemConfigurations.length; i++) {
                var keySystemConfiguration = keySystemConfigurations[i];
                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
                var supported = true;
                supported = supported && (!initDataTypes ||
                    !!initDataTypes.filter(function (idt) { return idt === "cenc"; })[0]);
                supported = supported && (distinctiveIdentifier !== "required");
                if (supported) {
                    var keySystemConfigurationResponse = {
                        videoCapabilities: videoCapabilities,
                        audioCapabilities: audioCapabilities,
                        initDataTypes: ["cenc"],
                        distinctiveIdentifier: "not-allowed",
                        persistentState: "required",
                        sessionTypes: ["temporary", "persistent-license"],
                    };
                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, 
                    // TODO Authorize 1 argument for IE?
                    new constants_1.MediaKeys_(keyType), keySystemConfigurationResponse));
                }
            }
            return Observable_1.Observable.throw(undefined);
        };
    }
    else {
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = null;
    }
}


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */
var CustomMediaKeySystemAccess = /** @class */ (function () {
    function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
        this._keyType = _keyType;
        this._mediaKeys = _mediaKeys;
        this._configuration = _configuration;
    }
    Object.defineProperty(CustomMediaKeySystemAccess.prototype, "keySystem", {
        get: function () {
            return this._keyType;
        },
        enumerable: true,
        configurable: true
    });
    CustomMediaKeySystemAccess.prototype.createMediaKeys = function () {
        var _this = this;
        return new Promise(function (res) { return res(_this._mediaKeys); });
    };
    CustomMediaKeySystemAccess.prototype.getConfiguration = function () {
        return this._configuration;
    };
    return CustomMediaKeySystemAccess;
}());
exports.default = CustomMediaKeySystemAccess;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(7);
var ObjectUnsubscribedError_1 = __webpack_require__(57);
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=refCount.js.map

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(17);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(59);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeAll_1 = __webpack_require__(105);
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(22);
exports.of = ArrayObservable_1.ArrayObservable.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(59);
var identity_1 = __webpack_require__(356);
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);
}
exports.mergeAll = mergeAll;
//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(358);
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(18);
var Action_1 = __webpack_require__(359);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(28);
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromPromise_1 = __webpack_require__(363);
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var Notification_1 = __webpack_require__(367);
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(18);
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromObservable_1 = __webpack_require__(370);
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */
var objectAssign = __webpack_require__(8);
var config_1 = __webpack_require__(2);
var languages_1 = __webpack_require__(29);
var log_1 = __webpack_require__(1);
var DEFAULT_AUTO_PLAY = config_1.default.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config_1.default.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config_1.default.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MAX_BITRATES = config_1.default.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config_1.default.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config_1.default.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config_1.default.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_TEXT_TRACK_MODE = config_1.default.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config_1.default.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config_1.default.DEFAULT_WANTED_BUFFER_AHEAD;
/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object} [options={}]
 * @returns {Object}
 */
function parseConstructorOptions(options) {
    var maxBufferAhead;
    var maxBufferBehind;
    var wantedBufferAhead;
    var limitVideoWidth;
    var throttleWhenHidden;
    var videoElement;
    var initialVideoBitrate;
    var initialAudioBitrate;
    var maxAudioBitrate;
    var maxVideoBitrate;
    var stopAtEnd;
    if (options.maxBufferAhead == null) {
        maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
    }
    else {
        maxBufferAhead = Number(options.maxBufferAhead);
        if (isNaN(maxBufferAhead)) {
            throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
        }
    }
    if (options.maxBufferBehind == null) {
        maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
    }
    else {
        maxBufferBehind = Number(options.maxBufferBehind);
        if (isNaN(maxBufferBehind)) {
            throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
        }
    }
    if (options.wantedBufferAhead == null) {
        wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
    }
    else {
        wantedBufferAhead = Number(options.wantedBufferAhead);
        if (isNaN(wantedBufferAhead)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    limitVideoWidth = options.limitVideoWidth == null ?
        DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;
    throttleWhenHidden = options.throttleWhenHidden == null ?
        DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden;
    if (options.videoElement == null) {
        videoElement = document.createElement("video");
    }
    else if (options.videoElement instanceof HTMLMediaElement) {
        videoElement = options.videoElement;
    }
    else {
        /* tslint:disable:max-line-length */
        throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
        /* tslint:enable:max-line-length */
    }
    if (options.initialVideoBitrate == null) {
        initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
    }
    else {
        initialVideoBitrate = Number(options.initialVideoBitrate);
        if (isNaN(initialVideoBitrate)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    if (options.initialAudioBitrate == null) {
        initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
    }
    else {
        initialAudioBitrate = Number(options.initialAudioBitrate);
        if (isNaN(initialAudioBitrate)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    if (options.maxVideoBitrate == null) {
        maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
    }
    else {
        maxVideoBitrate = Number(options.maxVideoBitrate);
        if (isNaN(maxVideoBitrate)) {
            throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
        }
    }
    if (options.maxAudioBitrate == null) {
        maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
    }
    else {
        maxAudioBitrate = Number(options.maxAudioBitrate);
        if (isNaN(maxAudioBitrate)) {
            throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
        }
    }
    if (options.stopAtEnd == null) {
        stopAtEnd = true;
    }
    else if (typeof options.stopAtEnd === "boolean") {
        stopAtEnd = options.stopAtEnd;
    }
    else {
        throw new Error("Invalid stopAtEnd parameter. Should be a boolean.");
    }
    return {
        maxBufferAhead: maxBufferAhead,
        maxBufferBehind: maxBufferBehind,
        limitVideoWidth: limitVideoWidth,
        videoElement: videoElement,
        wantedBufferAhead: wantedBufferAhead,
        throttleWhenHidden: throttleWhenHidden,
        initialAudioBitrate: initialAudioBitrate,
        initialVideoBitrate: initialVideoBitrate,
        maxAudioBitrate: maxAudioBitrate,
        maxVideoBitrate: maxVideoBitrate,
        stopAtEnd: stopAtEnd,
    };
}
exports.parseConstructorOptions = parseConstructorOptions;
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object} [options={}]
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */
function parseLoadVideoOptions(options) {
    var url;
    var transport;
    var autoPlay;
    var keySystems;
    var transportOptions;
    var supplementaryTextTracks;
    var supplementaryImageTracks;
    var textTrackMode;
    var textTrackElement;
    var defaultAudioTrack;
    var defaultTextTrack;
    var hideNativeSubtitle;
    var startAt;
    if (!options || options.url == null) {
        throw new Error("No url set on loadVideo");
    }
    else {
        url = String(options.url);
    }
    if (options.transport == null) {
        throw new Error("No transport set on loadVideo");
    }
    else {
        transport = String(options.transport);
    }
    autoPlay = options.autoPlay == null ?
        DEFAULT_AUTO_PLAY : !!options.autoPlay;
    if (options.keySystems == null) {
        keySystems = [];
    }
    else {
        keySystems = Array.isArray(options.keySystems) ?
            options.keySystems : [options.keySystems];
        for (var _i = 0, keySystems_1 = keySystems; _i < keySystems_1.length; _i++) {
            var keySystem = keySystems_1[_i];
            if (typeof keySystem.type !== "string" ||
                typeof keySystem.getLicense !== "function") {
                throw new Error("Invalid key system given: Missing type string or " +
                    "getLicense callback");
            }
        }
    }
    transportOptions = options.transportOptions;
    if (options.supplementaryTextTracks == null) {
        supplementaryTextTracks = [];
    }
    else {
        supplementaryTextTracks =
            Array.isArray(options.supplementaryTextTracks) ?
                options.supplementaryTextTracks : [options.supplementaryTextTracks];
        for (var _a = 0, supplementaryTextTracks_1 = supplementaryTextTracks; _a < supplementaryTextTracks_1.length; _a++) {
            var supplementaryTextTrack = supplementaryTextTracks_1[_a];
            if (typeof supplementaryTextTrack.closedCaption !== "boolean") {
                supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption;
            }
            if (typeof supplementaryTextTrack.language !== "string" ||
                typeof supplementaryTextTrack.mimeType !== "string" ||
                typeof supplementaryTextTrack.url !== "string") {
                /* tslint:disable:max-line-length */
                throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                /* tslint:enable:max-line-length */
            }
        }
    }
    if (options.supplementaryImageTracks == null) {
        supplementaryImageTracks = [];
    }
    else {
        supplementaryImageTracks =
            Array.isArray(options.supplementaryImageTracks) ?
                options.supplementaryImageTracks : [options.supplementaryImageTracks];
        for (var _b = 0, supplementaryImageTracks_1 = supplementaryImageTracks; _b < supplementaryImageTracks_1.length; _b++) {
            var supplementaryImageTrack = supplementaryImageTracks_1[_b];
            if (typeof supplementaryImageTrack.mimeType !== "string" ||
                typeof supplementaryImageTrack.url !== "string") {
                /* tslint:disable:max-line-length */
                throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                /* tslint:enable:max-line-length */
            }
        }
    }
    if (options.textTrackMode == null) {
        textTrackMode = DEFAULT_TEXT_TRACK_MODE;
    }
    else {
        if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
            throw new Error("Invalid textTrackMode.");
        }
        textTrackMode = options.textTrackMode;
    }
    defaultAudioTrack = languages_1.normalizeAudioTrack(options.defaultAudioTrack);
    defaultTextTrack = languages_1.normalizeTextTrack(options.defaultTextTrack);
    hideNativeSubtitle = options.hideNativeSubtitle == null ?
        !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle;
    if (textTrackMode === "html") {
        // TODO Better way to express that in TypeScript?
        if (options.textTrackElement == null) {
            /* tslint:disable:max-line-length */
            throw new Error("You have to provide a textTrackElement in \"html\" textTrackMode.");
            /* tslint:enable:max-line-length */
        }
        else if (!(options.textTrackElement instanceof HTMLElement)) {
            throw new Error("textTrackElement should be an HTMLElement.");
        }
        else {
            textTrackElement = options.textTrackElement;
        }
    }
    else if (options.textTrackElement != null) {
        /* tslint:disable:max-line-length */
        log_1.default.warn("You have set a textTrackElement without being in an \"html\" textTrackMode. It will be ignored.");
        /* tslint:enable:max-line-length */
    }
    if (options.startAt != null) {
        // TODO Better way to express that in TypeScript?
        if (options.startAt.wallClockTime
            instanceof Date) {
            var wallClockTime = options.startAt
                .wallClockTime.getTime() / 1000;
            startAt = objectAssign({}, options.startAt, { wallClockTime: wallClockTime });
        }
        else {
            startAt = options.startAt;
        }
    }
    var networkConfig = options.networkConfig == null ? {} : {
        manifestRetry: options.networkConfig.manifestRetry,
        offlineRetry: options.networkConfig.offlineRetry,
        segmentRetry: options.networkConfig.segmentRetry,
    };
    // TODO without cast
    /* tslint:disable no-object-literal-type-assertion */
    return {
        autoPlay: autoPlay,
        defaultAudioTrack: defaultAudioTrack,
        defaultTextTrack: defaultTextTrack,
        hideNativeSubtitle: hideNativeSubtitle,
        keySystems: keySystems,
        networkConfig: networkConfig,
        startAt: startAt,
        supplementaryImageTracks: supplementaryImageTracks,
        supplementaryTextTracks: supplementaryTextTracks,
        textTrackElement: textTrackElement,
        textTrackMode: textTrackMode,
        transport: transport,
        transportOptions: transportOptions,
        url: url,
    };
    /* tslint:enable no-object-literal-type-assertion */
}
exports.parseLoadVideoOptions = parseLoadVideoOptions;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file is used to abstract the notion of text and audio language-switching
 * for an easier API management.
 */
var arrayFind = __webpack_require__(9);
var array_includes_1 = __webpack_require__(13);
var log_1 = __webpack_require__(1);
var sorted_list_1 = __webpack_require__(44);
/**
 * Manage audio and text tracks for all active periods.
 *
 * Most methods here allow to interact with the first chronologically added
 * Period.
 *
 * Languages for subsequent periods are also chosen accordingly.
 * @class LanguageManager
 */
var LanguageManager = /** @class */ (function () {
    /**
     * @param {Object} defaults
     * @param {Array.<Object>} defaults.preferredAudioTracks
     * @param {Array.<Object>} defaults.preferredTextTracks
     */
    function LanguageManager(defaults) {
        if (defaults === void 0) { defaults = {}; }
        var preferredAudioTracks = defaults.preferredAudioTracks, preferredTextTracks = defaults.preferredTextTracks;
        this._periods = new sorted_list_1.default(function (a, b) { return a.period.start - b.period.start; });
        this._audioChoiceMemory = new WeakMap();
        this._textChoiceMemory = new WeakMap();
        this._preferredAudioTracks = preferredAudioTracks || [];
        this._preferredTextTracks = preferredTextTracks || [];
    }
    /**
     * Add Subject to choose Adaptation for new "audio" or "text" Period.
     * @param {string} bufferType
     * @param {Period} period
     * @param {Subject} adaptations
     */
    LanguageManager.prototype.addPeriod = function (bufferType, period, adaptation$) {
        var periodItem = getPeriodItem(this._periods, period);
        if (periodItem != null) {
            if (periodItem[bufferType] != null) {
                log_1.default.warn("LanguageManager: " + bufferType + " already added for period", period);
                return;
            }
            else {
                periodItem[bufferType] = {
                    adaptations: period.adaptations[bufferType] || [],
                    adaptation$: adaptation$,
                };
            }
        }
        else {
            this._periods.add((_a = {
                    period: period
                },
                _a[bufferType] = {
                    adaptations: period.adaptations[bufferType] || [],
                    adaptation$: adaptation$,
                },
                _a));
        }
        var _a;
    };
    /**
     * Remove Subject to choose an "audio" or "text" Adaptation for a Period.
     * @param {string} bufferType
     * @param {Period} period
     */
    LanguageManager.prototype.removePeriod = function (bufferType, period) {
        var periodIndex = findPeriodIndex(this._periods, period);
        if (periodIndex == null) {
            log_1.default.warn("LanguageManager: " + bufferType + " not found for period", period);
            return;
        }
        var periodItem = this._periods.get(periodIndex);
        if (periodItem[bufferType] == null) {
            log_1.default.warn("LanguageManager: " + bufferType + " already removed for period", period);
            return;
        }
        delete periodItem[bufferType];
        if (periodItem.audio == null && periodItem.text == null) {
            this._periods.removeFirst(periodItem);
        }
    };
    /**
     * Update the choice of all added Periods based on:
     *   1. What was the last chosen adaptation
     *   2. If not found, the preferences
     */
    LanguageManager.prototype.update = function () {
        this._updateAudioTrackChoices();
        this._updateTextTrackChoices();
    };
    /**
     * Emit initial audio Adaptation through the given Subject based on:
     *   - the preferred audio tracks
     *   - the last choice for this period, if one
     * @param {Period} period
     *
     * @throws Error - Throws if the period given has not been added
     */
    LanguageManager.prototype.setInitialAudioTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var audioInfos = periodItem && periodItem.audio;
        if (!audioInfos || !periodItem) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var preferredAudioTracks = this._preferredAudioTracks;
        var audioAdaptations = period.adaptations.audio || [];
        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (chosenAudioAdaptation === undefined ||
            !array_includes_1.default(audioAdaptations, chosenAudioAdaptation)) {
            var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
            this._audioChoiceMemory.set(period, optimalAdaptation);
            audioInfos.adaptation$.next(optimalAdaptation);
        }
        else {
            audioInfos.adaptation$.next(chosenAudioAdaptation);
        }
    };
    /**
     * Emit initial text Adaptation through the given Subject based on:
     *   - the preferred text tracks
     *   - the last choice for this period, if one
     * @param {Period} period
     *
     * @throws Error - Throws if the period given has not been added
     */
    LanguageManager.prototype.setInitialTextTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var textInfos = periodItem && periodItem.text;
        if (!textInfos || !periodItem) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var preferredTextTracks = this._preferredTextTracks;
        var textAdaptations = period.adaptations.text || [];
        var chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === undefined ||
            !array_includes_1.default(textAdaptations, chosenTextAdaptation)) {
            var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
            this._textChoiceMemory.set(period, optimalAdaptation);
            textInfos.adaptation$.next(optimalAdaptation);
        }
        else {
            textInfos.adaptation$.next(chosenTextAdaptation);
        }
    };
    /**
     * Set audio track based on the ID of its adaptation for a given added Period.
     *
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     *
     * @throws Error - Throws if the period given has not been added
     * @throws Error - Throws if the given id is not found in any audio adaptation
     * of the given Period.
     */
    LanguageManager.prototype.setAudioTrackByID = function (period, wantedId) {
        var periodItem = getPeriodItem(this._periods, period);
        var audioInfos = periodItem && periodItem.audio;
        if (!audioInfos) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var wantedAdaptation = arrayFind(audioInfos.adaptations, function (_a) {
            var id = _a.id;
            return id === wantedId;
        });
        if (wantedAdaptation === undefined) {
            throw new Error("Audio Track not found.");
        }
        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (chosenAudioAdaptation === wantedAdaptation) {
            return;
        }
        this._audioChoiceMemory.set(period, wantedAdaptation);
        audioInfos.adaptation$.next(wantedAdaptation);
    };
    /**
     * Set text track based on the ID of its adaptation for a given added Period.
     *
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     *
     * @throws Error - Throws if the period given has not been added
     * @throws Error - Throws if the given id is not found in any text adaptation
     * of the given Period.
     */
    LanguageManager.prototype.setTextTrackByID = function (period, wantedId) {
        var periodItem = getPeriodItem(this._periods, period);
        var textInfos = periodItem && periodItem.text;
        if (!textInfos) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var wantedAdaptation = arrayFind(textInfos.adaptations, function (_a) {
            var id = _a.id;
            return id === wantedId;
        });
        if (wantedAdaptation === undefined) {
            throw new Error("Text Track not found.");
        }
        var chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === wantedAdaptation) {
            return;
        }
        this._textChoiceMemory.set(period, wantedAdaptation);
        textInfos.adaptation$.next(wantedAdaptation);
    };
    /**
     * Disable the given audio track for a given Period.
     *
     * @param {Period} period - The concerned Period.
     *
     * @throws Error - Throws if the period given has not been added
     */
    LanguageManager.prototype.disableAudioTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var audioInfos = periodItem && periodItem.audio;
        if (!audioInfos) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (chosenAudioAdaptation === null) {
            return;
        }
        this._audioChoiceMemory.set(period, null);
        audioInfos.adaptation$.next(null);
    };
    /**
     * Disable the current text track for a given period.
     *
     * @param {Period} period - The concerned Period.
     *
     * @throws Error - Throws if the period given has not been added
     */
    LanguageManager.prototype.disableTextTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var textInfos = periodItem && periodItem.text;
        if (!textInfos) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        var chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === null) {
            return;
        }
        this._textChoiceMemory.set(period, null);
        textInfos.adaptation$.next(null);
    };
    /**
     * Returns an object describing the chosen audio track for the given audio
     * Period.
     *
     * Returns null is the the current audio track is disabled or not
     * set yet.
     *
     * @param {Period} period
     * @returns {Object|null}
     */
    LanguageManager.prototype.getChosenAudioTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var audioInfos = periodItem && periodItem.audio;
        if (audioInfos == null) {
            return null;
        }
        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (!chosenAudioAdaptation) {
            return null;
        }
        return {
            language: chosenAudioAdaptation.language || "",
            normalized: chosenAudioAdaptation.normalizedLanguage || "",
            audioDescription: !!chosenAudioAdaptation.isAudioDescription,
            id: chosenAudioAdaptation.id,
        };
    };
    /**
     * Returns an object describing the chosen text track for the given text
     * Period.
     *
     * Returns null is the the current text track is disabled or not
     * set yet.
     *
     * @param {Period} period
     * @returns {Object|null}
     */
    LanguageManager.prototype.getChosenTextTrack = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var textInfos = periodItem && periodItem.text;
        if (textInfos == null) {
            return null;
        }
        var chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (!chosenTextAdaptation) {
            return null;
        }
        return {
            language: chosenTextAdaptation.language || "",
            normalized: chosenTextAdaptation.normalizedLanguage || "",
            closedCaption: !!chosenTextAdaptation.isClosedCaption,
            id: chosenTextAdaptation.id,
        };
    };
    /**
     * Returns all available audio tracks for a given Period, as an array of
     * objects.
     *
     * @returns {Array.<Object>}
     */
    LanguageManager.prototype.getAvailableAudioTracks = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var audioInfos = periodItem && periodItem.audio;
        if (audioInfos == null) {
            return [];
        }
        var chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        var currentId = chosenAudioAdaptation && chosenAudioAdaptation.id;
        return audioInfos.adaptations
            .map(function (adaptation) { return ({
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            audioDescription: !!adaptation.isAudioDescription,
            id: adaptation.id,
            active: currentId == null ? false : currentId === adaptation.id,
        }); });
    };
    /**
     * Returns all available text tracks for a given Period, as an array of
     * objects.
     *
     * @param {Period} period
     * @returns {Array.<Object>}
     */
    LanguageManager.prototype.getAvailableTextTracks = function (period) {
        var periodItem = getPeriodItem(this._periods, period);
        var textInfos = periodItem && periodItem.text;
        if (textInfos == null) {
            return [];
        }
        var chosenTextAdaptation = this._textChoiceMemory.get(period);
        var currentId = chosenTextAdaptation && chosenTextAdaptation.id;
        return textInfos.adaptations
            .map(function (adaptation) { return ({
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            closedCaption: !!adaptation.isClosedCaption,
            id: adaptation.id,
            active: currentId == null ? false : currentId === adaptation.id,
        }); });
    };
    LanguageManager.prototype._updateAudioTrackChoices = function () {
        var _this = this;
        var preferredAudioTracks = this._preferredAudioTracks;
        var recursiveUpdateAudioTrack = function (index) {
            if (index >= _this._periods.length()) {
                // we did all audio Buffers, exit
                return;
            }
            var periodItem = _this._periods.get(index);
            if (periodItem.audio == null) {
                // No audio Buffer for this period, check next one
                recursiveUpdateAudioTrack(index + 1);
                return;
            }
            var period = periodItem.period, audioItem = periodItem.audio;
            var audioAdaptations = period.adaptations.audio || [];
            var chosenAudioAdaptation = _this._audioChoiceMemory.get(period);
            if (chosenAudioAdaptation === null ||
                (chosenAudioAdaptation !== undefined &&
                    array_includes_1.default(audioAdaptations, chosenAudioAdaptation))) {
                // Already best audio for this Buffer, check next one
                recursiveUpdateAudioTrack(index + 1);
                return;
            }
            var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks);
            _this._audioChoiceMemory.set(period, optimalAdaptation);
            audioItem.adaptation$.next(optimalAdaptation);
            // previous "next" call could have changed everything, start over
            recursiveUpdateAudioTrack(0);
        };
        recursiveUpdateAudioTrack(0);
    };
    LanguageManager.prototype._updateTextTrackChoices = function () {
        var _this = this;
        var preferredTextTracks = this._preferredTextTracks;
        var recursiveUpdateTextTrack = function (index) {
            if (index >= _this._periods.length()) {
                // we did all text Buffers, exit
                return;
            }
            var periodItem = _this._periods.get(index);
            if (periodItem.text == null) {
                // No text Buffer for this period, check next one
                recursiveUpdateTextTrack(index + 1);
                return;
            }
            var period = periodItem.period, textItem = periodItem.text;
            var textAdaptations = period.adaptations.text || [];
            var chosenTextAdaptation = _this._textChoiceMemory.get(period);
            if (chosenTextAdaptation === null ||
                (chosenTextAdaptation !== undefined &&
                    array_includes_1.default(textAdaptations, chosenTextAdaptation))) {
                // Already best text for this Buffer, check next one
                recursiveUpdateTextTrack(index + 1);
                return;
            }
            var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks);
            _this._textChoiceMemory.set(period, optimalAdaptation);
            textItem.adaptation$.next(optimalAdaptation);
            // previous "next" call could have changed everything, start over
            recursiveUpdateTextTrack(0);
        };
        recursiveUpdateTextTrack(0);
    };
    return LanguageManager;
}());
exports.default = LanguageManager;
// /**
//  * Returns true if the given audio adaptation is an optimal choice for a period
//  * given:
//  *
//  *   - the list of audio adaptations in the period
//  *
//  *   - an array of preferred audio configurations sorted from the most preferred
//  *     to the least preferred.
//  *
//  * @param {Adaptation|null} adaptation
//  * @param {Array.<Adaptation>} audioAdaptations
//  * @param {Array.<Object>} preferredAudioTracks
//  * @returns {Boolean}
//  */
// function isAudioAdaptationOptimal(
//   adaptation : Adaptation|null,
//   audioAdaptations : Adaptation[],
//   preferredAudioTracks : IAudioTrackPreference[]
// ) : boolean {
//   if (!audioAdaptations.length) {
//     return adaptation === null;
//   }
//   for (let i = 0; i < preferredAudioTracks.length; i++) {
//     const preferredAudioTrack = preferredAudioTracks[i];
//     if (preferredAudioTrack === null) {
//       return adaptation === null;
//     }
//     const foundAdaptation = arrayFind(audioAdaptations, (audioAdaptation) =>
//       audioAdaptation.normalizedLanguage === preferredAudioTrack.normalized &&
//       !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription
//     );
//     if (foundAdaptation !== undefined) {
//       if (adaptation === null) {
//         return false;
//       }
//       return (
//         (foundAdaptation.normalizedLanguage || "") ===
//         (adaptation.normalizedLanguage || "")
//       ) && !!foundAdaptation.isAudioDescription === !!adaptation.isAudioDescription;
//     }
//   }
//   return true; // no optimal adaptation, just return true
// }
/**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */
function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
    if (!audioAdaptations.length) {
        return null;
    }
    var _loop_1 = function (i) {
        var preferredAudioTrack = preferredAudioTracks[i];
        if (preferredAudioTrack === null) {
            return { value: null };
        }
        var foundAdaptation = arrayFind(audioAdaptations, function (audioAdaptation) {
            return (audioAdaptation.normalizedLanguage || "") === preferredAudioTrack.normalized &&
                !!audioAdaptation.isAudioDescription === preferredAudioTrack.audioDescription;
        });
        if (foundAdaptation !== undefined) {
            return { value: foundAdaptation };
        }
    };
    for (var i = 0; i < preferredAudioTracks.length; i++) {
        var state_1 = _loop_1(i);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    // no optimal adaptation, just return the first one
    return audioAdaptations[0];
}
// /**
//  * Returns true if the given text adaptation is an optimal choice for a period
//  * given:
//  *
//  *   - the list of text adaptations in the period
//  *
//  *   - an array of preferred text configurations sorted from the most preferred
//  *     to the least preferred.
//  *
//  * @param {Adaptation|null} adaptation
//  * @param {Array.<Adaptation>} audioAdaptations
//  * @param {Array.<Object>} preferredAudioTracks
//  * @returns {Boolean}
//  */
// function isTextAdaptationOptimal(
//   adaptation : Adaptation|null,
//   textAdaptations : Adaptation[],
//   preferredTextTracks : ITextTrackPreference[]
// ) : boolean {
//   if (!textAdaptations.length) {
//     return adaptation === null;
//   }
//   for (let i = 0; i < preferredTextTracks.length; i++) {
//     const preferredTextTrack = preferredTextTracks[i];
//     if (preferredTextTrack === null) {
//       return adaptation === null;
//     }
//     const foundAdaptation = arrayFind(textAdaptations, (textAdaptation) =>
//       (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized &&
//       !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption
//     );
//     if (foundAdaptation !== undefined) {
//       if (adaptation === null) {
//         return false;
//       }
//       return (
//         (foundAdaptation.normalizedLanguage || "") ===
//         (adaptation.normalizedLanguage || "")
//       ) && !!foundAdaptation.isClosedCaption === !!adaptation.isClosedCaption;
//     }
//   }
//   return adaptation === null;
// }
/**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * null if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @returns {Adaptation|null}
 */
function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
    if (!textAdaptations.length) {
        return null;
    }
    var _loop_2 = function (i) {
        var preferredTextTrack = preferredTextTracks[i];
        if (preferredTextTrack === null) {
            return { value: null };
        }
        var foundAdaptation = arrayFind(textAdaptations, function (textAdaptation) {
            return (textAdaptation.normalizedLanguage || "") === preferredTextTrack.normalized &&
                !!textAdaptation.isClosedCaption === preferredTextTrack.closedCaption;
        });
        if (foundAdaptation !== undefined) {
            return { value: foundAdaptation };
        }
    };
    for (var i = 0; i < preferredTextTracks.length; i++) {
        var state_2 = _loop_2(i);
        if (typeof state_2 === "object")
            return state_2.value;
    }
    // no optimal adaptation
    return null;
}
function findPeriodIndex(periods, period) {
    for (var i = 0; i < periods.length(); i++) {
        var periodI = periods.get(i);
        if (periodI.period.id === period.id) {
            return i;
        }
    }
}
function getPeriodItem(periods, period) {
    for (var i = 0; i < periods.length(); i++) {
        var periodI = periods.get(i);
        if (periodI.period.id === period.id) {
            return periodI;
        }
    }
}


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var constants_1 = __webpack_require__(67);
/**
 * Get state string for a loaded content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */
function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
    if (mediaElement.ended) {
        return constants_1.PLAYER_STATES.ENDED;
    }
    if (stalledStatus) {
        // TODO This is a TypeScript bug. Try to reproduce it easily and
        // open an issue:
        // Basically, putting this line at the top of the file would
        // trigger a TypeScript error down the line.
        var FORCED_ENDED_THRESHOLD = config_1.default.FORCED_ENDED_THRESHOLD;
        // On some old browsers (e.g. Chrome 54), the browser does not
        // emit an 'ended' event in some conditions. Detect if we
        // reached the end by comparing the current position and the
        // duration instead.
        var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);
        if (FORCED_ENDED_THRESHOLD != null &&
            gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
            return constants_1.PLAYER_STATES.ENDED;
        }
        return stalledStatus.reason === "seeking" ?
            constants_1.PLAYER_STATES.SEEKING :
            constants_1.PLAYER_STATES.BUFFERING;
    }
    return isPlaying ? constants_1.PLAYER_STATES.PLAYING : constants_1.PLAYER_STATES.PAUSED;
}
exports.default = getLoadedContentState;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass informations about the current state of the
 * video element to sub-parts of the player.
 */
var objectAssign = __webpack_require__(8);
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(39);
var config_1 = __webpack_require__(2);
var ranges_1 = __webpack_require__(16);
var SAMPLING_INTERVAL_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING = config_1.default.RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config_1.default.RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING = config_1.default.RESUME_GAP_AFTER_BUFFERING, STALL_GAP = config_1.default.STALL_GAP;
/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */
var SCANNED_VIDEO_EVENTS = [
    "canplay",
    "play",
    "progress",
    "seeking",
    "seeked",
    "loadedmetadata",
    "canplay",
    "ratechange",
];
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @returns {Number}
 */
function getResumeGap(stalled) {
    if (!stalled) {
        return 0;
    }
    switch (stalled.reason) {
        case "seeking":
            return RESUME_GAP_AFTER_SEEKING;
        case "not-ready":
            return RESUME_GAP_AFTER_NOT_ENOUGH_DATA;
        default:
            return RESUME_GAP_AFTER_BUFFERING;
    }
}
/**
 * TODO I just don't get it for this one.
 * gap + range.end ??? HELP
 * @param {Number} gap
 * @param {Object} range
 * @param {Number} duration
 * @returns {Boolean}
 */
function isEnding(bufferGap, currentRange, duration) {
    return currentRange != null &&
        (duration - (bufferGap + currentRange.end)) <= STALL_GAP;
}
/**
 * Generate a basic timings object from the video element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} video
 * @param {string} currentState
 * @returns {Object}
 */
function getVideoInfos(video, currentState) {
    var buffered = video.buffered, currentTime = video.currentTime, duration = video.duration, ended = video.ended, paused = video.paused, playbackRate = video.playbackRate, readyState = video.readyState, seeking = video.seeking;
    return {
        bufferGap: ranges_1.getLeftSizeOfRange(buffered, currentTime),
        buffered: buffered,
        currentRange: ranges_1.getRange(buffered, currentTime),
        currentTime: currentTime,
        duration: duration,
        ended: ended,
        paused: paused,
        playbackRate: playbackRate,
        readyState: readyState,
        seeking: seeking,
        state: currentState,
    };
}
/**
 * Infer stalled status of the video based on:
 *   - the return of the function getVideoInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */
function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
    var currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState, ended = currentTimings.ended;
    var prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime;
    var ending = isEnding(bufferGap, currentRange, duration);
    var canStall = (readyState >= 1 &&
        currentState !== "loadedmetadata" &&
        !prevStalled &&
        !(ending || ended));
    var shouldStall;
    var shouldUnstall;
    if (withMediaSource) {
        if (canStall &&
            (bufferGap <= STALL_GAP || bufferGap === Infinity || readyState === 1)) {
            shouldStall = true;
        }
        else if (prevStalled &&
            readyState > 1 &&
            bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending || ended)) {
            shouldUnstall = true;
        }
    }
    // when using a direct file, the video will stall and unstall on its
    // own, so we only try to detect when the video timestamp has not changed
    // between two consecutive timeupdates
    else {
        if (canStall &&
            (!paused && currentState === "timeupdate" &&
                prevState === "timeupdate" && currentTime === prevTime ||
                currentState === "seeking" && bufferGap === Infinity)) {
            shouldStall = true;
        }
        else if (prevStalled &&
            (currentState !== "seeking" && currentTime !== prevTime ||
                currentState === "canplay" ||
                bufferGap < Infinity &&
                    (bufferGap > getResumeGap(prevStalled) || ending || ended))) {
            shouldUnstall = true;
        }
    }
    if (shouldStall) {
        var reason = void 0;
        if (currentState === "seeking" || currentTimings.seeking) {
            reason = "seeking";
        }
        else if (readyState === 1) {
            reason = "not-ready";
        }
        else {
            reason = "buffering";
        }
        return {
            reason: reason,
            timestamp: Date.now(),
        };
    }
    else if (shouldUnstall) {
        return null;
    }
    else {
        return prevStalled;
    }
}
/**
 * Timings observable.
 *
 * This streams samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * video duration
 *
 * In addition to sampling, this stream also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to <video>
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} video
 * @param {Object} options
 * @returns {Observable}
 */
function createClock(video, _a) {
    var withMediaSource = _a.withMediaSource;
    return Observable_1.Observable.create(function (obs) {
        var lastTimings = objectAssign(getVideoInfos(video, "init"), { stalled: null });
        /**
         * Emit timings sample.
         * Meant to be used as a callback on various async events.
         * @param {Event} [evt] - The Event which triggered the callback, if one.
         */
        function emitSample(evt) {
            var timingEventType = evt && evt.type || "timeupdate";
            var videoTimings = getVideoInfos(video, timingEventType);
            var stalledState = getStalledStatus(lastTimings, videoTimings, withMediaSource);
            // /!\ Mutate videoTimings
            lastTimings = objectAssign(videoTimings, { stalled: stalledState });
            obs.next(lastTimings);
        }
        var interval = withMediaSource
            ? SAMPLING_INTERVAL_MEDIASOURCE
            : SAMPLING_INTERVAL_NO_MEDIASOURCE;
        var intervalID = setInterval(emitSample, interval);
        SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
            return video.addEventListener(eventName, emitSample);
        });
        obs.next(lastTimings);
        return function () {
            clearInterval(intervalID);
            SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
                return video.removeEventListener(eventName, emitSample);
            });
        };
    })
        .multicast(function () { return new ReplaySubject_1.ReplaySubject(1); }) // Always emit the last
        // item on subscription
        .refCount();
}
exports.default = createClock;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
var eme_1 = __webpack_require__(50);
var media_error_handler_1 = __webpack_require__(71);
var speed_manager_1 = __webpack_require__(70);
var stalling_manager_1 = __webpack_require__(69);
var stream_events_1 = __webpack_require__(34);
var video_events_1 = __webpack_require__(68);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {number}
 */
function getDirectFileInitialTime(mediaElement, startAt) {
    if (!startAt) {
        return 0;
    }
    if (startAt.position != null) {
        return startAt.position;
    }
    else if (startAt.wallClockTime != null) {
        return startAt.wallClockTime;
    }
    else if (startAt.fromFirstPosition != null) {
        return startAt.fromFirstPosition;
    }
    var duration = mediaElement.duration;
    if (!duration || !isFinite(duration)) {
        log_1.default.warn("startAt.fromLastPosition set but no known duration, " +
            "beginning at 0.");
        return 0;
    }
    if (startAt.fromLastPosition) {
        return Math.max(0, duration + startAt.fromLastPosition);
    }
    else if (startAt.percentage != null) {
        var percentage = startAt.percentage;
        if (percentage >= 100) {
            return duration;
        }
        else if (percentage <= 0) {
            return 0;
        }
        var ratio = +percentage / 100;
        return duration * ratio;
    }
    return 0;
}
/**
 * Initialize stream playback by merging all Observables that are required to
 * make the system cooperate.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function StreamDirectFile(_a) {
    var autoPlay = _a.autoPlay, clock$ = _a.clock$, keySystems = _a.keySystems, mediaElement = _a.mediaElement, speed$ = _a.speed$, startAt = _a.startAt, url = _a.url;
    /**
     * Observable through which all warning events will be sent.
     * @type {Subject}
     */
    var warning$ = new Subject_1.Subject();
    var warningEvents$ = warning$.map(stream_events_1.default.warning);
    compat_1.clearElementSrc(mediaElement);
    log_1.default.debug("calculating initial time");
    var initialTime = function () {
        return getDirectFileInitialTime(mediaElement, startAt);
    };
    log_1.default.debug("initial time calculated:", initialTime);
    var _b = video_events_1.default(mediaElement, initialTime, autoPlay), initialSeek$ = _b.initialSeek$, loadAndPlay$ = _b.loadAndPlay$;
    /**
     * Create EME Manager, an observable which will manage every EME-related
     * issue.
     * @type {Observable}
     */
    var emeManager$ = eme_1.default(mediaElement, keySystems, warning$);
    /**
     * Translate errors coming from the video element into RxPlayer errors
     * through a throwing Observable.
     * @type {Observable}
     */
    var mediaErrorHandler$ = media_error_handler_1.default(mediaElement);
    /**
     * Create Speed Manager, an observable which will set the speed set by the
     * user on the video element while pausing a little longer while the buffer
     * is stalled.
     * @type {Observable}
     */
    var speedManager$ = speed_manager_1.default(mediaElement, speed$, clock$, {
        pauseWhenStalled: true,
    }).map(stream_events_1.default.speedChanged);
    /**
     * Create Stalling Manager, an observable which will try to get out of
     * various infinite stalling issues
     * @type {Observable}
     */
    var stallingManager$ = stalling_manager_1.default(mediaElement, clock$)
        .map(stream_events_1.default.stalled);
    var loadedEvent$ = loadAndPlay$
        .mapTo(stream_events_1.default.loaded());
    var linkURL$ = compat_1.setElementSrc$(mediaElement, url)
        .ignoreElements();
    var mutedInitialSeek$ = initialSeek$
        .ignoreElements();
    var directFile$ = Observable_1.Observable.merge(loadedEvent$, mutedInitialSeek$, emeManager$, // TODO RxJS do something weird here
    mediaErrorHandler$, // TODO RxJS do something weird here
    speedManager$, stallingManager$, linkURL$);
    return Observable_1.Observable.merge(directFile$, warningEvents$);
}
exports.default = StreamDirectFile;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */
function takeFirstSet() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var i = 0;
    var len = args.length;
    while (i < len) {
        if (args[i] != null) {
            return args[i];
        }
        i++;
    }
}
exports.default = takeFirstSet;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(16);
var takeFirstSet_1 = __webpack_require__(122);
var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config_1.default.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config_1.default.MAX_BUFFERED_DISTANCE, MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;
/**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentBookkeeper
 */
var SegmentBookkeeper = /** @class */ (function () {
    function SegmentBookkeeper() {
        /**
         * The inventory keep track of all the segments which should be currently
         * in the browser's memory.
         * This array contains objects, each being related to a single downloaded
         * segment which is at least partially added in a source buffer.
         * @type {Array.<Object>}
         */
        this.inventory = [];
    }
    /**
     * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
     * given (coming from the source buffer).
     * @param {TimeRanges}
     *
     * TODO implement management of segments whose end is not known
     */
    SegmentBookkeeper.prototype.synchronizeBuffered = function (buffered) {
        var inventory = this.inventory;
        var ranges = ranges_1.convertToRanges(buffered);
        /**
         * Current inventory index considered.
         * @type {Number}
         */
        var inventoryIndex = 0;
        /**
         * Current segmentInfos considered
         * @type {Object}
         */
        var thisSegment = inventory[0];
        var rangesLength = ranges.length;
        for (var i = 0; i < rangesLength; i++) {
            if (thisSegment == null) {
                // If thisSegment is not set, it means that we arrived at the end of
                // our inventory.
                // This TimeRange do not link to any segment and neither will any
                // subsequent one.
                // (It may be linked to another adaptation, for example)
                return;
            }
            var _a = ranges[i], rangeStart = _a.start, rangeEnd = _a.end;
            // if current TimeRange is too small to contain a segment, go to next one
            if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
                continue;
            }
            /**
             * Inventory index of the last segment not contained in the current range.
             * Will be used to know how many segments have been garbage collected.
             * @type {Number}
             */
            var indexBefore = inventoryIndex;
            // Find the first segment either within this TimeRange or past it:
            // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
            // start of that range.
            while (thisSegment &&
                // TODO better way to indicate to typescript that all is well here
                (takeFirstSet_1.default(thisSegment.bufferedEnd, thisSegment.end)
                    - rangeStart)
                    < MINIMUM_SEGMENT_SIZE) {
                thisSegment = inventory[++inventoryIndex];
            }
            /**
             * Contains the end of the last garbage-collected segment before
             * thisSegment.
             * Might be useful to infer later the bufferedStart of thisSegment.
             *
             * -1 if no segment have been garbage-collected before thisSegment.
             * @type {Number}
             */
            var lastDeletedSegmentEnd = -1;
            // remove garbage-collected segments
            // (not in that TimeRange nor in the previous one)
            var numberOfSegmentToDelete = inventoryIndex - indexBefore;
            if (numberOfSegmentToDelete > 0) {
                // last garbage-collected segment
                var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
                // TODO better way to indicate to typescript that all is well here
                lastDeletedSegmentEnd = takeFirstSet_1.default(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);
                // mutate inventory
                inventory.splice(indexBefore, numberOfSegmentToDelete);
                inventoryIndex = indexBefore;
            }
            // if no segment is left for that range (or any other one), quit
            if (thisSegment == null) {
                return;
            }
            // Infer the bufferedStart for this segment, and the bufferedStart and
            // bufferedEnd for the following segments included in that range.
            //
            // If the current segment is actually completely outside that range (it
            // is contained in one of the next one), skip that part.
            if (rangeEnd -
                // TODO better way to indicate to typescript that all is well here
                takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start)
                >= MINIMUM_SEGMENT_SIZE) {
                // set the bufferedStart of the first segment in that range
                if (thisSegment.bufferedStart != null &&
                    thisSegment.bufferedStart < rangeStart) {
                    // the segment appears to have been partially garbage collected:
                    // Update bufferedStart
                    thisSegment.bufferedStart = rangeStart;
                }
                else if (thisSegment.bufferedStart == null) {
                    if (lastDeletedSegmentEnd !== -1 &&
                        lastDeletedSegmentEnd > rangeStart &&
                        thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE) {
                        thisSegment.bufferedStart = lastDeletedSegmentEnd;
                    }
                    else if (thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE) {
                        thisSegment.bufferedStart = rangeStart;
                    }
                    else {
                        thisSegment.bufferedStart = thisSegment.start;
                    }
                }
                thisSegment = inventory[++inventoryIndex];
                // Make contiguous until first segment outside that range
                // (i.e until the start of the next segment can not constitute a segment
                // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
                while (thisSegment &&
                    (rangeEnd -
                        // TODO better way to indicate to typescript that all is well here
                        takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start))
                        >= MINIMUM_SEGMENT_SIZE) {
                    var prevSegment = inventory[inventoryIndex - 1];
                    // those segments are contiguous, we have no way to infer their real
                    // end
                    if (prevSegment.bufferedEnd == null) {
                        prevSegment.bufferedEnd = prevSegment.end;
                    }
                    thisSegment.bufferedStart = prevSegment.bufferedEnd;
                    thisSegment = inventory[++inventoryIndex];
                }
            }
            // update the bufferedEnd of the last segment in that range
            var lastSegmentInRange = inventory[inventoryIndex - 1];
            if (lastSegmentInRange) {
                if (lastSegmentInRange.bufferedEnd != null &&
                    lastSegmentInRange.bufferedEnd > rangeEnd) {
                    // the segment appears to have been partially garbage collected:
                    // Update bufferedEnd
                    lastSegmentInRange.bufferedEnd = rangeEnd;
                }
                else if (lastSegmentInRange.bufferedEnd == null) {
                    lastSegmentInRange.bufferedEnd =
                        rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ?
                            rangeEnd : lastSegmentInRange.end;
                }
            }
        }
        // if we still have segments left, they are not affiliated to any range.
        // They might have been garbage collected, delete them from here.
        if (thisSegment) {
            inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
        }
    };
    /**
     * Add a new segment in the inventory.
     *
     * Note: As new segments can "replace" partially or completely old ones, we
     * have to perform a complex logic and might update previously added segments.
     *
     * @param {Object} segment
     * @param {Number} start - start time of the segment, in seconds
     * @param {Number|undefined} end - end time of the segment, in seconds. Can
     * be undefined in some rare cases
     * @param {Number} bitrate - bitrate of the representation the segment is in
     */
    SegmentBookkeeper.prototype.insert = function (period, adaptation, representation, segment, start, end) {
        // TODO (*very* low-priority) manage segments whose end is unknown (rare but
        // could eventually happen).
        // This should be properly managed in this method, but it is not in some
        // other methods of this class, so I decided to not one of those to the
        // inventory by security
        if (end == null) {
            if (false) {}
            // This leads to excessive re-downloads of segment without an ending time.
            log_1.default.warn("SegmentBookkeeper: ending time of the segment not defined");
            return;
        }
        var inventory = this.inventory;
        // infer start and end from the segment data
        // /!\ Can be a little different than their real start/end time in the
        // sourcebuffer.
        // const start = segment.time / segment.timescale;
        // const end = (segment.time + segment.duration) / segment.timescale;
        var newSegment = {
            start: start,
            end: end,
            bufferedStart: undefined,
            bufferedEnd: undefined,
            infos: {
                segment: segment,
                period: period,
                adaptation: adaptation,
                representation: representation,
            },
        };
        // begin by the end as in most use cases this will be faster
        for (var i = inventory.length - 1; i >= 0; i--) {
            var segmentI = inventory[i];
            if ((segmentI.start /* - SEGMENT_EPSILON */) <= start) {
                if ((segmentI.end /* - SEGMENT_EPSILON */) <= start) {
                    // our segment is after, push it after this one
                    //
                    // Case 1:
                    //   segmentI     : |------|
                    //   newSegment   :        |------|
                    //
                    // Case 2:
                    //   segmentI     : |------|
                    //   newSegment   :          |------|
                    this.inventory.splice(i + 1, 0, newSegment);
                    return;
                }
                else { // /!\ also goes here if end is undefined
                    if (segmentI.start >= (start /* - SEGMENT_EPSILON */)) {
                        // In those cases, replace
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   : |-------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   : |----------|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   : |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   : |------|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   : |???*
                        //
                        // *|??? - unknown end
                        this.inventory.splice(i, 1, newSegment);
                        return;
                    }
                    else {
                        // our segment has a "complex" relation with this one,
                        // update the old one end and add this one after it.
                        //
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   :    |------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   :    |----|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   :    |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   :    |----|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   :    |???*
                        //
                        // *|??? - unknown end
                        // (if segment's end is not known yet, it could perfectly
                        // end before the one we're adding now)
                        if (segmentI.end != null) {
                            segmentI.end = start;
                        }
                        this.inventory.splice(i + 1, 0, newSegment);
                        return;
                    }
                }
            }
        }
        // if we got here, we are the first segment
        // check bounds of the previous first segment
        var firstSegment = this.inventory[0];
        if (!firstSegment) { // we do not have any segment yet
            this.inventory.push(newSegment);
            return;
        }
        if (end == null) {
            if (firstSegment.start === start) {
                // same beginning, unknown end, just replace
                // Case 1:
                //  firstSegment : |-------|
                //  newSegment   : |???*
                //
                // Case 2:
                //  firstSegment : |???*
                //  newSegment   : |???*
                //
                // *|??? - unknown end
                this.inventory.splice(0, 1, newSegment);
            }
            else {
                // our segment begins before this one, push at the beginning
                // Case 1:
                // firstSegment :   |-------|
                // newSegment   : |???*
                //
                // Case 2:
                // firstSegment :   |???*
                // newSegment   : |???*
                //
                // *|??? - unknown end
                this.inventory.splice(0, 0, newSegment);
            }
            return;
        }
        if (firstSegment.start >= end) {
            // our segment is before, put it before
            // Case 1:
            //  firstSegment :      |----|
            //  newSegment   : |----|
            //
            // Case 2:
            //  firstSegment :        |----|
            //  newSegment   : |----|
            //
            // Case 3:
            //  firstSegment :        |???*
            //  newSegment   : |----|
            //
            // Case 4:
            //  firstSegment :      |???*
            //  newSegment   : |----|
            //
            // *|??? - unknown end
            this.inventory.splice(0, 0, newSegment);
        }
        else if ((firstSegment.end /* - SEGMENT_EPSILON */) <= end) {
            // Our segment is bigger, replace the first
            // Case 1:
            //  firstSegment :   |---|
            //  newSegment   : |-------|
            //
            // Case 2:
            //  firstSegment :   |-----|
            //  newSegment   : |-------|
            this.inventory.splice(0, 1, newSegment);
        }
        else {
            // our segment has a "complex" relation with the first one,
            // update the old one start and add this one before it.
            // Case 1:
            //  firstSegment :    |------|
            //  newSegment   : |------|
            //
            // Case 2:
            // firstSegment :   |???*
            // newSegment   : |-----|
            //
            // *|??? - unknown end
            firstSegment.start = end;
            this.inventory.splice(0, 0, newSegment);
        }
    };
    /**
     * Returns segment infos for a segment corresponding to the given time,
     * duration and timescale.
     *
     * Returns null if either:
     *   - no segment can be linked exactly to the given time/duration
     *   - a segment is linked to this information, but is currently considered
     *     "incomplete" to be playable, in the sourceBuffer. We check if all
     *     needed data for playback (from wanted range) is loaded.
     *
     * The main purpose of this method is to know if the segment asked should be
     * downloaded (or re-downloaded).
     *
     * /!\ Make sure that this class is synchronized with the sourceBuffer
     * (see addBufferedInfos method of the same class) before calling this method,
     * as it depends on it to categorize "incomplete" from "complete" segments.
     *
     * @param {Object} wantedRange
     * @param {Number} time
     * @param {Number} duration
     * @param {Number} timescale
     * @returns {Object|null}
     */
    SegmentBookkeeper.prototype.hasPlayableSegment = function (wantedRange, segmentInfos) {
        var time = segmentInfos.time, duration = segmentInfos.duration, timescale = segmentInfos.timescale;
        var inventory = this.inventory;
        for (var i = inventory.length - 1; i >= 0; i--) {
            var currentSegmentI = inventory[i];
            var prevSegmentI = inventory[i - 1];
            var nextSegmentI = inventory[i + 1];
            var segment = currentSegmentI.infos.segment;
            var _time = time;
            var _duration = duration;
            if (segment.timescale !== timescale) {
                // Note: we could get rounding errors here
                _time = (time * segment.timescale) / timescale;
                _duration = (duration * segment.timescale) / timescale;
            }
            if (segment.time === _time && segment.duration === _duration) {
                // false negatives are better than false positives here.
                // When impossible to know, say the segment is not complete
                if (hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI)) {
                    if (hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) {
                        return currentSegmentI;
                    }
                }
            }
        }
        return null;
        // -- Helpers
        /*
         * Check if segment can be evaluated.
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */
        function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
            if ((prevSegmentI && prevSegmentI.bufferedEnd == null) ||
                currentSegmentI.bufferedStart == null) {
                return false;
            }
            if ((nextSegmentI && nextSegmentI.bufferedStart == null) ||
                currentSegmentI.bufferedEnd == null) {
                return false;
            }
            return true;
        }
        /* Returns true if the segment given can be played for the wanted range.
         * @param {Object} _wantedRange
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */
        function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
            if (!prevSegmentI ||
                prevSegmentI.bufferedEnd == null ||
                currentSegmentI.bufferedStart == null ||
                prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
                if (currentSegmentI.bufferedStart == null) {
                    return false;
                }
                var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
                if (_wantedRange.start > currentSegmentI.start) {
                    var wantedDiff = currentSegmentI.bufferedStart - _wantedRange.start;
                    if (wantedDiff > 0 && timeDiff
                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
                else {
                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
            }
            if (currentSegmentI.end === null) {
                return false;
            }
            else if (!nextSegmentI ||
                nextSegmentI.bufferedStart == null ||
                currentSegmentI.bufferedEnd == null ||
                nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
                if (currentSegmentI.bufferedEnd == null) {
                    return false;
                }
                var timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
                if (_wantedRange.end < currentSegmentI.end) {
                    var wantedDiff = _wantedRange.end - currentSegmentI.bufferedEnd;
                    if (wantedDiff > 0 && timeDiff
                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
                else {
                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
            }
            return true;
        }
    };
    /**
     * Empty the current inventory
     */
    SegmentBookkeeper.prototype.reset = function () {
        this.inventory = [];
    };
    return SegmentBookkeeper;
}());
exports.default = SegmentBookkeeper;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
var source_buffers_1 = __webpack_require__(35);
var stream_events_1 = __webpack_require__(34);
/**
 * Re-fetch the manifest and merge it with the previous version.
 *
 * /!\ Mutates the given manifest
 * @param {Object} manifest
 * @returns {Observable}
 */
function refreshManifest(manifestPipeline, currentManifest) {
    var refreshURL = currentManifest.getUrl();
    if (!refreshURL) {
        log_1.default.warn("Cannot refresh the manifest: no url");
        return Observable_1.Observable.empty();
    }
    return manifestPipeline(refreshURL)
        .do(function (parsed) {
        currentManifest.update(parsed);
    })
        .mapTo(stream_events_1.default.manifestUpdate(currentManifest));
}
/**
 * Create handler for Buffer events happening only in live contexts.
 * @param {HTMLMediaElement} videoElement
 * @param {Object} manifest
 * @param {Function} fetchManifest
 * @returns {Function}
 */
function liveEventsHandler(videoElement, manifest, fetchManifest) {
    /**
     * Handle individual stream events
     * @param {string} message
     * @returns {Observable}
     */
    return function handleLiveEvents(message) {
        switch (message.type) {
            case "discontinuity-encountered":
                if (source_buffers_1.default.isNative(message.value.bufferType)) {
                    log_1.default.warn("explicit discontinuity seek", message.value.nextTime);
                    videoElement.currentTime = message.value.nextTime;
                }
                break;
            case "needs-manifest-refresh":
                log_1.default.debug("needs manifest to be refreshed");
                // out-of-index messages require a complete reloading of the
                // manifest to refresh the current index
                return refreshManifest(fetchManifest, manifest);
        }
        return Observable_1.Observable.of(message);
    };
}
exports.default = liveEventsHandler;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var timings_1 = __webpack_require__(53);
var DEFAULT_LIVE_GAP = config_1.default.DEFAULT_LIVE_GAP;
/**
 * Returns the calculated initial time for the stream described by the given
 * manifest:
 *   1. if a start time is defined by user, calculate video starting time from
 *      the manifest informations
 *   2. else if the video is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 *
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */
function getInitialTime(manifest, startAt) {
    if (startAt) {
        var _a = timings_1.getBufferLimits(manifest), min = _a[0], max = _a[1];
        if (startAt.position != null) {
            return Math.max(Math.min(startAt.position, max), min);
        }
        else if (startAt.wallClockTime != null) {
            var position = manifest.isLive ?
                startAt.wallClockTime - (manifest.availabilityStartTime || 0) :
                startAt.wallClockTime;
            return Math.max(Math.min(position, max), min);
        }
        else if (startAt.fromFirstPosition != null) {
            var fromFirstPosition = startAt.fromFirstPosition;
            return fromFirstPosition <= 0 ?
                min : Math.min(min + fromFirstPosition, max);
        }
        else if (startAt.fromLastPosition != null) {
            var fromLastPosition = startAt.fromLastPosition;
            return fromLastPosition >= 0 ?
                max : Math.max(min, max + fromLastPosition);
        }
        else if (startAt.percentage != null) {
            var percentage = startAt.percentage;
            if (percentage > 100) {
                return max;
            }
            else if (percentage < 0) {
                return min;
            }
            var ratio = +percentage / 100;
            var extent = max - min;
            return min + extent * ratio;
        }
    }
    if (manifest.isLive) {
        var sgp = manifest.suggestedPresentationDelay;
        return timings_1.getMaximumBufferPosition(manifest) -
            (sgp == null ? DEFAULT_LIVE_GAP : sgp);
    }
    return timings_1.getMinimumBufferPosition(manifest);
}
exports.default = getInitialTime;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(16);
/**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
function BufferGarbageCollector(_a) {
    var queuedSourceBuffer = _a.queuedSourceBuffer, clock$ = _a.clock$, maxBufferBehind$ = _a.maxBufferBehind$, maxBufferAhead$ = _a.maxBufferAhead$;
    return Observable_1.Observable.combineLatest(clock$, maxBufferBehind$, maxBufferAhead$)
        .mergeMap(function (_a) {
        var currentTime = _a[0], maxBufferBehind = _a[1], maxBufferAhead = _a[2];
        return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
    });
}
exports.default = BufferGarbageCollector;
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */
function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
        return Observable_1.Observable.empty();
    }
    var cleanedupRanges = [];
    var _a = ranges_1.getInnerAndOuterTimeRanges(qSourceBuffer.getBuffered(), position), innerRange = _a.innerRange, outerRanges = _a.outerRanges;
    var collectBufferBehind = function () {
        if (!isFinite(maxBufferBehind)) {
            return;
        }
        // begin from the oldest
        for (var i = 0; i < outerRanges.length; i++) {
            var outerRange = outerRanges[i];
            if (position - maxBufferBehind >= outerRange.end) {
                cleanedupRanges.push(outerRange);
            }
            else if (position >= outerRange.end &&
                position - maxBufferBehind > outerRange.start &&
                position - maxBufferBehind < outerRange.end) {
                cleanedupRanges.push({
                    start: outerRange.start,
                    end: position - maxBufferBehind,
                });
            }
        }
        if (innerRange) {
            if (position - maxBufferBehind > innerRange.start) {
                cleanedupRanges.push({
                    start: innerRange.start,
                    end: position - maxBufferBehind,
                });
            }
        }
    };
    var collectBufferAhead = function () {
        if (!isFinite(maxBufferAhead)) {
            return;
        }
        // begin from the oldest
        for (var i = 0; i < outerRanges.length; i++) {
            var outerRange = outerRanges[i];
            if (position + maxBufferAhead <= outerRange.start) {
                cleanedupRanges.push(outerRange);
            }
            else if (position <= outerRange.start &&
                position + maxBufferAhead < outerRange.end &&
                position + maxBufferAhead > outerRange.start) {
                cleanedupRanges.push({
                    start: position + maxBufferAhead,
                    end: outerRange.end,
                });
            }
        }
        if (innerRange) {
            if (position + maxBufferAhead < innerRange.end) {
                cleanedupRanges.push({
                    start: position + maxBufferAhead,
                    end: innerRange.end,
                });
            }
        }
    };
    collectBufferBehind();
    collectBufferAhead();
    var clean$ = Observable_1.Observable.from(cleanedupRanges.map(function (range) {
        log_1.default.debug("cleaning range from source buffer", range);
        return qSourceBuffer.removeBuffer(range);
    }))
        .concatAll()
        .ignoreElements();
    return clean$; // ignoreElements == the Observerable never emits
}


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var events_1 = __webpack_require__(15);
var log_1 = __webpack_require__(1);
/**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
function getUpdatingSourceBuffers(sourceBuffers) {
    var updatingSourceBuffers = [];
    for (var i = 0; i < sourceBuffers.length; i++) {
        var SourceBuffer_1 = sourceBuffers[i];
        if (SourceBuffer_1.updating) {
            updatingSourceBuffers.push(SourceBuffer_1);
        }
    }
    return updatingSourceBuffers;
}
/**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 *
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function triggerEndOfStream(mediaSource) {
    return Observable_1.Observable.defer(function () {
        if (mediaSource.readyState !== "open") {
            // already done, exit
            return Observable_1.Observable.of(null);
        }
        var sourceBuffers = mediaSource.sourceBuffers;
        var updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
        if (!updatingSourceBuffers.length) {
            log_1.default.info("triggering end of stream");
            mediaSource.endOfStream();
            return Observable_1.Observable.of(null);
        }
        var updatedSourceBuffers$ = updatingSourceBuffers
            .map(events_1.onUpdate$);
        return Observable_1.Observable.race(Observable_1.Observable
            .merge.apply(Observable_1.Observable, updatedSourceBuffers$).takeLast(1), events_1.onRemoveSourceBuffers$(sourceBuffers)
            .take(1)).mergeMap(function () {
            return triggerEndOfStream(mediaSource);
        });
    });
}
exports.default = triggerEndOfStream;
/**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function maintainEndOfStream(mediaSource) {
    return triggerEndOfStream(mediaSource)
        .concat(events_1.onSourceOpen$(mediaSource)
        .concatMapTo(triggerEndOfStream(mediaSource)));
}
exports.maintainEndOfStream = maintainEndOfStream;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var MediaError_1 = __webpack_require__(32);
var log_1 = __webpack_require__(1);
/**
 * Side effect that set the media duration in the mediaSource.
 *
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */
function setDurationToMediaSource(mediaSource, duration) {
    var newDuration = duration === Infinity ?
        Number.MAX_VALUE : duration;
    if (mediaSource.duration !== newDuration) {
        log_1.default.info("set duration", mediaSource.duration);
        mediaSource.duration = newDuration;
    }
}
exports.setDurationToMediaSource = setDurationToMediaSource;
/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the video's src (stop the video)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} video
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */
function resetMediaSource(video, mediaSource, mediaSourceURL) {
    if (mediaSource && mediaSource.readyState !== "closed") {
        var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers;
        for (var i = sourceBuffers.length - 1; i >= 0; i--) {
            var sourceBuffer = sourceBuffers[i];
            try {
                if (readyState === "open") {
                    log_1.default.info("removing SourceBuffer from mediaSource", sourceBuffer);
                    sourceBuffer.abort();
                }
                mediaSource.removeSourceBuffer(sourceBuffer);
            }
            catch (e) {
                log_1.default.warn("error while disposing SourceBuffer", e);
            }
        }
        if (sourceBuffers.length) {
            log_1.default.warn("not all SourceBuffers could have been removed.");
        }
    }
    compat_1.clearElementSrc(video);
    if (mediaSourceURL) {
        try {
            log_1.default.debug("revoking previous URL");
            URL.revokeObjectURL(mediaSourceURL);
        }
        catch (e) {
            log_1.default.warn("error while revoking the media source URL", e);
        }
    }
}
exports.resetMediaSource = resetMediaSource;
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * video element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the video element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the video.src is cleaned, MediaSource sourceBuffers and
 * customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} video
 * @returns {Observable}
 */
function createMediaSource(video) {
    return Observable_1.Observable.create(function (observer) {
        if (!compat_1.MediaSource_) {
            throw new MediaError_1.default("MEDIA_SOURCE_NOT_SUPPORTED", null, true);
        }
        // make sure the media has been correctly reset
        resetMediaSource(video, null, video.src || null);
        log_1.default.info("creating MediaSource");
        var mediaSource = new compat_1.MediaSource_();
        var objectURL = URL.createObjectURL(mediaSource);
        log_1.default.info("attaching MediaSource URL to video element", objectURL);
        video.src = objectURL;
        observer.next(mediaSource);
        return function () {
            resetMediaSource(video, mediaSource, objectURL);
        };
    });
}
exports.default = createMediaSource;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var Observable_1 = __webpack_require__(0);
var timings_1 = __webpack_require__(53);
/**
 * Create clock$ and seekings$ Observables:
 *   - clock$ is the given clock$ observable with added informations.
 *   - seekings$ emits each time the player go in a seeking state.
 * @param {Object} manifest
 * @param {Observable} streamClock$
 * @param {Observable} initialSeek$
 * @param {Number} startTime
 * @returns {Object}
 */
function createBufferClock(manifest, streamClock$, initialSeek$, startTime) {
    /**
     * Time offset is an offset to add to the timing's current time to have
     * the "real" position.
     * For now, this is seen when the video has not yet seeked to its initial
     * position, the currentTime will most probably be 0 where the effective
     * starting position will be _startTime_.
     * Thus we initially set a timeOffset equal to startTime.
     * @type {Number}
     */
    var timeOffset = startTime;
    var updateTimeOffset$ = initialSeek$
        .take(1)
        .do(function () {
        timeOffset = 0; // (initial seek performed)
    })
        .ignoreElements();
    var clock$ = streamClock$
        .map(function (timing) {
        return objectAssign({
            liveGap: manifest.isLive ?
                timings_1.getMaximumBufferPosition(manifest) - timing.currentTime :
                Infinity,
            timeOffset: timeOffset,
        }, timing);
    });
    return Observable_1.Observable.merge(clock$, updateTimeOffset$);
}
exports.default = createBufferClock;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
var sorted_list_1 = __webpack_require__(44);
var source_buffers_1 = __webpack_require__(35);
/**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a PeriodBuffer for every defined BUFFER_TYPES.
 *
 * Emit null if no Period has PeriodBuffers for all types.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video PeriodBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer informations when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer informations when
 * one is removed.
 * @returns {Observable}
 */
function ActivePeriodEmitter(addPeriodBuffer$, removePeriodBuffer$) {
    var periodsList = new sorted_list_1.default(function (a, b) { return a.period.start - b.period.start; });
    var onItemAdd$ = addPeriodBuffer$
        .do(function (_a) {
        var period = _a.period, type = _a.type;
        // add or update the periodItem
        var periodItem = periodsList.find(function (p) { return p.period === period; });
        if (!periodItem) {
            periodItem = {
                period: period,
                buffers: new Set(),
            };
            periodsList.add(periodItem);
        }
        if (periodItem.buffers.has(type)) {
            log_1.default.warn("Buffer type " + type + " already added to the period");
        }
        periodItem.buffers.add(type);
    });
    var onItemRemove$ = removePeriodBuffer$
        .do(function (_a) {
        var period = _a.period, type = _a.type;
        if (!periodsList || periodsList.length() === 0) {
            log_1.default.error("ActivePeriodStore: cannot remove, no period is active.");
            return;
        }
        var periodItem = periodsList.find(function (p) { return p.period === period; });
        if (!periodItem) {
            log_1.default.error("ActivePeriodStore: cannot remove, unknown period.");
            return;
        }
        periodItem.buffers.delete(type);
        if (!periodItem.buffers.size) {
            periodsList.removeFirst(periodItem);
        }
    });
    return Observable_1.Observable.merge(onItemAdd$, onItemRemove$)
        .map(function () {
        var head = periodsList.head();
        if (!head) {
            return null;
        }
        var periodItem = periodsList.find(function (p) { return isBufferListFull(p.buffers); });
        return periodItem != null ? periodItem.period : null;
    }).distinctUntilChanged();
}
exports.default = ActivePeriodEmitter;
/**
 * Returns true if the set of given buffer types is complete (has all possible
 * types).
 * @param {Set} bufferList
 * @returns {Boolean}
 */
function isBufferListFull(bufferList) {
    return bufferList.size >= source_buffers_1.BUFFER_TYPES.length;
}


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 */
var InitializationSegmentCache = /** @class */ (function () {
    function InitializationSegmentCache() {
        this._cache = new WeakMap();
    }
    /**
     * @param {Object} obj
     * @param {Object} obj.representation
     * @param {Object} obj.segment
     * @param {*} response
     */
    InitializationSegmentCache.prototype.add = function (_a, response) {
        var representation = _a.representation, segment = _a.segment;
        if (segment.isInit) {
            this._cache.set(representation, response);
        }
    };
    /**
     * @param {Object} obj
     * @param {Object} obj.segment
     * @returns {*} response
     * TODO just add segment directly, not in an object?
     */
    InitializationSegmentCache.prototype.get = function (_a) {
        var representation = _a.representation, segment = _a.segment;
        if (segment.isInit) {
            var value = this._cache.get(representation);
            if (value != null) {
                return value;
            }
        }
        return null;
    };
    return InitializationSegmentCache;
}());
exports.default = InitializationSegmentCache;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(39);
var Subject_1 = __webpack_require__(7);
var config_1 = __webpack_require__(2);
var errors_1 = __webpack_require__(6);
var array_includes_1 = __webpack_require__(13);
var initialization_segment_cache_1 = __webpack_require__(131);
var log_1 = __webpack_require__(1);
var sorted_list_1 = __webpack_require__(44);
var buffer_1 = __webpack_require__(82);
var source_buffers_1 = __webpack_require__(35);
var active_period_emitter_1 = __webpack_require__(130);
var stream_events_1 = __webpack_require__(34);
/**
 * Create and manage the various Buffer Observables needed for the content to
 * stream:
 *
 *   - Create or dispose SourceBuffers depending on the chosen adaptations.
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit events as Period or Adaptations change or as new Period are
 *     prepared.
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 *
 * @param {Object} content
 * @param {Manifest} content.manifest
 * @param {Period} content.period - The first period to play in the content
 * @param {Observable} clock$ - Emit current informations about the content
 * being played. Also regulate the frequencies of the time the Buffer check
 * for new its status / new segments.
 * @param {BufferManager} bufferManager - Will be used to create new
 * AdaptationBuffers at will
 * @param {SourceBufferManager} sourceBufferManager - Will be used to lazily
 * create SourceBuffer instances associated with the current content.
 * @param {SegmentPipelinesManager} segmentPipelinesManager - Used to download
 * segments.
 * @param {WeakMapMemory} segmentBookkeeper - Allow to easily retrieve
 * or create a unique SegmentBookkeeper per SourceBuffer
 * @param {WeakMapMemory} garbageCollectors - Allows to easily create a
 * unique Garbage Collector per SourceBuffer
 * @param {Object} options
 * @param {Subject} errorStream - Subject to emit minor errors
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 *
 * TODO Special garbage collection for text and image buffers, as we want to
 * clean it for potentially very long sessions.
 */
function BuffersHandler(content, clock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, options, errorStream) {
    var manifest = content.manifest;
    var firstPeriod = content.period;
    // Initialize all native source buffers from the first period at the same
    // time.
    // We cannot lazily create native sourcebuffers since the spec does not
    // allow adding them during playback.
    //
    // From https://w3c.github.io/media-source/#methods
    //    For example, a user agent may throw a QuotaExceededError
    //    exception if the media element has reached the HAVE_METADATA
    //    readyState. This can occur if the user agent's media engine
    //    does not support adding more tracks during playback.
    createNativeSourceBuffersForPeriod(sourceBufferManager, firstPeriod);
    var addPeriodBuffer$ = new Subject_1.Subject();
    var removePeriodBuffer$ = new Subject_1.Subject();
    /**
     * Every PeriodBuffers for every possible types
     * @type {Array.<Observable>}
     */
    var buffersArray = source_buffers_1.BUFFER_TYPES
        .map(function (bufferType) {
        return manageEveryBuffers(bufferType, firstPeriod)
            .do(function (evt) {
            if (evt.type === "periodBufferReady") {
                addPeriodBuffer$.next(evt.value);
            }
            else if (evt.type === "periodBufferCleared") {
                removePeriodBuffer$.next(evt.value);
            }
        }).share();
    });
    /**
     * Emits the active Period every time it changes
     * @type {Observable}
     */
    var activePeriod$ = active_period_emitter_1.default(addPeriodBuffer$, removePeriodBuffer$)
        .filter(function (period) { return !!period; });
    /**
     * Emits the activePeriodChanged events every time the active Period changes.
     * @type {Observable}
     */
    var activePeriodChanged$ = activePeriod$
        .do(function (period) {
        log_1.default.info("new active period", period);
    })
        .map(function (period) { return stream_events_1.default.activePeriodChanged(period); });
    /**
     * Emits an "end-of-stream" event once every PeriodBuffer are complete.
     * @type {Observable}
     */
    var streamHasEnded$ = buffersAreComplete.apply(void 0, buffersArray).map(function (areComplete) {
        return areComplete ? stream_events_1.default.endOfStream() : stream_events_1.default.resumeStream();
    });
    return Observable_1.Observable.merge.apply(Observable_1.Observable, [activePeriodChanged$].concat(buffersArray, [streamHasEnded$]));
    /**
     * Manage creation and removal of Buffers for every Periods.
     *
     * Works by creating consecutive buffers through the
     * manageConsecutivePeriodBuffers function, and restarting it when the clock
     * goes out of the bounds of these buffers.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @returns {Observable}
     */
    function manageEveryBuffers(bufferType, basePeriod) {
        /**
         * Keep a PeriodList for cases such as seeking ahead/before the
         * buffers already created.
         * When that happens, interrupt the previous buffers and create one back
         * from the new initial period.
         * @type {ConsecutivePeriodList}
         */
        var periodList = new sorted_list_1.default(function (a, b) { return a.start - b.start; });
        /**
         * Returns true if the given time is either:
         *   - less than the start of the chronologically first Period
         *   - more than the end of the chronologically last Period
         * @param {number} time
         * @returns {boolean}
         */
        function isOutOfPeriodList(time) {
            var head = periodList.head();
            var last = periodList.last();
            if (head == null || last == null) { // if no period
                return true;
            }
            return head.start > time ||
                (last.end || Infinity) < time;
        }
        /**
         * Destroy the current set of consecutive buffers.
         * Used when the clocks goes out of the bounds of those, e.g. when the user
         * seeks.
         * We can then re-create consecutive buffers, from the new point in time.
         * @type {Subject}
         */
        var destroyCurrentBuffers = new Subject_1.Subject();
        var restartBuffers$ = clock$
            .filter(function (_a) {
            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;
            if (!manifest.getPeriodForTime(timeOffset + currentTime)) {
                // TODO Manage out-of-manifest situations
                return false;
            }
            return isOutOfPeriodList(timeOffset + currentTime);
        })
            .take(1)
            .do(function (_a) {
            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;
            log_1.default.info("Current position out of the bounds of the active periods," +
                "re-creating buffers.", bufferType, currentTime + timeOffset);
            destroyCurrentBuffers.next();
        })
            .mergeMap(function (_a) {
            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;
            var newInitialPeriod = manifest.getPeriodForTime(currentTime + timeOffset);
            if (newInitialPeriod == null) {
                throw new errors_1.MediaError("MEDIA_TIME_NOT_FOUND", null, true);
            }
            else {
                // Note: For this to work, manageEveryBuffers should always emit the
                // "periodBufferReady" event for the new InitialPeriod synchronously
                return manageEveryBuffers(bufferType, newInitialPeriod);
            }
        });
        var currentBuffers$ = manageConsecutivePeriodBuffers(bufferType, basePeriod, destroyCurrentBuffers).do(function (message) {
            if (message.type === "periodBufferReady") {
                periodList.add(message.value.period);
            }
            else if (message.type === "periodBufferCleared") {
                periodList.removeFirst(message.value.period);
            }
        }).share(); // as always, with side-effects
        return Observable_1.Observable.merge(currentBuffers$, restartBuffers$);
    }
    /**
     * Manage creation and removal of Buffers for consecutive Periods.
     *
     * This function is called recursively for each successive Periods as needed.
     *
     * This function does not guarantee creation/destruction of the right Buffers
     * when the user seeks or rewind in the content.
     * It only manages regular playback, another layer should be used to manage
     * those cases.
     *
     * You can know about buffers creation and destruction respectively through
     * the "periodBufferReady" and "periodBufferCleared" events.
     *
     * The "periodBufferReady" related to the given period should be sent synchronously
     * on subscription.
     * Further "periodBufferReady" for further Periods should be sent each time the
     * Buffer for the previous Buffer is full.
     *
     * Buffers for each Period are cleared ("periodBufferCleared" event) either:
     *   - when it has finished to play (currentTime is after it)
     *   - when one of the older Buffers becomes active again, in which case the
     *     Buffers coming after will be cleared from the newest to the oldest.
     *   - when the destroy$ observable emits, in which case every created Buffer
     *     here will be cleared from the newest to the oldest.
     *
     * TODO The code here can surely be greatly simplified.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @param {Observable} destroy$ - Emit when/if all created Buffer from this
     * point should be destroyed.
     * @returns {Observable}
     */
    function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
        log_1.default.info("creating new Buffer for", bufferType, basePeriod);
        /**
         * Emits the chosen adaptation for the current type.
         * @type {ReplaySubject}
         */
        var adaptation$ = new ReplaySubject_1.ReplaySubject(1);
        /**
         * Emits the Period of the next Period Buffer when it can be created.
         * @type {Subject}
         */
        var createNextPeriodBuffer$ = new Subject_1.Subject();
        /**
         * Emits when the Buffers for the next Periods should be destroyed, if
         * created.
         * @type {Subject}
         */
        var destroyNextBuffers$ = new Subject_1.Subject();
        /**
         * Emits when the current position goes over the end of the current buffer.
         * @type {Subject}
         */
        var endOfCurrentBuffer$ = clock$
            .filter(function (_a) {
            var currentTime = _a.currentTime, timeOffset = _a.timeOffset;
            return !!basePeriod.end && (currentTime + timeOffset) >= basePeriod.end;
        });
        /**
         * Create Period Buffer for the next Period.
         * @type {Observable}
         */
        var nextPeriodBuffer$ = createNextPeriodBuffer$
            .exhaustMap(function (nextPeriod) {
            return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
        });
        /**
         * Allows to destroy each created Buffer, from the newest to the oldest,
         * once destroy$ emits.
         * @type {Observable}
         */
        var destroyAll$ = destroy$
            .take(1)
            .do(function () {
            // first complete createNextBuffer$ to allow completion of the
            // nextPeriodBuffer$ observable once every further Buffers have been
            // cleared.
            createNextPeriodBuffer$.complete();
            // emit destruction signal to the next Buffer first
            destroyNextBuffers$.next();
            destroyNextBuffers$.complete(); // we do not need it anymore
        }).share(); // share side-effects
        /**
         * Will emit when the current buffer should be destroyed.
         * @type {Observable}
         */
        var killCurrentBuffer$ = Observable_1.Observable.merge(endOfCurrentBuffer$, destroyAll$);
        var periodBuffer$ = createPeriodBuffer(bufferType, basePeriod, adaptation$)
            .mergeMap(function (evt) {
            var type = evt.type;
            if (type === "full-buffer") {
                /**
                 * The Period coming just after the current one.
                 * @type {Period|undefined}
                 */
                var nextPeriod = manifest.getPeriodAfter(basePeriod);
                if (nextPeriod == null) {
                    // no more period, emits  event
                    return Observable_1.Observable.of(stream_events_1.default.bufferComplete(bufferType));
                }
                else {
                    // current buffer is full, create the next one if not
                    createNextPeriodBuffer$.next(nextPeriod);
                }
            }
            else if (type === "active-buffer") {
                // current buffer is active, destroy next buffer if created
                destroyNextBuffers$.next();
            }
            return Observable_1.Observable.of(evt);
        })
            .share();
        /**
         * Buffer for the current Period.
         * @type {Observable}
         */
        var currentBuffer$ = Observable_1.Observable.of(stream_events_1.default.periodBufferReady(bufferType, basePeriod, adaptation$))
            .concat(periodBuffer$)
            .takeUntil(killCurrentBuffer$)
            .concat(Observable_1.Observable.of(stream_events_1.default.periodBufferCleared(bufferType, basePeriod))
            .do(function () {
            log_1.default.info("destroying buffer for", bufferType, basePeriod);
        }));
        return Observable_1.Observable.merge(currentBuffer$, nextPeriodBuffer$, destroyAll$.ignoreElements());
    }
    /**
     * Create single PeriodBuffer Observable:
     *   - Lazily create (or reuse) a SourceBuffer for the given type.
     *   - Create a Buffer linked to an Adaptation each time it changes, to
     *     download and append the corresponding Segments in the SourceBuffer.
     *   - Announce when the Buffer is full or is awaiting new Segments through
     *     events
     *
     * /!\ This Observable has multiple side-effects (creation of SourceBuffers,
     * downloading and appending of Segments etc.) on subscription.
     *
     * @param {string} bufferType
     * @param {Period} period - The period concerned
     * @param {Observable} adaptation$ - Emit the chosen adaptation.
     * Emit null to deactivate a type of adaptation
     * @returns {Observable}
     */
    function createPeriodBuffer(bufferType, period, adaptation$) {
        return adaptation$.switchMap(function (adaptation) {
            if (adaptation == null) {
                log_1.default.info("set no " + bufferType + " Adaptation", period);
                var cleanBuffer$ = void 0;
                if (sourceBufferManager.has(bufferType)) {
                    log_1.default.info("clearing previous " + bufferType + " SourceBuffer");
                    var _queuedSourceBuffer = sourceBufferManager.get(bufferType);
                    cleanBuffer$ = _queuedSourceBuffer
                        .removeBuffer({ start: period.start, end: period.end || Infinity })
                        .mapTo(null);
                }
                else {
                    cleanBuffer$ = Observable_1.Observable.of(null);
                }
                return cleanBuffer$
                    .mapTo(stream_events_1.default.adaptationChange(bufferType, null, period))
                    .concat(buffer_1.createFakeBuffer(clock$, wantedBufferAhead$, bufferType, { manifest: manifest, period: period }));
            }
            log_1.default.info("updating " + bufferType + " adaptation", adaptation, period);
            // 1 - create or reuse the SourceBuffer
            var queuedSourceBuffer;
            if (sourceBufferManager.has(bufferType)) {
                log_1.default.info("reusing a previous SourceBuffer for the type", bufferType);
                queuedSourceBuffer = sourceBufferManager.get(bufferType);
            }
            else {
                var codec = getFirstDeclaredMimeType(adaptation);
                var sourceBufferOptions = bufferType === "text" ?
                    options.textTrackOptions : undefined;
                queuedSourceBuffer = sourceBufferManager
                    .createSourceBuffer(bufferType, codec, sourceBufferOptions);
            }
            // 2 - create or reuse the associated BufferGarbageCollector and
            // SegmentBookkeeper
            var bufferGarbageCollector$ = garbageCollectors.get(queuedSourceBuffer);
            var segmentBookkeeper = segmentBookkeepers.get(queuedSourceBuffer);
            // TODO Clean previous QueuedSourceBuffer for previous content in the period
            // // 3 - Clean possible content from a precedent adaptation in this period
            // // (take the clock into account to avoid removing "now" for native sourceBuffers)
            // // like:
            // return clock$.pluck("currentTime").take(1).mergeMap(currentTime => {
            // })
            // 3 - create the pipeline
            var pipelineOptions = getPipelineOptions(bufferType, options.maxRetry, options.maxRetryOffline);
            var pipeline = segmentPipelinesManager
                .createPipeline(bufferType, pipelineOptions);
            // 4 - create the Buffer
            var adaptationBuffer$ = bufferManager.createBuffer(clock$, queuedSourceBuffer, segmentBookkeeper, pipeline, wantedBufferAhead$, { manifest: manifest, period: period, adaptation: adaptation }).catch(function (error) {
                // non native buffer should not impact the stability of the
                // player. ie: if a text buffer sends an error, we want to
                // continue streaming without any subtitles
                if (!source_buffers_1.default.isNative(bufferType)) {
                    log_1.default.error("custom buffer: ", bufferType, "has crashed. Aborting it.", error);
                    sourceBufferManager.disposeSourceBuffer(bufferType);
                    errorStream.next(error);
                    return buffer_1.createFakeBuffer(clock$, wantedBufferAhead$, bufferType, { manifest: manifest, period: period });
                }
                log_1.default.error("native buffer: ", bufferType, "has crashed. Stopping playback.", error);
                throw error; // else, throw
            });
            // 5 - Return the buffer and send right events
            return Observable_1.Observable
                .of(stream_events_1.default.adaptationChange(bufferType, adaptation, period))
                .concat(Observable_1.Observable.merge(adaptationBuffer$, bufferGarbageCollector$));
        });
    }
}
exports.default = BuffersHandler;
/**
 * @param {string} bufferType
 * @param {number} retry
 * @param {number} offlineRetry
 * @returns {Object} - Options to give to the Pipeline
 */
function getPipelineOptions(bufferType, retry, offlineRetry) {
    var cache = array_includes_1.default(["audio", "video"], bufferType) ?
        new initialization_segment_cache_1.default() : undefined;
    var maxRetry;
    var maxRetryOffline;
    if (bufferType === "image") {
        maxRetry = 0; // Deactivate BIF fetching if it fails
    }
    else {
        maxRetry = retry != null ?
            retry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR;
    }
    maxRetryOffline = offlineRetry != null ?
        offlineRetry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;
    return {
        cache: cache,
        maxRetry: maxRetry,
        maxRetryOffline: maxRetryOffline,
    };
}
/**
 * Returns an Observable which emits ``undefined`` and complete when all
 * buffers given are _complete_.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */
function buffersAreComplete() {
    var buffers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        buffers[_i] = arguments[_i];
    }
    /**
     * Array of Observables linked to the Array of Buffers which emit:
     *   - true when the corresponding buffer is considered _complete_.
     *   - false when the corresponding buffer is considered _active_.
     * @type {Array.<Observable>}
     */
    var isCompleteArray = buffers
        .map(function (buffer) {
        return buffer
            .filter(function (evt) {
            return evt.type === "complete-buffer" || evt.type === "active-buffer";
        })
            .map(function (evt) { return evt.type === "complete-buffer"; })
            .startWith(false)
            .distinctUntilChanged();
    });
    return Observable_1.Observable.combineLatest.apply(Observable_1.Observable, isCompleteArray).map(function (areComplete) {
        return areComplete.every(function (isComplete) { return isComplete; });
    })
        .distinctUntilChanged();
}
/**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */
function getFirstDeclaredMimeType(adaptation) {
    var representations = adaptation.representations;
    return (representations[0] && representations[0].getMimeTypeString()) || "";
}
/**
 * Create all native SourceBuffers needed for a given Period.
 *
 * Native Buffers have the particulary to need to be created at the beginning of
 * the content.
 * Custom source buffers (entirely managed in JS) can generally be created and
 * disposed at will during the lifecycle of the content.
 * @param {SourceBufferManager} sourceBufferManager
 * @param {Period} period
 */
function createNativeSourceBuffersForPeriod(sourceBufferManager, period) {
    Object.keys(period.adaptations).forEach(function (bufferType) {
        if (source_buffers_1.default.isNative(bufferType)) {
            var adaptations = period.adaptations[bufferType] || [];
            var representations = adaptations ?
                adaptations[0].representations : [];
            if (representations.length) {
                var codec = representations[0].getMimeTypeString();
                sourceBufferManager.createSourceBuffer(bufferType, codec);
            }
        }
    });
}


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation
var index_1 = __webpack_require__(5);
var findEndOfCueBlock_1 = __webpack_require__(74);
var parseTimestamp_1 = __webpack_require__(73);
/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSRTStringToVTTCues(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    var lines = srtStr.split(/\r\n|\n|\r/);
    var cueBlocks = [];
    for (var i = 0; i < lines.length; i++) {
        if (lines[i]) {
            var endOfCue = findEndOfCueBlock_1.default(lines, i);
            cueBlocks.push(lines.slice(i, endOfCue));
            i = endOfCue;
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseSRTStringToVTTCues;
/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {TextTrackCue|VTTCue|null}
 */
function parseCue(cueLines, timeOffset) {
    var _a = cueLines[1].split(" --> "), startString = _a[0], endString = _a[1];
    var payloadLines = cueLines.slice(2, cueLines.length);
    if (!startString || !endString || !payloadLines.length) {
        return null;
    }
    var start = parseTimestamp_1.default(startString);
    var end = parseTimestamp_1.default(endString);
    if (start == null || end == null) {
        return null;
    }
    var payload = payloadLines.join("\n");
    return index_1.makeCue(start + timeOffset, end + timeOffset, payload);
}


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var assert_1 = __webpack_require__(4);
var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
function createCuesFromArray(cuesArray) {
    var nativeCues = [];
    for (var i = 0; i < cuesArray.length; i++) {
        var _a = cuesArray[i], start = _a.start, end = _a.end, text = _a.text;
        if (text && end != null) {
            var cue = compat_1.makeCue(start, end, text);
            if (cue != null) {
                nativeCues.push(cue);
            }
        }
    }
    return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    var langs = {};
    var m;
    while ((m = ruleRe.exec(str))) {
        var name_1 = m[1];
        var lang = getCSSProperty(m[2], "lang");
        if (name_1 != null && lang != null) {
            langs[lang] = name_1;
        }
    }
    return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
    return matches ? matches[1] : null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(BR, "\n")
        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSami(smi, timeOffset, lang) {
    var syncOpen = /<sync[ >]/ig;
    var syncClose = /<sync[ >]|<\/body>/ig;
    var subs = [];
    var styleMatches = smi.match(STYLE);
    var css = styleMatches ? styleMatches[1] : "";
    var up;
    var to;
    // XXX TODO FIXME Is that wanted?
    // previously written as let to = SyncClose.exec(smi); but never used
    syncClose.exec(smi);
    var langs = getClassNameByLang(css);
    var klass = langs[lang];
    assert_1.default(!!klass, "sami: could not find lang " + lang + " in CSS");
    for (;;) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (!up && !to) {
            break;
        }
        if (!up || !to || up.index >= to.index) {
            throw new Error("parse error");
        }
        var str = smi.slice(up.index, to.index);
        var tim = str.match(START);
        if (!tim) {
            throw new Error("parse error (sync time attribute)");
        }
        var start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return createCuesFromArray(subs);
    function appendToSubs(lines, start) {
        var i = lines.length;
        var m;
        while (--i >= 0) {
            m = lines[i].match(PARAG);
            if (!m) {
                continue;
            }
            var kl = m[1], txt = m[2];
            if (klass !== kl) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                subs.push({
                    text: decodeEntities(txt),
                    start: start + timeOffset,
                });
            }
        }
    }
}
exports.default = parseSami;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var objectAssign = __webpack_require__(8);
var compat_1 = __webpack_require__(5);
var getParameters_1 = __webpack_require__(77);
var getParentElementsByTagName_1 = __webpack_require__(47);
var getTimeDelimiters_1 = __webpack_require__(75);
var nodes_1 = __webpack_require__(76);
var regexps_1 = __webpack_require__(45);
var style_1 = __webpack_require__(46);
/**
 * Style attributes currently used.
 */
var WANTED_STYLE_ATTRIBUTES = [
    "extent",
    "writingMode",
    "origin",
    "align",
];
/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_LIGN_ALIGN = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end",
};
/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_POSITION_ALIGN = {
    left: "line-left",
    center: "center",
    right: "line-right",
};
/**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseTTMLStringToVTT(str, timeOffset) {
    var ret = [];
    var xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml) {
        var tts = xml.getElementsByTagName("tt");
        var tt = tts[0];
        if (!tt) {
            throw new Error("invalid XML");
        }
        var body = nodes_1.getBodyNode(tt);
        var styleNodes = nodes_1.getStyleNodes(tt);
        var regionNodes = nodes_1.getRegionNodes(tt);
        var textNodes = nodes_1.getTextNodes(tt);
        var params = getParameters_1.default(tt);
        // construct styles array based on the xml as an optimization
        var styles = [];
        for (var i = 0; i <= styleNodes.length - 1; i++) {
            // TODO styles referencing other styles
            var styleNode = styleNodes[i];
            if (styleNode instanceof Element) {
                var styleID = styleNode.getAttribute("xml:id");
                if (styleID != null) {
                    styles.push({
                        id: styleID,
                        style: style_1.getStylingFromElement(styleNode),
                    });
                }
            }
        }
        // construct regions array based on the xml as an optimization
        var regions = [];
        var _loop_1 = function (i) {
            var regionNode = regionNodes[i];
            if (regionNode instanceof Element) {
                var regionID = regionNode.getAttribute("xml:id");
                if (regionID != null) {
                    var regionStyle = style_1.getStylingFromElement(regionNode);
                    var associatedStyle_1 = regionNode.getAttribute("style");
                    if (associatedStyle_1) {
                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });
                        if (style) {
                            regionStyle = objectAssign({}, style.style, regionStyle);
                        }
                    }
                    regions.push({
                        id: regionID,
                        style: regionStyle,
                    });
                }
            }
        };
        for (var i = 0; i <= regionNodes.length - 1; i++) {
            _loop_1(i);
        }
        // Computing the style takes a lot of ressources.
        // To avoid too much re-computation, let's compute the body style right
        // now and do the rest progressively.
        var bodyStyle = body ?
            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [body], styles, regions) :
            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [], styles, regions);
        for (var i = 0; i < textNodes.length; i++) {
            var paragraph = textNodes[i];
            if (paragraph instanceof Element) {
                var divs = getParentElementsByTagName_1.default(paragraph, "div");
                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
                var cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params);
                if (cue) {
                    ret.push(cue);
                }
            }
        }
    }
    return ret;
}
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @returns {TextTrackCue|null}
 */
function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params) {
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent || "")) {
        return null;
    }
    var _a = getTimeDelimiters_1.default(paragraph, params), start = _a.start, end = _a.end;
    var text = generateTextContent(paragraph, params.spaceStyle === "default");
    var cue = compat_1.makeCue(start + offset, end + offset, text);
    if (!cue) {
        return null;
    }
    if (cue instanceof VTTCue) {
        addStyle(cue, paragraphStyle);
    }
    return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {string}
 */
function generateTextContent(paragraph, shouldTrimWhiteSpace) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding string.
     * @param {Node} node - the node in question
     * @returns {string}
     */
    function loop(node) {
        var childNodes = node.childNodes;
        var text = "";
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                var textContent = currentNode.textContent || "";
                // TODO Also parse it from parent elements
                // const spaceAttr = getAttribute("xml:space", [
                //   ...spans, p, ...divs, body,
                // ]);
                // const shouldTrimWhiteSpace = spaceAttr ?
                //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
                if (shouldTrimWhiteSpace) {
                    // 1. Trim leading and trailing whitespace.
                    // 2. Collapse multiple spaces into one.
                    var trimmed = textContent.trim();
                    trimmed = trimmed.replace(/\s+/g, " ");
                    textContent = trimmed;
                }
                text += textContent;
            }
            else if (currentNode.nodeName === "br") {
                text += "\n";
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.childNodes.length > 0) {
                text += loop(currentNode);
            }
        }
        return text;
    }
    return loop(paragraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */
function addStyle(cue, style) {
    var extent = style.extent;
    if (extent) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);
        if (results != null) {
            // Use width value of the extent attribute for size.
            // Height value is ignored.
            cue.size = Number(results[1]);
        }
    }
    var writingMode = style.writingMode;
    // let isVerticalText = true;
    switch (writingMode) {
        case "tb":
        case "tblr":
            cue.vertical = "lr";
            break;
        case "tbrl":
            cue.vertical = "rl";
            break;
        default:
            // isVerticalText = false;
            break;
    }
    var origin = style.origin;
    if (origin) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(origin);
        if (results != null) {
            // for vertical text use first coordinate of tts:origin
            // to represent line of the cue and second - for position.
            // Otherwise (horizontal), use them the other way around.
            // if (isVerticalText) {
            // TODO check and uncomment
            // cue.position = Number(results[2]);
            // cue.line = Number(results[1]);
            // } else {
            // TODO check and uncomment
            // cue.position = Number(results[1]);
            // cue.line = Number(results[2]);
            // }
            // A boolean indicating whether the line is an integer
            // number of lines (using the line dimensions of the first
            // line of the cue), or whether it is a percentage of the
            // dimension of the video. The flag is set to true when lines
            // are counted, and false otherwise.
            // TODO check and uncomment
            // cue.snapToLines = false;
        }
    }
    var align = style.align;
    if (align) {
        cue.align = align;
        if (align === "center") {
            if (cue.align !== "center") {
                // Workaround for a Chrome bug http://crbug.com/663797
                // Chrome does not support align = "center"
                cue.align = "middle";
            }
            cue.position = "auto";
        }
        cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "";
        cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "";
    }
}
exports.default = parseTTMLStringToVTT;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array_includes_1 = __webpack_require__(13);
var index_1 = __webpack_require__(5);
var utils_1 = __webpack_require__(72);
// Simple VTT to VTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.
/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseVTTStringToVTTCues(vttStr, timeOffset) {
    // WEBVTT authorize CRLF, LF or CR as line terminators
    var lines = vttStr.split(/\r\n|\n|\r/);
    if (!(/^WEBVTT($| |\t)/.test(lines[0]))) {
        throw new Error("Can't parse WebVTT: Invalid file.");
    }
    var cueBlocks = [];
    for (var i = 1; i < lines.length; i++) {
        if (utils_1.isStartOfCueBlock(lines, i)) {
            var endOfCue = utils_1.findEndOfCueBlock(lines, i);
            cueBlocks.push(lines.slice(i, endOfCue));
            i = endOfCue;
        }
        else if (lines[i]) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            while (lines[i]) {
                i++;
            }
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseVTTStringToVTTCues;
/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {TextTrackCue|VTTCue}
 */
function parseCue(cueLines, timeOffset) {
    var timingRegexp = /-->/;
    var timeString;
    var payloadLines;
    if (!timingRegexp.test(cueLines[0])) {
        if (!timingRegexp.test(cueLines[1])) {
            // not a cue
            return null;
        }
        timeString = cueLines[1];
        payloadLines = cueLines.slice(2, cueLines.length);
    }
    else {
        timeString = cueLines[0];
        payloadLines = cueLines.slice(1, cueLines.length);
    }
    var timeAndSettings = parseTimeAndSettings(timeString);
    if (!timeAndSettings) {
        return null;
    }
    var start = timeAndSettings.start, end = timeAndSettings.end, settings = timeAndSettings.settings;
    var payload = payloadLines.join("\n");
    var cue = index_1.makeCue(start + timeOffset, end + timeOffset, payload);
    if (cue && cue instanceof VTTCue) {
        setSettingsOnCue(settings, cue);
    }
    return cue;
}
/**
 * Parse a single WEBVTT timestamp into seconds
 * @param {string} timestampString
 * @returns {Number}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":");
    if (splittedTS.length === 3) {
        var hours = parseInt(splittedTS[0], 10);
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[2]);
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
    else if (splittedTS.length === 2) {
        var minutes = parseInt(splittedTS[0], 10);
        var seconds = parseFloat(splittedTS[1]);
        if (isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return minutes * 60 + seconds;
    }
}
/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
function parseSettings(settingsString) {
    var splittedSettings = settingsString.split(/ |\t/);
    return splittedSettings.reduce(function (acc, setting) {
        var splittedSetting = setting.split(":");
        if (splittedSetting.length === 2) {
            acc[splittedSetting[0]] = splittedSetting[1];
        }
        return acc;
    }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */
function parseTimeAndSettings(timeString) {
    /*
     * RegExp for the timestamps + settings line.
     *
     * Capture groups:
     *   1 -> start timestamp
     *   2 -> end timestamp
     *   3 - settings
     * @type {RegExp}
     */
    var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
    var matches = timeString.match(lineRegex);
    if (!matches) {
        return null;
    }
    var start = parseTimestamp(matches[1]);
    var end = parseTimestamp(matches[2]);
    if (start == null || end == null) {
        return null;
    }
    var settings = parseSettings(matches[3]);
    return {
        start: start,
        end: end,
        settings: settings,
    };
}
/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {VTTCue|TextTrackCue} cue
 */
function setSettingsOnCue(settings, cue) {
    if (settings.vertical &&
        (settings.vertical === "rl" || settings.vertical === "lr")) {
        cue.vertical = settings.vertical;
    }
    if (settings.line) {
        /**
         * Capture groups:
         *   1 -> percentage position
         *   2 -> optional decimals from percentage position
         *   3 -> optional follow-up of the string indicating alignment value
         *   4 -> alignment value
         * @type {RegExp}
         */
        var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
        var percentageMatches = settings.line.match(percentagePosition);
        if (percentageMatches) {
            cue.line = percentageMatches[1];
            cue.snapToLines = false;
            if (array_includes_1.default(["start", "center", "end"], percentageMatches[4])) {
                cue.lineAlign = percentageMatches[4];
            }
        }
        else {
            /**
             * Capture groups:
             *   1 -> line number
             *   2 -> optional follow-up of the string indicating alignment value
             *   3 -> alignment value
             * @type {RegExp}
             */
            var linePosition = /^(-?\d+)(,([a-z]+))?/;
            var lineMatches = settings.line.match(linePosition);
            if (lineMatches) {
                cue.line = lineMatches[1];
                cue.snapToLines = true;
                if (array_includes_1.default(["start", "center", "end"], lineMatches[3])) {
                    cue.lineAlign = lineMatches[3];
                }
            }
        }
    }
    if (settings.position) {
        var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
        var positionArr = positionRegex.exec(settings.position);
        if (positionArr && positionArr.length >= 2) {
            var position = parseInt(positionArr[1], 10);
            if (!isNaN(position)) {
                cue.position = position;
                if (positionArr[2] != null) {
                    cue.positionAlign = positionArr[2];
                }
            }
        }
    }
    if (settings.size) {
        cue.size = settings.size;
    }
    if (settings.align &&
        array_includes_1.default(["start", "center", "end", "left"], settings.align)) {
        cue.align = settings.align;
    }
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var nativeParsers = {};
/* tslint:disable no-var-requires */
if (true) {
    nativeParsers.vtt =
        __webpack_require__(136).default;
}
if (true) {
    nativeParsers.ttml =
        __webpack_require__(135).default;
}
if (true) {
    nativeParsers.sami =
        __webpack_require__(134).default;
}
if (true) {
    nativeParsers.srt =
        __webpack_require__(133).default;
}
/* tslint:enable no-var-requires */
/**
 * @param {string} type
 * @param {string} data
 * @param {Number} timeOffset
 * @param {string} [language]
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToCues(type, data, timeOffset, language) {
    log_1.default.debug("finding parser for native text tracks:", type);
    var parser = nativeParsers[type];
    if (!parser) {
        throw new Error("no parser found for the given text track");
    }
    log_1.default.debug("parser found, parsing...");
    var parsed = parser(data, timeOffset, language);
    log_1.default.debug("parsed successfully!", parsed);
    return parsed;
}
exports.default = parseTextTrackToCues;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
var abstract_source_buffer_1 = __webpack_require__(48);
var parsers_1 = __webpack_require__(137);
/**
 * Source buffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextTrackSourceBuffer
 * @extends AbstractSourceBuffer
 */
var NativeTextTrackSourceBuffer = /** @class */ (function (_super) {
    __extends(NativeTextTrackSourceBuffer, _super);
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {Boolean} hideNativeSubtitle
     */
    function NativeTextTrackSourceBuffer(videoElement, hideNativeSubtitle) {
        var _this = this;
        log_1.default.debug("creating native text track source buffer");
        _this = _super.call(this) || this;
        var _a = compat_1.addTextTrack(videoElement, hideNativeSubtitle), track = _a.track, trackElement = _a.trackElement;
        _this._videoElement = videoElement;
        _this._track = track;
        _this._trackElement = trackElement;
        return _this;
    }
    /**
     * Append text tracks.
     * @param {Object} data
     * @param {string} data.data
     * @param {string} data.language
     * @param {Number} data.timescale
     * @param {Number} data.start
     * @param {Number} data.timeOffset
     * @param {Number|undefined} data.end
     */
    NativeTextTrackSourceBuffer.prototype._append = function (data) {
        log_1.default.debug("appending new native text tracks", data);
        var timescale = data.timescale, // timescale for the start and end
        timescaledStart = data.start, // exact beginning to which the track applies
        timescaledEnd = data.end, // exact end to which the track applies
        dataString = data.data, // text track content. Should be a string
        type = data.type, // type of texttracks (e.g. "ttml" or "vtt")
        language = data.language, // language the texttrack is in
        timeOffset = data.timeOffset;
        if (timescaledEnd != null && timescaledEnd - timescaledStart <= 0) {
            // this is accepted for error resilience, just skip that case.
            log_1.default.warn("Invalid subtitles appended");
            return;
        }
        var startTime = timescaledStart / timescale;
        var endTime = timescaledEnd != null ?
            timescaledEnd / timescale : undefined;
        var cues = parsers_1.default(type, dataString, timeOffset, language);
        if (cues.length > 0) {
            var firstCue = cues[0];
            // NOTE(compat): cleanup all current cues if the newly added
            // ones are in the past. this is supposed to fix an issue on
            // IE/Edge.
            var currentCues = this._track.cues;
            if (currentCues.length > 0) {
                if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
                    this._remove(firstCue.startTime, +Infinity);
                }
            }
            for (var i = 0; i < cues.length; i++) {
                this._track.addCue(cues[i]);
            }
            this.buffered.insert(startTime, endTime != null ? endTime : cues[cues.length - 1].endTime);
        }
        else if (endTime != null) {
            this.buffered.insert(startTime, endTime);
        }
    };
    /**
     * @param {Number} from
     * @param {Number} to
     */
    NativeTextTrackSourceBuffer.prototype._remove = function (from, to) {
        log_1.default.debug("removing native text track data", from, to);
        var track = this._track;
        var cues = track.cues;
        for (var i = cues.length - 1; i >= 0; i--) {
            var cue = cues[i];
            var startTime = cue.startTime, endTime = cue.endTime;
            if (startTime >= from && startTime <= to && endTime <= to) {
                track.removeCue(cue);
            }
        }
        this.buffered.remove(from, to);
    };
    NativeTextTrackSourceBuffer.prototype._abort = function () {
        log_1.default.debug("aborting native text track source buffer");
        var _a = this, _trackElement = _a._trackElement, _videoElement = _a._videoElement;
        if (_trackElement && _videoElement &&
            _videoElement.hasChildNodes()) {
            try {
                _videoElement.removeChild(_trackElement);
            }
            catch (e) {
                log_1.default.warn("Can't remove track element from the video");
            }
        }
        if (this._track) {
            this._track.mode = "disabled";
        }
        if (this._trackElement) {
            this._trackElement.innerHTML = "";
        }
    };
    return NativeTextTrackSourceBuffer;
}(abstract_source_buffer_1.default));
exports.default = NativeTextTrackSourceBuffer;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":").reverse();
    if (splittedTS[2] || splittedTS[1]) {
        var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0;
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[0].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}
exports.default = parseTimestamp;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var parseTimestamp_1 = __webpack_require__(139);
/**
 * Parse the VTT timecode line given and construct an object with two
 * properties:
 *   - start {Number|undefined}: the corresponding start time in seconds
 *   - end {Number|undefined}: the corresponding end time in seconds
 * @example
 * ```js
 * parseTimeCode("00:02:30 --> 00:03:00");
 * // -> {
 * //      start: 150,
 * //      end: 180,
 * //    }
 * ```
 * @param {string} text
 * @returns {Object|undefined}
 */
function parseTimeCode(text) {
    var tsRegex = "((?:[0-9]{2}\:)?[0-9]{2}:[0-9]{2}.[0-9]{2,3})";
    var startEndRegex = tsRegex + "(?:\ |\t)-->(?:\ |\t)" + tsRegex;
    var ranges = text.match(startEndRegex);
    if (ranges && ranges.length >= 3) {
        var start = parseTimestamp_1.default(ranges[1]);
        var end = parseTimestamp_1.default(ranges[2]);
        return { start: start, end: end };
    }
}
exports.default = parseTimeCode;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @return {Array.<Object>} styleElements
 */
function parseStyleBlock(styleBlock) {
    var styleElements = [];
    var index = 1;
    var classNames = [];
    if (styleBlock[index].match(/::cue {/)) {
        classNames.push({ isGlobalStyle: true });
        index++;
    }
    else {
        var cueClassLine = void 0;
        while (cueClassLine = styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/)) {
            classNames.push({
                className: cueClassLine[1],
                isGlobalStyle: false,
            });
            index++;
        }
    }
    var styleContent = "";
    while (!(styleBlock[index].match(/}/)
        || styleBlock[index].length === 0)) {
        styleContent += styleBlock[index];
        index++;
    }
    classNames.forEach(function (name) {
        styleElements.push({
            className: name.className,
            isGlobalStyle: name.isGlobalStyle,
            styleContent: styleContent.replace(/\s/g, ""),
        });
    });
    return styleElements;
}
exports.default = parseStyleBlock;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array_includes_1 = __webpack_require__(13);
/**
 * Format WebVTT tags and classes into usual HTML.
 * <b *> => <b>
 * <u *> => <u>
 * <i *> => <i>
 * <c.class *> => <c.class>
 * Style is inserted if associated to tag or class.
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<Node>}
 */
function formatCueLineToHTML(text, styleElements) {
    var HTMLTags = ["u", "i", "b"];
    var webVTTTags = ["u", "i", "b", "c", "#text"];
    var styleClasses = styleElements.map(function (styleElement) { return styleElement.className; });
    var filtered = text
        // Remove timestamp tags
        .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "")
        // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
        .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
    var parser = new DOMParser();
    var parsedWebVTT = parser.parseFromString(filtered, "text/html");
    var nodes = parsedWebVTT.body.childNodes;
    /**
     * Apply styles to specifig tag in children nodes.
     * (e.g. If class "b" has style, then : <b style="content">
     * )
     * Change class tags into span with associated style, or text*
     * First it was: <c.class>...</c>. Then <class></class>.
     * Finally <span style="content"></span> or text.
     * @param {Array.<Node>} childNodes
     * @returns {Array.<Node>}
     */
    function parseNode(nodeToParse) {
        var parsedNodeArray = [];
        for (var i = 0; i < nodeToParse.length; i++) {
            parsedNodeArray[i] = createStyleElement(nodeToParse[i]);
        }
        /**
         * Construct an HTMLElement/TextNode representing the given node and apply
         * the right styling on it.
         * @param {Node} baseNode
         * @returns {Node}
         */
        function createStyleElement(baseNode) {
            var mainTag = baseNode.nodeName.toLowerCase().split(".")[0];
            var nodeWithStyle;
            if (array_includes_1.default(webVTTTags, mainTag)) { // If element accepted
                if (mainTag === "#text") {
                    nodeWithStyle = document.createTextNode(baseNode.wholeText);
                }
                else {
                    var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
                    var classIndexes_1 = [];
                    nodeClasses.forEach(function (nodeClass) {
                        if (styleClasses.indexOf(nodeClass) !== -1) {
                            classIndexes_1.push(styleClasses.indexOf(nodeClass));
                        }
                    });
                    if (classIndexes_1.length !== 0) { // If style must be applied
                        var attr_1 = document.createAttribute("style");
                        classIndexes_1.forEach(function (index) {
                            attr_1.value += styleElements[index].styleContent;
                        });
                        var nameClass = array_includes_1.default(HTMLTags, mainTag) ? mainTag : "span";
                        nodeWithStyle = document.createElement(nameClass);
                        nodeWithStyle.setAttributeNode(attr_1);
                    }
                    else { // If style mustn't be applied. Rebuild element with tag name
                        var elementTag = !array_includes_1.default(HTMLTags, mainTag) ? "span" : mainTag;
                        nodeWithStyle = document.createElement(elementTag);
                    }
                    for (var j = 0; j < baseNode.childNodes.length; j++) {
                        nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));
                    }
                }
            }
            else {
                nodeWithStyle = document.createElement("span");
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));
                }
            }
            return nodeWithStyle;
        }
        return parsedNodeArray;
    }
    return parseNode(nodes);
}
exports.default = formatCueLineToHTML;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var utils_1 = __webpack_require__(72);
var formatCueLineToHTML_1 = __webpack_require__(142);
var parseStyleBlock_1 = __webpack_require__(141);
var parseTimeCode_1 = __webpack_require__(140);
/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @param {string} text
 * @param {Number} timeOffset
 * @return {Array.<Object>}
 * @throws Error - Throws if the given WebVTT string is invalid.
 */
function parseWebVTT(text, timeOffset) {
    var newLineChar = /\r\n|\n|\r/g;
    var linified = text.split(newLineChar);
    var cuesArray = [];
    var styleElements = [];
    if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) {
        throw new Error("Can't parse WebVTT: Invalid File.");
    }
    var firstLineAfterHeader = utils_1.getFirstLineAfterHeader(linified);
    for (var i = firstLineAfterHeader; i < linified.length; i++) {
        if (utils_1.isStartOfStyleBlock(linified, i)) {
            var startOfStyleBlock = i;
            i++;
            // continue incrementing i until either:
            //   - empty line
            //   - end of file
            while (linified[i]) {
                i++;
            }
            var styleBlock = linified.slice(startOfStyleBlock, i);
            var parsedStyles = parseStyleBlock_1.default(styleBlock);
            styleElements.push.apply(styleElements, parsedStyles);
        }
    }
    // Parse cues, format and apply style.
    for (var i = firstLineAfterHeader; i < linified.length; i++) {
        if (!(linified[i].length === 0)) {
            if (utils_1.isStartOfCueBlock(linified, i)) {
                var endOfCue = utils_1.findEndOfCueBlock(linified, i);
                var cueBlock = linified.slice(i, endOfCue);
                var cue = parseCue(cueBlock, timeOffset, styleElements);
                if (cue) {
                    cuesArray.push(cue);
                }
                i = endOfCue;
            }
            else {
                while (linified[i]) {
                    i++;
                }
            }
        }
    }
    return cuesArray;
}
exports.default = parseWebVTT;
/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} styleElements
 * @returns {Object|undefined}
 */
function parseCue(cueBlock, timeOffset, styleElements) {
    var region = document.createElement("div");
    var regionAttr = document.createAttribute("style");
    var index = 0;
    regionAttr.value =
        "width:100%;" +
            "height:100%;" +
            "display:flex;" +
            "flex-direction:column;" +
            "justify-content:flex-end;" +
            "align-items:center;";
    region.setAttributeNode(regionAttr);
    // Get Header. It may be a class name associated with cue.
    var header = cueBlock[index];
    index++;
    // Get time ranges.
    var timeCodes = cueBlock[index];
    var range = parseTimeCode_1.default(timeCodes);
    if (!range || range.start === undefined || range.end === undefined) {
        log_1.default.warn("VTT: Invalid cue, the timecode line could not be parsed.");
        return undefined; // cancel if we do not find the start or end of this cue
    }
    index++;
    // Get content, format and apply style.
    var pElement = document.createElement("p");
    var pAttr = document.createAttribute("style");
    pAttr.value = "text-align:center";
    pElement.setAttributeNode(pAttr);
    var spanElement = document.createElement("span");
    var attr = document.createAttribute("style");
    // set color and background-color default values, as indicated in:
    // https://www.w3.org/TR/webvtt1/#applying-css-properties
    attr.value =
        "background-color:rgba(0,0,0,0.8);" +
            "color:white;";
    spanElement.setAttributeNode(attr);
    var styles = styleElements
        .filter(function (styleElement) {
        return (styleElement.className === header && !styleElement.isGlobalStyle) ||
            styleElement.isGlobalStyle;
    }).map(function (styleElement) { return styleElement.styleContent; });
    if (styles) {
        attr.value += styles.join();
        spanElement.setAttributeNode(attr);
    }
    while (cueBlock[index] !== undefined) {
        if (spanElement.childNodes.length !== 0) {
            spanElement.appendChild(document.createElement("br"));
        }
        formatCueLineToHTML_1.default(cueBlock[index], styleElements)
            .forEach(function (child) {
            spanElement.appendChild(child);
        });
        index++;
    }
    region.appendChild(pElement);
    pElement.appendChild(spanElement);
    return {
        start: range.start + timeOffset,
        end: range.end + timeOffset,
        element: region,
    };
}


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.
var findEndOfCueBlock_1 = __webpack_require__(74);
var parseTimestamp_1 = __webpack_require__(73);
/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseSRTStringToHTML(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    var lines = srtStr.split(/\r\n|\n|\r/);
    var cueBlocks = [];
    for (var i = 0; i < lines.length; i++) {
        if (lines[i]) { // if not empty line or EOF
            var endOfCue = findEndOfCueBlock_1.default(lines, i);
            cueBlocks.push(lines.slice(i, endOfCue));
            i = endOfCue;
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseSRTStringToHTML;
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */
function parseCue(cueLines, timeOffset) {
    var _a = cueLines[1].split(" --> "), startString = _a[0], endString = _a[1];
    var payloadLines = cueLines.slice(2, cueLines.length);
    if (!startString || !endString || !payloadLines.length) {
        return null;
    }
    var start = parseTimestamp_1.default(startString);
    var end = parseTimestamp_1.default(endString);
    if (start == null || end == null) {
        return null;
    }
    var pEl = document.createElement("div");
    pEl.className = "rxp-texttrack-p";
    pEl.style.fontSize = "28px";
    pEl.style.position = "absolute";
    pEl.style.bottom = "5%";
    pEl.style.width = "100%";
    pEl.style.textAlign = "center";
    pEl.style.color = "#fff";
    pEl.style.textShadow = "-1px -1px 2px #000," +
        "1px -1px 2px #000," +
        "-1px 1px 2px #000," +
        "1px 1px 2px #000";
    for (var i = 0; i < payloadLines.length; i++) {
        if (i) {
            pEl.appendChild(document.createElement("br"));
        }
        var span = generateSpansFromSRTText(payloadLines[i]);
        pEl.appendChild(span);
    }
    return {
        start: start + timeOffset,
        end: end + timeOffset,
        element: pEl,
    };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */
function generateSpansFromSRTText(text) {
    var secureDiv = document.createElement("div");
    secureDiv.innerHTML = text;
    var _loop = function (node) {
        var childNodes = node.childNodes;
        var span = document.createElement("span");
        span.className = "rxp-texttrack-span";
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                span.innerHTML += currentNode.textContent;
            }
            else if (currentNode.nodeName === "B") {
                var spanChild = _loop(currentNode);
                spanChild.style.fontWeight = "bold";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "I") {
                var spanChild = _loop(currentNode);
                spanChild.style.fontStyle = "italic";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "U") {
                var spanChild = _loop(currentNode);
                spanChild.style.textDecoration = "underline";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "FONT" &&
                currentNode.color != null) {
                // TODO loop through attributes to find color?
                var spanChild = _loop(currentNode);
                spanChild.style.color = currentNode.color;
                span.appendChild(spanChild);
            }
            else {
                var spanChild = _loop(currentNode);
                span.appendChild(spanChild);
            }
        }
        return span;
    };
    return _loop(secureDiv);
}


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var getParentElementsByTagName_1 = __webpack_require__(47);
var regexps_1 = __webpack_require__(45);
var style_1 = __webpack_require__(46);
// import getAttributeInElements from "../getAttributeInElements";
// Styling which can be applied to <span> from any level upper.
// Added here as an optimization
var SPAN_LEVEL_ATTRIBUTES = [
    "color",
    "direction",
    "display",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
];
/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
function ttmlColorToCSSColor(color) {
    // TODO check all possible color fomats
    var regRes;
    regRes = regexps_1.REGXP_8_HEX_COLOR.exec(color);
    if (regRes != null) {
        return "rgba(" +
            parseInt(regRes[1], 16) + "," +
            parseInt(regRes[2], 16) + "," +
            parseInt(regRes[3], 16) + "," +
            parseInt(regRes[4], 16) / 255 + ")";
    }
    regRes = regexps_1.REGXP_4_HEX_COLOR.exec(color);
    if (regRes != null) {
        return "rgba(" +
            parseInt(regRes[1] + regRes[1], 16) + "," +
            parseInt(regRes[2] + regRes[2], 16) + "," +
            parseInt(regRes[3] + regRes[3], 16) + "," +
            parseInt(regRes[4] + regRes[4], 16) / 255 + ")";
    }
    return color;
}
/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
    return "-1px -1px " + thickness + " " + color + "," +
        ("1px -1px " + thickness + " " + color + ",") +
        ("-1px 1px " + thickness + " " + color + ",") +
        ("1px 1px " + thickness + " " + color);
}
// TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)
/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */
function applyTextStyle(element, style) {
    // applies to span
    var color = style.color;
    if (color) {
        element.style.color = ttmlColorToCSSColor(color);
    }
    // applies to body, div, p, region, span
    var backgroundColor = style.backgroundColor;
    if (backgroundColor) {
        element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
    }
    // applies to span
    var wrapOption = style.wrapOption;
    if (wrapOption && wrapOption === "noWrap") {
        element.style.whiteSpace = "nowrap";
    }
    // applies to span
    var textOutline = style.textOutline;
    if (textOutline) {
        var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
        var len = outlineData.length;
        if (len === 3) {
            var outlineColor = ttmlColorToCSSColor(outlineData[0]);
            var thickness = outlineData[1];
            element.style.textShadow =
                generateCSSTextOutline(outlineColor, thickness);
        }
        else if (color && len === 1) {
            var thickness = outlineData[0];
            element.style.textShadow = generateCSSTextOutline(color, thickness);
        }
        else if (len === 2) {
            var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
            var isFirstArgANumber = /^[0-9]/.test(outlineData[0]);
            // XOR-ing to be sure we get what we have
            if (isFirstArgAColor !== isFirstArgANumber) {
                if (isFirstArgAColor) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]);
                    var thickness = outlineData[1];
                    element.style.textShadow =
                        generateCSSTextOutline(outlineColor, thickness);
                }
                else if (color) {
                    var thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, thickness);
                }
            }
        }
    }
    // applies to span
    var textDecoration = style.textDecoration;
    if (textDecoration) {
        switch (textDecoration) {
            case "noUnderline":
            case "noLineThrough":
            case "noOverline":
                element.style.textDecoration = "none";
                break;
            case "lineThrough":
                element.style.textDecoration = "line-through";
                break;
            default:
                element.style.textDecoration = textDecoration;
                break;
        }
    }
    // applies to span
    var fontFamily = style.fontFamily;
    if (fontFamily) {
        switch (fontFamily) {
            case "proportionalSansSerif":
                element.style.fontFamily =
                    "Arial, Helvetica, Liberation Sans, sans-serif";
                break;
            // TODO monospace or sans-serif or font with both?
            case "monospaceSansSerif":
            case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;
            case "monospaceSerif":
            case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;
            // TODO font with both?
            case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;
            default:
                element.style.fontFamily = fontFamily;
        }
    }
    // applies to span
    var fontStyle = style.fontStyle;
    if (fontStyle) {
        element.style.fontStyle = fontStyle;
    }
    // applies to span
    var fontWeight = style.fontWeight;
    if (fontWeight) {
        element.style.fontWeight = fontWeight;
    }
    // applies to span
    var fontSize = style.fontSize;
    if (fontSize) {
        // TODO Check if formats are always really 1:1
        element.style.fontSize = fontSize;
    }
    // applies to p, span
    var direction = style.direction;
    if (direction) {
        element.style.direction = direction;
    }
    // applies to p, span
    var unicodeBidi = style.unicodeBidi;
    if (unicodeBidi) {
        switch (unicodeBidi) {
            case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;
            case "embed":
                element.style.unicodeBidi = "embed";
                break;
            default:
                element.style.unicodeBidi = "normal";
        }
    }
    // applies to body, div, p, region, span
    var visibility = style.visibility;
    if (visibility) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    var display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */
function applyGeneralStyle(element, style) {
    // applies to tt, region
    var extent = style.extent;
    if (extent) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);
        if (results != null) {
            element.style.width = results[1] + "%";
            element.style.height = results[2] + "%";
        }
    }
    // applies to region
    var writingMode = style.writingMode;
    if (writingMode) {
        // TODO
    }
    // applies to region
    var overflow = style.overflow;
    element.style.overflow = overflow || "hidden";
    // applies to region
    var padding = style.padding;
    if (padding) {
        element.style.padding = padding;
    }
    // applies to region
    var origin = style.origin;
    if (origin) {
        var resultsPercent = regexps_1.REGXP_PERCENT_VALUES.exec(origin);
        if (resultsPercent != null) {
            element.style.position = "relative";
            element.style.left = resultsPercent[1] + "%";
            element.style.top = resultsPercent[2] + "%";
        }
        else {
            // TODO also px
        }
    }
    // applies to region
    var displayAlign = style.displayAlign;
    element.style.display = "flex";
    element.style.flexDirection = "column";
    if (displayAlign) {
        switch (displayAlign) {
            case "before":
                element.style.justifyContent = "flex-start";
                break;
            case "center":
                element.style.justifyContent = "center";
                break;
            case "after":
                element.style.justifyContent = "flex-end";
                break;
        }
    }
    // applies to region
    var opacity = style.opacity;
    if (opacity) {
        element.style.opacity = opacity;
    }
    // applies to body, div, p, region, span
    var visibility = style.visibility;
    if (visibility) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    var display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */
function applyPStyle(element, style) {
    // applies to body, div, p, region, span
    var paragraphBackgroundColor = style.backgroundColor;
    if (paragraphBackgroundColor) {
        element.style.backgroundColor =
            ttmlColorToCSSColor(paragraphBackgroundColor);
    }
    // applies to p
    var lineHeight = style.lineHeight;
    if (lineHeight) {
        element.style.lineHeight = lineHeight;
    }
    // applies to p
    var textAlign = style.textAlign;
    if (textAlign) {
        switch (textAlign) {
            case "center":
                element.style.textAlign = "center";
                break;
            case "left":
            case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;
            case "right":
            case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
                break;
        }
    }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Array.<Element>} spans - <span> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} p - <p> tag which contain the element.
 * @param {Array.<Element>} divs - <div> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} body - <body> tag which contain the element.
 * @param {Array.<Object>} regions - Every <region> tag which can apply to
 * this element.
 * @param {Array.<Object>} styles - Every <style> tag which can apply to
 * this element.
 * @param {Boolean} shouldTrimWhiteSpaceParam - True if the space should be
 * trimmed by default. From the <tt> xml:space parameter.
 * @returns {HTMLElement}
 */
function createTextElement(el, style, shouldTrimWhiteSpaceParam) {
    var textElement = document.createElement("span");
    var textContent = el.textContent || "";
    var shouldTrimWhiteSpace = shouldTrimWhiteSpaceParam;
    // TODO Also parse it from parent elements
    // const spaceAttr = getAttributeInElements("xml:space", [
    //   ...spans, p, ...divs, body,
    // ]);
    // const shouldTrimWhiteSpace = spaceAttr ?
    //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
    if (shouldTrimWhiteSpace) {
        // 1. Trim leading and trailing whitespace.
        // 2. Collapse multiple spaces into one.
        var trimmed = textContent.trim();
        trimmed = trimmed.replace(/\s+/g, " ");
        textContent = trimmed;
    }
    textElement.innerHTML = textContent;
    textElement.className = "rxp-texttrack-span";
    applyTextStyle(textElement, style);
    return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */
function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding array of HTMLElement in order.
     * @param {Node} node - the node in question
     * @param {Object} style - the current state of the style for the node.
     * /!\ The style object can be mutated, provide a copy of it.
     * @param {Array.<Element>} spans - The spans parent of this node.
     * @returns {Array.<HTMLElement>}
     */
    function loop(node, style, spans) {
        var childNodes = node.childNodes;
        var elements = [];
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                var backgroundColor = style_1.getStylingAttributes(["backgroundColor"], spans, styles, regions).backgroundColor;
                if (backgroundColor) {
                    style.backgroundColor = backgroundColor;
                }
                else {
                    delete style.backgroundColor;
                }
                var el = createTextElement(currentNode, style, shouldTrimWhiteSpace);
                elements.push(el);
            }
            else if (currentNode.nodeName === "br") {
                var br = document.createElement("BR");
                elements.push(br);
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.childNodes.length > 0) {
                // compute the new applyable style
                var newStyle = objectAssign({}, style, style_1.getStylingAttributes(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
                elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans)));
            }
        }
        return elements;
    }
    return loop(paragraph, objectAssign({}, paragraphStyle), []);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} styles
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {HTMLElement}
 */
function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    var divs = getParentElementsByTagName_1.default(paragraph, "div");
    var parentElement = document.createElement("DIV");
    parentElement.className = "rxp-texttrack-region";
    applyGeneralStyle(parentElement, paragraphStyle);
    if (body) {
        // applies to body, div, p, region, span
        var bodyBackgroundColor = style_1.getStylingAttributes(["backgroundColor"], divs.concat([body]), styles, regions).bodyBackgroundColor;
        if (bodyBackgroundColor) {
            parentElement.style.backgroundColor =
                ttmlColorToCSSColor(bodyBackgroundColor);
        }
    }
    var pElement = document.createElement("p");
    pElement.className = "rxp-texttrack-p";
    applyPStyle(pElement, paragraphStyle);
    var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);
    for (var i = 0; i < textContent.length; i++) {
        pElement.appendChild(textContent[i]);
    }
    // NOTE:
    // The following code is for the inclusion of div elements. This has no
    // advantage for now, and might only with future evolutions.
    // (This is only an indication of what the base of the code could look like).
    // if (divs.length) {
    //   let container = parentElement;
    //   for (let i = divs.length - 1; i >= 0; i--) {
    //     // TODO manage style at div level?
    //     // They are: visibility, display and backgroundColor
    //     // All these do not have any difference if applied to the <p> element
    //     // instead of the div.
    //     // The advantage might only be for multiple <p> elements dispatched
    //     // in multiple div Which we do not manage anyway for now.
    //     const divEl = document.createElement("DIV");
    //     divEl.className = "rxp-texttrack-div";
    //     container.appendChild(divEl);
    //     container = divEl;
    //   }
    //   container.appendChild(pElement);
    //   parentElement.appendChild(container);
    // } else {
    //   parentElement.appendChild(pElement);
    // }
    parentElement.appendChild(pElement);
    return parentElement;
}
exports.default = createElement;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var regexps_1 = __webpack_require__(45);
/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */
function parseTime(text, ttParams) {
    if (regexps_1.REGXP_TIME_COLON_FRAMES.test(text)) {
        return parseColonTimeWithFrames(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_COLON.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON, text);
    }
    else if (regexps_1.REGXP_TIME_COLON_MS.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON_MS, text);
    }
    else if (regexps_1.REGXP_TIME_FRAMES.test(text)) {
        return parseFramesTime(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_TICK.test(text)) {
        return parseTickTime(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_HMS.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_HMS, text);
    }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseFramesTime(ttParams, text) {
    // 75f or 75.5f
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_FRAMES.exec(text);
    var frames = Number(results[1]);
    return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseTickTime(ttParams, text) {
    // 50t or 50.5t
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_TICK.exec(text);
    var ticks = Number(results[1]);
    return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseColonTimeWithFrames(ttParams, text) {
    // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_COLON_FRAMES.exec(text);
    var hours = Number(results[1]);
    var minutes = Number(results[2]);
    var seconds = Number(results[3]);
    var frames = Number(results[4]);
    var subframes = Number(results[5]) || 0;
    frames += subframes / ttParams.subFrameRate;
    seconds += frames / ttParams.frameRate;
    return seconds + (minutes * 60) + (hours * 3600);
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */
function parseTimeFromRegExp(regex, text) {
    var results = regex.exec(text);
    if (results === null || results[0] === "") {
        return null;
    }
    // This capture is optional, but will still be in the array as undefined,
    // default to 0.
    var hours = Number(results[1]) || 0;
    var minutes = Number(results[2]) || 0;
    var seconds = Number(results[3]) || 0;
    var miliseconds = Number(results[4]) || 0;
    return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);
}
exports.default = parseTime;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var getTimeDelimiters_1 = __webpack_require__(75);
var createElement_1 = __webpack_require__(145);
/**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @returns {Object|null}
 */
function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams) {
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent || "")) {
        return null;
    }
    var _a = getTimeDelimiters_1.default(paragraph, ttParams), start = _a.start, end = _a.end;
    var element = createElement_1.default(paragraph, body, regions, styles, styleBase, ttParams.spaceStyle === "default");
    return {
        start: start + offset,
        end: end + offset,
        element: element,
    };
}
exports.default = parseCue;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.STYLE_ATTRIBUTES = [
    "backgroundColor",
    "color",
    "direction",
    "display",
    "displayAlign",
    "extent",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lineHeight",
    "opacity",
    "origin",
    "overflow",
    "padding",
    "textAlign",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
    "writingMode",
];


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
function startsWith(completeString, searchString, position) {
    /* tslint:disable no-unbound-method */
    if (typeof String.prototype.startsWith === "function") {
        /* tslint:enable no-unbound-method */
        return completeString.startsWith(searchString, position);
    }
    return completeString
        .substr(position || 0, searchString.length) === searchString;
}
exports.default = startsWith;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var objectAssign = __webpack_require__(8);
var getParameters_1 = __webpack_require__(77);
var getParentElementsByTagName_1 = __webpack_require__(47);
var nodes_1 = __webpack_require__(76);
var style_1 = __webpack_require__(46);
var constants_1 = __webpack_require__(148);
var parseCue_1 = __webpack_require__(147);
/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseTTMLStringToDIV(str, timeOffset) {
    var ret = [];
    var xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml) {
        var tts = xml.getElementsByTagName("tt");
        var tt = tts[0];
        if (!tt) {
            throw new Error("invalid XML");
        }
        var body = nodes_1.getBodyNode(tt);
        var styleNodes = nodes_1.getStyleNodes(tt);
        var regionNodes = nodes_1.getRegionNodes(tt);
        var textNodes = nodes_1.getTextNodes(tt);
        var params = getParameters_1.default(tt);
        // construct styles array based on the xml as an optimization
        var styles = [];
        for (var i = 0; i <= styleNodes.length - 1; i++) {
            var styleNode = styleNodes[i];
            if (styleNode instanceof Element) {
                var styleID = styleNode.getAttribute("xml:id");
                if (styleID !== null) {
                    // TODO styles referencing other styles
                    styles.push({
                        id: styleID,
                        style: style_1.getStylingFromElement(styleNode),
                    });
                }
            }
        }
        // construct regions array based on the xml as an optimization
        var regions = [];
        var _loop_1 = function (i) {
            var regionNode = regionNodes[i];
            if (regionNode instanceof Element) {
                var regionID = regionNode.getAttribute("xml:id");
                if (regionID !== null) {
                    var regionStyle = style_1.getStylingFromElement(regionNode);
                    var associatedStyle_1 = regionNode.getAttribute("style");
                    if (associatedStyle_1) {
                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });
                        if (style) {
                            regionStyle = objectAssign({}, style.style, regionStyle);
                        }
                    }
                    regions.push({
                        id: regionID,
                        style: regionStyle,
                    });
                }
            }
        };
        for (var i = 0; i <= regionNodes.length - 1; i++) {
            _loop_1(i);
        }
        // Computing the style takes a lot of ressources.
        // To avoid too much re-computation, let's compute the body style right
        // now and do the rest progressively.
        // TODO Compute corresponding CSS style here (as soon as we now the TTML
        // style) to speed up the process even
        // more.
        var bodyStyle = body !== null ?
            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [body], styles, regions) :
            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [], styles, regions);
        for (var i = 0; i < textNodes.length; i++) {
            var paragraph = textNodes[i];
            if (paragraph instanceof Element) {
                var divs = getParentElementsByTagName_1.default(paragraph, "div");
                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
                var cue = parseCue_1.default(paragraph, timeOffset, styles, regions, body, paragraphStyle, params);
                if (cue) {
                    ret.push(cue);
                }
            }
        }
    }
    return ret;
}
exports.default = parseTTMLStringToDIV;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.
var assert_1 = __webpack_require__(4);
var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    var langs = {};
    var m;
    while ((m = ruleRe.exec(str))) {
        var name_1 = m[1];
        var lang = getCSSProperty(m[2], "lang");
        if (name_1 != null && lang != null) {
            langs[lang] = name_1;
        }
    }
    return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */
function getPCSSRules(str) {
    var pRuleRegex = /p\s*{([^}]*)}/gi;
    var rule = pRuleRegex.exec(str);
    if (!rule) {
        return "";
    }
    return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
    return matches ? matches[1] : null;
}
/**
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */
function parseSami(smi, timeOffset, lang) {
    var syncOpen = /<sync[ >]/ig;
    var syncClose = /<sync[ >]|<\/body>/ig;
    var subs = [];
    var styleMatches = smi.match(STYLE);
    var css = styleMatches ? styleMatches[1] : "";
    var up;
    var to;
    // XXX TODO FIXME Is that wanted?
    // previously written as let to = SyncClose.exec(smi); but never used
    syncClose.exec(smi);
    var langs = getClassNameByLang(css);
    var pCSS = getPCSSRules(css);
    var klass = langs[lang];
    assert_1.default(!!klass, "sami: could not find lang " + lang + " in CSS");
    for (;;) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (!up && !to) {
            break;
        }
        if (!up || !to || up.index >= to.index) {
            throw new Error("parse error");
        }
        var str = smi.slice(up.index, to.index);
        var tim = str.match(START);
        if (!tim) {
            throw new Error("parse error (sync time attribute)");
        }
        var start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return subs;
    function appendToSubs(lines, start) {
        var i = lines.length;
        while (--i >= 0) {
            var paragraphInfos = lines[i].match(PARAG);
            if (!paragraphInfos) {
                continue;
            }
            var className = paragraphInfos[1], txt = paragraphInfos[2];
            if (klass !== className) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                var wrapperEl = document.createElement("DIV");
                wrapperEl.className = "rxp-texttrack-region";
                var divEl = document.createElement("DIV");
                divEl.className = "rxp-texttrack-div";
                divEl.style.position = "absolute";
                divEl.style.bottom = "0";
                divEl.style.width = "100%";
                divEl.style.color = "#fff";
                divEl.style.textShadow = "-1px -1px 0 #000," +
                    "1px -1px 0 #000," +
                    "-1px 1px 0 #000," +
                    "1px 1px 0 #000";
                var pEl = document.createElement("div");
                pEl.className = "rxp-texttrack-p";
                if (pCSS) {
                    pEl.style.cssText = pCSS;
                }
                var textEls = txt.split(BR);
                for (var j = 0; j < textEls.length; j++) {
                    if (j) {
                        pEl.appendChild(document.createElement("BR"));
                    }
                    var spanEl = document.createElement("SPAN");
                    spanEl.className = "rxp-texttrack-span";
                    spanEl.textContent = decodeEntities(textEls[j]);
                    pEl.appendChild(spanEl);
                }
                divEl.appendChild(pEl);
                wrapperEl.appendChild(divEl);
                subs.push({
                    element: wrapperEl,
                    start: start + timeOffset,
                    end: -1,
                });
            }
        }
    }
}
exports.default = parseSami;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var htmlParsers = {};
/* tslint:disable no-var-requires */
if (true) {
    htmlParsers.sami =
        __webpack_require__(151).default;
}
if (true) {
    htmlParsers.ttml =
        __webpack_require__(150).default;
}
if (true) {
    htmlParsers.srt =
        __webpack_require__(144).default;
}
if (true) {
    htmlParsers.vtt =
        __webpack_require__(143).default;
}
/* tslint:enable no-var-requires */
/**
 * @param {string} type
 * @param {string} data
 * @param {Number} timeOffset
 * @param {string} [language]
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToElements(type, data, timeOffset, language) {
    log_1.default.debug("finding parser for html text tracks:", type);
    var parser = htmlParsers[type];
    if (!parser) {
        throw new Error("no parser found for the given text track");
    }
    log_1.default.debug("parser found, parsing...");
    var parsed = parser(data, timeOffset, language);
    log_1.default.debug("parsed successfully!", parsed);
    return parsed;
}
exports.default = parseTextTrackToElements;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * source buffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the source buffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the source buffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function areNearlyEqual(a, b) {
    return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}
/**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesBefore(cues, time) {
    for (var i = 0; i < cues.length; i++) {
        var cue = cues[i];
        if (time < cue.end) {
            if (time >= cue.start) {
                return cues.slice(0, i);
            }
            return cues.slice(0, i + 1);
        }
    }
    return cues.slice();
}
/**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesAfter(cues, time) {
    for (var i = 0; i < cues.length; i++) {
        var cue = cues[i];
        if (time < cue.end) {
            if (time >= cue.start) {
                return cues.slice(i + 1, cues.length);
            }
            return cues.slice(i, cues.length);
        }
    }
    return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */
function removeCuesInfosBetween(cuesInfos, start, end) {
    var end1 = Math.max(cuesInfos.start, start);
    var cuesInfos1 = {
        start: cuesInfos.start,
        end: end1,
        cues: getCuesBefore(cuesInfos.cues, start),
    };
    var start2 = Math.min(end, cuesInfos.end);
    var cuesInfos2 = {
        start: start2,
        end: cuesInfos.end,
        cues: getCuesAfter(cuesInfos.cues, end),
    };
    return [cuesInfos1, cuesInfos2];
}
/**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */
var TextBufferManager = /** @class */ (function () {
    function TextBufferManager() {
        this._cuesBuffer = [];
    }
    /**
     * Get corresponding cue for the given time.
     * A cue is an object with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * We do not mutate individual cue here.
     * That is, if the ``get`` method returns the same cue's reference than a
     * previous ``get`` call, its properties are guaranteed to have the exact same
     * values than before, if you did not mutate it on your side.
     * The inverse is true, if the values are the same than before, the reference
     * will stay the same (this is useful to easily check if the DOM should be
     * updated, for example).
     *
     * @param {Number} time
     * @returns {HTMLElement|undefined} - The cue to display
     */
    TextBufferManager.prototype.get = function (time) {
        var cuesBuffer = this._cuesBuffer;
        // begins at the end as most of the time the player will ask for the last
        // CuesGroup
        for (var i = cuesBuffer.length - 1; i >= 0; i--) {
            var cues = cuesBuffer[i].cues;
            for (var j = cues.length - 1; j >= 0; j--) {
                var cue = cues[j];
                if (time >= cue.start) {
                    if (time < cue.end) {
                        return cue;
                    }
                    else {
                        return undefined;
                    }
                }
            }
        }
        return undefined;
    };
    /**
     * Remove cue from a certain range of time.
     * @param {Number} from
     * @param {Number} to
     */
    TextBufferManager.prototype.remove = function (from, _to) {
        if (false) {}
        var to = Math.max(from, _to);
        var cuesBuffer = this._cuesBuffer;
        var len = cuesBuffer.length;
        for (var i = 0; i < len; i++) {
            if (cuesBuffer[i].end > from) {
                var startCuesInfos = cuesBuffer[i];
                if (startCuesInfos.start >= to) {
                    // our cue is strictly after this interval, we have nothing to do
                    return;
                }
                // ``to`` is within this segment
                if (startCuesInfos.end >= to) {
                    var _a = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _a[0], cuesInfos2 = _a[1];
                    this._cuesBuffer[i] = cuesInfos1;
                    cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    return;
                }
                // Else remove the part of the segment after ``from``, and the concerned
                // segments after that
                startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
                startCuesInfos.end = Math.max(from, startCuesInfos.start);
                for (var j = i + 1; j < len; j++) {
                    var endCuesInfos = cuesBuffer[i];
                    if (to <= endCuesInfos.end) {
                        // remove all cues from the start to this one non-included
                        cuesBuffer.splice(i + 1, j - (i + 1));
                        // if ``to`` is in the middle of the last segment
                        if (to > endCuesInfos.start) {
                            endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to);
                            endCuesInfos.start = to;
                        }
                        return;
                    }
                }
                cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
                return;
            }
        }
    };
    /**
     * Insert new cues in our text buffer.
     * cues is an array of objects with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * @param {Array.<Object>} cues - CuesGroups, array of objects with the
     * following properties:
     *   - start {Number}: the time at which the cue will start to be displayed
     *   - end {Number}: the time at which the cue will end to be displayed
     *   - cue {HTMLElement}: The cue
     * @param {Number} start - Start time at which the CuesGroup applies.
     * This is different than the start of the first cue to display in it, this
     * has more to do with the time at which the _text segment_ starts.
     * @param {Number} end - End time at which the CuesGroup applies.
     * This is different than the end of the last cue to display in it, this
     * has more to do with the time at which the _text segment_ ends.
     *
     * TODO add securities to ensure that:
     *   - the start of a CuesGroup is inferior or equal to the start of the first
     *     cue in it
     *   - the end of a CuesGroup is superior or equal to the end of the last
     *     cue in it
     * If those requirements are not met, we could delete some cues when adding
     * a CuesGroup before/after. Find a solution.
     */
    TextBufferManager.prototype.insert = function (cues, start, end) {
        var cuesBuffer = this._cuesBuffer;
        var cuesInfosToInsert = { start: start, end: end, cues: cues };
        for (var i = 0; i < cuesBuffer.length; i++) {
            var cuesInfos = cuesBuffer[i];
            if (start < cuesInfos.end) {
                if (areNearlyEqual(start, cuesInfos.start)) {
                    if (areNearlyEqual(end, cuesInfos.end)) {
                        // exact same segment
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |AAAAA|
                        // Which means:
                        //   1. replace the current cue with ours
                        cuesBuffer[i] = cuesInfosToInsert;
                        return;
                    }
                    else if (end < cuesInfos.end) {
                        // our cue overlaps with the current one:
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBBBBB|
                        //   Result:          |AAAAABBB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    // our cue goes beyond the current one:
                    //   ours:            |AAAAAAA|
                    //   the current one: |BBBB|
                    //   Result:          |AAAAAAA|
                    // Here we have to delete any cuesInfos which end before ours end,
                    // and see about the following one.
                    do {
                        cuesBuffer.splice(i, 1);
                        cuesInfos = cuesBuffer[i];
                    } while (cuesInfos && end > cuesInfos.end);
                    if (!cuesInfos || // There is no cue here
                        areNearlyEqual(end, cuesInfos.end) // this cue has the same end
                    ) {
                        // put in place
                        cuesBuffer[i] = cuesInfosToInsert;
                        return;
                    }
                    // else -> end < cuesInfos.end (overlapping case)
                    //   ours:            |AAAAA|
                    //   the current one: |BBBBBBBB|
                    //   Result:          |AAAAABBB|
                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                    cuesInfos.start = end;
                    cuesBuffer.splice(i, 0, cuesInfosToInsert);
                    return;
                }
                else if (start < cuesInfos.start) {
                    if (end < cuesInfos.start) {
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    else if (areNearlyEqual(end, cuesInfos.start)) {
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    // our cue overlaps the current one:
                    //   ours:            |AAAAAAA|
                    //   the current one:     |BBBBB|
                    //   Result:          |AAAAAAABB|
                    // Which means:
                    //   1. remove some cues at the start of the current one
                    //   2. update start of current one
                    //   3. add ours before the current one
                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                    cuesInfos.start = end;
                    cuesBuffer.splice(i, 0, cuesInfosToInsert);
                    return;
                }
                // else -> start > cuesInfos.start
                if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) {
                    // our cue overlaps the current one:
                    //   ours:              |AAAAAA|
                    //   the current one: |BBBBB|
                    //   Result:          |BBAAAAAA|
                    //   - or -
                    //   ours:              |AAAA|
                    //   the current one: |BBBBBB|
                    //   Result:          |BBAAAA|
                    // Which means:
                    //   1. remove some cues at the end of the current one
                    //   2. update end of current one
                    //   3. add ours after current one
                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
                    cuesInfos.end = start;
                    cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                    return;
                }
                // else -> end < cuesInfos.end
                // our cue is in the current one:
                //   ours:              |AAA|
                //   the current one: |BBBBBBB|
                //   Result:          |BBAAABB|
                // Which means:
                //   1. split current one in two parts based on our cue.
                //   2. insert our cue into it.
                var _a = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _a[0], cuesInfos2 = _a[1];
                this._cuesBuffer[i] = cuesInfos1;
                cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                cuesBuffer.splice(i + 2, 0, cuesInfos2);
                return;
            }
        }
        // no cues group has the end after our current start.
        // These cues should be the last one
        cuesBuffer.push(cuesInfosToInsert);
    };
    return TextBufferManager;
}());
exports.default = TextBufferManager;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var events_1 = __webpack_require__(15);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var abstract_source_buffer_1 = __webpack_require__(48);
var buffer_manager_1 = __webpack_require__(153);
var parsers_1 = __webpack_require__(152);
var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config_1.default.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function generateClock(videoElement) {
    var seeking$ = events_1.onSeeking$(videoElement);
    var seeked$ = events_1.onSeeked$(videoElement);
    var ended$ = events_1.onEnded$(videoElement);
    var manualRefresh$ = Observable_1.Observable.merge(seeked$, ended$);
    var autoRefresh$ = Observable_1.Observable
        .interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)
        .startWith(null);
    // TODO Better way to express that
    return manualRefresh$
        .startWith(null)
        .switchMapTo(autoRefresh$.mapTo(true)
        .takeUntil(seeking$)
        .concat(Observable_1.Observable.of(false)));
}
/**
 * @param {Element} element
 * @param {Element|null} [child]
 */
function safelyRemoveChild(element, child) {
    if (child) {
        try {
            element.removeChild(child);
        }
        catch (e) {
            log_1.default.warn("Can't remove text track: not in the element.");
        }
    }
}
/**
 * Source buffer to display TextTracks in the given HTML element.
 * @class HTMLTextTrackSourceBuffer
 */
var HTMLTextTrackSourceBuffer = /** @class */ (function (_super) {
    __extends(HTMLTextTrackSourceBuffer, _super);
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {HTMLElement} textTrackElement
     */
    function HTMLTextTrackSourceBuffer(videoElement, textTrackElement) {
        var _this = this;
        log_1.default.debug("creating html text track source buffer");
        _this = _super.call(this) || this;
        _this._videoElement = videoElement;
        _this._textTrackElement = textTrackElement;
        _this._destroy$ = new Subject_1.Subject();
        _this._buffer = new buffer_manager_1.default();
        _this._currentElement = null;
        generateClock(_this._videoElement)
            .takeUntil(_this._destroy$)
            .subscribe(function (shouldDisplay) {
            if (!shouldDisplay) {
                safelyRemoveChild(textTrackElement, _this._currentElement);
                _this._currentElement = null;
                return;
            }
            // to spread the time error, we divide the regular chosen interval.
            // As the clock is also based on real video events, we cannot just
            // divide by two the regular interval.
            var time = Math.max(_this._videoElement.currentTime -
                MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 2000, 0);
            var cue = _this._buffer.get(time);
            if (!cue) {
                safelyRemoveChild(textTrackElement, _this._currentElement);
                _this._currentElement = null;
                return;
            }
            else if (_this._currentElement === cue.element) {
                return;
            }
            safelyRemoveChild(textTrackElement, _this._currentElement);
            _this._currentElement = cue.element;
            textTrackElement.appendChild(_this._currentElement);
        });
        return _this;
    }
    /**
     * Append text tracks.
     * @param {Object} data
     * @param {string} data.type
     * @param {string} data.data
     * @param {string} data.language
     * @param {Number} data.timescale
     * @param {Number} data.start
     * @param {Number} data.timeOffset
     * @param {Number|undefined} data.end
     */
    HTMLTextTrackSourceBuffer.prototype._append = function (data) {
        log_1.default.debug("appending new html text tracks", data);
        var timescale = data.timescale, // timescale for the start and end
        timescaledStart = data.start, // exact beginning to which the track applies
        timescaledEnd = data.end, // exact end to which the track applies
        dataString = data.data, // text track content. Should be a string
        type = data.type, // type of texttracks (e.g. "ttml" or "vtt")
        language = data.language, // language the texttrack is in
        timeOffset = data.timeOffset;
        if (timescaledEnd && timescaledEnd - timescaledStart <= 0) {
            // this is accepted for error resilience, just skip that case.
            /* tslint:disable:max-line-length */
            log_1.default.warn("Invalid text track appended: the start time is inferior or equal to the end time.");
            /* tslint:enable:max-line-length */
            return;
        }
        var startTime = timescaledStart / timescale;
        var endTime = timescaledEnd != null ?
            timescaledEnd / timescale : undefined;
        var cues = parsers_1.default(type, dataString, timeOffset, language);
        var start = startTime;
        var end = endTime != null ? endTime : cues[cues.length - 1].end;
        this._buffer.insert(cues, start, end);
        this.buffered.insert(start, end);
    };
    /**
     * @param {Number} from
     * @param {Number} to
     */
    HTMLTextTrackSourceBuffer.prototype._remove = function (from, to) {
        log_1.default.debug("removing html text track data", from, to);
        this._buffer.remove(from, to);
        this.buffered.remove(from, to);
    };
    /**
     * Free up ressources from this sourceBuffer
     */
    HTMLTextTrackSourceBuffer.prototype._abort = function () {
        log_1.default.debug("aborting html text track source buffer");
        this._destroy$.next();
        this._destroy$.complete();
        safelyRemoveChild(this._textTrackElement, this._currentElement);
    };
    return HTMLTextTrackSourceBuffer;
}(abstract_source_buffer_1.default));
exports.default = HTMLTextTrackSourceBuffer;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Feature switching the HTML TextTrack implementation
var HAS_HTML_MODE = true ||
    true ||
    true ||
    true;
var HAS_NATIVE_MODE = true ||
    true ||
    true ||
    true;
/* tslint:disable no-var-requires */
var HTMLTextSourceBuffer = HAS_HTML_MODE ?
    __webpack_require__(154).default :
    function () {
        throw new Error("Cannot display HTML subtitles: feature not activated.");
    };
exports.HTMLTextSourceBuffer = HTMLTextSourceBuffer;
var NativeTextSourceBuffer = HAS_NATIVE_MODE ?
    __webpack_require__(138).default :
    function () {
        throw new Error("Cannot display native subtitles: feature not activated.");
    };
exports.NativeTextSourceBuffer = NativeTextSourceBuffer;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var log_1 = __webpack_require__(1);
var SourceBufferAction;
(function (SourceBufferAction) {
    SourceBufferAction[SourceBufferAction["Append"] = 0] = "Append";
    SourceBufferAction[SourceBufferAction["Remove"] = 1] = "Remove";
})(SourceBufferAction || (SourceBufferAction = {}));
/**
 * Wrap a SourceBuffer and append/remove segments in it in a queue.
 *
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */
var QueuedSourceBuffer = /** @class */ (function () {
    /**
     * @constructor
     * @param {SourceBuffer} sourceBuffer
     */
    function QueuedSourceBuffer(sourceBuffer) {
        this._buffer = sourceBuffer;
        this._queue = [];
        this._flushing = null;
        this._lastInitSegment = null;
        this.__onUpdate = this._onUpdate.bind(this);
        this.__onError = this._onError.bind(this);
        this.__flush = this._flush.bind(this);
        this._buffer.addEventListener("update", this.__onUpdate);
        this._buffer.addEventListener("error", this.__onError);
        this._buffer.addEventListener("updateend", this.__flush);
    }
    /**
     * Append media segment to the attached SourceBuffer, in a FIFO queue.
     *
     * Depending on the type of data appended, this might need an associated
     * initialization segment.
     *
     * Such initialization segment will be pushed in the SourceBuffer if the
     * last segment pushed was associated to another initialization segment.
     * This detection is entirely reference-based so make sure that the same
     * initSegment argument given share the same reference.
     *
     * You can deactivate the usage of initialization segment by setting the
     * initSegment argument to null.
     *
     * You can also only push an initialization segment by setting the segment
     * argument to null.
     * @param {*|null} initSegment
     * @param {*|null} segment
     * @returns {Observable}
     */
    QueuedSourceBuffer.prototype.appendBuffer = function (initSegment, segment) {
        var _this = this;
        return Observable_1.Observable.defer(function () {
            return _this._queueAction({
                type: SourceBufferAction.Append,
                segment: segment,
                initSegment: initSegment,
            });
        });
    };
    /**
     * Remove data from the attached SourceBuffer, in a FIFO queue.
     * @param {Object} range
     * @param {Number} range.start - start position, in seconds
     * @param {Number} range.end - end position, in seconds
     * @returns {Observable}
     */
    QueuedSourceBuffer.prototype.removeBuffer = function (_a) {
        var _this = this;
        var start = _a.start, end = _a.end;
        return Observable_1.Observable.defer(function () {
            return _this._queueAction({
                type: SourceBufferAction.Remove,
                start: start,
                end: end,
            });
        });
    };
    /**
     * Abort the linked SourceBuffer and dispose of the ressources used by this
     * QueuedSourceBuffer.
     *
     * /!\ You won't be able to use the QueuedSourceBuffer after calling this
     * function.
     * @private
     */
    QueuedSourceBuffer.prototype.abort = function () {
        this.dispose();
        this._buffer.abort();
    };
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    QueuedSourceBuffer.prototype.getBuffered = function () {
        return this._buffer.buffered;
    };
    /**
     * Free up ressources used by this class.
     *
     * /!\ You won't be able to use the QueuedSourceBuffer after calling this
     * function.
     */
    QueuedSourceBuffer.prototype.dispose = function () {
        this._buffer.removeEventListener("update", this.__onUpdate);
        this._buffer.removeEventListener("error", this.__onError);
        this._buffer.removeEventListener("updateend", this.__flush);
        this._queue.length = 0;
        this._flushing = null;
    };
    /**
     * Callback used for the 'update' event, as a segment has been added/removed.
     *
     * Emit and complete the corresponding subject to inform the action caller
     * of completion.
     *
     * @private
     */
    QueuedSourceBuffer.prototype._onUpdate = function () {
        if (this._flushing) {
            this._flushing.next(undefined);
            this._flushing.complete();
            this._flushing = null;
        }
    };
    /**
     * Callback used for the 'error' event from the SourceBuffer.
     *
     * Emit the error through the corresponding subject to inform the action
     * caller.
     *
     * @private
     * @param {Error} error
     */
    QueuedSourceBuffer.prototype._onError = function (error) {
        if (this._flushing) {
            this._flushing.error(error);
            this._flushing = null;
        }
    };
    /**
     * Queue a new action.
     * Begin flushing if no action were previously in the queue.
     * @private
     * @param {Object} action
     * @returns {Subject} - Can be used to follow the buffer action advancement.
     */
    QueuedSourceBuffer.prototype._queueAction = function (action) {
        var shouldFlush = !this._queue.length;
        var subject = new Subject_1.Subject();
        if (action.type === SourceBufferAction.Append) {
            var segment = action.segment, initSegment = action.initSegment;
            if (initSegment === null && segment === null) {
                log_1.default.warn("QueuedSourceBuffer: no segment appended.");
                return Observable_1.Observable.of(undefined);
            }
            if (initSegment === null) {
                this._queue.unshift({
                    type: SourceBufferAction.Append,
                    args: segment,
                    // case
                    subject: subject,
                });
            }
            else if (segment === null) {
                if (this._lastInitSegment === initSegment) {
                    return Observable_1.Observable.of(undefined);
                }
                this._queue.unshift({
                    type: SourceBufferAction.Append,
                    args: initSegment,
                    subject: subject,
                });
            }
            else {
                if (this._lastInitSegment !== initSegment) {
                    this._queue.unshift({
                        type: SourceBufferAction.Append,
                        args: initSegment,
                        subject: null,
                    });
                }
                this._queue.unshift({
                    type: SourceBufferAction.Append,
                    args: segment,
                    subject: subject,
                });
            }
            this._lastInitSegment = initSegment;
        }
        else if (action.type === SourceBufferAction.Remove) {
            this._queue.unshift({
                type: SourceBufferAction.Remove,
                args: {
                    start: action.start,
                    end: action.end,
                },
                subject: subject,
            });
        }
        else {
            throw new Error("QueuedSourceBuffer: unrecognized action");
        }
        if (shouldFlush) {
            this._flush();
        }
        return subject.mapTo(undefined);
    };
    /**
     * Perform next queued action if one and none are pending.
     * @private
     */
    QueuedSourceBuffer.prototype._flush = function () {
        if (this._flushing || this._queue.length === 0 || this._buffer.updating) {
            return;
        }
        // TODO TypeScrypt do not get the previous length check? Find solution /
        // open issue
        var queueElement = this._queue.pop();
        this._flushing = queueElement.subject;
        try {
            switch (queueElement.type) {
                case SourceBufferAction.Append:
                    log_1.default.debug("pushing data to source buffer", queueElement.args);
                    this._buffer.appendBuffer(queueElement.args);
                    break;
                case SourceBufferAction.Remove:
                    var _a = queueElement.args, start = _a.start, end = _a.end;
                    log_1.default.debug("removing data from source buffer", start, end);
                    this._buffer.remove(start, end);
                    break;
            }
        }
        catch (e) {
            this._onError(e);
        }
    };
    return QueuedSourceBuffer;
}());
exports.default = QueuedSourceBuffer;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
var ranges_1 = __webpack_require__(16);
/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */
var ManualTimeRanges = /** @class */ (function () {
    function ManualTimeRanges() {
        this._ranges = [];
        this.length = 0;
    }
    ManualTimeRanges.prototype.insert = function (start, end) {
        if (false) {}
        ranges_1.insertInto(this._ranges, { start: start, end: end });
        this.length = this._ranges.length;
    };
    ManualTimeRanges.prototype.remove = function (start, end) {
        if (false) {}
        var rangesToIntersect = [];
        if (start > 0) {
            rangesToIntersect.push({ start: 0, end: start });
        }
        if (end < Infinity) {
            rangesToIntersect.push({ start: end, end: Infinity });
        }
        ranges_1.keepRangeIntersection(this._ranges, rangesToIntersect);
        this.length = this._ranges.length;
    };
    ManualTimeRanges.prototype.start = function (index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].start;
    };
    ManualTimeRanges.prototype.end = function (index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].end;
    };
    return ManualTimeRanges;
}());
exports.default = ManualTimeRanges;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_source_buffer_1 = __webpack_require__(48);
// TODO
var ImageSourceBuffer = /** @class */ (function (_super) {
    __extends(ImageSourceBuffer, _super);
    function ImageSourceBuffer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {Object} data
     */
    ImageSourceBuffer.prototype._append = function (data) {
        var start = data.start, end = data.end, timescale = data.timescale;
        this.buffered.insert(start / timescale, end == null ? Number.MAX_VALUE : end / timescale);
    };
    // TODO
    /* tslint:disable no-empty */
    ImageSourceBuffer.prototype._remove = function () { };
    /* tslint:enable no-empty */
    // TODO
    /* tslint:disable no-empty */
    ImageSourceBuffer.prototype._abort = function () { };
    return ImageSourceBuffer;
}(abstract_source_buffer_1.default));
exports.default = ImageSourceBuffer;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var Subject_1 = __webpack_require__(7);
var id_1 = __webpack_require__(19);
var core_pipeline_1 = __webpack_require__(78);
/**
 * Create a function which will fetch segments.
 *
 * This function will:
 *   - only emit the resulting data
 *   - dispatch the other infos through the right subjects.
 *
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} network$ - Subject through which network metrics will be
 * sent, for the ABR.
 * @param {Subject} requests$ - Subject through which requests infos will be
 * sent, for the ABR.
 * @param {Subject} warning$ - Subject through which minor requests error will
 * be sent.
 * @param {Object} options
 * @returns {Function}
 */
function createSegmentFetcher(bufferType, transport, network$, requests$, warning$, options) {
    var basePipeline$ = core_pipeline_1.default(transport[bufferType], options);
    var request$;
    var id;
    /**
     * Process a pipeline observable to adapt it to the Stream way:
     *   - use the network$ subject for network metrics (bandwitdh mesure)
     *   - use the requests subject for network requests and their progress
     *   - use the warning$ subject for retries' error messages
     *   - only emit the data
     * @param {string} pipelineType
     * @param {Observable} pipeline$
     * @returns {Observable}
     */
    return function fetchSegment(content) {
        return basePipeline$(content)
            .do(function (arg) {
            switch (arg.type) {
                case "error":
                    warning$.next(objectAssign(arg.value, { pipelineType: bufferType }));
                    break;
                case "metrics": {
                    var value = arg.value;
                    var size = value.size, duration = value.duration; // unwrapping for TS
                    // format it for ABR Handling
                    if (size != null && duration != null) {
                        network$.next({
                            type: bufferType,
                            value: {
                                size: size,
                                duration: duration,
                            },
                        });
                    }
                    break;
                }
                case "request": {
                    var value = arg.value;
                    // format it for ABR Handling
                    var segment = value && value.segment;
                    if (segment != null && segment.duration != null) {
                        request$ = new Subject_1.Subject();
                        requests$.next(request$);
                        var duration = segment.duration / segment.timescale;
                        var time = segment.time / segment.timescale;
                        id = id_1.default();
                        request$.next({
                            type: bufferType,
                            event: "requestBegin",
                            value: {
                                duration: duration,
                                time: time,
                                requestTimestamp: Date.now(),
                                id: id,
                            },
                        });
                    }
                    break;
                }
                case "progress": {
                    var value = arg.value;
                    if (value.totalSize != null &&
                        value.size < value.totalSize &&
                        id != null &&
                        request$ != null) {
                        request$.next({
                            type: bufferType,
                            event: "progress",
                            value: {
                                duration: value.duration,
                                size: value.size,
                                totalSize: value.totalSize,
                                timestamp: Date.now(),
                                id: id,
                            },
                        });
                    }
                    break;
                }
            }
        })
            .filter(function (arg) {
            return arg.type === "data" || arg.type === "cache";
        })
            // take only value from data/cache events
            .map(function (_a) {
            var value = _a.value;
            return value;
        })
            .finally(function () {
            if (request$ != null) {
                if (id != null) {
                    request$.next({
                        type: bufferType,
                        event: "requestEnd",
                        value: { id: id },
                    });
                }
                request$.complete();
            }
        })
            .share(); // avoid multiple side effects if multiple subs
    };
}
exports.default = createSegmentFetcher;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
/**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * Observable.merge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   // To spice things up, update pObservable1 priority to go before
 *   // pObservable4
 *   if (i === 5) { // if pObservable5 is currently emitting
 *     prioritizer.updatePriority(pObservable1, 1);
 *   }
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */
var ObservablePrioritizer = /** @class */ (function () {
    function ObservablePrioritizer() {
        this._pendingPriority = null;
        this._numberOfPendingObservables = 0;
        this._queue = [];
    }
    /**
     * Create a priorized Observable from a base Observable.
     *
     * When subscribed to, this Observable will have its priority compared to
     * all the already-running Observables created from this class.
     * Only if this number is inferior or equal to the priority of the
     * currently-running Observables will it be immediately started.
     * In the opposite case, we will wait for higher-priority Observables to
     * finish before starting it.
     *
     * Note that while this Observable is waiting for its turn, it is possible
     * to update its property through the updatePriority method, by providing
     * the Observable returned by this function and its new priority number.
     *
     * @param {Observable} obs
     * @param {number} priority
     * @returns {Observable}
     */
    ObservablePrioritizer.prototype.create = function (obs, priority) {
        var _this = this;
        return Observable_1.Observable.defer(function () {
            if (_this._pendingPriority == null || _this._pendingPriority >= priority) {
                // Update the priority and start immediately the Observable
                _this._pendingPriority = priority;
                return _this._startObservable(obs);
            }
            else {
                var trigger = new Subject_1.Subject();
                _this._queue.push({
                    observable: obs,
                    priority: priority,
                    trigger: trigger,
                });
                return trigger
                    .mergeMap(function () { return _this._startObservable(obs); });
            }
        });
    };
    /**
     * Update the priority of an Observable created through the create method.
     *
     * Note that this will only have an effect on Observable which are not yet
     * started.
     * This means it will only have an effect on:
     *   - unsubscribed Observables
     *   - Observables waiting for Observables with an higher priority to
     *     finish
     *
     * @param {Observable} obs
     * @param {number} priority
     */
    ObservablePrioritizer.prototype.updatePriority = function (obs, priority) {
        var queueElement = arrayFind(this._queue, function (elt) { return elt.observable === obs; });
        if (!queueElement) {
            return;
        }
        queueElement.priority = priority;
    };
    ObservablePrioritizer.prototype._startObservable = function (obs) {
        var _this = this;
        var onObservableFinish = function () {
            _this._numberOfPendingObservables--;
            if (_this._numberOfPendingObservables > 0) {
                // still waiting for Observables to finish
                return;
            }
            _this._pendingPriority = null;
            if (_this._queue.length === 0) {
                return;
            }
            _this._pendingPriority = _this._queue
                .reduce(function (acc, elt) {
                return acc == null || acc > elt.priority ?
                    elt.priority : acc;
            }, null);
            for (var i = 0; i < _this._queue.length; i++) {
                var elt = _this._queue[i];
                if (elt.priority === _this._pendingPriority) {
                    _this._queue.splice(i, 1);
                    i--;
                    elt.trigger.next();
                    elt.trigger.complete();
                }
            }
        };
        this._numberOfPendingObservables++;
        return obs
            .finally(onObservableFinish);
    };
    return ObservablePrioritizer;
}());
exports.default = ObservablePrioritizer;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @returns {Object}
 */
function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
    return {
        /**
         * Create a Segment request with a given priority.
         * @param {Object} content - content to request
         * @param {Number} priority - priority at which the content should be
         * requested.
         * @returns {Observable}
         */
        createRequest: function (content, priority) {
            if (priority === void 0) { priority = 0; }
            return prioritizer.create(fetcher(content), priority);
        },
        /**
         * Update the priority of a pending request, created through createRequest.
         * @param {Observable} observable - the corresponding request
         * @param {Number} priority
         */
        updatePriority: function (observable, priority) {
            prioritizer.updatePriority(observable, priority);
        },
    };
}
exports.default = applyPrioritizerToSegmentFetcher;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var prioritized_segment_fetcher_1 = __webpack_require__(161);
var prioritizer_1 = __webpack_require__(160);
var segment_fetcher_1 = __webpack_require__(159);
/**
 * Interact with the networking pipelines to download segments and dispatch
 * the related events to the right subjects.
 *
 * @class SegmentPipelinesManager
 *
 * @example
 * ```js
 * const requests$ = new Subject();
 * const metrics$ = new Subject();
 * const warnings$ = new Subject();
 *
 * // 1 - create the manager
 * const segmentPipelinesManager =
 *   new SegmentPipelinesManager(transport, requests$, metrics$, warnings$);
 *
 * // Note:
 * // You can create an ABRManager with the same requests$ and metrics$ subjects.
 * // It will then be informed of when the SegmentPipelinesManager downloads
 * // segments and with which metrics.
 * // The format of those events is kept the same for ease of use.
 * const abrManager = new ABRManager(requests$, metrics$);
 *
 * // 2 - create a new pipeline with its own options
 * const pipeline = segmentPipelinesManager.createPipeline("audio", {
 *   maxRetry: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - request a content with a given priority
 * pipeline.createRequest(myContent, 1)
 *   .subscribe((res) => console.log("audio segment downloaded:", res));
 * ```
 */
var SegmentPipelinesManager = /** @class */ (function () {
    /**
     * @param {Object} transport
     * @param {Subject} requestsInfos$
     * @param {Subject} metrics$
     * @param {Subject} warning
     */
    function SegmentPipelinesManager(transport, requestsInfos$, metrics$, warning) {
        this._transport = transport;
        this._metrics$ = metrics$;
        this._requestsInfos$ = requestsInfos$;
        this._warning$ = warning;
        this._prioritizer = new prioritizer_1.default();
    }
    /**
     * @param {string} bufferType
     * @param {Object} options
     * @returns {Function}
     */
    SegmentPipelinesManager.prototype.createPipeline = function (bufferType, options) {
        var segmentFetcher = segment_fetcher_1.default(bufferType, this._transport, this._metrics$, this._requestsInfos$, this._warning$, options);
        return prioritized_segment_fetcher_1.default(this._prioritizer, segmentFetcher);
    };
    return SegmentPipelinesManager;
}());
exports.default = SegmentPipelinesManager;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var errors_1 = __webpack_require__(6);
var backoff_1 = __webpack_require__(85);
/**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
function shouldRetry(error) {
    if (!(error instanceof errors_1.RequestError)) {
        return false;
    }
    if (error.type === errors_1.RequestErrorTypes.ERROR_HTTP_CODE) {
        return error.status >= 500 || error.status === 404;
    }
    return (error.type === errors_1.RequestErrorTypes.TIMEOUT ||
        error.type === errors_1.RequestErrorTypes.ERROR_EVENT);
}
function isOfflineRequestError(error) {
    return error.type === errors_1.RequestErrorTypes.ERROR_EVENT && compat_1.isOffline();
}
/**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable}
 * @param {Object} options
 * @param {Number} options.baseDelay - First delay set when and if:
 *   - the first observable throws
 *   - any observable throws an error which has a type different than the last
 *     one.
 * @param {Number} options.maxDelay - Maximum delay considered for the backoff.
 * Note that this delay is not exact as it will be "fuzzed".
 * @param {Number} options.maxRetryRegular - Maximum number of retry for
 * "regular" errors. That is, errors that are most likely due to the CDN.
 * @param {Number} options.maxRetryOffline - Maximum number of retry for
 * "offline" errors. That is, errors that are most likely due to the user being
 * offline.
 * @param {Function} [options.onRetry] - callback to call as an observable
 * throws. Will be called with two arguments:
 *   - The error thrown by the observable.
 *   - The counter for the current error type.
 * @returns {Observable}
 */
function downloadingBackoff(obs$, options) {
    var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry;
    var retryCount = 0;
    var ERROR_TYPES = {
        NONE: 0,
        REGULAR: 1,
        OFFLINE: 2,
    };
    var lastError = ERROR_TYPES.NONE;
    return obs$.catch(function (error, source) {
        if (!shouldRetry(error)) {
            throw error;
        }
        var currentError = error instanceof errors_1.RequestError &&
            isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;
        var maxRetry = currentError === ERROR_TYPES.OFFLINE ?
            maxRetryOffline : maxRetryRegular;
        if (currentError !== lastError) {
            retryCount = 0;
            lastError = currentError;
        }
        if (++retryCount > maxRetry) {
            throw error;
        }
        if (onRetry) {
            onRetry(error, retryCount);
        }
        var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
        var fuzzedDelay = backoff_1.getFuzzedDelay(delay);
        return Observable_1.Observable.timer(fuzzedDelay)
            .mergeMap(function () { return source; });
    });
}
exports.default = downloadingBackoff;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */
var StaticRepresentationIndex = /** @class */ (function () {
    function StaticRepresentationIndex() {
    }
    /**
     * @returns {Object}
     */
    StaticRepresentationIndex.prototype.getInitSegment = function () {
        return null;
    };
    /**
     * Returns the only Segment available here.
     * @returns {Array.<Object>}
     */
    StaticRepresentationIndex.prototype.getSegments = function () {
        return [{
                id: "0",
                isInit: false,
                number: 0,
                time: 0,
                duration: Number.MAX_VALUE,
                timescale: 1,
            }];
    };
    /**
     * Returns first position in index.
     * @returns {undefined}
     */
    StaticRepresentationIndex.prototype.getFirstPosition = function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    };
    /**
     * Returns last position in index.
     * @returns {undefined}
     */
    StaticRepresentationIndex.prototype.getLastPosition = function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    };
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * @returns {Boolean}
     */
    StaticRepresentationIndex.prototype.shouldRefresh = function () {
        return false;
    };
    /**
     * @returns {Number}
     */
    StaticRepresentationIndex.prototype.checkDiscontinuity = function () {
        return -1;
    };
    /**
     * @returns {Array}
     */
    StaticRepresentationIndex.prototype._addSegments = function () {
        if (false) {}
    };
    StaticRepresentationIndex.prototype._update = function () {
        log_1.default.warn("Tried to update a static RepresentationIndex");
    };
    return StaticRepresentationIndex;
}());
exports.default = StaticRepresentationIndex;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var id_1 = __webpack_require__(19);
var languages_1 = __webpack_require__(29);
var adaptation_1 = __webpack_require__(81);
var representation_index_1 = __webpack_require__(79);
/**
 * @param {Array.<Object>} adaptations
 * @returns {Object}
 */
function createManifestAdaptations(adaptations) {
    return adaptations.reduce(function (acc, adaptation) {
        var type = adaptation.type, representations = adaptation.representations;
        if (!representations.length) {
            return acc;
        }
        if (!acc[type]) {
            acc[type] = [];
        }
        acc[type].push(new adaptation_1.default(adaptation));
        return acc;
    }, {});
}
var Period = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} args
     */
    function Period(args) {
        this.id = args.id;
        this.adaptations = createManifestAdaptations(args.adaptations);
        this.duration = args.duration;
        this.start = args.start;
        if (this.duration != null && this.start != null) {
            this.end = this.start + this.duration;
        }
    }
    /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} imageTracks
     */
    Period.prototype.addSupplementaryImageAdaptations = function (imageTracks) {
        var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
        var newImageTracks = _imageTracks.map(function (_a) {
            var mimeType = _a.mimeType, url = _a.url;
            var adaptationID = "gen-image-ada-" + id_1.default();
            var representationID = "gen-image-rep-" + id_1.default();
            return new adaptation_1.default({
                id: adaptationID,
                type: "image",
                manuallyAdded: true,
                representations: [{
                        baseURL: url,
                        bitrate: 0,
                        id: representationID,
                        mimeType: mimeType,
                        index: new representation_index_1.StaticRepresentationIndex(),
                    }],
            });
        });
        if (newImageTracks.length) {
            this.adaptations.image = this.adaptations.image ?
                this.adaptations.image.concat(newImageTracks) : newImageTracks;
        }
    };
    /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} textTracks
     */
    Period.prototype.addSupplementaryTextAdaptations = function (textTracks) {
        var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
        var newTextAdaptations = _textTracks.reduce(function (allSubs, _a) {
            var mimeType = _a.mimeType, codecs = _a.codecs, url = _a.url, language = _a.language, languages = _a.languages, closedCaption = _a.closedCaption;
            var langsToMapOn = language ? [language] : languages || [];
            return allSubs.concat(langsToMapOn.map(function (_language) {
                var adaptationID = "gen-text-ada-" + id_1.default();
                var representationID = "gen-text-rep-" + id_1.default();
                return new adaptation_1.default({
                    id: adaptationID,
                    type: "text",
                    language: _language,
                    normalizedLanguage: languages_1.normalize(_language),
                    closedCaption: closedCaption,
                    manuallyAdded: true,
                    representations: [{
                            baseURL: url,
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            codecs: codecs,
                            index: new representation_index_1.StaticRepresentationIndex(),
                        }],
                });
            }));
        }, []);
        if (newTextAdaptations.length) {
            this.adaptations.text = this.adaptations.text ?
                this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
        }
    };
    /**
     * @returns {Array.<Object>}
     */
    Period.prototype.getAdaptations = function () {
        var adaptationsByType = this.adaptations;
        if (!adaptationsByType) {
            return [];
        }
        var adaptationsList = [];
        for (var adaptationType in adaptationsByType) {
            if (adaptationsByType.hasOwnProperty(adaptationType)) {
                var adaptations = adaptationsByType[adaptationType];
                adaptationsList.push.apply(adaptationsList, adaptations);
            }
        }
        return adaptationsList;
    };
    Period.prototype.getAdaptationsForType = function (adaptationType) {
        var adaptations = this.adaptations[adaptationType];
        return adaptations || [];
    };
    Period.prototype.getAdaptation = function (wantedId) {
        return arrayFind(this.getAdaptations(), function (_a) {
            var id = _a.id;
            return wantedId === id;
        });
    };
    return Period;
}());
exports.default = Period;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var assert_1 = __webpack_require__(4);
var id_1 = __webpack_require__(19);
var languages_1 = __webpack_require__(29);
var log_1 = __webpack_require__(1);
var adaptation_1 = __webpack_require__(81);
exports.Adaptation = adaptation_1.default;
var period_1 = __webpack_require__(165);
exports.Period = period_1.default;
var representation_1 = __webpack_require__(80);
exports.Representation = representation_1.default;
var representation_index_1 = __webpack_require__(79);
/**
 * Normalized Manifest structure.
 * @class Manifest
 */
var Manifest = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} args
     */
    function Manifest(args) {
        var nId = id_1.default();
        this.id = args.id == null ? nId : "" + args.id;
        this.transport = args.transportType || "";
        // TODO Real period management
        this.periods = args.periods.map(function (period) {
            return new period_1.default(period);
        });
        /**
         * @deprecated TODO It is here to ensure compatibility with the way the
         * v3.x.x manages adaptations at the Manifest level
         */
        this.adaptations = (this.periods[0] && this.periods[0].adaptations) || [];
        this.minimumTime = args.minimumTime;
        this.isLive = args.type === "dynamic";
        this.uris = args.uris;
        this.suggestedPresentationDelay = args.suggestedPresentationDelay;
        this.availabilityStartTime = args.availabilityStartTime;
        this.presentationLiveGap = args.presentationLiveGap;
        this.timeShiftBufferDepth = args.timeShiftBufferDepth;
        // --------- private data
        this._duration = args.duration;
        if (false) {}
    }
    /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} imageTracks
     */
    Manifest.prototype.addSupplementaryImageAdaptations = function (imageTracks) {
        var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
        var newImageTracks = _imageTracks.map(function (_a) {
            var mimeType = _a.mimeType, url = _a.url;
            var adaptationID = "gen-image-ada-" + id_1.default();
            var representationID = "gen-image-rep-" + id_1.default();
            return new adaptation_1.default({
                id: adaptationID,
                type: "image",
                manuallyAdded: true,
                representations: [{
                        baseURL: url,
                        bitrate: 0,
                        id: representationID,
                        mimeType: mimeType,
                        index: new representation_index_1.StaticRepresentationIndex(),
                    }],
            });
        });
        if (newImageTracks.length) {
            this.adaptations.image = this.adaptations.image ?
                this.adaptations.image.concat(newImageTracks) : newImageTracks;
        }
    };
    /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @param {Object|Array.<Object>} textTracks
     */
    Manifest.prototype.addSupplementaryTextAdaptations = function (textTracks) {
        var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
        var newTextAdaptations = _textTracks.reduce(function (allSubs, _a) {
            var mimeType = _a.mimeType, codecs = _a.codecs, url = _a.url, language = _a.language, languages = _a.languages, closedCaption = _a.closedCaption;
            var langsToMapOn = language ? [language] : languages || [];
            return allSubs.concat(langsToMapOn.map(function (_language) {
                var adaptationID = "gen-text-ada-" + id_1.default();
                var representationID = "gen-text-rep-" + id_1.default();
                return new adaptation_1.default({
                    id: adaptationID,
                    type: "text",
                    language: _language,
                    normalizedLanguage: languages_1.normalize(_language),
                    closedCaption: closedCaption,
                    manuallyAdded: true,
                    representations: [{
                            baseURL: url,
                            bitrate: 0,
                            id: representationID,
                            mimeType: mimeType,
                            codecs: codecs,
                            index: new representation_index_1.StaticRepresentationIndex(),
                        }],
                });
            }));
        }, []);
        if (newTextAdaptations.length) {
            this.adaptations.text = this.adaptations.text ?
                this.adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
        }
    };
    /**
     * Returns Period encountered at the given time.
     * Returns undefined if there is no Period exactly at the given time.
     * @param {number} time
     * @returns {Period|undefined}
     */
    Manifest.prototype.getPeriodForTime = function (time) {
        return arrayFind(this.periods, function (period) {
            return time >= period.start &&
                (period.end == null || period.end > time);
        });
    };
    /**
     * Returns period coming just after a given period.
     * Returns undefined if not found.
     * @param {Period} period
     * @returns {Period|null}
     */
    Manifest.prototype.getPeriodAfter = function (period) {
        var endOfPeriod = period.end;
        if (endOfPeriod == null) {
            return null;
        }
        return arrayFind(this.periods, function (_period) {
            return _period.end == null || endOfPeriod < _period.end;
        }) || null;
    };
    /**
     * @returns {Number}
     */
    Manifest.prototype.getDuration = function () {
        return this._duration;
    };
    /**
     * @returns {string|undefined}
     */
    Manifest.prototype.getUrl = function () {
        return this.uris[0];
    };
    /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    Manifest.prototype.getAdaptations = function () {
        var firstPeriod = this.periods[0];
        if (!firstPeriod) {
            return [];
        }
        var adaptationsByType = firstPeriod.adaptations;
        var adaptationsList = [];
        for (var adaptationType in adaptationsByType) {
            if (adaptationsByType.hasOwnProperty(adaptationType)) {
                var adaptations = adaptationsByType[adaptationType];
                adaptationsList.push.apply(adaptationsList, adaptations);
            }
        }
        return adaptationsList;
    };
    /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    Manifest.prototype.getAdaptationsForType = function (adaptationType) {
        var firstPeriod = this.periods[0];
        if (!firstPeriod) {
            return [];
        }
        return firstPeriod.adaptations[adaptationType] || [];
    };
    /**
     * TODO log deprecation
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    Manifest.prototype.getAdaptation = function (wantedId) {
        /* tslint:disable:deprecation */
        return arrayFind(this.getAdaptations(), function (_a) {
            var id = _a.id;
            return wantedId === id;
        });
        /* tslint:enable:deprecation */
    };
    /**
     * @param {number} delta
     */
    Manifest.prototype.updateLiveGap = function (delta) {
        if (this.isLive) {
            if (this.presentationLiveGap) {
                this.presentationLiveGap += delta;
            }
            else {
                this.presentationLiveGap = delta;
            }
        }
    };
    /**
     * Update the current manifest properties
     * @param {Object} Manifest
     */
    Manifest.prototype.update = function (newManifest) {
        this._duration = newManifest.getDuration();
        this.timeShiftBufferDepth = newManifest.timeShiftBufferDepth;
        this.availabilityStartTime = newManifest.availabilityStartTime;
        this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
        this.uris = newManifest.uris;
        var oldPeriods = this.periods;
        var newPeriods = newManifest.periods;
        var _loop_1 = function (i) {
            var oldPeriod = oldPeriods[i];
            var newPeriod = arrayFind(newPeriods, function (a) { return a.id === oldPeriod.id; });
            if (!newPeriod) {
                log_1.default.info("Period " + oldPeriod.id + " not found after update. Removing.");
                oldPeriods.splice(i, 1);
                i--;
            }
            else {
                oldPeriod.start = newPeriod.start;
                oldPeriod.end = newPeriod.end;
                oldPeriod.duration = newPeriod.duration;
                var oldAdaptations = oldPeriod.getAdaptations();
                var newAdaptations = newPeriod.getAdaptations();
                var _loop_2 = function (j) {
                    var oldAdaptation = oldAdaptations[j];
                    var newAdaptation = arrayFind(newAdaptations, function (a) { return a.id === oldAdaptation.id; });
                    if (!newAdaptation) {
                        log_1.default.warn("manifest: adaptation \"" + oldAdaptations[j].id + "\" not found when merging.");
                    }
                    else {
                        var oldRepresentations = oldAdaptations[j].representations;
                        var newRepresentations = newAdaptation.representations;
                        var _loop_3 = function (k) {
                            var oldRepresentation = oldRepresentations[k];
                            var newRepresentation = arrayFind(newRepresentations, function (r) { return r.id === oldRepresentation.id; });
                            if (!newRepresentation) {
                                /* tslint:disable:max-line-length */
                                log_1.default.warn("manifest: representation \"" + oldRepresentations[k].id + "\" not found when merging.");
                                /* tslint:enable:max-line-length */
                            }
                            else {
                                oldRepresentation.baseURL = newRepresentation.baseURL;
                                oldRepresentations[k].index._update(newRepresentation.index);
                            }
                        };
                        for (var k = 0; k < oldRepresentations.length; k++) {
                            _loop_3(k);
                        }
                    }
                };
                for (var j = 0; j < oldAdaptations.length; j++) {
                    _loop_2(j);
                }
            }
            out_i_1 = i;
        };
        var out_i_1;
        for (var i = 0; i < oldPeriods.length; i++) {
            _loop_1(i);
            i = out_i_1;
        }
        // adding - perhaps - new Period[s]
        if (newPeriods.length > oldPeriods.length) {
            var lastOldPeriod = oldPeriods[oldPeriods.length - 1];
            if (lastOldPeriod) {
                for (var i = 0; i < newPeriods.length - 1; i++) {
                    var newPeriod = newPeriods[i];
                    if (newPeriod.start > lastOldPeriod.start) {
                        log_1.default.info("Adding new period " + newPeriod.id);
                        this.periods.push(newPeriod);
                    }
                }
            }
            else {
                for (var i = 0; i < newPeriods.length - 1; i++) {
                    var newPeriod = newPeriods[i];
                    log_1.default.info("Adding new period " + newPeriod.id);
                    this.periods.push(newPeriod);
                }
            }
        }
    };
    return Manifest;
}());
exports.default = Manifest;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var errors_1 = __webpack_require__(6);
var log_1 = __webpack_require__(1);
var index_1 = __webpack_require__(166);
var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];
/**
 * Run multiple checks before creating the Manifest:
 *   - filter out unsupported adaptation types
 *   - filter out adaptations without representations
 *   - filter out representations with an unsupported codec
 *   - check that every periods have at least one adaptation left
 *   - check that every adaptations have at least one representation left
 *
 * Then create a manifest and:
 *   - add supplementary text tracks
 *   - add supplementary image tracks
 *
 * @param {Object} manifest - the parsed manifest
 * @param {Array.<Object>|Object} externalTextTracks - Will be added to the
 * manifest as an adaptation.
 * @param {Array.<Object>|Object} externalImageTracks - Will be added to the
 * manifest as an adaptation.
 * @returns {Object}
 */
function createManifest(manifestObject, externalTextTracks, externalImageTracks, warning$) {
    manifestObject.periods = (manifestObject.periods).map(function (period) {
        period.adaptations = checkAdaptations(period.adaptations, warning$);
        return period;
    });
    // TODO Better way than this "as"
    var manifest = new index_1.default(manifestObject);
    manifest.addSupplementaryTextAdaptations(externalTextTracks);
    manifest.addSupplementaryImageAdaptations(externalImageTracks);
    return manifest;
}
exports.default = createManifest;
/**
 * Performs multiple checks on adaptations from a single period (things not
 * check-able by TypeScript itself like length of arrays).
 * Also filter unsupported codecs and unsupported adaptations types.
 * Throws if something is wrong.
 *
 * @param {Array.<Object>} initialAdaptations
 * @returns {Array.<Object>}
 */
function checkAdaptations(initialAdaptations, warning$) {
    var adaptations = initialAdaptations
        // 1. filter out adaptations from unsupported types
        .filter(function (adaptation) {
        if (SUPPORTED_ADAPTATIONS_TYPE.indexOf(adaptation.type) < 0) {
            log_1.default.info("not supported adaptation type", adaptation.type);
            var error = new errors_1.MediaError("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", null, false);
            warning$.next(error);
            return false;
        }
        else {
            return true;
        }
    })
        .map(function (adaptation) {
        if (adaptation.representations.length) {
            // 2. Filter from codecs and throw if none supported
            adaptation.representations = filterSupportedRepresentations(adaptation.type, adaptation.representations);
            if (adaptation.representations.length === 0) {
                log_1.default.warn("Incompatible codecs for adaptation", adaptation);
                var error = new errors_1.MediaError("MANIFEST_INCOMPATIBLE_CODECS_ERROR", null, false);
                warning$.next(error);
            }
        }
        return adaptation;
    })
        // 3. filter those without representations
        .filter(function (_a) {
        var representations = _a.representations;
        return representations.length;
    });
    // 4. throw if no adaptation
    if (adaptations.length === 0) {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    return adaptations;
}
/**
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */
function filterSupportedRepresentations(adaptationType, representations) {
    if (adaptationType === "audio" || adaptationType === "video") {
        return representations
            .filter(function (representation) {
            return compat_1.isCodecSupported(getCodec(representation));
        });
    }
    // TODO for the other types
    return representations;
    /**
     * Construct the codec string from given codecs and mimetype.
     * @param {Object} representation
     * @returns {string}
     */
    function getCodec(representation) {
        var _a = representation.codecs, codecs = _a === void 0 ? "" : _a, _b = representation.mimeType, mimeType = _b === void 0 ? "" : _b;
        return mimeType + ";codecs=\"" + codecs + "\"";
    }
}


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var factory_1 = __webpack_require__(167);
var core_pipeline_1 = __webpack_require__(78);
/**
 * Create function allowing to easily fetch and parse the manifest from its URL.
 *
 * @example
 * ```js
 * const manifestPipeline = createManifestPipeline(transport, warning$);
 * manifestPipeline(manifestURL)
 *  .subscribe(manifest => console.log("Manifest:", manifest));
 * ```
 *
 * @param {Object} transport
 * @param {Subject} warning$
 * @param {Array.<Object>} [supplementaryTextTracks=[]]
 * @param {Array.<Object>} [supplementaryImageTrack=[]]
 * @returns {Function}
 */
function createManifestPipeline(transport, pipelineOptions, warning$, supplementaryTextTracks, supplementaryImageTracks) {
    if (supplementaryTextTracks === void 0) { supplementaryTextTracks = []; }
    if (supplementaryImageTracks === void 0) { supplementaryImageTracks = []; }
    return function fetchManifest(url) {
        var manifest$ = core_pipeline_1.default(transport.manifest, pipelineOptions)({ url: url });
        return manifest$
            .do(function (arg) {
            if (arg.type === "error") {
                warning$.next(arg.value);
            }
        })
            .filter(function (arg) {
            return arg.type === "data" || arg.type === "cache";
        })
            .map(function (_a) {
            var value = _a.value;
            return factory_1.default(value.parsed.manifest, supplementaryTextTracks, supplementaryImageTracks, warning$);
        })
            .share();
    };
}
exports.default = createManifestPipeline;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var manifest_1 = __webpack_require__(168);
exports.createManifestPipeline = manifest_1.default;
var segment_1 = __webpack_require__(162);
exports.SegmentPipelinesManager = segment_1.default;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var BITRATE_REBUFFERING_RATIO = config_1.default.BITRATE_REBUFFERING_RATIO, MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;
/**
 * Returns true if the given Segment should be downloaded.
 * false otherwise.
 *
 * @param {Object} segment
 * @param {Object} content - The content the Segment depends on.
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @param {Object} segmentIDsToIgnore
 * @returns {boolean}
 */
function shouldDownloadSegment(segment, content, segmentBookkeeper, wantedRange, segmentIDsToIgnore) {
    var period = content.period, adaptation = content.adaptation, representation = content.representation;
    var shouldIgnore = segmentIDsToIgnore.test(segment.id);
    if (shouldIgnore) {
        return false;
    }
    // segment without time info are usually init segments or some
    // kind of metadata segment that we never filter out
    if (segment.isInit || segment.time < 0) {
        return true;
    }
    var time = segment.time, duration = segment.duration, timescale = segment.timescale;
    if (!duration) {
        return true;
    }
    if (duration / timescale < MINIMUM_SEGMENT_SIZE) {
        return false;
    }
    var currentSegment = segmentBookkeeper.hasPlayableSegment(wantedRange, { time: time, duration: duration, timescale: timescale });
    if (!currentSegment) {
        return true;
    }
    if (currentSegment.infos.period.id !== period.id ||
        currentSegment.infos.adaptation.id !== adaptation.id) {
        return true;
    }
    // only re-load comparatively-poor bitrates for the same adaptation.
    var bitrateCeil = currentSegment.infos.representation.bitrate *
        BITRATE_REBUFFERING_RATIO;
    return representation.bitrate > bitrateCeil;
}
exports.default = shouldDownloadSegment;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ranges_1 = __webpack_require__(16);
/**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} timing
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */
function getWantedRange(hardLimits, buffered, timing, bufferGoal, paddings) {
    var currentTime = timing.currentTime + timing.timeOffset;
    var limitEnd = timing.liveGap == null ?
        hardLimits.end :
        Math.min(hardLimits.end || Infinity, timing.currentTime + timing.liveGap);
    var boundedLimits = {
        start: Math.max(hardLimits.start || 0, currentTime),
        end: limitEnd,
    };
    var lowPadding = paddings.low, highPadding = paddings.high;
    // Difference between the current time and the end of the current range
    var bufferGap = ranges_1.getLeftSizeOfRange(buffered, currentTime);
    // the ts padding is the time offset that we want to apply to our current
    // start in order to calculate the starting point of the list of
    // segments to inject.
    var timestampPadding = bufferGap > lowPadding && bufferGap < Infinity ?
        Math.min(bufferGap, highPadding) : 0;
    return {
        start: Math.min(Math.max(currentTime + timestampPadding, boundedLimits.start), boundedLimits.end || Infinity),
        end: Math.min(Math.max(currentTime + bufferGoal, boundedLimits.start), boundedLimits.end || Infinity),
    };
}
exports.default = getWantedRange;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns every segments currently wanted.
 *
 * @param {Object} representation - The representation of the chosen
 * adaptation
 * @param {Object} range
 * @param {Object} options
 * @returns {Array.<Object>}
 */
function getSegmentsNeeded(representation, range) {
    var start = range.start, end = range.end;
    var duration = end - start;
    // given the current timestamp and the previously calculated time gap and
    // wanted buffer size, we can retrieve the list of segments to inject in
    // our pipelines.
    return representation.index.getSegments(start, duration);
}
exports.default = getSegmentsNeeded;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var SEGMENT_PRIORITIES_STEPS = config_1.default.SEGMENT_PRIORITIES_STEPS;
/**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */
function getSegmentPriority(segment, clockTick) {
    var currentTime = clockTick.currentTime + clockTick.timeOffset;
    var segmentStart = segment.time / segment.timescale;
    var distance = segmentStart - currentTime;
    for (var priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
        if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
            return priority;
        }
    }
    return SEGMENT_PRIORITIES_STEPS.length;
}
exports.default = getSegmentPriority;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var BUFFER_PADDING = config_1.default.BUFFER_PADDING;
/**
 * Get safety paddings (low and high) for the size of buffer that won't
 * be flushed when switching representation for smooth transitions
 * and avoiding buffer underflows.
 *
 * @param {Object} adaptation
 * @returns {Object}
 */
function getBufferPaddings(adaptation) {
    switch (adaptation.type) {
        case "audio":
        case "video":
            return BUFFER_PADDING[adaptation.type];
        default:
            return BUFFER_PADDING.other;
    }
}
exports.default = getBufferPaddings;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(16);
var GC_GAP_CALM = config_1.default.BUFFER_GC_GAPS.CALM;
var GC_GAP_BEEFY = config_1.default.BUFFER_GC_GAPS.BEEFY;
/**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {QueuedSourceBuffer} bufferingQueue
 * @returns {Observable}
 */
function forceGarbageCollection(timings$, bufferingQueue // The type of buffer has no importance here
) {
    // wait for next timing event
    return timings$.take(1).mergeMap(function (timing) {
        log_1.default.warn("buffer: running garbage collector");
        var buffered = bufferingQueue.getBuffered();
        var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
        // more aggressive GC if we could not find any range to clean
        if (cleanedupRanges.length === 0) {
            cleanedupRanges =
                selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);
        }
        log_1.default.debug("buffer: gc cleaning", cleanedupRanges);
        return Observable_1.Observable.from(cleanedupRanges.map(function (range) { return bufferingQueue.removeBuffer(range); })).concatAll();
    });
}
exports.default = forceGarbageCollection;
/**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Range>} - Ranges selected for clean up
 */
function selectGCedRanges(currentTime, buffered, gcGap) {
    var _a = ranges_1.getInnerAndOuterTimeRanges(buffered, currentTime), innerRange = _a.innerRange, outerRanges = _a.outerRanges;
    var cleanedupRanges = [];
    // start by trying to remove all ranges that do not contain the
    // current time and respect the gcGap
    // respect the gcGap? FIXME?
    for (var i = 0; i < outerRanges.length; i++) {
        var outerRange = outerRanges[i];
        if (currentTime - gcGap < outerRange.end) {
            cleanedupRanges.push(outerRange);
        }
        else if (currentTime + gcGap > outerRange.start) {
            cleanedupRanges.push(outerRange);
        }
    }
    // try to clean up some space in the current range
    if (innerRange) {
        log_1.default.debug("buffer: gc removing part of inner range", cleanedupRanges);
        if (currentTime - gcGap > innerRange.start) {
            cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap,
            });
        }
        if (currentTime + gcGap < innerRange.end) {
            cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end,
            });
        }
    }
    return cleanedupRanges;
}


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var force_garbage_collection_1 = __webpack_require__(175);
/**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Object} queuedSourceBuffer
 * @param {Object|null} initSegmentData
 * @param {Object} segment
 * @param {Object} segmentData
 * @returns {Observable}
 */
function appendDataToSourceBuffer(queuedSourceBuffer, initSegmentData, segment, segmentData) {
    var append$;
    if (segment.isInit) {
        append$ = initSegmentData == null ?
            Observable_1.Observable.of(undefined) :
            queuedSourceBuffer.appendBuffer(initSegmentData, null);
    }
    else {
        append$ = segmentData == null ?
            Observable_1.Observable.of(undefined) :
            queuedSourceBuffer.appendBuffer(initSegmentData, segmentData);
    }
    return append$;
}
/**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object|null} initSegmentData
 * @param {Object} segment
 * @param {Object} segmentData
 * @returns {Observable}
 */
function appendDataToSourceBufferWithRetries(clock$, queuedSourceBuffer, initSegmentData, segment, segmentData) {
    var append$ = appendDataToSourceBuffer(queuedSourceBuffer, initSegmentData, segment, segmentData);
    return append$
        .catch(function (appendError) {
        if (!appendError || appendError.name !== "QuotaExceededError") {
            throw new errors_1.MediaError("BUFFER_APPEND_ERROR", appendError, true);
        }
        return force_garbage_collection_1.default(clock$, queuedSourceBuffer)
            .mergeMapTo(append$)
            .catch(function (forcedGCError) {
            // (weird Typing either due to TypeScript or RxJS bug)
            throw new errors_1.MediaError("BUFFER_FULL_ERROR", forcedGCError, true);
        });
    });
}
exports.default = appendDataToSourceBufferWithRetries;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(39);
var log_1 = __webpack_require__(1);
var simple_set_1 = __webpack_require__(54);
var append_data_1 = __webpack_require__(176);
var get_buffer_paddings_1 = __webpack_require__(174);
var get_segment_priority_1 = __webpack_require__(173);
var get_segments_needed_1 = __webpack_require__(172);
var get_wanted_range_1 = __webpack_require__(171);
var segment_filter_1 = __webpack_require__(170);
/**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can be ran on the same
 * SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
function RepresentationBuffer(_a) {
    var clock$ = _a.clock$, // emit current playback informations
    content = _a.content, // all informations about the content we want to play
    queuedSourceBuffer = _a.queuedSourceBuffer, // allows to interact with the SourceBuffer
    segmentBookkeeper = _a.segmentBookkeeper, // keep track of what segments already are in the SourceBuffer
    segmentFetcher = _a.segmentFetcher, // allows to download new segments
    wantedBufferAhead$ = _a.wantedBufferAhead$;
    // unwrap components of the content
    var manifest = content.manifest, period = content.period, adaptation = content.adaptation, representation = content.representation;
    var bufferType = adaptation.type;
    var initSegment = representation.index.getInitSegment();
    // Compute paddings, then used to calculate the wanted range of Segments
    // wanted.
    var paddings = get_buffer_paddings_1.default(adaptation);
    // Saved initSegment state for this representation.
    var initSegmentObject = initSegment == null ?
        { segmentData: null, segmentInfos: null } : null;
    // Subject to start/restart a Buffer Queue.
    var startQueue$ = new ReplaySubject_1.ReplaySubject(1);
    // Segments queued for download in the BufferQueue.
    var downloadQueue = [];
    // Keep track of the informations about the pending Segment request.
    // null if no request is pending.
    var currentSegmentRequest = null;
    // Keep track of downloaded segments currently awaiting to be appended to the
    // SourceBuffer.
    //
    // This is to avoid scheduling another download for that segment.
    // The ID of each segment (segment.id) is thus added before each append and
    // removed after it.
    var sourceBufferWaitingQueue = new simple_set_1.default();
    /**
     * Request every Segment in the ``downloadQueue`` on subscription.
     * Emit the data of a segment when a request succeeded.
     * @returns {Observable}
     */
    function requestSegments() {
        var requestNextSegment$ = Observable_1.Observable.defer(function () {
            var currentNeededSegment = downloadQueue.shift();
            if (currentNeededSegment == null) {
                return Observable_1.Observable.empty();
            }
            var initInfos = initSegmentObject &&
                initSegmentObject.segmentInfos || undefined;
            var segment = currentNeededSegment.segment, priority = currentNeededSegment.priority;
            var request$ = segmentFetcher.createRequest({
                adaptation: adaptation,
                init: initInfos,
                manifest: manifest,
                period: period,
                representation: representation,
                segment: segment,
            }, priority);
            currentSegmentRequest = { segment: segment, priority: priority, request$: request$ };
            return request$
                .map(function (args) { return ({ segment: segment, value: args.parsed }); })
                .concat(requestNextSegment$);
        });
        return requestNextSegment$
            .finally(function () {
            currentSegmentRequest = null;
        });
    }
    /**
     * Append the given segment to the SourceBuffer.
     * Emit the right event when it succeeds.
     * @param {Object} data
     * @returns {Observable}
     */
    function appendSegment(data) {
        return Observable_1.Observable.defer(function () {
            var segment = data.segment;
            var _a = data.value, segmentInfos = _a.segmentInfos, segmentData = _a.segmentData;
            if (segment.isInit) {
                initSegmentObject = data.value;
            }
            if (segmentData == null) {
                // no segmentData to add here (for example, a text init segment)
                // just complete directly without appending anything
                return Observable_1.Observable.empty();
            }
            var initSegmentData = initSegmentObject && initSegmentObject.segmentData;
            var append$ = append_data_1.default(clock$, queuedSourceBuffer, initSegmentData, segment, segmentData);
            sourceBufferWaitingQueue.add(segment.id);
            return append$
                .mapTo({
                type: "added-segment",
                value: {
                    bufferType: bufferType,
                    segment: segment,
                    segmentData: segmentData,
                },
            })
                .do(function () {
                if (segment.isInit) {
                    return;
                }
                var _a = segmentInfos ? segmentInfos : segment, time = _a.time, duration = _a.duration, timescale = _a.timescale;
                // current segment timings informations are used to update
                // bufferedRanges informations
                segmentBookkeeper.insert(period, adaptation, representation, segment, time / timescale, // start
                duration != null ?
                    (time + duration) / timescale : undefined // end
                );
            })
                .finally(function () {
                sourceBufferWaitingQueue.remove(segment.id);
            });
        });
    }
    /**
     * Perform a check-up of the current status of the RepresentationBuffer:
     *   - synchronize the SegmentBookkeeper with the current buffered
     *   - checks if the manifest should be refreshed
     *   - checks if a discontinuity is encountered
     *   - check if segments need to be downloaded
     *   - Emit a description of the current state of the buffer
     *
     * @param {Array} arr
     * @returns {Object}
     */
    function getBufferStatus(_a) {
        var timing = _a[0], bufferGoal = _a[1];
        var buffered = queuedSourceBuffer.getBuffered();
        var neededRange = get_wanted_range_1.default(period, buffered, timing, bufferGoal, paddings);
        var discontinuity = getCurrentDiscontinuity(content, timing);
        var shouldRefreshManifest = shouldRefreshManifestForRange(content, neededRange);
        // /!\ Side effect to the SegmentBookkeeper
        segmentBookkeeper.synchronizeBuffered(buffered);
        var neededSegments = get_segments_needed_1.default(representation, neededRange)
            .filter(function (segment) {
            return segment_filter_1.default(segment, content, segmentBookkeeper, neededRange, sourceBufferWaitingQueue);
        })
            .map(function (segment) { return ({
            priority: get_segment_priority_1.default(segment, timing),
            segment: segment,
        }); });
        if (initSegment != null && initSegmentObject == null) {
            neededSegments = [
                {
                    segment: initSegment,
                    priority: get_segment_priority_1.default(initSegment, timing),
                }
            ].concat(neededSegments);
        }
        var state;
        if (!neededSegments.length) {
            state = period.end != null && neededRange.end >= period.end ?
                { type: "full-buffer", value: undefined } :
                { type: "idle-buffer", value: undefined };
        }
        else {
            state = {
                type: "need-segments",
                value: { neededSegments: neededSegments },
            };
        }
        return {
            discontinuity: discontinuity,
            shouldRefreshManifest: shouldRefreshManifest,
            state: state,
        };
    }
    /**
     * Exploit the status given by ``getBufferStatus``:
     *   - emit needed actions
     *   - mutates the downloadQueue
     *   - start/restart the current BufferQueue
     *   - emit the state of the Buffer
     * @param {Object} status
     * @returns {Observable}
     */
    function handleBufferStatus(status) {
        var discontinuity = status.discontinuity, shouldRefreshManifest = status.shouldRefreshManifest, state = status.state;
        var neededActions = getNeededActions(bufferType, discontinuity, shouldRefreshManifest);
        var downloadQueueState = updateQueueFromInternalState(state);
        return downloadQueueState.type === "idle-buffer" ? Observable_1.Observable.of.apply(Observable_1.Observable, neededActions) :
            Observable_1.Observable.of.apply(Observable_1.Observable, neededActions).concat(Observable_1.Observable.of(downloadQueueState));
    }
    /**
     * Update the downloadQueue and start/restart the queue depending on the
     * internalState and the current RepresentationBuffer's data.
     *
     * Returns the new state of the Downloading Queue.
     *
     * @param {Object} state
     * @returns {Object}
     */
    function updateQueueFromInternalState(state) {
        if (state.type !== "need-segments" || !state.value.neededSegments.length) {
            if (currentSegmentRequest) {
                log_1.default.debug("interrupting segment request.");
            }
            downloadQueue = [];
            startQueue$.next(undefined); // (re-)start with an empty queue
            return state.type === "full-buffer" ? {
                type: "full-buffer",
                value: { bufferType: bufferType },
            } : {
                type: "idle-buffer",
                value: { bufferType: bufferType },
            };
        }
        var neededSegments = state.value.neededSegments;
        var mostNeededSegment = neededSegments[0];
        if (!currentSegmentRequest) {
            log_1.default.debug("starting downloading queue", adaptation.type);
            downloadQueue = neededSegments;
            startQueue$.next(undefined); // restart the queue
        }
        else if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
            log_1.default.debug("canceling old downloading queue and starting a new one", adaptation.type);
            downloadQueue = neededSegments;
            startQueue$.next(undefined); // restart the queue
        }
        else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
            log_1.default.debug("updating pending request priority", adaptation.type);
            segmentFetcher.updatePriority(currentSegmentRequest.request$, mostNeededSegment.priority);
        }
        else {
            log_1.default.debug("updating downloading queue", adaptation.type);
            // Update the previous queue to be all needed segments but the first one,
            // for which a request is already pending
            var newQueue = neededSegments
                .slice() // clone previous
                .splice(1, neededSegments.length); // remove first element
            // (pending request)
            downloadQueue = newQueue;
        }
        return {
            type: "active-buffer",
            value: { bufferType: bufferType },
        };
    }
    /**
     * State Checker:
     *   - indicates when the manifest should be refreshed
     *   - indicates if a discontinuity is encountered
     *   - emit state updates
     *   - update the downloadQueue
     *   - start/restart the BufferQueue
     * @type {Observable}
     */
    var bufferState$ = Observable_1.Observable.combineLatest(clock$, wantedBufferAhead$)
        .map(getBufferStatus)
        .mergeMap(handleBufferStatus);
    /**
     * Buffer Queue:
     *   - download segment
     *   - append them to the SourceBuffer
     * @type {Observable}
     */
    var bufferQueue$ = startQueue$
        .switchMap(requestSegments)
        .mergeMap(appendSegment);
    return Observable_1.Observable.merge(bufferState$, bufferQueue$)
        .share();
}
exports.default = RepresentationBuffer;
/**
 * Emit the current discontinuity encountered.
 * Inferior or equal to 0 if no discontinuity is currently happening.
 * @param {Object} content
 * @param {Object} timing
 * @returns {number}
 */
function getCurrentDiscontinuity(_a, timing) {
    var manifest = _a.manifest, representation = _a.representation;
    return !timing.stalled || !manifest.isLive ?
        -1 : representation.index.checkDiscontinuity(timing.currentTime);
}
/**
 * Returns true if the current Manifest needs to be downloaded.
 * @param {Object} content
 * @param {Object} segmentBookkeeper
 * @param {Object} wantedRange
 * @returns {Boolean}
 */
function shouldRefreshManifestForRange(_a, wantedRange) {
    var representation = _a.representation;
    var start = wantedRange.start, end = wantedRange.end;
    return representation.index.shouldRefresh(start, end);
}
/**
 * @param {number} discontinuity
 * @param {boolean} shouldRefreshManifest
 * @returns {Array.<Object>}
 */
function getNeededActions(bufferType, discontinuity, shouldRefreshManifest) {
    var neededActions = [];
    if (discontinuity > 1) {
        neededActions.push({
            type: "discontinuity-encountered",
            value: {
                nextTime: discontinuity + 1,
                bufferType: bufferType,
            },
        });
    }
    if (shouldRefreshManifest) {
        neededActions.push({
            type: "needs-manifest-refresh",
            value: { bufferType: bufferType },
        });
    }
    return neededActions;
}


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
/**
 * Create empty Buffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 *
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */
function createFakeBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
    var period = content.period;
    return Observable_1.Observable.combineLatest(bufferClock$, wantedBufferAhead$)
        .filter(function (_a) {
        var clockTick = _a[0], wantedBufferAhead = _a[1];
        return period.end != null && clockTick.currentTime + wantedBufferAhead >= period.end;
    })
        .map(function () {
        return {
            type: "full-buffer",
            value: { bufferType: bufferType },
        };
    });
}
exports.default = createFakeBuffer;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFindIndex = __webpack_require__(83);
/**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation}
 */
function fromBitrateCeil(representations, bitrate) {
    var tooHighIndex = arrayFindIndex(representations, function (representation) { return representation.bitrate > bitrate; });
    if (tooHighIndex === -1) {
        return representations[representations.length - 1];
    }
    return representations[tooHighIndex - 1];
}
exports.default = fromBitrateCeil;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
/**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
function filterByWidth(representations, width) {
    var sortedRepsByWidth = representations
        .slice() // clone
        .sort(function (a, b) { return (a.width || 0) - (b.width || 0); });
    var repWithMaxWidth = arrayFind(sortedRepsByWidth, function (r) { return (r.width || 0) >= width; });
    if (repWithMaxWidth) {
        var maxWidth_1 = repWithMaxWidth.width || 0;
        return representations.filter(function (r) { return (r.width || 0) <= maxWidth_1; });
    }
    return representations;
}
exports.default = filterByWidth;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFindIndex = __webpack_require__(83);
/**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
function filterByBitrate(representations, bitrate) {
    var firstSuperiorBitrate = arrayFindIndex(representations, function (r) { return r.bitrate > bitrate; });
    if (firstSuperiorBitrate === -1) {
        return representations; // All representations have a lower bitrates.
    }
    return representations.slice(0, firstSuperiorBitrate);
}
exports.default = filterByBitrate;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var ewma_1 = __webpack_require__(84);
var FAST_EMA = 2;
var SLOW_EMA = 10;
var ABR_MINIMUM_TOTAL_BYTES = config_1.default.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config_1.default.ABR_MINIMUM_CHUNK_SIZE;
/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */
var BandwidthEstimator = /** @class */ (function () {
    function BandwidthEstimator() {
        /**
         * A fast-moving average.
         * @private
         */
        this._fast = new ewma_1.default(FAST_EMA);
        /**
         * A slow-moving average.
         * @private
         */
        this._slow = new ewma_1.default(SLOW_EMA);
        /**
         * Number of bytes sampled.
         * @private
         */
        this._bytesSampled = 0;
    }
    /**
     * Takes a bandwidth sample.
     * @param {number} durationMs The amount of time, in milliseconds, for a
     *   particular request.
     * @param {number} numBytes The total number of bytes transferred in that
     *   request.
     */
    BandwidthEstimator.prototype.addSample = function (durationInMs, numberOfBytes) {
        if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
            return;
        }
        var bandwidth = numberOfBytes * 8000 / durationInMs;
        var weight = durationInMs / 1000;
        this._bytesSampled += numberOfBytes;
        this._fast.addSample(weight, bandwidth);
        this._slow.addSample(weight, bandwidth);
    };
    /**
     * Get estimate of the bandwidth, in bits per seconds.
     * @returns {Number|undefined}
     */
    BandwidthEstimator.prototype.getEstimate = function () {
        if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
            return undefined;
        }
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this._fast.getEstimate(), this._slow.getEstimate());
    };
    /**
     * Reset the bandwidth estimation.
     */
    BandwidthEstimator.prototype.reset = function () {
        this._fast = new ewma_1.default(FAST_EMA);
        this._slow = new ewma_1.default(SLOW_EMA);
        this._bytesSampled = 0;
    };
    return BandwidthEstimator;
}());
exports.default = BandwidthEstimator;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var BehaviorSubject_1 = __webpack_require__(96);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var bandwidth_estimator_1 = __webpack_require__(182);
var ewma_1 = __webpack_require__(84);
var filterByBitrate_1 = __webpack_require__(181);
var filterByWidth_1 = __webpack_require__(180);
var fromBitrateCeil_1 = __webpack_require__(179);
var ABR_STARVATION_GAP = config_1.default.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config_1.default.OUT_OF_STARVATION_GAP, ABR_STARVATION_FACTOR = config_1.default.ABR_STARVATION_FACTOR, ABR_REGULAR_FACTOR = config_1.default.ABR_REGULAR_FACTOR;
/**
 * Returns an observable emitting only the representation concerned by the
 * bitrate ceil given.
 * @param {Array.<Representation>} representations
 * @param {number} bitrate
 * @returns {Observable}
 */
function setManualRepresentation(representations, bitrate) {
    var chosenRepresentation = fromBitrateCeil_1.default(representations, bitrate) ||
        representations[0];
    return Observable_1.Observable.of({
        bitrate: undefined,
        representation: chosenRepresentation,
    });
}
/**
 * Get the pending request containing the asked segment position.
 * @param {Object} requests
 * @param {number} segmentPosition
 * @returns {IRequestInfo|undefined}
 */
function getConcernedRequest(requests, segmentPosition) {
    var currentRequestIds = Object.keys(requests);
    var len = currentRequestIds.length;
    for (var i = 0; i < len - 1; i++) {
        var request = requests[currentRequestIds[i]];
        var chunkTime = request.time, chunkDuration = request.duration;
        // TODO review this
        if (Math.abs(segmentPosition - chunkTime) < chunkDuration) {
            return request;
        }
    }
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * Use progress events if available, set a much more random lower bitrate
 * if no progress events are available.
 *
 * @param {Object} request
 * @param {number} requestTime - Amount of time the request has taken for now,
 * in seconds.
 * @param {number} bitrate - Current bitrate at the time of download
 * @returns {number}
 */
function estimateRequestBandwidth(request, requestTime, bitrate) {
    var estimate;
    // try to infer quickly the current bitrate based on the
    // progress events
    if (request.progress.length >= 2) {
        var ewma1 = new ewma_1.default(2);
        var progress = request.progress;
        for (var i = 1; i < progress.length; i++) {
            var bytesDownloaded = progress[i].size - progress[i - 1].size;
            var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
            var reqBitrate = (bytesDownloaded * 8) / (timeElapsed / 1000);
            ewma1.addSample(timeElapsed / 1000, reqBitrate);
        }
        estimate = ewma1.getEstimate();
    }
    // if that fails / no progress event, take a guess
    if (!estimate && bitrate) {
        var chunkDuration = request.duration;
        var chunkSize = chunkDuration * bitrate;
        // take current duration of request as a base
        estimate = chunkSize / (requestTime * 5 / 4);
    }
    return estimate;
}
/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters
 * @param {number} [filters.bitrate] - max bitrate authorized (included).
 * @param {number} [filters.width] - max width authorized (included).
 * @returns {Representation[]}
 */
function getFilteredRepresentations(representations, filters) {
    var _representations = representations;
    if (filters.bitrate != null) {
        _representations = filterByBitrate_1.default(_representations, filters.bitrate);
    }
    if (filters.width != null) {
        _representations = filterByWidth_1.default(_representations, filters.width);
    }
    return _representations;
}
/**
 * Returns true if the request takes too much time relatively to how much we
 * should actually wait.
 * Depends on the chunk duration.
 * @param {number} durationOfRequest - time, in s, since the request has been
 * performed.
 * @param {number} chunkDuration - duration, in s, of a single chunk
 * @returns {Boolean}
 */
function requestTakesTime(durationOfRequest, chunkDuration) {
    return durationOfRequest > chunkDuration * 1.2 + 1;
}
/**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *   - etc.
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 * @class RepresentationChooser
 */
var RepresentationChooser = /** @class */ (function () {
    /**
     * @param {Object} options
     */
    function RepresentationChooser(options) {
        this._dispose$ = new Subject_1.Subject();
        this.manualBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.manualBitrate != null ?
            options.manualBitrate : -1);
        this.maxAutoBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.maxAutoBitrate != null ?
            options.maxAutoBitrate : Infinity);
        this.estimator = new bandwidth_estimator_1.default();
        this._currentRequests = {};
        this._initialBitrate = options.initialBitrate || 0;
        this._limitWidth$ = options.limitWidth$;
        this._throttle$ = options.throttle$;
    }
    /**
     * @param {Observable} clock$
     * @param {Array.<Object>} representations
     * @returns {Observable}
     */
    RepresentationChooser.prototype.get$ = function (clock$, representations) {
        var _this = this;
        if (representations.length < 2) {
            return Observable_1.Observable.of({
                bitrate: undefined,
                representation: representations.length ?
                    representations[0] : null,
            })
                .takeUntil(this._dispose$);
        }
        var _a = this, manualBitrate$ = _a.manualBitrate$, maxAutoBitrate$ = _a.maxAutoBitrate$, _initialBitrate = _a._initialBitrate;
        var _deviceEventsArray = [];
        if (this._limitWidth$) {
            _deviceEventsArray.push(this._limitWidth$.map(function (width) { return ({ width: width }); }));
        }
        if (this._throttle$) {
            _deviceEventsArray.push(this._throttle$.map(function (bitrate) { return ({ bitrate: bitrate }); }));
        }
        /**
         * Emit restrictions on the pools of available representations to choose
         * from.
         * @type {Observable}
         */
        var deviceEvents$ = _deviceEventsArray.length ?
            Observable_1.Observable.combineLatest.apply(Observable_1.Observable, _deviceEventsArray).map(function (args) { return objectAssign.apply(void 0, [{}].concat(args)); }) : Observable_1.Observable.of({});
        /**
         * Store the last client's bitrate generated by our estimation algorithms.
         * @type {Number|undefined}
         */
        var lastEstimatedBitrate;
        return manualBitrate$.switchMap(function (manualBitrate) {
            if (manualBitrate >= 0) {
                // MANUAL mode
                return setManualRepresentation(representations, manualBitrate);
            }
            // AUTO mode
            var inStarvationMode = false;
            return Observable_1.Observable.combineLatest(clock$, maxAutoBitrate$, deviceEvents$)
                .map(function (_a) {
                var clock = _a[0], maxAutoBitrate = _a[1], deviceEvents = _a[2];
                var nextBitrate;
                var bandwidthEstimate;
                var bufferGap = clock.bufferGap;
                // Check for starvation == not much left to play
                if (bufferGap <= ABR_STARVATION_GAP) {
                    inStarvationMode = true;
                }
                else if (inStarvationMode && bufferGap >= OUT_OF_STARVATION_GAP) {
                    inStarvationMode = false;
                }
                // If in starvation mode, check if the request for the next segment
                // takes too much time relatively to the chunk's duration.
                // If that's the case, re-calculate the bandwidth urgently based on
                // this single request.
                if (inStarvationMode) {
                    var position = clock.position, bitrate = clock.bitrate;
                    var nextSegmentPosition = bufferGap + position;
                    var request = getConcernedRequest(_this._currentRequests, nextSegmentPosition);
                    if (request) {
                        var chunkDuration = request.duration, requestTimestamp = request.requestTimestamp;
                        var now = Date.now();
                        var requestTimeInSeconds = (now - requestTimestamp) / 1000;
                        if (chunkDuration &&
                            requestTakesTime(requestTimeInSeconds, chunkDuration)) {
                            bandwidthEstimate = estimateRequestBandwidth(request, requestTimeInSeconds, bitrate);
                            if (bandwidthEstimate != null) {
                                // Reset all estimations to zero
                                // Note: this is weird to do this type of "global" side effect
                                // (for this class) in an observable, not too comfortable with
                                // that.
                                _this.resetEstimate();
                                if (bitrate != null) {
                                    nextBitrate = Math.min(bandwidthEstimate, bitrate, maxAutoBitrate);
                                }
                                else {
                                    nextBitrate = Math.min(bandwidthEstimate, maxAutoBitrate);
                                }
                            }
                        }
                    }
                }
                // if nextBitrate is not yet defined, do the normal estimation
                if (nextBitrate == null) {
                    bandwidthEstimate = _this.estimator.getEstimate();
                    var nextEstimate = void 0;
                    if (bandwidthEstimate != null) {
                        nextEstimate = inStarvationMode ?
                            bandwidthEstimate * ABR_STARVATION_FACTOR :
                            bandwidthEstimate * ABR_REGULAR_FACTOR;
                    }
                    else if (lastEstimatedBitrate != null) {
                        nextEstimate = inStarvationMode ?
                            lastEstimatedBitrate * ABR_STARVATION_FACTOR :
                            lastEstimatedBitrate * ABR_REGULAR_FACTOR;
                    }
                    else {
                        nextEstimate = _initialBitrate;
                    }
                    nextBitrate = Math.min(nextEstimate, maxAutoBitrate);
                }
                if (clock.speed > 1) {
                    nextBitrate /= clock.speed;
                }
                var _representations = getFilteredRepresentations(representations, deviceEvents);
                return {
                    bitrate: bandwidthEstimate,
                    representation: fromBitrateCeil_1.default(_representations, nextBitrate) ||
                        representations[0],
                };
            }).do(function (_a) {
                var bitrate = _a.bitrate;
                if (bitrate != null) {
                    lastEstimatedBitrate = bitrate;
                }
            }).share();
        });
    };
    /**
     * Add a bandwidth estimate by giving:
     *   - the duration of the request, in s
     *   - the size of the request in bytes
     * @param {number} duration
     * @param {number} size
     */
    RepresentationChooser.prototype.addEstimate = function (duration, size) {
        if (duration != null && size != null) {
            this.estimator.addSample(duration, size);
        }
    };
    /**
     * Reset all the estimates done until now.
     * Useful when the network situation changed completely.
     */
    RepresentationChooser.prototype.resetEstimate = function () {
        this.estimator.reset();
    };
    /**
     * Add informations about a new pending request.
     * This can be useful if the network bandwidth drastically changes to infer
     * a new bandwidth through this single request.
     * @param {string|number} id
     * @param {Object} payload
     */
    RepresentationChooser.prototype.addPendingRequest = function (id, payload) {
        if (this._currentRequests[id]) {
            if (false) {}
            log_1.default.warn("ABR: request already added.");
            return;
        }
        var _a = payload.value, time = _a.time, duration = _a.duration, requestTimestamp = _a.requestTimestamp;
        this._currentRequests[id] = {
            time: time,
            duration: duration,
            requestTimestamp: requestTimestamp,
            progress: [],
        };
        this._currentRequests[id].progress = [];
    };
    /**
     * Add progress informations to a pending request.
     * Progress objects are a key part to calculate the bandwidth from a single
     * request, in the case the user's bandwidth changes drastically while doing
     * it.
     * @param {string|number} id
     * @param {Object} progress
     */
    RepresentationChooser.prototype.addRequestProgress = function (id, progress) {
        if (!this._currentRequests[id]) {
            if (false) {}
            log_1.default.warn("ABR: progress for a request not added");
            return;
        }
        this._currentRequests[id].progress.push(progress.value);
    };
    /**
     * Remove a request previously set as pending through the addPendingRequest
     * method.
     * @param {string|number} id
     */
    RepresentationChooser.prototype.removePendingRequest = function (id) {
        if (!this._currentRequests[id]) {
            if (false) {}
            log_1.default.warn("ABR: can't remove unknown request");
        }
        delete this._currentRequests[id];
    };
    /**
     * Remove informations about all pending requests.
     */
    RepresentationChooser.prototype.resetRequests = function () {
        this._currentRequests = {};
    };
    /**
     * TODO See if we can avoid this
     */
    RepresentationChooser.prototype.dispose = function () {
        this._dispose$.next();
        this.manualBitrate$.complete();
        this.maxAutoBitrate$.complete();
    };
    return RepresentationChooser;
}());
exports.default = RepresentationChooser;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = __webpack_require__(7);
var representation_chooser_1 = __webpack_require__(183);
var defaultChooserOptions = {
    limitWidth: {},
    throttle: {},
    initialBitrates: {},
    manualBitrates: {},
    maxAutoBitrates: {},
};
/**
 * Create the right RepresentationChooser instance, from the given data.
 * @param {string} type
 * @param {Object} options
 * @returns {RepresentationChooser} - The RepresentationChooser instance
 */
var createChooser = function (type, options) {
    return new representation_chooser_1.default({
        limitWidth$: options.limitWidth[type],
        throttle$: options.throttle[type],
        initialBitrate: options.initialBitrates[type],
        manualBitrate: options.manualBitrates[type],
        maxAutoBitrate: options.maxAutoBitrates[type],
    });
};
/**
 * Adaptive BitRate Manager.
 *
 * Select the right representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */
var ABRManager = /** @class */ (function () {
    /**
     * @param {Observable} requests$ - Emit requests infos as they begin, progress
     * and end.
     * Allows to know if a request take too much time to be finished in
     * emergency times (e.g. when the user's bandwidth falls very quickly).
     *
     * The items emitted are Observables which each emit infos about a SINGLE
     * request. These infos are under the form of objects with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *
     *   - event {string}: Wether the request started, is progressing or has
     *     ended. Should be either one of these three strings:
     *       1. "requestBegin": The request has just begun.
     *
     *       2. "progress": Informations about the request progress were received
     *          (basically the amount of bytes currently received).
     *
     *       2. "requestEnd": The request just ended (successfully/on error/was
     *          canceled)
     *
     *     Note that it should ALWAYS happen in the following order:
     *     1 requestBegin -> 0+ progress -> 1 requestEnd
     *
     *     Also note that EVERY requestBegin should eventually be followed by a
     *     requestEnd at some point. If that's not the case, a memory leak
     *     can happen.
     *
     *   - value {Object|undefined}: The value depends on the type of event
     *     received:
     *       - for "requestBegin" events, it should be an object with the
     *         following keys:
     *           - id {number|String}: The id of this particular request.
     *           - duration {number}: duration, in seconds of the asked segment.
     *           - time {number}: The start time, in seconds of the asked segment.
     *           - requestTimestamp {number}: the timestamp at which the request
     *             was sent, in ms.
     *
     *       - for "progress" events, it should be an object with the following
     *         keys:
     *           - id {number|String}: The id of this particular request.
     *           - size {number}: amount currently downloaded, in bytes
     *           - timestamp {number}: timestamp at which the progress event was
     *             received, in ms
     *         Those events SHOULD be received in order (that is, in increasing
     *         order for both size and timestamp).
     *
     *       - for "requestEnd" events:
     *           - id {number|String}: The id of this particular request.
     *
     * @param {Observable} metrics$ - Emit each times the network downloaded
     * a new segment for a given buffer type. Allows to obtain informations about
     * the user's bitrate.
     *
     * The items emitted are object with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *   - value {Object}:
     *     - duration {number}: duration of the request, in seconds.
     *     - size {number}: size of the downloaded chunks, in bytes.
     *
     * @param {ChooserOption} [options={}]
     */
    function ABRManager(requests$, metrics$, options) {
        if (options === void 0) { options = defaultChooserOptions; }
        var _this = this;
        // Subject emitting and completing on dispose.
        // Used to clean up every created observables.
        this._dispose$ = new Subject_1.Subject();
        // Will contain every RepresentationChooser attached to the ABRManager,
        // by type ("audio"/"video" etc.)
        this._choosers = {};
        // -- OPTIONS --
        // Will contain options used when (lazily) instantiating a
        // RepresentationChooser
        this._chooserInstanceOptions = {
            initialBitrates: options.initialBitrates || {},
            manualBitrates: options.manualBitrates || {},
            maxAutoBitrates: options.maxAutoBitrates || {},
            throttle: options.throttle || {},
            limitWidth: options.limitWidth || {},
        };
        metrics$
            .takeUntil(this._dispose$)
            .subscribe(function (_a) {
            var type = _a.type, value = _a.value;
            _this._lazilyCreateChooser(type);
            var duration = value.duration, size = value.size;
            // TODO Should we do a single estimate instead of a per-type one?
            // Test it thoroughly
            _this._choosers[type].addEstimate(duration, size);
        });
        requests$
            // requests$ emits observables which are subscribed to
            .mergeMap(function (request$) { return request$; })
            .takeUntil(this._dispose$)
            .subscribe(function (request) {
            var type = request.type, value = request.value;
            _this._lazilyCreateChooser(type);
            switch (request.event) {
                case "requestBegin":
                    // use the id of the segment as in any case, we should only have at
                    // most one active download for the same segment.
                    // This might be not optimal if this changes however. The best I think
                    // for now is to just throw/warn in DEV mode when two pending ids
                    // are identical
                    _this._choosers[type].addPendingRequest(value.id, request);
                    break;
                case "requestEnd":
                    _this._choosers[type].removePendingRequest(value.id);
                    break;
                case "progress":
                    _this._choosers[type].addRequestProgress(value.id, request);
                    break;
            }
        });
    }
    /**
     * Take type and an array of the available representations, spit out an
     * observable emitting the best representation (given the network/buffer
     * state).
     * @param {string} type
     * @param {Observable<Object>} clock$
     * @param {Array.<Representation>} [representations=[]]
     * @returns {Observable}
     */
    ABRManager.prototype.get$ = function (type, clock$, representations) {
        if (representations === void 0) { representations = []; }
        this._lazilyCreateChooser(type);
        return this._choosers[type].get$(clock$, representations);
    };
    /**
     * Set manually the bitrate for a given type.
     *
     * The given number will act as a ceil.
     * If no representation is found with the given bitrate, we will consider:
     *   1. The representation just lower than it
     *   2. If no representation is found in the previous step, the representation
     *   with the lowest bitrate.
     *
     * @param {string} type
     * @param {number} bitrate
     */
    ABRManager.prototype.setManualBitrate = function (type, bitrate) {
        var chooser = this._choosers[type];
        if (!chooser) {
            // if no chooser yet, store as a chooser option for when it will be
            // effectively instantiated
            this._chooserInstanceOptions.initialBitrates[type] = bitrate;
        }
        else {
            chooser.manualBitrate$.next(bitrate);
        }
    };
    /**
     * Set a maximum bitrate a given type will be able to automatically switch to.
     * The chooser for the given type can still emit higher bitrates with the
     * setManualBitrate method.
     * @param {string} supportedBufferTypes
     * @param {number} bitrate
     */
    ABRManager.prototype.setMaxAutoBitrate = function (type, bitrate) {
        var chooser = this._choosers[type];
        if (!chooser) {
            // if no chooser yet, store as a chooser option for when it will be
            // effectively instantiated
            this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
        }
        else {
            chooser.maxAutoBitrate$.next(bitrate);
        }
    };
    /**
     * Returns the set (and active) manual bitrate for the given type.
     * @param {string} supportedBufferTypes
     * @returns {number|undefined}
     */
    ABRManager.prototype.getManualBitrate = function (type) {
        var chooser = this._choosers[type];
        return chooser ?
            chooser.manualBitrate$.getValue() :
            this._chooserInstanceOptions.manualBitrates[type];
    };
    /**
     * Returns the set (and active) maximum auto bitrate for the given type.
     * @param {string} supportedBufferTypes
     * @returns {number|undefined}
     */
    ABRManager.prototype.getMaxAutoBitrate = function (type) {
        var chooser = this._choosers[type];
        return chooser ?
            chooser.maxAutoBitrate$.getValue() :
            this._chooserInstanceOptions.maxAutoBitrates[type];
    };
    /**
     * Clean every ressources linked to the ABRManager.
     * The ABRManager is unusable after calling this method.
     */
    ABRManager.prototype.dispose = function () {
        var _this = this;
        Object.keys(this._choosers).forEach(function (type) {
            _this._choosers[type].dispose();
        });
        this._chooserInstanceOptions = defaultChooserOptions;
        this._choosers = {};
        this._dispose$.next();
        this._dispose$.complete();
    };
    /**
     * If it doesn't exist, create a RepresentationChooser under the
     * _choosers[bufferType] property.
     * @param {string} bufferType
     */
    ABRManager.prototype._lazilyCreateChooser = function (bufferType) {
        if (!this._choosers[bufferType]) {
            this._choosers[bufferType] =
                createChooser(bufferType, this._chooserInstanceOptions);
        }
    };
    return ABRManager;
}());
exports.default = ABRManager;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */
var WeakMapMemory = /** @class */ (function () {
    function WeakMapMemory(fn) {
        this._weakMap = new WeakMap();
        this._fn = fn;
    }
    WeakMapMemory.prototype.get = function (obj) {
        var fromMemory = this._weakMap.get(obj);
        if (!fromMemory) {
            var newElement = this._fn(obj);
            this._weakMap.set(obj, newElement);
            return newElement;
        }
        else {
            return fromMemory;
        }
    };
    WeakMapMemory.prototype.destroy = function (obj) {
        this._weakMap.delete(obj);
    };
    return WeakMapMemory;
}());
exports.default = WeakMapMemory;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var castToObservable_1 = __webpack_require__(14);
var noop_1 = __webpack_require__(40);
/**
 * Throttle an asynchronous function (returning an Observable or Promise) to
 * drop calls done before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 *
 * TODO Add typings from castToObservable?
 */
function throttle(func) {
    var isPending = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (isPending) {
            return Observable_1.Observable.empty();
        }
        isPending = true;
        return castToObservable_1.default(func.apply(void 0, args))
            .do(noop_1.default, function () { return isPending = false; }, function () { return isPending = false; });
    };
}
exports.default = throttle;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(7);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var rx_throttle_1 = __webpack_require__(186);
var weak_map_memory_1 = __webpack_require__(185);
var events_1 = __webpack_require__(15);
var errors_1 = __webpack_require__(6);
var abr_1 = __webpack_require__(184);
var buffer_1 = __webpack_require__(82);
var eme_1 = __webpack_require__(50);
var pipelines_1 = __webpack_require__(169);
var source_buffers_1 = __webpack_require__(35);
var buffers_handler_1 = __webpack_require__(132);
var clock_1 = __webpack_require__(129);
var create_media_source_1 = __webpack_require__(128);
var end_of_stream_1 = __webpack_require__(127);
var garbage_collector_1 = __webpack_require__(126);
var get_initial_time_1 = __webpack_require__(125);
var live_events_handler_1 = __webpack_require__(124);
var media_error_handler_1 = __webpack_require__(71);
var segment_bookkeeper_1 = __webpack_require__(123);
exports.SegmentBookkeeper = segment_bookkeeper_1.default;
var speed_manager_1 = __webpack_require__(70);
var stalling_manager_1 = __webpack_require__(69);
var stream_events_1 = __webpack_require__(34);
var video_events_1 = __webpack_require__(68);
function getManifestPipelineOptions(networkConfig) {
    return {
        maxRetry: networkConfig.manifestRetry != null ?
            networkConfig.manifestRetry : config_1.default.DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
        maxRetryOffline: networkConfig.offlineRetry != null ?
            networkConfig.offlineRetry : config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR,
    };
}
/**
 * Central part of the player. Play a given stream described by the given
 * manifest with given options.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - get Buffers for each active adaptations.
 *  - give choice of the adaptation to the caller (e.g. to choose a language)
 *  - returns Observable emitting notifications about the stream lifecycle.
 *
 * @param {Object} args
 * @returns {Observable}
 */
function Stream(_a) {
    var adaptiveOptions = _a.adaptiveOptions, autoPlay = _a.autoPlay, bufferOptions = _a.bufferOptions, clock$ = _a.clock$, keySystems = _a.keySystems, networkConfig = _a.networkConfig, speed$ = _a.speed$, startAt = _a.startAt, supplementaryImageTracks = _a.supplementaryImageTracks, // eventual manually added images
    supplementaryTextTracks = _a.supplementaryTextTracks, // eventual manually added subtitles
    textTrackOptions = _a.textTrackOptions, transport = _a.transport, url = _a.url, videoElement = _a.videoElement;
    var wantedBufferAhead$ = bufferOptions.wantedBufferAhead$, maxBufferAhead$ = bufferOptions.maxBufferAhead$, maxBufferBehind$ = bufferOptions.maxBufferBehind$;
    /**
     * Observable through which all warning events will be sent.
     * @type {Subject}
     */
    var warning$ = new Subject_1.Subject();
    /**
     * Fetch and parse the manifest from the URL given.
     * Throttled to avoid doing multiple simultaneous requests.
     * @param {string} url - the manifest url
     * @returns {Observable} - the parsed manifest
     */
    var fetchManifest = rx_throttle_1.default(pipelines_1.createManifestPipeline(transport, getManifestPipelineOptions(networkConfig), warning$, supplementaryTextTracks, supplementaryImageTracks));
    /**
     * Keep track of a unique BufferGarbageCollector created per
     * QueuedSourceBuffer.
     * @type {WeakMapMemory}
     */
    var garbageCollectors = new weak_map_memory_1.default(function (qSourceBuffer) {
        return garbage_collector_1.default({
            queuedSourceBuffer: qSourceBuffer,
            clock$: clock$.map(function (tick) { return tick.currentTime; }),
            maxBufferBehind$: maxBufferBehind$,
            maxBufferAhead$: maxBufferAhead$,
        });
    });
    /**
     * Keep track of a unique segmentBookkeeper created per
     * QueuedSourceBuffer.
     * @type {WeakMapMemory}
     */
    var segmentBookkeepers = new weak_map_memory_1.default(function () {
        return new segment_bookkeeper_1.default();
    });
    /**
     * Start the whole Stream.
     * @type {Observable}
     */
    var stream$ = create_media_source_1.default(videoElement)
        .mergeMap(function (mediaSource) {
        return Observable_1.Observable.combineLatest(fetchManifest(url), events_1.onSourceOpen$(mediaSource).take(1)).mergeMap(function (_a) {
            var manifest = _a[0];
            return initializeStream(mediaSource, manifest);
        });
    });
    var warningEvents$ = warning$.map(stream_events_1.default.warning);
    return Observable_1.Observable.merge(stream$, warningEvents$);
    /**
     * Initialize stream playback by merging all observable that are required to
     * make the system cooperate.
     * @param {MediaSource} mediaSource
     * @param {Object} manifest
     * @returns {Observable}
     */
    function initializeStream(mediaSource, manifest) {
        create_media_source_1.setDurationToMediaSource(mediaSource, manifest.getDuration());
        log_1.default.debug("calculating initial time");
        var initialTime = get_initial_time_1.default(manifest, startAt);
        log_1.default.debug("initial time calculated:", initialTime);
        var firstPeriodToPlay = manifest.getPeriodForTime(initialTime);
        if (firstPeriodToPlay == null) {
            throw new errors_1.MediaError("MEDIA_STARTING_TIME_NOT_FOUND", null, true);
        }
        var _a = video_events_1.default(videoElement, initialTime, autoPlay), initialSeek$ = _a.initialSeek$, loadAndPlay$ = _a.loadAndPlay$;
        var bufferClock$ = clock_1.default(manifest, clock$, initialSeek$, initialTime);
        /**
         * Subject through which network metrics will be sent by the segment
         * pipelines to the ABR manager.
         * @type {Subject}
         */
        var network$ = new Subject_1.Subject();
        /**
         * Subject through which each request progression will be sent by the
         * segment pipelines to the ABR manager.
         * @type {Subject}
         */
        var requestsInfos$ = new Subject_1.Subject();
        /**
         * Creates pipelines for downloading segments.
         * @type {SegmentPipelinesManager}
         */
        var segmentPipelinesManager = new pipelines_1.SegmentPipelinesManager(transport, requestsInfos$, network$, warning$);
        /**
         * Create ABR Manager, which will choose the right "Representation" for a
         * given "Adaptation".
         * @type {ABRManager}
         */
        var abrManager = new abr_1.default(requestsInfos$, network$, adaptiveOptions);
        /**
         * Clock needed by the BufferManager
         * @type {Observable}
         */
        var abrClock$ = Observable_1.Observable.combineLatest(clock$, speed$)
            .map(function (_a) {
            var tick = _a[0], speed = _a[1];
            return {
                bufferGap: tick.bufferGap,
                duration: tick.duration,
                isLive: manifest.isLive,
                position: tick.currentTime,
                speed: speed,
            };
        });
        /**
         * Creates BufferManager allowing to easily create a Buffer linked to any
         * Adaptation from the current content.
         * @type {BufferManager}
         */
        var bufferManager = new buffer_1.default(abrManager, abrClock$);
        /**
         * Creates SourceBufferManager allowing to create and keep track of a single
         * SourceBuffer per type.
         * @type {SourceBufferManager}
         */
        var sourceBufferManager = new source_buffers_1.default(videoElement, mediaSource);
        // Will be used to cancel any endOfStream tries when the contents resume
        var cancelEndOfStream$ = new Subject_1.Subject();
        // Will be used to process the events of the buffer
        var bufferEventHandler = manifest.isLive ?
            live_events_handler_1.default(videoElement, manifest, fetchManifest) :
            Observable_1.Observable.of;
        /**
         * Creates Observable which will manage every Buffer for the given Content.
         * @type {Observable}
         */
        var buffers$ = buffers_handler_1.default({ manifest: manifest, period: firstPeriodToPlay }, // content
        bufferClock$, wantedBufferAhead$, bufferManager, sourceBufferManager, segmentPipelinesManager, segmentBookkeepers, garbageCollectors, {
            maxRetry: networkConfig.segmentRetry,
            maxRetryOffline: networkConfig.offlineRetry,
            textTrackOptions: textTrackOptions,
        }, warning$).mergeMap(function (evt) {
            switch (evt.type) {
                case "end-of-stream":
                    return end_of_stream_1.maintainEndOfStream(mediaSource)
                        .ignoreElements()
                        .takeUntil(cancelEndOfStream$);
                case "resume-stream":
                    cancelEndOfStream$.next(null);
                    return Observable_1.Observable.empty();
                default:
                    return bufferEventHandler(evt);
            }
        });
        /**
         * Create EME Manager, an observable which will manage every EME-related
         * issue.
         * @type {Observable}
         */
        var emeManager$ = eme_1.default(videoElement, keySystems, warning$);
        /**
         * Translate errors coming from the video element into RxPlayer errors
         * through a throwing Observable.
         * @type {Observable}
         */
        var mediaErrorHandler$ = media_error_handler_1.default(videoElement);
        /**
         * Create Speed Manager, an observable which will set the speed set by the
         * user on the video element while pausing a little longer while the buffer
         * is stalled.
         * @type {Observable}
         */
        var speedManager$ = speed_manager_1.default(videoElement, speed$, clock$, {
            pauseWhenStalled: true,
        }).map(stream_events_1.default.speedChanged);
        /**
         * Create Stalling Manager, an observable which will try to get out of
         * various infinite stalling issues
         * @type {Observable}
         */
        var stallingManager$ = stalling_manager_1.default(videoElement, clock$)
            .map(stream_events_1.default.stalled);
        // Single lifecycle events
        var manifestReadyEvent$ = Observable_1.Observable
            .of(stream_events_1.default.manifestReady(abrManager, manifest));
        var loadedEvent$ = loadAndPlay$.mapTo(stream_events_1.default.loaded());
        return Observable_1.Observable.merge(manifestReadyEvent$, loadedEvent$, buffers$, emeManager$, // TODO RxJS Bug?
        mediaErrorHandler$, // TODO RxJS Bug?
        speedManager$, stallingManager$).finally(function () {
            // clean-up every created SourceBuffers
            sourceBufferManager.disposeAll();
        });
    }
}
exports.default = Stream;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var hash_buffer_1 = __webpack_require__(38);
var simple_set_1 = __webpack_require__(54);
/**
 * Memorize initialization data with straightforward methods.
 * @class InitDataStore
 */
var InitDataStore = /** @class */ (function () {
    function InitDataStore() {
        this._namedTypeData = {};
        this._unnamedTypeData = new simple_set_1.default();
    }
    /**
     * Returns true if this instance has the given initData stored.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {boolean}
     */
    InitDataStore.prototype.has = function (initData, initDataType) {
        if (!initDataType) {
            return this._unnamedTypeData.test(hash_buffer_1.default(initData));
        }
        if (!this._namedTypeData[initDataType]) {
            return false;
        }
        return this._namedTypeData[initDataType].test(hash_buffer_1.default(initData));
    };
    /**
     * Add initialization data to this memory.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     */
    InitDataStore.prototype.add = function (initData, initDataType) {
        if (this.has(initData, initDataType)) {
            return;
        }
        if (!initDataType) {
            this._unnamedTypeData.add(hash_buffer_1.default(initData));
            return;
        }
        if (!this._namedTypeData[initDataType]) {
            this._namedTypeData[initDataType] = new simple_set_1.default();
        }
        this._namedTypeData[initDataType].add(hash_buffer_1.default(initData));
    };
    /**
     * Remove the initialization data from this memory.
     * Returns true if this instance had the given initData stored.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {boolean}
     */
    InitDataStore.prototype.remove = function (initData, initDataType) {
        if (!initDataType) {
            var hashed = hash_buffer_1.default(initData);
            if (this._unnamedTypeData.test(hashed)) {
                this._unnamedTypeData.remove(hashed);
                return true;
            }
            return false;
        }
        else {
            if (!this._namedTypeData[initDataType]) {
                return false;
            }
            var hashed = hash_buffer_1.default(initData);
            var simpleSet = this._namedTypeData[initDataType];
            if (simpleSet.test(hashed)) {
                simpleSet.remove(hashed);
                return true;
            }
            return false;
        }
    };
    return InitDataStore;
}());
exports.default = InitDataStore;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Store the MediaKeys infos attached to a media element.
 * @class MediaKeysInfosStore
 */
var MediaKeysInfosStore = /** @class */ (function () {
    function MediaKeysInfosStore() {
        this._state = new WeakMap();
    }
    MediaKeysInfosStore.prototype.setState = function (mediaElement, state) {
        this._state.set(mediaElement, state);
    };
    MediaKeysInfosStore.prototype.getState = function (mediaElement) {
        return this._state.get(mediaElement) || null;
    };
    MediaKeysInfosStore.prototype.clearState = function (mediaElement) {
        this._state.set(mediaElement, null);
    };
    return MediaKeysInfosStore;
}());
exports.default = MediaKeysInfosStore;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Keys are the different key statuses possible.
// Values are ``true`` if such key status defines an error
/* tslint:disable no-object-literal-type-assertion */
exports.KEY_STATUS_ERRORS = {
    expired: true,
    "internal-error": true,
};
/* tslint:enable no-object-literal-type-assertion */


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var backoff_1 = __webpack_require__(85);
/**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay - delay in ms
 * @returns {Function}
 */
function debounce(fn, delay) {
    var timer = 0;
    return function () {
        if (timer) {
            clearTimeout(timer);
        }
        timer = window.setTimeout(fn, delay);
    };
}
/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options
 * @param {Number} options.retryDelay - The initial delay, in ms.
 * This delay will be fuzzed to fall under the range +-30% each time a new retry
 * is done.
 * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry
 * we performed (beginning at 1 for the first retry).
 * @param {Number} options.totalRetry - The amount of time we should retry. 0
 * means no retry, 1 means a single retry, Infinity means infinite retry etc.
 * If the observable still fails after this number of retry, the error will
 * be throwed through this observable.
 * @param {Number} [options.resetDelay] - Delay in ms since a retry after which
 * the counter of retry will be reset if the observable wasn't retried a new
 * time. 0 / undefined means no delay will be applied.
 * @param {Function} [options.shouldRetry] - Function which will receive the
 * observable error each time it fails, and should return a boolean. If this
 * boolean is false, the error will be directly thrown (without anymore retry).
 * @param {Function} [options.onRetry] - Function which will be triggered at
 * each retry. Will receive two arguments:
 *   1. The observable error
 *   2. The current retry count, beginning at 1 for the first retry
 * @param {Function} [options.errorSelector] - If and when the observable will
 * definitely throw (without retrying), this function will be called with two
 * arguments:
 *   1. The observable error
 *   2. The final retry count, beginning at 1 for the first retry
 * The returned value will be what will be thrown by the observable.
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryObsWithBackoff(obs$, options) {
    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;
    var retryCount = 0;
    var debounceRetryCount;
    if (resetDelay != null && resetDelay > 0) {
        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);
    }
    return obs$.catch(function (error, source) {
        var wantRetry = !shouldRetry || shouldRetry(error);
        if (!wantRetry || retryCount++ >= totalRetry) {
            if (errorSelector) {
                throw errorSelector(error, retryCount);
            }
            else {
                throw error;
            }
        }
        if (onRetry) {
            onRetry(error, retryCount);
        }
        var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);
        return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {
            if (debounceRetryCount) {
                debounceRetryCount();
            }
            return source;
        });
    });
}
exports.retryObsWithBackoff = retryObsWithBackoff;
/**
 * Retry the given function (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Number} options.retryDelay - The initial delay, in ms.
 * This delay will be fuzzed to fall under the range +-30% each time a new retry
 * is done.
 * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry
 * we performed (beginning at 1 for the first retry).
 * @param {Number} options.totalRetry - The amount of time we should retry. 0
 * means no retry, 1 means a single retry, Infinity means infinite retry etc.
 * If the observable still fails after this number of retry, the error will
 * be throwed through this observable.
 * @param {Number} [options.resetDelay] - Delay in ms since a retry after which
 * the counter of retry will be reset if the observable wasn't retried a new
 * time. 0 / undefined means no delay will be applied.
 * @param {Function} [options.shouldRetry] - Function which will receive the
 * observable error each time it fails, and should return a boolean. If this
 * boolean is false, the error will be directly thrown (without anymore retry).
 * @param {Function} [options.onRetry] - Function which will be triggered at
 * each retry. Will receive two arguments:
 *   1. The observable error
 *   2. The current retry count, beginning at 1 for the first retry
 * @param {Function} [options.errorSelector] - If and when the observable will
 * definitely throw (without retrying), this function will be called with two
 * arguments:
 *   1. The observable error
 *   2. The final retry count, beginning at 1 for the first retry
 * The returned value will be what will be thrown by the observable.
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryFuncWithBackoff(func, options) {
    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;
    var retryCount = 0;
    var debounceRetryCount;
    if (resetDelay != null && resetDelay > 0) {
        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);
    }
    function doRetry() {
        var func$ = Observable_1.Observable.create(function (obs) {
            obs.next(func());
            obs.complete();
        });
        return func$.catch(function (error) {
            var wantRetry = !shouldRetry || shouldRetry(error);
            if (!wantRetry || retryCount++ >= totalRetry) {
                if (errorSelector) {
                    throw errorSelector(error, retryCount);
                }
                else {
                    throw error;
                }
            }
            if (onRetry) {
                onRetry(error, retryCount);
            }
            var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);
            return Observable_1.Observable
                .timer(fuzzedDelay)
                .mergeMap(function () {
                if (debounceRetryCount) {
                    debounceRetryCount();
                }
                return doRetry();
            });
        });
    }
    return doRetry();
}
exports.retryFuncWithBackoff = retryFuncWithBackoff;
/**
 * Same than retryObsWithBackoff, only with a function returning an observable
 * instead of an observable.
 * @param {Function} fn - Function returning an Observable which
 * will (well, might) be retried.
 * @param {Object} options
 * @param {Number} options.retryDelay
 * @param {Number} options.totalRetry
 * @param {Number} [options.resetDelay]
 * @param {Function} [options.shouldRetry]
 * @param {Function} [options.errorSelector]
 * @param {Function} [options.onRetry]
 * @returns {Function} - take in argument fn's arguments, returns
 * an Observable.
 */
function retryableFuncWithBackoff(fn, options) {
    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;
    var retryCount = 0;
    var debounceRetryCount;
    if (resetDelay != null && resetDelay > 0) {
        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);
    }
    return function doRetry() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn.apply(void 0, args).catch(function (error) {
            var wantRetry = !shouldRetry || shouldRetry(error);
            if (!wantRetry || retryCount++ >= totalRetry) {
                if (errorSelector) {
                    throw errorSelector(error, retryCount);
                }
                else {
                    throw error;
                }
            }
            if (onRetry) {
                onRetry(error, retryCount);
            }
            var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);
            return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {
                if (debounceRetryCount) {
                    debounceRetryCount();
                }
                return doRetry.apply(void 0, args);
            });
        });
    };
}
exports.retryableFuncWithBackoff = retryableFuncWithBackoff;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var TimeoutError_1 = __webpack_require__(97);
var events_1 = __webpack_require__(15);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
var log_1 = __webpack_require__(1);
var retry_1 = __webpack_require__(191);
var rx_tryCatch_1 = __webpack_require__(49);
var types_1 = __webpack_require__(190);
/**
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function handleSessionEvents(session, keySystem, errorStream) {
    log_1.default.debug("eme: handle message events", session);
    /**
     * @param {Error|Object} error
     * @param {Boolean} fatal
     * @returns {Error|Object}
     */
    function licenseErrorSelector(error, fatal) {
        if (errors_1.isKnownError(error)) {
            if (error.type === errors_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR) {
                error.fatal = fatal;
                return error;
            }
        }
        return new errors_1.EncryptedMediaError("KEY_LOAD_ERROR", error, fatal);
    }
    var getLicenseRetryOptions = {
        totalRetry: 2,
        retryDelay: 200,
        errorSelector: function (error) { return licenseErrorSelector(error, true); },
        onRetry: function (error) { return errorStream.next(licenseErrorSelector(error, false)); },
    };
    var keyErrors = events_1.onKeyError$(session)
        .map(function (error) {
        throw new errors_1.EncryptedMediaError("KEY_ERROR", error, true);
    });
    var keyStatusesChanges = events_1.onKeyStatusesChange$(session).mergeMap(function (keyStatusesEvent) {
        log_1.default.debug("eme: keystatuseschange event", session, keyStatusesEvent);
        // find out possible errors associated with this event
        session.keyStatuses.forEach(function (keyStatus, keyId) {
            // Hack present because the order of the arguments has changed in spec
            // and is not the same between some versions of Edge and Chrome.
            if (types_1.KEY_STATUS_ERRORS[keyId]) {
                throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", keyId, true);
            }
            else if (types_1.KEY_STATUS_ERRORS[keyStatus]) {
                throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", keyStatus, true);
            }
        });
        var handledKeyStatusesChange$ = rx_tryCatch_1.default(function () {
            return keySystem && keySystem.onKeyStatusesChange ?
                castToObservable_1.default(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : Observable_1.Observable.empty();
        });
        return handledKeyStatusesChange$
            .catch(function (error) {
            throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", error, true);
        })
            .map(function (licenseObject) {
            return {
                type: "key-status-change",
                value: {
                    license: licenseObject,
                },
            };
        });
    });
    var keyMessages$ = events_1.onKeyMessage$(session).mergeMap(function (messageEvent) {
        var message = new Uint8Array(messageEvent.message);
        var messageType = messageEvent.messageType || "license-request";
        log_1.default.debug("eme: event message type " + messageType, session, messageEvent);
        var getLicense$ = Observable_1.Observable.defer(function () {
            var getLicense = keySystem.getLicense(message, messageType);
            return castToObservable_1.default(getLicense)
                .timeout(10 * 1000)
                .catch(function (error) {
                throw error instanceof TimeoutError_1.TimeoutError ?
                    new errors_1.EncryptedMediaError("KEY_LOAD_TIMEOUT", null, false) :
                    error;
            });
        });
        return retry_1.retryObsWithBackoff(getLicense$, getLicenseRetryOptions)
            .map(function (license) {
            return {
                type: messageType,
                value: {
                    license: license,
                },
            };
        });
    });
    var sessionUpdates = Observable_1.Observable.merge(keyMessages$, keyStatusesChanges)
        .concatMap(function (evt) {
        log_1.default.debug("eme: update session", evt);
        var license = evt.value.license;
        return castToObservable_1.default(session.update(license))
            .catch(function (error) {
            throw new errors_1.EncryptedMediaError("KEY_UPDATE_ERROR", error, true);
        })
            .mapTo({
            type: evt.type,
            value: {
                session: session,
                license: license,
            },
        });
    });
    var sessionEvents = Observable_1.Observable.merge(sessionUpdates, keyErrors);
    if (session.closed) {
        return sessionEvents
            .takeUntil(castToObservable_1.default(session.closed));
    }
    else {
        return sessionEvents;
    }
}
exports.default = handleSessionEvents;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var array_includes_1 = __webpack_require__(13);
var assert_1 = __webpack_require__(4);
var castToObservable_1 = __webpack_require__(14);
var log_1 = __webpack_require__(1);
var is_session_usable_1 = __webpack_require__(86);
/**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */
function loadPersistentSession(sessionId, session) {
    return Observable_1.Observable.defer(function () {
        log_1.default.debug("eme: load persisted session", sessionId);
        return castToObservable_1.default(session.load(sessionId));
    });
}
/**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function createSession(initData, initDataType, mediaKeysInfos) {
    return Observable_1.Observable.defer(function () {
        var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, sessionsStore = mediaKeysInfos.sessionsStore, sessionStorage = mediaKeysInfos.sessionStorage;
        var mksConfig = mediaKeySystemAccess.getConfiguration();
        var sessionTypes = mksConfig.sessionTypes;
        var hasPersistence = (sessionTypes && array_includes_1.default(sessionTypes, "persistent-license"));
        var sessionType = hasPersistence &&
            sessionStorage &&
            keySystemOptions.persistentLicense ?
            "persistent-license" : "temporary";
        log_1.default.debug("eme: create a new " + sessionType + " session");
        var session = sessionsStore.createSession(initData, initDataType, sessionType);
        // Re-check for Dumb typescript
        if (!hasPersistence || !sessionStorage || !keySystemOptions.persistentLicense) {
            if (false) {}
            return Observable_1.Observable.of({
                type: "created-session",
                value: { mediaKeySession: session, sessionType: sessionType },
            });
        }
        if (false) {}
        var storedEntry = sessionStorage.get(initData, initDataType);
        if (!storedEntry) {
            return Observable_1.Observable.of({
                type: "created-session",
                value: { mediaKeySession: session, sessionType: sessionType },
            });
        }
        /**
         * Helper function to close and restart the current persistent session
         * considered, and re-create it from scratch.
         * @returns {Observable}
         */
        var recreatePersistentSession = function () {
            log_1.default.info("eme: removing previous persistent session.");
            if (sessionStorage.get(initData, initDataType) !== null) {
                sessionStorage.delete(initData, initDataType);
            }
            return sessionsStore.closeSession(session)
                .map(function () {
                var newSession = sessionsStore.createSession(initData, initDataType, sessionType);
                return {
                    type: "created-session",
                    value: { mediaKeySession: newSession, sessionType: sessionType },
                };
            });
        };
        return loadPersistentSession(storedEntry.sessionId, session)
            .mergeMap(function (hasLoadedSession) {
            if (!hasLoadedSession) {
                log_1.default.warn("eme: no data stored for the loaded session");
                sessionStorage.delete(initData, initDataType);
                return Observable_1.Observable.of({
                    type: "created-session",
                    value: { mediaKeySession: session, sessionType: sessionType },
                });
            }
            if (hasLoadedSession && is_session_usable_1.default(session)) {
                sessionStorage.add(initData, initDataType, session);
                log_1.default.info("eme: succeeded to load persistent session.");
                return Observable_1.Observable.of({
                    type: "loaded-persistent-session",
                    value: { mediaKeySession: session, sessionType: sessionType },
                });
            }
            // Unusable persistent session: recreate a new session from scratch.
            log_1.default.warn("eme: previous persistent session not usable anymore.");
            return recreatePersistentSession();
        })
            .catch(function () {
            log_1.default.warn("eme: unable to load persistent session.");
            return recreatePersistentSession();
        });
    });
}
exports.default = createSession;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var config_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var create_session_1 = __webpack_require__(193);
var is_session_usable_1 = __webpack_require__(86);
var MAX_SESSIONS = config_1.default.EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, skip the event if it is already handled or
 * recuperate a previous session and returns it.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function handleEncryptedEvent(encryptedEvent, handledInitData, mediaKeysInfos) {
    return Observable_1.Observable.defer(function () {
        var _a = compat_1.getInitData(encryptedEvent), initData = _a.initData, initDataType = _a.initDataType;
        if (handledInitData.has(initData, initDataType)) {
            log_1.default.debug("init data already received. Skipping it.");
            return Observable_1.Observable.empty(); // Already handled, quit
        }
        handledInitData.add(initData, initDataType);
        // possible previous loaded session with the same initialization data
        var previousLoadedSession = null;
        var sessionsStore = mediaKeysInfos.sessionsStore;
        var entry = sessionsStore.get(initData, initDataType);
        if (entry != null) {
            previousLoadedSession = entry.session;
            if (is_session_usable_1.default(previousLoadedSession)) {
                log_1.default.debug("eme: reuse loaded session", previousLoadedSession.sessionId);
                return Observable_1.Observable.of({
                    type: "loaded-open-session",
                    value: {
                        mediaKeySession: previousLoadedSession,
                        sessionType: entry.sessionType,
                        initData: initData,
                        initDataType: initDataType,
                    },
                });
            }
            else if (mediaKeysInfos.sessionStorage) {
                mediaKeysInfos.sessionStorage.delete(new Uint8Array(initData), initDataType);
            }
        }
        return (previousLoadedSession ?
            sessionsStore.closeSession(previousLoadedSession) :
            Observable_1.Observable.of(null)).mergeMap(function () {
            var cleaningOldSessions$ = [];
            var entries = sessionsStore.getAll().slice();
            if (MAX_SESSIONS > 0 && MAX_SESSIONS <= entries.length) {
                for (var i = 0; i < (MAX_SESSIONS - entries.length + 1); i++) {
                    cleaningOldSessions$.push(sessionsStore.closeSession(entries[i].session));
                }
            }
            return Observable_1.Observable.merge.apply(Observable_1.Observable, cleaningOldSessions$).ignoreElements()
                .concat(create_session_1.default(initData, initDataType, mediaKeysInfos)
                .map(function (evt) { return ({
                type: evt.type,
                value: {
                    mediaKeySession: evt.value.mediaKeySession,
                    sessionType: evt.value.sessionType,
                    initData: initData,
                    initDataType: initDataType,
                },
            }); }));
        });
    });
}
exports.default = handleEncryptedEvent;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var assert_1 = __webpack_require__(4);
var hash_buffer_1 = __webpack_require__(38);
var log_1 = __webpack_require__(1);
function checkStorage(storage) {
    assert_1.default(storage != null, "no licenseStorage given for keySystem with persistentLicense");
    assert_1.assertInterface(storage, { save: "function", load: "function" }, "licenseStorage");
}
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */
var PersistedSessionsStore = /** @class */ (function () {
    /**
     * @param {Object} storage
     */
    function PersistedSessionsStore(storage) {
        checkStorage(storage);
        this._entries = [];
        this._storage = storage;
        try {
            this._entries = this._storage.load();
            assert_1.default(Array.isArray(this._entries));
        }
        catch (e) {
            log_1.default.warn("eme-persitent-store: could not get entries from license storage", e);
            this.dispose();
        }
    }
    /**
     * Retrieve entry (sessionId + initData) based on its initData.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */
    PersistedSessionsStore.prototype.get = function (initData, initDataType) {
        var hash = hash_buffer_1.default(initData);
        var entry = arrayFind(this._entries, function (e) {
            return e.initData === hash &&
                e.initDataType === initDataType;
        });
        return entry || null;
    };
    /**
     * Add a new entry in the storage.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @param {MediaKeySession} session
     */
    PersistedSessionsStore.prototype.add = function (initData, initDataType, session) {
        var sessionId = session && session.sessionId;
        if (!sessionId) {
            return;
        }
        var currentEntry = this.get(initData, initDataType);
        if (currentEntry && currentEntry.sessionId === sessionId) {
            return;
        }
        else if (currentEntry) { // currentEntry has a different sessionId
            this.delete(initData, initDataType);
        }
        log_1.default.info("eme-persitent-store: add new session", sessionId, session);
        this._entries.push({
            sessionId: sessionId,
            initData: hash_buffer_1.default(initData),
            initDataType: initDataType,
        });
        this._save();
    };
    /**
     * Delete entry (sessionId + initData) based on its initData.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     */
    PersistedSessionsStore.prototype.delete = function (initData, initDataType) {
        var hash = hash_buffer_1.default(initData);
        var entry = arrayFind(this._entries, function (e) {
            return e.initData === hash &&
                e.initDataType === initDataType;
        });
        if (entry) {
            log_1.default.warn("eme-persitent-store: delete session from store", entry);
            var idx = this._entries.indexOf(entry);
            this._entries.splice(idx, 1);
            this._save();
        }
    };
    /**
     * Delete all saved entries.
     */
    PersistedSessionsStore.prototype.dispose = function () {
        this._entries = [];
        this._save();
    };
    /**
     * Use the given storage to store the current entries.
     */
    PersistedSessionsStore.prototype._save = function () {
        try {
            this._storage.save(this._entries);
        }
        catch (e) {
            log_1.default.warn("eme-persitent-store: could not save licenses in localStorage");
        }
    };
    return PersistedSessionsStore;
}());
exports.default = PersistedSessionsStore;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(9);
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
var hash_buffer_1 = __webpack_require__(38);
var log_1 = __webpack_require__(1);
/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */
var MediaKeySessionsStore = /** @class */ (function () {
    function MediaKeySessionsStore(mediaKeys) {
        this._mediaKeys = mediaKeys;
        this._entries = [];
    }
    /**
     * @returns {Array.<Object>}
     */
    MediaKeySessionsStore.prototype.getAll = function () {
        return this._entries.map(function (entry) { return ({
            session: entry.session,
            sessionType: entry.sessionType,
        }); });
    };
    /**
     * Returns an entry in this cache with the initData and initDataType given.
     * null if no such session is stored.
     *
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */
    MediaKeySessionsStore.prototype.get = function (initData, initDataType) {
        var initDataHash = hash_buffer_1.default(initData);
        var foundEntry = arrayFind(this._entries, function (entry) { return (entry.initData === initDataHash &&
            entry.initDataType === initDataType); });
        if (foundEntry) {
            var session = foundEntry.session, sessionType = foundEntry.sessionType;
            return { session: session, sessionType: sessionType };
        }
        return null;
    };
    /**
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @param {string} sessionType
     * @returns {MediaKeySession}
     * @throws {EncryptedMediaError}
     */
    MediaKeySessionsStore.prototype.createSession = function (initData, initDataType, sessionType) {
        var _this = this;
        if (this.get(initData, initDataType)) {
            var error = new Error("This initialization data was already stored.");
            throw new errors_1.EncryptedMediaError("MULTIPLE_SESSIONS_SAME_INIT_DATA", error, true);
        }
        var session = this._mediaKeys /* TS bug */.createSession(sessionType);
        var entry = {
            session: session,
            sessionType: sessionType,
            initData: hash_buffer_1.default(initData),
            initDataType: initDataType,
        };
        if (session.closed !== null) {
            session.closed
                .then(function () {
                _this._delete(session);
            })
                .catch(function (e) {
                log_1.default.warn("session.closed rejected: " + e);
            });
        }
        log_1.default.debug("eme-mem-store: add session", entry);
        this._entries.push(entry);
        return session;
    };
    /**
     * Close a MediaKeySession stored here and remove its entry in the store.
     * @param {MediaKeySession} session_
     * @returns {Observable}
     */
    MediaKeySessionsStore.prototype.closeSession = function (session_) {
        var _this = this;
        return Observable_1.Observable.defer(function () {
            var session = _this._delete(session_);
            if (session == null) {
                return Observable_1.Observable.of(null);
            }
            log_1.default.debug("eme-mem-store: close session", session);
            return castToObservable_1.default(session.close())
                .mapTo(null)
                .catch(function () {
                return Observable_1.Observable.of(null);
            });
        });
    };
    /**
     * Close all sessions in this store.
     * Emit null when done
     * @returns {Observable}
     */
    MediaKeySessionsStore.prototype.closeAllSessions = function () {
        var _this = this;
        return Observable_1.Observable.defer(function () {
            var disposed = _this._entries.map(function (e) { return _this.closeSession(e.session); });
            _this._entries = [];
            return Observable_1.Observable.merge.apply(Observable_1.Observable, disposed).ignoreElements()
                .concat(Observable_1.Observable.of(null));
        });
    };
    /**
     * Remove a MediaKeySession from the Cache, without closing it.
     * Returns the entry if found, null otherwise.
     * @param {MediaKeySession} session_
     * @returns {MediaKeySession|null}
     */
    MediaKeySessionsStore.prototype._delete = function (session_) {
        var entry = arrayFind(this._entries, function (e) { return e.session === session_; });
        if (!entry) {
            return null;
        }
        var session = entry.session;
        log_1.default.debug("eme-mem-store: delete session", entry);
        var idx = this._entries.indexOf(entry);
        this._entries.splice(idx, 1);
        return session;
    };
    return MediaKeySessionsStore;
}());
exports.default = MediaKeySessionsStore;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
/**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function setServerCertificate(mediaKeys, serverCertificate) {
    return Observable_1.Observable.defer(function () {
        return castToObservable_1.default(mediaKeys.setServerCertificate(serverCertificate)).catch(function (error) {
            throw new errors_1.EncryptedMediaError("LICENSE_SERVER_CERTIFICATE_ERROR", error, true);
        });
    }).mapTo(null);
}
exports.setServerCertificate = setServerCertificate;
/**
 * Call the setCertificate API. If it fails just emit the error through the
 * errorStream and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) {
    return typeof mediaKeys.setServerCertificate === "function" ?
        setServerCertificate(mediaKeys, serverCertificate)
            .catch(function (error) {
            error.fatal = false;
            errorStream.next(error);
            return Observable_1.Observable.of(null);
        }) : Observable_1.Observable.of(null);
}
exports.default = trySettingServerCertificate;
exports.trySettingServerCertificate = trySettingServerCertificate;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var config_1 = __webpack_require__(2);
var errors_1 = __webpack_require__(6);
var array_includes_1 = __webpack_require__(13);
var log_1 = __webpack_require__(1);
var EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config_1.default.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config_1.default.EME_KEY_SYSTEMS;
/**
 * @param {Array.<Object>} keySystems
 * @param {Object} currentMediaKeysInfos
 * @returns {null|Object}
 */
function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
    var mksConfiguration = currentKeySystemAccess.getConfiguration();
    // NOTE(pierre): alwaysRenew flag is used for IE11 which require the
    // creation of a new MydiaKeys instance for each session creation
    if (compat_1.shouldRenewMediaKeys() || !mksConfiguration) {
        return null;
    }
    var firstCompatibleOption = keySystems.filter(function (ks) {
        // XXX TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
        if (ks.type !== currentKeySystemOptions.type) {
            return false;
        }
        if (ks.persistentLicense &&
            mksConfiguration.persistentState !== "required") {
            return false;
        }
        if (ks.distinctiveIdentifierRequired &&
            mksConfiguration.distinctiveIdentifier !== "required") {
            return false;
        }
        return true;
    })[0];
    if (firstCompatibleOption) {
        return {
            keySystemOptions: firstCompatibleOption,
            keySystemAccess: currentKeySystemAccess,
        };
    }
    return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */
function findKeySystemCanonicalName(ksType) {
    for (var _i = 0, _a = Object.keys(EME_KEY_SYSTEMS); _i < _a.length; _i++) {
        var ksName = _a[_i];
        if (array_includes_1.default(EME_KEY_SYSTEMS[ksName], ksType)) {
            return ksName;
        }
    }
    return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */
function buildKeySystemConfigurations(ksName, keySystem) {
    var sessionTypes = ["temporary"];
    var persistentState = "optional";
    var distinctiveIdentifier = "optional";
    if (keySystem.persistentLicense) {
        persistentState = "required";
        sessionTypes.push("persistent-license");
    }
    if (keySystem.persistentStateRequired) {
        persistentState = "required";
    }
    if (keySystem.distinctiveIdentifierRequired) {
        distinctiveIdentifier = "required";
    }
    // Set robustness, in order of consideration:
    //   1. the user specified its own robustnesses
    //   2. a "widevine" key system is used, in that case set the default widevine
    //      robustnesses as defined in the config
    //   3. set an undefined robustness
    var videoRobustnesses = keySystem.videoRobustnesses ||
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
    var audioRobustnesses = keySystem.audioRobustnesses ||
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
    if (!videoRobustnesses.length) {
        videoRobustnesses.push(undefined);
    }
    if (!audioRobustnesses.length) {
        audioRobustnesses.push(undefined);
    }
    // From the W3 EME spec, we have to provide videoCapabilities and
    // audioCapabilities.
    // These capabilities must specify a codec (even though your stream can use
    // a completely different codec afterward).
    // It is also strongly recommended to specify the required security
    // robustness. As we do not want to forbide any security level, we specify
    // every existing security level from highest to lowest so that the best
    // security level is selected.
    // More details here:
    // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
    // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent
    var videoCapabilities = videoRobustnesses.map(function (robustness) { return ({
        contentType: "video/mp4;codecs=\"avc1.4d401e\"",
        robustness: robustness,
    }); });
    var audioCapabilities = audioRobustnesses.map(function (robustness) { return ({
        contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
        robustness: robustness,
    }); });
    // TODO Re-test with a set contentType but an undefined robustness on the
    // STBs on which this problem was found.
    //
    // add another with no {audio,video}Capabilities for some legacy browsers.
    // As of today's spec, this should return NotSupported but the first
    // candidate configuration should be good, so we should have no downside
    // doing that.
    // initDataTypes: ["cenc"],
    // videoCapabilities: undefined,
    // audioCapabilities: undefined,
    // distinctiveIdentifier,
    // persistentState,
    // sessionTypes,
    return [{
            initDataTypes: ["cenc"],
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            distinctiveIdentifier: distinctiveIdentifier,
            persistentState: persistentState,
            sessionTypes: sessionTypes,
        }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */
function getMediaKeySystemAccess(mediaElement, keySystemsConfigs, currentMediaKeysInfos) {
    return Observable_1.Observable.defer(function () {
        var currentState = currentMediaKeysInfos.getState(mediaElement);
        if (currentState) {
            // Fast way to find a compatible keySystem if the currently loaded
            // one as exactly the same compatibility options.
            var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
            if (cachedKeySystemAccess) {
                log_1.default.debug("eme: found cached compatible keySystem", cachedKeySystemAccess);
                return Observable_1.Observable.of({
                    type: "reuse-media-key-system-access",
                    value: {
                        mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                        options: cachedKeySystemAccess.keySystemOptions,
                    },
                });
            }
        }
        /**
         * Array of set keySystems for this content.
         * Each item of this array is an object containing the following keys:
         *   - keyName {string}: keySystem canonical name (e.g. "widevine")
         *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
         *   - keySystem {Object}: the original keySystem object
         * @type {Array.<Object>}
         */
        var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {
            var ksType;
            if (EME_KEY_SYSTEMS[keySystemOptions.type]) {
                ksType = EME_KEY_SYSTEMS[keySystemOptions.type].map(function (keyType) {
                    var keyName = keySystemOptions.type;
                    return { keyName: keyName, keyType: keyType, keySystemOptions: keySystemOptions };
                });
            }
            else {
                var keyName = findKeySystemCanonicalName(keySystemOptions.type) || "";
                var keyType = keySystemOptions.type;
                ksType = [{ keyName: keyName, keyType: keyType, keySystemOptions: keySystemOptions }];
            }
            return arr.concat(ksType);
        }, []);
        return Observable_1.Observable.create(function (obs) {
            var disposed = false;
            var sub;
            /**
             * Test the key system as defined in keySystemsType[index].
             * @param {Number} index
             */
            function testKeySystem(index) {
                // completely quit the loop if unsubscribed
                if (disposed) {
                    return;
                }
                // if we iterated over the whole keySystemsType Array, quit on error
                if (index >= keySystemsType.length) {
                    obs.error(new errors_1.EncryptedMediaError("INCOMPATIBLE_KEYSYSTEMS", null, true));
                    return;
                }
                var _a = keySystemsType[index], keyName = _a.keyName, keyType = _a.keyType, keySystemOptions = _a.keySystemOptions;
                var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
                log_1.default.debug("eme: request keysystem access " + keyType + "," +
                    (index + 1 + " of " + keySystemsType.length), keySystemConfigurations);
                if (compat_1.requestMediaKeySystemAccess == null) {
                    throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
                }
                sub = compat_1.requestMediaKeySystemAccess(keyType, keySystemConfigurations)
                    .subscribe(function (keySystemAccess) {
                    log_1.default.info("eme: found compatible keysystem", keyType, keySystemConfigurations);
                    obs.next({
                        type: "create-media-key-system-access",
                        value: {
                            options: keySystemOptions,
                            mediaKeySystemAccess: keySystemAccess,
                        },
                    });
                    obs.complete();
                }, function () {
                    log_1.default.debug("eme: rejected access to keysystem", keyType, keySystemConfigurations);
                    sub = null;
                    testKeySystem(index + 1);
                });
            }
            testKeySystem(0);
            return function () {
                disposed = true;
                if (sub) {
                    sub.unsubscribe();
                }
            };
        });
    });
}
exports.default = getMediaKeySystemAccess;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
var log_1 = __webpack_require__(1);
var find_key_system_1 = __webpack_require__(198);
var set_server_certificate_1 = __webpack_require__(197);
var open_sessions_store_1 = __webpack_require__(196);
var persisted_session_store_1 = __webpack_require__(195);
/**
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 * @throws {EncryptedMediaError}
 */
function createSessionStorage(keySystemOptions) {
    if (!keySystemOptions.persistentLicense) {
        return null;
    }
    var licenseStorage = keySystemOptions.licenseStorage;
    if (!licenseStorage) {
        var error = new Error("no license storage found for persistent license.");
        throw new errors_1.EncryptedMediaError("INVALID_KEY_SYSTEM", error, true);
    }
    log_1.default.info("set the given license storage");
    return new persisted_session_store_1.default(licenseStorage);
}
function getMediaKeysInfos(mediaElement, keySystemsConfigs, currentMediaKeysInfos, errorStream) {
    return find_key_system_1.default(mediaElement, keySystemsConfigs, currentMediaKeysInfos)
        .mergeMap(function (evt) {
        var _a = evt.value, options = _a.options, mediaKeySystemAccess = _a.mediaKeySystemAccess;
        var currentState = currentMediaKeysInfos.getState(mediaElement);
        var mediaKeys$;
        if (currentState != null && evt.type === "reuse-media-key-system-access") {
            var mediaKeys = currentState.mediaKeys, sessionsStore = currentState.sessionsStore;
            mediaKeys$ = Observable_1.Observable.of({ mediaKeys: mediaKeys, sessionsStore: sessionsStore });
        }
        else {
            mediaKeys$ = castToObservable_1.default(mediaKeySystemAccess.createMediaKeys())
                .map(function (mediaKeys) { return ({
                mediaKeys: mediaKeys,
                sessionsStore: new open_sessions_store_1.default(mediaKeys),
            }); });
        }
        return mediaKeys$
            .mergeMap(function (_a) {
            var mediaKeys = _a.mediaKeys, sessionsStore = _a.sessionsStore;
            var serverCertificate = options.serverCertificate;
            return (serverCertificate != null ?
                set_server_certificate_1.default(mediaKeys, serverCertificate, errorStream) :
                Observable_1.Observable.of(null)).mapTo({
                mediaKeySystemAccess: mediaKeySystemAccess,
                keySystemOptions: options,
                mediaKeys: mediaKeys,
                sessionsStore: sessionsStore,
                sessionStorage: createSessionStorage(options),
            });
        });
    });
}
exports.default = getMediaKeysInfos;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(6);
var castToObservable_1 = __webpack_require__(14);
/**
 * Generate a request from session.
 * @param {MediaKeySession} session
 * @param {Uint8Array} initData
 * @param {string} initDataType
 * @param {string} sessionType
 * @returns {Observable}
 */
function generateKeyRequest(session, initData, initDataType) {
    return Observable_1.Observable.defer(function () {
        return castToObservable_1.default(session.generateRequest(initDataType || "", initData))
            .catch(function (error) {
            throw new errors_1.EncryptedMediaError("KEY_GENERATE_REQUEST_ERROR", error, false);
        })
            .mapTo(null);
    });
}
exports.default = generateKeyRequest;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
/**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function disposeMediaKeys(mediaElement, mediaKeysInfos) {
    return Observable_1.Observable.defer(function () {
        var currentState = mediaKeysInfos.getState(mediaElement);
        if (!currentState) {
            return Observable_1.Observable.of(null);
        }
        var sessionsStore = currentState.sessionsStore;
        mediaKeysInfos.clearState(mediaElement);
        return sessionsStore.closeAllSessions()
            .mergeMapTo(compat_1.setMediaKeys(mediaElement, null));
    });
}
exports.default = disposeMediaKeys;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
/**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily currentMediaKeysInfos
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} currentMediaKeysInfos
 * @returns {Observable}
 */
function attachMediaKeys(mediaKeysInfos, mediaElement, currentMediaKeysInfos) {
    return Observable_1.Observable.defer(function () {
        var previousState = currentMediaKeysInfos.getState(mediaElement);
        var keySystemOptions = mediaKeysInfos.keySystemOptions, mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess, mediaKeys = mediaKeysInfos.mediaKeys, sessionsStore = mediaKeysInfos.sessionsStore;
        currentMediaKeysInfos.setState(mediaElement, {
            keySystemOptions: keySystemOptions,
            mediaKeySystemAccess: mediaKeySystemAccess,
            mediaKeys: mediaKeys,
            sessionsStore: sessionsStore,
        });
        return (previousState && previousState.sessionsStore !== sessionsStore ?
            previousState.sessionsStore.closeAllSessions() :
            Observable_1.Observable.of(null)).mergeMap(function () {
            if (mediaElement.mediaKeys === mediaKeys) {
                return Observable_1.Observable.of(null);
            }
            log_1.default.debug("eme: set mediakeys");
            return compat_1.setMediaKeys(mediaElement, mediaKeys);
        });
    });
}
exports.default = attachMediaKeys;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(8);
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(4);
var strings_1 = __webpack_require__(92);
var url_1 = __webpack_require__(20);
var isobmff_1 = __webpack_require__(30);
var request_1 = __webpack_require__(23);
var isobmff_timing_infos_1 = __webpack_require__(89);
var utils_1 = __webpack_require__(51);
/**
 * Perform requests for "text" segments
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function TextTrackLoader(_a) {
    var segment = _a.segment, representation = _a.representation;
    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;
    // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
    var responseType = utils_1.isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
    // init segment without initialization media/range/indexRange:
    // we do nothing on the network
    if (isInit && !(media || range || indexRange)) {
        return Observable_1.Observable.of({
            type: "data",
            value: { responseData: null },
        });
    }
    var path = media ? utils_1.replaceTokens(media, segment, representation) : "";
    var mediaUrl = url_1.resolveURL(representation.baseURL, path);
    // fire a single time for contiguous init and index ranges
    if (range && indexRange && range[1] === indexRange[0] - 1) {
        return request_1.default({
            url: mediaUrl,
            responseType: responseType,
            headers: {
                Range: utils_1.byteRange([range[0], indexRange[1]]),
            },
        });
    }
    var mediaRequest = request_1.default({
        url: mediaUrl,
        responseType: responseType,
        headers: range ? {
            Range: utils_1.byteRange(range),
        } : null,
    });
    if (!indexRange) {
        return mediaRequest;
    }
    // If init segment has indexRange metadata, we need to fetch
    // both the initialization data and the index metadata. We do
    // this in parallel and send the both blobs into the pipeline.
    // TODO Find a solution for calling only one time the parser
    var indexRequest = request_1.default({
        url: mediaUrl,
        responseType: responseType,
        headers: {
            Range: utils_1.byteRange(indexRange),
        },
    });
    return Observable_1.Observable.merge(mediaRequest, indexRequest);
}
exports.loader = TextTrackLoader;
/**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function TextTrackParser(_a) {
    var response = _a.response, segment = _a.segment, adaptation = _a.adaptation, representation = _a.representation, init = _a.init;
    var language = adaptation.language;
    var isInit = segment.isInit, indexRange = segment.indexRange;
    if (response.responseData == null) {
        return Observable_1.Observable.of({
            segmentData: null,
            segmentInfos: segment.timescale > 0 ? {
                duration: segment.isInit ? 0 : segment.duration,
                time: segment.isInit ? -1 : segment.time,
                timescale: segment.timescale,
            } : null,
        });
    }
    var responseData;
    var nextSegments;
    var segmentInfos;
    var segmentData;
    var isMP4 = utils_1.isMP4EmbeddedTrack(representation);
    if (isMP4) {
        assert_1.default(response.responseData instanceof ArrayBuffer);
        responseData = new Uint8Array(response.responseData);
        var sidxSegments = isobmff_1.parseSidx(responseData, indexRange ? indexRange[0] : 0);
        if (sidxSegments) {
            nextSegments = sidxSegments;
        }
        segmentInfos = isInit ?
            { time: -1, duration: 0, timescale: segment.timescale } :
            isobmff_timing_infos_1.default(segment, responseData, sidxSegments, init);
    }
    else { // if not MP4
        assert_1.default(typeof response.responseData === "string");
        responseData = response.responseData;
        if (isInit) {
            segmentInfos = { time: -1, duration: 0, timescale: segment.timescale };
        }
        else {
            segmentInfos = {
                time: segment.time || 0,
                duration: segment.duration,
                timescale: segment.timescale,
            };
        }
    }
    if (isInit) {
        if (isMP4) {
            var timescale = isobmff_1.getMDHDTimescale(responseData);
            if (timescale > 0) {
                segmentInfos = {
                    time: -1,
                    duration: 0,
                    timescale: timescale,
                };
            }
        }
        segmentData = null;
    }
    else { // if not init
        assert_1.default(segmentInfos != null);
        var segmentDataBase = {
            start: segmentInfos.time,
            end: segmentInfos.time + (segmentInfos.duration || 0),
            language: language,
            timescale: segmentInfos.timescale,
            timeOffset: 0,
        };
        if (isMP4) {
            var _b = representation.codec, codec = _b === void 0 ? "" : _b;
            var type = void 0;
            switch (codec.toLowerCase()) {
                case "stpp": // stpp === TTML in MP4
                    type = "ttml";
                    break;
                case "wvtt": // wvtt === WebVTT in MP4
                    type = "vtt";
            }
            if (!type) {
                throw new Error("The codec used for the subtitle is not managed yet.");
            }
            segmentData = objectAssign({
                data: strings_1.stringFromUTF8(isobmff_1.getMDAT(responseData)),
                type: type,
            }, { timescale: 1 }, segmentDataBase);
        }
        else { // not MP4: check for plain text subtitles
            var type = void 0;
            var _c = representation.mimeType, mimeType = _c === void 0 ? "" : _c;
            switch (representation.mimeType) {
                case "application/ttml+xml":
                    type = "ttml";
                    break;
                case "application/x-sami":
                case "application/smil":
                    type = "sami";
                    break;
                case "text/vtt":
                    type = "vtt";
            }
            if (!type) {
                var _d = representation.codec, codec = _d === void 0 ? "" : _d;
                var codeLC = codec.toLowerCase();
                if (codeLC === "srt") {
                    type = "srt";
                }
                else {
                    throw new Error("could not find a text-track parser for the type " + mimeType);
                }
            }
            segmentData = objectAssign({
                data: responseData,
                type: type,
            }, { timescale: 1 }, segmentDataBase);
        }
    }
    if (nextSegments) {
        utils_1.addNextSegments(representation, nextSegments, segmentInfos);
    }
    return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
}
exports.parser = TextTrackParser;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var url_1 = __webpack_require__(20);
var request_1 = __webpack_require__(23);
var utils_1 = __webpack_require__(51);
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @param {string} opt.url
 * @param {Segment} opt.segment
 * @returns {Observable}
 */
function regularSegmentLoader(_a) {
    var url = _a.url, segment = _a.segment;
    var range = segment.range, indexRange = segment.indexRange;
    // fire a single time contiguous init and index ranges.
    if (range && indexRange &&
        range[1] === indexRange[0] - 1) {
        return request_1.default({
            url: url,
            responseType: "arraybuffer",
            headers: {
                Range: utils_1.byteRange([range[0], indexRange[1]]),
            },
        });
    }
    var mediaHeaders = range ?
        { Range: utils_1.byteRange(range) } : null;
    var mediaOrInitRequest = request_1.default({
        url: url,
        responseType: "arraybuffer",
        headers: mediaHeaders,
    });
    // If init segment has indexRange metadata, we need to fetch
    // both the initialization data and the index metadata. We do
    // this in parallel and send the both blobs into the pipeline.
    if (indexRange) {
        var indexRequest = request_1.default({
            url: url,
            responseType: "arraybuffer",
            headers: { Range: utils_1.byteRange(indexRange) },
        });
        return Observable_1.Observable.merge(mediaOrInitRequest, indexRequest);
    }
    else {
        return mediaOrInitRequest;
    }
}
/**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */
var segmentPreLoader = function (customSegmentLoader) { return function (_a) {
    var adaptation = _a.adaptation, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;
    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;
    // init segment without initialization media/range/indexRange:
    // we do nothing on the network
    if (isInit && !(media || range || indexRange)) {
        return Observable_1.Observable.empty();
    }
    // construct url for the segment
    var path = media ? utils_1.replaceTokens(media, segment, representation) : "";
    var url = url_1.resolveURL(representation.baseURL, path);
    var args = {
        adaptation: adaptation,
        manifest: manifest,
        period: period,
        representation: representation,
        segment: segment,
        transport: "dash",
        url: url,
    };
    if (!customSegmentLoader) {
        return regularSegmentLoader(args);
    }
    return Observable_1.Observable.create(function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         * @param {*} args.data - The segment data
         * @param {Number} args.size - The segment size
         * @param {Number} args.duration - The duration of the request, in ms
         */
        var resolve = function (_args) {
            if (!hasFallbacked) {
                hasFinished = true;
                obs.next({
                    type: "response",
                    value: {
                        responseData: _args.data,
                        size: _args.size,
                        duration: _args.duration,
                    },
                });
                obs.complete();
            }
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} [err={}] - The corresponding error encountered
         */
        var reject = function (err) {
            if (err === void 0) { err = {}; }
            if (!hasFallbacked) {
                hasFinished = true;
                obs.error(err);
            }
        };
        /**
         * Callback triggered when the custom segment loader wants to fallback to
         * the "regular" implementation
         */
        var fallback = function () {
            hasFallbacked = true;
            regularSegmentLoader(args).subscribe(obs);
        };
        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
        var abort = customSegmentLoader(args, callbacks);
        return function () {
            if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                abort();
            }
        };
    });
}; };
exports.default = segmentPreLoader;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseS(root, previousS) {
    var ts;
    var d;
    var r;
    for (var j = 0; j < root.attributes.length; j++) {
        var attribute = root.attributes[j];
        switch (attribute.name) {
            case "t":
                ts = parseInt(attribute.value, 10);
                break;
            case "d":
                d = parseInt(attribute.value, 10);
                break;
            case "r":
                r = parseInt(attribute.value, 10);
                break;
        }
    }
    if (ts == null && previousS && previousS.d != null) {
        ts = previousS.ts + (previousS.d * (previousS.r + 1));
    }
    if ((ts != null && !isNaN(ts)) &&
        (d == null || !isNaN(d)) &&
        (r == null || !isNaN(r))) {
        return {
            ts: ts,
            d: d,
            r: r || 0,
        };
    }
    else {
        log_1.default.warn("DASH: A \"S\" Element could not have been parsed.");
    }
}
exports.default = parseS;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var S_1 = __webpack_require__(205);
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function parseSegmentTimeline(root) {
    var timeline = [];
    var timelineChildren = root.childNodes;
    for (var i = 0; i < timelineChildren.length; i++) {
        if (timelineChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentElement = timelineChildren[i];
            if (currentElement.nodeName === "S") {
                var s = S_1.default(currentElement, timeline[timeline.length - 1] || null);
                if (s) {
                    timeline.push(s);
                }
            }
        }
    }
    return timeline;
}
exports.default = parseSegmentTimeline;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseSegmentURL(root) {
    var parsedSegmentURL = {};
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "media":
                parsedSegmentURL.media = attribute.value;
                break;
            case "indexRange":
                {
                    var indexRange = helpers_1.parseByteRange(attribute.value) || undefined;
                    if (!indexRange) {
                        log_1.default.warn("DASH: invalid indexRange (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedSegmentURL.indexRange = indexRange;
                    }
                }
                break;
            case "index":
                parsedSegmentURL.index = attribute.value;
                break;
            case "mediaRange":
                {
                    var mediaRange = helpers_1.parseByteRange(attribute.value) || undefined;
                    if (!mediaRange) {
                        log_1.default.warn("DASH: invalid mediaRange (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedSegmentURL.mediaRange = mediaRange;
                    }
                }
                break;
        }
    }
    return parsedSegmentURL;
}
exports.default = parseSegmentURL;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseInitialization(root) {
    var parsedInitialization = {};
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "range":
                {
                    var range = helpers_1.parseByteRange(attribute.value) || undefined;
                    if (!range) {
                        log_1.default.warn("DASH: invalid range (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedInitialization.range = range;
                    }
                }
                break;
            case "sourceURL":
                parsedInitialization.media = attribute.value;
                break;
        }
    }
    return parsedInitialization;
}
exports.default = parseInitialization;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
var SegmentBase_1 = __webpack_require__(36);
var SegmentList_1 = __webpack_require__(88);
var SegmentTemplate_1 = __webpack_require__(87);
/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */
function parseRepresentationChildren(representationChildren) {
    var children = {
        baseURL: "",
    };
    for (var i = 0; i < representationChildren.length; i++) {
        if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentElement = representationChildren[i];
            switch (currentElement.nodeName) {
                case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;
                case "SegmentBase":
                    children.segmentBase = SegmentBase_1.default(currentElement);
                    break;
                case "SegmentList":
                    children.segmentList = SegmentList_1.default(currentElement);
                    break;
                case "SegmentTemplate":
                    children.segmentTemplate = SegmentTemplate_1.default(currentElement);
                    break;
            }
        }
    }
    return children;
}
/**
 * @param {Element} representationElement
 * @returns {Object}
 */
function parseRepresentationAttributes(representationElement) {
    var attributes = {};
    for (var i = 0; i < representationElement.attributes.length; i++) {
        var attribute = representationElement.attributes[i];
        switch (attribute.name) {
            case "audioSamplingRate":
                attributes.audioSamplingRate = attribute.value;
                break;
            case "bandwidth":
                {
                    var bitrate = parseInt(attribute.value, 10);
                    if (isNaN(bitrate)) {
                        log_1.default.warn("DASH: invalid bandwidth (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.bitrate = bitrate;
                    }
                }
                break;
            case "codecs":
                attributes.codecs = attribute.value;
                break;
            case "codingDependency":
                attributes.codingDependency = helpers_1.parseBoolean(attribute.value);
                break;
            case "frameRate":
                {
                    var frameRate = helpers_1.parseFrameRate(attribute.value);
                    if (isNaN(frameRate)) {
                        log_1.default.warn("DASH: invalid frameRate (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.frameRate = frameRate;
                    }
                }
                break;
            case "height":
                {
                    var height = parseInt(attribute.value, 10);
                    if (isNaN(height)) {
                        log_1.default.warn("DASH: invalid height (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.height = height;
                    }
                }
                break;
            case "id":
                attributes.id = attribute.value;
                break;
            case "maxPlayoutRate":
                {
                    var maxPlayoutRate = parseFloat(attribute.value);
                    if (isNaN(maxPlayoutRate)) {
                        log_1.default.warn("DASH: invalid maxPlayoutRate (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.maxPlayoutRate = maxPlayoutRate;
                    }
                }
                break;
            case "maximumSAPPeriod":
                {
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    if (isNaN(maximumSAPPeriod)) {
                        log_1.default.warn("DASH: invalid maximumSAPPeriod (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.maximumSAPPeriod = maximumSAPPeriod;
                    }
                }
                break;
            case "mimeType":
                attributes.mimeType = attribute.value;
                break;
            case "profiles":
                attributes.profiles = attribute.value;
                break;
            case "qualityRanking":
                {
                    var qualityRanking = parseInt(attribute.value, 10);
                    if (isNaN(qualityRanking)) {
                        log_1.default.warn("DASH: invalid qualityRanking (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.qualityRanking = qualityRanking;
                    }
                }
                break;
            case "segmentProfiles":
                attributes.segmentProfiles = attribute.value;
                break;
            case "width":
                {
                    var width = parseInt(attribute.value, 10);
                    if (isNaN(width)) {
                        log_1.default.warn("DASH: invalid width (\"" + attribute.value + "\")");
                    }
                    else {
                        attributes.width = width;
                    }
                }
                break;
        }
    }
    return attributes;
}
function createRepresentationIntermediateRepresentation(representationElement) {
    return {
        children: parseRepresentationChildren(representationElement.childNodes),
        attributes: parseRepresentationAttributes(representationElement),
    };
}
exports.createRepresentationIntermediateRepresentation = createRepresentationIntermediateRepresentation;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(12);
/**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @param {Function} [contentProtectionParser]
 * @returns {Object}
 */
function parseContentProtection(root) {
    return helpers_1.parseScheme(root);
}
exports.default = parseContentProtection;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(12);
/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseContentComponent(root) {
    var ret = {};
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                ret.id = attribute.value;
                break;
            case "lang":
                ret.language = attribute.value;
                break;
            case "contentType":
                ret.contentType = attribute.value;
                break;
            case "par":
                ret.par = helpers_1.parseRatio(attribute.value);
                break;
        }
    }
    return ret;
}
exports.default = parseContentComponent;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
var ContentComponent_1 = __webpack_require__(211);
var ContentProtection_1 = __webpack_require__(210);
var Representation_1 = __webpack_require__(209);
var SegmentBase_1 = __webpack_require__(36);
var SegmentList_1 = __webpack_require__(88);
var SegmentTemplate_1 = __webpack_require__(87);
function parseAdaptationSetChildren(adaptationSetChildren) {
    var children = {
        baseURL: "",
        representations: [],
    };
    for (var i = 0; i < adaptationSetChildren.length; i++) {
        if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentElement = adaptationSetChildren[i];
            switch (currentElement.nodeName) {
                case "Accessibility":
                    children.accessibility = helpers_1.parseScheme(currentElement);
                    break;
                case "BaseURL":
                    children.baseURL = currentElement.textContent || "";
                    break;
                case "ContentComponent":
                    children.contentComponent = ContentComponent_1.default(currentElement);
                    break;
                case "Representation":
                    var representation = Representation_1.createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    break;
                case "Role":
                    children.role = helpers_1.parseScheme(currentElement);
                    break;
                case "SegmentBase":
                    children.segmentBase = SegmentBase_1.default(currentElement);
                    break;
                case "SegmentList":
                    children.segmentList = SegmentList_1.default(currentElement);
                    break;
                case "SegmentTemplate":
                    children.segmentTemplate = SegmentTemplate_1.default(currentElement);
                    break;
                case "ContentProtection":
                    children.contentProtection = ContentProtection_1.default(currentElement);
                    break;
                // case "Rating":
                //   children.rating = currentElement;
                //   break;
                // case "Viewpoint":
                //   children.viewpoint = currentElement;
                //   break;
            }
        }
    }
    return children;
}
function parseAdaptationSetAttributes(root) {
    var parsedAdaptation = {};
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                parsedAdaptation.id = attribute.value;
                break;
            case "group":
                {
                    var group = parseInt(attribute.value, 10);
                    if (isNaN(group)) {
                        log_1.default.warn("DASH: invalid group (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.group = group;
                    }
                }
                break;
            case "lang":
                parsedAdaptation.language = attribute.value;
                break;
            case "contentType":
                parsedAdaptation.contentType = attribute.value;
                break;
            case "par":
                parsedAdaptation.par = attribute.value;
                break;
            case "minBandwidth":
                {
                    var minBitrate = parseInt(attribute.value, 10);
                    if (isNaN(minBitrate)) {
                        log_1.default.warn("DASH: invalid minBandwidth (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.minBitrate = minBitrate;
                    }
                }
                break;
            case "maxBandwidth":
                {
                    var maxBitrate = parseInt(attribute.value, 10);
                    if (isNaN(maxBitrate)) {
                        log_1.default.warn("DASH: invalid maxBandwidth (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maxBitrate = maxBitrate;
                    }
                }
                break;
            case "minWidth":
                {
                    var minWidth = parseInt(attribute.value, 10);
                    if (isNaN(minWidth)) {
                        log_1.default.warn("DASH: invalid minWidth (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.minWidth = minWidth;
                    }
                }
                break;
            case "maxWidth":
                {
                    var maxWidth = parseInt(attribute.value, 10);
                    if (isNaN(maxWidth)) {
                        log_1.default.warn("DASH: invalid maxWidth (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maxWidth = maxWidth;
                    }
                }
                break;
            case "minHeight":
                {
                    var minHeight = parseInt(attribute.value, 10);
                    if (isNaN(minHeight)) {
                        log_1.default.warn("DASH: invalid minHeight (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.minHeight = minHeight;
                    }
                }
                break;
            case "maxHeight":
                {
                    var maxHeight = parseInt(attribute.value, 10);
                    if (isNaN(maxHeight)) {
                        log_1.default.warn("DASH: invalid maxHeight (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maxHeight = maxHeight;
                    }
                }
                break;
            case "minFrameRate":
                {
                    var minFrameRate = helpers_1.parseFrameRate(attribute.value);
                    if (isNaN(minFrameRate)) {
                        log_1.default.warn("DASH: invalid minFrameRate (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.minFrameRate = minFrameRate;
                    }
                }
                break;
            case "maxFrameRate":
                {
                    var maxFrameRate = helpers_1.parseFrameRate(attribute.value);
                    if (isNaN(maxFrameRate)) {
                        log_1.default.warn("DASH: invalid maxFrameRate (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maxFrameRate = maxFrameRate;
                    }
                }
                break;
            case "segmentAlignment":
                {
                    var segmentAlignment = helpers_1.parseIntOrBoolean(attribute.value);
                    if (typeof segmentAlignment === "number" && isNaN(segmentAlignment)) {
                        log_1.default.warn("DASH: invalid segmentAlignment (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.segmentAlignment = segmentAlignment;
                    }
                }
                break;
            case "subsegmentAlignment":
                {
                    var subsegmentAlignment = helpers_1.parseIntOrBoolean(attribute.value);
                    if (typeof subsegmentAlignment === "number" && isNaN(subsegmentAlignment)) {
                        log_1.default.warn("DASH: invalid subsegmentAlignment (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
                    }
                }
                break;
            case "bitstreamSwitching":
                parsedAdaptation.bitstreamSwitching = helpers_1.parseBoolean(attribute.value);
                break;
            case "audioSamplingRate":
                parsedAdaptation.audioSamplingRate = attribute.value;
                break;
            case "codecs":
                parsedAdaptation.codecs = attribute.value;
                break;
            case "codingDependency":
                parsedAdaptation.codingDependency = helpers_1.parseBoolean(attribute.value);
                break;
            case "frameRate":
                {
                    var frameRate = helpers_1.parseFrameRate(attribute.value);
                    if (isNaN(frameRate)) {
                        log_1.default.warn("DASH: invalid frameRate (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.frameRate = frameRate;
                    }
                }
                break;
            case "height":
                {
                    var height = parseInt(attribute.value, 10);
                    if (isNaN(height)) {
                        log_1.default.warn("DASH: invalid height (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.height = height;
                    }
                }
                break;
            case "maxPlayoutRate":
                {
                    var maxPlayoutRate = parseFloat(attribute.value);
                    if (isNaN(maxPlayoutRate)) {
                        log_1.default.warn("DASH: invalid maxPlayoutRate (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
                    }
                }
                break;
            case "maximumSAPPeriod":
                {
                    var maximumSAPPeriod = parseFloat(attribute.value);
                    if (isNaN(maximumSAPPeriod)) {
                        log_1.default.warn("DASH: invalid maximumSAPPeriod (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
                    }
                }
                break;
            case "mimeType":
                parsedAdaptation.mimeType = attribute.value;
                break;
            case "profiles":
                parsedAdaptation.profiles = attribute.value;
                break;
            case "segmentProfiles":
                parsedAdaptation.segmentProfiles = attribute.value;
                break;
            case "width":
                {
                    var width = parseInt(attribute.value, 10);
                    if (isNaN(width)) {
                        log_1.default.warn("DASH: invalid width (\"" + attribute.value + "\")");
                    }
                    else {
                        parsedAdaptation.width = width;
                    }
                }
                break;
        }
    }
    return parsedAdaptation;
}
function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
    return {
        children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
        attributes: parseAdaptationSetAttributes(adaptationSetElement),
    };
}
exports.createAdaptationSetIntermediateRepresentation = createAdaptationSetIntermediateRepresentation;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(12);
var AdaptationSet_1 = __webpack_require__(212);
/**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */
function parsePeriodChildren(periodChildren) {
    var baseURL = "";
    var adaptations = [];
    for (var i = 0; i < periodChildren.length; i++) {
        if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentElement = periodChildren[i];
            switch (currentElement.nodeName) {
                case "BaseURL":
                    baseURL = currentElement.textContent || "";
                    break;
                case "AdaptationSet":
                    var adaptation = AdaptationSet_1.createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                    break;
            }
        }
    }
    return { baseURL: baseURL, adaptations: adaptations };
}
/**
 * @param {Element} periodElement
 * @returns {Object}
 */
function parsePeriodAttributes(periodElement) {
    var res = {};
    for (var i = 0; i < periodElement.attributes.length; i++) {
        var attribute = periodElement.attributes[i];
        switch (attribute.name) {
            case "id":
                res.id = attribute.value;
                break;
            case "start":
                {
                    var tempStart = helpers_1.parseDuration(attribute.value);
                    if (!isNaN(tempStart)) {
                        res.start = tempStart;
                    }
                    else {
                        log_1.default.warn("DASH: Unrecognized start in the mpd:", attribute.value);
                    }
                }
                break;
            case "duration":
                {
                    var tempDuration = helpers_1.parseDuration(attribute.value);
                    if (!isNaN(tempDuration)) {
                        res.duration = tempDuration;
                    }
                    else {
                        log_1.default.warn("DASH: Unrecognized duration in the mpd:", attribute.value);
                    }
                }
                break;
            case "bitstreamSwitching":
                res.bitstreamSwitching = helpers_1.parseBoolean(attribute.value);
                break;
        }
    }
    return res;
}
function createPeriodIntermediateRepresentation(periodElement) {
    return {
        children: parsePeriodChildren(periodElement.childNodes),
        attributes: parsePeriodAttributes(periodElement),
    };
}
exports.createPeriodIntermediateRepresentation = createPeriodIntermediateRepresentation;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(12);
var Period_1 = __webpack_require__(213);
/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */
function parseMPDChildren(mpdChildren) {
    var baseURL = "";
    var locations = [];
    var periods = [];
    for (var i = 0; i < mpdChildren.length; i++) {
        if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
            var currentNode = mpdChildren[i];
            switch (currentNode.nodeName) {
                case "BaseURL":
                    baseURL = currentNode.textContent || "";
                    break;
                case "Location":
                    locations.push(currentNode.textContent || "");
                    break;
                case "Period":
                    var period = Period_1.createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                    break;
            }
        }
    }
    return { baseURL: baseURL, locations: locations, periods: periods };
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseMPDAttributes(root) {
    var res = {};
    for (var i = 0; i < root.attributes.length; i++) {
        var attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                res.id = attribute.value;
                break;
            case "profiles":
                res.profiles = attribute.value;
                break;
            case "type":
                res.type = attribute.value;
                break;
            case "availabilityStartTime":
                res.availabilityStartTime = +helpers_1.parseDateTime(attribute.value);
                break;
            case "availabilityEndTime":
                res.availabilityEndTime = +helpers_1.parseDateTime(attribute.value);
                break;
            case "publishTime":
                res.publishTime = +helpers_1.parseDateTime(attribute.value);
                break;
            case "mediaPresentationDuration":
                res.duration = helpers_1.parseDuration(attribute.value);
                break;
            case "minimumUpdatePeriod":
                res.minimumUpdatePeriod = helpers_1.parseDuration(attribute.value);
                break;
            case "minBufferTime":
                res.minBufferTime = helpers_1.parseDuration(attribute.value);
                break;
            case "timeShiftBufferDepth":
                res.timeShiftBufferDepth = helpers_1.parseDuration(attribute.value);
                break;
            case "suggestedPresentationDelay":
                res.suggestedPresentationDelay = helpers_1.parseDuration(attribute.value);
                break;
            case "maxSegmentDuration":
                res.maxSegmentDuration = helpers_1.parseDuration(attribute.value);
                break;
            case "maxSubsegmentDuration":
                res.maxSubsegmentDuration = helpers_1.parseDuration(attribute.value);
                break;
        }
    }
    return res;
}
function createMPDIntermediateRepresentation(root) {
    return {
        children: parseMPDChildren(root.childNodes),
        attributes: parseMPDAttributes(root),
    };
}
exports.createMPDIntermediateRepresentation = createMPDIntermediateRepresentation;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(37);
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */
function getSegmentIndex(index, ts) {
    var timeline = index.timeline;
    var low = 0;
    var high = timeline.length;
    while (low < high) {
        var mid = (low + high) >>> 1;
        if (timeline[mid].ts < ts) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return (low > 0)
        ? low - 1
        : low;
}
/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Number} newSegment.timescale
 * @param {Number} newSegment.time
 * @param {Number} newSegment.duration
 * @param {Object} currentSegment
 * @param {Number} currentSegment.timescale
 * @param {Number} currentSegment.time
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, newSegment, currentSegment) {
    var timeline = index.timeline, timescale = index.timescale;
    var timelineLength = timeline.length;
    var last = timeline[timelineLength - 1];
    var scaledNewSegment = newSegment.timescale === timescale ? {
        time: newSegment.time,
        duration: newSegment.duration,
    } : {
        time: (newSegment.time / newSegment.timescale) * timescale,
        duration: (newSegment.duration / newSegment.timescale) * timescale,
    };
    var scaledCurrentTime;
    if (currentSegment && currentSegment.timescale) {
        scaledCurrentTime = currentSegment.timescale === timescale ?
            currentSegment.time :
            (currentSegment.time / currentSegment.timescale) * timescale;
    }
    // in some circumstances, the new segment informations are only
    // duration informations that we can use to deduct the ts of the
    // next segment. this is the case where the new segment are
    // associated to a current segment and have the same ts
    var shouldDeductNextSegment = scaledCurrentTime != null &&
        (scaledNewSegment.time === scaledCurrentTime);
    if (shouldDeductNextSegment) {
        var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;
        var lastSegmentTs = (last.ts + last.d * last.r);
        var tsDiff = newSegmentTs - lastSegmentTs;
        if (tsDiff <= 0) { // same segment / behind the last
            return false;
        }
        // try to use the compact notation with @r attribute on the last
        // to elements of the timeline if we find out they have the same
        // duration
        if (last.d === -1) {
            var prev = timeline[timelineLength - 2];
            if (prev && prev.d === tsDiff) {
                prev.r++;
                timeline.pop();
            }
            else {
                last.d = tsDiff;
            }
        }
        index.timeline.push({
            d: -1,
            ts: newSegmentTs,
            r: 0,
        });
        return true;
    }
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    else if (scaledNewSegment.time >= helpers_1.getTimelineRangeEnd(last)) {
        if (last.d === scaledNewSegment.duration) {
            last.r++;
        }
        else {
            index.timeline.push({
                d: scaledNewSegment.duration,
                ts: scaledNewSegment.time,
                r: 0,
            });
        }
        return true;
    }
    return false;
}
var TimelineRepresentationIndex = /** @class */ (function () {
    /**
     * @param {Object} index
     */
    function TimelineRepresentationIndex(index, periodStart) {
        if (index.presentationTimeOffset == null) {
            index.presentationTimeOffset = periodStart * index.timescale;
        }
        this._index = index;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    TimelineRepresentationIndex.prototype.getInitSegment = function () {
        return helpers_1.getInitSegment(this._index);
    };
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    TimelineRepresentationIndex.prototype.getSegments = function (_up, _to) {
        return helpers_1.getSegmentsFromTimeline(this._index, _up, _to);
    };
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Boolean}
     */
    TimelineRepresentationIndex.prototype.shouldRefresh = function (_up, to) {
        var _a = this._index, timeline = _a.timeline, timescale = _a.timescale, _b = _a.presentationTimeOffset, presentationTimeOffset = _b === void 0 ? 0 : _b;
        var scaledTo = to * timescale - presentationTimeOffset;
        var last = timeline[timeline.length - 1];
        if (!last) {
            return false;
        }
        if (last.d < 0) {
            last = { ts: last.ts, d: 0, r: last.r };
        }
        return !(scaledTo <= helpers_1.getTimelineRangeEnd(last));
    };
    /**
     * Returns first position in index.
     * @returns {Number|undefined}
     */
    TimelineRepresentationIndex.prototype.getFirstPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        return index.timeline[0].ts / index.timescale;
    };
    /**
     * Returns last position in index.
     * @returns {Number|undefined}
     */
    TimelineRepresentationIndex.prototype.getLastPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);
    };
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting ts
     * for the next (discontinuited) range. If not this is equal to -1.
     */
    TimelineRepresentationIndex.prototype.checkDiscontinuity = function (_time) {
        var _a = this._index, timeline = _a.timeline, _b = _a.timescale, timescale = _b === void 0 ? 1 : _b;
        var time = _time * timescale;
        if (time <= 0) {
            return -1;
        }
        var segmentIndex = getSegmentIndex(this._index, time);
        if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
            return -1;
        }
        var range = timeline[segmentIndex];
        if (range.d === -1) {
            return -1;
        }
        var rangeUp = range.ts;
        var rangeTo = helpers_1.getTimelineRangeEnd(range);
        var nextRange = timeline[segmentIndex + 1];
        // when we are actually inside the found range and this range has
        // an explicit discontinuity with the next one
        if (rangeTo !== nextRange.ts &&
            time >= rangeUp &&
            time <= rangeTo &&
            (rangeTo - time) < timescale) {
            return nextRange.ts / timescale;
        }
        return -1;
    };
    /**
     * @param {Object}
     */
    TimelineRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {
        this._index = newIndex._index;
    };
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @param {Array.<Object>}
     * @param {Object}
     * @returns {Array}
     */
    TimelineRepresentationIndex.prototype._addSegments = function (nextSegments, currentSegment) {
        for (var i = 0; i < nextSegments.length; i++) {
            _addSegmentInfos(this._index, nextSegments[i], currentSegment);
        }
    };
    return TimelineRepresentationIndex;
}());
exports.default = TimelineRepresentationIndex;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(37);
var TemplateRepresentationIndex = /** @class */ (function () {
    /**
     * @param {Object} index
     */
    function TemplateRepresentationIndex(index, periodStart) {
        if (index.presentationTimeOffset == null) {
            index.presentationTimeOffset = periodStart * index.timescale;
        }
        this._index = index;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    TemplateRepresentationIndex.prototype.getInitSegment = function () {
        return helpers_1.getInitSegment(this._index);
    };
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    TemplateRepresentationIndex.prototype.getSegments = function (_up, _to) {
        var index = this._index;
        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        if (to <= up) {
            return [];
        }
        var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, media = index.media, presentationTimeOffset = index.presentationTimeOffset;
        var segments = [];
        for (var baseTime = up; baseTime <= to; baseTime += duration) {
            var number = Math.floor(baseTime / duration) +
                (startNumber == null ? 1 : startNumber);
            var time = (number -
                (startNumber == null ? 1 : startNumber)) * duration + (presentationTimeOffset || 0);
            var args = {
                id: "" + number,
                number: number,
                time: time,
                isInit: false,
                duration: duration,
                timescale: timescale,
                media: media,
            };
            segments.push(args);
        }
        return segments;
    };
    /**
     * Returns first position in index.
     * @returns {undefined}
     */
    TemplateRepresentationIndex.prototype.getFirstPosition = function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    };
    /**
     * Returns last position in index.
     * @returns {undefined}
     */
    TemplateRepresentationIndex.prototype.getLastPosition = function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    };
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */
    TemplateRepresentationIndex.prototype.shouldRefresh = function () {
        return false;
    };
    /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {Number}
     */
    TemplateRepresentationIndex.prototype.checkDiscontinuity = function () {
        return -1;
    };
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */
    TemplateRepresentationIndex.prototype._addSegments = function () {
        if (false) {}
    };
    /**
     * @param {Object}
     */
    TemplateRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {
        this._index = newIndex._index;
    };
    return TemplateRepresentationIndex;
}());
exports.default = TemplateRepresentationIndex;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var helpers_1 = __webpack_require__(37);
/**
 * Provide helpers for SegmentList-based DASH indexes.
 * @type {Object}
 */
var ListRepresentationIndex = /** @class */ (function () {
    /**
     * @param {Object} index
     */
    function ListRepresentationIndex(index, periodStart) {
        if (index.presentationTimeOffset == null) {
            index.presentationTimeOffset = periodStart * index.timescale;
        }
        this._index = index;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    ListRepresentationIndex.prototype.getInitSegment = function () {
        return helpers_1.getInitSegment(this._index);
    };
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    ListRepresentationIndex.prototype.getSegments = function (_up, _to) {
        var index = this._index;
        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        var duration = index.duration, list = index.list, timescale = index.timescale;
        var length = Math.min(list.length - 1, Math.floor(to / duration));
        var segments = [];
        var i = Math.floor(up / duration);
        while (i <= length) {
            var range = list[i].mediaRange;
            var media = list[i].media;
            var args = {
                id: "" + i,
                time: i * duration,
                isInit: false,
                range: range,
                duration: duration,
                timescale: timescale,
                media: media,
            };
            segments.push(args);
            i++;
        }
        return segments;
    };
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */
    ListRepresentationIndex.prototype.shouldRefresh = function (_up, to) {
        var _a = this._index, timescale = _a.timescale, duration = _a.duration, list = _a.list, _b = _a.presentationTimeOffset, presentationTimeOffset = _b === void 0 ? 0 : _b;
        var scaledTo = to * timescale - presentationTimeOffset;
        var i = Math.floor(scaledTo / duration);
        return !(i >= 0 && i < list.length);
    };
    /**
     * Returns first position in index.
     * @returns {Number}
     */
    ListRepresentationIndex.prototype.getFirstPosition = function () {
        return 0;
    };
    /**
     * Returns last position in index.
     * @returns {Number}
     */
    ListRepresentationIndex.prototype.getLastPosition = function () {
        var index = this._index;
        var duration = index.duration, list = index.list;
        return (list.length * duration) / index.timescale;
    };
    /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {Number}
     */
    ListRepresentationIndex.prototype.checkDiscontinuity = function () {
        return -1;
    };
    /**
     * @param {Object}
     */
    ListRepresentationIndex.prototype._update = function (newIndex) {
        this._index = newIndex._index;
    };
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * @returns {Array}
     */
    ListRepresentationIndex.prototype._addSegments = function () {
        if (false) {}
    };
    return ListRepresentationIndex;
}());
exports.default = ListRepresentationIndex;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(37);
/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @param {Number} segmentInfos.timescale
 * @param {Number} segmentInfos.duration
 * @param {Number} segmentInfos.count
 * @param {*} segmentInfos.range - TODO check type
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, segmentInfos) {
    if (segmentInfos.timescale !== index.timescale) {
        var timescale = index.timescale;
        index.timeline.push({
            ts: (segmentInfos.time / segmentInfos.timescale) * timescale,
            d: (segmentInfos.duration / segmentInfos.timescale) * timescale,
            r: segmentInfos.count || 0,
            range: segmentInfos.range,
        });
    }
    else {
        index.timeline.push({
            ts: segmentInfos.time,
            d: segmentInfos.duration,
            r: segmentInfos.count || 0,
            range: segmentInfos.range,
        });
    }
    return true;
}
/**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 * TODO weird that everything is inherited from Timeline...
 * Reimplement from scratch
 */
var BaseRepresentationIndex = /** @class */ (function () {
    /**
     * @param {Object} index
     */
    function BaseRepresentationIndex(index, periodStart) {
        if (index.presentationTimeOffset == null) {
            index.presentationTimeOffset = periodStart * index.timescale;
        }
        this._index = index;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    BaseRepresentationIndex.prototype.getInitSegment = function () {
        return helpers_1.getInitSegment(this._index);
    };
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    BaseRepresentationIndex.prototype.getSegments = function (_up, _to) {
        return helpers_1.getSegmentsFromTimeline(this._index, _up, _to);
    };
    /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */
    BaseRepresentationIndex.prototype.shouldRefresh = function () {
        return false;
    };
    /**
     * Returns first position in index.
     * @returns {Number|undefined}
     */
    BaseRepresentationIndex.prototype.getFirstPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        return index.timeline[0].ts / index.timescale;
    };
    /**
     * Returns last position in index.
     * @returns {Number|undefined}
     */
    BaseRepresentationIndex.prototype.getLastPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);
    };
    /**
     * We do not check for discontinuity in SegmentBase-based indexes.
     * @returns {Number}
     */
    BaseRepresentationIndex.prototype.checkDiscontinuity = function () {
        return -1;
    };
    /**
     * @param {Array.<Object>}
     * @returns {Array.<Object>}
     */
    BaseRepresentationIndex.prototype._addSegments = function (nextSegments) {
        for (var i = 0; i < nextSegments.length; i++) {
            _addSegmentInfos(this._index, nextSegments[i]);
        }
    };
    /**
     * @param {Object}
     */
    BaseRepresentationIndex.prototype._update = function (newIndex /* TODO @ index refacto */) {
        this._index = newIndex._index;
    };
    return BaseRepresentationIndex;
}());
exports.default = BaseRepresentationIndex;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var array_includes_1 = __webpack_require__(13);
var id_1 = __webpack_require__(19);
var languages_1 = __webpack_require__(29);
var log_1 = __webpack_require__(1);
var url_1 = __webpack_require__(20);
var helpers_1 = __webpack_require__(12);
var base_1 = __webpack_require__(218);
var list_1 = __webpack_require__(217);
var template_1 = __webpack_require__(216);
var timeline_1 = __webpack_require__(215);
var MPD_1 = __webpack_require__(214);
var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
function inferAdaptationType(adaptationMimeType, representationMimeTypes, adaptationCodecs, representationCodecs, adaptationRole) {
    function fromMimeType(mimeType, role) {
        var topLevel = mimeType.split("/")[0];
        if (array_includes_1.default(KNOWN_ADAPTATION_TYPES, topLevel)) {
            return topLevel;
        }
        if (mimeType === "application/bif") {
            return "image";
        }
        if (mimeType === "application/ttml+xml") {
            return "text";
        }
        // manage DASH-IF mp4-embedded subtitles and metadata
        if (mimeType === "application/mp4") {
            if (role) {
                if (role.schemeIdUri === "urn:mpeg:dash:role:2011" &&
                    array_includes_1.default(SUPPORTED_TEXT_TYPES, role.value)) {
                    return "text";
                }
            }
            return "metadata";
        }
    }
    function fromCodecs(codecs) {
        switch (codecs.substr(0, 3)) {
            case "avc":
            case "hev":
            case "hvc":
            case "vp8":
            case "vp9":
            case "av1":
                return "video";
            case "vtt":
                return "text";
            case "bif":
                return "image";
        }
        switch (codecs.substr(0, 4)) {
            case "mp4a":
                return "audio";
            case "wvtt":
            case "stpp":
                return "text";
        }
    }
    if (adaptationMimeType != null) {
        var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRole);
        if (typeFromMimeType != null) {
            return typeFromMimeType;
        }
    }
    if (adaptationCodecs != null) {
        var typeFromCodecs = fromCodecs(adaptationCodecs);
        if (typeFromCodecs != null) {
            return typeFromCodecs;
        }
    }
    for (var i = 0; i < representationMimeTypes.length; i++) {
        var representationMimeType = representationMimeTypes[i];
        if (representationMimeType != null) {
            var typeFromMimeType = fromMimeType(representationMimeType, adaptationRole);
            if (typeFromMimeType != null) {
                return typeFromMimeType;
            }
        }
    }
    for (var i = 0; i < representationCodecs.length; i++) {
        var codecs = representationCodecs[i];
        if (codecs != null) {
            var typeFromMimeType = fromCodecs(codecs);
            if (typeFromMimeType != null) {
                return typeFromMimeType;
            }
        }
    }
    return "unknown";
}
/**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 *
 * This is done to calculate a liveGap which is valid for the whole manifest,
 * even in weird ones.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
var getLastLiveTimeReference = function (adaptation) {
    // Here's how we do, for each possibility:
    //  1. only the adaptation has an index (no representation has):
    //    - returns the index last time reference
    //
    //  2. every representations have an index:
    //    - returns minimum for every representations
    //
    //  3. not all representations have an index but the adaptation has
    //    - returns minimum between all representations and the adaptation
    //
    //  4. no index for 1+ representation(s) and no adaptation index:
    //    - returns undefined
    //
    //  5. Invalid index found somewhere:
    //    - returns undefined
    if (!adaptation) {
        return undefined;
    }
    var representations = adaptation.representations || [];
    var lastLiveTimeReferences = representations
        .map(function (representation) {
        var lastPosition = representation.index.getLastPosition();
        return lastPosition != null ? lastPosition - 10 : undefined; // TODO
    });
    if (lastLiveTimeReferences.some(function (x) { return x == null; })) {
        return undefined;
    }
    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);
    if (isNaN(representationsMin)) {
        return undefined;
    }
    return representationsMin;
};
function parseManifest(root, uri
// contentProtectionParser?: IContentProtectionParser
) {
    // Transform whole MPD into a parsed JS object representation
    var _a = MPD_1.createMPDIntermediateRepresentation(root), rootChildren = _a.children, rootAttributes = _a.attributes;
    var mpdRootURL = url_1.resolveURL(url_1.normalizeBaseURL(uri), rootChildren.baseURL);
    var parsedPeriods = [];
    var _loop_1 = function (i) {
        var period = rootChildren.periods[i];
        // 1. Construct partial URL for contents
        var periodRootURL = url_1.resolveURL(mpdRootURL, period.children.baseURL);
        // 2. Generate ID
        var periodID = void 0;
        if (period.attributes.id == null) {
            log_1.default.warn("DASH: No usable id found in the Period. Generating one.");
            periodID = "gen-dash-period-" + id_1.default();
        }
        else {
            periodID = period.attributes.id;
        }
        // 3. Find the start of the Period (required)
        var periodStart;
        if (period.attributes.start != null) {
            periodStart = period.attributes.start;
        }
        else {
            if (i === 0) {
                periodStart = (rootAttributes.type === "static" ||
                    rootAttributes.availabilityStartTime == null) ? 0 : rootAttributes.availabilityStartTime;
            }
            else {
                var prevPeriod = parsedPeriods[i - 1];
                if (prevPeriod.duration != null) {
                    periodStart = prevPeriod.start + prevPeriod.duration;
                }
                else {
                    throw new Error("Not enough informations on the periods: cannot find start.");
                }
            }
        }
        var periodDuration = void 0;
        if (period.attributes.duration != null) {
            periodDuration = period.attributes.duration;
        }
        else {
            var nextPeriod = parsedPeriods[i + 1];
            if (nextPeriod && nextPeriod.start != null) {
                periodDuration = nextPeriod.start - periodStart;
            }
            else if (i === 0 &&
                rootAttributes.duration &&
                !nextPeriod) {
                periodDuration = rootAttributes.duration;
            }
        }
        // 4. Construct underlying adaptations
        var adaptations = period.children.adaptations.map(function (adaptation) {
            var adaptationRootURL = url_1.resolveURL(periodRootURL, adaptation.children.baseURL);
            var adaptationChildren = adaptation.children;
            // 4-1. Find Index
            var adaptationIndex;
            if (adaptationChildren.segmentBase != null) {
                adaptationIndex = new base_1.default(adaptationChildren.segmentBase, periodStart);
            }
            else if (adaptationChildren.segmentList != null) {
                adaptationIndex = new list_1.default(adaptationChildren.segmentList, periodStart);
            }
            else if (adaptationChildren.segmentTemplate != null) {
                var template = adaptationChildren.segmentTemplate;
                template.presentationTimeOffset = periodStart * template.timescale;
                adaptationIndex = template.indexType === "timeline" ?
                    // TODO Find a way with the optional 'd'
                    new timeline_1.default(template, periodStart) :
                    new template_1.default(template, periodStart);
            }
            else {
                adaptationIndex = new template_1.default({
                    duration: Number.MAX_VALUE,
                    timescale: 1,
                    startNumber: 0,
                }, periodStart);
            }
            // 4-2. Construct Representations
            var representations = adaptation.children
                .representations.map(function (representation) {
                var representationURL = url_1.resolveURL(adaptationRootURL, representation.children.baseURL);
                // 4-2-1. Find bitrate
                var representationBitrate;
                if (representation.attributes.bitrate == null) {
                    log_1.default.warn("DASH: No usable bitrate found in the Representation.");
                    representationBitrate = 0;
                }
                else {
                    representationBitrate = representation.attributes.bitrate;
                }
                // 4-2-2. Find Index
                var representationIndex;
                if (representation.children.segmentBase != null) {
                    representationIndex = new base_1.default(representation.children.segmentBase, periodStart);
                }
                else if (representation.children.segmentList != null) {
                    representationIndex = new list_1.default(representation.children.segmentList, periodStart);
                }
                else if (representation.children.segmentTemplate != null) {
                    var template = representation.children.segmentTemplate;
                    representationIndex = template.indexType === "timeline" ?
                        // TODO Find a way with the optional 'd'
                        new timeline_1.default(template, periodStart) :
                        new template_1.default(template, periodStart);
                }
                else {
                    representationIndex = adaptationIndex;
                }
                // 4-2-3. Set ID
                var representationID = representation.attributes.id != null ?
                    representation.attributes.id :
                    (representation.attributes.bitrate +
                        (representation.attributes.height != null ?
                            ("-" + representation.attributes.height) : "") +
                        (representation.attributes.width != null ?
                            ("-" + representation.attributes.width) : "") +
                        (representation.attributes.mimeType != null ?
                            ("-" + representation.attributes.mimeType) : "") +
                        (representation.attributes.codecs != null ?
                            ("-" + representation.attributes.codecs) : ""));
                // 4-2-4. Construct Representation Base
                var parsedRepresentation = {
                    bitrate: representationBitrate,
                    index: representationIndex,
                    id: representationID,
                    baseURL: representationURL,
                };
                // 4-2-5. Add optional attributes
                var codecs;
                if (representation.attributes.codecs != null) {
                    codecs = representation.attributes.codecs;
                }
                else if (adaptation.attributes.codecs != null) {
                    codecs = adaptation.attributes.codecs;
                }
                if (codecs != null) {
                    codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
                    parsedRepresentation.codecs = codecs;
                }
                if (representation.attributes.audioSamplingRate != null) {
                    parsedRepresentation.audioSamplingRate =
                        representation.attributes.audioSamplingRate;
                }
                else if (adaptation.attributes.audioSamplingRate != null) {
                    parsedRepresentation.audioSamplingRate =
                        adaptation.attributes.audioSamplingRate;
                }
                if (representation.attributes.codingDependency != null) {
                    parsedRepresentation.codingDependency =
                        representation.attributes.codingDependency;
                }
                else if (adaptation.attributes.codingDependency != null) {
                    parsedRepresentation.codingDependency =
                        adaptation.attributes.codingDependency;
                }
                if (representation.attributes.frameRate != null) {
                    parsedRepresentation.frameRate =
                        representation.attributes.frameRate;
                }
                else if (adaptation.attributes.frameRate != null) {
                    parsedRepresentation.frameRate =
                        adaptation.attributes.frameRate;
                }
                if (representation.attributes.height != null) {
                    parsedRepresentation.height =
                        representation.attributes.height;
                }
                else if (adaptation.attributes.height != null) {
                    parsedRepresentation.height =
                        adaptation.attributes.height;
                }
                if (representation.attributes.maxPlayoutRate != null) {
                    parsedRepresentation.maxPlayoutRate =
                        representation.attributes.maxPlayoutRate;
                }
                else if (adaptation.attributes.maxPlayoutRate != null) {
                    parsedRepresentation.maxPlayoutRate =
                        adaptation.attributes.maxPlayoutRate;
                }
                if (representation.attributes.maximumSAPPeriod != null) {
                    parsedRepresentation.maximumSAPPeriod =
                        representation.attributes.maximumSAPPeriod;
                }
                else if (adaptation.attributes.maximumSAPPeriod != null) {
                    parsedRepresentation.maximumSAPPeriod =
                        adaptation.attributes.maximumSAPPeriod;
                }
                if (representation.attributes.mimeType != null) {
                    parsedRepresentation.mimeType =
                        representation.attributes.mimeType;
                }
                else if (adaptation.attributes.mimeType != null) {
                    parsedRepresentation.mimeType =
                        adaptation.attributes.mimeType;
                }
                if (representation.attributes.profiles != null) {
                    parsedRepresentation.profiles =
                        representation.attributes.profiles;
                }
                else if (adaptation.attributes.profiles != null) {
                    parsedRepresentation.profiles =
                        adaptation.attributes.profiles;
                }
                if (representation.attributes.qualityRanking != null) {
                    parsedRepresentation.qualityRanking =
                        representation.attributes.qualityRanking;
                }
                if (representation.attributes.segmentProfiles != null) {
                    parsedRepresentation.segmentProfiles =
                        representation.attributes.segmentProfiles;
                }
                else if (adaptation.attributes.segmentProfiles != null) {
                    parsedRepresentation.segmentProfiles =
                        adaptation.attributes.segmentProfiles;
                }
                if (representation.attributes.width != null) {
                    parsedRepresentation.width =
                        representation.attributes.width;
                }
                else if (adaptation.attributes.width != null) {
                    parsedRepresentation.width =
                        adaptation.attributes.width;
                }
                return parsedRepresentation;
            });
            var adaptationMimeType = adaptation.attributes.mimeType;
            var adaptationCodecs = adaptation.attributes.codecs;
            var representationMimeTypes = representations
                .map(function (r) { return r.mimeType; })
                .filter(function (mimeType) { return mimeType != null; });
            var representationCodecs = representations
                .map(function (r) { return r.codecs; })
                .filter(function (codecs) { return codecs != null; });
            var type = inferAdaptationType(adaptationMimeType || null, representationMimeTypes, adaptationCodecs || null, representationCodecs, adaptationChildren.role || null);
            var closedCaption;
            var audioDescription;
            if (type === "text" &&
                adaptationChildren.accessibility &&
                helpers_1.isHardOfHearing(adaptationChildren.accessibility)) {
                closedCaption = true;
            }
            if (type === "audio" &&
                adaptationChildren.accessibility &&
                helpers_1.isVisuallyImpaired(adaptationChildren.accessibility)) {
                audioDescription = true;
            }
            var adaptationID;
            if (adaptation.attributes.id != null) {
                adaptationID = adaptation.attributes.id;
            }
            else {
                var idString = type;
                if (adaptation.attributes.language) {
                    idString += "-" + adaptation.attributes.language;
                }
                if (closedCaption) {
                    idString += "-cc";
                }
                if (audioDescription) {
                    idString += "-ad";
                }
                if (adaptation.attributes.contentType) {
                    idString += "-" + adaptation.attributes.contentType;
                }
                if (adaptation.attributes.codecs) {
                    idString += "-" + adaptation.attributes.codecs;
                }
                if (adaptation.attributes.mimeType) {
                    idString += "-" + adaptation.attributes.mimeType;
                }
                if (adaptation.attributes.frameRate) {
                    idString += "-" + adaptation.attributes.frameRate;
                }
                if (idString.length === type.length) {
                    idString += representations.length ?
                        ("-" + representations[0].id) : "-empty";
                }
                adaptationID = "adaptation-" + idString;
            }
            var parsedAdaptationSet = {
                id: adaptationID,
                representations: representations,
                type: type,
            };
            if (adaptation.attributes.language != null) {
                parsedAdaptationSet.language = adaptation.attributes.language;
                parsedAdaptationSet.normalizedLanguage =
                    languages_1.normalize(adaptation.attributes.language);
            }
            if (closedCaption != null) {
                parsedAdaptationSet.closedCaption = closedCaption;
            }
            if (audioDescription != null) {
                parsedAdaptationSet.audioDescription = audioDescription;
            }
            return parsedAdaptationSet;
        });
        var parsedPeriod = {
            id: periodID,
            start: periodStart,
            duration: periodDuration,
            adaptations: adaptations,
        };
        if (period.attributes.bitstreamSwitching != null) {
            parsedPeriod.bitstreamSwitching = period.attributes.bitstreamSwitching;
        }
        parsedPeriods.push(parsedPeriod);
    };
    for (var i = 0; i < rootChildren.periods.length; i++) {
        _loop_1(i);
    }
    var parsedMPD = {
        availabilityStartTime: (rootAttributes.type === "static" ||
            rootAttributes.availabilityStartTime == null) ? 0 : rootAttributes.availabilityStartTime,
        duration: rootAttributes.duration == null ? Infinity : rootAttributes.duration,
        id: rootAttributes.id != null ?
            rootAttributes.id : "gen-dash-manifest-" + id_1.default(),
        periods: parsedPeriods,
        transportType: "dash",
        type: rootAttributes.type || "static",
        uris: [uri].concat(rootChildren.locations),
        suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay != null ?
            rootAttributes.suggestedPresentationDelay :
            config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH,
    };
    // -- add optional fields --
    if (rootAttributes.profiles != null) {
        parsedMPD.profiles = rootAttributes.profiles;
    }
    if (rootAttributes.type !== "static" && rootAttributes.availabilityEndTime != null) {
        parsedMPD.availabilityEndTime = rootAttributes.availabilityEndTime;
    }
    if (rootAttributes.publishTime != null) {
        parsedMPD.publishTime = rootAttributes.publishTime;
    }
    if (rootAttributes.duration != null) {
        parsedMPD.duration = rootAttributes.duration;
    }
    if (rootAttributes.minimumUpdatePeriod != null) {
        parsedMPD.minimumUpdatePeriod = rootAttributes.minimumUpdatePeriod;
    }
    if (rootAttributes.minBufferTime != null) {
        parsedMPD.minBufferTime = rootAttributes.minBufferTime;
    }
    if (rootAttributes.timeShiftBufferDepth != null) {
        parsedMPD.timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
    }
    if (rootAttributes.maxSegmentDuration != null) {
        parsedMPD.maxSegmentDuration = rootAttributes.maxSegmentDuration;
    }
    if (rootAttributes.maxSubsegmentDuration != null) {
        parsedMPD.maxSubsegmentDuration = rootAttributes.maxSubsegmentDuration;
    }
    if (parsedMPD.type === "dynamic") {
        var lastPeriodAdaptations = parsedMPD.periods[parsedMPD.periods.length - 1].adaptations;
        var firstVideoAdaptationFromLastPeriod = lastPeriodAdaptations
            .filter(function (a) { return a.type === "video"; })[0];
        var lastRef = getLastLiveTimeReference(firstVideoAdaptationFromLastPeriod);
        parsedMPD.presentationLiveGap = lastRef != null ?
            Date.now() / 1000 - (lastRef + parsedMPD.availabilityStartTime) : 10;
    }
    return parsedMPD;
}
exports.default = parseManifest;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var node_parsers_1 = __webpack_require__(219);
/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parseFromDocument(document, uri /*,*/
// contentProtectionParser?: IContentProtectionParser
) {
    var root = document.documentElement;
    if (!root || root.nodeName !== "MPD") {
        throw new Error("document root should be MPD");
    }
    return node_parsers_1.default(root, uri /*, contentProtectionParser*/);
}
exports.default = parseFromDocument;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var isobmff_1 = __webpack_require__(30);
var bif_1 = __webpack_require__(93);
var request_1 = __webpack_require__(23);
var url_1 = __webpack_require__(20);
var manifest_loader_1 = __webpack_require__(91);
var isobmff_timing_infos_1 = __webpack_require__(89);
var manifest_1 = __webpack_require__(220);
var segment_loader_1 = __webpack_require__(204);
var texttracks_1 = __webpack_require__(203);
var utils_1 = __webpack_require__(51);
/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @param {Function} [options.contentProtectionParser] - Optional parser for the
 * manifest's content Protection.
 * @returns {Object}
 */
function default_1(options) {
    if (options === void 0) { options = {}; }
    var manifestLoader = manifest_loader_1.default({
        customManifestLoader: options.manifestLoader,
    });
    var segmentLoader = segment_loader_1.default(options.segmentLoader);
    // const { contentProtectionParser } = options;
    var manifestPipeline = {
        loader: function (_a) {
            var url = _a.url;
            return manifestLoader(url);
        },
        parser: function (_a) {
            var response = _a.response, reqURL = _a.url;
            var url = response.url == null ? reqURL : response.url;
            var data = typeof response.responseData === "string" ?
                new DOMParser().parseFromString(response.responseData, "text/xml") :
                response.responseData;
            return Observable_1.Observable.of({
                manifest: manifest_1.default(data, url),
                url: url,
            });
        },
    };
    var segmentPipeline = {
        loader: function (_a) {
            var adaptation = _a.adaptation, init = _a.init, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;
            return segmentLoader({
                adaptation: adaptation,
                init: init,
                manifest: manifest,
                period: period,
                representation: representation,
                segment: segment,
            });
        },
        parser: function (_a) {
            var segment = _a.segment, representation = _a.representation, response = _a.response, init = _a.init;
            var segmentData = response.responseData instanceof Uint8Array ?
                response.responseData :
                new Uint8Array(response.responseData);
            var indexRange = segment.indexRange;
            var sidxSegments = isobmff_1.parseSidx(segmentData, indexRange ? indexRange[0] : 0);
            if (!segment.isInit) {
                return Observable_1.Observable.of({
                    segmentData: segmentData,
                    segmentInfos: isobmff_timing_infos_1.default(segment, segmentData, sidxSegments, init),
                });
            }
            if (sidxSegments) {
                var nextSegments = sidxSegments;
                utils_1.addNextSegments(representation, nextSegments);
            }
            var timescale = isobmff_1.getMDHDTimescale(segmentData);
            return Observable_1.Observable.of({
                segmentData: segmentData,
                segmentInfos: timescale > 0 ? { time: -1, duration: 0, timescale: timescale } : null,
            });
        },
    };
    var textTrackPipeline = {
        loader: texttracks_1.loader,
        parser: texttracks_1.parser,
    };
    var imageTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            if (segment.isInit) {
                // image do not need an init segment. Passthrough directly to the parser
                return Observable_1.Observable.of({
                    type: "data",
                    value: { responseData: null },
                });
            }
            var media = segment.media;
            var path = media ? utils_1.replaceTokens(media, segment, representation) : "";
            var url = url_1.resolveURL(representation.baseURL, path);
            return request_1.default({ url: url, responseType: "arraybuffer" });
        },
        parser: function (_a) {
            var response = _a.response, segment = _a.segment;
            var responseData = response.responseData;
            if (responseData === null) {
                return Observable_1.Observable.of({
                    segmentData: null,
                    segmentInfos: segment.timescale > 0 ? {
                        duration: segment.isInit ? 0 : segment.duration,
                        time: segment.isInit ? -1 : segment.time,
                        timescale: segment.timescale,
                    } : null,
                });
            }
            var bifObject = bif_1.default(new Uint8Array(responseData));
            var data = bifObject.thumbs;
            return Observable_1.Observable.of({
                segmentData: {
                    data: data,
                    start: 0,
                    end: Number.MAX_VALUE,
                    timescale: 1,
                    timeOffset: 0,
                    type: "bif",
                },
                segmentInfos: {
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: bifObject.timescale,
                },
            });
        },
    };
    return {
        manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline,
    };
}
exports.default = default_1;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(4);
var request_1 = __webpack_require__(23);
var url_1 = __webpack_require__(20);
var mp4_1 = __webpack_require__(52);
var utils_1 = __webpack_require__(90);
var createVideoInitSegment = mp4_1.default.createVideoInitSegment, createAudioInitSegment = mp4_1.default.createAudioInitSegment;
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @param {string} opt.url
 * @param {Segment} opt.segment
 * @returns {Observable}
 */
function regularSegmentLoader(_a) {
    var url = _a.url, segment = _a.segment;
    var headers;
    var range = segment.range;
    if (range) {
        headers = {
            Range: utils_1.byteRange(range),
        };
    }
    return request_1.default({
        url: url,
        responseType: "arraybuffer",
        headers: headers,
    });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */
var generateSegmentLoader = function (customSegmentLoader) { return function (_a) {
    var segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, period = _a.period, manifest = _a.manifest, init = _a.init;
    if (segment.isInit) {
        if (!segment.privateInfos || segment.privateInfos.type !== "smooth-init") {
            throw new Error("Smooth: Invalid segment format");
        }
        var responseData = void 0;
        var privateInfos = segment.privateInfos;
        var protection = privateInfos.protection;
        switch (adaptation.type) {
            case "video":
                responseData = createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                privateInfos.codecPrivateData, protection && protection.keyId, // keyId
                protection && protection.keySystems // pssList
                );
                break;
            case "audio":
                responseData = createAudioInitSegment(segment.timescale, privateInfos.channels || 0, privateInfos.bitsPerSample || 0, privateInfos.packetSize || 0, privateInfos.samplingRate || 0, privateInfos.codecPrivateData, protection && protection.keyId, // keyId
                protection && protection.keySystems // pssList
                );
                break;
            default:
                if (false) {}
                responseData = new Uint8Array(0);
        }
        return Observable_1.Observable.of({
            type: "data",
            value: { responseData: responseData },
        });
    }
    else {
        var url = utils_1.buildSegmentURL(url_1.resolveURL(representation.baseURL), representation, segment);
        var args_1 = {
            adaptation: adaptation,
            init: init,
            manifest: manifest,
            period: period,
            representation: representation,
            segment: segment,
            transport: "smooth",
            url: url,
        };
        if (!customSegmentLoader) {
            return regularSegmentLoader(args_1);
        }
        return Observable_1.Observable.create(function (obs) {
            var hasFinished = false;
            var hasFallbacked = false;
            var resolve = function (_args) {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.next({
                        type: "response",
                        value: {
                            responseData: _args.data,
                            size: _args.size,
                            duration: _args.duration,
                        },
                    });
                    obs.complete();
                }
            };
            var reject = function (err) {
                if (err === void 0) { err = {}; }
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.error(err);
                }
            };
            var fallback = function () {
                hasFallbacked = true;
                regularSegmentLoader(args_1).subscribe(obs);
            };
            var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
            var abort = customSegmentLoader(args_1, callbacks);
            return function () {
                if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                    abort();
                }
            };
        });
    }
}; };
exports.default = generateSegmentLoader;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Number} newSegment.timescale
 * @param {Number} newSegment.time
 * @param {Number} newSegment.duration
 * @param {Object} currentSegment
 * @param {Number} currentSegment.timescale
 * @param {Number} currentSegment.time
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, newSegment, currentSegment) {
    var timeline = index.timeline, timescale = index.timescale;
    var timelineLength = timeline.length;
    var last = timeline[timelineLength - 1];
    var scaledNewSegment = newSegment.timescale === timescale ? {
        time: newSegment.time,
        duration: newSegment.duration,
    } : {
        time: (newSegment.time / newSegment.timescale) * timescale,
        duration: (newSegment.duration / newSegment.timescale) * timescale,
    };
    var scaledCurrentTime;
    if (currentSegment && currentSegment.timescale) {
        scaledCurrentTime = currentSegment.timescale === timescale ?
            currentSegment.time :
            (currentSegment.time / currentSegment.timescale) * timescale;
    }
    // in some circumstances, the new segment informations are only
    // duration informations that we can use to deduct the ts of the
    // next segment. this is the case where the new segment are
    // associated to a current segment and have the same ts
    var shouldDeductNextSegment = scaledCurrentTime != null &&
        (scaledNewSegment.time === scaledCurrentTime);
    if (shouldDeductNextSegment) {
        var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;
        var lastSegmentTs = (last.ts + (last.d || 0) * last.r);
        var tsDiff = newSegmentTs - lastSegmentTs;
        if (tsDiff <= 0) { // same segment / behind the last
            return false;
        }
        // try to use the compact notation with @r attribute on the last
        // to elements of the timeline if we find out they have the same
        // duration
        if (last.d === -1) {
            var prev = timeline[timelineLength - 2];
            if (prev && prev.d === tsDiff) {
                prev.r++;
                timeline.pop();
            }
            else {
                last.d = tsDiff;
            }
        }
        index.timeline.push({
            d: -1,
            ts: newSegmentTs,
            r: 0,
        });
        return true;
    }
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    else if (scaledNewSegment.time >= getTimelineRangeEnd(last)) {
        if (last.d === scaledNewSegment.duration) {
            last.r++;
        }
        else {
            index.timeline.push({
                d: scaledNewSegment.duration,
                ts: scaledNewSegment.time,
                r: 0,
            });
        }
        return true;
    }
    return false;
}
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */
function getSegmentIndex(index, ts) {
    var timeline = index.timeline;
    var low = 0;
    var high = timeline.length;
    while (low < high) {
        var mid = (low + high) >>> 1;
        if (timeline[mid].ts < ts) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return (low > 0)
        ? low - 1
        : low;
}
/**
 * @param {Number} ts
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
function getSegmentNumber(ts, up, duration) {
    if (!duration) {
        return 0;
    }
    var diff = up - ts;
    if (diff > 0) {
        return Math.floor(diff / duration);
    }
    else {
        return 0;
    }
}
/**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute end time of the range
 */
function getTimelineRangeEnd(_a) {
    var ts = _a.ts, d = _a.d, r = _a.r;
    return (d == null || d === -1) ? ts : ts + (r + 1) * d;
}
// interface ISmoothIndex {
//   presentationTimeOffset? : number;
//   timescale : number;
//   media? : string;
//   timeline : IIndexSegment[];
//   startNumber? : number;
// }
/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function normalizeRange(index, // TODO
ts, duration) {
    var pto = index.presentationTimeOffset || 0;
    var timescale = index.timescale || 1;
    return {
        up: (ts) * timescale - pto,
        to: (ts + duration) * timescale - pto,
    };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Number} segment.ts - beginning timescaled timestamp
 * @param {Number} segment.d - timescaled duration of the segment
 * @param {Object} nextSegment
 * @param {Number} nextSegment.ts
 * @returns {Number}
 */
function calculateRepeat(segment, nextSegment) {
    var repeatCount = segment.r || 0;
    // A negative value of the @r attribute of the S element indicates
    // that the duration indicated in @d attribute repeats until the
    // start of the next S element, the end of the Period or until the
    // next MPD update.
    // TODO Also for SMOOTH????
    if (segment.d != null && repeatCount < 0) {
        var repeatEnd = nextSegment ? nextSegment.ts : Infinity;
        repeatCount = Math.ceil((repeatEnd - segment.ts) / segment.d) - 1;
    }
    return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */
var SmoothRepresentationIndex = /** @class */ (function () {
    // private _index : {
    //   timeline : IHSSManifestSegment[];
    //   timescale : number;
    // }; // TODO
    function SmoothRepresentationIndex(index, infos) {
        this._index = index;
        this._bitsPerSample = infos.bitsPerSample;
        this._channels = infos.channels;
        this._codecPrivateData = infos.codecPrivateData;
        this._packetSize = infos.packetSize;
        this._samplingRate = infos.samplingRate;
        this._protection = infos.protection;
    }
    /**
     * Construct init Segment compatible with a Smooth Manifest.
     * @returns {Object}
     */
    SmoothRepresentationIndex.prototype.getInitSegment = function () {
        var index = this._index;
        return {
            id: "init",
            isInit: true,
            time: 0,
            timescale: index.timescale,
            privateInfos: {
                type: "smooth-init",
                bitsPerSample: this._bitsPerSample,
                channels: this._channels,
                codecPrivateData: this._codecPrivateData,
                packetSize: this._packetSize,
                samplingRate: this._samplingRate,
                protection: this._protection,
            },
        };
    };
    /**
     * Generate a list of Segments for a particular period of time.
     *
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    SmoothRepresentationIndex.prototype.getSegments = function (_up, _to) {
        var index = this._index;
        var _a = normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        var timeline = index.timeline, timescale = index.timescale;
        var currentNumber;
        var segments = [];
        var timelineLength = timeline.length;
        // TODO(pierre): use @maxSegmentDuration if possible
        var maxEncounteredDuration = (timeline.length && timeline[0].d) || 0;
        for (var i = 0; i < timelineLength; i++) {
            var segmentRange = timeline[i];
            var d = segmentRange.d, ts = segmentRange.ts;
            maxEncounteredDuration = Math.max(maxEncounteredDuration, d || 0);
            // live-added segments have @d attribute equals to -1
            if (d != null && d < 0) {
                // TODO what? May be to play it safe and avoid adding segments which are
                // not completely generated
                if (ts + maxEncounteredDuration < to) {
                    var segment = {
                        id: "" + ts,
                        time: ts,
                        isInit: false,
                        timescale: timescale,
                        number: currentNumber != null ? currentNumber : undefined,
                    };
                    segments.push(segment);
                }
                return segments;
            }
            var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
            var segmentNumberInCurrentRange = getSegmentNumber(ts, up, d);
            var segmentTime = ts + segmentNumberInCurrentRange * (d == null ? 0 : d);
            while (segmentTime < to && segmentNumberInCurrentRange <= repeat) {
                var segment = {
                    id: "" + segmentTime,
                    time: segmentTime,
                    isInit: false,
                    duration: d,
                    timescale: timescale,
                    number: currentNumber != null ?
                        currentNumber + segmentNumberInCurrentRange : undefined,
                };
                segments.push(segment);
                // update segment number and segment time for the next segment
                segmentNumberInCurrentRange++;
                segmentTime = ts + segmentNumberInCurrentRange * d;
            }
            if (segmentTime >= to) {
                // we reached ``to``, we're done
                return segments;
            }
            if (currentNumber != null) {
                currentNumber += repeat + 1;
            }
        }
        return segments;
    };
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} from
     * @param {Number} to
     * @returns {Boolean}
     */
    SmoothRepresentationIndex.prototype.shouldRefresh = function (up, to) {
        var _a = this._index, timeline = _a.timeline, timescale = _a.timescale;
        var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
        if (!lastSegmentInCurrentTimeline) {
            return false;
        }
        var repeat = lastSegmentInCurrentTimeline.r || 0;
        var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.ts + (repeat + 1) * lastSegmentInCurrentTimeline.d;
        if (to * timescale < endOfLastSegmentInCurrentTimeline) {
            return false;
        }
        if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
            return true;
        }
        // ----
        var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.ts + repeat * lastSegmentInCurrentTimeline.d;
        return up > startOfLastSegmentInCurrentTimeline;
    };
    /**
     * Returns first position in the index.
     *
     * @param {Object} index
     * @returns {Number}
     */
    SmoothRepresentationIndex.prototype.getFirstPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        return index.timeline[0].ts / index.timescale;
    };
    /**
     * Returns last position in the index.
     * @param {Object} index
     * @returns {Number}
     */
    SmoothRepresentationIndex.prototype.getLastPosition = function () {
        var index = this._index;
        if (!index.timeline.length) {
            return undefined;
        }
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return (getTimelineRangeEnd(lastTimelineElement) / index.timescale);
    };
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     *
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting ts
     * for the next (discontinuited) range. If not this is equal to -1.
     */
    SmoothRepresentationIndex.prototype.checkDiscontinuity = function (_time) {
        var index = this._index;
        var timeline = index.timeline, _a = index.timescale, timescale = _a === void 0 ? 1 : _a;
        var time = _time * timescale;
        if (time <= 0) {
            return -1;
        }
        var segmentIndex = getSegmentIndex(index, time);
        if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
            return -1;
        }
        var range = timeline[segmentIndex];
        if (range.d === -1) {
            return -1;
        }
        var rangeUp = range.ts;
        var rangeTo = getTimelineRangeEnd(range);
        var nextRange = timeline[segmentIndex + 1];
        // when we are actually inside the found range and this range has
        // an explicit discontinuity with the next one
        if (rangeTo !== nextRange.ts &&
            time >= rangeUp &&
            time <= rangeTo &&
            (rangeTo - time) < timescale) {
            return nextRange.ts / timescale;
        }
        return -1;
    };
    SmoothRepresentationIndex.prototype._update = function (newIndex) {
        this._index = newIndex._index;
    };
    SmoothRepresentationIndex.prototype._addSegments = function (nextSegments, currentSegment) {
        for (var i = 0; i < nextSegments.length; i++) {
            _addSegmentInfos(this._index, nextSegments[i], currentSegment);
        }
    };
    return SmoothRepresentationIndex;
}());
exports.default = SmoothRepresentationIndex;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
var ISO_MAP_2_TO_3 = {
    alb: "sqi",
    arm: "hye",
    baq: "eus",
    bur: "mya",
    chi: "zho",
    cze: "ces",
    dut: "nld",
    fre: "fra",
    geo: "kat",
    ger: "deu",
    gre: "ell",
    ice: "isl",
    mac: "mkd",
    mao: "mri",
    may: "msa",
    per: "fas",
    slo: "slk",
    rum: "ron",
    tib: "bod",
    wel: "cym",
};
exports.default = ISO_MAP_2_TO_3;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
var ISO_MAP_1_TO_3 = {
    aa: "aar",
    ab: "abk",
    ae: "ave",
    af: "afr",
    ak: "aka",
    am: "amh",
    an: "arg",
    ar: "ara",
    as: "asm",
    av: "ava",
    ay: "aym",
    az: "aze",
    ba: "bak",
    be: "bel",
    bg: "bul",
    bi: "bis",
    bm: "bam",
    bn: "ben",
    bo: "bod",
    br: "bre",
    bs: "bos",
    ca: "cat",
    ce: "che",
    ch: "cha",
    co: "cos",
    cr: "cre",
    cs: "ces",
    cu: "chu",
    // Old Slavonic, Old Bulgarian
    cv: "chv",
    cy: "cym",
    da: "dan",
    de: "deu",
    dv: "div",
    dz: "dzo",
    ee: "ewe",
    el: "ell",
    en: "eng",
    eo: "epo",
    es: "spa",
    et: "est",
    eu: "eus",
    fa: "fas",
    ff: "ful",
    fi: "fin",
    fj: "fij",
    fo: "fao",
    fr: "fra",
    fy: "fry",
    ga: "gle",
    gd: "gla",
    gl: "glg",
    gn: "grn",
    gu: "guj",
    gv: "glv",
    ha: "hau",
    he: "heb",
    hi: "hin",
    ho: "hmo",
    hr: "hrv",
    ht: "hat",
    hu: "hun",
    hy: "hye",
    hz: "her",
    ia: "ina",
    id: "ind",
    ie: "ile",
    ig: "ibo",
    ii: "iii",
    ik: "ipk",
    io: "ido",
    is: "isl",
    it: "ita",
    iu: "iku",
    ja: "jpn",
    jv: "jav",
    ka: "kat",
    kg: "kon",
    ki: "kik",
    kj: "kua",
    kk: "kaz",
    kl: "kal",
    km: "khm",
    kn: "kan",
    ko: "kor",
    kr: "kau",
    ks: "kas",
    ku: "kur",
    kv: "kom",
    kw: "cor",
    ky: "kir",
    la: "lat",
    lb: "ltz",
    lg: "lug",
    li: "lim",
    ln: "lin",
    lo: "lao",
    lt: "lit",
    lu: "lub",
    lv: "lav",
    mg: "mlg",
    mh: "mah",
    mi: "mri",
    mk: "mkd",
    ml: "mal",
    mn: "mon",
    mr: "mar",
    ms: "msa",
    mt: "mlt",
    my: "mya",
    na: "nau",
    nb: "nob",
    nd: "nde",
    ne: "nep",
    ng: "ndo",
    nl: "nld",
    nn: "nno",
    no: "nor",
    nr: "nbl",
    nv: "nav",
    ny: "nya",
    oc: "oci",
    oj: "oji",
    om: "orm",
    or: "ori",
    os: "oss",
    pa: "pan",
    pi: "pli",
    pl: "pol",
    ps: "pus",
    pt: "por",
    qu: "que",
    rm: "roh",
    rn: "run",
    ro: "ron",
    ru: "rus",
    rw: "kin",
    sa: "san",
    sc: "srd",
    sd: "snd",
    se: "sme",
    sg: "sag",
    si: "sin",
    sk: "slk",
    sl: "slv",
    sm: "smo",
    sn: "sna",
    so: "som",
    sq: "sqi",
    sr: "srp",
    ss: "ssw",
    st: "sot",
    su: "sun",
    sv: "swe",
    sw: "swa",
    ta: "tam",
    te: "tel",
    tg: "tgk",
    th: "tha",
    ti: "tir",
    tk: "tuk",
    tl: "tgl",
    tn: "tsn",
    to: "ton",
    tr: "tur",
    ts: "tso",
    tt: "tat",
    tw: "twi",
    ty: "tah",
    ug: "uig",
    uk: "ukr",
    ur: "urd",
    uz: "uzb",
    ve: "ven",
    vi: "vie",
    vo: "vol",
    wa: "wln",
    wo: "wol",
    xh: "xho",
    yi: "yid",
    yo: "yor",
    za: "zha",
    zh: "zho",
    zu: "zul",
};
exports.default = ISO_MAP_1_TO_3;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(2);
var array_includes_1 = __webpack_require__(13);
var assert_1 = __webpack_require__(4);
var bytes_1 = __webpack_require__(21);
var id_1 = __webpack_require__(19);
var languages_1 = __webpack_require__(29);
var log_1 = __webpack_require__(1);
var url_1 = __webpack_require__(20);
var representationIndex_1 = __webpack_require__(223);
var DEFAULT_MIME_TYPES = {
    audio: "audio/mp4",
    video: "video/mp4",
    text: "application/ttml+xml",
};
var DEFAULT_CODECS = {
    audio: "mp4a.40.2",
    video: "avc1.4D401E",
};
var MIME_TYPES = {
    AACL: "audio/mp4",
    AVC1: "video/mp4",
    H264: "video/mp4",
    TTML: "application/ttml+xml+mp4",
};
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */
function extractVideoCodecs(codecPrivateData) {
    // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
    var _a = /00000001\d7([0-9a-fA-F]{6})/
        .exec(codecPrivateData) || [], _b = _a[1], avcProfile = _b === void 0 ? "" : _b;
    return avcProfile && "avc1." + avcProfile;
}
/**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */
function extractAudioCodecs(fourCC, codecPrivateData) {
    var mpProfile;
    if (fourCC === "AACH") {
        mpProfile = 5; // High Efficiency AAC Profile
    }
    else {
        mpProfile = codecPrivateData ?
            (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3 : 2;
    }
    return mpProfile ? ("mp4a.40." + mpProfile) : "";
}
/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
    if (typeof val === "boolean") {
        return val;
    }
    else if (typeof val === "string") {
        return val.toUpperCase() === "TRUE";
    }
    else {
        return false;
    }
}
/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */
function getKeySystems(keyIdBytes) {
    return [
        {
            // Widevine
            systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
            privateData: bytes_1.concat([0x08, 0x01, 0x12, 0x10], keyIdBytes),
        },
    ];
}
/**
 * @param {Object} [parserOptions={}]
 */
function createSmoothStreamingParser(parserOptions) {
    if (parserOptions === void 0) { parserOptions = {}; }
    var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay == null ?
        config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH :
        parserOptions.suggestedPresentationDelay;
    var REFERENCE_DATE_TIME = parserOptions.referenceDateTime ||
        Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000;
    var MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate ||
        190000;
    var keySystems = parserOptions.keySystems || getKeySystems;
    /**
     * @param {Uint8Array} buf
     * @returns {string}
     */
    function getHexKeyId(buf) {
        var len = bytes_1.le2toi(buf, 8);
        var xml = bytes_1.bytesToUTF16Str(buf.subarray(10, len + 10));
        var doc = new DOMParser().parseFromString(xml, "application/xml");
        var kidElement = doc.querySelector("KID");
        if (!kidElement) {
            throw new Error("invalid XML");
        }
        var kid = kidElement.textContent || "";
        return bytes_1.guidToUuid(atob(kid)).toLowerCase();
    }
    /**
     * Reduce implementation for the children of the given element.
     * TODO better typings
     * @param {Element} root
     * @param {Function} fn
     * @param {*} init
     * @returns {*}
     */
    function reduceChildren(root, fn, init) {
        var node = root.firstElementChild;
        var r = init;
        while (node) {
            r = fn(r, node.nodeName, node);
            node = node.nextElementSibling;
        }
        return r;
    }
    /**
     * @param {Element} root
     * @returns {Object}
     */
    function parseProtection(root) {
        var header = root.firstElementChild;
        assert_1.default(header.nodeName === "ProtectionHeader", "Protection should have ProtectionHeader child");
        var privateData = bytes_1.strToBytes(atob(header.textContent || ""));
        var keyId = getHexKeyId(privateData);
        var keyIdBytes = bytes_1.hexToBytes(keyId);
        // remove possible braces
        var systemId = (header.getAttribute("SystemID") || "").toLowerCase()
            .replace(/\{|\}/g, "");
        return {
            keyId: keyId,
            keySystems: [
                {
                    systemId: systemId,
                    privateData: privateData,
                },
            ].concat(keySystems(keyIdBytes)),
        };
    }
    /**
     * @param {Element} node
     * @param {Array.<Object>} timeline
     * @returns {Array.<Object>}
     */
    function parseC(node, timeline) {
        var len = timeline.length;
        var prev = len > 0 ?
            timeline[len - 1] : { d: 0, ts: 0, r: 0 };
        var dAttr = node.getAttribute("d");
        var tAttr = node.getAttribute("t");
        var rAttr = node.getAttribute("r");
        // in smooth streaming format,
        // r refers to number of same duration
        // chunks, not repetitions (defers from DASH)
        var r = rAttr ? +rAttr - 1 : 0;
        var t = tAttr ? +tAttr : undefined;
        var d = dAttr ? +dAttr : undefined;
        if (len > 0 && !prev.d) {
            if (false) {}
            prev.d = t != null ? t - prev.ts : 0;
            timeline[len - 1] = prev; // TODO might not be needed
        }
        // if same segment than the last one, repeat the previous one
        if (len > 0 && d === prev.d && t == null) {
            prev.r += (r || 0) + 1;
        }
        else {
            if (false) {}
            var ts = (t == null)
                ? prev.ts + (prev.d || 0) * (prev.r + 1)
                : t;
            timeline.push({ d: d, ts: ts, r: r });
        }
        return timeline;
    }
    /**
     * @param {Element} q
     * @param {string} type
     * @return {Object}
     */
    function parseQualityLevel(q, type) {
        /**
         * @param {string} name
         * @returns {string|undefined}
         */
        function getAttribute(name) {
            var attr = q.getAttribute(name);
            return attr == null ? undefined : attr;
        }
        switch (type) {
            case "audio": {
                var audiotag = getAttribute("AudioTag");
                var bitrate = getAttribute("Bitrate");
                var bitsPerSample = getAttribute("BitsPerSample");
                var channels = getAttribute("Channels");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                var packetSize = getAttribute("PacketSize");
                var samplingRate = getAttribute("SamplingRate");
                return {
                    audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    bitsPerSample: bitsPerSample !== undefined ?
                        parseInt(bitsPerSample, 10) : bitsPerSample,
                    channels: channels !== undefined ? parseInt(channels, 10) : channels,
                    codecPrivateData: codecPrivateData || "",
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    packetSize: packetSize !== undefined ?
                        parseInt(packetSize, 10) : packetSize,
                    samplingRate: samplingRate !== undefined ?
                        parseInt(samplingRate, 10) : samplingRate,
                };
            }
            case "video": {
                var bitrate = getAttribute("Bitrate");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                var width = getAttribute("MaxWidth");
                var height = getAttribute("MaxHeight");
                return {
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    codecPrivateData: codecPrivateData || "",
                    codecs: extractVideoCodecs(codecPrivateData || ""),
                    width: width !== undefined ? parseInt(width, 10) : undefined,
                    height: height !== undefined ? parseInt(height, 10) : undefined,
                };
            }
            case "text": {
                var bitrate = getAttribute("Bitrate");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                return {
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    codecPrivateData: codecPrivateData || "",
                };
            }
            default:
                throw new Error("Unrecognized StreamIndex type: " + type);
        }
    }
    /**
     * Parse the adaptations (<StreamIndex>) tree containing
     * representations (<QualityLevels>) and timestamp indexes (<c>).
     * Indexes can be quite huge, and this function needs to
     * to be optimized.
     * @param {Element} root
     * @param {string} rootURL
     * @param {Number} timescale
     * @returns {Object}
     */
    function parseAdaptation(root, rootURL, timescale, protection) {
        var _timescale = root.hasAttribute("Timescale") ?
            +(root.getAttribute("Timescale") || 0) : timescale;
        var adaptationType = root.getAttribute("Type");
        if (adaptationType == null) {
            throw new Error("StreamIndex without type.");
        }
        var subType = root.getAttribute("Subtype");
        var name = root.getAttribute("Name");
        var language = root.getAttribute("Language");
        var normalizedLanguage = language == null ?
            language : languages_1.normalize(language);
        var baseURL = root.getAttribute("Url") || "";
        if (false) {}
        var _a = reduceChildren(root, function (res, _name, node) {
            switch (_name) {
                case "QualityLevel":
                    var rep = parseQualityLevel(node, adaptationType);
                    if (adaptationType === "audio") {
                        var fourCC = node.getAttribute("FourCC") || "";
                        rep.codecs = extractAudioCodecs(fourCC, rep.codecPrivateData);
                    }
                    // filter out video representations with small bitrates
                    if (adaptationType !== "video" || rep.bitrate > MIN_REPRESENTATION_BITRATE) {
                        res.representations.push(rep);
                    }
                    break;
                case "c":
                    res.index.timeline = parseC(node, res.index.timeline);
                    break;
            }
            return res;
        }, {
            representations: [],
            index: {
                timeline: [],
                timescale: _timescale,
                initialization: {},
            },
        }), representations = _a.representations, index = _a.index;
        // we assume that all representations have the same
        // codec and mimeType
        assert_1.default(representations.length !== 0, "adaptation should have at least one representation");
        var id = adaptationType + (language ? ("_" + language) : "");
        // apply default properties
        representations.forEach(function (representation) {
            representation.baseURL = url_1.resolveURL(rootURL, baseURL);
            representation.mimeType =
                representation.mimeType || DEFAULT_MIME_TYPES[adaptationType];
            representation.codecs = representation.codecs || DEFAULT_CODECS[adaptationType];
            representation.id = id + "_" + adaptationType + "-" +
                representation.mimeType + "-" +
                representation.codecs + "-" + representation.bitrate;
            var initSegmentInfos = {
                bitsPerSample: representation.bitsPerSample,
                channels: representation.channels,
                codecPrivateData: representation.codecPrivateData,
                packetSize: representation.packetSize,
                samplingRate: representation.samplingRate,
                protection: protection,
            };
            representation.index = new representationIndex_1.default(index, initSegmentInfos);
        });
        // TODO(pierre): real ad-insert support
        if (subType === "ADVT") {
            return null;
        }
        var parsedAdaptation = {
            id: id,
            type: adaptationType,
            representations: representations,
            name: name == null ? undefined : name,
            language: language == null ?
                undefined : language,
            normalizedLanguage: normalizedLanguage == null ?
                undefined : normalizedLanguage,
        };
        if (adaptationType === "text" && subType === "DESC") {
            parsedAdaptation.closedCaption = true;
        }
        return parsedAdaptation;
    }
    function parseFromDocument(doc, url) {
        var rootURL = url_1.normalizeBaseURL(url);
        var root = doc.documentElement;
        assert_1.default(root.nodeName === "SmoothStreamingMedia", "document root should be SmoothStreamingMedia");
        assert_1.default(/^[2]-[0-2]$/
            .test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion")), "Version should be 2.0, 2.1 or 2.2");
        var timescale = +(root.getAttribute("Timescale") || 10000000);
        var _a = reduceChildren(root, function (res, name, node) {
            switch (name) {
                case "Protection": {
                    res.protection = parseProtection(node);
                    break;
                }
                case "StreamIndex":
                    res.adaptationNodes.push(node);
                    break;
            }
            return res;
        }, {
            adaptationNodes: [],
        }), protection = _a.protection, adaptationNodes = _a.adaptationNodes;
        var adaptations = adaptationNodes.map(function (node) {
            return parseAdaptation(node, rootURL, timescale, protection);
        }).filter(function (adaptation) { return !!adaptation; });
        var suggestedPresentationDelay;
        var presentationLiveGap;
        var timeShiftBufferDepth;
        var availabilityStartTime;
        var duration;
        var firstVideoAdaptation = adaptations.filter(function (a) { return a.type === "video"; })[0];
        var firstAudioAdaptation = adaptations.filter(function (a) { return a.type === "audio"; })[0];
        var firstTimeReference;
        var lastTimeReference;
        if (firstVideoAdaptation || firstAudioAdaptation) {
            var firstTimeReferences = [];
            var lastTimeReferences = [];
            if (firstVideoAdaptation) {
                var firstVideoRepresentation = firstVideoAdaptation.representations[0];
                if (firstVideoRepresentation) {
                    var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();
                    var lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                    if (firstVideoTimeReference != null) {
                        firstTimeReferences.push(firstVideoTimeReference);
                    }
                    if (lastVideoTimeReference != null) {
                        lastTimeReferences.push(lastVideoTimeReference);
                    }
                }
            }
            if (firstAudioAdaptation) {
                var firstAudioRepresentation = firstAudioAdaptation.representations[0];
                if (firstAudioRepresentation) {
                    var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();
                    var lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                    if (firstAudioTimeReference != null) {
                        firstTimeReferences.push(firstAudioTimeReference);
                    }
                    if (lastAudioTimeReference != null) {
                        lastTimeReferences.push(lastAudioTimeReference);
                    }
                }
            }
            if (firstTimeReferences.length) {
                firstTimeReference = Math.max.apply(Math, firstTimeReferences);
            }
            if (lastTimeReferences.length) {
                lastTimeReference = Math.max.apply(Math, lastTimeReferences);
            }
        }
        var isLive = parseBoolean(root.getAttribute("IsLive"));
        if (isLive) {
            suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY;
            timeShiftBufferDepth =
                +(root.getAttribute("DVRWindowLength") || 0) / timescale;
            availabilityStartTime = REFERENCE_DATE_TIME;
            presentationLiveGap = Date.now() / 1000 -
                (lastTimeReference != null ?
                    (lastTimeReference + availabilityStartTime) : 10);
            var manifestDuration = root.getAttribute("Duration");
            duration = (manifestDuration != null && +manifestDuration !== 0) ?
                (+manifestDuration / timescale) : Infinity;
        }
        else {
            // if non-live and first time reference different than 0. Add first time reference
            // to duration
            var manifestDuration = root.getAttribute("Duration");
            if (manifestDuration != null && +manifestDuration !== 0) {
                duration = lastTimeReference == null ?
                    (+manifestDuration + (firstTimeReference || 0)) / timescale :
                    lastTimeReference;
            }
            else {
                duration = Infinity;
            }
        }
        var minimumTime = firstTimeReference != null ?
            firstTimeReference / timescale : undefined;
        var manifest = {
            id: "gen-smooth-manifest-" + id_1.default(),
            availabilityStartTime: availabilityStartTime || 0,
            duration: duration,
            presentationLiveGap: presentationLiveGap,
            suggestedPresentationDelay: suggestedPresentationDelay,
            timeShiftBufferDepth: timeShiftBufferDepth,
            transportType: "smooth",
            type: isLive ? "dynamic" : "static",
            uris: [url],
            minimumTime: minimumTime,
            periods: [{
                    id: "gen-smooth-period-0",
                    duration: duration,
                    adaptations: adaptations,
                    start: 0,
                }],
        };
        checkManifestIDs(manifest);
        return manifest;
    }
    return parseFromDocument;
}
/**
 * Ensure that no two adaptations have the same ID and that no two
 * representations from a same adaptation neither.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
function checkManifestIDs(manifest) {
    manifest.periods.forEach(function (_a) {
        var adaptations = _a.adaptations;
        var adaptationIDs = [];
        adaptations.forEach(function (adaptation) {
            var adaptationID = adaptation.id;
            if (array_includes_1.default(adaptationIDs, adaptationID)) {
                log_1.default.warn("Smooth: Two adaptations with the same ID found. Updating.", adaptationID);
                var newID = adaptationID + "-";
                adaptation.id = newID;
                checkManifestIDs(manifest);
                adaptationIDs.push(newID);
            }
            else {
                adaptationIDs.push(adaptationID);
            }
            var representationIDs = [];
            adaptation.representations.forEach(function (representation) {
                var representationID = representation.id;
                if (array_includes_1.default(representationIDs, representationID)) {
                    log_1.default.warn("Smooth: Two representations with the same ID found. Updating.", representationID);
                    var newID = representationID + "-";
                    representation.id = newID;
                    checkManifestIDs(manifest);
                    representationIDs.push(newID);
                }
                else {
                    representationIDs.push(representationID);
                }
            });
        });
    });
}
exports.default = createSmoothStreamingParser;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(4);
var bytes_1 = __webpack_require__(21);
/**
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {UInt8Array|null}
 */
function getBox(buf, boxName) {
    var l = buf.length;
    var i = 0;
    var name;
    var size = 0;
    while (i + 8 < l) {
        size = bytes_1.be4toi(buf, i);
        name = bytes_1.be4toi(buf, i + 4);
        assert_1.default(size > 0, "out of range size");
        if (name === boxName) {
            break;
        }
        else {
            i += size;
        }
    }
    if (i < l) {
        return buf.subarray(i + 8, i + size);
    }
    else {
        return null;
    }
}
/**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getTRAF(buffer) {
    var moof = getBox(buffer, 0x6d6f6f66 /* moof */);
    if (!moof) {
        return null;
    }
    return getBox(moof, 0x74726166 /* traf */);
}
exports.getTRAF = getTRAF;
/**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDAT(buf) {
    return getBox(buf, 0x6D646174 /* "mdat" */);
}
exports.getMDAT = getMDAT;
/**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDIA(buf) {
    var moov = getBox(buf, 0x6d6f6f76 /* moov */);
    if (!moov) {
        return null;
    }
    var trak = getBox(moov, 0x7472616b /* "trak" */);
    if (!trak) {
        return null;
    }
    return getBox(trak, 0x6d646961 /* "mdia" */);
}
exports.getMDIA = getMDIA;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var isobmff_1 = __webpack_require__(30);
var mp4_1 = __webpack_require__(52);
var getTraf = mp4_1.default.getTraf, parseTfrf = mp4_1.default.parseTfrf, parseTfxd = mp4_1.default.parseTfxd;
function extractTimingsInfos(responseData, segment, isLive) {
    var nextSegments = [];
    var segmentInfos;
    var tfxdSegment;
    var tfrfSegments;
    if (isLive) {
        var traf = getTraf(responseData);
        if (traf) {
            tfrfSegments = parseTfrf(traf);
            tfxdSegment = parseTfxd(traf);
        }
        else {
            log_1.default.warn("smooth: could not find traf atom");
        }
    }
    if (!tfxdSegment) {
        // we could always make a mistake when reading a container.
        // If the estimate is too far from what the segment seems to imply, take
        // the segment infos instead.
        var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);
        var trunDuration = isobmff_1.getDurationFromTrun(responseData);
        if (trunDuration >= 0 && (segment.duration == null ||
            Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {
            segmentInfos = {
                time: segment.time,
                duration: trunDuration,
                timescale: segment.timescale,
            };
        }
        else {
            segmentInfos = {
                time: segment.time,
                duration: segment.duration,
                timescale: segment.timescale,
            };
        }
    }
    else {
        segmentInfos = {
            time: tfxdSegment.time,
            duration: tfxdSegment.duration,
            timescale: segment.timescale,
        };
    }
    if (tfrfSegments) {
        for (var i = 0; i < tfrfSegments.length; i++) {
            nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale,
            });
        }
    }
    return { nextSegments: nextSegments, segmentInfos: segmentInfos };
}
exports.default = extractTimingsInfos;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var bif_1 = __webpack_require__(93);
var assert_1 = __webpack_require__(4);
var request_1 = __webpack_require__(23);
var strings_1 = __webpack_require__(92);
var url_1 = __webpack_require__(20);
var manifest_loader_1 = __webpack_require__(91);
var isobmff_timings_infos_1 = __webpack_require__(228);
var manifest_1 = __webpack_require__(226);
var mp4_1 = __webpack_require__(52);
var segment_loader_1 = __webpack_require__(222);
var utils_1 = __webpack_require__(90);
var patchSegment = mp4_1.default.patchSegment, getMdat = mp4_1.default.getMdat;
var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(adaptation, nextSegments, dlSegment) {
    var representations = adaptation.representations;
    for (var i = 0; i < representations.length; i++) {
        var representation = representations[i];
        representation.index._addSegments(nextSegments, dlSegment);
    }
}
function default_1(options) {
    if (options === void 0) { options = {}; }
    var smoothManifestParser = manifest_1.default(options);
    var segmentLoader = segment_loader_1.default(options.segmentLoader);
    var manifestLoaderOptions = {
        customManifestLoader: options.manifestLoader,
        ignoreProgressEvents: true,
    };
    var manifestLoader = manifest_loader_1.default(manifestLoaderOptions);
    var manifestPipeline = {
        resolver: function (_a) {
            var url = _a.url;
            var resolving;
            var token = utils_1.extractToken(url);
            // TODO Remove WSX logic
            if (WSX_REG.test(url)) {
                resolving = request_1.default({
                    url: utils_1.replaceToken(url, ""),
                    responseType: "document",
                    ignoreProgressEvents: true,
                })
                    .map(function (_a) {
                    var value = _a.value;
                    var extractedURL = utils_1.extractISML(value.responseData);
                    if (!extractedURL) {
                        throw new Error("Invalid ISML");
                    }
                    return extractedURL;
                });
            }
            else {
                resolving = Observable_1.Observable.of(url);
            }
            return resolving
                .map(function (_url) { return ({ url: utils_1.replaceToken(utils_1.resolveManifest(_url), token) }); });
        },
        loader: function (_a) {
            var url = _a.url;
            return manifestLoader(url);
        },
        parser: function (_a) {
            var response = _a.response, reqURL = _a.url;
            var url = response.url == null ? reqURL : response.url;
            var data = typeof response.responseData === "string" ?
                new DOMParser().parseFromString(response.responseData, "text/xml") :
                response.responseData;
            var manifest = smoothManifestParser(data, url);
            return Observable_1.Observable.of({ manifest: manifest, url: url });
        },
    };
    var segmentPipeline = {
        loader: function (_a) {
            var adaptation = _a.adaptation, init = _a.init, manifest = _a.manifest, period = _a.period, representation = _a.representation, segment = _a.segment;
            return segmentLoader({
                adaptation: adaptation,
                init: init,
                manifest: manifest,
                period: period,
                representation: representation,
                segment: segment,
            });
        },
        parser: function (_a) {
            var segment = _a.segment, response = _a.response, adaptation = _a.adaptation, manifest = _a.manifest;
            var responseData = response.responseData;
            if (segment.isInit) {
                // smooth init segments are crafted by hand. Their timescale is the one
                // from the manifest.
                var initSegmentInfos = {
                    timescale: segment.timescale,
                    time: -1,
                    duration: 0,
                };
                return Observable_1.Observable.of({
                    segmentData: responseData,
                    segmentInfos: initSegmentInfos,
                });
            }
            if (false) {}
            var responseBuffer = new Uint8Array(responseData);
            var _b = isobmff_timings_infos_1.default(responseBuffer, segment, manifest.isLive), nextSegments = _b.nextSegments, segmentInfos = _b.segmentInfos;
            var segmentData = patchSegment(responseBuffer, segmentInfos.time);
            if (nextSegments) {
                addNextSegments(adaptation, nextSegments, segmentInfos);
            }
            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
        },
    };
    var textTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            if (segment.isInit) {
                return Observable_1.Observable.of({
                    type: "data",
                    value: { responseData: null },
                });
            }
            // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
            var responseType = isMP4EmbeddedTrack(representation) ? "arraybuffer" : "text";
            var base = url_1.resolveURL(representation.baseURL);
            var url = utils_1.buildSegmentURL(base, representation, segment);
            return request_1.default({ url: url, responseType: responseType });
        },
        parser: function (_a) {
            var response = _a.response, segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest;
            var language = adaptation.language;
            var _b = representation.mimeType, mimeType = _b === void 0 ? "" : _b, _c = representation.codec, codec = _c === void 0 ? "" : _c;
            if (false) {}
            var responseData = response.responseData;
            if (responseData === null) {
                return Observable_1.Observable.of({
                    segmentData: null,
                    segmentInfos: segment.timescale > 0 ? {
                        duration: segment.isInit ? 0 : segment.duration,
                        time: segment.isInit ? -1 : segment.time,
                        timescale: segment.timescale,
                    } : null,
                });
            }
            var parsedResponse;
            var nextSegments;
            var segmentInfos = null;
            var isMP4 = mimeType.indexOf("mp4") >= 0;
            // segmentData components
            var _sdStart;
            var _sdEnd;
            var _sdTimescale;
            var _sdData;
            var _sdType;
            if (isMP4) {
                if (false) {}
                parsedResponse = new Uint8Array(responseData);
                var timings = isobmff_timings_infos_1.default(parsedResponse, segment, manifest.isLive);
                nextSegments = timings.nextSegments;
                segmentInfos = timings.segmentInfos;
                _sdStart = segmentInfos.time;
                _sdEnd = segmentInfos.duration != null ?
                    segmentInfos.time + segmentInfos.duration : undefined;
                if (false) {}
                _sdTimescale = segmentInfos.timescale;
            }
            else {
                if (false) {}
                parsedResponse = responseData;
                var segmentTime = segment.time || 0;
                // vod is simple WebVTT or TTML text
                _sdStart = segmentTime;
                _sdEnd = segment.duration != null ?
                    segmentTime + segment.duration : undefined;
                _sdTimescale = segment.timescale;
            }
            if (isMP4) {
                var lcCodec = codec.toLowerCase();
                if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp") {
                    _sdType = "ttml";
                }
                else if (lcCodec === "wvtt") {
                    _sdType = "vtt";
                }
                else {
                    throw new Error("could not find a text-track parser for the type " + mimeType);
                }
                var mdat = getMdat(parsedResponse);
                _sdData = strings_1.stringFromUTF8(mdat);
            }
            else {
                switch (mimeType) {
                    case "application/x-sami":
                    case "application/smil": // TODO SMIL should be its own format, no?
                        _sdType = "sami";
                        break;
                    case "application/ttml+xml":
                        _sdType = "ttml";
                        break;
                    case "text/vtt":
                        _sdType = "vtt";
                        break;
                }
                if (!_sdType) {
                    var lcCodec = codec.toLowerCase();
                    if (lcCodec === "srt") {
                        _sdType = "srt";
                    }
                    else {
                        throw new Error("could not find a text-track parser for the type " + mimeType);
                    }
                }
                _sdData = responseData;
            }
            if (segmentInfos != null && nextSegments) {
                addNextSegments(adaptation, nextSegments, segmentInfos);
            }
            return Observable_1.Observable.of({
                segmentData: {
                    type: _sdType,
                    data: _sdData,
                    language: language,
                    timescale: _sdTimescale,
                    start: _sdStart,
                    end: _sdEnd,
                    timeOffset: _sdStart / _sdTimescale,
                },
                segmentInfos: segmentInfos,
            });
        },
    };
    var imageTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            if (segment.isInit) {
                // image do not need an init segment. Passthrough directly to the parser
                return Observable_1.Observable.of({
                    type: "data",
                    value: { responseData: null },
                });
            }
            var baseURL = url_1.resolveURL(representation.baseURL);
            var url = utils_1.buildSegmentURL(baseURL, representation, segment);
            return request_1.default({ url: url, responseType: "arraybuffer" });
        },
        parser: function (_a) {
            var response = _a.response, segment = _a.segment;
            var responseData = response.responseData;
            if (responseData === null) {
                return Observable_1.Observable.of({
                    segmentData: null,
                    segmentInfos: segment.timescale > 0 ? {
                        duration: segment.isInit ? 0 : segment.duration,
                        time: segment.isInit ? -1 : segment.time,
                        timescale: segment.timescale,
                    } : null,
                });
            }
            var bifObject = bif_1.default(new Uint8Array(responseData));
            var data = bifObject.thumbs;
            return Observable_1.Observable.of({
                segmentData: {
                    data: data,
                    start: 0,
                    end: Number.MAX_VALUE,
                    timescale: 1,
                    timeOffset: 0,
                    type: "bif",
                },
                segmentInfos: {
                    time: 0,
                    duration: Number.MAX_VALUE,
                    timescale: bifObject.timescale,
                },
            });
        },
    };
    return {
        manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline,
    };
}
exports.default = default_1;
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
    return !!representation.mimeType && representation.mimeType.indexOf("mp4") >= 0;
}


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var exported = {};
/* tslint:disable no-var-requires */
if (true) {
    exported.smooth = __webpack_require__(229).default;
}
if (true) {
    exported.dash = __webpack_require__(221).default;
}
exports.default = exported;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var castToObservable_1 = __webpack_require__(14);
var MediaKeys_1 = __webpack_require__(94);
/**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */
function _setMediaKeys(elt, mediaKeys) {
    if (mediaKeys instanceof MediaKeys_1.MockMediaKeys) {
        return mediaKeys._setVideo(elt);
    }
    if (elt.setMediaKeys) {
        return elt.setMediaKeys(mediaKeys);
    }
    if (mediaKeys === null) {
        return;
    }
    if (elt.WebkitSetMediaKeys) {
        return elt.WebkitSetMediaKeys(mediaKeys);
    }
    if (elt.mozSetMediaKeys) {
        return elt.mozSetMediaKeys(mediaKeys);
    }
    if (elt.msSetMediaKeys) {
        return elt.msSetMediaKeys(mediaKeys);
    }
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */
function setMediaKeys$(elt, mediaKeys) {
    return Observable_1.Observable.defer(function () {
        return castToObservable_1.default(_setMediaKeys(elt, mediaKeys)).mapTo(null);
    });
}
exports.default = setMediaKeys$;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */
var RequestError = /** @class */ (function (_super) {
    __extends(RequestError, _super);
    function RequestError(xhr, url, type) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, RequestError.prototype);
        _this.name = "RequestError";
        _this.url = url;
        _this.xhr = xhr;
        _this.status = xhr.status;
        _this.type = type;
        _this.message = type;
        return _this;
    }
    return RequestError;
}(Error));
exports.default = RequestError;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(24);
var errorMessage_1 = __webpack_require__(31);
/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    function NetworkError(code, requestError, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, NetworkError.prototype);
        _this.name = "NetworkError";
        _this.type = constants_1.ErrorTypes.NETWORK_ERROR;
        _this.xhr = requestError.xhr;
        _this.url = requestError.url;
        _this.status = requestError.status;
        _this.errorType = requestError.type;
        _this.reason = requestError;
        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?
            constants_1.ErrorCodes[code] : "";
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    /**
     * Returns true if the NetworkError is due to the given http error code
     * @param {number} httpErrorCode
     * @returns {Boolean}
     */
    NetworkError.prototype.isHttpError = function (httpErrorCode) {
        return (this.errorType === constants_1.RequestErrorTypes.ERROR_HTTP_CODE &&
            this.status === httpErrorCode);
    };
    return NetworkError;
}(Error));
exports.default = NetworkError;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// TODO https://stackoverflow.com/questions/41102060/typescript-extending-error-class
var constants_1 = __webpack_require__(24);
var errorMessage_1 = __webpack_require__(31);
/**
 * @class OtherError
 * @extends Error
 */
var OtherError = /** @class */ (function (_super) {
    __extends(OtherError, _super);
    function OtherError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, OtherError.prototype);
        _this.name = "OtherError";
        _this.type = constants_1.ErrorTypes.OTHER_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?
            constants_1.ErrorCodes[code] : "";
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return OtherError;
}(Error));
exports.default = OtherError;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(24);
var errorMessage_1 = __webpack_require__(31);
/**
 * Error linked to the Index part of the Manifest.
 *
 * TODO Rename ManifestError or something?
 *
 * @class IndexError
 * @extends Error
 */
var IndexError = /** @class */ (function (_super) {
    __extends(IndexError, _super);
    function IndexError(code, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, IndexError.prototype);
        _this.name = "IndexError";
        _this.type = constants_1.ErrorTypes.INDEX_ERROR;
        _this.reason = null;
        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?
            constants_1.ErrorCodes[code] : "";
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, null);
        return _this;
    }
    return IndexError;
}(Error));
exports.default = IndexError;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(24);
var errorMessage_1 = __webpack_require__(31);
/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */
var EncryptedMediaError = /** @class */ (function (_super) {
    __extends(EncryptedMediaError, _super);
    function EncryptedMediaError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, EncryptedMediaError.prototype);
        _this.name = "EncryptedMediaError";
        _this.type = constants_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes.hasOwnProperty(code) ?
            constants_1.ErrorCodes[code] : "";
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return EncryptedMediaError;
}(Error));
exports.default = EncryptedMediaError;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = __webpack_require__(6);
var bytes_1 = __webpack_require__(21);
var hash_buffer_1 = __webpack_require__(38);
var log_1 = __webpack_require__(1);
var simple_set_1 = __webpack_require__(54);
var PSSH_TO_INTEGER = bytes_1.be4toi(bytes_1.strToBytes("pssh"), 0);
/**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the source buffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData
 * @returns {Uint8Array}
 */
function cleanEncryptedEvent(initData) {
    var resInitData = new Uint8Array();
    var currentHashes = new simple_set_1.default();
    var offset = 0;
    while (offset < initData.length) {
        if (initData.length < offset + 8 ||
            bytes_1.be4toi(initData, offset + 4) !== PSSH_TO_INTEGER) {
            log_1.default.warn("unrecognized initialization data. Use as is.");
            return initData;
        }
        var len = bytes_1.be4toi(new Uint8Array(initData), offset);
        if (offset + len > initData.length) {
            log_1.default.warn("unrecognized initialization data. Use as is.");
            return initData;
        }
        var currentPSSH = initData.subarray(offset, offset + len);
        var currentPSSHHash = hash_buffer_1.default(currentPSSH);
        if (!currentHashes.test(currentPSSHHash)) {
            currentHashes.add(currentPSSHHash);
            resInitData = bytes_1.concat(resInitData, currentPSSH);
        }
        else {
            log_1.default.warn("Duplicated PSSH found in initialization data, removing it.");
        }
        offset += len;
    }
    if (offset !== initData.length) {
        log_1.default.warn("unrecognized initialization data. Use as is.");
        return initData;
    }
    return resInitData;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent
 * @returns {Object}
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */
function getInitData(encryptedEvent) {
    var initData = encryptedEvent.initData;
    if (initData == null) {
        var error = new Error("no init data found on media encrypted event.");
        throw new errors_1.EncryptedMediaError("INVALID_ENCRYPTED_EVENT", error, true);
    }
    var initDataBytes = new Uint8Array(initData);
    return {
        initData: cleanEncryptedEvent(initDataBytes),
        initDataType: encryptedEvent.initDataType,
    };
}
exports.default = getInitData;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var get_init_data_1 = __webpack_require__(237);
exports.getInitData = get_init_data_1.default;
var keySystemAccess_1 = __webpack_require__(95);
exports.KeySystemAccess = keySystemAccess_1.default;
var MediaKeys_1 = __webpack_require__(94);
exports.requestMediaKeySystemAccess = MediaKeys_1.requestMediaKeySystemAccess;
var setMediaKeys_1 = __webpack_require__(231);
exports.setMediaKeys = setMediaKeys_1.default;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Request fullScreen action on a given element.
 * @paras {HTMLElement} elt
 * rs-detect)
 */
function requestFullscreen(elt) {
    if (!isFullscreen()) {
        if (elt.requestFullscreen) {
            elt.requestFullscreen();
        }
        else if (elt.msRequestFullscreen) {
            elt.msRequestFullscreen();
        }
        else if (elt.mozRequestFullScreen) {
            elt.mozRequestFullScreen();
        }
        else if (elt.webkitRequestFullscreen) {
            // TODO Open issue in TypeScript?
            elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
    }
}
exports.requestFullscreen = requestFullscreen;
/**
 * Exit fullscreen if an element is currently in fullscreen.
 * TODO this exit fullscreen mode even if any element in the document is in
 * fullscreen, is it really what we want?
 */
function exitFullscreen() {
    if (isFullscreen()) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    }
}
exports.exitFullscreen = exitFullscreen;
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */
function isFullscreen() {
    return !!(document.fullscreenElement ||
        document.mozFullScreenElement ||
        document.webkitFullscreenElement ||
        document.msFullscreenElement);
}
exports.isFullscreen = isFullscreen;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */
var AssertionError = /** @class */ (function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(message) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, AssertionError.prototype);
        _this.name = "AssertionError";
        _this.message = message;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, AssertionError);
        }
        return _this;
    }
    return AssertionError;
}(Error));
exports.default = AssertionError;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(106);
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(107);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var QueueAction_1 = __webpack_require__(242);
var QueueScheduler_1 = __webpack_require__(241);
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),
/* 244 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 245 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(245);
var isArguments = __webpack_require__(244);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file and directory defines the public API for the RxPlayer.
 *
 * It also starts the different sub-parts of the player on various API calls.
 */
var deepEqual = __webpack_require__(246);
var BehaviorSubject_1 = __webpack_require__(96);
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(39);
var Subject_1 = __webpack_require__(7);
var config_1 = __webpack_require__(2);
var assert_1 = __webpack_require__(4);
var eventemitter_1 = __webpack_require__(33);
var log_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(40);
var ranges_1 = __webpack_require__(16);
var compat_1 = __webpack_require__(5);
var events_1 = __webpack_require__(15);
var errors_1 = __webpack_require__(6);
var timings_1 = __webpack_require__(53);
var net_1 = __webpack_require__(230);
var eme_1 = __webpack_require__(50);
var stream_1 = __webpack_require__(187);
var directfile_1 = __webpack_require__(121);
var clock_1 = __webpack_require__(120);
var constants_1 = __webpack_require__(67);
var get_player_state_1 = __webpack_require__(119);
var language_manager_1 = __webpack_require__(118);
var option_parsers_1 = __webpack_require__(117);
var DEFAULT_UNMUTED_VOLUME = config_1.default.DEFAULT_UNMUTED_VOLUME;
/**
 * @class Player
 * @extends EventEmitter
 */
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    /**
     * Note: as the private state from this class can be pretty heavy, every
     * private properties should be initialized here for better visibility.
     * @constructor
     * @param {Object} options
     * @param {HTMLMediaElement} options.videoElement
     */
    function Player(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        var _a = option_parsers_1.parseConstructorOptions(options), initialAudioBitrate = _a.initialAudioBitrate, initialVideoBitrate = _a.initialVideoBitrate, limitVideoWidth = _a.limitVideoWidth, maxAudioBitrate = _a.maxAudioBitrate, maxBufferAhead = _a.maxBufferAhead, maxBufferBehind = _a.maxBufferBehind, maxVideoBitrate = _a.maxVideoBitrate, throttleWhenHidden = _a.throttleWhenHidden, videoElement = _a.videoElement, wantedBufferAhead = _a.wantedBufferAhead, stopAtEnd = _a.stopAtEnd;
        // Workaround to support Firefox autoplay on FF 42.
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
        videoElement.preload = "auto";
        _this.version = /*PLAYER_VERSION*/ "3.4.1";
        _this.log = log_1.default;
        _this.state = "STOPPED";
        _this.videoElement = videoElement;
        _this._priv_destroy$ = new Subject_1.Subject();
        events_1.onFullscreenChange$(videoElement)
            .takeUntil(_this._priv_destroy$)
            .subscribe(function () { return _this.trigger("fullscreenChange", _this.isFullscreen()); });
        events_1.onTextTrackChanges$(videoElement.textTracks)
            .takeUntil(_this._priv_destroy$)
            .map(function (evt) {
            var target = evt.target;
            var arr = [];
            for (var i = 0; i < target.length; i++) {
                var textTrack = target[i];
                arr.push(textTrack);
            }
            return arr;
        })
            // We can have two consecutive textTrackChanges with the exact same
            // payload when we perform multiple texttrack operations before the event
            // loop is freed.
            // In that case we only want to fire one time the observable.
            .distinctUntilChanged(function (textTracksA, textTracksB) {
            if (textTracksA.length !== textTracksB.length) {
                return false;
            }
            for (var i = 0; i < textTracksA.length; i++) {
                if (textTracksA[i] !== textTracksB[i]) {
                    return false;
                }
            }
            return true;
        })
            .subscribe(function (x) { return _this._priv_onNativeTextTracksNext(x); });
        _this._priv_playing$ = new ReplaySubject_1.ReplaySubject(1);
        _this._priv_speed$ = new BehaviorSubject_1.BehaviorSubject(videoElement.playbackRate);
        _this._priv_stopCurrentContent$ = new Subject_1.Subject();
        _this._priv_streamLock$ = new BehaviorSubject_1.BehaviorSubject(false);
        _this._priv_bufferOptions = {
            wantedBufferAhead$: new BehaviorSubject_1.BehaviorSubject(wantedBufferAhead),
            maxBufferAhead$: new BehaviorSubject_1.BehaviorSubject(maxBufferAhead),
            maxBufferBehind$: new BehaviorSubject_1.BehaviorSubject(maxBufferBehind),
        };
        _this._priv_bitrateInfos = {
            lastBitrates: {
                audio: initialAudioBitrate,
                video: initialVideoBitrate,
            },
            initialMaxAutoBitrates: {
                audio: maxAudioBitrate,
                video: maxVideoBitrate,
            },
            manualBitrates: {
                audio: -1,
                video: -1,
            },
        };
        _this._priv_throttleWhenHidden = throttleWhenHidden;
        _this._priv_limitVideoWidth = limitVideoWidth;
        _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
        _this._priv_languageManager = null;
        _this._priv_abrManager = null;
        _this._priv_currentError = null;
        _this._priv_contentInfos = null;
        _this._priv_contentEventsMemory = {
            period: null,
            audioTrack: null,
            textTrack: null,
            videoBitrate: null,
            audioBitrate: null,
            bitrateEstimation: undefined,
        };
        _this._priv_stopAtEnd = stopAtEnd;
        _this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        return _this;
    }
    Object.defineProperty(Player, "ErrorTypes", {
        /**
         * @returns {Object}
         */
        get: function () {
            return errors_1.ErrorTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player, "ErrorCodes", {
        /**
         * @returns {Object}
         */
        get: function () {
            return errors_1.ErrorCodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player, "LogLevel", {
        /**
         * @returns {string} - current log level
         */
        get: function () {
            return log_1.default.getLevel();
        },
        /**
         * @param {string} logLevel - should be either (by verbosity ascending):
         *   - "NONE"
         *   - "ERROR"
         *   - "WARNING"
         *   - "INFO"
         *   - "DEBUG"
         * Any other value will be translated to "NONE".
         */
        set: function (logLevel) {
            log_1.default.setLevel(logLevel);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stop the player.
     */
    Player.prototype.stop = function () {
        if (this.state !== constants_1.PLAYER_STATES.STOPPED) {
            this._priv_stopCurrentContent$.next();
            this._priv_cleanUpCurrentContentState();
            this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        }
    };
    /**
     * Free the resources used by the player.
     */
    Player.prototype.dispose = function () {
        // free resources linked to the loaded content
        this.stop();
        if (this.videoElement) {
            // free resources used for EME management
            eme_1.disposeEME(this.videoElement);
        }
        // free Observables linked to the Player instance
        this._priv_destroy$.next();
        this._priv_destroy$.complete();
        // Complete all subjects
        this._priv_stopCurrentContent$.complete();
        this._priv_playing$.complete();
        this._priv_speed$.complete();
        this._priv_streamLock$.complete();
        this._priv_bufferOptions.wantedBufferAhead$.complete();
        this._priv_bufferOptions.maxBufferAhead$.complete();
        this._priv_bufferOptions.maxBufferBehind$.complete();
        // un-attach video element
        this.videoElement = null;
    };
    /**
     * Load a new video.
     * @param {Object} opts
     * @returns {Observable}
     * @throws Error - throws if no url is given.
     * @throws Error - throws if no transport is given and no default transport
     * has been set.
     * @throws Error - throws if the asked transport does not exist
     */
    Player.prototype.loadVideo = function (opts) {
        var _this = this;
        var options = option_parsers_1.parseLoadVideoOptions(opts);
        log_1.default.info("loadvideo", options);
        var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, networkConfig = options.networkConfig, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
        // Perform multiple checks on the given options
        if (!this.videoElement) {
            throw new Error("the attached video element is disposed");
        }
        // now that every check has passed, stop previous content
        // TODO First stop?
        this.stop();
        var isDirectFile = transport === "directfile";
        this._priv_currentError = null;
        this._priv_contentInfos = {
            url: url,
            isDirectFile: isDirectFile,
            thumbnails: null,
            manifest: null,
            currentPeriod: null,
            activeAdaptations: null,
            activeRepresentations: null,
            initialAudioTrack: defaultAudioTrack,
            initialTextTrack: defaultTextTrack,
        };
        // inilialize to false
        this._priv_playing$.next(false);
        // get every properties used from context for clarity
        var videoElement = this.videoElement;
        /**
         * Global clock used for the whole application.
         * @type {Observable.<Object>}
         */
        var clock$ = clock_1.default(videoElement, {
            withMediaSource: !isDirectFile,
        });
        var closeStream$ = Observable_1.Observable.merge(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? events_1.onEnded$(videoElement) : Observable_1.Observable.empty()).take(1);
        var stream;
        if (!isDirectFile) {
            var transportFn = net_1.default[transport];
            if (!transportFn) {
                throw new Error("transport \"" + transport + "\" not supported");
            }
            var transportObj = transportFn(transportOptions);
            /**
             * Options used by the ABR Manager.
             * @type {Object}
             */
            var adaptiveOptions = {
                initialBitrates: this._priv_bitrateInfos.lastBitrates,
                manualBitrates: this._priv_bitrateInfos.manualBitrates,
                maxAutoBitrates: this._priv_bitrateInfos.initialMaxAutoBitrates,
                throttle: this._priv_throttleWhenHidden ? {
                    video: events_1.isInBackground$()
                        .map(function (isBg) { return isBg ? 0 : Infinity; })
                        .takeUntil(this._priv_stopCurrentContent$),
                } : {},
                limitWidth: this._priv_limitVideoWidth ? {
                    video: events_1.videoWidth$(videoElement)
                        .takeUntil(this._priv_stopCurrentContent$),
                } : {},
            };
            /**
             * Options used by the TextTrack SourceBuffer
             * @type {Object}
             */
            var textTrackOptions = options.textTrackMode === "native" ? {
                textTrackMode: "native",
                hideNativeSubtitle: options.hideNativeSubtitle,
            } : {
                textTrackMode: "html",
                textTrackElement: options.textTrackElement,
            };
            /**
             * Stream Observable, through which the content will be launched.
             * @type {Observable.<Object>}
             */
            stream = stream_1.default({
                adaptiveOptions: adaptiveOptions,
                autoPlay: autoPlay,
                bufferOptions: this._priv_bufferOptions,
                clock$: clock$,
                keySystems: keySystems,
                networkConfig: networkConfig,
                speed$: this._priv_speed$,
                startAt: startAt,
                supplementaryImageTracks: supplementaryImageTracks,
                supplementaryTextTracks: supplementaryTextTracks,
                textTrackOptions: textTrackOptions,
                transport: transportObj,
                url: url,
                videoElement: videoElement,
            })
                .takeUntil(closeStream$)
                .publish();
        }
        else {
            stream = directfile_1.default({
                autoPlay: autoPlay,
                clock$: clock$,
                keySystems: keySystems,
                mediaElement: videoElement,
                speed$: this._priv_speed$,
                startAt: startAt,
                url: url,
            })
                .takeUntil(closeStream$)
                .publish();
        }
        /**
         * Emit a truthy value when the player stalls, a falsy value as it unstalls.
         * TODO Find a way with TS
         * @type {Observable}
         */
        var stalled$ = stream
            .filter(function (_a) {
            var type = _a.type;
            return type === "stalled";
        })
            .map(function (x) { return x.value; });
        /**
         * Emit when the stream is considered "loaded".
         * @type {Observable}
         */
        var loaded = stream
            .filter(function (_a) {
            var type = _a.type;
            return type === "loaded";
        })
            .take(1)
            .share();
        /**
         * Emit when the media element emits an "ended" event.
         * @type {Observable}
         */
        var endedEvent$ = events_1.onEnded$(videoElement);
        /**
         * Emit when the media element emits a "seeking" event.
         * @type {Observable}
         */
        var seekingEvent$ = events_1.onSeeking$(videoElement);
        /**
         * Emit the player state as it changes.
         * TODO only way to call setPlayerState?
         * @type {Observable.<string>}
         */
        var stateChanges$ = loaded.mapTo(constants_1.PLAYER_STATES.LOADED)
            .concat(Observable_1.Observable.combineLatest(this._priv_playing$, stalled$.startWith(null), endedEvent$.startWith(null), seekingEvent$.startWith(null))
            .takeUntil(this._priv_stopCurrentContent$)
            .map(function (_a) {
            var isPlaying = _a[0], stalledStatus = _a[1];
            return get_player_state_1.default(videoElement, isPlaying, stalledStatus);
        })
            // begin emitting those only when the content start to play
            .skipUntil(this._priv_playing$.filter(function (isPlaying) { return isPlaying; })))
            .distinctUntilChanged()
            .startWith(constants_1.PLAYER_STATES.LOADING);
        /**
         * Emit true each time the player goes into a "play" state.
         * @type {Observable.<Boolean>}
         */
        var videoPlays$ = events_1.onPlayPause$(videoElement)
            .map(function (evt) { return evt.type === "play"; });
        var streamDisposable;
        this._priv_stopCurrentContent$.take(1).subscribe(function () {
            if (streamDisposable) {
                streamDisposable.unsubscribe();
            }
        });
        videoPlays$
            .takeUntil(this._priv_stopCurrentContent$)
            .subscribe(function (x) { return _this._priv_onPlayPauseNext(x); }, noop_1.default);
        clock$
            .takeUntil(this._priv_stopCurrentContent$)
            .subscribe(function (x) { return _this._priv_triggerTimeChange(x); }, noop_1.default);
        stateChanges$
            .takeUntil(this._priv_stopCurrentContent$)
            .subscribe(function (x) { return _this._priv_setPlayerState(x); }, noop_1.default);
        stream.subscribe(function (x) { return _this._priv_onStreamNext(x); }, function (err) { return _this._priv_onStreamError(err); }, function () { return _this._priv_onStreamComplete(); });
        // connect the stream when the lock is inactive
        this._priv_streamLock$
            .filter(function (isLocked) { return !isLocked; })
            .take(1)
            .takeUntil(this._priv_stopCurrentContent$)
            .subscribe(function () {
            streamDisposable = stream.connect();
        });
    };
    /**
     * Returns fatal error if one for the current content. null otherwise.
     * @returns {Object|null}
     */
    Player.prototype.getError = function () {
        return this._priv_currentError;
    };
    /**
     * Returns manifest/playlist object.
     * null if the player is STOPPED.
     * @returns {Manifest|null}
     */
    Player.prototype.getManifest = function () {
        return this._priv_contentInfos && this._priv_contentInfos.manifest;
    };
    /**
     * Returns adaptations (tracks) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
    Player.prototype.getCurrentAdaptations = function () {
        if (!this._priv_contentInfos) {
            return null;
        }
        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;
        if (!currentPeriod || !activeAdaptations) {
            return null;
        }
        return activeAdaptations.get(currentPeriod) || null;
    };
    /**
     * Returns representations (qualities) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
    Player.prototype.getCurrentRepresentations = function () {
        if (!this._priv_contentInfos) {
            return null;
        }
        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeRepresentations = _a.activeRepresentations;
        if (!currentPeriod || !activeRepresentations) {
            return null;
        }
        return activeRepresentations.get(currentPeriod) || null;
    };
    /**
     * Returns the video DOM element used by the player.
     * You should not its HTML5 API directly and use the player's method instead,
     * to ensure a well-behaved player.
     * @returns {HTMLMediaElement|null}
     */
    Player.prototype.getVideoElement = function () {
        return this.videoElement;
    };
    /**
     * Returns the text-track element used by the player to inject subtitles.
     * @returns {TextTrack}
     */
    Player.prototype.getNativeTextTrack = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        var textTracks = videoElement.textTracks;
        if (textTracks.length > 0) {
            return videoElement.textTracks[0];
        }
        else {
            return null;
        }
    };
    /**
     * Returns the player's current state.
     * @returns {string}
     */
    Player.prototype.getPlayerState = function () {
        return this.state;
    };
    /**
     * Returns true if:
     *   - a content is loaded
     *   - the content is a live content
     * @returns {Boolean}
     */
    Player.prototype.isLive = function () {
        if (!this._priv_contentInfos) {
            return false;
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;
        if (isDirectFile || !manifest) {
            return false;
        }
        return manifest.isLive;
    };
    /**
     * Returns the url of the content's manifest
     * @returns {string|undefined}
     */
    Player.prototype.getUrl = function () {
        if (!this._priv_contentInfos) {
            return undefined;
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest, url = _a.url;
        if (isDirectFile) {
            return url;
        }
        if (manifest) {
            return manifest.getUrl();
        }
        return undefined;
    };
    /**
     * Returns the video duration, in seconds.
     * NaN if no video is playing.
     * @returns {Number}
     */
    Player.prototype.getVideoDuration = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.duration;
    };
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the current time
     * @returns {Number}
     */
    Player.prototype.getVideoBufferGap = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getLeftSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    Player.prototype.getVideoLoadedTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Returns in seconds the difference between:
     *   - the current time.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    Player.prototype.getVideoPlayedTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getPlayedSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Get the current position, in s, in wall-clock time.
     * That is:
     *   - for live content, get a timestamp, in s, of the current played content.
     *   - for static content, returns the position from beginning in s.
     *
     * If you do not know if you want to use this method or getPosition:
     *   - If what you want is to display the current time to the user, use this
     *     one.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use getPosition.
     *
     * @returns {Number}
     */
    Player.prototype.getWallClockTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        if (!this._priv_contentInfos) {
            return this.videoElement.currentTime;
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;
        if (isDirectFile) {
            return this.videoElement.currentTime;
        }
        if (manifest) {
            var currentTime = this.videoElement.currentTime;
            return this.isLive() ?
                (+timings_1.toWallClockTime(currentTime, manifest) / 1000) :
                currentTime;
        }
        return 0;
    };
    /**
     * Get the current position, in seconds, of the video element.
     *
     * If you do not know if you want to use this method or getWallClockTime:
     *   - If what you want is to display the current time to the user, use
     *     getWallClockTime.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use this one.
     *
     * @returns {Number}
     */
    Player.prototype.getPosition = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.currentTime;
    };
    /**
     * Returns the current speed at which the video plays.
     * @returns {Number}
     */
    Player.prototype.getPlaybackRate = function () {
        return this._priv_speed$.getValue();
    };
    /**
     * @returns {Number}
     */
    Player.prototype.getVolume = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.volume;
    };
    /**
     * @returns {Boolean}
     */
    Player.prototype.isFullscreen = function () {
        return compat_1.isFullscreen();
    };
    /**
     * @returns {Array.<Number>}
     */
    Player.prototype.getAvailableVideoBitrates = function () {
        if (!this._priv_contentInfos) {
            return [];
        }
        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;
        if (!currentPeriod || !activeAdaptations) {
            return [];
        }
        var adaptations = activeAdaptations.get(currentPeriod);
        var videoAdaptation = adaptations && adaptations.video;
        if (!videoAdaptation) {
            return [];
        }
        return videoAdaptation.representations
            .map(function (_a) {
            var bitrate = _a.bitrate;
            return bitrate;
        });
    };
    /**
     * @returns {Array.<Number>}
     */
    Player.prototype.getAvailableAudioBitrates = function () {
        if (!this._priv_contentInfos) {
            return [];
        }
        var _a = this._priv_contentInfos, currentPeriod = _a.currentPeriod, activeAdaptations = _a.activeAdaptations;
        if (!currentPeriod || !activeAdaptations) {
            return [];
        }
        var adaptations = activeAdaptations.get(currentPeriod);
        var audioAdaptation = adaptations && adaptations.audio;
        if (!audioAdaptation) {
            return [];
        }
        return audioAdaptation.representations
            .map(function (_a) {
            var bitrate = _a.bitrate;
            return bitrate;
        });
    };
    /**
     * Returns the manual audio bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    Player.prototype.getManualAudioBitrate = function () {
        return this._priv_bitrateInfos.manualBitrates.audio;
    };
    /**
     * Returns the manual video bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    Player.prototype.getManualVideoBitrate = function () {
        return this._priv_bitrateInfos.manualBitrates.video;
    };
    /**
     * Returns currently considered bitrate for video segments.
     * @returns {Number|undefined}
     */
    Player.prototype.getVideoBitrate = function () {
        var representations = this.getCurrentRepresentations();
        if (!representations || !representations.video) {
            return undefined;
        }
        return representations.video.bitrate;
    };
    /**
     * Returns currently considered bitrate for audio segments.
     * @returns {Number|undefined}
     */
    Player.prototype.getAudioBitrate = function () {
        var representations = this.getCurrentRepresentations();
        if (!representations || !representations.audio) {
            return undefined;
        }
        return representations.audio.bitrate;
    };
    /**
     * Returns max wanted video bitrate currently set.
     * @returns {Number}
     */
    Player.prototype.getMaxVideoBitrate = function () {
        if (!this._priv_abrManager) {
            return this._priv_bitrateInfos.initialMaxAutoBitrates.video;
        }
        return this._priv_abrManager.getMaxAutoBitrate("video");
    };
    /**
     * Returns max wanted audio bitrate currently set.
     * @returns {Number}
     */
    Player.prototype.getMaxAudioBitrate = function () {
        if (!this._priv_abrManager) {
            return this._priv_bitrateInfos.initialMaxAutoBitrates.audio;
        }
        return this._priv_abrManager.getMaxAutoBitrate("audio");
    };
    /**
     * Play/Resume the current video.
     */
    Player.prototype.play = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        /* tslint:disable no-floating-promises */
        this.videoElement.play();
        /* tslint:enable no-floating-promises */
    };
    /**
     * Pause playback of the video.
     */
    Player.prototype.pause = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        this.videoElement.pause();
    };
    /**
     * Update the playback rate of the video.
     * @param {Number} rate
     */
    Player.prototype.setPlaybackRate = function (rate) {
        this._priv_speed$.next(rate);
    };
    /**
     * Seek to a given absolute position.
     * @param {Number|Object} time
     * @returns {Number} - The time the player has seek to
     */
    Player.prototype.seekTo = function (time) {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        if (!this._priv_contentInfos) {
            throw new Error("player: no content loaded");
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;
        if (!isDirectFile && !manifest) {
            throw new Error("player: the content did not load yet");
        }
        var positionWanted;
        var typeOf = typeof time;
        if (typeOf === "number") {
            positionWanted = time;
        }
        else if (typeOf === "object") {
            var currentTs = this.videoElement.currentTime;
            if (time.relative != null) {
                positionWanted = currentTs + time.relative;
            }
            else if (time.position != null) {
                positionWanted = time.position;
            }
            else if (time.wallClockTime != null) {
                positionWanted = isDirectFile ?
                    time.wallClockTime :
                    timings_1.fromWallClockTime(time.wallClockTime * 1000, manifest // is TS or I dumb here?
                    );
            }
            else {
                throw new Error("invalid time object. You must set one of the " +
                    "following properties: \"relative\", \"position\" or " +
                    "\"wallClockTime\"");
            }
        }
        if (positionWanted === undefined) {
            throw new Error("invalid time given");
        }
        this.videoElement.currentTime = positionWanted;
        return positionWanted;
    };
    Player.prototype.exitFullscreen = function () {
        compat_1.exitFullscreen();
    };
    /**
     * Set/exit fullScreen.
     * @param {Boolean} [goFull=true] - if false, exit full screen.
     */
    Player.prototype.setFullscreen = function (goFull) {
        if (goFull === void 0) { goFull = true; }
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        if (goFull) {
            compat_1.requestFullscreen(this.videoElement);
        }
        else {
            compat_1.exitFullscreen();
        }
    };
    /**
     * Set the player's volume. From 0 (muted volume) to 1 (maximum volume).
     * @param {Number}
     */
    Player.prototype.setVolume = function (volume) {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        if (volume !== videoElement.volume) {
            videoElement.volume = volume;
            this.trigger("volumeChange", volume);
        }
    };
    /**
     * Returns true if the volume is set to 0. false otherwise.
     * @returns {Boolean}
     */
    Player.prototype.isMute = function () {
        return !this.getVolume();
    };
    /**
     * Set the volume to 0 and save current one for when unmuted.
     */
    Player.prototype.mute = function () {
        this._priv_mutedMemory = this.getVolume();
        this.setVolume(0);
    };
    /**
     * Set the volume back to when it was when mute was last called.
     * If the volume was set to 0, set a default volume instead (see config).
     */
    Player.prototype.unMute = function () {
        var vol = this.getVolume();
        if (vol === 0) {
            this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
        }
    };
    /**
     * Force the video bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    Player.prototype.setVideoBitrate = function (btr) {
        this._priv_bitrateInfos.manualBitrates.video = btr;
        if (this._priv_abrManager) {
            this._priv_abrManager.setManualBitrate("video", btr);
        }
    };
    /**
     * Force the audio bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    Player.prototype.setAudioBitrate = function (btr) {
        this._priv_bitrateInfos.manualBitrates.audio = btr;
        if (this._priv_abrManager) {
            this._priv_abrManager.setManualBitrate("audio", btr);
        }
    };
    /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
    Player.prototype.setMaxVideoBitrate = function (btr) {
        // set it for the next content loaded
        this._priv_bitrateInfos.initialMaxAutoBitrates.video = btr;
        // set it for the current if one is loaded
        if (this._priv_abrManager) {
            this._priv_abrManager.setMaxAutoBitrate("video", btr);
        }
    };
    /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
    Player.prototype.setMaxAudioBitrate = function (btr) {
        // set it for the next content loaded
        this._priv_bitrateInfos.initialMaxAutoBitrates.audio = btr;
        // set it for the current if one is loaded
        if (this._priv_abrManager) {
            this._priv_abrManager.setMaxAutoBitrate("audio", btr);
        }
    };
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    Player.prototype.setMaxBufferBehind = function (depthInSeconds) {
        this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
    };
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    Player.prototype.setMaxBufferAhead = function (depthInSeconds) {
        this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
    };
    /**
     * Set the max buffer size for the buffer ahead of the current position.
     * The player will stop downloading chunks when this size is reached.
     * @param {Number} sizeInSeconds
     */
    Player.prototype.setWantedBufferAhead = function (sizeInSeconds) {
        this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
    };
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    Player.prototype.getMaxBufferBehind = function () {
        return this._priv_bufferOptions.maxBufferBehind$.getValue();
    };
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    Player.prototype.getMaxBufferAhead = function () {
        return this._priv_bufferOptions.maxBufferAhead$.getValue();
    };
    /**
     * Returns the max buffer size for the buffer ahead of the current position.
     * @returns {Number}
     */
    Player.prototype.getWantedBufferAhead = function () {
        return this._priv_bufferOptions.wantedBufferAhead$.getValue();
    };
    /**
     * Returns type of current keysystem (e.g. playready, widevine) if the content
     * is encrypted. null otherwise.
     * @returns {string|null}
     */
    Player.prototype.getCurrentKeySystem = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return eme_1.getCurrentKeySystem(this.videoElement);
    };
    /**
     * Returns every available audio tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
    Player.prototype.getAvailableAudioTracks = function () {
        if (!this._priv_contentInfos) {
            return [];
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            return [];
        }
        return this._priv_languageManager.getAvailableAudioTracks(currentPeriod);
    };
    /**
     * Returns every available text tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
    Player.prototype.getAvailableTextTracks = function () {
        if (!this._priv_contentInfos) {
            return [];
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            return [];
        }
        return this._priv_languageManager.getAvailableTextTracks(currentPeriod);
    };
    /**
     * Returns currently chosen audio language for the current Period.
     * @returns {string}
     */
    Player.prototype.getAudioTrack = function () {
        if (!this._priv_contentInfos) {
            return undefined;
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            return undefined;
        }
        return this._priv_languageManager.getChosenAudioTrack(currentPeriod);
    };
    /**
     * Returns currently chosen subtitle for the current Period.
     * @returns {string}
     */
    Player.prototype.getTextTrack = function () {
        if (!this._priv_contentInfos) {
            return undefined;
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            return undefined;
        }
        return this._priv_languageManager.getChosenTextTrack(currentPeriod);
    };
    /**
     * Update the audio language for the current Period.
     * @param {string} audioId
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no audio track.
     */
    Player.prototype.setAudioTrack = function (audioId) {
        if (!this._priv_contentInfos) {
            throw new Error("No content loaded");
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_languageManager.setAudioTrackByID(currentPeriod, audioId);
        }
        catch (e) {
            throw new Error("player: unknown audio track");
        }
    };
    /**
     * Update the text language for the current Period.
     * @param {string} sub
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no text track.
     */
    Player.prototype.setTextTrack = function (textId) {
        if (!this._priv_contentInfos) {
            throw new Error("No content loaded");
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_languageManager.setTextTrackByID(currentPeriod, textId);
        }
        catch (e) {
            throw new Error("player: unknown text track");
        }
    };
    /**
     * Disable subtitles for the current content.
     */
    Player.prototype.disableTextTrack = function () {
        if (!this._priv_contentInfos) {
            return;
        }
        var currentPeriod = this._priv_contentInfos.currentPeriod;
        if (!this._priv_languageManager || !currentPeriod) {
            return;
        }
        return this._priv_languageManager.disableTextTrack(currentPeriod);
    };
    /**
     * @returns {Array.<Object>|null}
     */
    Player.prototype.getImageTrackData = function () {
        return this._priv_contentInfos && this._priv_contentInfos.thumbnails;
    };
    /**
     * Get minimum seek-able position.
     * @returns {number}
     */
    Player.prototype.getMinimumPosition = function () {
        if (!this._priv_contentInfos) {
            return null;
        }
        if (this._priv_contentInfos.isDirectFile) {
            return 0;
        }
        var manifest = this._priv_contentInfos.manifest;
        if (manifest) {
            return timings_1.getMinimumBufferPosition(manifest);
        }
        return null;
    };
    /**
     * Get maximum seek-able position.
     * @returns {number}
     */
    Player.prototype.getMaximumPosition = function () {
        if (!this._priv_contentInfos) {
            return null;
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;
        if (isDirectFile) {
            if (!this.videoElement) {
                throw new Error("Disposed player");
            }
            return this.videoElement.duration;
        }
        if (manifest) {
            return timings_1.getMaximumBufferPosition(manifest);
        }
        return null;
    };
    /**
     * Reset all state properties relative to a playing content.
     */
    Player.prototype._priv_cleanUpCurrentContentState = function () {
        var _this = this;
        // lock creation of new streams while cleaning up is pending
        this._priv_streamLock$.next(true);
        this._priv_contentInfos = null;
        this._priv_languageManager = null;
        if (this._priv_abrManager) {
            this._priv_abrManager.dispose();
            this._priv_abrManager = null;
        }
        this._priv_contentEventsMemory = {
            period: null,
            audioTrack: null,
            textTrack: null,
            videoBitrate: null,
            audioBitrate: null,
            bitrateEstimation: undefined,
        };
        // EME cleaning
        var freeUpStreamLock = function () {
            _this._priv_streamLock$.next(false);
        };
        if (this.videoElement) {
            eme_1.clearEMESession(this.videoElement)
                .catch(function () { return Observable_1.Observable.empty(); })
                .subscribe(noop_1.default, freeUpStreamLock, freeUpStreamLock);
        }
        else {
            freeUpStreamLock();
        }
    };
    Player.prototype._priv_triggerContentEvent = function (type, value) {
        var prev = this._priv_contentEventsMemory[type];
        if (!deepEqual(prev, value)) {
            this._priv_contentEventsMemory[type] = value;
            // SAD
            this.trigger(type + "Change", value);
        }
    };
    /**
     * Triggered each time the Stream Observable emits.
     *
     * React to various events.
     *
     * @param {Object} streamInfos - payload emitted
     */
    Player.prototype._priv_onStreamNext = function (streamInfos) {
        switch (streamInfos.type) {
            case "activePeriodChanged":
                this._priv_onActivePeriodChanged(streamInfos.value);
                break;
            case "periodBufferReady":
                this._priv_onPeriodBufferReady(streamInfos.value);
                break;
            case "periodBufferCleared":
                this._priv_onPeriodBufferCleared(streamInfos.value);
                break;
            case "representationChange":
                this._priv_onRepresentationChange(streamInfos.value);
                break;
            case "adaptationChange":
                this._priv_onAdaptationChange(streamInfos.value);
                break;
            case "manifestUpdate":
                this._priv_onManifestUpdate(streamInfos.value);
                break;
            case "bitrateEstimationChange":
                this._priv_onBitrateEstimationChange(streamInfos.value);
                break;
            case "manifestReady":
                this._priv_onManifestReady(streamInfos.value);
                break;
            case "warning":
                this._priv_onStreamWarning(streamInfos.value);
                break;
            case "added-segment":
                if (!this._priv_contentInfos) {
                    log_1.default.error("Added segment while no content is loaded");
                    return;
                }
                // Manage image tracks
                // TODO Better way? Perhaps linked to an ImageSourceBuffer
                // implementation
                var _a = streamInfos.value, bufferType = _a.bufferType, segmentData = _a.segmentData;
                if (bufferType === "image") {
                    if (segmentData != null && segmentData.type === "bif") {
                        var imageData = segmentData.data;
                        // TODO merge multiple data from the same track together
                        this._priv_contentInfos.thumbnails = imageData;
                        this.trigger("imageTrackUpdate", {
                            data: this._priv_contentInfos.thumbnails,
                        });
                    }
                }
        }
    };
    /**
     * Triggered when the Stream throws (fatal errors).
     *
     * Clean-up ressources and signal that the content has stopped on error.
     *
     * @param {Error} error
     */
    Player.prototype._priv_onStreamError = function (error) {
        this._priv_stopCurrentContent$.next();
        this._priv_cleanUpCurrentContentState();
        this._priv_currentError = error;
        this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        // TODO This condition is here because the eventual callback called when the
        // player state is updated can launch a new content, thus the error will not
        // be here anymore, in which case triggering the "error" event is unwanted.
        // This is very ugly though, and we should probable have a better solution
        if (this._priv_currentError === error) {
            this.trigger("error", error);
        }
    };
    /**
     * Triggered when the Stream instance ends.
     *
     * Clean-up ressources and signal that the content has ended.
     */
    Player.prototype._priv_onStreamComplete = function () {
        this._priv_stopCurrentContent$.next();
        this._priv_cleanUpCurrentContentState();
        this._priv_setPlayerState(constants_1.PLAYER_STATES.ENDED);
    };
    /**
     * Triggered when the Stream emits a warning.
     *
     * Trigger the right Player event.
     * @param {Object} streamInfos
     */
    Player.prototype._priv_onStreamWarning = function (error) {
        this.trigger("warning", error);
    };
    /**
     * Triggered when the stream starts.
     *
     * Initialize various private properties and emit initial event.
     *
     * @param {Object} value
     * @param {Manifest} value.manifest - The Manifest instance
     * @param {Object} value.abrManager - ABR manager which can be used to select
     * the wanted bandwidth.
     */
    Player.prototype._priv_onManifestReady = function (value) {
        if (!this._priv_contentInfos) {
            log_1.default.error("The manifest is loaded but no content is.");
            return;
        }
        var manifest = value.manifest, abrManager = value.abrManager;
        this._priv_contentInfos.manifest = manifest;
        this._priv_abrManager = abrManager;
        var _a = this._priv_contentInfos, initialAudioTrack = _a.initialAudioTrack, initialTextTrack = _a.initialTextTrack;
        this._priv_languageManager = new language_manager_1.default({
            preferredAudioTracks: initialAudioTrack === undefined ?
                undefined : [initialAudioTrack],
            preferredTextTracks: initialTextTrack === undefined ?
                undefined : [initialTextTrack],
        });
        this.trigger("manifestChange", manifest);
    };
    /**
     * Triggered each times the current Period Changed.
     *
     * Store and emit initial state for the Period.
     *
     * @param {Object} value
     * @param {Period} value.period
     */
    Player.prototype._priv_onActivePeriodChanged = function (_a) {
        var period = _a.period;
        if (!this._priv_contentInfos) {
            log_1.default.error("The active period changed but no content is loaded");
            return;
        }
        this._priv_contentInfos.currentPeriod = period;
        this._priv_triggerContentEvent("period", period);
        // Emit intial events for the Period
        if (this._priv_languageManager) {
            var audioTrack = this._priv_languageManager.getChosenAudioTrack(period);
            var textTrack = this._priv_languageManager.getChosenTextTrack(period);
            this._priv_triggerContentEvent("audioTrack", audioTrack);
            this._priv_triggerContentEvent("textTrack", textTrack);
        }
        else {
            this._priv_triggerContentEvent("audioTrack", null);
            this._priv_triggerContentEvent("textTrack", null);
        }
        var activeAudioRepresentations = this.getCurrentRepresentations();
        if (activeAudioRepresentations && activeAudioRepresentations.audio != null) {
            var bitrate = activeAudioRepresentations.audio.bitrate;
            this._priv_triggerContentEvent("audioBitrate", bitrate != null ? bitrate : -1);
        }
        else {
            this._priv_triggerContentEvent("audioBitrate", null);
        }
        var activeVideoRepresentations = this.getCurrentRepresentations();
        if (activeVideoRepresentations && activeVideoRepresentations.video != null) {
            var bitrate = activeVideoRepresentations.video.bitrate;
            this._priv_triggerContentEvent("videoBitrate", bitrate != null ? bitrate : -1);
        }
        else {
            this._priv_triggerContentEvent("videoBitrate", null);
        }
    };
    /**
     * Triggered each times the Stream "prepares" a new Period, and
     * needs the API to send it its chosen Adaptation.
     *
     * Choose the right Adaptation for the Period and emit it.
     *
     * @param {Object} value
     * @param {string} value.type
     * @param {Period} value.period
     * @param {Subject} value.adaptation$
     */
    Player.prototype._priv_onPeriodBufferReady = function (value) {
        var type = value.type, period = value.period, adaptation$ = value.adaptation$;
        switch (type) {
            case "audio":
                if (!this._priv_languageManager) {
                    log_1.default.error("LanguageManager not instanciated for a new " + type + " period");
                    adaptation$.next(null);
                }
                else {
                    this._priv_languageManager.addPeriod(type, period, adaptation$);
                    this._priv_languageManager.setInitialAudioTrack(period);
                }
                break;
            case "text":
                if (!this._priv_languageManager) {
                    log_1.default.error("LanguageManager not instanciated for a new " + type + " period");
                    adaptation$.next(null);
                }
                else {
                    this._priv_languageManager.addPeriod(type, period, adaptation$);
                    this._priv_languageManager.setInitialTextTrack(period);
                }
                break;
            default:
                var adaptations = period.adaptations[type];
                if (adaptations && adaptations.length) {
                    adaptation$.next(adaptations[0]);
                }
                else {
                    adaptation$.next(null);
                }
                break;
        }
    };
    /**
     * Triggered each times the Stream "removes" a Period.
     *
     * Update the LanguageManager to remove the corresponding Period.
     *
     * @param {Object} value
     * @param {Period} value.period
     */
    Player.prototype._priv_onPeriodBufferCleared = function (value) {
        var type = value.type, period = value.period;
        if (type === "audio" || type === "text") {
            if (this._priv_languageManager) {
                this._priv_languageManager.removePeriod(type, period);
            }
        }
    };
    /**
     * Triggered each times the Manifest is updated.
     *
     * Update the LanguageManager and emit events.
     *
     * @param {Object} value
     * @param {Manifest} value.manifest
     */
    Player.prototype._priv_onManifestUpdate = function (value) {
        if (!this._priv_contentInfos) {
            log_1.default.error("The manifest is updated but no content is loaded.");
            return;
        }
        var manifest = value.manifest;
        this._priv_contentInfos.manifest = manifest;
        // Update the languages chosen if it changed
        if (this._priv_languageManager) {
            this._priv_languageManager.update();
        }
        this.trigger("manifestUpdate", manifest);
    };
    /**
     * Triggered each times a new Adaptation is considered by the Stream.
     *
     * Store given Adaptation and emit it if from the current Period.
     *
     * @param {Object} value
     * @param {string} value.type
     * @param {Period} value.period
     * @param {Adaptation} value.adaptation
     */
    Player.prototype._priv_onAdaptationChange = function (_a) {
        var type = _a.type, adaptation = _a.adaptation, period = _a.period;
        if (!this._priv_contentInfos) {
            log_1.default.error("The adaptations changed but no content is loaded");
            return;
        }
        // lazily create this._priv_contentInfos.activeAdaptations
        if (!this._priv_contentInfos.activeAdaptations) {
            this._priv_contentInfos.activeAdaptations = new Map();
        }
        var _b = this._priv_contentInfos, activeAdaptations = _b.activeAdaptations, currentPeriod = _b.currentPeriod;
        var activePeriodAdaptations = activeAdaptations.get(period);
        if (!activePeriodAdaptations) {
            activeAdaptations.set(period, (_c = {}, _c[type] = adaptation, _c));
        }
        else {
            activePeriodAdaptations[type] = adaptation;
        }
        if (this._priv_languageManager &&
            period != null && period === currentPeriod) {
            if (type === "audio") {
                var audioTrack = this._priv_languageManager
                    .getChosenAudioTrack(currentPeriod);
                this._priv_triggerContentEvent("audioTrack", audioTrack);
            }
            else if (type === "text") {
                var textTrack = this._priv_languageManager
                    .getChosenTextTrack(currentPeriod);
                this._priv_triggerContentEvent("textTrack", textTrack);
            }
        }
        var _c;
    };
    /**
     * Triggered each times a new Representation is considered by the Stream.
     *
     * Store given Representation and emit it if from the current Period.
     *
     * @param {Object} obj
     * @param {string} obj.type
     * @param {Object} obj.representation
     */
    Player.prototype._priv_onRepresentationChange = function (_a) {
        var type = _a.type, period = _a.period, representation = _a.representation;
        if (!this._priv_contentInfos) {
            log_1.default.error("The representations changed but no content is loaded");
            return;
        }
        // lazily create this._priv_contentInfos.activeRepresentations
        if (!this._priv_contentInfos.activeRepresentations) {
            this._priv_contentInfos.activeRepresentations = new Map();
        }
        var _b = this._priv_contentInfos, activeRepresentations = _b.activeRepresentations, currentPeriod = _b.currentPeriod;
        var activePeriodRepresentations = activeRepresentations.get(period);
        if (!activePeriodRepresentations) {
            activeRepresentations.set(period, (_c = {}, _c[type] = representation, _c));
        }
        else {
            activePeriodRepresentations[type] = representation;
        }
        var bitrate = representation && representation.bitrate;
        if (bitrate != null) {
            this._priv_bitrateInfos.lastBitrates[type] = bitrate;
        }
        if (period != null && currentPeriod === period) {
            if (type === "video") {
                this._priv_triggerContentEvent("videoBitrate", bitrate != null ? bitrate : -1);
            }
            else if (type === "audio") {
                this._priv_triggerContentEvent("audioBitrate", bitrate != null ? bitrate : -1);
            }
        }
        var _c;
    };
    /**
     * Triggered each time a bitrate estimate is calculated.
     *
     * Emit it.
     *
     * @param {Object} value
     * @param {string} value.type
     * @param {number|undefined} value.bitrate
     */
    Player.prototype._priv_onBitrateEstimationChange = function (_a) {
        var type = _a.type, bitrate = _a.bitrate;
        if (false) {}
        this._priv_triggerContentEvent("bitrateEstimation", { type: type, bitrate: bitrate });
    };
    /**
     * Triggered each time the videoElement alternates between play and pause.
     *
     * Emit the info through the right Subject.
     *
     * @param {Boolean} isPlaying
     */
    Player.prototype._priv_onPlayPauseNext = function (isPlaying) {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        this._priv_playing$.next(isPlaying);
    };
    /**
     * Triggered each time a textTrack is added to the video DOM Element.
     *
     * Trigger the right Player Event.
     *
     * @param {Array.<TextTrackElement} tracks
     */
    Player.prototype._priv_onNativeTextTracksNext = function (tracks) {
        this.trigger("nativeTextTracksChange", tracks);
    };
    /**
     * Triggered each time the player state updates.
     *
     * Trigger the right Player Event.
     *
     * @param {string} newState
     */
    Player.prototype._priv_setPlayerState = function (newState) {
        if (this.state !== newState) {
            this.state = newState;
            log_1.default.info("playerStateChange", newState);
            this.trigger("playerStateChange", newState);
        }
    };
    /**
     * Triggered each time a new clock tick object is emitted.
     *
     * Trigger the right Player Event
     *
     * @param {Object} clockTick
     */
    Player.prototype._priv_triggerTimeChange = function (clockTick) {
        if (!this._priv_contentInfos) {
            log_1.default.warn("Cannot perform time update: no content loaded.");
            return;
        }
        var _a = this._priv_contentInfos, isDirectFile = _a.isDirectFile, manifest = _a.manifest;
        if ((!isDirectFile && !manifest) || !clockTick) {
            return;
        }
        var positionData = {
            position: clockTick.currentTime,
            duration: clockTick.duration,
            playbackRate: clockTick.playbackRate,
            // TODO fix higher up?
            bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0,
        };
        if (manifest &&
            manifest.isLive &&
            clockTick.currentTime > 0) {
            positionData.wallClockTime =
                timings_1.toWallClockTime(clockTick.currentTime, manifest)
                    .getTime() / 1000;
            positionData.liveGap =
                timings_1.getMaximumBufferPosition(manifest) - clockTick.currentTime;
        }
        this.trigger("positionUpdate", positionData);
    };
    return Player;
}(eventemitter_1.default));
exports.default = Player;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var withLatestFrom_1 = __webpack_require__(248);
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);
}
exports.withLatestFrom = withLatestFrom;
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var withLatestFrom_1 = __webpack_require__(249);
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;
//# sourceMappingURL=withLatestFrom.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(25);
var isDate_1 = __webpack_require__(103);
var Subscriber_1 = __webpack_require__(3);
var TimeoutError_1 = __webpack_require__(97);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(25);
var timeout_1 = __webpack_require__(251);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeout_1.timeout(due, scheduler)(this);
}
exports.timeout = timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timeout_1 = __webpack_require__(252);
Observable_1.Observable.prototype.timeout = timeout_1.timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var takeUntil_1 = __webpack_require__(254);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value, the output Observable stops mirroring the source Observable
 * and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return takeUntil_1.takeUntil(notifier)(this);
}
exports.takeUntil = takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeUntil_1 = __webpack_require__(255);
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var ArgumentOutOfRangeError_1 = __webpack_require__(98);
var EmptyObservable_1 = __webpack_require__(26);
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var takeLast_1 = __webpack_require__(257);
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast(count) {
    return takeLast_1.takeLast(count)(this);
}
exports.takeLast = takeLast;
//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeLast_1 = __webpack_require__(258);
Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;
//# sourceMappingURL=takeLast.js.map

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var ArgumentOutOfRangeError_1 = __webpack_require__(98);
var EmptyObservable_1 = __webpack_require__(26);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var take_1 = __webpack_require__(260);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return take_1.take(count)(this);
}
exports.take = take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var take_1 = __webpack_require__(261);
Observable_1.Observable.prototype.take = take_1.take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMapTo_1 = __webpack_require__(263);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);
}
exports.switchMapTo = switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMapTo_1 = __webpack_require__(264);
Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMap_1 = __webpack_require__(266);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return switchMap_1.switchMap(project, resultSelector)(this);
}
exports.switchMap = switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMap_1 = __webpack_require__(267);
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(22);
var ScalarObservable_1 = __webpack_require__(61);
var EmptyObservable_1 = __webpack_require__(26);
var concat_1 = __webpack_require__(41);
var isScheduler_1 = __webpack_require__(27);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1) {
            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
        }
        else if (len > 1) {
            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
        }
        else {
            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
        }
    };
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var startWith_1 = __webpack_require__(269);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return startWith_1.startWith.apply(void 0, array)(this);
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var startWith_1 = __webpack_require__(270);
Observable_1.Observable.prototype.startWith = startWith_1.startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var skipWhile_1 = __webpack_require__(272);
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile(predicate) {
    return skipWhile_1.skipWhile(predicate)(this);
}
exports.skipWhile = skipWhile;
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skipWhile_1 = __webpack_require__(273);
Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;
//# sourceMappingURL=skipWhile.js.map

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var skipUntil_1 = __webpack_require__(275);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return skipUntil_1.skipUntil(notifier)(this);
}
exports.skipUntil = skipUntil;
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skipUntil_1 = __webpack_require__(276);
Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var skip_1 = __webpack_require__(278);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return skip_1.skip(count)(this);
}
exports.skip = skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skip_1 = __webpack_require__(279);
Observable_1.Observable.prototype.skip = skip_1.skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(58);
var refCount_1 = __webpack_require__(99);
var Subject_1 = __webpack_require__(7);
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .multicast(() => new Subject()).refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var share_1 = __webpack_require__(281);
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 *
 * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.
 * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.
 * Observable.of("test").publish().refCount() will not re-emit "test" on new subscriptions, Observable.of("test").share() will
 * re-emit "test" to new subscriptions.
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return share_1.share()(this);
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var share_1 = __webpack_require__(282);
Observable_1.Observable.prototype.share = share_1.share;
//# sourceMappingURL=share.js.map

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var scan_1 = __webpack_require__(284);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    if (arguments.length >= 2) {
        return scan_1.scan(accumulator, seed)(this);
    }
    return scan_1.scan(accumulator)(this);
}
exports.scan = scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var scan_1 = __webpack_require__(285);
Observable_1.Observable.prototype.scan = scan_1.scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subject_1 = __webpack_require__(7);
var multicast_1 = __webpack_require__(58);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var publish_1 = __webpack_require__(287);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return publish_1.publish(selector)(this);
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publish_1 = __webpack_require__(288);
Observable_1.Observable.prototype.publish = publish_1.publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var pairwise_1 = __webpack_require__(290);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return pairwise_1.pairwise()(this);
}
exports.pairwise = pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var pairwise_1 = __webpack_require__(291);
Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(17);
var refCount_1 = __webpack_require__(99);
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(58);
/* tslint:enable:max-line-length */
/**
 * Allows source Observable to be subscribed only once with a Subject of choice,
 * while still sharing its values between multiple subscribers.
 *
 * <span class="informal">Subscribe to Observable once, but send its values to multiple subscribers.</span>
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * `multicast` is an operator that works in two modes.
 *
 * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject
 * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be
 * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that
 * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when
 * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription
 * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,
 * even though usually it would send a request per every subscriber. Since it sends a request at the moment of
 * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.
 *
 * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,
 * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source
 * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,
 * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count
 * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least
 * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a
 * ConnectableObservable, use `refCount`.
 *
 * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.
 * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable
 * as well, which should be the input stream modified by any operators you want. Note that in this
 * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If
 * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.
 * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,
 * if inside the selector function you subscribe to the input Observable multiple times, actual source stream
 * will be subscribed only once. So if you have a chain of operators that use some Observable many times,
 * but you want to subscribe to that Observable only once, this is the mode you would use.
 *
 * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the
 * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject
 * has some special properties, Observable returned by `multicast` will have them as well. If you want to use
 * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},
 * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},
 * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually
 * just wrappers around `multicast`, with a specific Subject hardcoded inside.
 *
 * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,
 * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.
 *
 * @example <caption>Use ConnectableObservable</caption>
 * const seconds = Rx.Observable.interval(1000);
 * const connectableSeconds = seconds.multicast(new Subject());
 *
 * connectableSeconds.subscribe(value => console.log('first: ' + value));
 * connectableSeconds.subscribe(value => console.log('second: ' + value));
 *
 * // At this point still nothing happens, even though we subscribed twice.
 *
 * connectableSeconds.connect();
 *
 * // From now on `seconds` are being logged to the console,
 * // twice per every second. `seconds` Observable was however only subscribed once,
 * // so under the hood Observable.interval had only one clock started.
 *
 * @example <caption>Use selector</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds
 *     .multicast(
 *         () => new Subject(),
 *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.
 *                                         // Because we are inside selector, `seconds` is subscribed once,
 *     )                                   // thus starting only one clock used internally by Observable.interval.
 *     .subscribe();
 *
 * @see {@link publish}
 * @see {@link publishLast}
 * @see {@link publishBehavior}
 * @see {@link publishReplay}
 * @see {@link share}
 * @see {@link shareReplay}
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through
 * which the source sequence's elements will be multicast to the selector function input Observable or
 * ConnectableObservable returned by the operator.
 * @param {Function} [selector] - Optional selector function that can use the input stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the input source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector
 * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.
 *
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);
}
exports.multicast = multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var multicast_1 = __webpack_require__(294);
Observable_1.Observable.prototype.multicast = multicast_1.multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };
}
exports.mergeMapTo = mergeMapTo;
// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
var MergeMapToOperator = (function () {
    function MergeMapToOperator(ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapToOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
    };
    return MergeMapToOperator;
}());
exports.MergeMapToOperator = MergeMapToOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = (function (_super) {
    __extends(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapToSubscriber = MergeMapToSubscriber;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMapTo_1 = __webpack_require__(296);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);
}
exports.mergeMapTo = mergeMapTo;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeMapTo_1 = __webpack_require__(297);
Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
//# sourceMappingURL=mergeMapTo.js.map

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(59);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
}
exports.mergeMap = mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeMap_1 = __webpack_require__(299);
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(42);
var merge_2 = __webpack_require__(42);
exports.mergeStatic = merge_2.merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(301);
var merge_2 = __webpack_require__(42);
exports.mergeStatic = merge_2.merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return merge_1.merge.apply(void 0, observables)(this);
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(302);
Observable_1.Observable.prototype.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mapTo_1 = __webpack_require__(304);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return mapTo_1.mapTo(value)(this);
}
exports.mapTo = mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mapTo_1 = __webpack_require__(305);
Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(307);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return map_1.map(project, thisArg)(this);
}
exports.map = map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var map_1 = __webpack_require__(308);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var noop_1 = __webpack_require__(62);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ignoreElements_1 = __webpack_require__(310);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return ignoreElements_1.ignoreElements()(this);
}
exports.ignoreElements = ignoreElements;
;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ignoreElements_1 = __webpack_require__(311);
Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(17);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finalize.js.map

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var finalize_1 = __webpack_require__(313);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return finalize_1.finalize(callback)(this);
}
exports._finally = _finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var finally_1 = __webpack_require__(314);
Observable_1.Observable.prototype.finally = finally_1._finally;
Observable_1.Observable.prototype._finally = finally_1._finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var filter_1 = __webpack_require__(316);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return filter_1.filter(predicate, thisArg)(this);
}
exports.filter = filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var filter_1 = __webpack_require__(317);
Observable_1.Observable.prototype.filter = filter_1.filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = (function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = (function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        }
        catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var exhaustMap_1 = __webpack_require__(319);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return exhaustMap_1.exhaustMap(project, resultSelector)(this);
}
exports.exhaustMap = exhaustMap;
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var exhaustMap_1 = __webpack_require__(320);
Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;
//# sourceMappingURL=exhaustMap.js.map

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=tap.js.map

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var tap_1 = __webpack_require__(322);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return tap_1.tap(nextOrObserver, error, complete)(this);
}
exports._do = _do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var do_1 = __webpack_require__(323);
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var tryCatch_1 = __webpack_require__(65);
var errorObject_1 = __webpack_require__(43);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var distinctUntilChanged_1 = __webpack_require__(325);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);
}
exports.distinctUntilChanged = distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var distinctUntilChanged_1 = __webpack_require__(326);
Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var async_1 = __webpack_require__(25);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(25);
var debounceTime_1 = __webpack_require__(328);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return debounceTime_1.debounceTime(dueTime, scheduler)(this);
}
exports.debounceTime = debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var debounceTime_1 = __webpack_require__(329);
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMap_1 = __webpack_require__(101);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMapTo_1 = __webpack_require__(331);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return concatMapTo_1.concatMapTo(innerObservable, resultSelector)(this);
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatMapTo_1 = __webpack_require__(332);
Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;
//# sourceMappingURL=concatMapTo.js.map

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMap_1 = __webpack_require__(101);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return concatMap_1.concatMap(project, resultSelector)(this);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatMap_1 = __webpack_require__(334);
Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatAll_1 = __webpack_require__(102);
/* tslint:enable:max-line-length */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return concatAll_1.concatAll()(this);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatAll_1 = __webpack_require__(336);
Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(41);
var concat_2 = __webpack_require__(41);
exports.concatStatic = concat_2.concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(338);
var concat_2 = __webpack_require__(41);
exports.concatStatic = concat_2.concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return concat_1.concat.apply(void 0, observables)(this);
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concat_1 = __webpack_require__(339);
Observable_1.Observable.prototype.concat = concat_1.concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @name catchError
 */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catchError.js.map

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var catchError_1 = __webpack_require__(341);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    return catchError_1.catchError(selector)(this);
}
exports._catch = _catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var catch_1 = __webpack_require__(342);
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(108);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(25);
var isScheduler_1 = __webpack_require__(27);
var isDate_1 = __webpack_require__(103);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TimerObservable_1 = __webpack_require__(344);
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timer_1 = __webpack_require__(345);
Observable_1.Observable.timer = timer_1.timer;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = (function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        }
        else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable));
exports.ErrorObservable = ErrorObservable;
//# sourceMappingURL=ErrorObservable.js.map

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ErrorObservable_1 = __webpack_require__(347);
exports._throw = ErrorObservable_1.ErrorObservable.create;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var throw_1 = __webpack_require__(348);
Observable_1.Observable.throw = throw_1._throw;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(28);
var ArrayObservable_1 = __webpack_require__(22);
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `race([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;
//# sourceMappingURL=race.js.map

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var race_1 = __webpack_require__(350);
Observable_1.Observable.race = race_1.race;
//# sourceMappingURL=race.js.map

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var of_1 = __webpack_require__(104);
Observable_1.Observable.of = of_1.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var noop_1 = __webpack_require__(62);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var NeverObservable = (function (_super) {
    __extends(NeverObservable, _super);
    function NeverObservable() {
        _super.call(this);
    }
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please note
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.noop();
    };
    return NeverObservable;
}(Observable_1.Observable));
exports.NeverObservable = NeverObservable;
//# sourceMappingURL=NeverObservable.js.map

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NeverObservable_1 = __webpack_require__(353);
exports.never = NeverObservable_1.NeverObservable.create;
//# sourceMappingURL=never.js.map

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var never_1 = __webpack_require__(354);
Observable_1.Observable.never = never_1.never;
//# sourceMappingURL=never.js.map

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(42);
Observable_1.Observable.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(17);
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(108);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(25);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IntervalObservable = (function (_super) {
    __extends(IntervalObservable, _super);
    function IntervalObservable(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = async_1.async;
        }
    }
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified IScheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` IScheduler to provide a notion of time, but you may pass any
     * IScheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    IntervalObservable.create = function (period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        return new IntervalObservable(period, scheduler);
    };
    IntervalObservable.dispatch = function (state) {
        var index = state.index, subscriber = state.subscriber, period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };
    IntervalObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };
    return IntervalObservable;
}(Observable_1.Observable));
exports.IntervalObservable = IntervalObservable;
//# sourceMappingURL=IntervalObservable.js.map

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IntervalObservable_1 = __webpack_require__(360);
exports.interval = IntervalObservable_1.IntervalObservable.create;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var interval_1 = __webpack_require__(361);
Observable_1.Observable.interval = interval_1.interval;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PromiseObservable_1 = __webpack_require__(111);
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var tryCatch_1 = __webpack_require__(65);
var isFunction_1 = __webpack_require__(66);
var errorObject_1 = __webpack_require__(43);
var Subscription_1 = __webpack_require__(17);
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = (function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node.js
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * `fromEvent` accepts as a first argument event target, which is an object with methods
     * for registering event handler functions. As a second argument it takes string that indicates
     * type of event we want to listen for. `fromEvent` supports selected types of event targets,
     * which are described in detail below. If your event target does not match any of the ones listed,
     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
     * handler functions have different names, but they all accept a string describing event type
     * and function itself, which will be called whenever said event happens.
     *
     * Every time resulting Observable is subscribed, event handler function will be registered
     * to event target on given event type. When that event fires, value
     * passed as a first argument to registered function will be emitted by output Observable.
     * When Observable is unsubscribed, function will be unregistered from event target.
     *
     * Note that if event target calls registered function with more than one argument, second
     * and following arguments will not appear in resulting stream. In order to get access to them,
     * you can pass to `fromEvent` optional project function, which will be called with all arguments
     * passed to event handler. Output Observable will then emit value returned by project function,
     * instead of the usual value.
     *
     * Remember that event targets listed below are checked via duck typing. It means that
     * no matter what kind of object you have and no matter what environment you work in,
     * you can safely use `fromEvent` on that object if it exposes described methods (provided
     * of course they behave as was described above). So for example if Node.js library exposes
     * event target which has the same method names as DOM EventTarget, `fromEvent` is still
     * a good choice.
     *
     * If the API you use is more callback then event handler oriented (subscribed
     * callback function fires only once and thus there is no need to manually
     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
     * instead.
     *
     * `fromEvent` supports following types of event targets:
     *
     * **DOM EventTarget**
     *
     * This is an object with `addEventListener` and `removeEventListener` methods.
     *
     * In the browser, `addEventListener` accepts - apart from event type string and event
     * handler function arguments - optional third parameter, which is either an object or boolean,
     * both used for additional configuration how and when passed function will be called. When
     * `fromEvent` is used with event target of that type, you can provide this values
     * as third parameter as well.
     *
     * **Node.js EventEmitter**
     *
     * An object with `addListener` and `removeListener` methods.
     *
     * **JQuery-style event target**
     *
     * An object with `on` and `off` methods
     *
     * **DOM NodeList**
     *
     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
     *
     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
     * it contains and install event handler function in every of them. When returned Observable
     * is unsubscribed, function will be removed from all Nodes.
     *
     * **DOM HtmlCollection**
     *
     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
     * installed and removed in each of elements.
     *
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console every time a click
     * // occurs on the document.
     *
     *
     * @example <caption>Use addEventListener with capture option</caption>
     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter
     *                                                                          // which will be passed to addEventListener
     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');
     *
     * clicksInDocument.subscribe(() => console.log('document'));
     * clicksInDiv.subscribe(() => console.log('div'));
     *
     * // By default events bubble UP in DOM tree, so normally
     * // when we would click on div in document
     * // "div" would be logged first and then "document".
     * // Since we specified optional `capture` option, document
     * // will catch event when it goes DOWN DOM tree, so console
     * // will log "document" and then "div".
     *
     * @see {@link bindCallback}
     * @see {@link bindNodeCallback}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOM EventTarget, Node.js
     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            }
            else {
                subscriber.next(result);
            }
        } : function (e) { return subscriber.next(e); };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable));
exports.FromEventObservable = FromEventObservable;
//# sourceMappingURL=FromEventObservable.js.map

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromEventObservable_1 = __webpack_require__(364);
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromEvent_1 = __webpack_require__(365);
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(61);
var EmptyObservable_1 = __webpack_require__(26);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(18);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(60);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(28);
var isArrayLike_1 = __webpack_require__(114);
var isPromise_1 = __webpack_require__(113);
var PromiseObservable_1 = __webpack_require__(111);
var IteratorObservable_1 = __webpack_require__(369);
var ArrayObservable_1 = __webpack_require__(22);
var ArrayLikeObservable_1 = __webpack_require__(368);
var iterator_1 = __webpack_require__(60);
var Observable_1 = __webpack_require__(0);
var observeOn_1 = __webpack_require__(110);
var observable_1 = __webpack_require__(63);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var from_1 = __webpack_require__(112);
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EmptyObservable_1 = __webpack_require__(26);
exports.empty = EmptyObservable_1.EmptyObservable.create;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var empty_1 = __webpack_require__(372);
Observable_1.Observable.empty = empty_1.empty;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var subscribeToResult_1 = __webpack_require__(10);
var OuterSubscriber_1 = __webpack_require__(11);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = (function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable));
exports.DeferObservable = DeferObservable;
var DeferSubscriber = (function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        }
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DeferObservable_1 = __webpack_require__(374);
exports.defer = DeferObservable_1.DeferObservable.create;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var defer_1 = __webpack_require__(375);
Observable_1.Observable.defer = defer_1.defer;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(22);
var isArray_1 = __webpack_require__(28);
var OuterSubscriber_1 = __webpack_require__(11);
var subscribeToResult_1 = __webpack_require__(10);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(27);
var isArray_1 = __webpack_require__(28);
var ArrayObservable_1 = __webpack_require__(22);
var combineLatest_1 = __webpack_require__(378);
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var noop_1 = __webpack_require__(62);
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(3);
var rxSubscriber_1 = __webpack_require__(64);
var Observer_1 = __webpack_require__(115);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 383 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var combineLatest_1 = __webpack_require__(379);
Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(384);
__webpack_require__(376);
__webpack_require__(373);
__webpack_require__(371);
__webpack_require__(366);
__webpack_require__(109);
__webpack_require__(362);
__webpack_require__(357);
__webpack_require__(355);
__webpack_require__(352);
__webpack_require__(351);
__webpack_require__(349);
__webpack_require__(346);
__webpack_require__(343);
__webpack_require__(340);
__webpack_require__(337);
__webpack_require__(335);
__webpack_require__(333);
__webpack_require__(330);
__webpack_require__(327);
__webpack_require__(324);
__webpack_require__(321);
__webpack_require__(318);
__webpack_require__(315);
__webpack_require__(312);
__webpack_require__(309);
__webpack_require__(306);
__webpack_require__(303);
__webpack_require__(300);
__webpack_require__(298);
__webpack_require__(295);
__webpack_require__(292);
__webpack_require__(289);
__webpack_require__(286);
__webpack_require__(283);
__webpack_require__(280);
__webpack_require__(277);
__webpack_require__(274);
__webpack_require__(271);
__webpack_require__(268);
__webpack_require__(265);
__webpack_require__(262);
__webpack_require__(259);
__webpack_require__(256);
__webpack_require__(253);
__webpack_require__(250);
var log_1 = __webpack_require__(1);
var api_1 = __webpack_require__(247);
if (false) {}
exports.default = api_1.default;


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ugly webpack workaround to export require-style
/* tslint:disable no-var-requires */
module.exports = __webpack_require__(385).default;
/* tslint:enable no-var-requires */


/***/ })
/******/ ]);
});