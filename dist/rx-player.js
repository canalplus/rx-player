(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 102);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(11);
var toSubscriber_1 = __webpack_require__(106);
var observable_1 = __webpack_require__(39);
var pipe_1 = __webpack_require__(108);
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __webpack_require__(18);
var LEVELS = {
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFO: 3,
    DEBUG: 4,
};
var currentLevel = Object.keys(LEVELS)[0];
var logger = {
    LEVELS: Object.keys(LEVELS),
    error: noop_1.default,
    warn: noop_1.default,
    info: noop_1.default,
    debug: noop_1.default,
    setLevel: function (levelStr) {
        var level;
        var foundLevel = LEVELS[levelStr];
        if (foundLevel) {
            level = foundLevel;
            currentLevel = levelStr;
        }
        else {
            level = 0;
            currentLevel = "NONE";
        }
        /* tslint:disable no-invalid-this */
        this.error = (level >= LEVELS.ERROR) ?
            console.error.bind(console) : noop_1.default;
        this.warn = (level >= LEVELS.WARNING) ?
            console.warn.bind(console) : noop_1.default;
        this.info = (level >= LEVELS.INFO) ?
            console.info.bind(console) : noop_1.default;
        this.debug = (level >= LEVELS.DEBUG) ?
            console.log.bind(console) : noop_1.default;
        /* tslint:enable no-invalid-this */
    },
    getLevel: function () {
        return currentLevel;
    },
};
exports.default = logger;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AssertionError_1 = __webpack_require__(229);
/**
 * @param {*} value
 * @param {string} message
 * @throws AssertionError - Throws if the value given is falsy
 */
var assert = function (value, message) {
    if (!value) {
        throw new AssertionError_1.default(message || "invalid assertion");
    }
};
// TODO Rename assertEqual
assert.equal = function (a, b, message) {
    return assert(a === b, message);
};
// TODO Rename assertInterface
/**
 * @param {Object} o
 * @param {string} name - name of the _interface_
 * @param {Object} iface - Contains the checked keynames of O and link them
 * to their types (obtained through the typeof operator).
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */
assert.iface = function (o, name, iface) {
    assert(o, name + " should be an object");
    for (var k in iface) {
        if (iface.hasOwnProperty(k)) {
            /* tslint:disable:max-line-length */
            assert.equal(typeof o[k], iface[k], name + " should have property " + k + " as a " + iface[k]);
            /* tslint:enable:max-line-length */
        }
    }
};
exports.default = assert;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(36);
var Subscription_1 = __webpack_require__(12);
var Observer_1 = __webpack_require__(61);
var rxSubscriber_1 = __webpack_require__(38);
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    /**
     * Volume set on unMute if the volume is set to 0 and either:
     *   - mute has never been called before
     *   - mute has last been called while the volume was already set to 0 (either
     *     via setVolume, or a previous mute call)
     * @type {Number}
     */
    DEFAULT_UNMUTED_VOLUME: 0.1,
    /**
     * Can be either:
     *   - "native": Subtitles are all displayed in a <track> element
     *   - "html": Subtitles are all displayed in a <div> separated from the video
     *     element. Can be useful to display richer TTML subtitles, for example.
     * @type {Object|null}
     */
    // TODO ugly TypeScript workaround. Find better way
    DEFAULT_TEXT_TRACK_MODE: "native",
    /**
     * If set to true, video through loadVideo will auto play by default
     * @type {Boolean}
     */
    DEFAULT_AUTO_PLAY: false,
    /**
     * If set to false, "native" subtitles (in a <track> element) will be hidden
     * by default.
     * @type {Boolean}
     */
    DEFAULT_SHOW_NATIVE_SUBTITLE: true,
    /*
     * Default buffer goal in seconds. Once this amount of time reached ahead in
     * the buffer, the player won't automatically download segments.
     * @type {Number}
     */
    DEFAULT_WANTED_BUFFER_AHEAD: 30,
    /*
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _after_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_AHEAD: Infinity,
    /*
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _before_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_BEHIND: Infinity,
    /**
     * Default bitrate ceils initially set as the first content begins.
     *
     * If no track is found with a bitrate inferior or equal to the
     * bitrate there, the one with the lowest bitrate will be taken instead.
     *
     * Set to 0 for the lowest bitrate, Infinity for the highest.
     *
     * These values are only useful for the first content played, as consecutive
     * play will always take the last set one.
     * @type {Object}
     */
    DEFAULT_INITIAL_BITRATES: {
        audio: 0,
        video: 0,
        other: 0,
    },
    /**
     * Default bitrate ceil initially set to dictate the maximum bitrate the
     * ABR manager can automatically switch to.
     *
     * If no track is found with a quality inferior or equal to the
     * bitrate there, the lowest bitrate will be taken instead.
     *
     * Set to Infinity to discard any limit in the ABR strategy.
     * @type {Object}
     */
    /* tslint:disable no-object-literal-type-assertion */
    DEFAULT_MAX_BITRATES: {
        audio: Infinity,
        video: Infinity,
        other: Infinity,
    },
    /* tslint:enable no-object-literal-type-assertion */
    /**
     * Buffer threshold ratio used as a lower bound margin to find the suitable
     * representation.
     * @param {Number}
     */
    DEFAULT_ADAPTIVE_BUFFER_THRESHOLD: 0.3,
    /**
     * Delay after which, if the page is hidden, the user is considered inactive
     * on the current video. Allow to enforce specific optimizations when the
     * page is not shown.
     * @see DEFAULT_THROTTLE_WHEN_HIDDEN
     * @type {Number}
     */
    INACTIVITY_DELAY: 60 * 1000,
    /**
     * If true, if the player is in a "hidden" state for a delay specified by the
     * INACTIVITY DELAY config property, we throttle automatically to the video
     * representation with the lowest bitrate.
     * @type {Boolean}
     */
    DEFAULT_THROTTLE_WHEN_HIDDEN: false,
    /**
     * If true, the video representations you can switch to in adaptive mode
     * are limited by the video element's width.
     * @type {Boolean}
     */
    DEFAULT_LIMIT_VIDEO_WIDTH: false,
    /**
     * Default initial live gap considered if no presentation delay has been
     * suggested, in seconds.
     * @type {Number}
     */
    DEFAULT_LIVE_GAP: 10,
    /**
     * Default value for a manifest's suggested presentation delay if not
     * specified in the manifest.
     * @type {Object}
     */
    DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
        SMOOTH: 10,
        DASH: 10,
    },
    /**
     * Maximum time, in seconds, the player should automatically skip when stalled
     * because of a discontinuity in the downloaded range.
     * @type {Number}
     */
    DISCONTINUITY_THRESHOLD: 1,
    /**
     * Time before the end of a video (in seconds) at which the player should
     * automatically stop.
     * It happens often that the video gets stuck 100 to 300 ms before the end,
     * especially on IE11 and Edge
     * @type {Number}
     */
    END_OF_PLAY: 0.5,
    /**
     * Ratio used to know if an already loaded segment should be re-buffered.
     * We re-load the given segment if the current one times that ratio is
     * inferior to the new one.
     * @type {Number}
     */
    BITRATE_REBUFFERING_RATIO: 1.5,
    /**
     * Those are used when a "QuotaExceededError" error is received after
     * appending a new segment in the source buffer.
     *
     * This error can arise when the browser's buffer is considered full.
     * In this case, the player goes into manual garbage collection (GC) mode.
     * @type {Object}
     */
    BUFFER_GC_GAPS: {
        /**
         * _Low_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received.
         * In seconds.
         * @type {Number}
         */
        CALM: 240,
        /**
         * _High_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received, if the low one does not clean up any buffer.
         * In seconds.
         * @type {Number}
         */
        BEEFY: 30,
    },
    /**
     * The default number of times a pipeline request will be re-performed when
     * on error which justify a retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     *   - if it has a high chance of being due to the user being offline, a
     *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
     * @type Number
     */
    DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,
    /**
     * Under some circonstances, we're able to tell that the user is offline (see
     * the compat files).
     * When this happens, and xhr requests fails due to an error event (you might
     * still be able to perform xhr offline, e.g. on localhost), you might want to
     * retry indefinitely or with a higher number of retry than if the error is
     * due to a CDN problem.
     *
     * A capped exponential backoff will still be used (like for an error code).
     * @type {Number}
     */
    DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,
    /**
     * Initial backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * This delay will then grow exponentally by power of twos (200, 400, 800
     * etc.)
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    INITIAL_BACKOFF_DELAY_BASE: 200,
    /**
     * Maximum backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    MAX_BACKOFF_DELAY_BASE: 3000,
    /**
     * Minimum interval at which timeupdate events will be "constructed". This
     * variable is for the "regular" mediasource strategy (that is, not for the
     * directfile API.
     *
     * Those events are the base of various important mechanisms in the player:
     *   - set the clock for the buffer.
     *   - set the clock for the ABR strategy.
     *   - used to trigger positionUpdate events.
     *
     * This common logic is for performance reasons, as we call multiple browser's
     * APIs which are useful for most of these.
     *
     * Keep in mind this is the minimum interval. This logic will also be
     * triggered when various events of the media element are received.
     * @type {Number}
     */
    SAMPLING_INTERVAL_MEDIASOURCE: 1000,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
     * @type {Number}
     */
    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
    /**
     * Minimum number of bytes sampled before we trust the estimate.
     * If we have not sampled much data, our estimate may not be accurate
     * enough to trust.
     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_TOTAL_BYTES: 350e3,
    /**
     * Minimum number of bytes, under which samples are discarded.
     * Our models do not include latency information, so connection startup time
     * (time to first byte) is considered part of the download time.
     * Because of this, we should ignore very small downloads which would cause
     * our estimate to be too low.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_CHUNK_SIZE: 16e3,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is in
     * starvation mode.
     * @type {Number}
     */
    ABR_STARVATION_FACTOR: 0.72,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is not
     * in starvation mode.
     * @type {Number}
     */
    ABR_REGULAR_FACTOR: 0.90,
    /**
     * If a SourceBuffer has less than this amount of seconds ahead of the current
     * position in its buffer, the ABR manager will go into starvation mode.
     *
     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
     * reached.
     *
     * Under this mode:
     *   - the bandwidth considered will be a little lower than the one estimated
     *   - the time the next important request take will be checked
     *     multiple times to detect when/if it takes too much time.
     *     If the request is considered too long, the bitrate will be hastily
     *     re-calculated from this single request.
     * @type {Number}
     */
    ABR_STARVATION_GAP: 5,
    OUT_OF_STARVATION_GAP: 7,
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * seeking on an unbuffered part of the stream.
     * @type {Number}
     */
    RESUME_AFTER_SEEKING_GAP: 1.5,
    /**
     * Number of seconds ahead in the buffer after which playback will resume
     * after the player went through a buffering step.
     * @type {Number}
     */
    RESUME_AFTER_BUFFERING_GAP: 5,
    /**
     * Maximum number of seconds in the buffer based on which a "stalling"
     * strategy will be considered:
     * The player will pause playback to get enough time building a sufficient
     * buffer. This mostly happen when seeking in an unbuffered part or when
     * buffering.
     * @type {Number}
     */
    STALL_GAP: 0.5,
    /**
     * Maximum difference allowed between a segment _announced_ start (what the
     * rx-player infers to be the starting time) and its _real_  current starting
     * time in the source buffer, in seconds, until the segment is considered
     * "incomplete".
     * Same for the ending time announced and its effective end time in the source
     * buffer.
     *
     * If the difference is bigger than this value, the segment will be considered
     * incomplete (e.g. considered as partially garbage-collected) and as such
     * might be re-downloaded.
     *
     * Keeping a too high value might lead to incomplete segments being wrongly
     * considered as complete (and thus not be re-downloaded, this could lead the
     * player to stall).
     * Note that in a worst-case scenario this can happen for the end of a segment
     * and the start of the contiguous segment, leading to a discontinuity two
     * times this value.
     *
     * Keeping a too low value might lead to re-downloading the same segment
     * multiple times (when the start and end times are badly estimated) as they
     * will wrongly believed to be partially garbage-collected.
     *
     * If a segment has a perfect continuity with a previous/following one in the
     * source buffer the start/end of it will not be checked. This allows to limit
     * the number of time this error-prone logic is applied.
     *
     * Note that in most cases, the rx-player's start and end times estimations
     * are __really__ close to what they really are in the sourcebuffer (we
     * usually have a difference in the order of 10^-7), as time information is
     * most of the time directly parsed from the media container.
     *
     * @type {Number}
     */
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.12,
    /**
     * The maximum time, in seconds, the real buffered time in the sourcebuffer
     * can be superior to the time inferred by the rx-player (the "real" buffered
     * start inferior to the inferred start and the "real" buffered end superior
     * to the inferred end).
     * This limit allows to avoid resizing too much downloaded segments because
     * no other segment is linked to a buffered part.
     *
     * Setting a value too high can lead to parts of the source buffer being
     * linked to the wrong segments.
     * Setting a value too low can lead to parts of the source buffer not being
     * linked to the concerned segment.
     * @type {Number}
     */
    MAX_BUFFERED_DISTANCE: 0.1,
    /**
     * Minimum duration in seconds a segment should be into a buffered range to be
     * considered as part of that range.
     * Segments which have less than this amount of time "linked" to a buffered
     * range will be deleted.
     *
     * Setting a value too low can lead in worst-case scenarios to segments being
     * wrongly linked to the next or previous range it is truly linked too (if
     * those ranges are too close).
     *
     * Setting a value too high can lead to part of the buffer not being assigned
     * any segment. It also limits the minimum duration a segment can be.
     *
     * TODO As of now, this limits the minimum size a complete segment can be. A
     * better logic would be to also consider the duration of a segment. Though
     * this logic could lead to bugs with the current code.
     * @type {Number}
     */
    MINIMUM_SEGMENT_SIZE: 0.3,
    /**
     * Maximum interval at which text tracks are refreshed in an "html"
     * textTrackMode.
     *
     * The text tracks are also refreshed on various video events, this interval
     * will only trigger a refresh if none of those events was received during
     * that timespan.
     *
     * Note that if the TextTrack cue did not change between two intervals or
     * events, the DOM won't be refreshed.
     * The TextTrack cues structure is also optimized for fast retrieval.
     * We should thus not have much of a performance impact here if we set a low
     * interval.
     *
     * @type {Number}
     */
    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 100,
    /**
     * Robustnesses used in the {audio,video}Capabilities of the
     * MediaKeySystemConfiguration (EME).
     *
     * Only used for widevine keysystems.
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: [
        "HW_SECURE_ALL",
        "HW_SECURE_DECODE",
        "HW_SECURE_CRYPTO",
        "SW_SECURE_DECODE",
        "SW_SECURE_CRYPTO",
    ],
    /**
     * Link canonical key systems names to their respective reverse domain name,
     * used in the EME APIs.
     * This allows to have a simpler API, where users just need to set "widevine"
     * or "playready" as a keySystem.
     * @type {Object}
     */
    /* tslint:disable no-object-literal-type-assertion */
    EME_KEY_SYSTEMS: {
        clearkey: [
            "webkit-org.w3.clearkey",
            "org.w3.clearkey",
        ],
        widevine: [
            "com.widevine.alpha",
        ],
        playready: [
            "com.microsoft.playready",
            "com.chromecast.playready",
            "com.youtube.playready",
        ],
    },
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var eventemitter_1 = __webpack_require__(32);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(47);
var constants_1 = __webpack_require__(48);
exports.isFirefox = constants_1.isFirefox;
exports.isIE = constants_1.isIE;
exports.MediaSource_ = constants_1.MediaSource_;
exports.VTTCue_ = constants_1.VTTCue_;
var events = __webpack_require__(16);
exports.events = events;
var fullscreen_1 = __webpack_require__(231);
exports.exitFullscreen = fullscreen_1.exitFullscreen;
exports.isFullscreen = fullscreen_1.isFullscreen;
exports.requestFullscreen = fullscreen_1.requestFullscreen;
var eme_1 = __webpack_require__(232);
exports.KeySystemAccess = eme_1.KeySystemAccess;
exports.requestMediaKeySystemAccess = eme_1.requestMediaKeySystemAccess;
exports.setMediaKeys = eme_1.setMediaKeys;
/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */
function isCodecSupported(codec) {
    if (!constants_1.MediaSource_) {
        return false;
    }
    if (typeof constants_1.MediaSource_.isTypeSupported === "function") {
        return constants_1.MediaSource_.isTypeSupported(codec);
    }
    return true;
}
exports.isCodecSupported = isCodecSupported;
/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */
function shouldRenewMediaKeys() {
    return constants_1.isIE;
}
exports.shouldRenewMediaKeys = shouldRenewMediaKeys;
/**
 * Returns true if the mediakeys associated to a video element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */
function shouldUnsetMediaKeys() {
    return constants_1.isIE;
}
exports.shouldUnsetMediaKeys = shouldUnsetMediaKeys;
/**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource}
 * @returns {Observable}
 */
function onSourceOpen$(mediaSource) {
    if (mediaSource.readyState === "open") {
        return Observable_1.Observable.of(null);
    }
    else {
        return events.onSourceOpen$(mediaSource).take(1);
    }
}
exports.onSourceOpen$ = onSourceOpen$;
/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metatada are loaded).
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function canSeek(videoElement) {
    if (videoElement.readyState >= constants_1.READY_STATES.HAVE_METADATA) {
        return Observable_1.Observable.of(null);
    }
    else {
        return events.onLoadedMetadata$(videoElement).take(1);
    }
}
exports.canSeek = canSeek;
/**
 * Returns ane observable emitting a single time, as soon as a play is possible.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function canPlay(videoElement) {
    if (videoElement.readyState >= constants_1.READY_STATES.HAVE_ENOUGH_DATA) {
        return Observable_1.Observable.of(null);
    }
    else {
        return rx_onEvent_1.default(videoElement, "canplay").take(1);
    }
}
exports.canPlay = canPlay;
// old WebKit SourceBuffer implementation,
// where a synchronous append is used instead of appendBuffer
if (window.WebKitSourceBuffer &&
    !window.WebKitSourceBuffer.prototype.addEventListener) {
    var sourceBufferWebkitRef = window.WebKitSourceBuffer;
    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;
    for (var fnName in eventemitter_1.default.prototype) {
        if (eventemitter_1.default.prototype.hasOwnProperty(fnName)) {
            sourceBufferWebkitProto[fnName] = eventemitter_1.default.prototype[fnName];
        }
    }
    sourceBufferWebkitProto._listeners = [];
    sourceBufferWebkitProto.__emitUpdate =
        function (eventName, val) {
            var _this = this;
            setTimeout(function () {
                /* tslint:disable no-invalid-this */
                _this.trigger(eventName, val);
                _this.updating = false;
                _this.trigger("updateend");
                /* tslint:enable no-invalid-this */
            }, 0);
        };
    sourceBufferWebkitProto.appendBuffer =
        function (data) {
            /* tslint:disable no-invalid-this */
            if (this.updating) {
                throw new Error("updating");
            }
            this.trigger("updatestart");
            this.updating = true;
            try {
                this.append(data);
            }
            catch (error) {
                this.__emitUpdate("error", error);
                return;
            }
            this.__emitUpdate("update");
            /* tslint:enable no-invalid-this */
        };
}
/**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 * @param {HTMLMediaElement} video
 * @param {Boolean} hidden
 * @returns {Object}
 */
function addTextTrack(video, hidden) {
    var track;
    var trackElement;
    var kind = "subtitles";
    if (constants_1.isIE) {
        var tracksLength = video.textTracks.length;
        track = tracksLength > 0 ?
            video.textTracks[tracksLength - 1] : video.addTextTrack(kind);
        track.mode = hidden ? track.HIDDEN : track.SHOWING;
    }
    else {
        // there is no removeTextTrack method... so we need to reuse old
        // text-tracks objects and clean all its pending cues
        trackElement = document.createElement("track");
        video.appendChild(trackElement);
        track = trackElement.track;
        trackElement.kind = kind;
        track.mode = hidden ? "hidden" : "showing";
    }
    return { track: track, trackElement: trackElement };
}
exports.addTextTrack = addTextTrack;
/**
 * firefox fix: sometimes the stream can be stalled, even if we are in a
 * buffer.
 *
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {Object} timing
 * @returns {Boolean}
 */
function isPlaybackStuck(time, currentRange, state, isStalled) {
    var FREEZE_THRESHOLD = 10; // video freeze threshold in seconds
    return (constants_1.isFirefox && isStalled && state === "timeupdate" &&
        !!currentRange && currentRange.end - time > FREEZE_THRESHOLD);
}
exports.isPlaybackStuck = isPlaybackStuck;
/**
 * Clear video src attribute.
 *
 * On IE11,  video.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use video.removeAttr("src").
 * @param {HTMLMediaElement} video
 */
function clearVideoSrc(video) {
    video.src = "";
    video.removeAttribute("src");
}
exports.clearVideoSrc = clearVideoSrc;
/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
    /* tslint:disable no-boolean-literal-compare */
    return navigator.onLine === false;
    /* tslint:enable no-boolean-literal-compare */
}
exports.isOffline = isOffline;
/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {TextTrackCue} or null if the parameters were invalid.
 */
function makeCue(startTime, endTime, payload) {
    if (!constants_1.VTTCue_) {
        throw new Error("VTT cues not supported in your target");
    }
    if (startTime >= endTime) {
        // IE/Edge will throw in this case.
        // See issue #501
        log_1.default.warn("Invalid cue times: " + startTime + " - " + endTime);
        return null;
    }
    return new constants_1.VTTCue_(startTime, endTime, payload);
}
exports.makeCue = makeCue;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(12);
var ObjectUnsubscribedError_1 = __webpack_require__(45);
var SubjectSubscription_1 = __webpack_require__(78);
var rxSubscriber_1 = __webpack_require__(38);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(22);
exports.ErrorCodes = constants_1.ErrorCodes;
exports.ErrorTypes = constants_1.ErrorTypes;
exports.RequestErrorTypes = constants_1.RequestErrorTypes;
// Custom Errors
var EncryptedMediaError_1 = __webpack_require__(84);
exports.EncryptedMediaError = EncryptedMediaError_1.default;
var IndexError_1 = __webpack_require__(236);
exports.IndexError = IndexError_1.default;
var MediaError_1 = __webpack_require__(26);
exports.MediaError = MediaError_1.default;
var OtherError_1 = __webpack_require__(237);
exports.OtherError = OtherError_1.default;
var NetworkError_1 = __webpack_require__(238);
exports.NetworkError = NetworkError_1.default;
// Error used for XHRs
var RequestError_1 = __webpack_require__(239);
exports.RequestError = RequestError_1.default;
/**
 * Whether the error given is a CustomError.
 * @param {Error} error
 * @returns {Boolean}
 */
function isKnownError(error) {
    return (!!error &&
        !!error.type &&
        Object.keys(constants_1.ErrorTypes).indexOf(error.type) >= 0);
}
exports.isKnownError = isKnownError;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// inspired from MDN polyfill, but ponyfilled instead
function arrayIncludes(arr, searchElement, fromIndex) {
    if (typeof Array.prototype.includes === "function") {
        return arr.includes(searchElement, fromIndex);
    }
    var len = arr.length >>> 0;
    if (len === 0) {
        return false;
    }
    var n = fromIndex | 0;
    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
    var areTheSame = function (x, y) {
        return x === y ||
            // Viva las JavaScriptas!
            (typeof x === "number" && typeof y === "number"
                && isNaN(x) && isNaN(y));
    };
    while (k < len) {
        if (areTheSame(arr[k], searchElement)) {
            return true;
        }
        k++;
    }
    return false;
}
exports.default = arrayIncludes;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
__webpack_require__(67);
function castToObservable(value) {
    if (value instanceof Observable_1.Observable) {
        return value;
    }
    if (value && typeof value.subscribe === "function") {
        var valObsLike_1 = value;
        return new Observable_1.Observable(function (obs) {
            var sub = valObsLike_1.subscribe(function (val) { obs.next(val); }, function (err) { obs.error(err); }, function () { obs.complete(); });
            return function () {
                if (sub && sub.dispose) {
                    sub.dispose();
                }
                else if (sub && sub.unsubscribe) {
                    sub.unsubscribe();
                }
            };
        });
    }
    if (value && typeof value.then === "function") {
        return Observable_1.Observable.fromPromise(value);
    }
    return Observable_1.Observable.of(value);
}
exports.default = castToObservable;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.
var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
    self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(105)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(24);
var isObject_1 = __webpack_require__(60);
var isFunction_1 = __webpack_require__(36);
var tryCatch_1 = __webpack_require__(37);
var errorObject_1 = __webpack_require__(31);
var UnsubscriptionError_1 = __webpack_require__(107);
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(11);
var isArrayLike_1 = __webpack_require__(62);
var isPromise_1 = __webpack_require__(63);
var isObject_1 = __webpack_require__(60);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(42);
var InnerSubscriber_1 = __webpack_require__(111);
var observable_1 = __webpack_require__(39);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            destination.syncErrorThrowable = true;
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
var EPSILON = 1 / 60;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function nearlyEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */
function createRangeUnion(range1, range2) {
    var start = Math.min(range1.start, range2.start);
    var end = Math.max(range1.end, range2.end);
    return { start: start, end: end };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function removeEmptyRanges(ranges) {
    for (var index = 0; index < ranges.length; index++) {
        var range = ranges[index];
        if (range.start === range.end) {
            ranges.splice(index++, 1);
        }
    }
    return ranges;
}
exports.removeEmptyRanges = removeEmptyRanges;
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function mergeContiguousRanges(ranges) {
    for (var index = 1; index < ranges.length; index++) {
        var prevRange = ranges[index - 1];
        var currRange = ranges[index];
        if (areRangesNearlyContiguous(prevRange, currRange)) {
            var unionRange = createRangeUnion(prevRange, currRange);
            ranges.splice(--index, 2, unionRange);
        }
    }
    return ranges;
}
exports.mergeContiguousRanges = mergeContiguousRanges;
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isAfter(range1, range2) {
    return range1.start >= range2.end;
}
exports.isAfter = isAfter;
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isBefore(range1, range2) {
    return range1.end <= range2.start;
}
exports.isBefore = isBefore;
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */
function isTimeInRange(_a, time) {
    var start = _a.start, end = _a.end;
    return start <= time && time < end;
}
exports.isTimeInRange = isTimeInRange;
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesOverlapping(range1, range2) {
    return isTimeInRange(range1, range2.start) ||
        range1.start < range2.end && range2.end < range1.end ||
        isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesNearlyContiguous(range1, range2) {
    return nearlyEqual(range2.start, range1.end) ||
        nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */
function convertToRanges(timeRanges) {
    var ranges = [];
    for (var i = 0; i < timeRanges.length; i++) {
        ranges.push({
            start: timeRanges.start(i),
            end: timeRanges.end(i),
        });
    }
    return ranges;
}
exports.convertToRanges = convertToRanges;
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */
function getRange(timeRanges, time) {
    for (var i = timeRanges.length - 1; i >= 0; i--) {
        var start = timeRanges.start(i);
        if (time >= start) {
            var end = timeRanges.end(i);
            if (time < end) {
                return {
                    start: start,
                    end: end,
                };
            }
        }
    }
    return null;
}
exports.getRange = getRange;
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */
function getNextRangeGap(timeRanges, time) {
    var len = timeRanges.length;
    for (var i = 0; i < len; i++) {
        var start = timeRanges.start(i);
        if (time < start) {
            return start - time;
        }
    }
    return Infinity;
}
exports.getNextRangeGap = getNextRangeGap;
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */
function getInnerAndOuterTimeRanges(timeRanges, time) {
    var innerRange = null;
    var outerRanges = [];
    for (var i = 0; i < timeRanges.length; i++) {
        var start = timeRanges.start(i);
        var end = timeRanges.end(i);
        if (time < start || time >= end) {
            outerRanges.push({ start: start, end: end });
        }
        else {
            innerRange = { start: start, end: end };
        }
    }
    return { outerRanges: outerRanges, innerRange: innerRange };
}
exports.getInnerAndOuterTimeRanges = getInnerAndOuterTimeRanges;
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? range.end - range.start
        : 0;
}
exports.getSizeOfRange = getSizeOfRange;
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getPlayedSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? currentTime - range.start
        : 0;
}
exports.getPlayedSizeOfRange = getPlayedSizeOfRange;
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getLeftSizeOfRange(timeRanges, currentTime) {
    var range = getRange(timeRanges, currentTime);
    return range
        ? range.end - currentTime
        : Infinity;
}
exports.getLeftSizeOfRange = getLeftSizeOfRange;
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */
function insertInto(ranges, rangeToAddArg) {
    if (rangeToAddArg.start === rangeToAddArg.end) {
        return ranges;
    }
    var rangeToAdd = rangeToAddArg;
    // For each present range check if we need to:
    // - In case we are overlapping or contiguous:
    //   - if added range has the same bitrate as the overlapped or
    //     contiguous one, we can merge themcurrentRange
    //   - if added range has a different bitrate we need to insert it
    //     in place
    // - Need to insert in place, we we are completely, not overlapping
    //   and not contiguous in between two ranges.
    var index = 0;
    for (; index < ranges.length; index++) {
        var range = ranges[index];
        var overlapping = areRangesOverlapping(rangeToAdd, range);
        var contiguous = areRangesNearlyContiguous(rangeToAdd, range);
        // We assume ranges are ordered and two ranges can not be
        // completely overlapping.
        if (overlapping || contiguous) {
            rangeToAdd = createRangeUnion(rangeToAdd, range);
            ranges.splice(index--, 1);
        }
        else {
            // Check the case for which there is no more to do
            if (index === 0) {
                if (isBefore(rangeToAdd, ranges[0])) {
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                }
            }
            else {
                if (isBefore(ranges[index - 1], rangeToAdd)
                    && isBefore(rangeToAdd, range)) {
                    // We are exactly after the current previous range, and
                    // before the current range, while not overlapping with none
                    // of them. Insert here.
                    break;
                }
            }
        }
    }
    // Now that we are sure we don't overlap with any range, just add it.
    ranges.splice(index, 0, rangeToAdd);
    return mergeContiguousRanges(removeEmptyRanges(ranges));
}
exports.insertInto = insertInto;
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Object|null}
 */
function findOverlappingRange(range, ranges) {
    for (var i = 0; i < ranges.length; i++) {
        if (areRangesOverlapping(range, ranges[i])) {
            return ranges[i];
        }
    }
    return null;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * /!\ Mutates the ranges1 array given
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */
function keepRangeIntersection(ranges1, ranges2) {
    for (var i = 0; i < ranges1.length; i++) {
        var range = ranges1[i];
        var overlappingRange = findOverlappingRange(range, ranges2);
        if (!overlappingRange) {
            ranges1.splice(i--, 1);
        }
        else if (overlappingRange.start > range.start) {
            range.start = overlappingRange.start;
        }
        else if (overlappingRange.end < range.end) {
            range.end = overlappingRange.end;
        }
    }
    return ranges1;
}
exports.keepRangeIntersection = keepRangeIntersection;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */
var Observable_1 = __webpack_require__(0);
var config_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(47);
var constants_1 = __webpack_require__(48);
var INACTIVITY_DELAY = config_1.default.INACTIVITY_DELAY;
var pixelRatio = window.devicePixelRatio || 1;
/**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
function isEventSupported(element, eventNameSuffix) {
    var clone = document.createElement(element.tagName);
    var eventName = "on" + eventNameSuffix;
    if (eventName in clone) {
        return true;
    }
    else {
        clone.setAttribute(eventName, "return;");
        return typeof clone[eventName] === "function";
    }
}
/**
 * Find the first supported event from the list given.
 * @param {Element} element
 * @param {Array.<string>} eventNames
 * @returns {string}
 */
function findSupportedEvent(element, eventNames) {
    return eventNames
        .filter(function (name) { return isEventSupported(element, name); })[0];
}
function eventPrefixed(eventNames, prefixes) {
    return eventNames.reduce(function (parent, name) {
        return parent
            .concat((prefixes || constants_1.BROWSER_PREFIXES)
            .map(function (p) { return p + name; }));
    }, []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>} prefixes
 * @returns {Observable}
 */
function compatibleListener(eventNames, prefixes) {
    var mem;
    var prefixedEvents = eventPrefixed(eventNames, prefixes);
    return function (element) {
        // if the element is a HTMLElement we can detect
        // the supported event, and memoize it in `mem`
        if (element instanceof constants_1.HTMLElement_) {
            if (typeof mem === "undefined") {
                mem = findSupportedEvent(element, prefixedEvents);
            }
            if (mem) {
                return Observable_1.Observable.fromEvent(element, mem);
            }
            else {
                if (false) {
                    /* tslint:disable:max-line-length */
                    log_1.default.warn("compat: element <" + element.tagName + "> does not support any of these events: " + prefixedEvents.join(", ")
                    /* tslint:enable:max-line-length */
                    );
                }
                return Observable_1.Observable.never();
            }
        }
        // otherwise, we need to listen to all the events
        // and merge them into one observable sequence
        return rx_onEvent_1.default(element, prefixedEvents);
    };
}
/**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */
function visibilityChange() {
    var prefix;
    if (document.hidden != null) {
        prefix = "";
    }
    else if (document.mozHidden != null) {
        prefix = "moz";
    }
    else if (document.msHidden != null) {
        prefix = "ms";
    }
    else if (document.webkitHidden != null) {
        prefix = "webkit";
    }
    var hidden = prefix ? prefix + "Hidden" : "hidden";
    var visibilityChangeEvent = prefix + "visibilitychange";
    return rx_onEvent_1.default(document, visibilityChangeEvent)
        .map(function () { return document[hidden]; });
}
function videoSizeChange() {
    return rx_onEvent_1.default(window, "resize");
}
var isVisible = visibilityChange() // emit false when visible
    .filter(function (x) { return !x; });
// Emit true if the visibility changed to hidden since 60s
var isHidden = visibilityChange()
    .debounceTime(INACTIVITY_DELAY)
    .filter(function (x) { return x; });
var isInBackground$ = function () { return Observable_1.Observable.merge(isVisible, isHidden)
    .startWith(false); };
exports.isInBackground$ = isInBackground$;
function videoWidth$(videoElement) {
    return Observable_1.Observable.merge(Observable_1.Observable.interval(20000), videoSizeChange().debounceTime(500))
        .startWith(0) // emit on subscription
        .map(function () { return videoElement.clientWidth * pixelRatio; })
        .distinctUntilChanged();
}
exports.videoWidth$ = videoWidth$;
var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
exports.onLoadedMetadata$ = onLoadedMetadata$;
var onSeeking$ = compatibleListener(["seeking"]);
exports.onSeeking$ = onSeeking$;
var onSeeked$ = compatibleListener(["seeked"]);
exports.onSeeked$ = onSeeked$;
var onEnded$ = compatibleListener(["ended"]);
exports.onEnded$ = onEnded$;
var onTimeUpdate$ = compatibleListener(["timeupdate"]);
exports.onTimeUpdate$ = onTimeUpdate$;
var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], 
// On IE11, fullscreen change events is called MSFullscreenChange
constants_1.BROWSER_PREFIXES.concat("MS"));
exports.onFullscreenChange$ = onFullscreenChange$;
var onPlayPause$ = function (videoElement) {
    return Observable_1.Observable.merge(compatibleListener(["play"])(videoElement), compatibleListener(["pause"])(videoElement));
};
exports.onPlayPause$ = onPlayPause$;
var onTextTrackChanges$ = function (textTrackList) {
    return Observable_1.Observable.merge(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
};
exports.onTextTrackChanges$ = onTextTrackChanges$;
var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
exports.onSourceOpen$ = onSourceOpen$;
var onEncrypted$ = compatibleListener(["encrypted", "needkey"]);
exports.onEncrypted$ = onEncrypted$;
var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
exports.onKeyMessage$ = onKeyMessage$;
var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
exports.onKeyAdded$ = onKeyAdded$;
var onKeyError$ = compatibleListener(["keyerror", "error"]);
exports.onKeyError$ = onKeyError$;
var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);
exports.onKeyStatusesChange$ = onKeyStatusesChange$;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function find(array, predicate, context) {
  if (typeof Array.prototype.find === 'function') {
    return array.find(predicate, context);
  }

  context = context || this;
  var length = array.length;
  var i;

  if (typeof predicate !== 'function') {
    throw new TypeError(predicate + ' is not a function');
  }

  for (i = 0; i < length; i++) {
    if (predicate.call(context, array[i], i, array)) {
      return array[i];
    }
  }
}

module.exports = find;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Do nothing, well.
 */
/* tslint:disable:no-empty */
function default_1() { }
exports.default = default_1;
/* tslint:enable:no-empty */


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(41);
var EmptyObservable_1 = __webpack_require__(25);
var isScheduler_1 = __webpack_require__(19);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = (function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        }
        else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        }
        else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable));
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AsyncAction_1 = __webpack_require__(69);
var AsyncScheduler_1 = __webpack_require__(70);
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var listToMap_1 = __webpack_require__(230);
var ErrorTypes = listToMap_1.default([
    "NETWORK_ERROR",
    "MEDIA_ERROR",
    "ENCRYPTED_MEDIA_ERROR",
    "INDEX_ERROR",
    "OTHER_ERROR",
]);
exports.ErrorTypes = ErrorTypes;
var RequestErrorTypes = listToMap_1.default([
    "TIMEOUT",
    "ERROR_EVENT",
    "ERROR_HTTP_CODE",
    "PARSE_ERROR",
]);
exports.RequestErrorTypes = RequestErrorTypes;
var ErrorCodes = listToMap_1.default([
    "PIPELINE_RESOLVE_ERROR",
    "PIPELINE_LOAD_ERROR",
    "PIPELINE_PARSING_ERROR",
    "MANIFEST_PARSE_ERROR",
    "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
    "MEDIA_IS_ENCRYPTED_ERROR",
    "KEY_ERROR",
    "KEY_STATUS_CHANGE_ERROR",
    "KEY_UPDATE_ERROR",
    "KEY_LOAD_ERROR",
    "KEY_LOAD_TIMEOUT",
    "KEY_GENERATE_REQUEST_ERROR",
    "INCOMPATIBLE_KEYSYSTEMS",
    "LICENSE_SERVER_CERTIFICATE_ERROR",
    "BUFFER_APPEND_ERROR",
    "BUFFER_FULL_ERROR",
    "BUFFER_TYPE_UNKNOWN",
    "MEDIA_ERR_ABORTED",
    "MEDIA_ERR_NETWORK",
    "MEDIA_ERR_DECODE",
    "MEDIA_ERR_SRC_NOT_SUPPORTED",
    "MEDIA_ERR_UNKNOWN",
    "MEDIA_SOURCE_NOT_SUPPORTED",
    "MEDIA_KEYS_NOT_SUPPORTED",
    "OUT_OF_INDEX_ERROR",
    "UNKNOWN_INDEX",
]);
exports.ErrorCodes = ErrorCodes;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Scheme part of an url (e.g. "http://").
 */
var schemeRe = /^(?:[a-z]+:)?\/\//i;
/**
 * Captures "/../" or "/./".
 */
var selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
function _normalizeUrl(url) {
    // fast path if no ./ or ../ are present in the url
    if (!selfDirRe.test(url)) {
        return url;
    }
    var newUrl = [];
    var oldUrl = url.split("/");
    for (var i = 0, l = oldUrl.length; i < l; i++) {
        if (oldUrl[i] === "..") {
            newUrl.pop();
        }
        else if (oldUrl[i] === ".") {
            continue;
        }
        else {
            newUrl.push(oldUrl[i]);
        }
    }
    return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */
function resolveURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var len = args.length;
    if (len === 0) {
        return "";
    }
    var base = "";
    for (var i = 0; i < len; i++) {
        var part = args[i];
        if (typeof part !== "string" || part === "") {
            continue;
        }
        if (schemeRe.test(part)) {
            base = part;
        }
        else {
            // trim if begins with "/"
            if (part[0] === "/") {
                part = part.substr(1);
            }
            // trim if ends with "/"
            if (base[base.length - 1] === "/") {
                base = base.substr(0, base.length - 1);
            }
            base = base + "/" + part;
        }
    }
    return _normalizeUrl(base);
}
exports.resolveURL = resolveURL;
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */
function normalizeBaseURL(url) {
    var slash = url.lastIndexOf("/");
    if (slash >= 0) {
        return url.substring(0, slash + 1);
    }
    else {
        return url;
    }
}
exports.normalizeBaseURL = normalizeBaseURL;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArray.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = (function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        }
        else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable));
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(22);
var errorMessage_1 = __webpack_require__(27);
/**
 * @class MediaError
 * @extends Error
 */
var MediaError = /** @class */ (function (_super) {
    __extends(MediaError, _super);
    function MediaError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, MediaError.prototype);
        _this.name = "MediaError";
        _this.type = constants_1.ErrorTypes.MEDIA_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes[code];
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return MediaError;
}(Error));
exports.default = MediaError;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
    if (reason == null) {
        return name + " (" + code + ")";
    }
    else if (typeof reason === "string") {
        return name + " (" + code + ") " + reason;
    }
    else {
        var message = reason.message;
        return name + " (" + code + ") " + message;
    }
}
exports.default = errorMessage;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
/**
 * Returns Uint8Array from UTF16 string.
 * /!\ Take only the first byte from each UTF16 code.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToBytes(str) {
    var len = str.length;
    var arr = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        arr[i] = str.charCodeAt(i) & 0xFF;
    }
    return arr;
}
exports.strToBytes = strToBytes;
/**
 * construct string from unicode values.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToStr(bytes) {
    return String.fromCharCode.apply(null, bytes);
}
exports.bytesToStr = bytesToStr;
/**
 * construct string from unicode values.
 * Only use every other byte for each UTF-16 character.
 * /!\ does not support non-UCS-2 values
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function bytesToUTF16Str(bytes) {
    var str = "";
    var len = bytes.length;
    for (var i = 0; i < len; i += 2) {
        str += String.fromCharCode(bytes[i]);
    }
    return str;
}
exports.bytesToUTF16Str = bytesToUTF16Str;
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */
function hexToBytes(str) {
    var len = str.length;
    var arr = new Uint8Array(len / 2);
    for (var i = 0, j = 0; i < len; i += 2, j++) {
        arr[j] = parseInt(str.substr(i, 2), 16) & 0xFF;
    }
    return arr;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */
function bytesToHex(bytes, sep) {
    if (sep === void 0) { sep = ""; }
    var hex = "";
    for (var i = 0; i < bytes.byteLength; i++) {
        hex += (bytes[i] >>> 4).toString(16);
        hex += (bytes[i] & 0xF).toString(16);
        if (sep.length && i < bytes.byteLength - 1) {
            hex += sep;
        }
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */
function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var l = args.length;
    var i = -1;
    var len = 0;
    var arg;
    while (++i < l) {
        arg = args[i];
        len += (typeof arg === "number") ? arg : arg.length;
    }
    var arr = new Uint8Array(len);
    var offset = 0;
    i = -1;
    while (++i < l) {
        arg = args[i];
        if (typeof arg === "number") {
            offset += arg;
        }
        else if (arg.length > 0) {
            arr.set(arg, offset);
            offset += arg.length;
        }
    }
    return arr;
}
exports.concat = concat;
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be2toi(bytes, offset) {
    return ((bytes[offset + 0] << 8) +
        (bytes[offset + 1] << 0));
}
exports.be2toi = be2toi;
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be3toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x0010000) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2]));
}
exports.be3toi = be3toi;
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be4toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3]));
}
exports.be4toi = be4toi;
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be8toi(bytes, offset) {
    return (((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3])) * 0x100000000 +
        (bytes[offset + 4] * 0x1000000) +
        (bytes[offset + 5] * 0x0010000) +
        (bytes[offset + 6] * 0x0000100) +
        (bytes[offset + 7]));
}
exports.be8toi = be8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe2(num) {
    return new Uint8Array([
        (num >>> 8) & 0xFF,
        (num) & 0xFF,
    ]);
}
exports.itobe2 = itobe2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe4(num) {
    return new Uint8Array([
        (num >>> 24) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 8) & 0xFF,
        (num) & 0xFF,
    ]);
}
exports.itobe4 = itobe4;
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe8(num) {
    var l = (num % 0x100000000);
    var h = (num - l) / 0x100000000;
    return new Uint8Array([
        (h >>> 24) & 0xFF,
        (h >>> 16) & 0xFF,
        (h >>> 8) & 0xFF,
        (h) & 0xFF,
        (l >>> 24) & 0xFF,
        (l >>> 16) & 0xFF,
        (l >>> 8) & 0xFF,
        (l) & 0xFF,
    ]);
}
exports.itobe8 = itobe8;
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le2toi(bytes, offset) {
    return ((bytes[offset + 0] << 0) +
        (bytes[offset + 1] << 8));
}
exports.le2toi = le2toi;
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le4toi(bytes, offset) {
    return ((bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000));
}
exports.le4toi = le4toi;
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le8toi(bytes, offset) {
    return ((bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000) +
        ((bytes[offset + 4]) +
            (bytes[offset + 5] * 0x0000100) +
            (bytes[offset + 6] * 0x0010000) +
            (bytes[offset + 7] * 0x1000000)) * 0x100000000);
}
exports.le8toi = le8toi;
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole2(num) {
    return new Uint8Array([
        (num) & 0xFF,
        (num >>> 8) & 0xFF,
    ]);
}
exports.itole2 = itole2;
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole4(num) {
    return new Uint8Array([
        (num) & 0xFF,
        (num >>> 8) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 24) & 0xFF,
    ]);
}
exports.itole4 = itole4;
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole8(num) {
    var l = (num % 0x100000000);
    var h = (num - l) / 0x100000000;
    return new Uint8Array([
        (h) & 0xFF,
        (h >>> 8) & 0xFF,
        (h >>> 16) & 0xFF,
        (h >>> 24) & 0xFF,
        (l) & 0xFF,
        (l >>> 8) & 0xFF,
        (l >>> 16) & 0xFF,
        (l >>> 24) & 0xFF,
    ]);
}
exports.itole8 = itole8;
/**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
function guidToUuid(uuid) {
    assert_1.default.equal(uuid.length, 16, "UUID length should be 16");
    var buf = strToBytes(uuid);
    var p1A = buf[0];
    var p1B = buf[1];
    var p1C = buf[2];
    var p1D = buf[3];
    var p2A = buf[4];
    var p2B = buf[5];
    var p3A = buf[6];
    var p3B = buf[7];
    var p4 = buf.subarray(8, 10);
    var p5 = buf.subarray(10, 16);
    var ord = new Uint8Array(16);
    ord[0] = p1D;
    ord[1] = p1C;
    ord[2] = p1B;
    ord[3] = p1A; // swap32 BE -> LE
    ord[4] = p2B;
    ord[5] = p2A; // swap16 BE -> LE
    ord[6] = p3B;
    ord[7] = p3A; // swap16 BE -> LE
    ord.set(p4, 8);
    ord.set(p5, 10);
    return bytesToHex(ord);
}
exports.guidToUuid = guidToUuid;
/**
 * Creates a base-64 encoded ASCII string from a string of binary data, with
 * possible trailing equal sign(s) stripped.
 * @param {string}
 * @returns {string}
 */
function toBase64URL(str) {
    return btoa(str).replace(/\=+$/, "");
}
exports.toBase64URL = toBase64URL;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var errors_1 = __webpack_require__(8);
var DEFAULT_RESPONSE_TYPE = "json";
var DEFAULT_REQUEST_TIMEOUT = 30 * 1000; // TODO move to config?
function toJSONForIE(data) {
    try {
        return JSON.parse(data);
    }
    catch (e) {
        return null;
    }
}
function request(options) {
    var requestOptions = {
        url: options.url,
        body: options.body,
        headers: options.headers,
        method: options.method == null ?
            "GET" : options.method,
        responseType: options.responseType == null ?
            DEFAULT_RESPONSE_TYPE : options.responseType,
        timeout: options.timeout == null ?
            DEFAULT_REQUEST_TIMEOUT : options.timeout,
    };
    return Observable_1.Observable.create(function (obs) {
        var url = requestOptions.url, headers = requestOptions.headers, method = requestOptions.method, responseType = requestOptions.responseType, timeout = requestOptions.timeout, body = requestOptions.body;
        var xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        if (timeout >= 0) {
            xhr.timeout = timeout;
        }
        xhr.responseType = responseType;
        if (xhr.responseType === "document") {
            xhr.overrideMimeType("text/xml");
        }
        if (headers) {
            var _headers = headers;
            for (var key in _headers) {
                if (_headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, _headers[key]);
                }
            }
        }
        var sentTime = Date.now();
        xhr.onerror = function onXHRError() {
            var errorCode = errors_1.RequestErrorTypes.ERROR_EVENT;
            obs.error(new errors_1.RequestError(xhr, url, errorCode));
        };
        xhr.ontimeout = function onXHRTimeout() {
            var errorCode = errors_1.RequestErrorTypes.TIMEOUT;
            obs.error(new errors_1.RequestError(xhr, url, errorCode));
        };
        if (!options.ignoreProgressEvents) {
            xhr.onprogress = function onXHRProgress(event) {
                var currentTime = Date.now();
                obs.next({
                    type: "progress",
                    value: {
                        url: url,
                        duration: currentTime - sentTime,
                        sentTime: sentTime,
                        currentTime: currentTime,
                        size: event.loaded,
                        totalSize: event.total,
                    },
                });
            };
        }
        // XXX TODO:
        // Waiting for https://github.com/Microsoft/TypeScript/issues/19830
        xhr.onload = function onXHRLoad(event) {
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    var receivedTime = Date.now();
                    var totalSize = event.total;
                    var status_1 = xhr.status;
                    var loadedResponseType = xhr.responseType;
                    var _url = xhr.responseURL || url;
                    var responseData = void 0;
                    if (loadedResponseType === "json") {
                        // IE bug where response is string with responseType json
                        responseData = xhr.response !== "string" ?
                            xhr.response : toJSONForIE(xhr.responseText);
                    }
                    else {
                        responseData = xhr.response;
                    }
                    if (responseData == null) {
                        var errorCode = errors_1.RequestErrorTypes.PARSE_ERROR;
                        obs.error(new errors_1.RequestError(xhr, _url, errorCode));
                        return;
                    }
                    obs.next({
                        type: "response",
                        value: {
                            status: status_1,
                            url: _url,
                            responseType: loadedResponseType,
                            sentTime: sentTime,
                            receivedTime: receivedTime,
                            duration: receivedTime - sentTime,
                            size: totalSize,
                            responseData: responseData,
                        },
                    });
                    obs.complete();
                }
                else {
                    var errorCode = errors_1.RequestErrorTypes.ERROR_HTTP_CODE;
                    obs.error(new errors_1.RequestError(xhr, url, errorCode));
                }
            }
        };
        if (body !== undefined) {
            xhr.send(body);
        }
        else {
            xhr.send();
        }
        return function () {
            if (xhr && xhr.readyState !== 4) {
                xhr.abort();
            }
        };
    });
}
exports.default = request;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var segment_1 = __webpack_require__(35);
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} seg
 * @param {Number} seg.ts - beginning timescaled timestamp
 * @param {Number} seg.d - timescaled duration of the segment
 * @param {Object} nextSeg
 * @param {Number} nextSeg.ts
 * @returns {Number}
 */
function calculateRepeat(seg, nextSeg) {
    var rep = seg.r || 0;
    // A negative value of the @r attribute of the S element indicates
    // that the duration indicated in @d attribute repeats until the
    // start of the next S element, the end of the Period or until the
    // next MPD update.
    if (rep < 0) {
        var repEnd = nextSeg ? nextSeg.ts : Infinity;
        rep = Math.ceil((repEnd - seg.ts) / seg.d) - 1;
    }
    return rep;
}
exports.calculateRepeat = calculateRepeat;
/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function normalizeRange(index, // TODO
    ts, duration) {
    var pto = index.presentationTimeOffset || 0;
    var timescale = index.timescale || 1;
    return {
        up: (ts) * timescale - pto,
        to: (ts + duration) * timescale - pto,
    };
}
exports.normalizeRange = normalizeRange;
/**
 * Get start of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute start time of the range
 */
function getTimelineRangeStart(_a) {
    var ts = _a.ts, d = _a.d, r = _a.r;
    return d === -1 ? ts : ts + r * d;
}
exports.getTimelineRangeStart = getTimelineRangeStart;
/**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute end time of the range
 */
function getTimelineRangeEnd(_a) {
    var ts = _a.ts, d = _a.d, r = _a.r;
    return d === -1 ? ts : ts + (r + 1) * d;
}
exports.getTimelineRangeEnd = getTimelineRangeEnd;
/**
 * Construct init segment for the given index.
 * @param {string} rootId
 * @param {Object} index
 * @param {Number} index.timescale
 * @param {Object} [index.initialization={}]
 * @param {Array.<Number>|null} [index.initialization.range=null]
 * @param {Array.<Number>|null} [index.initialization.indexRange=null]
 * @param {string} [index.initialization.media]
 * @returns {Segment}
 */
function getInitSegment(rootId, index) {
    var _a = index.initialization, initialization = _a === void 0 ? {} : _a;
    var args = {
        id: "" + rootId + "_init",
        init: true,
        time: 0,
        range: initialization.range || null,
        indexRange: index.indexRange || null,
        media: initialization.media,
        timescale: index.timescale,
    };
    return new segment_1.default(args);
}
exports.getInitSegment = getInitSegment;
/**
 * Update the timescale used (for all segments).
 * TODO This should probably update all previous segments to the newly set
 * Timescale.
 *
 * /!\ Mutates the given index
 * @param {Object} index
 * @param {Number} timescale
 * @returns {Object}
 */
var setTimescale = function (index, timescale) {
    if (false) {
        assert_1.default(typeof timescale === "number");
        assert_1.default(timescale > 0);
    }
    if (index.timescale !== timescale) {
        index.timescale = timescale;
    }
    return {
        timescale: index.timescale === timescale ?
            timescale : index.timescale,
    };
};
exports.setTimescale = setTimescale;
/**
 * Re-scale a given time from timescaled information to second-based.
 * @param {Object} index
 * @param {Number} time
 * @returns {Number}
 */
var scale = function (index, time) {
    if (false) {
        assert_1.default(index.timescale > 0);
    }
    return time / index.timescale;
};
exports.scale = scale;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.on = this.addEventListener;
        this.off = this.removeEventListener;
        this._listeners = {};
    }
    EventEmitter.prototype.addEventListener = function (evt, fn) {
        assert_1.default(typeof fn === "function", "eventemitter: second argument should be a function");
        if (!this._listeners[evt]) {
            this._listeners[evt] = [];
        }
        this._listeners[evt].push(fn);
    };
    EventEmitter.prototype.removeEventListener = function (evt, fn) {
        if (arguments.length === 0) {
            this._listeners = {};
            return;
        }
        if (!this._listeners.hasOwnProperty(evt)) {
            return;
        }
        if (arguments.length === 1) {
            delete this._listeners[evt];
            return;
        }
        var listeners = this._listeners[evt];
        var index = listeners.indexOf(fn);
        if (~index) {
            listeners.splice(index, 1);
        }
        if (!listeners.length) {
            delete this._listeners[evt];
        }
    };
    EventEmitter.prototype.trigger = function (evt, arg) {
        if (!this._listeners.hasOwnProperty(evt)) {
            return;
        }
        var listeners = this._listeners[evt].slice();
        listeners.forEach(function (listener) {
            try {
                listener(arg);
            }
            catch (e) {
                log_1.default.error(e, e.stack);
            }
        });
    };
    return EventEmitter;
}());
exports.default = EventEmitter;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var bytes_1 = __webpack_require__(28);
/**
 * Find the right atom (box) in an isobmff file from its hexa-encoded name.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {Number} - offset where the corresponding box is (starting with its
 * size), 0 if not found.
 */
function findAtom(buf, atomName) {
    var l = buf.length;
    var i = 0;
    var name;
    var size = 0;
    while (i + 8 < l) {
        size = bytes_1.be4toi(buf, i);
        name = bytes_1.be4toi(buf, i + 4);
        assert_1.default(size > 0, "out of range size");
        if (name === atomName) {
            break;
        }
        else {
            i += size;
        }
    }
    if (i >= l) {
        return -1;
    }
    assert_1.default(i + size <= l, "atom out of range");
    return i;
}
/**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */
function parseSidx(buf, initialOffset) {
    var index = findAtom(buf, 0x73696478 /* "sidx" */);
    if (index === -1) {
        return null;
    }
    var offset = initialOffset;
    var size = bytes_1.be4toi(buf, index);
    var pos = index + /* size */ 4 + /* name */ 4;
    /* version(8) */
    /* flags(24) */
    /* reference_ID(32); */
    /* timescale(32); */
    var version = buf[pos];
    pos += 4 + 4;
    var timescale = bytes_1.be4toi(buf, pos);
    pos += 4;
    /* earliest_presentation_time(32 / 64) */
    /* first_offset(32 / 64) */
    var time;
    if (version === 0) {
        time = bytes_1.be4toi(buf, pos);
        pos += 4;
        offset += bytes_1.be4toi(buf, pos) + size;
        pos += 4;
    }
    else if (version === 1) {
        time = bytes_1.be8toi(buf, pos);
        pos += 8;
        offset += bytes_1.be8toi(buf, pos) + size;
        pos += 8;
    }
    else {
        return null;
    }
    var segments = [];
    /* reserved(16) */
    /* reference_count(16) */
    pos += 2;
    var count = bytes_1.be2toi(buf, pos);
    pos += 2;
    while (--count >= 0) {
        /* reference_type(1) */
        /* reference_size(31) */
        /* segment_duration(32) */
        /* sap..(32) */
        var refChunk = bytes_1.be4toi(buf, pos);
        pos += 4;
        var refType = (refChunk & 0x80000000) >>> 31;
        var refSize = (refChunk & 0x7fffffff);
        // when set to 1 indicates that the reference is to a sidx, else to media
        if (refType === 1) {
            throw new Error("not implemented");
        }
        var d = bytes_1.be4toi(buf, pos);
        pos += 4;
        // let sapChunk = be4toi(buf, pos + 8);
        pos += 4;
        // TODO(pierre): handle sap
        // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
        // let sapType = (sapChunk & 0x70000000) >>> 28;
        // let sapDelta = sapChunk & 0x0FFFFFFF;
        segments.push({
            time: time,
            duration: d,
            count: 0,
            timescale: timescale,
            range: [offset, offset + refSize - 1],
        });
        time += d;
        offset += refSize;
    }
    return segments;
}
exports.parseSidx = parseSidx;
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function parseTfdt(buffer) {
    var moof = getAtomContent(buffer, 0x6d6f6f66 /* moof */);
    if (!moof) {
        return -1;
    }
    var traf = getAtomContent(moof, 0x74726166 /* traf */);
    if (!traf) {
        return -1;
    }
    var index = findAtom(traf, 0x74666474 /* tfdt */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = traf[pos];
    pos += 4;
    if (version > 1) {
        return -1;
    }
    return version ? bytes_1.be8toi(traf, pos) : bytes_1.be4toi(traf, pos);
}
exports.parseTfdt = parseTfdt;
function getDefaultDurationFromTFHDInTRAF(traf) {
    var index = findAtom(traf, 0x74666864 /* tfhd */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4 + /* version */ 1;
    var flags = bytes_1.be3toi(traf, pos);
    var hasBaseDataOffset = flags & 0x000001;
    var hasSampleDescriptionIndex = flags & 0x000002;
    var hasDefaultSampleDuration = flags & 0x000008;
    if (!hasDefaultSampleDuration) {
        return -1;
    }
    pos += 4;
    if (hasBaseDataOffset) {
        pos += 8;
    }
    if (hasSampleDescriptionIndex) {
        pos += 4;
    }
    var defaultDuration = bytes_1.be4toi(traf, pos);
    return defaultDuration;
}
function getDurationFromTrun(buffer) {
    var moof = getAtomContent(buffer, 0x6d6f6f66 /* moof */);
    if (!moof) {
        return -1;
    }
    var traf = getAtomContent(moof, 0x74726166 /* traf */);
    if (!traf) {
        return -1;
    }
    var index = findAtom(traf, 0x7472756e /* tfdt */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = traf[pos];
    pos += 1;
    if (version > 1) {
        return -1;
    }
    var flags = bytes_1.be3toi(traf, pos);
    pos += 3;
    var hasSampleDuration = flags & 0x000100;
    var defaultDuration = 0;
    if (!hasSampleDuration) {
        defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
        if (defaultDuration >= 0) {
            return defaultDuration;
        }
        return -1;
    }
    var hasDataOffset = flags & 0x000001;
    var hasFirstSampleFlags = flags & 0x000004;
    var hasSampleSize = flags & 0x000200;
    var hasSampleFlags = flags & 0x000400;
    var hasSampleCompositionOffset = flags & 0x000800;
    var sampleCounts = bytes_1.be4toi(traf, pos);
    pos += 4;
    if (hasDataOffset) {
        pos += 4;
    }
    if (hasFirstSampleFlags) {
        pos += 4;
    }
    var i = sampleCounts;
    var duration = 0;
    while (i--) {
        if (hasSampleDuration) {
            duration += bytes_1.be4toi(traf, pos);
            pos += 4;
        }
        else {
            duration += defaultDuration;
        }
        if (hasSampleSize) {
            pos += 4;
        }
        if (hasSampleFlags) {
            pos += 4;
        }
        if (hasSampleCompositionOffset) {
            pos += 4;
        }
    }
    return duration;
}
exports.getDurationFromTrun = getDurationFromTrun;
/**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function getMDHDTimescale(buffer) {
    var moov = getAtomContent(buffer, 0x6d6f6f76 /* moov */);
    if (!moov) {
        return -1;
    }
    var trak = getAtomContent(moov, 0x7472616b /* "trak" */);
    if (!trak) {
        return -1;
    }
    var mdia = getAtomContent(trak, 0x6d646961 /* "mdia" */);
    if (!mdia) {
        return -1;
    }
    var index = findAtom(mdia, 0x6d646864 /* "mdhd" */);
    if (index === -1) {
        return -1;
    }
    var pos = index + /* size */ 4 + /* name */ 4;
    var version = mdia[pos];
    pos += 4;
    if (version === 1) {
        pos += 16;
        return bytes_1.be4toi(mdia, pos);
    }
    else if (version === 0) {
        pos += 8;
        return bytes_1.be4toi(mdia, pos);
    }
    else {
        return -1;
    }
}
exports.getMDHDTimescale = getMDHDTimescale;
/**
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {UInt8Array|null}
 */
function getAtomContent(buf, atomName) {
    var l = buf.length;
    var i = 0;
    var name;
    var size = 0;
    while (i + 8 < l) {
        size = bytes_1.be4toi(buf, i);
        name = bytes_1.be4toi(buf, i + 4);
        assert_1.default(size > 0, "out of range size");
        if (name === atomName) {
            break;
        }
        else {
            i += size;
        }
    }
    if (i < l) {
        return buf.subarray(i + 8, i + size);
    }
    else {
        return null;
    }
}
/**
 * @param {Uint8Array} buf - The isobmff
 * @returns {Uint8Array|null} - Content of the mdat atom, null if not found
 */
function getMdat(buf) {
    return getAtomContent(buf, 0x6D646174 /* "mdat" */);
}
exports.getMdat = getMdat;
/**
 * Create a new _Atom_ (isobmff box).
 * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)
 * @param {Uint8Array} buff - The box's content
 */
function Atom(name, buff) {
    var len = buff.length + 8;
    return bytes_1.concat(bytes_1.itobe4(len), bytes_1.strToBytes(name), buff);
}
/**
 * Returns a PSSH Atom from a systemId and private data.
 * @param {Object} args
 * @returns {Uint8Array}
 */
function createPssh(_a) {
    var systemId = _a.systemId, privateData = _a.privateData;
    var _systemId = systemId.replace(/-/g, "");
    assert_1.default(_systemId.length === 32);
    return Atom("pssh", bytes_1.concat(4, // 4 initial zeroed bytes
    bytes_1.hexToBytes(_systemId), bytes_1.itobe4(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the pssList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} pssList - The content protections under the form of
 * objects containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {*}: private data associated.
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */
function patchPssh(buf, pssList) {
    if (!pssList || !pssList.length) {
        return buf;
    }
    var pos = findAtom(buf, 0x6d6f6f76 /* = "moov" */);
    if (pos === -1) {
        return buf;
    }
    var size = bytes_1.be4toi(buf, pos); // size of the "moov" box
    var moov = buf.subarray(pos, pos + size);
    var moovArr = [moov];
    for (var i = 0; i < pssList.length; i++) {
        moovArr.push(createPssh(pssList[i]));
    }
    var newmoov = bytes_1.concat.apply(void 0, moovArr);
    newmoov.set(bytes_1.itobe4(newmoov.length), 0); // overwrite "moov" length
    return bytes_1.concat(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));
}
exports.patchPssh = patchPssh;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ISO_639_1_to_ISO_639_3_1 = __webpack_require__(242);
var ISO_639_2_to_ISO_639_3_1 = __webpack_require__(243);
/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
function normalize(_language) {
    if (_language == null || _language === "") {
        return "";
    }
    var fields = ("" + _language).toLowerCase().split("-");
    var base = fields[0];
    var normalizedBase = normalizeBase(base);
    if (normalizedBase) {
        fields[0] = normalizedBase;
    }
    return fields.join("-");
}
exports.normalize = normalize;
/**
 * Normalize language into an ISO639-3 format.
 * @param {string} base
 * @returns {string}
 */
function normalizeBase(base) {
    var result;
    switch (base.length) {
        case 2:
            result = ISO_639_1_to_ISO_639_3_1.default[base];
            break;
        case 3:
            result = ISO_639_2_to_ISO_639_3_1.default[base];
            break;
    }
    return result || base;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeTextTrack(_language) {
    if (_language != null) {
        var language = void 0;
        var closedCaption = void 0;
        if (typeof _language === "string") {
            language = _language;
            closedCaption = false;
        }
        else {
            language = _language.language;
            closedCaption = !!_language.closedCaption;
        }
        return {
            language: language,
            closedCaption: closedCaption,
            normalized: normalize(language),
        };
    }
    return _language;
}
exports.normalizeTextTrack = normalizeTextTrack;
/**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeAudioTrack(_language) {
    if (_language != null) {
        var language = void 0;
        var audioDescription = void 0;
        if (typeof _language === "string") {
            language = _language;
            audioDescription = false;
        }
        else {
            language = _language.language;
            audioDescription = !!_language.audioDescription;
        }
        return {
            language: language,
            audioDescription: audioDescription,
            normalized: normalize(language),
        };
    }
    return _language;
}
exports.normalizeAudioTrack = normalizeAudioTrack;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
// TODO Both InitSegment and Segment
var Segment /* implements ISegment */ = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} [args={}]
     * @param {string|Number} [args.id]
     * @param {Number} [args.duration]
     * @param {Boolean} [args.init=false]
     * @param {Number} [args.time]
     * @param {Array.<Number>} [args.range]
     * @param {Array.<Number>} [args.indexRange]
     * @param {Number} [args.number]
     * @param {Number} [args.timescale]
     * @param {string} [args.media]
     */
    function Segment(args) {
        if (false) {
            if (!args.init) {
                assert_1.default(typeof args.time === "number" && args.time >= 0);
            }
            assert_1.default(args.id);
            assert_1.default(args.timescale);
        }
        this.id = args.id;
        this.duration = args.duration;
        this.isInit = !!args.init;
        this.range = args.range || undefined;
        this.time = args.time || 0;
        this.indexRange = args.indexRange || undefined;
        this.number = args.number;
        this.timescale = args.timescale == null ? 1 : args.timescale;
        this.media = args.media || "";
    }
    return Segment;
}());
exports.default = Segment;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var errorObject_1 = __webpack_require__(31);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(11);
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(11);
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;
//# sourceMappingURL=observable.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = (function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        }
        else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable));
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var root_1 = __webpack_require__(11);
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = __webpack_require__(14);
var OuterSubscriber_1 = __webpack_require__(13);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
    };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ConnectableObservable_1 = __webpack_require__(184);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var queue_1 = __webpack_require__(226);
var Subscription_1 = __webpack_require__(12);
var observeOn_1 = __webpack_require__(66);
var ObjectUnsubscribedError_1 = __webpack_require__(45);
var SubjectSubscription_1 = __webpack_require__(78);
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
/**
 * Returns a fromEvent on the given element for the given event(s).
 * @param {Element|Document|Window}
 * @param {Array.<string>|string}
 * @returns {Observable}
 */
function onEvent(elt, evts) {
    if (Array.isArray(evts)) {
        var eventsArray = evts.map(function (evt) { return Observable_1.Observable.fromEvent(elt, evt); });
        return Observable_1.Observable.merge.apply(Observable_1.Observable, eventsArray);
    }
    else {
        return Observable_1.Observable.fromEvent(elt, evts);
    }
}
exports.default = onEvent;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(26);
var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
exports.BROWSER_PREFIXES = BROWSER_PREFIXES;
var win = window;
var HTMLElement_ = win.HTMLElement;
exports.HTMLElement_ = HTMLElement_;
var VTTCue_ = win.VTTCue || win.TextTrackCue;
exports.VTTCue_ = VTTCue_;
var MediaSource_ = (win.MediaSource ||
    win.MozMediaSource ||
    win.WebKitMediaSource ||
    win.MSMediaSource);
exports.MediaSource_ = MediaSource_;
var MediaKeys_ = (win.MediaKeys ||
    win.MozMediaKeys ||
    win.WebKitMediaKeys ||
    win.MSMediaKeys);
exports.MediaKeys_ = MediaKeys_;
if (!MediaKeys_) {
    var noMediaKeys_1 = function () {
        throw new MediaError_1.default("MEDIA_KEYS_NOT_SUPPORTED", null, true);
    };
    exports.MediaKeys_ = MediaKeys_ = /** @class */ (function () {
        function class_1() {
            this.create = noMediaKeys_1;
            this.createSession = noMediaKeys_1;
            this.isTypeSupported = noMediaKeys_1;
            this.setServerCertificate = noMediaKeys_1;
        }
        return class_1;
    }());
}
// true for IE / Edge
var isIE = (navigator.appName === "Microsoft Internet Explorer" ||
    navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent));
exports.isIE = isIE;
var isFirefox = (navigator.userAgent.toLowerCase().indexOf("firefox") !== -1);
exports.isFirefox = isFirefox;
var READY_STATES = {
    HAVE_NOTHING: 0,
    HAVE_METADATA: 1,
    HAVE_CURRENT_DATA: 2,
    HAVE_FUTURE_DATA: 3,
    HAVE_ENOUGH_DATA: 4,
};
exports.READY_STATES = READY_STATES;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var assert_1 = __webpack_require__(2);
var bytes_1 = __webpack_require__(28);
/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */
var SAMPLING_FREQUENCIES = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
];
/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */
var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
function boxName(str) {
    if (boxNamesMem[str]) {
        return boxNamesMem[str];
    }
    var nameInBytes = bytes_1.strToBytes(str);
    boxNamesMem[str] = nameInBytes;
    return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */
function Atom(name, buff) {
    if (false) {
        assert_1.default(name.length === 4);
    }
    var len = buff.length + 8;
    return bytes_1.concat(bytes_1.itobe4(len), boxName(name), buff);
}
/**
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */
function readUuid(buf, id1, id2, id3, id4) {
    var l = buf.length;
    var i = 0;
    var len;
    while (i < l) {
        len = bytes_1.be4toi(buf, i);
        if (bytes_1.be4toi(buf, i + 4) === 0x75756964 /* === "uuid" */ &&
            bytes_1.be4toi(buf, i + 8) === id1 &&
            bytes_1.be4toi(buf, i + 12) === id2 &&
            bytes_1.be4toi(buf, i + 16) === id3 &&
            bytes_1.be4toi(buf, i + 20) === id4) {
            return buf.subarray(i + 24, i + len);
        }
        i += len;
    }
}
/**
 * @param {Uint8Array} buf
 * @param {Number} atomName
 * @returns {Uint8Array|null}
 */
function findAtom(buf, atomName) {
    var l = buf.length;
    var i = 0;
    var name;
    var size = 0;
    while (i + 8 < l) {
        size = bytes_1.be4toi(buf, i);
        name = bytes_1.be4toi(buf, i + 4);
        assert_1.default(size > 0, "smooth: out of range size");
        if (name === atomName) {
            break;
        }
        else {
            i += size;
        }
    }
    if (i < l) {
        return buf.subarray(i + 8, i + size);
    }
    else {
        return null;
    }
}
var atoms = {
    /**
     * @param {string} name
     * @param {Array.<Uint8Array>} children
     * @returns {Uint8Array}
     */
    mult: function (name, children) {
        return Atom(name, bytes_1.concat.apply(null, children));
    },
    /**
     * @param {string} name - "avc1" or "encv"
     * @param {Number} drefIdx - shall be 1
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes - horizontal resolution, eg 72
     * @param {Number} vRes - horizontal resolution, eg 72
     * @param {string} encDepth
     * @param {Number} colorDepth - eg 24
     * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "encv"
     * @returns {Uint8Array}
     */
    avc1encv: function (name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
        if (false) {
            assert_1.default(name === "avc1" || name === "encv", "should be avc1 or encv atom");
            assert_1.default(name !== "encv" || sinf instanceof Uint8Array);
        }
        return Atom(name, bytes_1.concat(6, // 6 bytes reserved
        bytes_1.itobe2(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes
        bytes_1.itobe2(width), // size 2 w
        bytes_1.itobe2(height), // size 2 h
        bytes_1.itobe2(hRes), 2, // reso 4 h
        bytes_1.itobe2(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
        [0, 1, encName.length], // frame count (default 1)
        bytes_1.strToBytes(encName), // 1byte len + encoder name str
        (31 - encName.length), // + padding
        bytes_1.itobe2(colorDepth), // color depth
        [0xFF, 0xFF], // reserved ones
        avcc, // avcc atom,
        name === "encv" ? sinf || [] : []));
    },
    /**
     * @param {Uint8Array} sps
     * @param {Uint8Array} pps
     * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
     * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
     * 1, "68ef3880")
     * @returns {Uint8Array}
     */
    avcc: function (sps, pps, nalLen) {
        var nal = (nalLen === 2) ?
            0x1 : (nalLen === 4) ?
            0x3 : 0x0;
        // Deduce AVC Profile from SPS
        var h264Profile = sps[1];
        var h264CompatibleProfile = sps[2];
        var h264Level = sps[3];
        return Atom("avcC", bytes_1.concat([
            1,
            h264Profile,
            h264CompatibleProfile,
            h264Level,
            (0x3F << 2 | nal),
            (0xE0 | 1),
        ], bytes_1.itobe2(sps.length), sps, [1], bytes_1.itobe2(pps.length), pps));
    },
    /**
     * @param {url} Uint8Array
     * @returns {Uint8Array}
     */
    dref: function (url) {
        // only one description here... FIXME
        return Atom("dref", bytes_1.concat(7, [1], url));
    },
    /**
     * @param {Number} stream
     * @param {string} codecPrivateData - hex string
     * eg: esds(1, 98800, "1190")
     * @returns {Uint8Array}
     */
    esds: function (stream, codecPrivateData) {
        return Atom("esds", bytes_1.concat(4, [0x03, 0x19], bytes_1.itobe2(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], bytes_1.hexToBytes(codecPrivateData), [0x06, 0x01, 0x02]));
    },
    /**
     * @param {string} dataFormat - four letters (eg "avc1")
     * @returns {Uint8Array}
     */
    frma: function (dataFormat) {
        if (false) {
            assert_1.default.equal(dataFormat.length, 4, "wrong data format length");
        }
        return Atom("frma", bytes_1.strToBytes(dataFormat));
    },
    /**
     * @param {Number} length
     * @returns {Uint8Array}
     */
    free: function (length) {
        return Atom("free", new Uint8Array(length - 8));
    },
    /**
     * @param {string} majorBrand
     * @param {Array.<string>} brands
     * @returns {Uint8Array}
     */
    ftyp: function (majorBrand, brands) {
        return Atom("ftyp", bytes_1.concat.apply(null, [
            bytes_1.strToBytes(majorBrand),
            [0, 0, 0, 1],
        ].concat(brands.map(bytes_1.strToBytes))));
    },
    /**
     * @param {string} type - "video" or "audio"
     * @returns {Uint8Array}
     */
    hdlr: function (type) {
        var name;
        var handlerName;
        switch (type) {
            case "video":
                name = "vide";
                handlerName = "VideoHandler";
                break;
            case "audio":
                name = "soun";
                handlerName = "SoundHandler";
                break;
            default:
                name = "hint";
                handlerName = "";
                break;
        }
        return Atom("hdlr", bytes_1.concat(8, bytes_1.strToBytes(name), 12, bytes_1.strToBytes(handlerName), 1 // handler name is C-style string (0 terminated)
        ));
    },
    /**
     * @param {number} timescale
     * @returns {Uint8Array}
     */
    mdhd: function (timescale) {
        return Atom("mdhd", bytes_1.concat(12, bytes_1.itobe4(timescale), 8));
    },
    /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} traf
     * @returns {Uint8Array}
     */
    moof: function (mfhd, traf) {
        return atoms.mult("moof", [mfhd, traf]);
    },
    /**
     * @param {string} name - "mp4a" or "enca"
     * @param {Number} drefIdx
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {Uint8Array} esds - Uint8Array representing the esds atom
     * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
     * only if name == "enca"
     * @returns {Uint8Array}
     */
    mp4aenca: function (name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
        if (false) {
            assert_1.default(name !== "enca" || sinf instanceof Uint8Array);
        }
        return Atom(name, bytes_1.concat(6, bytes_1.itobe2(drefIdx), 8, bytes_1.itobe2(channelsCount), bytes_1.itobe2(sampleSize), 2, bytes_1.itobe2(packetSize), bytes_1.itobe2(sampleRate), 2, esds, (name === "enca") ? sinf || [] : []));
    },
    /**
     * @param {Number} timescale
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    mvhd: function (timescale, trackId) {
        return Atom("mvhd", bytes_1.concat(12, bytes_1.itobe4(timescale), 4, [0, 1], 2, // we assume rate = 1;
        [1, 0], 10, // we assume volume = 100%;
        [0, 1], 14, // default matrix
        [0, 1], 14, // default matrix
        [64, 0, 0, 0], 26, bytes_1.itobe2(trackId + 1) // next trackId (=trackId + 1);
        ));
    },
    /**
     * @param {string} systemId - Hex string representing the CDM, 16 bytes.
     * @param {Uint8Array} [privateData=[]] - Data associated to protection
     * specific system.
     * @param {[]Uint8Array} keyIds - List of key ids contained in the PSSH
     * @returns {Uint8Array}
     */
    pssh: function (systemId, privateData, keyIds) {
        if (privateData === void 0) { privateData = new Uint8Array(0); }
        if (keyIds === void 0) { keyIds = new Uint8Array(0); }
        var _systemId = systemId.replace(/-/g, "");
        assert_1.default(_systemId.length === 32, "wrong system id length");
        var version;
        var kidList;
        var kidCount = keyIds.length;
        if (kidCount > 0) {
            version = 1;
            kidList = bytes_1.concat.apply(void 0, [bytes_1.itobe4(kidCount)].concat(keyIds));
        }
        else {
            version = 0;
            kidList = [];
        }
        return Atom("pssh", bytes_1.concat([version, 0, 0, 0], bytes_1.hexToBytes(_systemId), kidList, bytes_1.itobe4(privateData.length), privateData));
    },
    /**
     * @param {Uint8Array} mfhd
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @returns {Uint8Array}
     */
    saio: function (mfhd, tfhd, tfdt, trun) {
        return Atom("saio", bytes_1.concat(4, [0, 0, 0, 1], // ??
        bytes_1.itobe4(mfhd.length +
            tfhd.length +
            tfdt.length +
            trun.length +
            8 + 8 + 8 + 8)));
    },
    /**
     * @param {Uint8Array} sencData - including 8 bytes flags and entries count
     * @returns {Uint8Array}
     */
    saiz: function (senc) {
        if (senc.length === 0) {
            return Atom("saiz", new Uint8Array(0));
        }
        var flags = bytes_1.be4toi(senc, 0);
        var entries = bytes_1.be4toi(senc, 4);
        var arr = new Uint8Array(entries + 9);
        arr.set(bytes_1.itobe4(entries), 5);
        var i = 9;
        var j = 8;
        var pairsCnt;
        var pairsLen;
        while (j < senc.length) {
            j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
            // if we have extradata for each entry
            if ((flags & 0x2) === 0x2) {
                pairsLen = 2;
                pairsCnt = bytes_1.be2toi(senc, j);
                j += (pairsCnt * 6) + 2;
            }
            else {
                pairsCnt = 0;
                pairsLen = 0;
            }
            arr[i] = pairsCnt * 6 + 8 + pairsLen;
            i++;
        }
        return Atom("saiz", arr);
    },
    /**
     * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
     * @param {Number} schemeVersion - eg 65536
     * @returns {Uint8Array}
     */
    schm: function (schemeType, schemeVersion) {
        if (false) {
            assert_1.default.equal(schemeType.length, 4, "wrong scheme type length");
        }
        return Atom("schm", bytes_1.concat(4, bytes_1.strToBytes(schemeType), bytes_1.itobe4(schemeVersion)));
    },
    /**
     * @param {Uint8Array} buf
     * @returns {Uint8Array}
     */
    senc: function (buf) {
        return Atom("senc", buf);
    },
    /**
     * @returns {Uint8Array}
     */
    smhd: function () {
        return Atom("smhd", new Uint8Array(8));
    },
    /**
     * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
     * typically [avc1] or [encv, avc1]
     * @returns {Uint8Array}
     */
    stsd: function (reps) {
        // only one description here... FIXME
        var arrBase = [7, [reps.length]];
        return Atom("stsd", bytes_1.concat.apply(void 0, arrBase.concat(reps)));
    },
    /**
     * @param {Number} width
     * @param {Number} height
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    tkhd: function (width, height, trackId) {
        return Atom("tkhd", bytes_1.concat(bytes_1.itobe4(1 + 2 + 4), 8, // we assume track is enabled,
        // in media and in preview.
        bytes_1.itobe4(trackId), 20, // we assume trackId = 1;
        [1, 0, 0, 0], // we assume volume = 100%;
        [0, 1, 0, 0], 12, // default matrix
        [0, 1, 0, 0], 12, // default matrix
        [64, 0, 0, 0], // ??
        bytes_1.itobe2(width), 2, // width (TODO handle fixed)
        bytes_1.itobe2(height), 2 // height (TODO handle fixed)
        ));
    },
    /**
     * @param {Number} trackId
     * @returns {Uint8Array}
     */
    trex: function (trackId) {
        // default sample desc idx = 1
        return Atom("trex", bytes_1.concat(4, bytes_1.itobe4(trackId), [0, 0, 0, 1], 12));
    },
    /**
     * @param {Number} decodeTime
     * @returns {Uint8Array}
     */
    tfdt: function (decodeTime) {
        return Atom("tfdt", bytes_1.concat([1, 0, 0, 0], bytes_1.itobe8(decodeTime)));
    },
    /**
     * @param {Number} algId - eg 1
     * @param {Number} ivSize - eg 8
     * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
     * @returns {Uint8Array}
     */
    tenc: function (algId, ivSize, keyId) {
        if (false) {
            assert_1.default.equal(keyId.length, 32, "wrong default KID length");
        }
        return Atom("tenc", bytes_1.concat(6, [algId, ivSize], bytes_1.hexToBytes(keyId)));
    },
    /**
     * @param {Uint8Array} tfhd
     * @param {Uint8Array} tfdt
     * @param {Uint8Array} trun
     * @param {Uint8Array} senc
     * @param {Uint8Array} mfhd
     * @returns {Uint8Array}
     */
    traf: function (tfhd, tfdt, trun, mfhd, senc) {
        var trafs = [tfhd, tfdt, trun];
        if (senc) {
            trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun));
        }
        return atoms.mult("traf", trafs);
    },
    /**
     * @param {Uint8Array} oldtrun
     * @returns {Uint8Array}
     */
    trun: function (oldtrun) {
        var headersLast = oldtrun[11];
        var hasDataOffset = headersLast & 0x01;
        if (hasDataOffset) {
            return oldtrun;
        }
        // If no dataoffset is present, we change the headers and add one
        var trun = new Uint8Array(oldtrun.length + 4);
        trun.set(bytes_1.itobe4(oldtrun.length + 4), 0);
        trun.set(oldtrun.subarray(4, 16), 4); // name + (version + headers) +
        // samplecount
        trun[11] = trun[11] | 0x01; // add data offset header info
        trun.set([0, 0, 0, 0], 16); // data offset
        trun.set(oldtrun.subarray(16, oldtrun.length), 20);
        return trun;
    },
    /**
     * @returns {Uint8Array}
     */
    vmhd: function () {
        var arr = new Uint8Array(12);
        arr[3] = 1; // QuickTime...
        return Atom("vmhd", arr);
    },
};
var reads = {
    /**
     * @param {Uint8Array} buff
     * @returns {Uint8Array|null}
     */
    traf: function (buff) {
        var moof = findAtom(buff, 0x6D6F6F66);
        if (moof) {
            return findAtom(moof, 0x74726166);
        }
        else {
            return null;
        }
    },
    /**
     * Extract senc data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    senc: function (traf) {
        return readUuid(traf, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
    },
    /**
     * Extract tfxd data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    tfxd: function (traf) {
        return readUuid(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);
    },
    /**
     * Extract tfrf data (derived from UUID MS Atom)
     * @param {Uint8Array} traf
     * @returns {Uint8Array|undefined}
     */
    tfrf: function (traf) {
        return readUuid(traf, 0xD4807EF2, 0XCA394695, 0X8E5426CB, 0X9E46A79F);
    },
    /**
     * @param {Uint8Array} buff
     * @returns {Uint8Array|null}
     */
    mdat: function (buff) {
        return findAtom(buff, 0x6D646174 /* "mdat" */);
    },
};
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
function aacesHeader(type, frequency, chans) {
    var freq = SAMPLING_FREQUENCIES.indexOf(frequency);
    if (false) {
        assert_1.default(freq >= 0, "non supported frequency"); // TODO : handle Idx = 15...
    }
    var val;
    val = (type & 0x3F) << 0x4;
    val = (val | (freq & 0x1F)) << 0x4;
    val = (val | (chans & 0x1F)) << 0x3;
    return bytes_1.bytesToHex(bytes_1.itobe2(val));
}
/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */
function moovChildren(mvhd, mvex, trak, pssList) {
    var moov = [mvhd, mvex, trak];
    pssList.forEach(function (pss) {
        var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);
        moov.push(pssh);
    });
    return moov;
}
/**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Number} trunoffset
 * @param {Number} dataoffset
 */
function patchTrunDataOffset(segment, trunoffset, dataOffset) {
    // patch trun dataoffset with new moof atom size
    segment.set(bytes_1.itobe4(dataOffset), trunoffset + 16);
}
/**
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */
function createNewSegment(segment, newmoof, oldmoof, trunoffset) {
    var segmentlen = segment.length;
    var newmooflen = newmoof.length;
    var oldmooflen = oldmoof.length;
    var mdat = segment.subarray(oldmooflen, segmentlen);
    var newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));
    newSegment.set(newmoof, 0);
    newSegment.set(mdat, newmooflen);
    patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8);
    return newSegment;
}
/**
 * /!\ Mutates given segment
 * @param {Uint8Array} segment
 * @param {Uint8Array} newmoof
 * @param {Uint8Array} oldmoof
 * @param {Number} trunoffset
 * @returns {Uint8Array}
 */
function patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {
    var free = oldmoof.length - newmoof.length;
    segment.set(newmoof, 0);
    segment.set(atoms.free(free), newmoof.length);
    patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free);
    return segment;
}
/**
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
    var stbl = atoms.mult("stbl", [
        stsd,
        Atom("stts", new Uint8Array(0x08)),
        Atom("stsc", new Uint8Array(0x08)),
        Atom("stsz", new Uint8Array(0x0c)),
        Atom("stco", new Uint8Array(0x08)),
    ]);
    var url = Atom("url ", new Uint8Array([0, 0, 0, 1]));
    var dref = atoms.dref(url);
    var dinf = atoms.mult("dinf", [dref]);
    var minf = atoms.mult("minf", [mhd, dinf, stbl]);
    var hdlr = atoms.hdlr(type);
    var mdhd = atoms.mdhd(timescale); // this one is really important
    var mdia = atoms.mult("mdia", [mdhd, hdlr, minf]);
    var tkhd = atoms.tkhd(width, height, 1);
    var trak = atoms.mult("trak", [tkhd, mdia]);
    var trex = atoms.trex(1);
    var mvex = atoms.mult("mvex", [trex]);
    var mvhd = atoms.mvhd(timescale, 1); // in fact, we don't give a sh** about
    // this value :O
    var moov = atoms.mult("moov", moovChildren(mvhd, mvex, trak, pssList));
    var ftyp = atoms.ftyp("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
    return bytes_1.concat(ftyp, moov);
}
// TODO
exports.default = {
    getMdat: reads.mdat,
    getTraf: reads.traf,
    /**
     * @param {Uint8Array} traf
     * @returns {Array.<Object>}
     */
    parseTfrf: function (traf) {
        var tfrf = reads.tfrf(traf);
        if (!tfrf) {
            return [];
        }
        var frags = [];
        var version = tfrf[0];
        var fragCount = tfrf[4];
        for (var i = 0; i < fragCount; i++) {
            var duration = void 0;
            var time = void 0;
            if (version === 1) {
                time = bytes_1.be8toi(tfrf, i * 16 + 5);
                duration = bytes_1.be8toi(tfrf, i * 16 + 5 + 8);
            }
            else {
                time = bytes_1.be4toi(tfrf, i * 8 + 5);
                duration = bytes_1.be4toi(tfrf, i * 8 + 5 + 4);
            }
            frags.push({
                time: time,
                duration: duration,
            });
        }
        return frags;
    },
    /**
     * @param {Uint8Array} traf
     * @returns {Object|undefined}
     */
    parseTfxd: function (traf) {
        var tfxd = reads.tfxd(traf);
        if (tfxd) {
            return {
                duration: bytes_1.be8toi(tfxd, 12),
                time: bytes_1.be8toi(tfxd, 4),
            };
        }
    },
    /**
     * Return full video Init segment as Uint8Array
     * @param {Number} timescale - lowest number, this one will be set into mdhd
     * *10000 in mvhd, e.g. 1000
     * @param {Number} width
     * @param {Number} height
     * @param {Number} hRes
     * @param {Number} vRes
     * @param {Number} nalLength (1, 2 or 4)
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id,
     * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
     * @returns {Uint8Array}
     */
    createVideoInitSegment: function (timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
        var _pssList = pssList || [];
        var _a = codecPrivateData.split("00000001"), spsHex = _a[1], ppsHex = _a[2];
        var sps = bytes_1.hexToBytes(spsHex);
        var pps = bytes_1.hexToBytes(ppsHex);
        // TODO NAL length is forced to 4
        var avcc = atoms.avcc(sps, pps, nalLength);
        var stsd;
        if (!_pssList.length || keyId == null) {
            var avc1 = atoms.avc1encv("avc1", // name
            1, // drefIdx
            width, height, hRes, vRes, "AVC Coding", // encName
            24, // color depth
            avcc);
            stsd = atoms.stsd([avc1]);
        }
        else {
            var tenc = atoms.tenc(1, 8, keyId);
            var schi = atoms.mult("schi", [tenc]);
            var schm = atoms.schm("cenc", 65536);
            var frma = atoms.frma("avc1");
            var sinf = atoms.mult("sinf", [frma, schm, schi]);
            var encv = atoms.avc1encv("encv", 1, width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
            stsd = atoms.stsd([encv]);
        }
        return createInitSegment(timescale, "video", stsd, atoms.vmhd(), width, height, _pssList);
    },
    /**
     * Return full audio Init segment as Uint8Array
     * @param {Number} timescale
     * @param {Number} channelsCount
     * @param {Number} sampleSize
     * @param {Number} packetSize
     * @param {Number} sampleRate
     * @param {string} codecPrivateData
     * @param {string} keyId - hex string representing the key Id, 32 chars.
     * eg. a800dbed49c12c4cb8e0b25643844b9b
     * @param {Array.<Object>} [pssList] - List of dict, example:
     * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF"}
     * @returns {Uint8Array}
     */
    createAudioInitSegment: function (timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
        var _pssList = pssList || [];
        var _codecPrivateData = codecPrivateData || aacesHeader(2, sampleRate, channelsCount);
        var esds = atoms.esds(1, _codecPrivateData);
        var stsd;
        if (!_pssList.length || keyId == null) {
            var mp4a = atoms.mp4aenca("mp4a", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);
            stsd = atoms.stsd([mp4a]);
        }
        else {
            var tenc = atoms.tenc(1, 8, keyId);
            var schi = atoms.mult("schi", [tenc]);
            var schm = atoms.schm("cenc", 65536);
            var frma = atoms.frma("mp4a");
            var sinf = atoms.mult("sinf", [frma, schm, schi]);
            var enca = atoms.mp4aenca("enca", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
            stsd = atoms.stsd([enca]);
        }
        return createInitSegment(timescale, "audio", stsd, atoms.smhd(), 0, 0, _pssList);
    },
    /**
     * Add decodeTime info in a segment (tfdt box)
     * @param {Uint8Array} segment
     * @param {Number} decodeTime
     * @return {Uint8Array}
     */
    patchSegment: function (segment, decodeTime) {
        if (false) {
            // TODO handle segments with styp/free...
            var name_1 = bytes_1.bytesToStr(segment.subarray(4, 8));
            assert_1.default(name_1 === "moof");
        }
        var oldmoof = segment.subarray(0, bytes_1.be4toi(segment, 0));
        var newtfdt = atoms.tfdt(decodeTime);
        // reads [moof[mfhd|traf[tfhd|trun|..]]]
        var tfdtlen = newtfdt.length;
        var mfhdlen = bytes_1.be4toi(oldmoof, 8);
        var traflen = bytes_1.be4toi(oldmoof, mfhdlen + 8);
        var tfhdlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8);
        var trunlen = bytes_1.be4toi(oldmoof, mfhdlen + 8 + 8 + tfhdlen);
        var oldmfhd = oldmoof.subarray(8, mfhdlen + 8);
        var oldtraf = oldmoof
            .subarray(mfhdlen + 8 + 8, mfhdlen + 8 + 8 + traflen - 8);
        var oldtfhd = oldtraf.subarray(0, tfhdlen);
        var oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);
        // force trackId=1 since trackIds are not always reliable...
        oldtfhd.set([0, 0, 0, 1], 12);
        // TODO fallback?
        var oldsenc = reads.senc(oldtraf);
        // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]
        var newtrun = atoms.trun(oldtrun);
        var newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldmfhd, oldsenc);
        var newmoof = atoms.moof(oldmfhd, newtraf);
        var trunoffset = mfhdlen + 8 + 8 + tfhdlen + tfdtlen;
        // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
        // try to put free atom inside traf children
        if (compat_1.isIE) {
            return createNewSegment(segment, newmoof, oldmoof, trunoffset);
        }
        else {
            if (oldmoof.length - newmoof.length >= 8 /* minimum "free" atom size */) {
                return patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset);
            }
            else {
                return createNewSegment(segment, newmoof, oldmoof, trunoffset);
            }
        }
    },
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(representation, dlSegment, nextSegments) {
    if (dlSegment.duration != null &&
        dlSegment.timescale != null) {
        // TODO TypeScript bug?
        representation.index._addSegments(nextSegments, dlSegment);
    }
}
exports.addNextSegments = addNextSegments;
/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */
function pad(n, l) {
    var nToString = n.toString();
    if (nToString.length >= l) {
        return nToString;
    }
    var arr = new Array(l + 1).join("0") + nToString;
    return arr.slice(-l);
}
exports.pad = pad;
/**
 * Add formatting when asked in a token (add padding to numbers).
 * @param {string|Number} replacer - the token value
 * @returns {Function} - @see replaceTokens
 */
function processFormatedToken(replacer) {
    return function (_match, _format, widthStr) {
        var width = widthStr ? parseInt(widthStr, 10) : 1;
        return pad("" + replacer, width);
    };
}
exports.processFormatedToken = processFormatedToken;
/**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {Segment} segment
 * @param {Representation} representation
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */
function replaceTokens(path, segment, representation) {
    if (path.indexOf("$") === -1) {
        return path;
    }
    else {
        return path
            .replace(/\$\$/g, "$")
            .replace(/\$RepresentationID\$/g, String(representation.id))
            .replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(representation.bitrate))
            .replace(/\$Number(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
            if (segment.number == null) {
                throw new Error("Segment number not defined in a $Number$ scheme");
            }
            return processFormatedToken(segment.number)(_x, _y, widthStr);
        })
            .replace(/\$Time(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
            if (segment.time == null) {
                throw new Error("Segment time not defined in a $Time$ scheme");
            }
            return processFormatedToken(segment.time)(_x, _y, widthStr);
        });
    }
}
exports.replaceTokens = replaceTokens;
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
    return representation.mimeType === "application/mp4";
}
exports.isMP4EmbeddedTrack = isMP4EmbeddedTrack;
/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>}
 * @returns {string}
 */
function byteRange(_a) {
    var start = _a[0], end = _a[1];
    if (!end || end === Infinity) {
        return "bytes=" + (+start) + "-";
    }
    else {
        return "bytes=" + (+start) + "-" + (+end);
    }
}
exports.byteRange = byteRange;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var _lastId = 0;
/**
 * @returns {string}
 */
function generateNewId() {
    var newId = 0;
    if (_lastId < Number.MAX_VALUE) {
        newId = _lastId + 1;
    }
    _lastId = newId;
    return "" + newId;
}
exports.default = generateNewId;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO This file should probably be moved somewhere in the net folder
// TODO Should also probably a class implementing an interface e.g.
// IIndexManager (with the index in state?)
var segment_1 = __webpack_require__(35);
var helpers_1 = __webpack_require__(30);
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */
function getSegmentIndex(index, ts) {
    var timeline = index.timeline;
    var low = 0;
    var high = timeline.length;
    while (low < high) {
        var mid = (low + high) >>> 1;
        if (timeline[mid].ts < ts) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return (low > 0)
        ? low - 1
        : low;
}
/**
 * @param {Number} ts
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
function getSegmentNumber(ts, up, duration) {
    var diff = up - ts;
    if (diff > 0) {
        return Math.floor(diff / duration);
    }
    else {
        return 0;
    }
}
var SegmentTimelineHelpers = {
    getInitSegment: helpers_1.getInitSegment,
    setTimescale: helpers_1.setTimescale,
    scale: helpers_1.scale,
    /**
     * @param {string|Number} repId
     * @param {Object} index
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Segment>}
     */
    getSegments: function (repId, index, _up, _to) {
        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        var timeline = index.timeline, timescale = index.timescale, media = index.media, startNumber = index.startNumber;
        var currentNumber = startNumber != null ? startNumber : undefined;
        var segments = [];
        var timelineLength = timeline.length;
        // TODO(pierre): use @maxSegmentDuration if possible
        var maxEncounteredDuration = (timeline.length && timeline[0].d) || 0;
        for (var i = 0; i < timelineLength; i++) {
            var segmentRange = timeline[i];
            var d = segmentRange.d, ts = segmentRange.ts, range = segmentRange.range;
            maxEncounteredDuration = Math.max(maxEncounteredDuration, d);
            // live-added segments have @d attribute equals to -1
            if (d < 0) {
                // TODO what? May be to play it safe and avoid adding segments which are
                // not completely generated
                if (ts + maxEncounteredDuration < to) {
                    var segment = new segment_1.default({
                        id: "" + repId + "_" + ts,
                        time: ts,
                        init: false,
                        range: range,
                        duration: undefined,
                        indexRange: null,
                        timescale: timescale,
                        media: media,
                        number: currentNumber != null ? currentNumber : undefined,
                    });
                    segments.push(segment);
                }
                return segments;
            }
            var repeat = helpers_1.calculateRepeat(segmentRange, timeline[i + 1]);
            var segmentNumberInCurrentRange = getSegmentNumber(ts, up, d);
            var segmentTime = ts + segmentNumberInCurrentRange * d;
            while (segmentTime < to && segmentNumberInCurrentRange <= repeat) {
                var segment = new segment_1.default({
                    id: "" + repId + "_" + segmentTime,
                    time: segmentTime,
                    init: false,
                    range: range,
                    duration: d,
                    indexRange: null,
                    timescale: timescale,
                    media: media,
                    number: currentNumber != null ?
                        currentNumber + segmentNumberInCurrentRange : undefined,
                });
                segments.push(segment);
                // update segment number and segment time for the next segment
                segmentNumberInCurrentRange++;
                segmentTime = ts + segmentNumberInCurrentRange * d;
            }
            if (segmentTime >= to) {
                // we reached ``to``, we're done
                return segments;
            }
            if (currentNumber != null) {
                currentNumber += repeat + 1;
            }
        }
        return segments;
    },
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * @param {Object} index
     * @param {Number} time
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh: function (index, _, _up, to) {
        var timeline = index.timeline, timescale = index.timescale, _a = index.presentationTimeOffset, presentationTimeOffset = _a === void 0 ? 0 : _a;
        var scaledTo = to * timescale - presentationTimeOffset;
        var last = timeline[timeline.length - 1];
        if (!last) {
            return false;
        }
        if (last.d < 0) {
            last = { ts: last.ts, d: 0, r: last.r };
        }
        return !(scaledTo <= helpers_1.getTimelineRangeEnd(last));
    },
    /**
     * Returns first position in index.
     * @param {Object} index
     * @returns {Number}
     */
    getFirstPosition: function (index) {
        if (!index.timeline.length) {
            return undefined;
        }
        return index.timeline[0].ts / index.timescale;
    },
    /**
     * Returns last position in index.
     * @param {Object} index
     * @returns {Number}
     */
    getLastPosition: function (index) {
        if (!index.timeline.length) {
            return undefined;
        }
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);
    },
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Object} index
     * @param {Number} _time
     * @returns {Number} - If a discontinuity is present, this is the Starting ts
     * for the next (discontinuited) range. If not this is equal to -1.
     */
    checkDiscontinuity: function (index, _time) {
        var timeline = index.timeline, _a = index.timescale, timescale = _a === void 0 ? 1 : _a;
        var time = _time * timescale;
        if (time <= 0) {
            return -1;
        }
        var segmentIndex = getSegmentIndex(index, time);
        if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
            return -1;
        }
        var range = timeline[segmentIndex];
        if (range.d === -1) {
            return -1;
        }
        var rangeUp = range.ts;
        var rangeTo = helpers_1.getTimelineRangeEnd(range);
        var nextRange = timeline[segmentIndex + 1];
        // when we are actually inside the found range and this range has
        // an explicit discontinuity with the next one
        if (rangeTo !== nextRange.ts &&
            time >= rangeUp &&
            time <= rangeTo &&
            (rangeTo - time) < timescale) {
            return nextRange.ts / timescale;
        }
        return -1;
    },
    /**
     * Add a new segment to the index.
     *
     * /!\ Mutate the given index
     * @param {Object} index
     * @param {Object} newSegment
     * @param {Number} newSegment.timescale
     * @param {Number} newSegment.time
     * @param {Number} newSegment.duration
     * @param {Object} currentSegment
     * @param {Number} currentSegment.timescale
     * @param {Number} currentSegment.time
     * @returns {Boolean} - true if the segment has been added
     */
    _addSegmentInfos: function (index, newSegment, currentSegment) {
        var timeline = index.timeline, timescale = index.timescale;
        var timelineLength = timeline.length;
        var last = timeline[timelineLength - 1];
        var scaledNewSegment = newSegment.timescale === timescale ? {
            time: newSegment.time,
            duration: newSegment.duration,
        } : {
            time: (newSegment.time / newSegment.timescale) * timescale,
            duration: (newSegment.duration / newSegment.timescale) * timescale,
        };
        var scaledCurrentTime;
        if (currentSegment) {
            scaledCurrentTime = currentSegment.timescale === timescale ?
                currentSegment.time :
                (currentSegment.time / currentSegment.timescale) * timescale;
        }
        // in some circumstances, the new segment informations are only
        // duration informations that we can use to deduct the ts of the
        // next segment. this is the case where the new segment are
        // associated to a current segment and have the same ts
        var shouldDeductNextSegment = scaledCurrentTime != null &&
            (scaledNewSegment.time === scaledCurrentTime);
        if (shouldDeductNextSegment) {
            var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;
            var lastSegmentTs = (last.ts + last.d * last.r);
            var tsDiff = newSegmentTs - lastSegmentTs;
            if (tsDiff <= 0) {
                return false;
            }
            // try to use the compact notation with @r attribute on the last
            // to elements of the timeline if we find out they have the same
            // duration
            if (last.d === -1) {
                var prev = timeline[timelineLength - 2];
                if (prev && prev.d === tsDiff) {
                    prev.r++;
                    timeline.pop();
                }
                else {
                    last.d = tsDiff;
                }
            }
            index.timeline.push({
                d: -1,
                ts: newSegmentTs,
                r: 0,
            });
            return true;
        }
        else if (scaledNewSegment.time >= helpers_1.getTimelineRangeEnd(last)) {
            if (last.d === scaledNewSegment.duration) {
                last.r++;
            }
            else {
                index.timeline.push({
                    d: scaledNewSegment.duration,
                    ts: scaledNewSegment.time,
                    r: 0,
                });
            }
            return true;
        }
        return false;
    },
};
exports.default = SegmentTimelineHelpers;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */
function tryCatch(func, args) {
    try {
        return func(args);
    }
    catch (e) {
        return Observable_1.Observable.throw(e);
    }
}
exports.default = tryCatch;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var noop_1 = __webpack_require__(18);
var sessions_set_1 = __webpack_require__(281);
var emptyStorage = {
    load: function () { return []; },
    save: noop_1.default,
};
var $storedSessions = new sessions_set_1.PersistedSessionsSet(emptyStorage);
exports.$storedSessions = $storedSessions;
var $loadedSessions = new sessions_set_1.InMemorySessionsSet();
exports.$loadedSessions = $loadedSessions;
if (false) {
    // disable typescript warning TODO better way?
    window.$loadedSessions = $loadedSessions;
    window.$storedSessions = $storedSessions;
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function toWallClockTime(position, manifest) {
    return new Date((position + (manifest.availabilityStartTime || 0)) * 1000);
}
exports.toWallClockTime = toWallClockTime;
/**
 * TODO This function should have more of a seekTo kind of name
 * ``fromWallClockTime`` should probably just do:
 * ```js
 * (timeInSeconds, manifest) => {
 *   return timeInSeconds - manifest.availabilityStartTime;
 * };
 * ```
 * It should be the exact opposite of ``toWallClockTime``
 */
function fromWallClockTime(timeInMs, manifest) {
    return normalizeWallClockTime(timeInMs, manifest) / 1000
        - (manifest.availabilityStartTime || 0);
}
exports.fromWallClockTime = fromWallClockTime;
/**
 * TODO This function should have more of a seekTo kind of name
 */
function normalizeWallClockTime(_time, manifest) {
    if (!manifest.isLive) {
        return +_time;
    }
    var spd = manifest.suggestedPresentationDelay || 0;
    var plg = manifest.presentationLiveGap || 0;
    var tsbd = manifest.timeShiftBufferDepth || 0;
    var timeInMs = typeof _time === "number" ?
        _time : +_time;
    var now = Date.now();
    var max = now - (plg + spd) * 1000;
    var min = now - (tsbd) * 1000;
    return Math.max(Math.min(timeInMs, max), min);
}
function getMinimumBufferPosition(manifest) {
    // we have to know both the min and the max to be sure
    var min = getBufferLimits(manifest)[0];
    return min;
}
exports.getMinimumBufferPosition = getMinimumBufferPosition;
/**
 * Get maximum position to which we should be able to construct a buffer.
 * @param {Manifest} manifest
 * @returns {Number}
 */
function getMaximumBufferPosition(manifest) {
    if (!manifest.isLive) {
        return manifest.getDuration();
    }
    var ast = manifest.availabilityStartTime || 0;
    var plg = manifest.presentationLiveGap || 0;
    var now = Date.now() / 1000;
    return now - ast - plg;
}
exports.getMaximumBufferPosition = getMaximumBufferPosition;
function getBufferLimits(manifest) {
    // TODO use RTT for the manifest request + 3 or something
    var BUFFER_DEPTH_SECURITY = 5;
    if (!manifest.isLive) {
        return [0, manifest.getDuration()];
    }
    var ast = manifest.availabilityStartTime || 0;
    var plg = manifest.presentationLiveGap || 0;
    var tsbd = manifest.timeShiftBufferDepth || 0;
    var now = Date.now() / 1000;
    var max = now - ast - plg;
    return [
        Math.min(max, max - tsbd + BUFFER_DEPTH_SECURITY),
        max,
    ];
}
exports.getBufferLimits = getBufferLimits;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var castToObservable_1 = __webpack_require__(10);
var eventemitter_1 = __webpack_require__(32);
var rx_tryCatch_1 = __webpack_require__(53);
var time_ranges_1 = __webpack_require__(97);
/**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */
var AbstractSourceBuffer = /** @class */ (function (_super) {
    __extends(AbstractSourceBuffer, _super);
    function AbstractSourceBuffer(codec) {
        var _this = _super.call(this) || this;
        _this.codec = codec;
        _this.updating = false;
        _this.readyState = "opened";
        _this.buffered = new time_ranges_1.default();
        return _this;
    }
    /**
     * Mimic the SourceBuffer _appendBuffer_ method: Append segment.
     * @param {*} data
     */
    AbstractSourceBuffer.prototype.appendBuffer = function (data) {
        var _this = this;
        this._lock(function () { return _this._append(data); });
    };
    /**
     * Mimic the SourceBuffer _remove_ method: remove segment.
     * @param {Number} from
     * @param {Number} to
     */
    AbstractSourceBuffer.prototype.remove = function (from, to) {
        var _this = this;
        this._lock(function () { return _this._remove(from, to); });
    };
    /**
     * Mimic the SourceBuffer _abort_ method.
     */
    AbstractSourceBuffer.prototype.abort = function () {
        this.remove(0, Infinity);
        this.updating = false;
        this.readyState = "closed";
        this._abort();
    };
    /**
     * Active a lock, execute the given function, unlock when finished (on
     * nextTick).
     * Throws if multiple lock are active at the same time.
     * Also triggers the right events on start, error and end
     * @param {Function} func
     */
    AbstractSourceBuffer.prototype._lock = function (func) {
        var _this = this;
        assert_1.default(!this.updating, "updating");
        this.updating = true;
        this.trigger("updatestart");
        var result = rx_tryCatch_1.default(function () { return castToObservable_1.default(func()); });
        result.subscribe(function () { return setTimeout(function () { _this._unlock("update"); }, 0); }, function (e) { return setTimeout(function () { _this._unlock("error", e); }, 0); });
    };
    /**
     * Free the lock and trigger the right events.
     * @param {string} eventName
     * @param {*} value - value sent with the given event.
     */
    AbstractSourceBuffer.prototype._unlock = function (eventName, value) {
        this.updating = false;
        this.trigger(eventName, value);
        this.trigger("updateend");
    };
    return AbstractSourceBuffer;
}(eventemitter_1.default));
exports.AbstractSourceBuffer = AbstractSourceBuffer;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
    if (!(element.parentNode instanceof Element)) {
        return [];
    }
    function constructArray(_element) {
        var elements = [];
        if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
            elements.push(_element);
        }
        var parentNode = _element.parentNode;
        if (parentNode instanceof Element) {
            elements.push.apply(elements, constructArray(parentNode));
        }
        return elements;
    }
    return constructArray(element.parentNode);
}
exports.default = getParentElementsByTagName;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
var array_includes_1 = __webpack_require__(9);
var starts_with_1 = __webpack_require__(301);
/**
 * Retrieve the attributes given in arguments in the given elements and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given elements in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} elements
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
function getStylingAttributes(attributes, elements, styles, regions) {
    var currentStyle = {};
    var leftAttributes = attributes.slice();
    var _loop_1 = function (i) {
        var element = elements[i];
        if (element) {
            var styleID_1;
            var regionID_1;
            // 1. the style is directly set on a "tts:" attribute
            for (var j = 0; j <= element.attributes.length - 1; j++) {
                var attribute = element.attributes[j];
                var name_1 = attribute.name;
                if (name_1 === "style") {
                    styleID_1 = attribute.value;
                }
                else if (name_1 === "region") {
                    regionID_1 = attribute.value;
                }
                else {
                    var nameWithoutTTS = name_1.substr(4);
                    if (array_includes_1.default(leftAttributes, nameWithoutTTS)) {
                        currentStyle[nameWithoutTTS] = attribute.value;
                        leftAttributes.splice(j, 1);
                        if (!leftAttributes.length) {
                            return { value: currentStyle };
                        }
                    }
                }
            }
            // 2. the style is referenced on a "style" attribute
            if (styleID_1) {
                var style = arrayFind(styles, function (x) { return x.id === styleID_1; });
                if (style) {
                    for (var j = 0; j <= leftAttributes.length - 1; j++) {
                        var attribute = leftAttributes[j];
                        if (!currentStyle[attribute]) {
                            if (style.style[attribute]) {
                                currentStyle[attribute] = style.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (!leftAttributes.length) {
                                    return { value: currentStyle };
                                }
                                j--;
                            }
                        }
                    }
                }
            }
            // 3. the element reference a region (which can have a value for the
            //    corresponding style)
            if (regionID_1) {
                var region = arrayFind(regions, function (x) {
                    return x.id === regionID_1;
                });
                if (region) {
                    for (var j = 0; j <= leftAttributes.length - 1; j++) {
                        var attribute = leftAttributes[j];
                        if (!currentStyle[attribute]) {
                            if (region.style[attribute]) {
                                currentStyle[attribute] = region.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (!leftAttributes.length) {
                                    return { value: currentStyle };
                                }
                                j--;
                            }
                        }
                    }
                }
            }
        }
    };
    for (var i = 0; i <= elements.length - 1; i++) {
        var state_1 = _loop_1(i);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return currentStyle;
}
exports.getStylingAttributes = getStylingAttributes;
/**
 * Returns the styling directly linked to an element.
 * @param {Node} element
 * @returns {Object}
 */
function getStylingFromElement(element) {
    var currentStyle = {};
    for (var i = 0; i <= element.attributes.length - 1; i++) {
        var styleAttribute = element.attributes[i];
        if (starts_with_1.default(styleAttribute.name, "tts")) {
            var nameWithoutTTS = styleAttribute.name.substr(4);
            currentStyle[nameWithoutTTS] = styleAttribute.value;
        }
    }
    return currentStyle;
}
exports.getStylingFromElement = getStylingFromElement;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
exports.REGXP_TIME_COLON_FRAMES = REGXP_TIME_COLON_FRAMES;
/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;
exports.REGXP_TIME_COLON = REGXP_TIME_COLON;
/**
 * @type {RegExp}
 * @example 01:02:43.0345555 or 02:43.03
 */
var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;
exports.REGXP_TIME_COLON_MS = REGXP_TIME_COLON_MS;
/**
 * @type {RegExp}
 * @example 75f or 75.5f
 */
var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;
exports.REGXP_TIME_FRAMES = REGXP_TIME_FRAMES;
/**
 * @type {RegExp}
 * @example 50t or 50.5t
 */
var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;
exports.REGXP_TIME_TICK = REGXP_TIME_TICK;
/**
 * @type {RegExp}
 * @example 3.45h, 3m or 4.20s
 */
var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;
exports.REGXP_TIME_HMS = REGXP_TIME_HMS;
/**
 * @type {RegExp}
 * @example 50% 10%
 */
var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
exports.REGXP_PERCENT_VALUES = REGXP_PERCENT_VALUES;
var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
exports.REGXP_8_HEX_COLOR = REGXP_8_HEX_COLOR;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
exports.REGXP_4_HEX_COLOR = REGXP_4_HEX_COLOR;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromObservable_1 = __webpack_require__(118);
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(11);
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var Notification_1 = __webpack_require__(121);
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromPromise_1 = __webpack_require__(125);
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray_1 = __webpack_require__(24);
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(11);
var Action_1 = __webpack_require__(129);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(130);
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(72);
var merge_2 = __webpack_require__(72);
exports.mergeStatic = merge_2.mergeStatic;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return merge_1.merge.apply(void 0, observables)(this);
}
exports.merge = merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ArrayObservable_1 = __webpack_require__(20);
var mergeAll_1 = __webpack_require__(73);
var isScheduler_1 = __webpack_require__(19);
/* tslint:enable:max-line-length */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(mergeStatic.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));
}
exports.mergeStatic = mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(43);
var identity_1 = __webpack_require__(133);
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);
}
exports.mergeAll = mergeAll;
//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(20);
exports.of = ArrayObservable_1.ArrayObservable.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(19);
var of_1 = __webpack_require__(74);
var from_1 = __webpack_require__(64);
var concatAll_1 = __webpack_require__(77);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeAll_1 = __webpack_require__(73);
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(12);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=refCount.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var ObjectUnsubscribedError_1 = __webpack_require__(45);
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */
var CustomMediaKeySystemAccess = /** @class */ (function () {
    function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
        this._keyType = _keyType;
        this._mediaKeys = _mediaKeys;
        this._configuration = _configuration;
    }
    Object.defineProperty(CustomMediaKeySystemAccess.prototype, "keySystem", {
        get: function () {
            return this._keyType;
        },
        enumerable: true,
        configurable: true
    });
    CustomMediaKeySystemAccess.prototype.createMediaKeys = function () {
        var _this = this;
        return new Promise(function (res) { return res(_this._mediaKeys); });
    };
    CustomMediaKeySystemAccess.prototype.getConfiguration = function () {
        return this._configuration;
    };
    return CustomMediaKeySystemAccess;
}());
exports.default = CustomMediaKeySystemAccess;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var eventemitter_1 = __webpack_require__(32);
var bytes_1 = __webpack_require__(28);
var castToObservable_1 = __webpack_require__(10);
var constants_1 = __webpack_require__(48);
var events = __webpack_require__(16);
var keySystemAccess_1 = __webpack_require__(82);
var requestMediaKeySystemAccess;
exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;
// Wrap "MediaKeys.prototype.update" form an event based system to a
// Promise based function.
var wrapUpdate = function (memUpdate) {
    return function (license, sessionId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                memUpdate.call(_this, license, sessionId);
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    };
};
// ---------------------------------------------------------------
// End of the limitation
// XXX TODO Put that after the:
// ```js
// if (HTMLVideoElement.prototype.webkitGenerateKeyRequest) {
// ```
// line. This was put here because of:
// https://github.com/Microsoft/TypeScript/issues/20104
// ---------------------------------------------------------------
// TODO implement MediaKeySession completely
var MockMediaKeySession = /** @class */ (function (_super) {
    __extends(MockMediaKeySession, _super);
    function MockMediaKeySession(video, keySystem) {
        var _this = _super.call(this) || this;
        _this.sessionId = "";
        _this._vid = video;
        _this._key = keySystem;
        _this._con = Observable_1.Observable.merge(events.onKeyMessage$(video), events.onKeyAdded$(video), events.onKeyError$(video)).subscribe(function (evt) { return _this.trigger(evt.type, evt); });
        _this.update = wrapUpdate(function (license, sessionId) {
            if (_this._key.indexOf("clearkey") >= 0) {
                var json = JSON.parse(bytes_1.bytesToStr(license));
                var key = bytes_1.strToBytes(atob(json.keys[0].k));
                var kid = bytes_1.strToBytes(atob(json.keys[0].kid));
                _this._vid.webkitAddKey(_this._key, key, kid, sessionId);
            }
            else {
                _this._vid.webkitAddKey(_this._key, license, null, sessionId);
            }
            _this.sessionId = sessionId;
        });
        return _this;
    }
    MockMediaKeySession.prototype.generateRequest = function (_initDataType, initData) {
        var _this = this;
        return new Promise(function (resolve) {
            if (typeof _this._vid.webkitGenerateKeyRequest !== "function") {
                throw new Error("impossible to generate a key request");
            }
            _this._vid.webkitGenerateKeyRequest(_this._key, initData);
            resolve();
        });
    };
    MockMediaKeySession.prototype.close = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._con) {
                _this._con.unsubscribe();
            }
            resolve();
        });
    };
    return MockMediaKeySession;
}(eventemitter_1.default));
// TODO implement MediaKeySession completely
var SessionProxy = /** @class */ (function (_super) {
    __extends(SessionProxy, _super);
    function SessionProxy(mk) {
        var _this = _super.call(this) || this;
        _this.sessionId = "";
        _this._mk = mk;
        _this.update = wrapUpdate(function (license, sessionId) {
            if (!_this._ss) {
                throw new Error("MediaKeySession not set");
            }
            _this._ss.update(license, sessionId);
            _this.sessionId = sessionId;
        });
        return _this;
    }
    SessionProxy.prototype.generateRequest = function (_initDataType, initData) {
        var _this = this;
        return new Promise(function (resolve) {
            _this._ss = _this._mk.memCreateSession("video/mp4", initData);
            _this._con = Observable_1.Observable.merge(events.onKeyMessage$(_this._ss), events.onKeyAdded$(_this._ss), events.onKeyError$(_this._ss)).subscribe(function (evt) { return _this.trigger(evt.type, evt); });
            resolve();
        });
    };
    SessionProxy.prototype.close = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._ss) {
                /* tslint:disable no-floating-promises */
                _this._ss.close();
                /* tslint:enable no-floating-promises */
                _this._ss = undefined;
            }
            if (_this._con) {
                _this._con.unsubscribe();
                _this._con = undefined;
            }
            resolve();
        });
    };
    return SessionProxy;
}(eventemitter_1.default));
// ---------------------------------------------------------------
// End of the limitation
// Default MockMediaKeys implementation
var MockMediaKeys = /** @class */ (function () {
    function class_1() {
    }
    class_1.prototype._setVideo = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    class_1.prototype.createSession = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    class_1.prototype.setServerCertificate = function () {
        throw new Error("MediaKeys is not implemented in your browser");
    };
    return class_1;
}());
exports.MockMediaKeys = MockMediaKeys;
if (navigator.requestMediaKeySystemAccess) {
    exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (a, b) {
        return castToObservable_1.default(navigator.requestMediaKeySystemAccess(a, b));
    };
}
else {
    // XXX TODO Put wrapUpdate here
    // Browser without any MediaKeys object: A mock for MediaKey and
    // MediaKeySession are created, and the <video>.addKey api is used to
    // pass the license.
    //
    // This is for Chrome with unprefixed EME api
    if (HTMLVideoElement.prototype.webkitGenerateKeyRequest) {
        exports.MockMediaKeys = MockMediaKeys = /** @class */ (function () {
            function class_2(keySystem) {
                this.ks_ = keySystem;
            }
            class_2.prototype._setVideo = function (vid) {
                this._vid = vid;
            };
            class_2.prototype.createSession = function () {
                if (!this._vid) {
                    throw new Error("Video not attached to the MediaKeys");
                }
                return new MockMediaKeySession(this._vid, this.ks_);
            };
            class_2.prototype.setServerCertificate = function () {
                throw new Error("Server certificate is not implemented in your browser");
            };
            return class_2;
        }());
        var isTypeSupported_1 = function (keyType) {
            // get any <video> element from the DOM or create one
            // and try the `canPlayType` method
            var video = document.querySelector("video") ||
                document.createElement("video");
            if (video && video.canPlayType) {
                return !!video.canPlayType("video/mp4", keyType);
            }
            else {
                return false;
            }
        };
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {
            if (!isTypeSupported_1(keyType)) {
                return Observable_1.Observable.throw(undefined);
            }
            for (var i = 0; i < keySystemConfigurations.length; i++) {
                var keySystemConfiguration = keySystemConfigurations[i];
                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, sessionTypes = keySystemConfiguration.sessionTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier, persistentState = keySystemConfiguration.persistentState;
                var supported = true;
                supported = supported && (!initDataTypes ||
                    !!initDataTypes.filter(function (initDataType) { return initDataType === "cenc"; })[0]);
                supported = supported && (!sessionTypes ||
                    sessionTypes
                        .filter(function (sessionType) { return sessionType === "temporary"; }).length ===
                        sessionTypes.length);
                supported = supported && (distinctiveIdentifier !== "required");
                supported = supported && (persistentState !== "required");
                if (supported) {
                    var keySystemConfigurationResponse = {
                        videoCapabilities: videoCapabilities,
                        audioCapabilities: audioCapabilities,
                        initDataTypes: ["cenc"],
                        sessionTypes: ["temporary"],
                        // TODO TypesScript bug or what? Check and open an issue
                        distinctiveIdentifier: "not-allowed",
                        persistentState: "not-allowed",
                    };
                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));
                }
            }
            return Observable_1.Observable.throw(undefined);
        };
    }
    else if (constants_1.MediaKeys_) {
        // XXX TODO Put SessionProxy here
        // Add empty prototype for some IE targets which do not set one and just
        // throws in the following lines
        if (!constants_1.MediaKeys_.prototype) {
            constants_1.MediaKeys_.prototype = {};
        }
        // on IE11, each created session needs to be created on a new
        // MediaKeys object
        constants_1.MediaKeys_.prototype.alwaysRenew = true;
        constants_1.MediaKeys_.prototype.memCreateSession = constants_1.MediaKeys_.prototype.createSession;
        constants_1.MediaKeys_.prototype.createSession = function () {
            /* tslint:disable no-invalid-this */
            return new SessionProxy(this);
            /* tslint:enable no-invalid-this */
        };
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {
            // TODO Authorize isTypeSupported for IE?
            if (!constants_1.MediaKeys_.isTypeSupported(keyType)) {
                return Observable_1.Observable.throw(undefined);
            }
            for (var i = 0; i < keySystemConfigurations.length; i++) {
                var keySystemConfiguration = keySystemConfigurations[i];
                var videoCapabilities = keySystemConfiguration.videoCapabilities, audioCapabilities = keySystemConfiguration.audioCapabilities, initDataTypes = keySystemConfiguration.initDataTypes, distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
                var supported = true;
                supported = supported && (!initDataTypes ||
                    !!initDataTypes.filter(function (idt) { return idt === "cenc"; })[0]);
                supported = supported && (distinctiveIdentifier !== "required");
                if (supported) {
                    var keySystemConfigurationResponse = {
                        videoCapabilities: videoCapabilities,
                        audioCapabilities: audioCapabilities,
                        initDataTypes: ["cenc"],
                        distinctiveIdentifier: "not-allowed",
                        persistentState: "required",
                        sessionTypes: ["temporary", "persistent-license"],
                    };
                    return Observable_1.Observable.of(new keySystemAccess_1.default(keyType, 
                    // TODO Authorize 1 argument for IE?
                    new MediaKeys(keyType), keySystemConfigurationResponse));
                }
            }
            return Observable_1.Observable.throw(undefined);
        };
    }
    else {
        exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess = function () {
            throw new Error("requestMediaKeySystemAccess is not implemented in your browser.");
        };
    }
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(22);
var errorMessage_1 = __webpack_require__(27);
/**
 * @class EncryptedMediaError
 * @extends Error
 */
var EncryptedMediaError = /** @class */ (function (_super) {
    __extends(EncryptedMediaError, _super);
    function EncryptedMediaError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, EncryptedMediaError.prototype);
        _this.name = "EncryptedMediaError";
        _this.type = constants_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes[code];
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return EncryptedMediaError;
}(Error));
exports.default = EncryptedMediaError;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */
function stringFromCharCode(args) {
    var max = 16000;
    var ret = "";
    for (var i = 0; i < args.length; i += max) {
        var subArray = args.subarray(i, i + max);
        ret += String.fromCharCode.apply(null, subArray);
    }
    return ret;
}
exports.stringFromCharCode = stringFromCharCode;
/**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */
function stringFromUTF8(data) {
    if (!data) {
        return "";
    }
    var uint8 = new Uint8Array(data);
    // If present, strip off the UTF-8 BOM.
    if (uint8[0] === 0xef && uint8[1] === 0xbb && uint8[2] === 0xbf) {
        uint8 = uint8.subarray(3);
    }
    // http://stackoverflow.com/a/13691499
    var utf8 = stringFromCharCode(uint8);
    // This converts each character in the string to an escape sequence.  If the
    // character is in the ASCII range, it is not converted; otherwise it is
    // converted to a URI escape sequence.
    // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
    // TODO "escape" is deprecated, provide a ponyfill?
    var escaped = escape(utf8);
    // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
    // correct character.
    // Example: "g#%E3%82%AC" -> "g#"
    return decodeURIComponent(escaped);
}
exports.stringFromUTF8 = stringFromUTF8;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var bytes_1 = __webpack_require__(28);
/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */
function parseBif(buf) {
    var pos = 0;
    var length = buf.length;
    var fileFormat = bytes_1.bytesToStr(buf.subarray(pos, pos + 8));
    pos += 8;
    var minorVersion = buf[pos];
    pos += 1;
    var majorVersion = buf[pos];
    pos += 1;
    var patchVersion = buf[pos];
    pos += 1;
    var increVersion = buf[pos];
    pos += 1;
    var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");
    var imageCount = buf[pos] + bytes_1.le4toi(buf, pos + 1);
    pos += 4;
    var timescale = bytes_1.le4toi(buf, pos);
    pos += 4;
    var format = bytes_1.bytesToStr(buf.subarray(pos, pos + 4));
    pos += 4;
    var width = bytes_1.le2toi(buf, pos);
    pos += 2;
    var height = bytes_1.le2toi(buf, pos);
    pos += 2;
    var aspectRatio = [buf[pos], buf[pos + 1]].join(":");
    pos += 2;
    var isVod = buf[pos] === 1;
    pos += 1;
    // bytes 0x1F to 0x40 is unused data for now
    pos = 0x40;
    var thumbs = [];
    var currentImage;
    var currentTs = 0;
    if (!imageCount) {
        throw new Error("bif: no images to parse");
    }
    while (pos < length) {
        var currentImageIndex = bytes_1.le4toi(buf, pos);
        pos += 4;
        var currentImageOffset = bytes_1.le4toi(buf, pos);
        pos += 4;
        if (currentImage) {
            var index = currentImage.index;
            var duration = timescale;
            var ts = currentTs;
            var data = buf.subarray(currentImage.offset, currentImageOffset);
            thumbs.push({ index: index, duration: duration, ts: ts, data: data });
            currentTs += timescale;
        }
        if (currentImageIndex === 0xffffffff) {
            break;
        }
        currentImage = {
            index: currentImageIndex,
            offset: currentImageOffset,
        };
    }
    return {
        fileFormat: fileFormat,
        version: version,
        imageCount: imageCount,
        timescale: timescale,
        format: format,
        width: width,
        height: height,
        aspectRatio: aspectRatio,
        isVod: isVod,
        thumbs: thumbs,
    };
}
exports.default = parseBif;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ISM_REG = /\.(isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
function byteRange(_a) {
    var start = _a[0], end = _a[1];
    if (!end || end === Infinity) {
        return "bytes=" + (+start) + "-";
    }
    else {
        return "bytes=" + (+start) + "-" + (+end);
    }
}
exports.byteRange = byteRange;
/**
 * TODO Remove this logic completely from the player
 * @returns {string|null}
 */
function extractISML(doc) {
    return doc.getElementsByTagName("media")[0].getAttribute("src");
}
exports.extractISML = extractISML;
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */
function extractToken(url) {
    var tokenMatch = url.match(TOKEN_REG);
    return (tokenMatch && tokenMatch[1]) || "";
}
exports.extractToken = extractToken;
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */
function replaceToken(url, token) {
    if (token) {
        return url.replace(TOKEN_REG, "?token=" + token);
    }
    else {
        return url.replace(TOKEN_REG, "");
    }
}
exports.replaceToken = replaceToken;
/**
 * @param {string} url
 * @returns {string}
 */
function resolveManifest(url) {
    var ismMatch = url.match(ISM_REG);
    if (ismMatch) {
        return url.replace(ismMatch[1], ismMatch[1] + "/manifest");
    }
    else {
        return url;
    }
}
exports.resolveManifest = resolveManifest;
/**
 * @param {string} url
 * @param {Representation} representation
 * @param {Segment} segment
 * @returns {string}
 */
function buildSegmentURL(url, representation, segment) {
    return url
        .replace(/\{bitrate\}/g, String(representation.bitrate))
        .replace(/\{start time\}/g, String(segment.time));
}
exports.buildSegmentURL = buildSegmentURL;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var isobmff_1 = __webpack_require__(33);
/**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Segment} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>} [sidxSegments=[]] - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
    var _sidxSegments = sidxSegments || [];
    var startTime;
    var duration;
    var decodeTime = isobmff_1.parseTfdt(buffer);
    var trunDuration = isobmff_1.getDurationFromTrun(buffer);
    var timescale = initInfos && initInfos.timescale ?
        initInfos.timescale : segment.timescale;
    // we could always make a mistake when reading a container.
    // If the estimate is too far from what the segment seems to imply, take
    // the segment infos instead.
    var maxDecodeTimeDelta;
    // Scaled start time and duration as announced in the segment data
    var segmentDuration;
    var segmentStart;
    if (timescale === segment.timescale) {
        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);
        segmentStart = segment.time;
        segmentDuration = segment.duration;
    }
    else {
        maxDecodeTimeDelta = Math.min(timescale * 0.9, segment.duration != null ?
            ((segment.duration / segment.timescale) * timescale) / 4 : 0.25);
        segmentStart = ((segment.time || 0) / segment.timescale) * timescale;
        segmentDuration = segment.duration != null ?
            (segment.duration / segment.timescale) * timescale : undefined;
    }
    if (decodeTime >= 0 &&
        (segmentStart == null ||
            Math.abs(decodeTime - segmentStart) <= maxDecodeTimeDelta)) {
        startTime = decodeTime;
    }
    if (trunDuration >= 0 &&
        (segmentDuration == null ||
            Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
        duration = trunDuration;
    }
    if (startTime == null) {
        if (_sidxSegments.length === 1) {
            var sidxStart = _sidxSegments[0].time;
            if (sidxStart >= 0 &&
                (segmentStart == null ||
                    Math.abs(segmentStart - sidxStart) <= maxDecodeTimeDelta)) {
                var sidxTimescale = _sidxSegments[0].timescale;
                startTime = sidxTimescale != null && sidxTimescale !== timescale ?
                    (sidxStart / sidxTimescale) * timescale : sidxStart;
            }
            else {
                startTime = segmentStart;
            }
        }
        else {
            startTime = segmentStart;
        }
    }
    if (duration == null) {
        if (_sidxSegments.length === 1) {
            var sidxDuration = _sidxSegments[0].duration;
            if (sidxDuration >= 0 &&
                (segmentDuration == null ||
                    Math.abs(segmentDuration - sidxDuration) <= maxDecodeTimeDelta)) {
                var sidxTimescale = _sidxSegments[0].timescale;
                duration = sidxTimescale != null && sidxTimescale !== timescale ?
                    (sidxDuration / sidxTimescale) * timescale : sidxDuration;
            }
            else {
                duration = segmentDuration;
            }
        }
        else {
            duration = segmentDuration;
        }
    }
    if (false) {
        assert_1.default(startTime != null);
        assert_1.default(duration != null);
    }
    return {
        timescale: timescale,
        time: startTime || 0,
        duration: duration || 0,
    };
}
exports.default = getISOBMFFTimingInfos;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// XML-Schema
/* tslint:disable:max-line-length */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>
/* tslint:enable:max-line-length */
var array_includes_1 = __webpack_require__(9);
var assert_1 = __webpack_require__(2);
var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
var frameRateRe = /([0-9]+)(\/([0-9]+))?/;
var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
/**
 * @param {Object} index
 * @returns {Number|undefined}
 */
function calculateIndexLastLiveTimeReference(index) {
    if (index.indexType === "timeline") {
        var _a = index.timeline[index.timeline.length - 1], ts = _a.ts, r = _a.r, d = _a.d;
        // TODO FIXME does that make sense?
        var securityTime = Math.min(Math.max(d ? d : 0 / index.timescale, 5), 10);
        return ((ts + (r + 1) * (d ? d : 0)) / index.timescale) - securityTime;
    }
}
/**
 * Parse MPD string attributes.
 * @param {string} str
 * @returns {string} - the same string
 */
function parseString(str) {
    return str;
}
exports.parseString = parseString;
/**
 * Parse MPD boolean attributes.
 * @param {string}
 * @returns {Boolean}
 */
function parseBoolean(str) {
    return str === "true";
}
exports.parseBoolean = parseBoolean;
/**
 * Parse some MPD attributes.
 * @param {string}
 * @returns {Boolean|Number}
 */
function parseIntOrBoolean(str) {
    if (str === "true") {
        return true;
    }
    if (str === "false") {
        return false;
    }
    return parseInt(str, 10);
}
exports.parseIntOrBoolean = parseIntOrBoolean;
/**
 * Parse MPD date attributes.
 * @param {string}
 * @returns {Date}
 */
function parseDateTime(str) {
    return new Date(Date.parse(str));
}
exports.parseDateTime = parseDateTime;
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string}
 * @returns {Number}
 */
function parseDuration(date) {
    if (!date) {
        return 0;
    }
    var match = iso8601Duration.exec(date);
    assert_1.default(match, date + " is not a valid ISO8601 duration");
    return (parseFloat(match[2] || "0") * 365 * 24 * 60 * 60 +
        parseFloat(match[4] || "0") * 30 * 24 * 60 * 60 + // not precise +
        parseFloat(match[6] || "0") * 24 * 60 * 60 +
        parseFloat(match[8] || "0") * 60 * 60 +
        parseFloat(match[10] || "0") * 60 +
        parseFloat(match[12] || "0"));
}
exports.parseDuration = parseDuration;
/**
 * Parse MPD frame rate attributes.
 * -1 if the frameRate could not be parsed,
 * @param {string} str
 * @returns {Number}
 */
function parseFrameRate(str) {
    var match = frameRateRe.exec(str);
    if (!match) {
        return -1;
    }
    var nom = parseInt(match[1], 10) || 0;
    var den = parseInt(match[2], 10) || 0;
    return den > 0
        ? nom / den
        : nom;
}
exports.parseFrameRate = parseFrameRate;
/**
 * Parse MPD ratio attributes.
 * @param {string} str
 * @returns {string}
 */
function parseRatio(str) {
    return str;
}
exports.parseRatio = parseRatio;
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */
function parseByteRange(str) {
    var match = rangeRe.exec(str);
    if (!match) {
        return null;
    }
    else {
        return [+match[1], +match[2]];
    }
}
exports.parseByteRange = parseByteRange;
/**
 * Reduce on each immediate children from the Document object given.
 * @param {Document} root
 * @param {Function} fn - Will be called on each children with the following
 * arguments:
 *   1. the reducer's accumulator
 *   2. the current node's name
 *   3. the current node Document Object
 * @param {*} init - the initial value for the accumulator
 * @returns {*} - the accumulator
 */
function reduceChildren(root, fn, init) {
    var node = root.firstElementChild;
    var r = init;
    while (node) {
        r = fn(r, node.nodeName, node);
        node = node.nextElementSibling;
    }
    return r;
}
exports.reduceChildren = reduceChildren;
/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isVisuallyImpaired(accessibility) {
    if (!accessibility) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === 1);
}
exports.isVisuallyImpaired = isVisuallyImpaired;
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
function inferAdaptationType(adaptation) {
    var mimeType = adaptation.mimeType;
    var topLevel = mimeType ? mimeType.split("/")[0] : "";
    if (array_includes_1.default(KNOWN_ADAPTATION_TYPES, topLevel)) {
        return topLevel;
    }
    if (mimeType === "application/bif") {
        return "image";
    }
    if (mimeType === "application/ttml+xml") {
        return "text";
    }
    // manage DASH-IF mp4-embedded subtitles and metadata
    if (mimeType === "application/mp4") {
        var role = adaptation.role;
        if (role) {
            if (role.schemeIdUri === "urn:mpeg:dash:role:2011" &&
                role.value === "subtitle") {
                return "text";
            }
        }
        return "metadata";
    }
    // take 1st representation's mimetype as default
    var representations = adaptation.representations;
    if (representations.length) {
        var firstReprMimeType = representations[0].mimeType || "";
        var _topLevel = firstReprMimeType.split("/")[0];
        if (array_includes_1.default(KNOWN_ADAPTATION_TYPES, _topLevel)) {
            return _topLevel;
        }
    }
    // TODO infer from representations' codecs?
    return "unknown";
}
exports.inferAdaptationType = inferAdaptationType;
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isHardOfHearing(accessibility) {
    if (!accessibility) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === 2);
}
exports.isHardOfHearing = isHardOfHearing;
/**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 *
 * This is done to calculate a liveGap which is valid for the whole manifest,
 * even in weird ones.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
var getLastLiveTimeReference = function (adaptation) {
    // Here's how we do, for each possibility:
    //  1. only the adaptation has an index (no representation has):
    //    - returns the index last time reference
    //
    //  2. every representations have an index:
    //    - returns minimum for every representations
    //
    //  3. not all representations have an index but the adaptation has
    //    - returns minimum between all representations and the adaptation
    //
    //  4. no index for 1+ representation(s) and no adaptation index:
    //    - returns undefined
    //
    //  5. Invalid index found somewhere:
    //    - returns undefined
    if (!adaptation) {
        return undefined;
    }
    var representations = adaptation.representations || [];
    var representationsWithIndex = representations
        .filter(function (r) { return r && r.index; });
    if (!representations.length && adaptation.index) {
        return calculateIndexLastLiveTimeReference(adaptation.index);
    }
    var lastLiveTimeReferences = representationsWithIndex
        .map(function (representation) {
        return representation.index ?
            calculateIndexLastLiveTimeReference(representation.index) :
            undefined;
    });
    if (lastLiveTimeReferences.some(function (x) { return x == null; })) {
        return undefined;
    }
    var representationsMin = Math.min.apply(Math, lastLiveTimeReferences);
    // if the last live time reference could not be calculated, return undefined
    if (isNaN(representationsMin)) {
        return undefined;
    }
    if (representations.length === representationsWithIndex.length) {
        return representationsMin;
    }
    if (adaptation.index) {
        var adaptationRef = calculateIndexLastLiveTimeReference(adaptation.index);
        if (adaptationRef) {
            return Math.min(representationsMin, adaptationRef);
        }
    }
};
exports.getLastLiveTimeReference = getLastLiveTimeReference;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var backoff_1 = __webpack_require__(91);
/**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay - delay in ms
 * @returns {Function}
 */
function debounce(fn, delay) {
    var timer = 0;
    return function () {
        if (timer) {
            clearTimeout(timer);
        }
        timer = window.setTimeout(fn, delay);
    };
}
/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options
 * @param {Number} options.retryDelay - The initial delay, in ms.
 * This delay will be fuzzed to fall under the range +-30% each time a new retry
 * is done.
 * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry
 * we performed (beginning at 1 for the first retry).
 * @param {Number} options.totalRetry - The amount of time we should retry. 0
 * means no retry, 1 means a single retry, Infinity means infinite retry etc.
 * If the observable still fails after this number of retry, the error will
 * be throwed through this observable.
 * @param {Number} [options.resetDelay] - Delay in ms since a retry after which
 * the counter of retry will be reset if the observable wasn't retried a new
 * time. 0 / undefined means no delay will be applied.
 * @param {Function} [options.shouldRetry] - Function which will receive the
 * observable error each time it fails, and should return a boolean. If this
 * boolean is false, the error will be directly thrown (without anymore retry).
 * @param {Function} [options.onRetry] - Function which will be triggered at
 * each retry. Will receive two arguments:
 *   1. The observable error
 *   2. The current retry count, beginning at 1 for the first retry
 * @param {Function} [options.errorSelector]
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryWithBackoff(obs$, options) {
    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;
    var retryCount = 0;
    var debounceRetryCount;
    if (resetDelay != null && resetDelay > 0) {
        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);
    }
    return obs$.catch(function (error, source) {
        var wantRetry = !shouldRetry || shouldRetry(error);
        if (!wantRetry || retryCount++ >= totalRetry) {
            if (errorSelector) {
                throw errorSelector(error, retryCount);
            }
            else {
                throw error;
            }
        }
        if (onRetry) {
            onRetry(error, retryCount);
        }
        var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);
        return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {
            if (debounceRetryCount) {
                debounceRetryCount();
            }
            return source;
        });
    });
}
exports.retryWithBackoff = retryWithBackoff;
/**
 * Same than retryWithBackoff, only with a function returning an observable
 * instead of an observable.
 * @param {Function} fn - Function returning an Observable which
 * will (well, might) be retried.
 * @param {Object} options
 * @param {Number} options.retryDelay
 * @param {Number} options.totalRetry
 * @param {Number} [options.resetDelay]
 * @param {Function} [options.shouldRetry]
 * @param {Function} [options.errorSelector]
 * @param {Function} [options.onRetry]
 * @returns {Function} - take in argument fn's arguments, returns
 * an Observable.
 */
function retryableFuncWithBackoff(fn, options) {
    var retryDelay = options.retryDelay, totalRetry = options.totalRetry, shouldRetry = options.shouldRetry, resetDelay = options.resetDelay, errorSelector = options.errorSelector, onRetry = options.onRetry;
    var retryCount = 0;
    var debounceRetryCount;
    if (resetDelay != null && resetDelay > 0) {
        debounceRetryCount = debounce(function () { retryCount = 0; }, resetDelay);
    }
    return function doRetry() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn.apply(void 0, args).catch(function (error) {
            var wantRetry = !shouldRetry || shouldRetry(error);
            if (!wantRetry || retryCount++ >= totalRetry) {
                if (errorSelector) {
                    throw errorSelector(error, retryCount);
                }
                else {
                    throw error;
                }
            }
            if (onRetry) {
                onRetry(error, retryCount);
            }
            var fuzzedDelay = backoff_1.getBackedoffDelay(retryDelay, retryCount);
            return Observable_1.Observable.timer(fuzzedDelay).mergeMap(function () {
                if (debounceRetryCount) {
                    debounceRetryCount();
                }
                return doRetry.apply(void 0, args);
            });
        });
    };
}
exports.retryableFuncWithBackoff = retryableFuncWithBackoff;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */
function getFuzzedDelay(retryDelay) {
    var fuzzingFactor = ((Math.random() * 2) - 1) * FUZZ_FACTOR;
    return retryDelay * (fuzzingFactor + 1.0); // Max 1.3 Min 0.7
}
exports.getFuzzedDelay = getFuzzedDelay;
/**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number} [retryCount=1]
 * @returns {Number}
 */
function getBackedoffDelay(retryDelay, retryCount) {
    if (retryCount === void 0) { retryCount = 1; }
    return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
}
exports.getBackedoffDelay = getBackedoffDelay;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
var EWMA = /** @class */ (function () {
    function EWMA(halfLife) {
        // (half-life = log(1/2) / log(Decay Factor)
        this._alpha = Math.exp(Math.log(0.5) / halfLife);
        this._lastEstimate = 0;
        this._totalWeight = 0;
    }
    EWMA.prototype.addSample = function (weight, value) {
        var adjAlpha = Math.pow(this._alpha, weight);
        var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
        if (!isNaN(newEstimate)) {
            this._lastEstimate = newEstimate;
            this._totalWeight += weight;
        }
    };
    EWMA.prototype.getEstimate = function () {
        var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
        return this._lastEstimate / zeroFactor;
    };
    return EWMA;
}());
exports.default = EWMA;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (arr, predicate, ctx) {
	if (typeof Array.prototype.findIndex === 'function') {
		return arr.findIndex(predicate, ctx);
	}

	if (typeof predicate !== 'function') {
		throw new TypeError('predicate must be a function');
	}

	var list = Object(arr);
	var len = list.length;

	if (len === 0) {
		return -1;
	}

	for (var i = 0; i < len; i++) {
		if (predicate.call(ctx, list[i], i, list)) {
			return i;
		}
	}

	return -1;
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(2);
var castToObservable_1 = __webpack_require__(10);
var log_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(18);
var _1 = __webpack_require__(5);
var events_1 = __webpack_require__(16);
var globals_1 = __webpack_require__(54);
var key_system_1 = __webpack_require__(284);
var server_certificate_1 = __webpack_require__(285);
var session_1 = __webpack_require__(286);
var set_media_keys_1 = __webpack_require__(288);
var errors_1 = __webpack_require__(8);
// Persisted singleton instance of MediaKeys. We do not allow multiple
// CDM instances.
var instanceInfos = {
    $mediaKeys: null,
    $mediaKeySystemConfiguration: null,
    $keySystem: null,
    $videoElement: null,
};
/**
 * Call the createMediaKeys API and cast it to an observable.
 * @param {MediaKeySystemAccess} keySystemAccess
 * @returns {Observable}
 */
function createMediaKeysObs(keySystemAccess) {
    // MediaKeySystemAccess.prototype.createMediaKeys returns a promise
    return castToObservable_1.default(keySystemAccess.createMediaKeys());
}
/**
 * Function triggered when both:
 *   - the ``encrypted`` event has been received.
 *   - a compatible key system configuration has been found.
 *
 * Calls all subsequent EME APIs.
 * @param {MediaEncryptedEvent} encryptedEvent
 * @param {Object} compatibleKeySystem
 * @param {MediaKeySystemAccess} compatibleKeySystem.keySystemAccess
 * @param {Object} compatibleKeySystem.keySystem - config given by the user
 * @returns {Observable}
 */
function handleEncryptedEvents(encryptedEvent, keySystemInfo, video, errorStream) {
    var keySystem = keySystemInfo.keySystem, keySystemAccess = keySystemInfo.keySystemAccess;
    if (keySystem.persistentLicense) {
        if (keySystem.licenseStorage) {
            globals_1.$storedSessions.setStorage(keySystem.licenseStorage);
        }
        else {
            var error = new Error("no license storage found for persistent license.");
            throw new errors_1.EncryptedMediaError("INVALID_KEY_SYSTEM", error, true);
        }
    }
    log_1.default.info("eme: encrypted event", encryptedEvent);
    return createMediaKeysObs(keySystemAccess).mergeMap(function (mediaKeys) {
        // set server certificate if set in API
        var serverCertificate = keySystem.serverCertificate;
        var setCertificate$ = (serverCertificate &&
            typeof mediaKeys.setServerCertificate === "function" ?
            server_certificate_1.trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) :
            Observable_1.Observable.empty()); // Typescript hack
        var mksConfig = keySystemAccess.getConfiguration();
        var setMediaKeys$ = set_media_keys_1.default(mediaKeys, mksConfig, video, keySystem, instanceInfos);
        if (encryptedEvent.initData) {
            var initData = new Uint8Array(encryptedEvent.initData);
            var manageSessionCreation$ = session_1.default(mediaKeys, mksConfig, keySystem, encryptedEvent.initDataType, initData, errorStream);
            return setCertificate$
                .concat(Observable_1.Observable.merge(setMediaKeys$, manageSessionCreation$));
        }
        else {
            var error = new Error("no init data found on media encrypted event.");
            throw new errors_1.EncryptedMediaError("INVALID_ENCRYPTED_EVENT", error, true);
        }
    });
}
/**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} video
 * @param {Object} keySystems
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createEME(video, keySystems, errorStream) {
    if (false) {
        keySystems.forEach(function (ks) { return assert_1.default.iface(ks, "keySystem", {
            getLicense: "function",
            type: "string",
        }); });
    }
    return Observable_1.Observable.combineLatest(events_1.onEncrypted$(video), // wait for "encrypted" event
    key_system_1.default(keySystems, instanceInfos))
        .take(1)
        .mergeMap(function (_a) {
        var evt = _a[0], ks = _a[1];
        return handleEncryptedEvents(evt, ks, video, errorStream);
    });
}
exports.createEME = createEME;
/**
 * Free up all ressources taken by the EME management.
 */
function dispose() {
    // Remove MediaKey before to prevent MediaKey error
    // if other instance is creating after dispose
    set_media_keys_1.disposeMediaKeys(instanceInfos.$videoElement).subscribe(noop_1.default);
    instanceInfos.$mediaKeys = null;
    instanceInfos.$keySystem = null;
    instanceInfos.$videoElement = null;
    instanceInfos.$mediaKeySystemConfiguration = null;
    globals_1.$loadedSessions.dispose();
}
exports.dispose = dispose;
/**
 * Clear EME ressources as the current content stops its playback.
 */
function clearEME() {
    return Observable_1.Observable.defer(function () {
        if (instanceInfos.$videoElement && _1.shouldUnsetMediaKeys()) {
            return set_media_keys_1.disposeMediaKeys(instanceInfos.$videoElement)
                .finally(function () {
                instanceInfos.$videoElement = null;
            });
        }
        return Observable_1.Observable.empty();
    });
}
exports.clearEME = clearEME;
/**
 * Returns the name of the current key system used.
 * @returns {string}
 */
function getCurrentKeySystem() {
    return key_system_1.getKeySystem(instanceInfos);
}
exports.getCurrentKeySystem = getCurrentKeySystem;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var SessionSet = /** @class */ (function () {
    function SessionSet() {
        this._entries = [];
    }
    SessionSet.prototype.find = function (func) {
        for (var i = 0; i < this._entries.length; i++) {
            if (func(this._entries[i])) {
                return this._entries[i];
            }
        }
        return null;
    };
    return SessionSet;
}());
exports.default = SessionSet;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Convert given buffer to a 32bit integer hash
 * @param {Array|TypedArray} buffer
 * @returns {Number}
 */
function hashBuffer(buffer) {
    var hash = 0;
    var char;
    for (var i = 0; i < buffer.length; i++) {
        char = buffer[i];
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}
/**
 * Convert given init data to a 32bit integer hash
 * @param {Array|TypedArray|number} buffer
 * @returns {Number}
 */
function hashInitData(initData) {
    if (typeof initData === "number") {
        return initData;
    }
    else {
        return hashBuffer(initData);
    }
}
exports.default = hashInitData;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var ranges_1 = __webpack_require__(15);
/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */
var ManualTimeRanges = /** @class */ (function () {
    function ManualTimeRanges() {
        this._ranges = [];
        this.length = 0;
    }
    ManualTimeRanges.prototype.insert = function (start, end) {
        if (false) {
            assert_1.default(start >= 0, "invalid start time");
            assert_1.default(end - start > 0, "invalid end time");
        }
        ranges_1.insertInto(this._ranges, { start: start, end: end });
        this.length = this._ranges.length;
    };
    ManualTimeRanges.prototype.remove = function (start, end) {
        if (false) {
            assert_1.default(start >= 0, "invalid start time");
            assert_1.default(end - start > 0, "invalid end time");
        }
        var rangesToIntersect = [];
        if (start > 0) {
            rangesToIntersect.push({ start: 0, end: start });
        }
        if (end < Infinity) {
            rangesToIntersect.push({ start: end, end: Infinity });
        }
        ranges_1.keepRangeIntersection(this._ranges, rangesToIntersect);
        this.length = this._ranges.length;
    };
    ManualTimeRanges.prototype.start = function (index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].start;
    };
    ManualTimeRanges.prototype.end = function (index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].end;
    };
    return ManualTimeRanges;
}());
exports.default = ManualTimeRanges;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns global parameters from a TTML Document
 * TODO Missing parameters.
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object} params
 * @returns {Number} params.frameRate
 * @returns {Number} params.subFrameRate
 * @returns {Number} params.tickRate
 * @returns {string} params.spaceStyle
 */
function getParameters(tt) {
    var parsedFrameRate = tt.getAttribute("ttp:frameRate");
    var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
    var parsedTickRate = tt.getAttribute("ttp:tickRate");
    var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
    var parsedSpaceStyle = tt.getAttribute("xml:space");
    if (parsedSpaceStyle && parsedSpaceStyle !== "default" &&
        parsedSpaceStyle !== "preserve") {
        throw new Error("Invalid spacing style");
    }
    var nbFrameRate = Number(parsedFrameRate) || 30;
    var nbSubFrameRate = Number(parsedSubFrameRate) || 1;
    var nbTickRate = Number(parsedTickRate) || 0;
    var tickRate = nbTickRate;
    var frameRate = nbFrameRate;
    var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
    // TypeScript too dumdum here :/
    var spaceStyle = (parsedSpaceStyle || "default");
    if (nbTickRate === 0) {
        tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1;
    }
    if (parsedFrameRateMultiplier) {
        var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
        if (multiplierResults) {
            var numerator = Number(multiplierResults[1]);
            var denominator = Number(multiplierResults[2]);
            var multiplierNum = numerator / denominator;
            frameRate = nbFrameRate * multiplierNum;
        }
    }
    return {
        tickRate: tickRate,
        frameRate: frameRate,
        subFrameRate: subFrameRate,
        spaceStyle: spaceStyle,
    };
}
exports.default = getParameters;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
    return tt.getElementsByTagName("body")[0];
}
exports.getBodyNode = getBodyNode;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getStyleNodes(tt) {
    return tt.getElementsByTagName("style");
}
exports.getStyleNodes = getStyleNodes;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getRegionNodes(tt) {
    return tt.getElementsByTagName("region");
}
exports.getRegionNodes = getRegionNodes;
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getTextNodes(tt) {
    return tt.getElementsByTagName("p");
}
exports.getTextNodes = getTextNodes;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var time_parsing_1 = __webpack_require__(304);
/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
function getTimeDelimiters(element, ttParams) {
    var beginAttr = element.getAttribute("begin");
    var durationAttr = element.getAttribute("dur");
    var endAttr = element.getAttribute("end");
    var start = beginAttr ? time_parsing_1.default(beginAttr, ttParams) : null;
    var duration = durationAttr ? time_parsing_1.default(durationAttr, ttParams) : null;
    var parsedEnd = endAttr ? time_parsing_1.default(endAttr, ttParams) : null;
    if (start == null || (parsedEnd == null && duration == null)) {
        throw new Error("Invalid text cue");
    }
    // TODO Huh? Is TypeScript that dumb here?
    var end = parsedEnd == null ?
        start + duration : parsedEnd;
    return { start: start, end: end };
}
exports.default = getTimeDelimiters;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":");
    if (splittedTS[2]) {
        var hours = parseInt(splittedTS[0], 10);
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[2].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}
exports.default = parseTimestamp;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ugly webpack workaround to export require-style
/* tslint:disable no-var-requires */
module.exports = __webpack_require__(103).default;
/* tslint:enable no-var-requires */


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(104);
__webpack_require__(112);
__webpack_require__(115);
__webpack_require__(117);
__webpack_require__(122);
__webpack_require__(67);
__webpack_require__(126);
__webpack_require__(131);
__webpack_require__(134);
__webpack_require__(137);
__webpack_require__(138);
__webpack_require__(141);
__webpack_require__(144);
__webpack_require__(147);
__webpack_require__(150);
__webpack_require__(152);
__webpack_require__(155);
__webpack_require__(158);
__webpack_require__(161);
__webpack_require__(164);
__webpack_require__(167);
__webpack_require__(170);
__webpack_require__(173);
__webpack_require__(176);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(182);
__webpack_require__(185);
__webpack_require__(188);
__webpack_require__(191);
__webpack_require__(194);
__webpack_require__(197);
__webpack_require__(200);
__webpack_require__(203);
__webpack_require__(206);
__webpack_require__(209);
__webpack_require__(212);
__webpack_require__(216);
__webpack_require__(219);
var log_1 = __webpack_require__(1);
var api_1 = __webpack_require__(222);
if (false) {
    log_1.default.setLevel(__LOGGER_LEVEL__);
}
exports.default = api_1.default;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var combineLatest_1 = __webpack_require__(109);
Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subscriber_1 = __webpack_require__(3);
var rxSubscriber_1 = __webpack_require__(38);
var Observer_1 = __webpack_require__(61);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var noop_1 = __webpack_require__(40);
/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;
//# sourceMappingURL=pipe.js.map

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isScheduler_1 = __webpack_require__(19);
var isArray_1 = __webpack_require__(24);
var ArrayObservable_1 = __webpack_require__(20);
var combineLatest_1 = __webpack_require__(110);
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(20);
var isArray_1 = __webpack_require__(24);
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var defer_1 = __webpack_require__(113);
Observable_1.Observable.defer = defer_1.defer;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DeferObservable_1 = __webpack_require__(114);
exports.defer = DeferObservable_1.DeferObservable.create;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var subscribeToResult_1 = __webpack_require__(14);
var OuterSubscriber_1 = __webpack_require__(13);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = (function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable));
exports.DeferObservable = DeferObservable;
var DeferSubscriber = (function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        }
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var empty_1 = __webpack_require__(116);
Observable_1.Observable.empty = empty_1.empty;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EmptyObservable_1 = __webpack_require__(25);
exports.empty = EmptyObservable_1.EmptyObservable.create;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var from_1 = __webpack_require__(64);
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(24);
var isArrayLike_1 = __webpack_require__(62);
var isPromise_1 = __webpack_require__(63);
var PromiseObservable_1 = __webpack_require__(65);
var IteratorObservable_1 = __webpack_require__(119);
var ArrayObservable_1 = __webpack_require__(20);
var ArrayLikeObservable_1 = __webpack_require__(120);
var iterator_1 = __webpack_require__(42);
var Observable_1 = __webpack_require__(0);
var observeOn_1 = __webpack_require__(66);
var observable_1 = __webpack_require__(39);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = (function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            }
            else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            }
            else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            }
            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            }
            else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        }
        else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable));
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(11);
var Observable_1 = __webpack_require__(0);
var iterator_1 = __webpack_require__(42);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = (function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        }
        else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                }
                else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable));
exports.IteratorObservable = IteratorObservable;
var StringIterator = (function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = str.length; }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}());
var ArrayIterator = (function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) { idx = 0; }
        if (len === void 0) { len = toLength(arr); }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}());
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var ScalarObservable_1 = __webpack_require__(41);
var EmptyObservable_1 = __webpack_require__(25);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = (function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        }
        else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        }
        else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable));
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var fromEvent_1 = __webpack_require__(123);
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FromEventObservable_1 = __webpack_require__(124);
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var tryCatch_1 = __webpack_require__(37);
var isFunction_1 = __webpack_require__(36);
var errorObject_1 = __webpack_require__(31);
var Subscription_1 = __webpack_require__(12);
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = (function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node.js
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * `fromEvent` accepts as a first argument event target, which is an object with methods
     * for registering event handler functions. As a second argument it takes string that indicates
     * type of event we want to listen for. `fromEvent` supports selected types of event targets,
     * which are described in detail below. If your event target does not match any of the ones listed,
     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
     * handler functions have different names, but they all accept a string describing event type
     * and function itself, which will be called whenever said event happens.
     *
     * Every time resulting Observable is subscribed, event handler function will be registered
     * to event target on given event type. When that event fires, value
     * passed as a first argument to registered function will be emitted by output Observable.
     * When Observable is unsubscribed, function will be unregistered from event target.
     *
     * Note that if event target calls registered function with more than one argument, second
     * and following arguments will not appear in resulting stream. In order to get access to them,
     * you can pass to `fromEvent` optional project function, which will be called with all arguments
     * passed to event handler. Output Observable will then emit value returned by project function,
     * instead of the usual value.
     *
     * Remember that event targets listed below are checked via duck typing. It means that
     * no matter what kind of object you have and no matter what environment you work in,
     * you can safely use `fromEvent` on that object if it exposes described methods (provided
     * of course they behave as was described above). So for example if Node.js library exposes
     * event target which has the same method names as DOM EventTarget, `fromEvent` is still
     * a good choice.
     *
     * If the API you use is more callback then event handler oriented (subscribed
     * callback function fires only once and thus there is no need to manually
     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
     * instead.
     *
     * `fromEvent` supports following types of event targets:
     *
     * **DOM EventTarget**
     *
     * This is an object with `addEventListener` and `removeEventListener` methods.
     *
     * In the browser, `addEventListener` accepts - apart from event type string and event
     * handler function arguments - optional third parameter, which is either an object or boolean,
     * both used for additional configuration how and when passed function will be called. When
     * `fromEvent` is used with event target of that type, you can provide this values
     * as third parameter as well.
     *
     * **Node.js EventEmitter**
     *
     * An object with `addListener` and `removeListener` methods.
     *
     * **JQuery-style event target**
     *
     * An object with `on` and `off` methods
     *
     * **DOM NodeList**
     *
     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
     *
     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
     * it contains and install event handler function in every of them. When returned Observable
     * is unsubscribed, function will be removed from all Nodes.
     *
     * **DOM HtmlCollection**
     *
     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
     * installed and removed in each of elements.
     *
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console every time a click
     * // occurs on the document.
     *
     *
     * @example <caption>Use addEventListener with capture option</caption>
     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter
     *                                                                          // which will be passed to addEventListener
     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');
     *
     * clicksInDocument.subscribe(() => console.log('document'));
     * clicksInDiv.subscribe(() => console.log('div'));
     *
     * // By default events bubble UP in DOM tree, so normally
     * // when we would click on div in document
     * // "div" would be logged first and then "document".
     * // Since we specified optional `capture` option, document
     * // will catch event when it goes DOWN DOM tree, so console
     * // will log "document" and then "div".
     *
     * @see {@link bindCallback}
     * @see {@link bindNodeCallback}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOM EventTarget, Node.js
     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            }
            else {
                subscriber.next(result);
            }
        } : function (e) { return subscriber.next(e); };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable));
exports.FromEventObservable = FromEventObservable;
//# sourceMappingURL=FromEventObservable.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PromiseObservable_1 = __webpack_require__(65);
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var interval_1 = __webpack_require__(127);
Observable_1.Observable.interval = interval_1.interval;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IntervalObservable_1 = __webpack_require__(128);
exports.interval = IntervalObservable_1.IntervalObservable.create;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(68);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(21);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IntervalObservable = (function (_super) {
    __extends(IntervalObservable, _super);
    function IntervalObservable(period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = async_1.async;
        }
    }
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified IScheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` IScheduler to provide a notion of time, but you may pass any
     * IScheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    IntervalObservable.create = function (period, scheduler) {
        if (period === void 0) { period = 0; }
        if (scheduler === void 0) { scheduler = async_1.async; }
        return new IntervalObservable(period, scheduler);
    };
    IntervalObservable.dispatch = function (state) {
        var index = state.index, subscriber = state.subscriber, period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };
    IntervalObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };
    return IntervalObservable;
}(Observable_1.Observable));
exports.IntervalObservable = IntervalObservable;
//# sourceMappingURL=IntervalObservable.js.map

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(12);
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(132);
Observable_1.Observable.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var merge_1 = __webpack_require__(71);
exports.merge = merge_1.mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function identity(x) {
    return x;
}
exports.identity = identity;
//# sourceMappingURL=identity.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var never_1 = __webpack_require__(135);
Observable_1.Observable.never = never_1.never;
//# sourceMappingURL=never.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NeverObservable_1 = __webpack_require__(136);
exports.never = NeverObservable_1.NeverObservable.create;
//# sourceMappingURL=never.js.map

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
var noop_1 = __webpack_require__(40);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var NeverObservable = (function (_super) {
    __extends(NeverObservable, _super);
    function NeverObservable() {
        _super.call(this);
    }
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please note
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.noop();
    };
    return NeverObservable;
}(Observable_1.Observable));
exports.NeverObservable = NeverObservable;
//# sourceMappingURL=NeverObservable.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var of_1 = __webpack_require__(74);
Observable_1.Observable.of = of_1.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var throw_1 = __webpack_require__(139);
Observable_1.Observable.throw = throw_1._throw;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ErrorObservable_1 = __webpack_require__(140);
exports._throw = ErrorObservable_1.ErrorObservable.create;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(0);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = (function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        }
        else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable));
exports.ErrorObservable = ErrorObservable;
//# sourceMappingURL=ErrorObservable.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timer_1 = __webpack_require__(142);
Observable_1.Observable.timer = timer_1.timer;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TimerObservable_1 = __webpack_require__(143);
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(68);
var Observable_1 = __webpack_require__(0);
var async_1 = __webpack_require__(21);
var isScheduler_1 = __webpack_require__(19);
var isDate_1 = __webpack_require__(75);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = (function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        }
        else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ?
            (+dueTime - this.scheduler.now()) :
            dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) { initialDelay = 0; }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index, period = state.period, subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable));
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var catch_1 = __webpack_require__(145);
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var catchError_1 = __webpack_require__(146);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    return catchError_1.catchError(selector)(this);
}
exports._catch = _catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @name catchError
 */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catchError.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concat_1 = __webpack_require__(148);
Observable_1.Observable.prototype.concat = concat_1.concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(149);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return concat_1.concat.apply(void 0, observables)(this);
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concat_1 = __webpack_require__(76);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatAll_1 = __webpack_require__(151);
Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatAll_1 = __webpack_require__(77);
/* tslint:enable:max-line-length */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return concatAll_1.concatAll()(this);
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var concatMap_1 = __webpack_require__(153);
Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var concatMap_1 = __webpack_require__(154);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return concatMap_1.concatMap(project, resultSelector)(this);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(43);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var debounceTime_1 = __webpack_require__(156);
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(21);
var debounceTime_1 = __webpack_require__(157);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return debounceTime_1.debounceTime(dueTime, scheduler)(this);
}
exports.debounceTime = debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var async_1 = __webpack_require__(21);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var distinctUntilChanged_1 = __webpack_require__(159);
Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var distinctUntilChanged_1 = __webpack_require__(160);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);
}
exports.distinctUntilChanged = distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var tryCatch_1 = __webpack_require__(37);
var errorObject_1 = __webpack_require__(31);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var do_1 = __webpack_require__(162);
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var tap_1 = __webpack_require__(163);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return tap_1.tap(nextOrObserver, error, complete)(this);
}
exports._do = _do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        }
        else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=tap.js.map

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var filter_1 = __webpack_require__(165);
Observable_1.Observable.prototype.filter = filter_1.filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var filter_1 = __webpack_require__(166);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return filter_1.filter(predicate, thisArg)(this);
}
exports.filter = filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=filter.js.map

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var finally_1 = __webpack_require__(168);
Observable_1.Observable.prototype.finally = finally_1._finally;
Observable_1.Observable.prototype._finally = finally_1._finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var finalize_1 = __webpack_require__(169);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return finalize_1.finalize(callback)(this);
}
exports._finally = _finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(12);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=finalize.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var ignoreElements_1 = __webpack_require__(171);
Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ignoreElements_1 = __webpack_require__(172);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return ignoreElements_1.ignoreElements()(this);
}
exports.ignoreElements = ignoreElements;
;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var noop_1 = __webpack_require__(40);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var map_1 = __webpack_require__(174);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var map_1 = __webpack_require__(175);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return map_1.map(project, thisArg)(this);
}
exports.map = map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=map.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mapTo_1 = __webpack_require__(177);
Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mapTo_1 = __webpack_require__(178);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return mapTo_1.mapTo(value)(this);
}
exports.mapTo = mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var merge_1 = __webpack_require__(71);
Observable_1.Observable.prototype.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var mergeMap_1 = __webpack_require__(181);
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var mergeMap_1 = __webpack_require__(43);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
}
exports.mergeMap = mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var multicast_1 = __webpack_require__(183);
Observable_1.Observable.prototype.multicast = multicast_1.multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(44);
/* tslint:enable:max-line-length */
/**
 * Allows source Observable to be subscribed only once with a Subject of choice,
 * while still sharing its values between multiple subscribers.
 *
 * <span class="informal">Subscribe to Observable once, but send its values to multiple subscribers.</span>
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * `multicast` is an operator that works in two modes.
 *
 * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject
 * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be
 * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that
 * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when
 * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription
 * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,
 * even though usually it would send a request per every subscriber. Since it sends a request at the moment of
 * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.
 *
 * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,
 * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source
 * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,
 * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count
 * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least
 * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a
 * ConnectableObservable, use `refCount`.
 *
 * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.
 * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable
 * as well, which should be the input stream modified by any operators you want. Note that in this
 * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If
 * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.
 * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,
 * if inside the selector function you subscribe to the input Observable multiple times, actual source stream
 * will be subscribed only once. So if you have a chain of operators that use some Observable many times,
 * but you want to subscribe to that Observable only once, this is the mode you would use.
 *
 * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the
 * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject
 * has some special properties, Observable returned by `multicast` will have them as well. If you want to use
 * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},
 * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},
 * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually
 * just wrappers around `multicast`, with a specific Subject hardcoded inside.
 *
 * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,
 * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.
 *
 * @example <caption>Use ConnectableObservable</caption>
 * const seconds = Rx.Observable.interval(1000);
 * const connectableSeconds = seconds.multicast(new Subject());
 *
 * connectableSeconds.subscribe(value => console.log('first: ' + value));
 * connectableSeconds.subscribe(value => console.log('second: ' + value));
 *
 * // At this point still nothing happens, even though we subscribed twice.
 *
 * connectableSeconds.connect();
 *
 * // From now on `seconds` are being logged to the console,
 * // twice per every second. `seconds` Observable was however only subscribed once,
 * // so under the hood Observable.interval had only one clock started.
 *
 * @example <caption>Use selector</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds
 *     .multicast(
 *         () => new Subject(),
 *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.
 *                                         // Because we are inside selector, `seconds` is subscribed once,
 *     )                                   // thus starting only one clock used internally by Observable.interval.
 *     .subscribe();
 *
 * @see {@link publish}
 * @see {@link publishLast}
 * @see {@link publishBehavior}
 * @see {@link publishReplay}
 * @see {@link share}
 * @see {@link shareReplay}
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through
 * which the source sequence's elements will be multicast to the selector function input Observable or
 * ConnectableObservable returned by the operator.
 * @param {Function} [selector] - Optional selector function that can use the input stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the input source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector
 * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.
 *
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);
}
exports.multicast = multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(6);
var Observable_1 = __webpack_require__(0);
var Subscriber_1 = __webpack_require__(3);
var Subscription_1 = __webpack_require__(12);
var refCount_1 = __webpack_require__(79);
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var pairwise_1 = __webpack_require__(186);
Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var pairwise_1 = __webpack_require__(187);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return pairwise_1.pairwise()(this);
}
exports.pairwise = pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var publish_1 = __webpack_require__(189);
Observable_1.Observable.prototype.publish = publish_1.publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var publish_1 = __webpack_require__(190);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return publish_1.publish(selector)(this);
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Subject_1 = __webpack_require__(6);
var multicast_1 = __webpack_require__(44);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var scan_1 = __webpack_require__(192);
Observable_1.Observable.prototype.scan = scan_1.scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var scan_1 = __webpack_require__(193);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    if (arguments.length >= 2) {
        return scan_1.scan(accumulator, seed)(this);
    }
    return scan_1.scan(accumulator)(this);
}
exports.scan = scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=scan.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var share_1 = __webpack_require__(195);
Observable_1.Observable.prototype.share = share_1.share;
//# sourceMappingURL=share.js.map

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var share_1 = __webpack_require__(196);
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 *
 * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.
 * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.
 * Observable.of("test").publish().refCount() will not re-emit "test" on new subscriptions, Observable.of("test").share() will
 * re-emit "test" to new subscriptions.
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return share_1.share()(this);
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var multicast_1 = __webpack_require__(44);
var refCount_1 = __webpack_require__(79);
var Subject_1 = __webpack_require__(6);
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .multicast(() => new Subject()).refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skip_1 = __webpack_require__(198);
Observable_1.Observable.prototype.skip = skip_1.skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var skip_1 = __webpack_require__(199);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return skip_1.skip(count)(this);
}
exports.skip = skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=skip.js.map

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var skipUntil_1 = __webpack_require__(201);
Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var skipUntil_1 = __webpack_require__(202);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return skipUntil_1.skipUntil(notifier)(this);
}
exports.skipUntil = skipUntil;
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        }
        else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=skipUntil.js.map

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var startWith_1 = __webpack_require__(204);
Observable_1.Observable.prototype.startWith = startWith_1.startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var startWith_1 = __webpack_require__(205);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return startWith_1.startWith.apply(void 0, array)(this);
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayObservable_1 = __webpack_require__(20);
var ScalarObservable_1 = __webpack_require__(41);
var EmptyObservable_1 = __webpack_require__(25);
var concat_1 = __webpack_require__(76);
var isScheduler_1 = __webpack_require__(19);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1) {
            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
        }
        else if (len > 1) {
            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
        }
        else {
            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
        }
    };
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMap_1 = __webpack_require__(207);
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMap_1 = __webpack_require__(208);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return switchMap_1.switchMap(project, resultSelector)(this);
}
exports.switchMap = switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return function switchMapOperatorFunction(source) {
        return source.lift(new SwitchMapOperator(project, resultSelector));
    };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var switchMapTo_1 = __webpack_require__(210);
Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var switchMapTo_1 = __webpack_require__(211);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);
}
exports.switchMapTo = switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = (function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var take_1 = __webpack_require__(213);
Observable_1.Observable.prototype.take = take_1.take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var take_1 = __webpack_require__(214);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return take_1.take(count)(this);
}
exports.take = take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(3);
var ArgumentOutOfRangeError_1 = __webpack_require__(215);
var EmptyObservable_1 = __webpack_require__(25);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    return function (source) {
        if (count === 0) {
            return new EmptyObservable_1.EmptyObservable();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=take.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var takeUntil_1 = __webpack_require__(217);
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var takeUntil_1 = __webpack_require__(218);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value, the output Observable stops mirroring the source Observable
 * and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return takeUntil_1.takeUntil(notifier)(this);
}
exports.takeUntil = takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(13);
var subscribeToResult_1 = __webpack_require__(14);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Observable_1 = __webpack_require__(0);
var timeout_1 = __webpack_require__(220);
Observable_1.Observable.prototype.timeout = timeout_1.timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var async_1 = __webpack_require__(21);
var timeout_1 = __webpack_require__(221);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeout_1.timeout(due, scheduler)(this);
}
exports.timeout = timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(21);
var isDate_1 = __webpack_require__(75);
var Subscriber_1 = __webpack_require__(3);
var TimeoutError_1 = __webpack_require__(80);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = (function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber));
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var deepEqual = __webpack_require__(223);
var BehaviorSubject_1 = __webpack_require__(81);
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(46);
var Subject_1 = __webpack_require__(6);
var config_1 = __webpack_require__(4);
var assert_1 = __webpack_require__(2);
var eventemitter_1 = __webpack_require__(32);
var log_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(18);
var ranges_1 = __webpack_require__(15);
var compat_1 = __webpack_require__(5);
var events_1 = __webpack_require__(16);
var net_1 = __webpack_require__(234);
var errors_1 = __webpack_require__(8);
var stream_1 = __webpack_require__(252);
var timings_1 = __webpack_require__(55);
var eme_1 = __webpack_require__(94);
var constants_1 = __webpack_require__(322);
var language_manager_1 = __webpack_require__(323);
var clock_1 = __webpack_require__(324);
var option_parsers_1 = __webpack_require__(325);
var DEFAULT_UNMUTED_VOLUME = config_1.default.DEFAULT_UNMUTED_VOLUME;
/**
 * @class Player
 * @extends EventEmitter
 */
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    /**
     * Note: as the private state from this class can be pretty heavy, every
     * private properties should be initialized here for better visibility.
     * @constructor
     * @param {Object} options
     * @param {HTMLMediaElement} options.videoElement
     */
    function Player(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        var _a = option_parsers_1.parseConstructorOptions(options), initialAudioBitrate = _a.initialAudioBitrate, initialVideoBitrate = _a.initialVideoBitrate, limitVideoWidth = _a.limitVideoWidth, maxAudioBitrate = _a.maxAudioBitrate, maxBufferAhead = _a.maxBufferAhead, maxBufferBehind = _a.maxBufferBehind, maxVideoBitrate = _a.maxVideoBitrate, throttleWhenHidden = _a.throttleWhenHidden, videoElement = _a.videoElement, wantedBufferAhead = _a.wantedBufferAhead;
        // Workaround to support Firefox autoplay on FF 42.
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
        videoElement.preload = "auto";
        _this.version = /*PLAYER_VERSION*/ "3.0.5";
        _this.log = log_1.default;
        _this.state = "STOPPED";
        _this.videoElement = videoElement;
        _this._priv_destroy$ = new Subject_1.Subject();
        events_1.onFullscreenChange$(videoElement)
            .takeUntil(_this._priv_destroy$)
            .subscribe(function () { return _this.trigger("fullscreenChange", _this.isFullscreen()); });
        events_1.onTextTrackChanges$(videoElement.textTracks)
            .takeUntil(_this._priv_destroy$)
            .map(function (evt) {
            var target = evt.target;
            var arr = [];
            for (var i = 0; i < target.length; i++) {
                var textTrack = target[i];
                arr.push(textTrack);
            }
            return arr;
        })
            .distinctUntilChanged(function (textTracksA, textTracksB) {
            if (textTracksA.length !== textTracksB.length) {
                return false;
            }
            for (var i = 0; i < textTracksA.length; i++) {
                if (textTracksA[i] !== textTracksB[i]) {
                    return false;
                }
            }
            return true;
        })
            .subscribe(function (x) { return _this._priv_onNativeTextTracksNext(x); });
        _this._priv_errorStream$ = new Subject_1.Subject();
        _this._priv_playing$ = new ReplaySubject_1.ReplaySubject(1);
        _this._priv_speed$ = new BehaviorSubject_1.BehaviorSubject(videoElement.playbackRate);
        _this._priv_unsubscribeLoadedVideo$ = new Subject_1.Subject();
        _this._priv_streamLock$ = new BehaviorSubject_1.BehaviorSubject(false);
        _this._priv_wantedBufferAhead$ = new BehaviorSubject_1.BehaviorSubject(wantedBufferAhead);
        _this._priv_maxBufferAhead$ = new BehaviorSubject_1.BehaviorSubject(maxBufferAhead);
        _this._priv_maxBufferBehind$ = new BehaviorSubject_1.BehaviorSubject(maxBufferBehind);
        _this._priv_lastBitrates = {
            audio: initialAudioBitrate,
            video: initialVideoBitrate,
        };
        _this._priv_initialMaxAutoBitrates = {
            audio: maxAudioBitrate,
            video: maxVideoBitrate,
        };
        _this._priv_manualBitrates = {
            audio: -1,
            video: -1,
        };
        _this._priv_throttleWhenHidden = throttleWhenHidden;
        _this._priv_limitVideoWidth = limitVideoWidth;
        _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
        _this._priv_initialAudioTrack = undefined;
        _this._priv_initialTextTrack = undefined;
        _this._priv_languageManager = null;
        _this._priv_abrManager = null;
        _this._priv_manifest = null;
        _this._priv_currentRepresentations = {};
        _this._priv_currentAdaptations = {};
        _this._priv_recordedEvents = {}; // event memory
        _this._priv_fatalError = null;
        _this._priv_currentImagePlaylist = null;
        _this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        return _this;
    }
    Object.defineProperty(Player, "ErrorTypes", {
        /**
         * @returns {Object}
         */
        get: function () {
            return errors_1.ErrorTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player, "ErrorCodes", {
        /**
         * @returns {Object}
         */
        get: function () {
            return errors_1.ErrorCodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Player, "LogLevel", {
        /**
         * @returns {string} - current log level
         */
        get: function () {
            return log_1.default.getLevel();
        },
        /**
         * @param {string} logLevel - should be either (by verbosity ascending):
         *   - "NONE"
         *   - "ERROR"
         *   - "WARNING"
         *   - "INFO"
         *   - "DEBUG"
         * Any other value will be translated to "NONE".
         */
        set: function (logLevel) {
            log_1.default.setLevel(logLevel);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stop the player.
     */
    Player.prototype.stop = function () {
        if (this.state !== constants_1.PLAYER_STATES.STOPPED) {
            this._priv_unsubscribeLoadedVideo$.next();
            this._priv_cleanUpCurrentContentState();
            this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        }
    };
    /**
     * Free the resources used by the player.
     */
    Player.prototype.dispose = function () {
        // free resources linked to the loaded content
        this.stop();
        // free resources used for EME management
        eme_1.dispose();
        // free Observables linked to the Player instance
        this._priv_destroy$.next();
        this._priv_destroy$.complete();
        // Complete all subjects
        this._priv_unsubscribeLoadedVideo$.complete();
        this._priv_errorStream$.complete();
        this._priv_playing$.complete();
        this._priv_speed$.complete();
        this._priv_streamLock$.complete();
        this._priv_wantedBufferAhead$.complete();
        this._priv_maxBufferAhead$.complete();
        this._priv_maxBufferBehind$.complete();
        // un-attach video element
        this.videoElement = null;
    };
    /**
     * Load a new video.
     * @param {Object} opts
     * @returns {Observable}
     * @throws Error - throws if no url is given.
     * @throws Error - throws if no transport is given and no default transport
     * has been set.
     * @throws Error - throws if the asked transport does not exist
     */
    Player.prototype.loadVideo = function (opts) {
        var _this = this;
        var options = option_parsers_1.parseLoadVideoOptions(opts);
        log_1.default.info("loadvideo", options);
        var autoPlay = options.autoPlay, defaultAudioTrack = options.defaultAudioTrack, defaultTextTrack = options.defaultTextTrack, keySystems = options.keySystems, startAt = options.startAt, supplementaryImageTracks = options.supplementaryImageTracks, supplementaryTextTracks = options.supplementaryTextTracks, transport = options.transport, transportOptions = options.transportOptions, url = options.url;
        // Perform multiple checks on the given options
        if (!this.videoElement) {
            throw new Error("the attached video element is disposed");
        }
        var transportFn = net_1.default[transport];
        if (!transportFn) {
            throw new Error("transport \"" + transport + "\" not supported");
        }
        var transportObj = transportFn(transportOptions);
        // now that every check has passed, stop previous content
        this.stop();
        // prepare initial tracks played
        this._priv_initialAudioTrack = defaultAudioTrack;
        this._priv_initialTextTrack = defaultTextTrack;
        // inilialize to false
        this._priv_playing$.next(false);
        // get every properties used from context for clarity
        var videoElement = this.videoElement;
        // TODO either ditch or repair directFile playback
        /** @type {Boolean} */
        // const withMediaSource = !transport.directFile;
        var withMediaSource = true;
        /**
         * Global clock used for the whole application.
         * @type {Observable.<Object>}
         */
        var clock$ = clock_1.default(videoElement, { withMediaSource: withMediaSource });
        /**
         * Options used by the ABR Manager.
         * @type {Object}
         */
        var adaptiveOptions = {
            initialBitrates: this._priv_lastBitrates,
            manualBitrates: this._priv_manualBitrates,
            maxAutoBitrates: this._priv_initialMaxAutoBitrates,
            throttle: this._priv_throttleWhenHidden ? {
                video: events_1.isInBackground$()
                    .map(function (isBg) { return isBg ? 0 : Infinity; })
                    .takeUntil(this._priv_unsubscribeLoadedVideo$),
            } : {},
            limitWidth: this._priv_limitVideoWidth ? {
                video: events_1.videoWidth$(videoElement)
                    .takeUntil(this._priv_unsubscribeLoadedVideo$),
            } : {},
        };
        /**
         * Options used by the Buffer(s)
         * @type {Object}
         */
        var bufferOptions = {
            wantedBufferAhead$: this._priv_wantedBufferAhead$,
            maxBufferAhead$: this._priv_maxBufferAhead$,
            maxBufferBehind$: this._priv_maxBufferBehind$,
        };
        /**
         * Options used by the TextTrack SourceBuffer
         * @type {Object}
         */
        var textTrackOptions = options.textTrackMode === "native" ? {
            textTrackMode: "native",
            hideNativeSubtitle: options.hideNativeSubtitle,
        } : {
            textTrackMode: "html",
            textTrackElement: options.textTrackElement,
        };
        /**
         * Stream Observable, through which the content will be launched.
         * @type {Observable.<Object>}
         */
        var stream = stream_1.default({
            adaptiveOptions: adaptiveOptions,
            autoPlay: autoPlay,
            bufferOptions: bufferOptions,
            errorStream: this._priv_errorStream$,
            keySystems: keySystems,
            speed$: this._priv_speed$,
            startAt: startAt,
            textTrackOptions: textTrackOptions,
            timings$: clock$,
            transport: transportObj,
            url: url,
            videoElement: videoElement,
            withMediaSource: withMediaSource,
            supplementaryImageTracks: supplementaryImageTracks,
            supplementaryTextTracks: supplementaryTextTracks,
        })
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .publish();
        /**
         * Emit a truthy value when the player stalls, a falsy value as it unstalls.
         * TODO Find a way with TS
         * @type {Observable}
         */
        var stalled$ = stream
            .filter(function (_a) {
            var type = _a.type;
            return type === "stalled";
        })
            .map(function (x) { return x.value; })
            .startWith(null);
        /**
         * Emit when the stream is considered "loaded".
         * @type {Observable}
         */
        var loaded = stream
            .filter(function (_a) {
            var type = _a.type;
            return type === "loaded";
        })
            .take(1)
            .share();
        /**
         * Emit the player state as it changes.
         * TODO only way to call setPlayerState?
         * @type {Observable.<string>}
         */
        var stateChanges$ = loaded.mapTo(constants_1.PLAYER_STATES.LOADED)
            .concat(Observable_1.Observable.combineLatest(this._priv_playing$, stalled$)
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .map(function (_a) {
            var isPlaying = _a[0], stalledStatus = _a[1];
            if (stalledStatus) {
                return (stalledStatus.state === "seeking") ?
                    constants_1.PLAYER_STATES.SEEKING : constants_1.PLAYER_STATES.BUFFERING;
            }
            return isPlaying ? constants_1.PLAYER_STATES.PLAYING : constants_1.PLAYER_STATES.PAUSED;
        })
            .skipUntil(this._priv_playing$.filter(function (isPlaying) { return isPlaying; })))
            .distinctUntilChanged()
            .startWith(constants_1.PLAYER_STATES.LOADING);
        /**
         * Emit true each time the player goes into a "play" state.
         * @type {Observable.<Boolean>}
         */
        var videoPlays$ = events_1.onPlayPause$(videoElement)
            .map(function (evt) { return evt.type === "play"; });
        var streamDisposable;
        this._priv_unsubscribeLoadedVideo$.take(1).subscribe(function () {
            if (streamDisposable) {
                streamDisposable.unsubscribe();
            }
        });
        videoPlays$
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .subscribe(function (x) { return _this._priv_onPlayPauseNext(x); }, noop_1.default);
        clock$
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .subscribe(function (x) { return _this._priv_triggerTimeChange(x); }, noop_1.default);
        stateChanges$
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .subscribe(function (x) { return _this._priv_setPlayerState(x); }, noop_1.default);
        stream.subscribe(function (x) { return _this._priv_onStreamNext(x); }, function (err) { return _this._priv_onStreamError(err); }, function () { return _this._priv_onStreamComplete(); });
        this._priv_errorStream$
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .subscribe(function (x) { return _this._priv_onErrorStreamNext(x); });
        // connect the stream when the lock is inactive
        this._priv_streamLock$
            .filter(function (isLocked) { return !isLocked; })
            .take(1)
            .takeUntil(this._priv_unsubscribeLoadedVideo$)
            .subscribe(function () {
            streamDisposable = stream.connect();
        });
    };
    /**
     * Returns fatal error if one for the current content. null otherwise.
     * @returns {Object|null}
     */
    Player.prototype.getError = function () {
        return this._priv_fatalError;
    };
    /**
     * Returns manifest/playlist object.
     * null if the player is STOPPED.
     * @returns {Manifest|null}
     */
    Player.prototype.getManifest = function () {
        return this._priv_manifest || null;
    };
    /**
     * Returns adaptations (tracks) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
    Player.prototype.getCurrentAdaptations = function () {
        if (!this._priv_manifest) {
            return null;
        }
        return this._priv_currentAdaptations;
    };
    /**
     * Returns representations (qualities) for every currently playing type
     * (audio/video/text...).
     * @returns {Object|null}
     */
    Player.prototype.getCurrentRepresentations = function () {
        if (!this._priv_manifest) {
            return null;
        }
        return this._priv_currentRepresentations;
    };
    /**
     * Returns the video DOM element used by the player.
     * You should not its HTML5 API directly and use the player's method instead,
     * to ensure a well-behaved player.
     * @returns {HTMLMediaElement|null}
     */
    Player.prototype.getVideoElement = function () {
        return this.videoElement;
    };
    /**
     * Returns the text-track element used by the player to inject subtitles.
     * @returns {TextTrack}
     */
    Player.prototype.getNativeTextTrack = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        var textTracks = videoElement.textTracks;
        if (textTracks.length > 0) {
            return videoElement.textTracks[0];
        }
        else {
            return null;
        }
    };
    /**
     * Returns the player's current state.
     * @returns {string}
     */
    Player.prototype.getPlayerState = function () {
        return this.state;
    };
    /**
     * Returns true if:
     *   - a content is loaded
     *   - the content is a live content
     * @returns {Boolean}
     */
    Player.prototype.isLive = function () {
        if (!this._priv_manifest) {
            return false;
        }
        return this._priv_manifest.isLive;
    };
    /**
     * Returns the url of the content's manifest
     * @returns {string|undefined}
     */
    Player.prototype.getUrl = function () {
        if (!this._priv_manifest) {
            return undefined;
        }
        return this._priv_manifest.getUrl();
    };
    /**
     * Returns the video duration, in seconds.
     * NaN if no video is playing.
     * @returns {Number}
     */
    Player.prototype.getVideoDuration = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.duration;
    };
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the current time
     * @returns {Number}
     */
    Player.prototype.getVideoBufferGap = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getLeftSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    Player.prototype.getVideoLoadedTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Returns in seconds the difference between:
     *   - the current time.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    Player.prototype.getVideoPlayedTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        return ranges_1.getPlayedSizeOfRange(videoElement.buffered, videoElement.currentTime);
    };
    /**
     * Get the current position, in s, in wall-clock time.
     * That is:
     *   - for live content, get a timestamp, in s, of the current played content.
     *   - for static content, returns the position from beginning in s.
     *
     * If you do not know if you want to use this method or getPosition:
     *   - If what you want is to display the current time to the user, use this
     *     one.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use getPosition.
     *
     * @returns {Number}
     */
    Player.prototype.getWallClockTime = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        if (!this._priv_manifest) {
            return 0;
        }
        var ct = this.videoElement.currentTime;
        return this.isLive() ?
            (+timings_1.toWallClockTime(ct, this._priv_manifest) / 1000) : ct;
    };
    /**
     * Get the current position, in seconds, of the video element.
     *
     * If you do not know if you want to use this method or getWallClockTime:
     *   - If what you want is to display the current time to the user, use
     *     getWallClockTime.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use this one.
     *
     * @returns {Number}
     */
    Player.prototype.getPosition = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.currentTime;
    };
    /**
     * Returns the current speed at which the video plays.
     * @returns {Number}
     */
    Player.prototype.getPlaybackRate = function () {
        return this._priv_speed$.getValue();
    };
    /**
     * @returns {Number}
     */
    Player.prototype.getVolume = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        return this.videoElement.volume;
    };
    /**
     * @returns {Boolean}
     */
    Player.prototype.isFullscreen = function () {
        return compat_1.isFullscreen();
    };
    /**
     * @returns {Array.<Number>}
     */
    Player.prototype.getAvailableVideoBitrates = function () {
        var videoAdaptation = this._priv_currentAdaptations.video;
        if (!videoAdaptation) {
            return [];
        }
        return videoAdaptation.representations
            .map(function (_a) {
            var bitrate = _a.bitrate;
            return bitrate;
        });
    };
    /**
     * @returns {Array.<Number>}
     */
    Player.prototype.getAvailableAudioBitrates = function () {
        var audioAdaptation = this._priv_currentAdaptations.audio;
        if (!audioAdaptation) {
            return [];
        }
        return audioAdaptation.representations
            .map(function (_a) {
            var bitrate = _a.bitrate;
            return bitrate;
        });
    };
    /**
     * Returns the manual audio bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    Player.prototype.getManualAudioBitrate = function () {
        return this._priv_manualBitrates.audio;
    };
    /**
     * Returns the manual video bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    Player.prototype.getManualVideoBitrate = function () {
        return this._priv_manualBitrates.video;
    };
    /**
     * Returns currently considered bitrate for video segments.
     * @returns {Number|undefined}
     */
    Player.prototype.getVideoBitrate = function () {
        return this._priv_recordedEvents.videoBitrate;
    };
    /**
     * Returns currently considered bitrate for audio segments.
     * @returns {Number|undefined}
     */
    Player.prototype.getAudioBitrate = function () {
        return this._priv_recordedEvents.audioBitrate;
    };
    /**
     * Returns max wanted video bitrate currently set.
     * @returns {Number}
     */
    Player.prototype.getMaxVideoBitrate = function () {
        if (!this._priv_abrManager) {
            return this._priv_initialMaxAutoBitrates.video;
        }
        return this._priv_abrManager.getMaxAutoBitrate("video");
    };
    /**
     * Returns max wanted audio bitrate currently set.
     * @returns {Number}
     */
    Player.prototype.getMaxAudioBitrate = function () {
        if (!this._priv_abrManager) {
            return this._priv_initialMaxAutoBitrates.audio;
        }
        return this._priv_abrManager.getMaxAutoBitrate("audio");
    };
    /**
     * Play/Resume the current video.
     */
    Player.prototype.play = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        /* tslint:disable no-floating-promises */
        this.videoElement.play();
        /* tslint:enable no-floating-promises */
    };
    /**
     * Pause playback of the video.
     */
    Player.prototype.pause = function () {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        this.videoElement.pause();
    };
    /**
     * Update the playback rate of the video.
     * @param {Number} rate
     */
    Player.prototype.setPlaybackRate = function (rate) {
        this._priv_speed$.next(rate);
    };
    /**
     * Seek to a given absolute position.
     * @param {Number|Object} time
     * @returns {Number} - The time the player has seek to
     */
    Player.prototype.seekTo = function (time) {
        if (!this._priv_manifest) {
            throw new Error("player: no manifest loaded");
        }
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var positionWanted;
        var typeOf = typeof time;
        if (typeOf === "number") {
            positionWanted = time;
        }
        else if (typeOf === "object") {
            var currentTs = this.videoElement.currentTime;
            if (time.relative != null) {
                positionWanted = currentTs + time.relative;
            }
            else if (time.position != null) {
                positionWanted = time.position;
            }
            else if (time.wallClockTime != null) {
                var manifest = this._priv_manifest;
                positionWanted = timings_1.fromWallClockTime(time.wallClockTime * 1000, manifest);
            }
            else {
                throw new Error("invalid time object. You must set one of the " +
                    "following properties: \"relative\", \"position\" or " +
                    "\"wallClockTime\"");
            }
        }
        if (positionWanted === undefined) {
            throw new Error("invalid time given");
        }
        this.videoElement.currentTime = positionWanted;
        return positionWanted;
    };
    Player.prototype.exitFullscreen = function () {
        compat_1.exitFullscreen();
    };
    /**
     * Set/exit fullScreen.
     * @param {Boolean} [goFull=true] - if false, exit full screen.
     */
    Player.prototype.setFullscreen = function (goFull) {
        if (goFull === void 0) { goFull = true; }
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        if (goFull) {
            compat_1.requestFullscreen(this.videoElement);
        }
        else {
            compat_1.exitFullscreen();
        }
    };
    /**
     * Set the player's volume. From 0 (muted volume) to 1 (maximum volume).
     * @param {Number}
     */
    Player.prototype.setVolume = function (volume) {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        if (volume !== videoElement.volume) {
            videoElement.volume = volume;
            this.trigger("volumeChange", volume);
        }
    };
    /**
     * Returns true if the volume is set to 0. false otherwise.
     * @returns {Boolean}
     */
    Player.prototype.isMute = function () {
        return !this.getVolume();
    };
    /**
     * Set the volume to 0 and save current one for when unmuted.
     */
    Player.prototype.mute = function () {
        this._priv_mutedMemory = this.getVolume();
        this.setVolume(0);
    };
    /**
     * Set the volume back to when it was when mute was last called.
     * If the volume was set to 0, set a default volume instead (see config).
     */
    Player.prototype.unMute = function () {
        var vol = this.getVolume();
        if (vol === 0) {
            this.setVolume(this._priv_mutedMemory || DEFAULT_UNMUTED_VOLUME);
        }
    };
    /**
     * Force the video bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    Player.prototype.setVideoBitrate = function (btr) {
        this._priv_manualBitrates.video = btr;
        if (this._priv_abrManager) {
            this._priv_abrManager.setManualBitrate("video", btr);
        }
    };
    /**
     * Force the audio bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    Player.prototype.setAudioBitrate = function (btr) {
        this._priv_manualBitrates.audio = btr;
        if (this._priv_abrManager) {
            this._priv_abrManager.setManualBitrate("audio", btr);
        }
    };
    /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
    Player.prototype.setMaxVideoBitrate = function (btr) {
        // set it for the next content loaded
        this._priv_initialMaxAutoBitrates.video = btr;
        // set it for the current if one is loaded
        if (this._priv_abrManager) {
            this._priv_abrManager.setMaxAutoBitrate("video", btr);
        }
    };
    /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
    Player.prototype.setMaxAudioBitrate = function (btr) {
        // set it for the next content loaded
        this._priv_initialMaxAutoBitrates.audio = btr;
        // set it for the current if one is loaded
        if (this._priv_abrManager) {
            this._priv_abrManager.setMaxAutoBitrate("audio", btr);
        }
    };
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    Player.prototype.setMaxBufferBehind = function (depthInSeconds) {
        this._priv_maxBufferBehind$.next(depthInSeconds);
    };
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    Player.prototype.setMaxBufferAhead = function (depthInSeconds) {
        this._priv_maxBufferAhead$.next(depthInSeconds);
    };
    /**
     * Set the max buffer size for the buffer ahead of the current position.
     * The player will stop downloading chunks when this size is reached.
     * @param {Number} sizeInSeconds
     */
    Player.prototype.setWantedBufferAhead = function (sizeInSeconds) {
        this._priv_wantedBufferAhead$.next(sizeInSeconds);
    };
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    Player.prototype.getMaxBufferBehind = function () {
        return this._priv_maxBufferBehind$.getValue();
    };
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    Player.prototype.getMaxBufferAhead = function () {
        return this._priv_maxBufferAhead$.getValue();
    };
    /**
     * Returns the max buffer size for the buffer ahead of the current position.
     * @returns {Number}
     */
    Player.prototype.getWantedBufferAhead = function () {
        return this._priv_wantedBufferAhead$.getValue();
    };
    /**
     * Returns type of current keysystem (e.g. playready, widevine) if the content
     * is encrypted. null otherwise.
     * @returns {string|null}
     */
    Player.prototype.getCurrentKeySystem = function () {
        return eme_1.getCurrentKeySystem();
    };
    /**
     * @returns {Array.<Object>|null}
     */
    Player.prototype.getAvailableAudioTracks = function () {
        if (!this._priv_languageManager) {
            return null;
        }
        return this._priv_languageManager.getAvailableAudioTracks();
    };
    /**
     * @returns {Array.<Object>|null}
     */
    Player.prototype.getAvailableTextTracks = function () {
        if (!this._priv_languageManager) {
            return null;
        }
        return this._priv_languageManager.getAvailableTextTracks();
    };
    /**
     * Returns last chosen language.
     * @returns {string}
     */
    Player.prototype.getAudioTrack = function () {
        if (!this._priv_languageManager) {
            return undefined;
        }
        return this._priv_languageManager.getCurrentAudioTrack();
    };
    /**
     * Returns last chosen subtitle.
     * @returns {string}
     */
    Player.prototype.getTextTrack = function () {
        if (!this._priv_languageManager) {
            return undefined;
        }
        return this._priv_languageManager.getCurrentTextTrack();
    };
    /**
     * Update the audio language.
     * @param {string} audioId
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no audio track.
     */
    Player.prototype.setAudioTrack = function (audioId) {
        if (!this._priv_languageManager) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_languageManager.setAudioTrackByID(audioId);
        }
        catch (e) {
            throw new Error("player: unknown audio track");
        }
    };
    /**
     * Update the audio language.
     * @param {string} sub
     * @throws Error - the current content has no LanguageManager.
     * @throws Error - the given id is linked to no text track.
     */
    Player.prototype.setTextTrack = function (textId) {
        if (!this._priv_languageManager) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_languageManager.setTextTrackByID(textId);
        }
        catch (e) {
            throw new Error("player: unknown text track");
        }
    };
    Player.prototype.disableTextTrack = function () {
        if (!this._priv_languageManager) {
            return;
        }
        return this._priv_languageManager.disableTextTrack();
    };
    Player.prototype.getImageTrackData = function () {
        if (!this._priv_manifest) {
            return null;
        }
        return this._priv_currentImagePlaylist;
    };
    /**
     * Get minimum seek-able position.
     * @returns {number}
     */
    Player.prototype.getMinimumPosition = function () {
        if (!this._priv_manifest) {
            return null;
        }
        return timings_1.getMinimumBufferPosition(this._priv_manifest);
    };
    /**
     * Get maximum seek-able position.
     * @returns {number}
     */
    Player.prototype.getMaximumPosition = function () {
        if (!this._priv_manifest) {
            return null;
        }
        return timings_1.getMaximumBufferPosition(this._priv_manifest);
    };
    /**
     * Reset all state properties relative to a playing content.
     */
    Player.prototype._priv_cleanUpCurrentContentState = function () {
        var _this = this;
        // lock creation of new streams while cleaning up is pending
        this._priv_streamLock$.next(true);
        // language management
        this._priv_initialAudioTrack = undefined;
        this._priv_initialTextTrack = undefined;
        this._priv_languageManager = null;
        if (this._priv_abrManager) {
            this._priv_abrManager.dispose();
            this._priv_abrManager = null;
        }
        this._priv_manifest = null;
        this._priv_currentRepresentations = {};
        this._priv_currentAdaptations = {};
        this._priv_recordedEvents = {}; // event memory
        this._priv_fatalError = null;
        this._priv_currentImagePlaylist = null;
        var freeUpStreamLock = function () {
            _this._priv_streamLock$.next(false);
        };
        eme_1.clearEME()
            .catch(function () { return Observable_1.Observable.empty(); })
            .subscribe(noop_1.default, freeUpStreamLock, freeUpStreamLock);
    };
    /**
     * Store and emit new player state (e.g. text track, videoBitrate...).
     * We check for deep equality to avoid emitting 2 consecutive times the same
     * state.
     * @param {string} type - the type of the updated state (videoBitrate...)
     * @param {*} value - its new value
     */
    Player.prototype._priv_recordState = function (type, value) {
        var prev = this._priv_recordedEvents[type];
        if (!deepEqual(prev, value)) {
            this._priv_recordedEvents[type] = value;
            this.trigger(type + "Change", value);
        }
    };
    /**
     * Called each time the Stream Observable emits.
     * @param {Object} streamInfos - payload emitted
     */
    Player.prototype._priv_onStreamNext = function (streamInfos) {
        switch (streamInfos.type) {
            case "representationChange":
                this._priv_onRepresentationChange(streamInfos.value);
                break;
            case "manifestUpdate":
                this._priv_onManifestUpdate(streamInfos.value);
                break;
            case "adaptationChange":
                this._priv_onAdaptationChange(streamInfos.value);
                break;
            case "bitrateEstimationChange":
                this._priv_onBitrateEstimationChange(streamInfos.value);
                break;
            case "manifestChange":
                this._priv_onManifestChange(streamInfos.value);
                break;
            case "pipeline":
                var _a = streamInfos.value, bufferType = _a.bufferType, parsed = _a.parsed;
                if (bufferType === "image") {
                    var segmentData = parsed.segmentData;
                    // TODO merge multiple data from the same track together
                    this._priv_currentImagePlaylist = segmentData;
                    this.trigger("imageTrackUpdate", {
                        data: this._priv_currentImagePlaylist,
                    });
                }
        }
    };
    /**
     * Called each time the Stream emits through its errorStream (non-fatal
     * errors).
     * @param {Object} streamInfos
     */
    Player.prototype._priv_onErrorStreamNext = function (error) {
        this.trigger("warning", error);
    };
    /**
     * Called when the Stream instance throws (fatal errors).
     * @param {Object} streamInfos
     */
    Player.prototype._priv_onStreamError = function (error) {
        this._priv_unsubscribeLoadedVideo$.next();
        this._priv_cleanUpCurrentContentState();
        this._priv_fatalError = error;
        this._priv_setPlayerState(constants_1.PLAYER_STATES.STOPPED);
        // TODO This condition is here because the eventual callback called when the
        // player state is updated can launch a new content, thus the error will not
        // be here anymore, in which case triggering the "error" event is unwanted.
        // This is not perfect however as technically, this condition could be true
        // even for a new content (I cannot see it happen with the current code but
        // that's not a reason). In that case, "error" would be triggered 2 times.
        // Find a better solution.
        if (this._priv_fatalError === error) {
            this.trigger("error", error);
        }
    };
    /**
     * Called when the Stream instance complete.
     * @param {Object} streamInfos
     */
    Player.prototype._priv_onStreamComplete = function () {
        this._priv_unsubscribeLoadedVideo$.next();
        this._priv_cleanUpCurrentContentState();
        this._priv_setPlayerState(constants_1.PLAYER_STATES.ENDED);
    };
    /**
     * Called when the manifest is first downloaded.
     * @param {Object} value
     * @param {Manifest} value.manifest - The Manifest instance
     * @param {Subject} value.adaptations$ - Subject to emit the chosen
     * adaptation for each type.
     */
    Player.prototype._priv_onManifestChange = function (value) {
        var manifest = value.manifest, adaptations$ = value.adaptations$;
        this._priv_manifest = manifest;
        // set language management for audio and text
        this._priv_languageManager =
            new language_manager_1.default(manifest.adaptations, {
                audio$: adaptations$.audio,
                text$: adaptations$.text,
            });
        // set initial adaptations
        for (var _i = 0, _a = Object.keys(adaptations$); _i < _a.length; _i++) {
            var bufferType = _a[_i];
            var adaptations = manifest.getAdaptationsForType(bufferType);
            // if we have adaptations for the given type, make a choice.
            // if we do not, do not emit anything for it.
            if (adaptations.length) {
                if (bufferType === "audio" && this._priv_languageManager) {
                    this._priv_languageManager
                        .setInitialAudioTrack(this._priv_initialAudioTrack);
                }
                else if (bufferType === "text" && this._priv_languageManager) {
                    this._priv_languageManager
                        .setInitialTextTrack(this._priv_initialTextTrack);
                }
                else {
                    var adaptation$ = adaptations$[bufferType];
                    adaptation$.next(adaptations[0]);
                }
            }
        }
        this._priv_abrManager = value.abrManager;
        this.trigger("manifestChange", manifest);
    };
    Player.prototype._priv_onManifestUpdate = function (value) {
        if (false) {
            assert_1.default(value && value.manifest, "no manifest received");
        }
        var manifest = value.manifest;
        this._priv_manifest = manifest;
        if (this._priv_languageManager) {
            this._priv_languageManager.updateAdaptations(manifest.adaptations);
        }
        this.trigger("manifestUpdate", manifest);
    };
    /**
     * @param {Object} obj
     * @param {string} obj.type
     * @param {Object} obj.adaptation
     */
    Player.prototype._priv_onAdaptationChange = function (_a) {
        var type = _a.type, adaptation = _a.adaptation;
        this._priv_currentAdaptations[type] = adaptation;
        // TODO Emit adaptationChange?
        if (!this._priv_languageManager) {
            return;
        }
        if (type === "audio") {
            var audioTrack = this._priv_languageManager.getCurrentAudioTrack();
            this._priv_recordState("audioTrack", audioTrack);
        }
        else if (type === "text") {
            var textTrack = this._priv_languageManager.getCurrentTextTrack();
            this._priv_recordState("textTrack", textTrack);
        }
    };
    /**
     * Called each time a representation changes.
     * @param {Object} obj
     * @param {string} obj.type
     * @param {Object} obj.representation
     */
    Player.prototype._priv_onRepresentationChange = function (_a) {
        var type = _a.type, representation = _a.representation;
        this._priv_currentRepresentations[type] = representation;
        var bitrate = representation && representation.bitrate;
        if (bitrate != null) {
            this._priv_lastBitrates[type] = bitrate;
        }
        // TODO Emit representationChange?
        if (type === "video") {
            this._priv_recordState("videoBitrate", bitrate != null ? bitrate : -1);
        }
        else if (type === "audio") {
            this._priv_recordState("audioBitrate", bitrate != null ? bitrate : -1);
        }
    };
    Player.prototype._priv_onBitrateEstimationChange = function (_a) {
        var type = _a.type, bitrate = _a.bitrate;
        if (false) {
            assert_1.default(type != null);
            assert_1.default(bitrate != null);
        }
        this._priv_recordState("bitrateEstimation", { type: type, bitrate: bitrate });
    };
    /**
     * Called each time the player alternates between play and pause.
     * @param {Boolean} isPlaying
     */
    Player.prototype._priv_onPlayPauseNext = function (isPlaying) {
        if (!this.videoElement) {
            throw new Error("Disposed player");
        }
        var videoElement = this.videoElement;
        if (!videoElement.ended) {
            this._priv_playing$.next(isPlaying);
        }
    };
    /**
     * Called each time a textTrack is added to the video DOM Element.
     * @param {Array.<TextTrackElement} tracks
     */
    Player.prototype._priv_onNativeTextTracksNext = function (tracks) {
        this.trigger("nativeTextTracksChange", tracks);
    };
    /**
     * Called each time the player state updates.
     * @param {string} s
     */
    Player.prototype._priv_setPlayerState = function (s) {
        if (this.state !== s) {
            this.state = s;
            log_1.default.info("playerStateChange", s);
            this.trigger("playerStateChange", s);
        }
    };
    /**
     * Called each time a new timing object is emitted.
     * @param {Object} timing
     */
    Player.prototype._priv_triggerTimeChange = function (timing) {
        if (!this._priv_manifest || !timing) {
            return;
        }
        var positionData = {
            position: timing.currentTime,
            duration: timing.duration,
            playbackRate: timing.playbackRate,
            // TODO fix higher up?
            bufferGap: isFinite(timing.bufferGap) ? timing.bufferGap : 0,
        };
        if (this._priv_manifest.isLive && timing.currentTime > 0) {
            positionData.wallClockTime =
                timings_1.toWallClockTime(timing.currentTime, this._priv_manifest)
                    .getTime() / 1000;
            positionData.liveGap =
                timings_1.getMaximumBufferPosition(this._priv_manifest) - timing.currentTime;
        }
        this.trigger("positionUpdate", positionData);
    };
    return Player;
}(eventemitter_1.default));
exports.default = Player;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(224);
var isArguments = __webpack_require__(225);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 224 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 225 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var QueueAction_1 = __webpack_require__(227);
var QueueScheduler_1 = __webpack_require__(228);
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(69);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(70);
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class AssertionError
 * @extends Error
 */
var AssertionError = /** @class */ (function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(message) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, AssertionError.prototype);
        _this.name = "AssertionError";
        _this.message = message;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, AssertionError);
        }
        return _this;
    }
    return AssertionError;
}(Error));
exports.default = AssertionError;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transform an array of strings into an Object with the key and value
 * mirrored.
 * @param {Array.<string>} list
 * @returns {Object}
 */
function listToMap(list) {
    var map = list.reduce(function (obj, name) {
        obj[name] = name;
        return obj;
    }, {});
    return map;
}
exports.default = listToMap;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Request fullScreen action on a given element.
 * @paras {HTMLElement} elt
 * rs-detect)
 */
function requestFullscreen(elt) {
    if (!isFullscreen()) {
        if (elt.requestFullscreen) {
            elt.requestFullscreen();
        }
        else if (elt.msRequestFullscreen) {
            elt.msRequestFullscreen();
        }
        else if (elt.mozRequestFullScreen) {
            elt.mozRequestFullScreen();
        }
        else if (elt.webkitRequestFullscreen) {
            // TODO Open issue in TypeScript?
            elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
    }
}
exports.requestFullscreen = requestFullscreen;
/**
 * Exit fullscreen if an element is currently in fullscreen.
 * TODO this exit fullscreen mode even if any element in the document is in
 * fullscreen, is it really what we want?
 */
function exitFullscreen() {
    if (isFullscreen()) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    }
}
exports.exitFullscreen = exitFullscreen;
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */
function isFullscreen() {
    return !!(document.fullscreenElement ||
        document.mozFullScreenElement ||
        document.webkitFullscreenElement ||
        document.msFullscreenElement);
}
exports.isFullscreen = isFullscreen;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var keySystemAccess_1 = __webpack_require__(82);
exports.KeySystemAccess = keySystemAccess_1.default;
var MediaKeys_1 = __webpack_require__(83);
exports.requestMediaKeySystemAccess = MediaKeys_1.requestMediaKeySystemAccess;
var setMediaKeys_1 = __webpack_require__(233);
exports.setMediaKeys = setMediaKeys_1.default;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var castToObservable_1 = __webpack_require__(10);
var MediaKeys_1 = __webpack_require__(83);
/**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Promise}
 */
function _setMediaKeys(elt, mediaKeys) {
    if (mediaKeys instanceof MediaKeys_1.MockMediaKeys) {
        return mediaKeys._setVideo(elt);
    }
    if (elt.setMediaKeys) {
        return elt.setMediaKeys(mediaKeys);
    }
    if (mediaKeys === null) {
        return;
    }
    if (elt.WebkitSetMediaKeys) {
        return elt.WebkitSetMediaKeys(mediaKeys);
    }
    if (elt.mozSetMediaKeys) {
        return elt.mozSetMediaKeys(mediaKeys);
    }
    if (elt.msSetMediaKeys) {
        return elt.msSetMediaKeys(mediaKeys);
    }
}
/**
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */
exports.default = function (elt, mediaKeys) {
    return Observable_1.Observable.defer(function () {
        return castToObservable_1.default(_setMediaKeys(elt, mediaKeys));
    });
};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var exported = {};
/* tslint:disable no-var-requires */
if (true) {
    exported.smooth = __webpack_require__(235).default;
}
if (true) {
    exported.dash = __webpack_require__(245).default;
}
if (true) {
    exported.directfile = __webpack_require__(251).default;
}
exports.default = exported;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(2);
var request_1 = __webpack_require__(29);
var strings_1 = __webpack_require__(85);
var url_1 = __webpack_require__(23);
var bif_1 = __webpack_require__(86);
var isobmff_timings_infos_1 = __webpack_require__(240);
var mp4_1 = __webpack_require__(49);
var parser_1 = __webpack_require__(241);
var segment_loader_1 = __webpack_require__(244);
var utils_1 = __webpack_require__(87);
var patchSegment = mp4_1.default.patchSegment, getMdat = mp4_1.default.getMdat;
var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(adaptation, dlSegment, nextSegments) {
    var representations = adaptation.representations;
    for (var i = 0; i < representations.length; i++) {
        var representation = representations[i];
        if (dlSegment.duration != null &&
            dlSegment.timescale != null) {
            // TODO TypeScript bug?
            representation.index._addSegments(nextSegments, dlSegment);
        }
    }
}
function default_1(options) {
    if (options === void 0) { options = {}; }
    var smoothManifestParser = parser_1.default(options);
    var segmentLoader = segment_loader_1.default(options.segmentLoader);
    var manifestPipeline = {
        resolver: function (_a) {
            var url = _a.url;
            var resolving;
            var token = utils_1.extractToken(url);
            // TODO Remove WSX logic
            if (WSX_REG.test(url)) {
                resolving = request_1.default({
                    url: utils_1.replaceToken(url, ""),
                    responseType: "document",
                    ignoreProgressEvents: true,
                })
                    .map(function (_a) {
                    var value = _a.value;
                    var extractedURL = utils_1.extractISML(value.responseData);
                    if (!extractedURL) {
                        throw new Error("Invalid ISML");
                    }
                    return extractedURL;
                });
            }
            else {
                resolving = Observable_1.Observable.of(url);
            }
            return resolving
                .map(function (_url) { return ({ url: utils_1.replaceToken(utils_1.resolveManifest(_url), token) }); });
        },
        loader: function (_a) {
            var url = _a.url;
            return request_1.default({
                url: url,
                responseType: "document",
                ignoreProgressEvents: true,
            });
        },
        parser: function (_a) {
            var response = _a.response;
            var manifest = smoothManifestParser(response.responseData);
            return Observable_1.Observable.of({ manifest: manifest, url: response.url });
        },
    };
    var segmentPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest, init = _a.init;
            return segmentLoader({
                segment: segment,
                representation: representation,
                adaptation: adaptation,
                manifest: manifest,
                init: init,
            });
        },
        parser: function (_a) {
            var segment = _a.segment, response = _a.response, adaptation = _a.adaptation, manifest = _a.manifest;
            var responseData = response.responseData;
            if (segment.isInit) {
                // smooth init segments are crafted by hand. Their timescale is the one
                // from the manifest.
                var initSegmentInfos = {
                    timescale: segment.timescale,
                    time: -1,
                    duration: 0,
                };
                return Observable_1.Observable.of({
                    segmentData: responseData,
                    segmentInfos: initSegmentInfos,
                });
            }
            if (false) {
                assert_1.default(responseData instanceof ArrayBuffer);
            }
            var responseBuffer = new Uint8Array(responseData);
            var _b = isobmff_timings_infos_1.default(responseBuffer, segment, manifest.isLive), nextSegments = _b.nextSegments, segmentInfos = _b.segmentInfos;
            var segmentData = patchSegment(responseBuffer, segmentInfos.time);
            if (nextSegments) {
                addNextSegments(adaptation, segmentInfos, nextSegments);
            }
            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
        },
    };
    var textTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            if (segment.isInit) {
                return Observable_1.Observable.empty();
            }
            var mimeType = representation.mimeType;
            var base = url_1.resolveURL(representation.baseURL);
            var url = utils_1.buildSegmentURL(base, representation, segment);
            return request_1.default({
                url: url,
                responseType: (mimeType && mimeType.indexOf("mp4") >= 0) ?
                    "arraybuffer" : "text",
            });
        },
        parser: function (_a) {
            var response = _a.response, segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest;
            var language = adaptation.language;
            var _b = representation.mimeType, mimeType = _b === void 0 ? "" : _b, _c = representation.codec, codec = _c === void 0 ? "" : _c;
            if (false) {
                assert_1.default(typeof response.responseData === "string" ||
                    response.responseData instanceof ArrayBuffer);
            }
            var responseData = response.responseData;
            var parsedResponse;
            var nextSegments;
            var segmentInfos;
            var isMP4 = mimeType.indexOf("mp4") >= 0;
            // segmentData components
            var _sdStart;
            var _sdEnd;
            var _sdTimescale;
            var _sdData;
            var _sdType;
            if (isMP4) {
                if (false) {
                    assert_1.default(responseData instanceof ArrayBuffer);
                }
                parsedResponse = new Uint8Array(responseData);
                var timings = isobmff_timings_infos_1.default(parsedResponse, segment, manifest.isLive);
                nextSegments = timings.nextSegments;
                segmentInfos = timings.segmentInfos;
                _sdStart = segmentInfos.time;
                _sdEnd = segmentInfos.duration != null ?
                    segmentInfos.time + segmentInfos.duration : undefined;
                if (false) {
                    assert_1.default(typeof segmentInfos.timescale === "number");
                }
                _sdTimescale = segmentInfos.timescale;
            }
            else {
                if (false) {
                    assert_1.default(typeof responseData === "string");
                }
                parsedResponse = responseData;
                var segmentTime = segment.time || 0;
                // vod is simple WebVTT or TTML text
                _sdStart = segmentTime;
                _sdEnd = segment.duration != null ?
                    segmentTime + segment.duration : undefined;
                _sdTimescale = segment.timescale;
            }
            if (isMP4) {
                var lcCodec = codec.toLowerCase();
                if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp") {
                    _sdType = "ttml";
                }
                else if (lcCodec === "wvtt") {
                    _sdType = "vtt";
                }
                else {
                    throw new Error("could not find a text-track parser for the type " + mimeType);
                }
                var mdat = getMdat(parsedResponse);
                _sdData = strings_1.stringFromUTF8(mdat);
            }
            else {
                switch (mimeType) {
                    case "application/x-sami":
                    case "application/smil":// TODO SMIL should be its own format, no?
                        _sdType = "sami";
                        break;
                    case "application/ttml+xml":
                        _sdType = "ttml";
                        break;
                    case "text/vtt":
                        _sdType = "vtt";
                        break;
                }
                if (!_sdType) {
                    var lcCodec = codec.toLowerCase();
                    if (lcCodec === "srt") {
                        _sdType = "srt";
                    }
                    else {
                        throw new Error("could not find a text-track parser for the type " + mimeType);
                    }
                }
                _sdData = responseData;
            }
            if (segmentInfos != null && nextSegments) {
                addNextSegments(adaptation, segmentInfos, nextSegments);
            }
            return Observable_1.Observable.of({
                segmentData: {
                    type: _sdType,
                    data: _sdData,
                    language: language,
                    timescale: _sdTimescale,
                    start: _sdStart,
                    end: _sdEnd,
                    timeOffset: _sdStart / _sdTimescale,
                },
                segmentInfos: segmentInfos,
            });
        },
    };
    var imageTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            if (segment.isInit) {
                return Observable_1.Observable.empty();
            }
            else {
                var baseURL = url_1.resolveURL(representation.baseURL);
                var url = utils_1.buildSegmentURL(baseURL, representation, segment);
                return request_1.default({
                    url: url,
                    responseType: "arraybuffer",
                });
            }
        },
        parser: function (_a) {
            var response = _a.response;
            var responseData = response.responseData;
            var blob = new Uint8Array(responseData);
            var bif = bif_1.default(blob);
            var segmentData = bif.thumbs;
            var segmentInfos = {
                time: 0,
                duration: Number.MAX_VALUE,
                timescale: bif.timescale,
            };
            // var firstThumb = blob[0];
            // var lastThumb  = blob[blob.length - 1];
            // segmentInfos = {
            //   time: firstThumb.ts,
            //   duration: lastThumb.ts
            // };
            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
        },
    };
    return {
        manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline,
    };
}
exports.default = default_1;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(22);
var errorMessage_1 = __webpack_require__(27);
/**
 * @class IndexError
 * @extends Error
 */
var IndexError = /** @class */ (function (_super) {
    __extends(IndexError, _super);
    function IndexError(code, indexType, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, IndexError.prototype);
        _this.name = "IndexError";
        _this.type = constants_1.ErrorTypes.INDEX_ERROR;
        _this.indexType = indexType;
        _this.reason = null;
        _this.code = constants_1.ErrorCodes[code];
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, null);
        return _this;
    }
    return IndexError;
}(Error));
exports.default = IndexError;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// TODO https://stackoverflow.com/questions/41102060/typescript-extending-error-class
var constants_1 = __webpack_require__(22);
var errorMessage_1 = __webpack_require__(27);
/**
 * @class OtherError
 * @extends Error
 */
var OtherError = /** @class */ (function (_super) {
    __extends(OtherError, _super);
    function OtherError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, OtherError.prototype);
        _this.name = "OtherError";
        _this.type = constants_1.ErrorTypes.OTHER_ERROR;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes[code];
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    return OtherError;
}(Error));
exports.default = OtherError;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(22);
var errorMessage_1 = __webpack_require__(27);
/**
 * @class NetworkError
 * @extends Error
 */
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    function NetworkError(code, reason, fatal) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, NetworkError.prototype);
        _this.name = "NetworkError";
        _this.type = constants_1.ErrorTypes.NETWORK_ERROR;
        _this.xhr = reason.xhr;
        _this.url = reason.url;
        _this.status = reason.status;
        _this.errorType = reason.type;
        _this.reason = reason;
        _this.code = constants_1.ErrorCodes[code];
        _this.fatal = !!fatal;
        _this.message = errorMessage_1.default(_this.name, _this.code, _this.reason);
        return _this;
    }
    /**
     * Returns true if the NetworkError is due to the given http error code
     * @param {number} httpErrorCode
     * @returns {Boolean}
     */
    NetworkError.prototype.isHttpError = function (httpErrorCode) {
        return (this.errorType === constants_1.RequestErrorTypes.ERROR_HTTP_CODE &&
            this.status === httpErrorCode);
    };
    return NetworkError;
}(Error));
exports.default = NetworkError;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class RequestError
 * @extends Error
 */
var RequestError = /** @class */ (function (_super) {
    __extends(RequestError, _super);
    function RequestError(xhr, url, type) {
        var _this = _super.call(this) || this;
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(_this, RequestError.prototype);
        _this.name = "RequestError";
        _this.url = url;
        _this.xhr = xhr;
        _this.status = xhr.status;
        _this.type = type;
        _this.message = type;
        return _this;
    }
    return RequestError;
}(Error));
exports.default = RequestError;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var isobmff_1 = __webpack_require__(33);
var mp4_1 = __webpack_require__(49);
var getTraf = mp4_1.default.getTraf, parseTfrf = mp4_1.default.parseTfrf, parseTfxd = mp4_1.default.parseTfxd;
function extractTimingsInfos(responseData, segment, isLive) {
    var nextSegments = [];
    var segmentInfos;
    var tfxdSegment;
    var tfrfSegments;
    if (isLive) {
        var traf = getTraf(responseData);
        if (traf) {
            tfrfSegments = parseTfrf(traf);
            tfxdSegment = parseTfxd(traf);
        }
        else {
            log_1.default.warn("smooth: could not find traf atom");
        }
    }
    if (!tfxdSegment) {
        // we could always make a mistake when reading a container.
        // If the estimate is too far from what the segment seems to imply, take
        // the segment infos instead.
        var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration != null ? segment.duration / 4 : 0.25);
        var trunDuration = isobmff_1.getDurationFromTrun(responseData);
        if (trunDuration >= 0 && (segment.duration == null ||
            Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {
            segmentInfos = {
                time: segment.time,
                duration: trunDuration,
                timescale: segment.timescale,
            };
        }
        else {
            segmentInfos = {
                time: segment.time,
                duration: segment.duration,
                timescale: segment.timescale,
            };
        }
    }
    else {
        segmentInfos = {
            time: tfxdSegment.time,
            duration: tfxdSegment.duration,
            timescale: segment.timescale,
        };
    }
    if (tfrfSegments) {
        for (var i = 0; i < tfrfSegments.length; i++) {
            nextSegments.push({
                time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: segment.timescale,
            });
        }
    }
    return { nextSegments: nextSegments, segmentInfos: segmentInfos };
}
exports.default = extractTimingsInfos;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var array_includes_1 = __webpack_require__(9);
var assert_1 = __webpack_require__(2);
var bytes_1 = __webpack_require__(28);
var languages_1 = __webpack_require__(34);
var DEFAULT_MIME_TYPES = {
    audio: "audio/mp4",
    video: "video/mp4",
    text: "application/ttml+xml",
};
var DEFAULT_CODECS = {
    audio: "mp4a.40.2",
    video: "avc1.4D401E",
};
var MIME_TYPES = {
    AACL: "audio/mp4",
    AVC1: "video/mp4",
    H264: "video/mp4",
    TTML: "application/ttml+xml+mp4",
};
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */
function extractVideoCodecs(codecPrivateData) {
    // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
    var _a = /00000001\d7([0-9a-fA-F]{6})/
        .exec(codecPrivateData) || [], _b = _a[1], avcProfile = _b === void 0 ? "" : _b;
    return avcProfile && "avc1." + avcProfile;
}
/**
 * @param {string} fourCC
 * @param {string} codecPrivateData
 * @returns {string}
 */
function extractAudioCodecs(fourCC, codecPrivateData) {
    var mpProfile;
    if (fourCC === "AACH") {
        mpProfile = 5; // High Efficiency AAC Profile
    }
    else {
        mpProfile = codecPrivateData ?
            (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3 : 2;
    }
    return mpProfile ? ("mp4a.40." + mpProfile) : "";
}
/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
    if (typeof val === "boolean") {
        return val;
    }
    else if (typeof val === "string") {
        return val.toUpperCase() === "TRUE";
    }
    else {
        return false;
    }
}
/**
 * @param {Object} adaptation
 * @returns {Number}
 */
function calcLastRef(adaptation) {
    if (!adaptation) {
        return Infinity;
    }
    var index = adaptation.index;
    var _a = index.timeline[index.timeline.length - 1], ts = _a.ts, r = _a.r, d = _a.d;
    return ((ts + (r + 1) * (d ? d : 0)) / index.timescale);
}
/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */
function getKeySystems(keyIdBytes) {
    return [
        {
            // Widevine
            systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
            privateData: bytes_1.concat([0x08, 0x01, 0x12, 0x10], keyIdBytes),
        },
    ];
}
/**
 * @param {Object} [parserOptions={}]
 */
function createSmoothStreamingParser(parserOptions) {
    if (parserOptions === void 0) { parserOptions = {}; }
    var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay == null ?
        config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH :
        parserOptions.suggestedPresentationDelay;
    var REFERENCE_DATE_TIME = parserOptions.referenceDateTime ||
        Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000;
    var MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate ||
        190000;
    var keySystems = parserOptions.keySystems || getKeySystems;
    /**
     * @param {Uint8Array} buf
     * @returns {string}
     */
    function getHexKeyId(buf) {
        var len = bytes_1.le2toi(buf, 8);
        var xml = bytes_1.bytesToUTF16Str(buf.subarray(10, len + 10));
        var doc = new DOMParser().parseFromString(xml, "application/xml");
        var kidElement = doc.querySelector("KID");
        if (!kidElement) {
            throw new Error("invalid XML");
        }
        var kid = kidElement.textContent || "";
        return bytes_1.guidToUuid(atob(kid)).toLowerCase();
    }
    /**
     * Reduce implementation for the children of the given element.
     * TODO better typings
     * @param {Element} root
     * @param {Function} fn
     * @param {*} init
     * @returns {*}
     */
    function reduceChildren(root, fn, init) {
        var node = root.firstElementChild;
        var r = init;
        while (node) {
            r = fn(r, node.nodeName, node);
            node = node.nextElementSibling;
        }
        return r;
    }
    /**
     * @param {Element} root
     * @returns {Object}
     */
    function parseProtection(root) {
        var header = root.firstElementChild;
        assert_1.default.equal(header.nodeName, "ProtectionHeader", "Protection should have ProtectionHeader child");
        var privateData = bytes_1.strToBytes(atob(header.textContent || ""));
        var keyId = getHexKeyId(privateData);
        var keyIdBytes = bytes_1.hexToBytes(keyId);
        // remove possible braces
        var systemId = (header.getAttribute("SystemID") || "").toLowerCase()
            .replace(/\{|\}/g, "");
        return {
            keyId: keyId,
            keySystems: [
                {
                    systemId: systemId,
                    privateData: privateData,
                },
            ].concat(keySystems(keyIdBytes)),
        };
    }
    /**
     * @param {Element} node
     * @param {Array.<Object>} timeline
     * @returns {Array.<Object>}
     */
    function parseC(node, timeline) {
        var len = timeline.length;
        var prev = len > 0 ?
            timeline[len - 1] : { d: 0, ts: 0, r: 0 };
        var dAttr = node.getAttribute("d");
        var tAttr = node.getAttribute("t");
        var rAttr = node.getAttribute("r");
        // in smooth streaming format,
        // r refers to number of same duration
        // chunks, not repetitions (defers from DASH)
        var r = rAttr ? +rAttr - 1 : 0;
        var t = tAttr ? +tAttr : undefined;
        var d = dAttr ? +dAttr : undefined;
        if (len > 0 && !prev.d) {
            if (false) {
                assert_1.default(typeof t === "number");
            }
            prev.d = t != null ? t - prev.ts : 0;
            timeline[len - 1] = prev; // TODO might not be needed
        }
        // if same segment than the last one, repeat the previous one
        if (len > 0 && d === prev.d && t == null) {
            prev.r += (r || 0) + 1;
        }
        else {
            if (false) {
                assert_1.default(t != null || prev.d != null);
            }
            var ts = (t == null)
                ? prev.ts + (prev.d || 0) * (prev.r + 1)
                : t;
            timeline.push({ d: d, ts: ts, r: r });
        }
        return timeline;
    }
    /**
     * @param {Element} q
     * @param {string} type
     * @return {Object}
     */
    function parseQualityLevel(q, type) {
        /**
         * @param {string} name
         * @returns {string|undefined}
         */
        function getAttribute(name) {
            var attr = q.getAttribute(name);
            return attr == null ? undefined : attr;
        }
        switch (type) {
            case "audio": {
                var audiotag = getAttribute("AudioTag");
                var bitrate = getAttribute("Bitrate");
                var bitsPerSample = getAttribute("BitsPerSample");
                var channels = getAttribute("Channels");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                var packetSize = getAttribute("PacketSize");
                var samplingRate = getAttribute("SamplingRate");
                return {
                    audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    bitsPerSample: bitsPerSample !== undefined ?
                        parseInt(bitsPerSample, 10) : bitsPerSample,
                    channels: channels !== undefined ? parseInt(channels, 10) : channels,
                    codecPrivateData: codecPrivateData || "",
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    packetSize: packetSize !== undefined ?
                        parseInt(packetSize, 10) : packetSize,
                    samplingRate: samplingRate !== undefined ?
                        parseInt(samplingRate, 10) : samplingRate,
                };
            }
            case "video": {
                var bitrate = getAttribute("Bitrate");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                var width = getAttribute("MaxWidth");
                var height = getAttribute("MaxHeight");
                return {
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    codecPrivateData: codecPrivateData || "",
                    codecs: extractVideoCodecs(codecPrivateData || ""),
                    width: width !== undefined ? parseInt(width, 10) : undefined,
                    height: height !== undefined ? parseInt(height, 10) : undefined,
                };
            }
            case "text": {
                var bitrate = getAttribute("Bitrate");
                var codecPrivateData = getAttribute("CodecPrivateData");
                var fourCC = getAttribute("FourCC");
                return {
                    bitrate: bitrate ? parseInt(bitrate, 10) || 0 : 0,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    codecPrivateData: codecPrivateData || "",
                };
            }
            default:
                throw new Error("Unrecognized StreamIndex type: " + type);
        }
    }
    /**
     * Parse the adaptations (<StreamIndex>) tree containing
     * representations (<QualityLevels>) and timestamp indexes (<c>).
     * Indexes can be quite huge, and this function needs to
     * to be optimized.
     * @param {Element} root
     * @param {Number} timescale
     * @returns {Object}
     */
    function parseAdaptation(root, timescale) {
        var _timescale = root.hasAttribute("Timescale") ?
            +(root.getAttribute("Timescale") || 0) : timescale;
        var type = root.getAttribute("Type");
        if (type == null) {
            throw new Error("StreamIndex without type.");
        }
        var subType = root.getAttribute("Subtype");
        var name = root.getAttribute("Name");
        var language = root.getAttribute("Language");
        var normalizedLanguage = language == null ?
            language : languages_1.normalize(language);
        var baseURL = root.getAttribute("Url");
        var accessibility = [];
        var representationCount = 0;
        var _a = reduceChildren(root, function (res, _name, node) {
            switch (_name) {
                case "QualityLevel":
                    var rep = parseQualityLevel(node, type);
                    if (type === "audio") {
                        var fourCC = node.getAttribute("FourCC") || "";
                        rep.codecs = extractAudioCodecs(fourCC, rep.codecPrivateData);
                    }
                    // filter out video representations with small bitrates
                    if (type !== "video" || rep.bitrate > MIN_REPRESENTATION_BITRATE) {
                        rep.id = representationCount++;
                        res.representations.push(rep);
                    }
                    break;
                case "c":
                    res.index.timeline = parseC(node, res.index.timeline);
                    break;
            }
            return res;
        }, {
            representations: [],
            index: {
                timeline: [],
                indexType: "smooth",
                timescale: _timescale,
                initialization: {},
            },
        }), representations = _a.representations, index = _a.index;
        // we assume that all representations have the same
        // codec and mimeType
        assert_1.default(representations.length, "adaptation should have at least one representation");
        // apply default codec if non-supported
        representations.forEach(function (rep) {
            return rep.codecs = rep.codecs || DEFAULT_CODECS[type];
        });
        // apply default mimetype if non-supported
        representations.forEach(function (rep) {
            return rep.mimeType = rep.mimeType || DEFAULT_MIME_TYPES[type];
        });
        // TODO(pierre): real ad-insert support
        if (subType === "ADVT") {
            return null;
        }
        else if (type === "text" && subType === "DESC") {
            accessibility.push("hardOfHearing");
        }
        // TODO check that one, I did not find it in the spec
        // else if (type === "audio" && subType === "DESC") {
        //   accessibility.push("visuallyImpaired");
        // }
        return {
            type: type,
            accessibility: accessibility,
            index: index,
            representations: representations,
            name: name,
            language: language,
            normalizedLanguage: normalizedLanguage,
            baseURL: baseURL,
        };
    }
    function parseFromString(manifest) {
        return parseFromDocument(new DOMParser().parseFromString(manifest, "application/xml"));
    }
    function parseFromDocument(doc) {
        var root = doc.documentElement;
        assert_1.default.equal(root.nodeName, "SmoothStreamingMedia", "document root should be SmoothStreamingMedia");
        assert_1.default(/^[2]-[0-2]$/
            .test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion")), "Version should be 2.0, 2.1 or 2.2");
        var timescale = +(root.getAttribute("Timescale") || 10000000);
        var adaptationIds = [];
        var _a = reduceChildren(root, function (res, name, node) {
            switch (name) {
                case "Protection": {
                    res.protection = parseProtection(node);
                    break;
                }
                case "StreamIndex":
                    var ada = parseAdaptation(node, timescale);
                    if (ada) {
                        var i = 0;
                        var id = void 0;
                        do {
                            id = ada.type + "_" +
                                (ada.language ? (ada.language + "_") : "") + i++;
                        } while (array_includes_1.default(adaptationIds, id));
                        ada.id = id;
                        adaptationIds.push(id);
                        res.adaptations.push(ada);
                    }
                    break;
            }
            return res;
        }, {
            protection: null,
            adaptations: [],
        }), protection = _a.protection, adaptations = _a.adaptations;
        adaptations.forEach(function (a) { return a.smoothProtection = protection; });
        var suggestedPresentationDelay;
        var presentationLiveGap;
        var timeShiftBufferDepth;
        var availabilityStartTime;
        var isLive = parseBoolean(root.getAttribute("IsLive"));
        if (isLive) {
            suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY;
            timeShiftBufferDepth =
                +(root.getAttribute("DVRWindowLength") || 0) / timescale;
            availabilityStartTime = REFERENCE_DATE_TIME;
            var video = adaptations.filter(function (a) { return a.type === "video"; })[0];
            var audio = adaptations.filter(function (a) { return a.type === "audio"; })[0];
            var lastRef = Math.min(calcLastRef(video), calcLastRef(audio));
            presentationLiveGap = Date.now() / 1000 -
                (lastRef + availabilityStartTime);
        }
        return {
            transportType: "smooth",
            profiles: "",
            type: isLive ? "dynamic" : "static",
            suggestedPresentationDelay: suggestedPresentationDelay,
            timeShiftBufferDepth: timeShiftBufferDepth,
            presentationLiveGap: presentationLiveGap,
            availabilityStartTime: availabilityStartTime,
            periods: [{
                    duration: +(root.getAttribute("Duration") || Infinity) / timescale,
                    adaptations: adaptations,
                    laFragCount: +(root.getAttribute("LookAheadFragmentCount") || 0),
                }],
        };
    }
    var parser = function (val) {
        if (typeof val === "string") {
            return parseFromString(val);
        }
        else {
            return parseFromDocument(val);
        }
    };
    parser.parseFromString = parseFromString;
    parser.parseFromDocument = parseFromDocument;
    return parser;
}
exports.default = createSmoothStreamingParser;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
var ISO_MAP_1_TO_3 = {
    aa: "aar",
    ab: "abk",
    ae: "ave",
    af: "afr",
    ak: "aka",
    am: "amh",
    an: "arg",
    ar: "ara",
    as: "asm",
    av: "ava",
    ay: "aym",
    az: "aze",
    ba: "bak",
    be: "bel",
    bg: "bul",
    bi: "bis",
    bm: "bam",
    bn: "ben",
    bo: "bod",
    br: "bre",
    bs: "bos",
    ca: "cat",
    ce: "che",
    ch: "cha",
    co: "cos",
    cr: "cre",
    cs: "ces",
    cu: "chu",
    // Old Slavonic, Old Bulgarian
    cv: "chv",
    cy: "cym",
    da: "dan",
    de: "deu",
    dv: "div",
    dz: "dzo",
    ee: "ewe",
    el: "ell",
    en: "eng",
    eo: "epo",
    es: "spa",
    et: "est",
    eu: "eus",
    fa: "fas",
    ff: "ful",
    fi: "fin",
    fj: "fij",
    fo: "fao",
    fr: "fra",
    fy: "fry",
    ga: "gle",
    gd: "gla",
    gl: "glg",
    gn: "grn",
    gu: "guj",
    gv: "glv",
    ha: "hau",
    he: "heb",
    hi: "hin",
    ho: "hmo",
    hr: "hrv",
    ht: "hat",
    hu: "hun",
    hy: "hye",
    hz: "her",
    ia: "ina",
    id: "ind",
    ie: "ile",
    ig: "ibo",
    ii: "iii",
    ik: "ipk",
    io: "ido",
    is: "isl",
    it: "ita",
    iu: "iku",
    ja: "jpn",
    jv: "jav",
    ka: "kat",
    kg: "kon",
    ki: "kik",
    kj: "kua",
    kk: "kaz",
    kl: "kal",
    km: "khm",
    kn: "kan",
    ko: "kor",
    kr: "kau",
    ks: "kas",
    ku: "kur",
    kv: "kom",
    kw: "cor",
    ky: "kir",
    la: "lat",
    lb: "ltz",
    lg: "lug",
    li: "lim",
    ln: "lin",
    lo: "lao",
    lt: "lit",
    lu: "lub",
    lv: "lav",
    mg: "mlg",
    mh: "mah",
    mi: "mri",
    mk: "mkd",
    ml: "mal",
    mn: "mon",
    mr: "mar",
    ms: "msa",
    mt: "mlt",
    my: "mya",
    na: "nau",
    nb: "nob",
    nd: "nde",
    ne: "nep",
    ng: "ndo",
    nl: "nld",
    nn: "nno",
    no: "nor",
    nr: "nbl",
    nv: "nav",
    ny: "nya",
    oc: "oci",
    oj: "oji",
    om: "orm",
    or: "ori",
    os: "oss",
    pa: "pan",
    pi: "pli",
    pl: "pol",
    ps: "pus",
    pt: "por",
    qu: "que",
    rm: "roh",
    rn: "run",
    ro: "ron",
    ru: "rus",
    rw: "kin",
    sa: "san",
    sc: "srd",
    sd: "snd",
    se: "sme",
    sg: "sag",
    si: "sin",
    sk: "slk",
    sl: "slv",
    sm: "smo",
    sn: "sna",
    so: "som",
    sq: "sqi",
    sr: "srp",
    ss: "ssw",
    st: "sot",
    su: "sun",
    sv: "swe",
    sw: "swa",
    ta: "tam",
    te: "tel",
    tg: "tgk",
    th: "tha",
    ti: "tir",
    tk: "tuk",
    tl: "tgl",
    tn: "tsn",
    to: "ton",
    tr: "tur",
    ts: "tso",
    tt: "tat",
    tw: "twi",
    ty: "tah",
    ug: "uig",
    uk: "ukr",
    ur: "urd",
    uz: "uzb",
    ve: "ven",
    vi: "vie",
    vo: "vol",
    wa: "wln",
    wo: "wol",
    xh: "xho",
    yi: "yid",
    yo: "yor",
    za: "zha",
    zh: "zho",
    zu: "zul",
};
exports.default = ISO_MAP_1_TO_3;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
var ISO_MAP_2_TO_3 = {
    alb: "sqi",
    arm: "hye",
    baq: "eus",
    bur: "mya",
    chi: "zho",
    cze: "ces",
    dut: "nld",
    fre: "fra",
    geo: "kat",
    ger: "deu",
    gre: "ell",
    ice: "isl",
    mac: "mkd",
    mao: "mri",
    may: "msa",
    per: "fas",
    slo: "slk",
    rum: "ron",
    tib: "bod",
    wel: "cym",
};
exports.default = ISO_MAP_2_TO_3;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(2);
var request_1 = __webpack_require__(29);
var url_1 = __webpack_require__(23);
var mp4_1 = __webpack_require__(49);
var utils_1 = __webpack_require__(87);
var createVideoInitSegment = mp4_1.default.createVideoInitSegment, createAudioInitSegment = mp4_1.default.createAudioInitSegment;
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @param {string} opt.url
 * @param {Segment} opt.segment
 * @returns {Observable}
 */
function regularSegmentLoader(_a) {
    var url = _a.url, segment = _a.segment;
    var headers;
    var range = segment.range;
    if (range) {
        headers = {
            Range: utils_1.byteRange(range),
        };
    }
    return request_1.default({
        url: url,
        responseType: "arraybuffer",
        headers: headers,
    });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */
var generateSegmentLoader = function (customSegmentLoader) { return function (_a) {
    var segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest, init = _a.init;
    if (segment.isInit) {
        if (representation._codecPrivateData == null) {
            throw new Error("Invalid request: A smooth init segment should have CodecPrivateData");
        }
        var responseData = void 0;
        var protection = adaptation._smoothProtection;
        switch (adaptation.type) {
            case "video":
                responseData = createVideoInitSegment(segment.timescale, representation.width || 0, representation.height || 0, 72, 72, 4, // vRes, hRes, nal
                representation._codecPrivateData, protection && protection.keyId, // keyId
                protection && protection.keySystems // pssList
                );
                break;
            case "audio":
                responseData = createAudioInitSegment(segment.timescale, 
                // TODO See if this should already be defined in the Smooth manifest
                representation._channels || 0, representation._bitsPerSample || 0, representation._packetSize || 0, representation._samplingRate || 0, representation._codecPrivateData, protection && protection.keyId, // keyId
                protection && protection.keySystems // pssList
                );
                break;
            default:
                if (false) {
                    assert_1.default(false, "responseData should have been set");
                }
                responseData = new Uint8Array(0);
        }
        return Observable_1.Observable.of({
            type: "data",
            value: { responseData: responseData },
        });
    }
    else {
        var url = utils_1.buildSegmentURL(url_1.resolveURL(representation.baseURL), representation, segment);
        var args_1 = {
            adaptation: adaptation,
            representation: representation,
            segment: segment,
            transport: "smooth",
            url: url,
            manifest: manifest,
            init: init,
        };
        if (!customSegmentLoader) {
            return regularSegmentLoader(args_1);
        }
        return Observable_1.Observable.create(function (obs) {
            var hasFinished = false;
            var hasFallbacked = false;
            var resolve = function (_args) {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.next({
                        type: "response",
                        value: {
                            responseData: _args.data,
                            size: _args.size,
                            duration: _args.duration,
                        },
                    });
                    obs.complete();
                }
            };
            var reject = function (err) {
                if (err === void 0) { err = {}; }
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.error(err);
                }
            };
            var fallback = function () {
                hasFallbacked = true;
                regularSegmentLoader(args_1).subscribe(obs);
            };
            var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
            var abort = customSegmentLoader(args_1, callbacks);
            return function () {
                if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                    abort();
                }
            };
        });
    }
}; };
exports.default = generateSegmentLoader;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var request_1 = __webpack_require__(29);
var url_1 = __webpack_require__(23);
var isobmff_1 = __webpack_require__(33);
var bif_1 = __webpack_require__(86);
var isobmff_timing_infos_1 = __webpack_require__(88);
var manifest_1 = __webpack_require__(246);
var segment_loader_1 = __webpack_require__(249);
var texttracks_1 = __webpack_require__(250);
var utils_1 = __webpack_require__(50);
/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @param {Function} [options.contentProtectionParser] - Optional parser for the
 * manifest's content Protection.
 * @returns {Object}
 */
function default_1(options) {
    if (options === void 0) { options = {}; }
    var segmentLoader = segment_loader_1.default(options.segmentLoader);
    var contentProtectionParser = options.contentProtectionParser;
    var manifestPipeline = {
        loader: function (_a) {
            var url = _a.url;
            return request_1.default({
                url: url,
                responseType: "document",
            });
        },
        parser: function (_a) {
            var response = _a.response;
            var data = response.responseData;
            return Observable_1.Observable.of({
                manifest: manifest_1.default(data, contentProtectionParser),
                url: response.url,
            });
        },
    };
    var segmentPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation, adaptation = _a.adaptation, manifest = _a.manifest, init = _a.init;
            return segmentLoader({
                segment: segment,
                representation: representation,
                adaptation: adaptation,
                manifest: manifest,
                init: init,
            });
        },
        parser: function (_a) {
            var segment = _a.segment, representation = _a.representation, response = _a.response, init = _a.init;
            var responseData = response.responseData instanceof Uint8Array
                ? response.responseData
                : new Uint8Array(response.responseData);
            var nextSegments;
            var segmentInfos;
            var segmentData = responseData;
            var indexRange = segment.indexRange;
            var sidxSegments = isobmff_1.parseSidx(responseData, indexRange ? indexRange[0] : 0);
            if (sidxSegments) {
                nextSegments = sidxSegments;
            }
            if (segment.isInit) {
                segmentInfos = { time: -1, duration: 0 };
                var timescale = isobmff_1.getMDHDTimescale(responseData);
                if (timescale > 0) {
                    segmentInfos.timescale = timescale;
                }
            }
            else {
                segmentInfos =
                    isobmff_timing_infos_1.default(segment, responseData, sidxSegments, init);
            }
            if (nextSegments) {
                utils_1.addNextSegments(representation, segmentInfos, nextSegments);
            }
            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
        },
    };
    var textTrackPipeline = {
        loader: texttracks_1.loader,
        parser: texttracks_1.parser,
    };
    var imageTrackPipeline = {
        loader: function (_a) {
            var segment = _a.segment, representation = _a.representation;
            var isInit = segment.isInit;
            if (isInit) {
                return Observable_1.Observable.empty();
            }
            else {
                var media = segment.media;
                var path = media ?
                    utils_1.replaceTokens(media, segment, representation) : "";
                var mediaUrl = url_1.resolveURL(representation.baseURL, path);
                return request_1.default({
                    url: mediaUrl,
                    responseType: "arraybuffer",
                });
            }
        },
        parser: function (_a) {
            var response = _a.response;
            var responseData = response.responseData;
            var blob = new Uint8Array(responseData);
            var bif = bif_1.default(blob);
            var segmentData = bif.thumbs;
            var segmentInfos = {
                time: 0,
                duration: Number.MAX_VALUE,
                timescale: bif.timescale,
            };
            // var firstThumb = blob[0];
            // var lastThumb  = blob[blob.length - 1];
            // segmentInfos = {
            //   time: firstThumb.ts,
            //   duration: lastThumb.ts
            // };
            return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
        },
    };
    return {
        manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline,
    };
}
exports.default = default_1;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var parsers_1 = __webpack_require__(247);
/**
 * @param {string|Document} manifest - Original manifest as returned by the
 * server. Either in string format, or in a Document Object format.
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
var parser = function (manifest, contentProtectionParser) {
    if (typeof manifest === "string") {
        return parseFromString(manifest, contentProtectionParser);
    }
    else {
        return parseFromDocument(manifest, contentProtectionParser);
    }
};
/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parseFromDocument(document, contentProtectionParser) {
    var root = document.documentElement;
    if (!root || root.nodeName !== "MPD") {
        throw new Error("document root should be MPD");
    }
    return parsers_1.parseMPD(root, contentProtectionParser);
}
exports.parseFromDocument = parseFromDocument;
/**
 * @param {string} manifest - manifest file in a string format
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parseFromString(manifest, contentProtectionParser) {
    return parseFromDocument(new DOMParser().parseFromString(manifest, "application/xml"), contentProtectionParser);
}
exports.parseFromString = parseFromString;
exports.default = parser;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var helpers_1 = __webpack_require__(89);
var attributes_1 = __webpack_require__(248);
function parseMPD(root, contentProtectionParser) {
    var mpd = helpers_1.reduceChildren(root, function (res, name, node) {
        switch (name) {
            case "BaseURL":
                res.baseURL = node.textContent;
                break;
            case "Location":
                if (!res.locations) {
                    res.locations = [];
                }
                res.locations.push(node.textContent);
                break;
            case "Period":
                res.periods.push(parsePeriod(node, contentProtectionParser));
                break;
        }
        return res;
    }, {
        transportType: "dash",
        periods: [],
        locations: [],
    });
    var parsedMpd = attributes_1.default(root, mpd);
    if (parsedMpd.type && /dynamic/.test(parsedMpd.type)) {
        // As adaptations can either be from DASH or SMOOTH in parsed mpd object,
        // we must type adaptations as IAdaptationDash.
        var adaptations = parsedMpd.periods[0].adaptations;
        var videoAdaptation = adaptations
            .filter(function (a) { return a.type === "video"; })[0];
        var lastRef = helpers_1.getLastLiveTimeReference(videoAdaptation);
        if (false) {
            assert_1.default(parsedMpd.availabilityStartTime);
        }
        if (parsedMpd.availabilityStartTime &&
            typeof parsedMpd.availabilityStartTime !== "number") {
            parsedMpd.availabilityStartTime =
                parsedMpd.availabilityStartTime.getTime() / 1000;
            parsedMpd.presentationLiveGap = lastRef != null ?
                Date.now() / 1000 - (lastRef + parsedMpd.availabilityStartTime) : 10;
        }
    }
    return parsedMpd;
}
exports.parseMPD = parseMPD;
/**
 * Parse a single manifest period.
 * @param {Document} root
 * @param {Function} contentProtectionParser
 * @returns {Object}
 */
function parsePeriod(root, contentProtectionParser) {
    var period = attributes_1.default(root, helpers_1.reduceChildren(root, function (res, name, node) {
        switch (name) {
            case "BaseURL":
                res.baseURL = node.textContent;
                break;
            case "AdaptationSet":
                var ada = parseAdaptationSet(node, contentProtectionParser);
                if (ada.id == null) {
                    ada.id = res.adaptations.length;
                }
                res.adaptations.push(ada);
                break;
        }
        return res;
    }, {
        id: null,
        adaptations: [],
    }));
    return period;
}
function parseAdaptationSet(root, contentProtectionParser) {
    var accessibility;
    var adapatationSet = helpers_1.reduceChildren(root, function (res, name, node) {
        switch (name) {
            // case "Rating": break;
            // case "Viewpoint": break;
            case "Accessibility":
                accessibility = parseAccessibility(node);
                break;
            case "BaseURL":
                res.baseURL = node.textContent;
                break;
            // TODO seems to be unused
            case "ContentComponent":
                res.contentComponent = parseContentComponent(node);
                break;
            // TODO seems to be unused
            case "ContentProtection":
                res.contentProtection =
                    parseContentProtection(node, contentProtectionParser);
                break;
            case "Representation":
                var rep = parseRepresentation(node);
                if (rep.id == null) {
                    rep.id = res.representations.length;
                }
                res.representations.push(rep);
                break;
            case "Role":
                res.role = parseRole(node);
                break;
            case "SegmentBase":
                res.index = parseSegmentBase(node);
                break;
            case "SegmentList":
                res.index = parseSegmentList(node);
                break;
            case "SegmentTemplate":
                res.index = parseSegmentTemplate(node);
                break;
        }
        return res;
    }, {
        index: null,
        id: null,
        representations: [],
        mimeType: null,
    });
    var parsedAdaptation = attributes_1.default(root, adapatationSet);
    parsedAdaptation.type = helpers_1.inferAdaptationType(parsedAdaptation);
    parsedAdaptation.accessibility = [];
    if (accessibility && helpers_1.isHardOfHearing(accessibility)) {
        parsedAdaptation.accessibility.push("hardOfHearing");
    }
    if (accessibility && helpers_1.isVisuallyImpaired(accessibility)) {
        parsedAdaptation.accessibility.push("visuallyImpaired");
    }
    // representations inherit some adaptation keys
    if (parsedAdaptation.representations) {
        parsedAdaptation.representations = parsedAdaptation.representations
            .map(function (representation) {
            if (parsedAdaptation.codecs && representation.codecs == null) {
                representation.codecs = parsedAdaptation.codecs;
            }
            if (parsedAdaptation.height && representation.height == null) {
                representation.height = parsedAdaptation.height;
            }
            if (parsedAdaptation.index && representation.index == null) {
                representation.index = parsedAdaptation.index;
            }
            if (parsedAdaptation.mimeType && representation.mimeType == null) {
                representation.mimeType = parsedAdaptation.mimeType;
            }
            if (parsedAdaptation.width && representation.width == null) {
                representation.width = parsedAdaptation.width;
            }
            return representation;
        });
    }
    return parsedAdaptation;
}
function parseRepresentation(root) {
    var representation = helpers_1.reduceChildren(root, function (res, name, node) {
        switch (name) {
            case "BaseURL":
                res.baseURL = node.textContent;
                break;
            case "SegmentBase":
                res.index = parseSegmentBase(node);
                break;
            case "SegmentList":
                res.index = parseSegmentList(node);
                break;
            case "SegmentTemplate":
                res.index = parseSegmentTemplate(node);
                break;
        }
        return res;
    }, {
        id: null,
        index: null,
        mimeType: null,
    });
    var parsedRep = attributes_1.default(root, representation);
    return parsedRep;
}
function parseRole(root) {
    return attributes_1.default(root);
}
function parseAccessibility(root) {
    return attributes_1.default(root);
}
function parseContentComponent(root) {
    return attributes_1.default(root);
}
function parseSegmentTemplate(root) {
    var base = parseMultipleSegmentBase(root);
    if (!base.indexType) {
        base.indexType = "template";
    }
    return base;
}
function parseSegmentList(root) {
    var base = parseMultipleSegmentBase(root);
    base.list = [];
    base.indexType = "list";
    return helpers_1.reduceChildren(root, function (res, name, node) {
        if (name === "SegmentURL") {
            res.list.push(attributes_1.default(node));
        }
        return res;
    }, base);
}
/**
 * Parse the contentProtection node of a MPD.
 * @param {Document} root
 * @param {Function} contentProtectionParser
 * @returns {Object}
 */
function parseContentProtection(root, contentProtectionParser) {
    if (contentProtectionParser) {
        return contentProtectionParser(attributes_1.default(root), root);
    }
}
function parseSegmentBase(root) {
    var index = helpers_1.reduceChildren(root, function (res, name, node) {
        if (name === "Initialization") {
            res.initialization = parseInitialization(node);
        }
        return res;
    }, attributes_1.default(root));
    if (root.nodeName === "SegmentBase") {
        index.indexType = "base";
        index.timeline = [];
    }
    return index;
}
function parseMultipleSegmentBase(root) {
    return helpers_1.reduceChildren(root, function (res, name, node) {
        if (name === "SegmentTimeline") {
            res.indexType = "timeline";
            res.timeline = parseSegmentTimeline(node);
        }
        return res;
    }, parseSegmentBase(root));
}
function parseSegmentTimeline(root) {
    return helpers_1.reduceChildren(root, function (arr, _name, node) {
        var len = arr.length;
        var seg = attributes_1.default(node);
        if (seg.ts == null) {
            var prev = (len > 0) && arr[len - 1];
            seg.ts = prev
                ? prev.ts + prev.d * (prev.r + 1)
                : 0;
        }
        if (seg.r == null) {
            seg.r = 0;
        }
        arr.push(seg);
        return arr;
    }, []);
}
function parseInitialization(root) {
    var range;
    var media;
    if (root.hasAttribute("range")) {
        range = helpers_1.parseByteRange(root.getAttribute("range"));
    }
    if (root.hasAttribute("sourceURL")) {
        media = root.getAttribute("sourceURL");
    }
    return { range: range, media: media };
}


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var assert_1 = __webpack_require__(2);
var languages_1 = __webpack_require__(34);
var helpers_1 = __webpack_require__(89);
/**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */
function parseInitializationAttribute(attrValue) {
    return { media: attrValue, range: undefined };
}
// @see attributes
var representationBaseType = [
    { k: "profiles", fn: helpers_1.parseString },
    { k: "width", fn: parseInt },
    { k: "height", fn: parseInt },
    { k: "frameRate", fn: helpers_1.parseFrameRate },
    { k: "audioSamplingRate", fn: helpers_1.parseString },
    { k: "mimeType", fn: helpers_1.parseString },
    { k: "segmentProfiles", fn: helpers_1.parseString },
    { k: "codecs", fn: helpers_1.parseString },
    { k: "maximumSAPPeriod", fn: parseFloat },
    { k: "maxPlayoutRate", fn: parseFloat },
    { k: "codingDependency", fn: helpers_1.parseBoolean },
];
// @see attributes
var segmentBaseType = [
    { k: "timescale", fn: parseInt, def: 1 },
    { k: "timeShiftBufferDepth", fn: helpers_1.parseDuration },
    { k: "presentationTimeOffset", fn: parseFloat, def: 0 },
    { k: "indexRange", fn: helpers_1.parseByteRange },
    { k: "indexRangeExact", fn: helpers_1.parseBoolean, def: false },
    { k: "availabilityTimeOffset", fn: parseFloat },
    { k: "availabilityTimeComplete", fn: helpers_1.parseBoolean, def: true },
];
// @see attributes
var multipleSegmentBaseType = segmentBaseType.concat([
    { k: "duration", fn: parseInt },
    { k: "startNumber", fn: parseInt },
]);
/**
 * Object describing how a Dash MPD should be parsed automatically.
 *
 * Basically, immediate keys are the nodeName concerned.
 * They contain array of Objects, each concerning a unique node attributes.
 *
 * The keys these Objects have are as such:
 *
 *   - k {string}: the name of the node attribute
 *
 *   - fn {Function}: the function called to parse this attribute. It takes
 *     as argument the attribute value and should return the parsed value.
 *
 *   - n {string}: new name used for the attribute in the parsed object.
 *
 *   - def {*}: the default value used if the attribute is not found in the
 *     MPD.
 */
var attributes = {
    ContentProtection: [
        { k: "schemeIdUri", fn: helpers_1.parseString },
        { k: "value", fn: helpers_1.parseString },
    ],
    SegmentURL: [
        { k: "media", fn: helpers_1.parseString },
        { k: "mediaRange", fn: helpers_1.parseByteRange },
        { k: "index", fn: helpers_1.parseString },
        { k: "indexRange", fn: helpers_1.parseByteRange },
    ],
    S: [
        { k: "t", fn: parseInt, n: "ts" },
        { k: "d", fn: parseInt },
        { k: "r", fn: parseInt },
    ],
    SegmentTimeline: [],
    SegmentBase: segmentBaseType,
    SegmentTemplate: multipleSegmentBaseType.concat([
        { k: "initialization", fn: parseInitializationAttribute },
        { k: "index", fn: helpers_1.parseString },
        { k: "media", fn: helpers_1.parseString },
        { k: "bitstreamSwitching", fn: helpers_1.parseString },
    ]),
    SegmentList: multipleSegmentBaseType,
    ContentComponent: [
        { k: "id", fn: helpers_1.parseString },
        { k: "lang", fn: helpers_1.parseString, n: "language" },
        { k: "lang", fn: languages_1.normalize, n: "normalizedLanguage" },
        { k: "contentType", fn: helpers_1.parseString },
        { k: "par", fn: helpers_1.parseRatio },
    ],
    Representation: representationBaseType.concat([
        { k: "id", fn: helpers_1.parseString },
        { k: "bandwidth", fn: parseInt, n: "bitrate" },
        { k: "qualityRanking", fn: parseInt },
    ]),
    AdaptationSet: representationBaseType.concat([
        { k: "id", fn: helpers_1.parseString },
        { k: "group", fn: parseInt },
        { k: "lang", fn: helpers_1.parseString, n: "language" },
        { k: "lang", fn: languages_1.normalize, n: "normalizedLanguage" },
        { k: "contentType", fn: helpers_1.parseString },
        { k: "par", fn: helpers_1.parseRatio },
        { k: "minBandwidth", fn: parseInt, n: "minBitrate" },
        { k: "maxBandwidth", fn: parseInt, n: "maxBitrate" },
        { k: "minWidth", fn: parseInt },
        { k: "maxWidth", fn: parseInt },
        { k: "minHeight", fn: parseInt },
        { k: "maxHeight", fn: parseInt },
        { k: "minFrameRate", fn: helpers_1.parseFrameRate },
        { k: "maxFrameRate", fn: helpers_1.parseFrameRate },
        { k: "segmentAlignment", fn: helpers_1.parseIntOrBoolean },
        { k: "subsegmentAlignment", fn: helpers_1.parseIntOrBoolean },
        { k: "bitstreamSwitching", fn: helpers_1.parseBoolean },
    ]),
    Period: [
        { k: "id", fn: helpers_1.parseString },
        { k: "start", fn: helpers_1.parseDuration },
        { k: "duration", fn: helpers_1.parseDuration },
        { k: "bitstreamSwitching", fn: helpers_1.parseBoolean },
    ],
    MPD: [
        { k: "id", fn: helpers_1.parseString },
        { k: "profiles", fn: helpers_1.parseString },
        { k: "type", fn: helpers_1.parseString, def: "static" },
        { k: "availabilityStartTime", fn: helpers_1.parseDateTime },
        { k: "availabilityEndTime", fn: helpers_1.parseDateTime },
        { k: "publishTime", fn: helpers_1.parseDateTime },
        { k: "mediaPresentationDuration", fn: helpers_1.parseDuration, n: "duration" },
        { k: "minimumUpdatePeriod", fn: helpers_1.parseDuration },
        { k: "minBufferTime", fn: helpers_1.parseDuration },
        { k: "timeShiftBufferDepth", fn: helpers_1.parseDuration },
        {
            k: "suggestedPresentationDelay",
            fn: helpers_1.parseDuration,
            def: config_1.default.DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH,
        },
        { k: "maxSegmentDuration", fn: helpers_1.parseDuration },
        { k: "maxSubsegmentDuration", fn: helpers_1.parseDuration },
    ],
    Role: [
        { k: "schemeIdUri", fn: helpers_1.parseString },
        { k: "value", fn: helpers_1.parseString },
    ],
    Accessibility: [
        { k: "schemeIdUri", fn: helpers_1.parseString },
        { k: "value", fn: parseInt },
    ],
};
function feedAttributes(node, base) {
    var attrs = attributes[node.nodeName];
    assert_1.default(attrs, "no attributes for " + node.nodeName);
    /**
     * XXX TODO Remove the obj with any type. Only security we got in this method
     * is the assumption that fields in attr match exactly with properties of
     * input elements.
     */
    var obj = base || {};
    for (var i = 0; i < attrs.length; i++) {
        var _a = attrs[i], k = _a.k, fn = _a.fn, n = _a.n, def = _a.def;
        if (node.hasAttribute(k)) {
            obj[n || k] = fn(node.getAttribute(k));
        }
        else if (def != null) {
            obj[n || k] = def;
        }
    }
    return obj;
}
exports.default = feedAttributes;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var url_1 = __webpack_require__(23);
var request_1 = __webpack_require__(29);
var utils_1 = __webpack_require__(50);
/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @param {string} opt.url
 * @param {Segment} opt.segment
 * @returns {Observable}
 */
function regularSegmentLoader(_a) {
    var url = _a.url, segment = _a.segment;
    var range = segment.range, indexRange = segment.indexRange;
    // fire a single time contiguous init and index ranges.
    if (range && indexRange &&
        range[1] === indexRange[0] - 1) {
        return request_1.default({
            url: url,
            responseType: "arraybuffer",
            headers: {
                Range: utils_1.byteRange([range[0], indexRange[1]]),
            },
        });
    }
    var mediaHeaders = range ?
        { Range: utils_1.byteRange(range) } : null;
    var mediaOrInitRequest = request_1.default({
        url: url,
        responseType: "arraybuffer",
        headers: mediaHeaders,
    });
    // If init segment has indexRange metadata, we need to fetch
    // both the initialization data and the index metadata. We do
    // this in parallel and send the both blobs into the pipeline.
    if (indexRange) {
        var indexRequest = request_1.default({
            url: url,
            responseType: "arraybuffer",
            headers: { Range: utils_1.byteRange(indexRange) },
        });
        return Observable_1.Observable.merge(mediaOrInitRequest, indexRequest);
    }
    else {
        return mediaOrInitRequest;
    }
}
/**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */
var segmentPreLoader = function (customSegmentLoader) { return function (_a) {
    var segment = _a.segment, adaptation = _a.adaptation, representation = _a.representation, manifest = _a.manifest;
    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;
    // init segment without initialization media/range/indexRange:
    // we do nothing on the network
    if (isInit && !(media || range || indexRange)) {
        return Observable_1.Observable.empty();
    }
    // construct url for the segment
    var path = media ? utils_1.replaceTokens(media, segment, representation) : "";
    var url = url_1.resolveURL(representation.baseURL, path);
    var args = {
        adaptation: adaptation,
        representation: representation,
        manifest: manifest,
        segment: segment,
        transport: "dash",
        url: url,
    };
    if (!customSegmentLoader) {
        return regularSegmentLoader(args);
    }
    return Observable_1.Observable.create(function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         * @param {*} args.data - The segment data
         * @param {Number} args.size - The segment size
         * @param {Number} args.duration - The duration of the request, in ms
         */
        var resolve = function (_args) {
            if (!hasFallbacked) {
                hasFinished = true;
                obs.next({
                    type: "response",
                    value: {
                        responseData: _args.data,
                        size: _args.size,
                        duration: _args.duration,
                    },
                });
                obs.complete();
            }
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} [err={}] - The corresponding error encountered
         */
        var reject = function (err) {
            if (err === void 0) { err = {}; }
            if (!hasFallbacked) {
                hasFinished = true;
                obs.error(err);
            }
        };
        /**
         * Callback triggered when the custom segment loader wants to fallback to
         * the "regular" implementation
         */
        var fallback = function () {
            hasFallbacked = true;
            regularSegmentLoader(args).subscribe(obs);
        };
        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
        var abort = customSegmentLoader(args, callbacks);
        return function () {
            if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                abort();
            }
        };
    });
}; };
exports.default = segmentPreLoader;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var assert_1 = __webpack_require__(2);
var strings_1 = __webpack_require__(85);
var url_1 = __webpack_require__(23);
var isobmff_1 = __webpack_require__(33);
var request_1 = __webpack_require__(29);
var isobmff_timing_infos_1 = __webpack_require__(88);
var utils_1 = __webpack_require__(50);
/**
 * Perform requests for "text" segments
 * TODO DRY this (code too similar to segmentPipeline)
 *
 * @param {Object} infos
 * @param {Segment} infos.segment
 * @param {Representation} infos.representation
 * @returns {Observable.<Object>}
 */
function TextTrackLoader(_a) {
    var segment = _a.segment, representation = _a.representation;
    var media = segment.media, range = segment.range, indexRange = segment.indexRange, isInit = segment.isInit;
    /**
     * ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
     * @type string
     */
    var responseType = utils_1.isMP4EmbeddedTrack(representation) ?
        "arraybuffer" : "text";
    // init segment without initialization media/range/indexRange:
    // we do nothing on the network
    if (isInit && !(media || range || indexRange)) {
        return Observable_1.Observable.empty();
    }
    /**
     * filename
     * @type string
     */
    var path = media ?
        utils_1.replaceTokens(media, segment, representation) : "";
    /**
     * Complete path of the segment.
     * @type string
     */
    var mediaUrl = url_1.resolveURL(representation.baseURL, path);
    // fire a single time contiguous init and index ranges.
    // TODO Find a solution for indicating that special case to the parser
    if (range && indexRange &&
        range[1] === indexRange[0] - 1) {
        return request_1.default({
            url: mediaUrl,
            responseType: responseType,
            headers: {
                Range: utils_1.byteRange([range[0], indexRange[1]]),
            },
        });
    }
    /**
     * Segment request.
     * @type Observable.<Object>
     */
    var mediaOrInitRequest = request_1.default({
        url: mediaUrl,
        responseType: responseType,
        headers: range ? {
            Range: utils_1.byteRange(range),
        } : null,
    });
    // If init segment has indexRange metadata, we need to fetch
    // both the initialization data and the index metadata. We do
    // this in parallel and send the both blobs into the pipeline.
    // TODO Find a solution for calling only one time the parser
    if (indexRange) {
        var indexRequest = request_1.default({
            url: mediaUrl,
            responseType: responseType,
            headers: {
                Range: utils_1.byteRange(indexRange),
            },
        });
        // TypeScript just break here, supposedly for the responseType
        // TODO A TS Bug? Open an issue. Investigate first.
        return Observable_1.Observable.merge(mediaOrInitRequest, indexRequest);
    }
    else {
        // TypeScript just break here, supposedly for the responseType
        // TODO A TS Bug? Open an issue. Investigate first.
        return mediaOrInitRequest;
    }
}
exports.loader = TextTrackLoader;
/**
 * Parse TextTrack data.
 *
 * @param {Object} infos
 * @param {Segment} infos.segment
 * @param {Manifest} infos.manifest
 * @param {Adaptation} infos.adaptation
 * @param {Representation} infos.representation
 * @param {Object} infos.init
 * @returns {Observable.<Object>}
 */
function TextTrackParser(_a) {
    var response = _a.response, segment = _a.segment, adaptation = _a.adaptation, representation = _a.representation, manifest = _a.manifest, init = _a.init;
    var language = adaptation.language;
    var isInit = segment.isInit, indexRange = segment.indexRange;
    var responseData;
    var nextSegments;
    var segmentInfos;
    var segmentData;
    var isMP4 = utils_1.isMP4EmbeddedTrack(representation);
    if (isMP4) {
        assert_1.default(response.responseData instanceof ArrayBuffer);
        responseData = new Uint8Array(response.responseData);
        var sidxSegments = isobmff_1.parseSidx(responseData, indexRange ? indexRange[0] : 0);
        if (sidxSegments) {
            nextSegments = sidxSegments;
        }
        segmentInfos = isInit ?
            { time: -1, duration: 0, timescale: segment.timescale } :
            isobmff_timing_infos_1.default(segment, responseData, sidxSegments, init);
    }
    else {
        assert_1.default(typeof response.responseData === "string");
        responseData = response.responseData;
        if (isInit) {
            segmentInfos = { time: -1, duration: 0, timescale: segment.timescale };
        }
        else {
            segmentInfos = {
                time: segment.time || 0,
                duration: segment.duration,
                timescale: segment.timescale,
            };
        }
    }
    if (isInit) {
        segmentInfos = { time: -1, duration: 0 };
        if (isMP4) {
            var timescale = isobmff_1.getMDHDTimescale(responseData);
            if (timescale > 0) {
                segmentInfos.timescale = timescale;
            }
        }
        segmentData = undefined;
    }
    else {
        assert_1.default(segmentInfos);
        var segmentDataBase = {
            start: segmentInfos.time,
            end: segmentInfos.time + (segmentInfos.duration || 0),
            language: language,
            timescale: segmentInfos.timescale,
            timeOffset: manifest.availabilityStartTime || 0,
        };
        if (isMP4) {
            var _b = representation.codec, codec = _b === void 0 ? "" : _b;
            var type = void 0;
            switch (codec.toLowerCase()) {
                case "stpp":// stpp === TTML in MP4
                    type = "ttml";
                    break;
                case "wvtt":// wvtt === WebVTT in MP4
                    type = "vtt";
            }
            if (!type) {
                throw new Error("The codec used for the subtitle is not managed yet.");
            }
            segmentData = objectAssign({
                data: strings_1.stringFromUTF8(isobmff_1.getMdat(responseData)),
                type: type,
            }, { timescale: 1 }, segmentDataBase);
        }
        else {
            var type = void 0;
            var _c = representation.mimeType, mimeType = _c === void 0 ? "" : _c;
            switch (representation.mimeType) {
                case "application/ttml+xml":
                    type = "ttml";
                    break;
                case "application/x-sami":
                case "application/smil":
                    type = "sami";
                    break;
                case "text/vtt":
                    type = "vtt";
            }
            if (!type) {
                var _d = representation.codec, codec = _d === void 0 ? "" : _d;
                var codeLC = codec.toLowerCase();
                if (codeLC === "srt") {
                    type = "srt";
                }
                else {
                    throw new Error("could not find a text-track parser for the type " + mimeType);
                }
            }
            segmentData = objectAssign({
                data: responseData,
                type: type,
            }, { timescale: 1 }, segmentDataBase);
        }
    }
    if (nextSegments) {
        utils_1.addNextSegments(representation, segmentInfos, nextSegments);
    }
    return Observable_1.Observable.of({ segmentData: segmentData, segmentInfos: segmentInfos });
}
exports.parser = TextTrackParser;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
// TODO What? just don't call the pipeline for directfile
// TODO Delete this file and handle it elsewhere
var manifestPipeline = {
    loader: function (_a) {
        var url = _a.url;
        return Observable_1.Observable.of({ url: url });
    },
    parser: function (_a) {
        var url = _a.url;
        var manifest = {
            transportType: "directfile",
            locations: [url],
            periods: [],
            isLive: false,
            duration: Infinity,
            adaptations: null,
        };
        return Observable_1.Observable.of({ manifest: manifest, url: url });
    },
};
exports.default = function () { return ({
    manifest: manifestPipeline,
}); };


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(46);
var Subject_1 = __webpack_require__(6);
var config_1 = __webpack_require__(4);
var array_includes_1 = __webpack_require__(9);
var initialization_segment_cache_1 = __webpack_require__(253);
var log_1 = __webpack_require__(1);
var retry_1 = __webpack_require__(90);
var rx_throttle_1 = __webpack_require__(254);
var compat_1 = __webpack_require__(5);
var events_1 = __webpack_require__(16);
var errors_1 = __webpack_require__(8);
var abr_1 = __webpack_require__(255);
var buffer_1 = __webpack_require__(261);
var manifest_1 = __webpack_require__(268);
var pipelines_1 = __webpack_require__(278);
var eme_1 = __webpack_require__(280);
var error_stream_1 = __webpack_require__(289);
var initial_time_1 = __webpack_require__(290);
var media_source_1 = __webpack_require__(291);
var process_pipeline_1 = __webpack_require__(292);
var source_buffers_1 = __webpack_require__(293);
var speed_manager_1 = __webpack_require__(319);
var stalling_obs_1 = __webpack_require__(320);
var timings_1 = __webpack_require__(321);
var END_OF_PLAY = config_1.default.END_OF_PLAY;
var SUPPORTED_BUFFER_TYPES = ["audio", "video", "text", "image"];
/**
 * Returns the pipeline options depending on the type of pipeline concerned.
 * @param {string} bufferType - e.g. "audio"|"text"...
 * @returns {Object} - Options to give to the Pipeline
 */
function getPipelineOptions(bufferType) {
    var downloaderOptions = {};
    if (array_includes_1.default(["audio", "video"], bufferType)) {
        downloaderOptions.cache = new initialization_segment_cache_1.default();
    }
    else if (bufferType === "image") {
        downloaderOptions.maxRetry = 0; // Deactivate BIF fetching if it fails
    }
    return downloaderOptions;
}
/**
 * Central part of the player. Play a given stream described by the given
 * manifest with given options.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - create Buffer instances for each adaptation to manage buffers.
 *  - give adaptation control to the caller (e.g. to choose a language)
 *  - perform ABR Management
 *  - returns Observable emitting notifications about the stream lifecycle.
 *
 * TODO TOO MANY PARAMETERS something is wrong here.
 * @param {Object} args
 * @returns {Observable}
 */
function Stream(_a) {
    var adaptiveOptions = _a.adaptiveOptions, autoPlay = _a.autoPlay, bufferOptions = _a.bufferOptions, keySystems = _a.keySystems, speed$ = _a.speed$, startAt = _a.startAt, url = _a.url, videoElement = _a.videoElement, supplementaryImageTracks = _a.supplementaryImageTracks, // eventual manually added images
    supplementaryTextTracks = _a.supplementaryTextTracks, // eventual manually added subtitles
    errorStream = _a.errorStream, // subject through which minor errors are emitted TODO Remove?
    textTrackOptions = _a.textTrackOptions, timings$ = _a.timings$, _b = _a.withMediaSource, withMediaSource = _b === void 0 ? true : _b, transport = _a.transport;
    var wantedBufferAhead$ = bufferOptions.wantedBufferAhead$, maxBufferAhead$ = bufferOptions.maxBufferAhead$, maxBufferBehind$ = bufferOptions.maxBufferBehind$;
    /**
     * Subject through which network metrics will be sent to the ABR manager.
     */
    var network$ = new Subject_1.Subject();
    /**
     * Subject through which each request progression will be reported to the ABR
     * manager.
     */
    var requestsInfos$ = new Subject_1.Subject();
    /**
     * Pipeline used to download the manifest file.
     * @see ../pipelines
     * @type {Function} - take in argument the pipeline data, returns a pipeline
     * observable.
     */
    var manifestPipeline = pipelines_1.default(transport.manifest);
    /**
     * ...Fetch the manifest file given.
     * Throttled to avoid doing multiple simultaneous requests because multiple
     * source buffers are out-of-index
     * @param {string} url - the manifest url
     * @returns {Observable} - the parsed manifest
     */
    var fetchManifest = rx_throttle_1.default(function (_url) {
        var manifest$ = manifestPipeline({ url: _url });
        var fakeSubject = new Subject_1.Subject();
        return process_pipeline_1.default("manifest", manifest$, fakeSubject, // we don't care about metrics here
        fakeSubject, // and we don't care about the request progress
        errorStream).map(function (_a) {
            var parsed = _a.parsed;
            return manifest_1.normalizeManifest(parsed.url, parsed.manifest, supplementaryTextTracks, supplementaryImageTracks);
        });
    });
    /**
     * Map the "type" of a sourceBuffer (example "audio" or "video") to a
     * SourceBuffer.
     *
     * Allow to avoid creating multiple sourceBuffers for the same type.
     * TODO Is this compatible with codec switching?
     *
     * There is 2 "native" SourceBuffers: "audio" and "video" as they are the
     * only one added to the MediaSource.
     *
     * All other SourceBuffers are "custom"
     * @type Object
     */
    var sourceBufferMemory = {
        native: {},
        custom: {},
    };
    /**
     * Backoff options used given to the backoff retry done with the manifest
     * pipeline.
     * @see retryWithBackoff
     */
    var retryOptions = {
        totalRetry: 3,
        retryDelay: 250,
        resetDelay: 60 * 1000,
        shouldRetry: function (error) {
            if (errors_1.isKnownError(error)) {
                return !error.fatal;
            }
            return true;
        },
        errorSelector: function (error) {
            if (!errors_1.isKnownError(error)) {
                return new errors_1.OtherError("NONE", error, true);
            }
            error.fatal = true;
            return error;
        },
        onRetry: function (error, tryCount) {
            log_1.default.warn("stream retry", error, tryCount);
            errorStream.next(error);
        },
    };
    /**
     * End-Of-Play emit when the current timing is really close to the end.
     * @see END_OF_PLAY
     * @type {Observable}
     */
    var endOfPlay = timings$
        .filter(function (_a) {
        var currentTime = _a.currentTime, duration = _a.duration;
        return (duration > 0 && duration - currentTime < END_OF_PLAY);
    });
    /**
     * On subscription:
     *   - load the manifest (through its pipeline)
     *   - wiat for the given mediasource to be open
     * Once those are done, initialize the source duration and creates every
     * SourceBuffers and Buffers instances.
     *
     * This Observable can be retried on the basis of the retryOptions defined
     * here.
     * @param {Object} params
     * @param {string} params.url
     * @param {MediaSource|null} params.mediaSource
     * @returns {Observable}
     */
    var startStream = retry_1.retryableFuncWithBackoff(function (_a) {
        var 
        // TODO tslint bug? Document.
        /* tslint:disable no-use-before-declare */
        _url = _a.url, 
        /* tslint:enable no-use-before-declare */
        mediaSource = _a.mediaSource;
        var sourceOpening$ = mediaSource
            ? events_1.onSourceOpen$(mediaSource)
            : Observable_1.Observable.of(null);
        return Observable_1.Observable.combineLatest(fetchManifest(url), sourceOpening$)
            .mergeMap(function (_a) {
            var manifest = _a[0];
            return createStream(mediaSource, manifest);
        });
    }, retryOptions);
    /**
     * Creates a stream of audio/video/text buffers given a set of
     * adaptations and a codec information.
     *
     * For each buffer stream, a unique "sourceBuffer" observable is
     * created that will be reused for each created buffer.
     *
     * An "adaptations choice" observable is also created and
     * responsible for changing the video or audio adaptation choice in
     * reaction to user choices (ie. changing the language).
     *
     * @param {MediaSource} mediaSource
     * @param {Object} bufferInfos - Per-type object containing the adaptions,
     * the codec and the type
     * @param {Observable} timings
     * @param {Observable} seekings
     * @returns {Observable}
     */
    function createBuffer(mediaSource, bufferType, timings, seekings, manifest, adaptation$, abrManager) {
        var pipelineOptions = getPipelineOptions(bufferType);
        return adaptation$.switchMap(function (adaptation) {
            if (!adaptation) {
                log_1.default.info("disposing " + bufferType + " adaptation");
                source_buffers_1.disposeSourceBuffer(videoElement, mediaSource, bufferType, sourceBufferMemory);
                return Observable_1.Observable.of({
                    type: "adaptationChange",
                    value: {
                        type: bufferType,
                        adaptation: null,
                    },
                }).concat(buffer_1.EmptyBuffer({ bufferType: bufferType }));
            }
            log_1.default.info("updating " + bufferType + " adaptation", adaptation);
            /**
             * Keep the current representation to add informations to the ABR clock.
             * TODO isn't that a little bit ugly?
             * @type {Object|null}
             */
            var currentRepresentation = null;
            var abrClock$ = timings$
                .map(function (timing) {
                var bitrate;
                var lastIndexPosition;
                if (currentRepresentation) {
                    bitrate = currentRepresentation.bitrate;
                    if (currentRepresentation.index) {
                        lastIndexPosition =
                            currentRepresentation.index.getLastPosition();
                    }
                }
                return {
                    bitrate: bitrate,
                    bufferGap: timing.bufferGap,
                    duration: timing.duration,
                    isLive: manifest.isLive,
                    lastIndexPosition: lastIndexPosition,
                    position: timing.currentTime,
                    speed: speed$.getValue(),
                };
            });
            var representations = adaptation.representations;
            var abr$ = abrManager.get$(bufferType, abrClock$, representations);
            var representation$ = abr$
                .map(function (abr) { return abr.representation; })
                .filter(function (representation) { return representation != null; })
                .distinctUntilChanged(function (a, b) {
                return (a && a.bitrate) === (b && b.bitrate) &&
                    (a && a.id) === (b && b.id);
            })
                .do(function (representation) {
                currentRepresentation = representation;
            });
            var codec = manifest_1.getCodec(adaptation.representations[0] || {});
            var sourceBuffer = source_buffers_1.createSourceBuffer(videoElement, mediaSource, bufferType, codec, sourceBufferMemory, bufferType === "text" ? textTrackOptions : {});
            function downloader(_a) {
                var segment = _a.segment, representation = _a.representation, init = _a.init;
                var pipeline$ = pipelines_1.default(transport[bufferType], pipelineOptions)({
                    segment: segment,
                    representation: representation,
                    adaptation: adaptation,
                    manifest: manifest,
                    init: init,
                });
                return process_pipeline_1.default(bufferType, pipeline$, network$, requestsInfos$, errorStream);
            }
            var switchRepresentation$ = Observable_1.Observable.combineLatest(representation$, seekings)
                .map(function (_a) {
                var representation = _a[0];
                return representation;
            });
            log_1.default.info("creating Buffer for ", bufferType);
            var buffer = buffer_1.Buffer({
                sourceBuffer: sourceBuffer,
                downloader: downloader,
                switch$: switchRepresentation$,
                clock$: timings,
                wantedBufferAhead: wantedBufferAhead$,
                maxBufferBehind: maxBufferBehind$,
                maxBufferAhead: maxBufferAhead$,
                bufferType: bufferType,
                isLive: manifest.isLive,
            });
            var buffer$ = Observable_1.Observable.of({
                type: "adaptationChange",
                value: {
                    type: bufferType,
                    adaptation: adaptation,
                },
            })
                .concat(buffer)
                .catch(function (error) {
                // non native buffer should not impact the stability of the
                // player. ie: if a text buffer sends an error, we want to
                // continue streaming without any subtitles
                if (!source_buffers_1.shouldHaveNativeSourceBuffer(bufferType)) {
                    log_1.default.error("custom buffer: ", bufferType, "has crashed. Aborting it.", error);
                    errorStream.next(error);
                    return Observable_1.Observable.empty();
                }
                log_1.default.error("native buffer: ", bufferType, "has crashed. Stopping playback.", error);
                throw error; // else, throw
            });
            var bitrateEstimate$ = abr$
                .filter(function (_a) {
                var bitrate = _a.bitrate;
                return bitrate != null;
            })
                .map(function (_a) {
                var bitrate = _a.bitrate;
                return {
                    type: "bitrateEstimationChange",
                    value: {
                        type: bufferType,
                        bitrate: bitrate,
                    },
                };
            });
            return Observable_1.Observable.merge(buffer$, bitrateEstimate$);
        });
    }
    /**
     * Creates an observable waiting for the "loadedmetadata" and "canplay"
     * events, and emitting a "loaded" event as both are received.
     *
     * /!\ This has also the side effect of setting the initial time as soon as
     * the loadedmetadata event pops up.
     * @param {Object} manifest
     * @returns {Observable}
     */
    function createVideoEventsObservables(manifest, timings) {
        log_1.default.debug("calculating initial time");
        var startTime = initial_time_1.default(manifest, startAt);
        log_1.default.debug("initial time calculated:", startTime);
        /**
         * Time offset is an offset to add to the timing's current time to have
         * the "real" position.
         * For now, this is seen when the video has not yet seeked to its initial
         * position, the currentTime will most probably be 0 where the effective
         * starting position will be _startTime_.
         * Thus we initially set a timeOffset equal to startTime.
         * TODO That look ugly, find better solution?
         * @type {Number}
         */
        var timeOffset = startTime;
        var canSeek$ = compat_1.canSeek(videoElement)
            .do(function () {
            log_1.default.info("set initial time", startTime);
            // reset playbackRate to 1 in case we were at 0 (from a stalled
            // retry for instance)
            videoElement.playbackRate = 1;
            videoElement.currentTime = startTime;
            timeOffset = 0;
        });
        var canPlay$ = compat_1.canPlay(videoElement)
            .do(function () {
            log_1.default.info("canplay event");
            if (autoPlay) {
                /* tslint:disable no-floating-promises */
                videoElement.play();
                /* tslint:enable no-floating-promises */
            }
        });
        return {
            clock$: timings
                .map(function (timing) {
                return objectAssign({ timeOffset: timeOffset }, timing);
            }),
            loaded$: Observable_1.Observable.combineLatest(canSeek$, canPlay$)
                .take(1)
                .mapTo({
                type: "loaded",
                value: true,
            }),
        };
    }
    /**
     * Re-fetch the manifest and merge it with the previous version.
     * @param {Object} manifest
     * @returns {Observable}
     */
    function refreshManifest(manifest) {
        return fetchManifest(manifest.getUrl())
            .map(function (parsed) {
            var newManifest = manifest_1.updateManifest(manifest, parsed);
            return {
                type: "manifestUpdate",
                value: {
                    manifest: newManifest,
                },
            };
        });
    }
    /**
     * Handle events happening only in live contexts.
     * @param {Object} message
     * @param {Object} manifest
     * @returns {Observable}
     */
    function liveMessageHandler(message, manifest) {
        switch (message.type) {
            case "index-discontinuity":
                log_1.default.warn("explicit discontinuity seek", message.value.ts);
                videoElement.currentTime = message.value.ts;
                break;
            // precondition-failed messages require a change of live-gap to
            // calibrate the live representation of the player
            // TODO(pierre): smarter converging algorithm
            case "precondition-failed":
                manifest.updateLiveGap(1); // go back 1s for now
                log_1.default.warn("precondition failed", manifest.presentationLiveGap);
                break;
            case "out-of-index":
                // out-of-index messages require a complete reloading of the
                // manifest to refresh the current index
                log_1.default.info("out of index");
                return refreshManifest(manifest);
        }
        return Observable_1.Observable.of(message);
    }
    /**
     * Creates a stream merging all observable that are required to make
     * the system cooperate.
     * @param {MediaSource} mediaSource
     * @param {Object} manifest
     * @returns {Observable}
     */
    function createStream(mediaSource, manifest) {
        // TODO Find what to do with no media source.
        if (!mediaSource) {
            throw new Error("No media source.");
        }
        if (mediaSource) {
            media_source_1.setDurationToMediaSource(mediaSource, manifest.getDuration());
            // Initialize all native source buffer at the same time. We cannot
            // lazily create native sourcebuffers since the spec does not
            // allow adding them during playback.
            //
            // From https://w3c.github.io/media-source/#methods
            //    For example, a user agent may throw a QuotaExceededError
            //    exception if the media element has reached the HAVE_METADATA
            //    readyState. This can occur if the user agent's media engine
            //    does not support adding more tracks during playback.
            Object.keys(manifest.adaptations).map(function (bufferType) {
                if (source_buffers_1.shouldHaveNativeSourceBuffer(bufferType)) {
                    var adaptations = manifest.getAdaptationsForType(bufferType);
                    var representations = adaptations ?
                        adaptations[0].representations : [];
                    if (representations.length) {
                        var codec = manifest_1.getCodec(representations[0]);
                        source_buffers_1.addNativeSourceBuffer(mediaSource, bufferType, codec, sourceBufferMemory);
                    }
                }
            });
        }
        var _a = timings_1.default(manifest, timings$), _timings = _a.timings, seekings = _a.seekings;
        var _b = createVideoEventsObservables(manifest, _timings), loaded$ = _b.loaded$, clock$ = _b.clock$;
        var abrManager = new abr_1.default(requestsInfos$, network$, // emit network metrics such as the observed bandwidth
        adaptiveOptions);
        var _adaptations$ = {};
        var _buffersArray = SUPPORTED_BUFFER_TYPES.map(function (type) {
            var adaptation$ = new ReplaySubject_1.ReplaySubject(1);
            _adaptations$[type] = adaptation$;
            return createBuffer(mediaSource, type, clock$, seekings, manifest, adaptation$, abrManager);
        });
        var adaptations$ = _adaptations$;
        var buffers$ = manifest.isLive ?
            Observable_1.Observable.merge.apply(Observable_1.Observable, _buffersArray).mergeMap(function (message) { return liveMessageHandler(message, manifest); }) : Observable_1.Observable.merge.apply(Observable_1.Observable, _buffersArray);
        var manifest$ = Observable_1.Observable.of({
            type: "manifestChange",
            value: {
                manifest: manifest,
                adaptations$: adaptations$,
                abrManager: abrManager,
            },
        });
        var emeManager$ = eme_1.default(videoElement, keySystems, errorStream);
        var speedManager$ = speed_manager_1.default(videoElement, speed$, timings$, {
            pauseWhenStalled: withMediaSource,
        }).map(function (newSpeed) { return ({ type: "speed", value: newSpeed }); });
        var stallingManager$ = stalling_obs_1.default(videoElement, manifest, timings$)
            .map(function (stalledStatus) { return ({ type: "stalled", value: stalledStatus }); });
        var mediaErrorManager$ = error_stream_1.default(videoElement);
        return Observable_1.Observable.merge(buffers$, emeManager$, loaded$, manifest$, mediaErrorManager$, speedManager$, stallingManager$);
    }
    return media_source_1.createAndPlugMediaSource(url, videoElement, withMediaSource, sourceBufferMemory)
        .mergeMap(startStream)
        .takeUntil(endOfPlay);
}
exports.default = Stream;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 */
var InitializationSegmentCache = /** @class */ (function () {
    function InitializationSegmentCache() {
        this._cache = {};
    }
    /**
     * @param {Object} obj
     * @param {Object} obj.segment
     * @param {*} response
     * TODO just add segment directly, not in an object?
     */
    InitializationSegmentCache.prototype.add = function (_a, response) {
        var segment = _a.segment;
        if (segment.isInit) {
            this._cache[segment.id] = response;
        }
    };
    /**
     * @param {Object} obj
     * @param {Object} obj.segment
     * @returns {*} response
     * TODO just add segment directly, not in an object?
     */
    InitializationSegmentCache.prototype.get = function (_a) {
        var segment = _a.segment;
        if (segment.isInit) {
            var value = this._cache[segment.id];
            if (value != null) {
                return value;
            }
        }
        return null;
    };
    return InitializationSegmentCache;
}());
exports.default = InitializationSegmentCache;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var castToObservable_1 = __webpack_require__(10);
var noop_1 = __webpack_require__(18);
/**
 * Throttle an asynchronous function (returning an Observable or Promise) to
 * drop calls done before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 *
 * TODO Add typings from castToObservable?
 */
function throttle(func) {
    var isPending = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (isPending) {
            return Observable_1.Observable.empty();
        }
        isPending = true;
        return castToObservable_1.default(func.apply(void 0, args))
            .do(noop_1.default, function () { return isPending = false; }, function () { return isPending = false; });
    };
}
exports.default = throttle;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = __webpack_require__(6);
var representation_chooser_1 = __webpack_require__(256);
var defaultChooserOptions = {
    limitWidth: {},
    throttle: {},
    initialBitrates: {},
    manualBitrates: {},
    maxAutoBitrates: {},
};
/**
 * Create the right RepresentationChooser instance, from the given data.
 * @param {string} type
 * @param {Object} options
 * @returns {RepresentationChooser} - The RepresentationChooser instance
 */
var createChooser = function (type, options) {
    return new representation_chooser_1.default({
        limitWidth$: options.limitWidth[type],
        throttle$: options.throttle[type],
        initialBitrate: options.initialBitrates[type],
        manualBitrate: options.manualBitrates[type],
        maxAutoBitrate: options.maxAutoBitrates[type],
    });
};
/**
 * Adaptive BitRate Manager.
 *
 * Select the right representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */
var ABRManager = /** @class */ (function () {
    /**
     * @param {Observable} requests$ - Emit requests infos as they begin, progress
     * and end.
     * Allows to know if a request take too much time to be finished in
     * emergency times (e.g. when the user's bandwidth falls very quickly).
     *
     * The items emitted are Observables which each emit infos about a SINGLE
     * request. These infos are under the form of objects with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *
     *   - event {string}: Wether the request started, is progressing or has
     *     ended. Should be either one of these three strings:
     *       1. "requestBegin": The request has just begun.
     *
     *       2. "progress": Informations about the request progress were received
     *          (basically the amount of bytes currently received).
     *
     *       2. "requestEnd": The request just ended (successfully/on error/was
     *          canceled)
     *
     *     Note that it should ALWAYS happen in the following order:
     *     1 requestBegin -> 0+ progress -> 1 requestEnd
     *
     *     Also note that EVERY requestBegin should eventually be followed by a
     *     requestEnd at some point. If that's not the case, a memory leak
     *     can happen.
     *
     *   - value {Object|undefined}: The value depends on the type of event
     *     received:
     *       - for "requestBegin" events, it should be an object with the
     *         following keys:
     *           - id {number|String}: The id of this particular request.
     *           - duration {number}: duration, in seconds of the asked segment.
     *           - time {number}: The start time, in seconds of the asked segment.
     *           - requestTimestamp {number}: the timestamp at which the request
     *             was sent, in ms.
     *
     *       - for "progress" events, it should be an object with the following
     *         keys:
     *           - id {number|String}: The id of this particular request.
     *           - size {number}: amount currently downloaded, in bytes
     *           - timestamp {number}: timestamp at which the progress event was
     *             received, in ms
     *         Those events SHOULD be received in order (that is, in increasing
     *         order for both size and timestamp).
     *
     *       - for "requestEnd" events:
     *           - id {number|String}: The id of this particular request.
     *
     * @param {Observable} metrics$ - Emit each times the network downloaded
     * a new segment for a given buffer type. Allows to obtain informations about
     * the user's bitrate.
     *
     * The items emitted are object with the following keys:
     *   - type {string}: the buffer type (example: "video")
     *   - value {Object}:
     *     - duration {number}: duration of the request, in seconds.
     *     - size {number}: size of the downloaded chunks, in bytes.
     *
     * @param {ChooserOption} [options={}]
     */
    function ABRManager(requests$, metrics$, options) {
        if (options === void 0) { options = defaultChooserOptions; }
        var _this = this;
        // Subject emitting and completing on dispose.
        // Used to clean up every created observables.
        this._dispose$ = new Subject_1.Subject();
        // Will contain every RepresentationChooser attached to the ABRManager,
        // by type ("audio"/"video" etc.)
        this._choosers = {};
        // -- OPTIONS --
        // Will contain options used when (lazily) instantiating a
        // RepresentationChooser
        this._chooserInstanceOptions = {
            initialBitrates: options.initialBitrates || {},
            manualBitrates: options.manualBitrates || {},
            maxAutoBitrates: options.maxAutoBitrates || {},
            throttle: options.throttle || {},
            limitWidth: options.limitWidth || {},
        };
        metrics$
            .takeUntil(this._dispose$)
            .subscribe(function (_a) {
            var type = _a.type, value = _a.value;
            _this._lazilyCreateChooser(type);
            var duration = value.duration, size = value.size;
            // TODO Should we do a single estimate instead of a per-type one?
            // Test it thoroughly
            _this._choosers[type].addEstimate(duration, size);
        });
        requests$
            .mergeMap(function (request$) { return request$; })
            .takeUntil(this._dispose$)
            .subscribe(function (request) {
            var type = request.type, value = request.value;
            _this._lazilyCreateChooser(type);
            switch (request.event) {
                case "requestBegin":
                    // use the id of the segment as in any case, we should only have at
                    // most one active download for the same segment.
                    // This might be not optimal if this changes however. The best I think
                    // for now is to just throw/warn in DEV mode when two pending ids
                    // are identical
                    _this._choosers[type].addPendingRequest(value.id, request);
                    break;
                case "requestEnd":
                    _this._choosers[type].removePendingRequest(value.id);
                    break;
                case "progress":
                    _this._choosers[type].addRequestProgress(value.id, request);
                    break;
            }
        });
    }
    /**
     * Take type and an array of the available representations, spit out an
     * observable emitting the best representation (given the network/buffer
     * state).
     * @param {string} type
     * @param {Observable<Object>} clock$
     * @param {Array.<Representation>} [representations=[]]
     * @returns {Observable}
     */
    ABRManager.prototype.get$ = function (type, clock$, representations) {
        if (representations === void 0) { representations = []; }
        this._lazilyCreateChooser(type);
        return this._choosers[type].get$(clock$, representations);
    };
    /**
     * Set manually the bitrate for a given type.
     *
     * The given number will act as a ceil.
     * If no representation is found with the given bitrate, we will consider:
     *   1. The representation just lower than it
     *   2. If no representation is found in the previous step, the representation
     *   with the lowest bitrate.
     *
     * @param {string} type
     * @param {number} bitrate
     */
    ABRManager.prototype.setManualBitrate = function (type, bitrate) {
        var chooser = this._choosers[type];
        if (!chooser) {
            // if no chooser yet, store as a chooser option for when it will be
            // effectively instantiated
            this._chooserInstanceOptions.initialBitrates[type] = bitrate;
        }
        else {
            chooser.manualBitrate$.next(bitrate);
        }
    };
    ABRManager.prototype.setMaxAutoBitrate = function (type, bitrate) {
        var chooser = this._choosers[type];
        if (!chooser) {
            // if no chooser yet, store as a chooser option for when it will be
            // effectively instantiated
            this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
        }
        else {
            chooser.maxAutoBitrate$.next(bitrate);
        }
    };
    ABRManager.prototype.getManualBitrate = function (type) {
        var chooser = this._choosers[type];
        return chooser ?
            chooser.manualBitrate$.getValue() :
            this._chooserInstanceOptions.manualBitrates[type];
    };
    ABRManager.prototype.getMaxAutoBitrate = function (type) {
        var chooser = this._choosers[type];
        return chooser ?
            chooser.maxAutoBitrate$.getValue() :
            this._chooserInstanceOptions.maxAutoBitrates[type];
    };
    ABRManager.prototype.dispose = function () {
        var _this = this;
        Object.keys(this._choosers).forEach(function (type) {
            _this._choosers[type].dispose();
        });
        this._chooserInstanceOptions = defaultChooserOptions;
        this._choosers = {};
        this._dispose$.next();
        this._dispose$.complete();
    };
    /**
     * If it doesn't exist, create a RepresentationChooser under the
     * _choosers.<bufferType> property.
     * @param {ABRManager} intce
     * @param {string} bufferType
     */
    ABRManager.prototype._lazilyCreateChooser = function (bufferType) {
        if (!this._choosers[bufferType]) {
            this._choosers[bufferType] =
                createChooser(bufferType, this._chooserInstanceOptions);
        }
    };
    return ABRManager;
}());
exports.default = ABRManager;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var BehaviorSubject_1 = __webpack_require__(81);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(6);
var config_1 = __webpack_require__(4);
var assert_1 = __webpack_require__(2);
var bandwidth_estimator_1 = __webpack_require__(257);
var filterByBitrate_1 = __webpack_require__(258);
var filterByWidth_1 = __webpack_require__(259);
var fromBitrateCeil_1 = __webpack_require__(260);
var ewma_1 = __webpack_require__(92);
var ABR_STARVATION_GAP = config_1.default.ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP = config_1.default.OUT_OF_STARVATION_GAP, ABR_STARVATION_FACTOR = config_1.default.ABR_STARVATION_FACTOR, ABR_REGULAR_FACTOR = config_1.default.ABR_REGULAR_FACTOR;
/**
 * Returns an observable emitting only the representation concerned by the
 * bitrate ceil given.
 * @param {Array.<Representation>} representations
 * @param {number} bitrate
 * @returns {Observable}
 */
function setManualRepresentation(representations, bitrate) {
    var chosenRepresentation = fromBitrateCeil_1.default(representations, bitrate) ||
        representations[0];
    return Observable_1.Observable.of({
        bitrate: undefined,
        representation: chosenRepresentation,
    });
}
/**
 * Get the pending request containing the asked segment position.
 * @param {Object} requests
 * @param {number} segmentPosition
 * @returns {IRequestInfo|undefined}
 */
function getConcernedRequest(requests, segmentPosition) {
    var currentRequestIds = Object.keys(requests);
    var len = currentRequestIds.length;
    for (var i = 0; i < len - 1; i++) {
        var request = requests[currentRequestIds[i]];
        var chunkTime = request.time, chunkDuration = request.duration;
        // TODO review this
        if (Math.abs(segmentPosition - chunkTime) < chunkDuration) {
            return request;
        }
    }
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * Use progress events if available, set a much more random lower bitrate
 * if no progress events are available.
 *
 * @param {Object} request
 * @param {number} requestTime - Amount of time the request has taken for now,
 * in seconds.
 * @param {number} bitrate - Current bitrate at the time of download
 * @returns {number}
 */
function estimateRequestBandwidth(request, requestTime, bitrate) {
    var estimate;
    // try to infer quickly the current bitrate based on the
    // progress events
    if (request.progress.length >= 2) {
        var ewma1 = new ewma_1.default(2);
        var progress = request.progress;
        for (var i = 1; i < progress.length; i++) {
            var bytesDownloaded = progress[i].size - progress[i - 1].size;
            var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
            var reqBitrate = (bytesDownloaded * 8) / (timeElapsed / 1000);
            ewma1.addSample(timeElapsed / 1000, reqBitrate);
        }
        estimate = ewma1.getEstimate();
    }
    // if that fails / no progress event, take a guess
    if (!estimate && bitrate) {
        var chunkDuration = request.duration;
        var chunkSize = chunkDuration * bitrate;
        // take current duration of request as a base
        estimate = chunkSize / (requestTime * 5 / 4);
    }
    return estimate;
}
/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters
 * @param {number} [filters.bitrate] - max bitrate authorized (included).
 * @param {number} [filters.width] - max width authorized (included).
 * @returns {Representation[]}
 */
function getFilteredRepresentations(representations, filters) {
    var _representations = representations;
    if (filters.bitrate != null) {
        _representations = filterByBitrate_1.default(_representations, filters.bitrate);
    }
    if (filters.width != null) {
        _representations = filterByWidth_1.default(_representations, filters.width);
    }
    return _representations;
}
/**
 * Returns true if the request takes too much time relatively to how much we
 * should actually wait.
 * Depends on the chunk duration.
 * @param {number} durationOfRequest - time, in s, since the request has been
 * performed.
 * @param {number} chunkDuration - duration, in s, of a single chunk
 * @returns {Boolean}
 */
function requestTakesTime(durationOfRequest, chunkDuration) {
    return durationOfRequest > chunkDuration * 1.2 + 1;
}
/**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *   - etc.
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 */
var RepresentationChooser = /** @class */ (function () {
    /**
     * @param {Object} options
     */
    function RepresentationChooser(options) {
        this._dispose$ = new Subject_1.Subject();
        this.manualBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.manualBitrate != null ?
            options.manualBitrate : -1);
        this.maxAutoBitrate$ = new BehaviorSubject_1.BehaviorSubject(options.maxAutoBitrate != null ?
            options.maxAutoBitrate : Infinity);
        this.estimator = new bandwidth_estimator_1.default();
        this._currentRequests = {};
        this._initialBitrate = options.initialBitrate || 0;
        this._limitWidth$ = options.limitWidth$;
        this._throttle$ = options.throttle$;
    }
    RepresentationChooser.prototype.get$ = function (clock$, representations) {
        var _this = this;
        if (representations.length < 2) {
            return Observable_1.Observable.of({
                bitrate: undefined,
                representation: representations.length ?
                    representations[0] : null,
            })
                .takeUntil(this._dispose$);
        }
        var _a = this, manualBitrate$ = _a.manualBitrate$, maxAutoBitrate$ = _a.maxAutoBitrate$, _initialBitrate = _a._initialBitrate;
        var _deviceEventsArray = [];
        if (this._limitWidth$) {
            _deviceEventsArray.push(this._limitWidth$.map(function (width) { return ({ width: width }); }));
        }
        if (this._throttle$) {
            _deviceEventsArray.push(this._throttle$.map(function (bitrate) { return ({ bitrate: bitrate }); }));
        }
        /**
         * Emit restrictions on the pools of available representations to choose
         * from.
         * @type {Observable}
         */
        var deviceEvents$ = _deviceEventsArray.length ?
            Observable_1.Observable.combineLatest.apply(Observable_1.Observable, _deviceEventsArray).map(function (args) { return objectAssign.apply(void 0, [{}].concat(args)); }) : Observable_1.Observable.of({});
        /**
         * Store the last client's bitrate generated by our estimation algorithms.
         * @type {Number|undefined}
         */
        var lastEstimatedBitrate;
        return manualBitrate$.switchMap(function (manualBitrate) {
            if (manualBitrate >= 0) {
                // MANUAL mode
                return setManualRepresentation(representations, manualBitrate);
            }
            // AUTO mode
            var inStarvationMode = false;
            return Observable_1.Observable.combineLatest(clock$, maxAutoBitrate$, deviceEvents$)
                .map(function (_a) {
                var clock = _a[0], maxAutoBitrate = _a[1], deviceEvents = _a[2];
                var nextBitrate;
                var bandwidthEstimate;
                var bufferGap = clock.bufferGap;
                // Check for starvation == not much left to play
                if (bufferGap <= ABR_STARVATION_GAP) {
                    inStarvationMode = true;
                }
                else if (inStarvationMode && bufferGap >= OUT_OF_STARVATION_GAP) {
                    inStarvationMode = false;
                }
                // If in starvation mode, check if the request for the next segment
                // takes too much time relatively to the chunk's duration.
                // If that's the case, re-calculate the bandwidth urgently based on
                // this single request.
                if (inStarvationMode) {
                    var position = clock.position, bitrate = clock.bitrate;
                    var nextSegmentPosition = bufferGap + position;
                    var request = getConcernedRequest(_this._currentRequests, nextSegmentPosition);
                    if (request) {
                        var chunkDuration = request.duration, requestTimestamp = request.requestTimestamp;
                        var now = Date.now();
                        var requestTimeInSeconds = (now - requestTimestamp) / 1000;
                        if (chunkDuration &&
                            requestTakesTime(requestTimeInSeconds, chunkDuration)) {
                            bandwidthEstimate = estimateRequestBandwidth(request, requestTimeInSeconds, bitrate);
                            if (bandwidthEstimate != null) {
                                // Reset all estimations to zero
                                // Note: this is weird to do this type of "global" side effect
                                // (for this class) in an observable, not too comfortable with
                                // that.
                                _this.resetEstimate();
                                if (bitrate != null) {
                                    nextBitrate = Math.min(bandwidthEstimate, bitrate, maxAutoBitrate);
                                }
                                else {
                                    nextBitrate = Math.min(bandwidthEstimate, maxAutoBitrate);
                                }
                            }
                        }
                    }
                }
                // if nextBitrate is not yet defined, do the normal estimation
                if (nextBitrate == null) {
                    bandwidthEstimate = _this.estimator.getEstimate();
                    var nextEstimate = void 0;
                    if (bandwidthEstimate != null) {
                        nextEstimate = inStarvationMode ?
                            bandwidthEstimate * ABR_STARVATION_FACTOR :
                            bandwidthEstimate * ABR_REGULAR_FACTOR;
                    }
                    else if (lastEstimatedBitrate != null) {
                        nextEstimate = inStarvationMode ?
                            lastEstimatedBitrate * ABR_STARVATION_FACTOR :
                            lastEstimatedBitrate * ABR_REGULAR_FACTOR;
                    }
                    else {
                        nextEstimate = _initialBitrate;
                    }
                    nextBitrate = Math.min(nextEstimate, maxAutoBitrate);
                }
                if (clock.speed > 1) {
                    nextBitrate /= clock.speed;
                }
                var _representations = getFilteredRepresentations(representations, deviceEvents);
                return {
                    bitrate: bandwidthEstimate,
                    representation: fromBitrateCeil_1.default(_representations, nextBitrate) ||
                        representations[0],
                };
            }).do(function (_a) {
                var bitrate = _a.bitrate;
                if (bitrate != null) {
                    lastEstimatedBitrate = bitrate;
                }
            }).share();
        });
    };
    /**
     * Add a bandwidth estimate by giving:
     *   - the duration of the request, in s
     *   - the size of the request in bytes
     * @param {number} duration
     * @param {number} size
     */
    RepresentationChooser.prototype.addEstimate = function (duration, size) {
        if (duration != null && size != null) {
            this.estimator.addSample(duration, size);
        }
    };
    /**
     * Reset all the estimates done until now.
     * Useful when the network situation changed completely.
     */
    RepresentationChooser.prototype.resetEstimate = function () {
        this.estimator.reset();
    };
    /**
     * Add informations about a new pending request.
     * This can be useful if the network bandwidth drastically changes to infer
     * a new bandwidth through this single request.
     * @param {string|number} id
     * @param {Object} payload
     */
    RepresentationChooser.prototype.addPendingRequest = function (id, payload) {
        if (false) {
            assert_1.default(!this._currentRequests[id], "request already added");
        }
        var _a = payload.value, time = _a.time, duration = _a.duration, requestTimestamp = _a.requestTimestamp;
        this._currentRequests[id] = {
            time: time,
            duration: duration,
            requestTimestamp: requestTimestamp,
            progress: [],
        };
        this._currentRequests[id].progress = [];
    };
    /**
     * Add progress informations to a pending request.
     * Progress objects are a key part to calculate the bandwidth from a single
     * request, in the case the user's bandwidth changes drastically while doing
     * it.
     * @param {string|number} id
     * @param {Object} progress
     */
    RepresentationChooser.prototype.addRequestProgress = function (id, progress) {
        if (false) {
            assert_1.default(this._currentRequests[id] &&
                this._currentRequests[id].progress, "not a valid request");
        }
        this._currentRequests[id].progress.push(progress.value);
    };
    /**
     * Remove a request previously set as pending through the addPendingRequest
     * method.
     * @param {string|number} id
     */
    RepresentationChooser.prototype.removePendingRequest = function (id) {
        if (false) {
            assert_1.default(this._currentRequests[id], "can't remove request: id not found");
        }
        delete this._currentRequests[id];
    };
    /**
     * Remove informations about all pending requests.
     */
    RepresentationChooser.prototype.resetRequests = function () {
        this._currentRequests = {};
    };
    /**
     * TODO See if we can avoid this
     */
    RepresentationChooser.prototype.dispose = function () {
        this._dispose$.next();
        this.manualBitrate$.complete();
        this.maxAutoBitrate$.complete();
    };
    return RepresentationChooser;
}());
exports.default = RepresentationChooser;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var ewma_1 = __webpack_require__(92);
var FAST_EMA = 2;
var SLOW_EMA = 10;
var ABR_MINIMUM_TOTAL_BYTES = config_1.default.ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE = config_1.default.ABR_MINIMUM_CHUNK_SIZE;
/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */
var BandwidthEstimator = /** @class */ (function () {
    function BandwidthEstimator() {
        /**
         * A fast-moving average.
         * @private
         */
        this._fast = new ewma_1.default(FAST_EMA);
        /**
         * A slow-moving average.
         * @private
         */
        this._slow = new ewma_1.default(SLOW_EMA);
        /**
         * Number of bytes sampled.
         * @private
         */
        this._bytesSampled = 0;
    }
    /**
     * Takes a bandwidth sample.
     * @param {number} durationMs The amount of time, in milliseconds, for a
     *   particular request.
     * @param {number} numBytes The total number of bytes transferred in that
     *   request.
     */
    BandwidthEstimator.prototype.addSample = function (durationInMs, numberOfBytes) {
        if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
            return;
        }
        var bandwidth = numberOfBytes * 8000 / durationInMs;
        var weight = durationInMs / 1000;
        this._bytesSampled += numberOfBytes;
        this._fast.addSample(weight, bandwidth);
        this._slow.addSample(weight, bandwidth);
    };
    /**
     * Get estimate of the bandwidth, in bits per seconds.
     * @returns {Number}
     */
    BandwidthEstimator.prototype.getEstimate = function () {
        if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
            return undefined;
        }
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this._fast.getEstimate(), this._slow.getEstimate());
    };
    /**
     * Reset the bandwidth estimation.
     */
    BandwidthEstimator.prototype.reset = function () {
        this._fast = new ewma_1.default(FAST_EMA);
        this._slow = new ewma_1.default(SLOW_EMA);
        this._bytesSampled = 0;
    };
    return BandwidthEstimator;
}());
exports.default = BandwidthEstimator;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFindIndex = __webpack_require__(93);
/**
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
function filterByBitrate(representations, bitrate) {
    var firstSuperiorBitrate = arrayFindIndex(representations, function (r) { return r.bitrate > bitrate; });
    if (firstSuperiorBitrate === -1) {
        return representations;
    }
    return representations.slice(0, firstSuperiorBitrate);
}
exports.default = filterByBitrate;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
/**
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
function filterByWidth(representations, width) {
    var sortedRepsByWidth = representations.sort(function (a, b) { return (a.width || 0) - (b.width || 0); });
    var repWithMaxWidth = arrayFind(sortedRepsByWidth, function (r) { return (r.width || 0) >= width; });
    if (repWithMaxWidth) {
        var maxWidth_1 = repWithMaxWidth.width || 0;
        return representations.filter(function (r) { return (r.width || 0) <= maxWidth_1; });
    }
    return representations;
}
exports.default = filterByWidth;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFindIndex = __webpack_require__(93);
/**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation}
 */
function fromBitrateCeil(representations, bitrate) {
    var tooHighIndex = arrayFindIndex(representations, function (representation) { return representation.bitrate > bitrate; });
    if (tooHighIndex === -1) {
        return representations[representations.length - 1];
    }
    return representations[tooHighIndex - 1];
}
exports.default = fromBitrateCeil;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(6);
var config_1 = __webpack_require__(4);
var errors_1 = __webpack_require__(8);
var collections_1 = __webpack_require__(262);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(15);
var cleanBuffer_1 = __webpack_require__(263);
var gc_1 = __webpack_require__(264);
var queued_source_buffer_1 = __webpack_require__(265);
var segment_bookkeeper_1 = __webpack_require__(266);
var BITRATE_REBUFFERING_RATIO = config_1.default.BITRATE_REBUFFERING_RATIO;
/**
 * Calculate start and end timestamps of the wanted buffer.
 * @param {TimeRanges} buffered - TimeRanges coming from the concerned
 * SourceBuffer
 * @param {Object} clock
 * @param {Number} bufferGoal
 * @param {Object} paddings
 * @param {Number} paddings.low
 * @param {Number} paddings.high
 * @returns {Object} - Start and end timestamps, in seconds, under an object
 * form with two properties:
 *   - start {Number}
 *   - end {Number}
 */
function getWantedBufferRange(buffered, clock, bufferGoal, paddings) {
    var lowPadding = paddings.low, highPadding = paddings.high;
    var timestamp = clock.currentTime + clock.timeOffset;
    // wantedBufferSize calculates the size of the buffer we want to ensure,
    // taking into account the min between: the set max buffer size, the
    // duration and the live gap.
    var endDiff = (clock.duration || Infinity) - timestamp;
    var wantedBufferSize = Math.max(0, clock.liveGap == null ?
        Math.min(bufferGoal, endDiff) :
        Math.min(bufferGoal, clock.liveGap, endDiff));
    var bufferGap = ranges_1.getLeftSizeOfRange(buffered, timestamp);
    // the ts padding is the time offset that we want to apply to our current
    // timestamp in order to calculate the starting point of the list of
    // segments to inject.
    var timestampPadding = bufferGap > lowPadding && bufferGap < Infinity ?
        Math.min(bufferGap, highPadding) : 0;
    return {
        start: timestamp + timestampPadding,
        end: timestamp + wantedBufferSize,
    };
}
/**
 * Manage a single buffer:
 *   - load the right segments through the downloader on normal playback /
 *     seeking / as the adaptation chosen changes
 *   - add those to the sourceBuffer
 *   - clean up if too much segments have been loaded
 *
 * TODO too many parameters?
 * @param {Object} opt
 * @param {SourceBuffer} opt.sourceBuffer
 * @param {Function} opt.downloader
 * @param {Observable} opt.switch$
 * @param {Observable} opt.clock
 * @param {Observable} opt.wantedBufferAhead
 * @param {Observable} opt.maxBufferBehind
 * @param {Observable} opt.maxBufferAhead
 * @param {string} opt.bufferType
 * @param {Boolean} opt.isLive
 * @returns {Observable}
 */
function Buffer(_a) {
    var sourceBuffer = _a.sourceBuffer, downloader = _a.downloader, switch$ = _a.switch$, clock$ = _a.clock$, wantedBufferAhead = _a.wantedBufferAhead, maxBufferBehind = _a.maxBufferBehind, maxBufferAhead = _a.maxBufferAhead, 
    // TODO Remove that from here
    bufferType = _a.bufferType, // Buffer type (audio, video, text, image)
    isLive = _a.isLive;
    /**
     * Saved state of an init segment to give to the downloader.
     * TODO Re-think that mess for a Buffer refacto.
     */
    var initSegmentInfos = null;
    // will be used to emit messages to the calling function
    var messageSubject = new Subject_1.Subject();
    // safety level (low and high water mark) size of buffer that won't
    // be flushed when switching representation for smooth transitions
    // and avoiding buffer underflows
    var LOW_PADDING = bufferType === "video" ? 4 : 1;
    var HIGH_PADDING = bufferType === "video" ? 6 : 1;
    var bookkeeper = new segment_bookkeeper_1.default();
    var bufferingQueue = new queued_source_buffer_1.default(sourceBuffer);
    /**
     * Returns every segments currently wanted.
     * @param {Object} adaptation - The adaptation concerned (audio/video...)
     * @param {Object} representation - The representation of the chosen
     * adaptation
     * @param {BufferedRanges} buffered - The BufferedRanges of the corresponding
     * sourceBuffer
     * @param {Object} timing - The last item emitted from clock$
     * @param {Number} bufferGoal - The last item emitted from wantedBufferAhead
     * @param {Number} bufferSize - The last item emitted from bufferSize$
     * @param {Boolean} withInitSegment - Whether we're dealing with an init
     * segment.
     * @returns {Array.<Segment>}
     * @throws IndexError - Throws if the current timestamp is considered out
     * of bounds.
     */
    function getSegmentsListToInject(representation, range, timing, withInitSegment) {
        var initSegment = null;
        if (withInitSegment) {
            log_1.default.debug("add init segment", bufferType);
            initSegment = representation.index.getInitSegment();
        }
        if (timing.readyState === 0) {
            return initSegment ? [initSegment] : [];
        }
        var start = range.start, end = range.end;
        var duration = end - start;
        var segments = bookkeeper.inventory.map(function (s) { return s.segment; });
        var shouldRefresh = representation.index.shouldRefresh(segments, start, end);
        if (shouldRefresh) {
            var error = new errors_1.IndexError("OUT_OF_INDEX_ERROR", representation.index.getType(), false);
            messageSubject.next({
                type: "out-of-index",
                value: error,
            });
        }
        // given the current timestamp and the previously calculated time gap and
        // wanted buffer size, we can retrieve the list of segments to inject in
        // our pipelines.
        var mediaSegments = representation.index.getSegments(start, duration);
        if (initSegment) {
            mediaSegments.unshift(initSegment);
        }
        return mediaSegments;
    }
    function createRepresentationBuffer(representation) {
        log_1.default.info("bitrate", bufferType, representation.bitrate);
        var queuedSegments = new collections_1.SimpleSet();
        /**
         * Returns true if it considers that the segment given should be loaded.
         * @param {Segment} segment
         * @param {Object} wantedRange
         * @returns {Boolean}
         */
        function segmentFilter(segment, wantedRange) {
            // if this segment is already in the pipeline
            var isInQueue = queuedSegments.test(segment.id);
            if (isInQueue) {
                return false;
            }
            // segment without time info are usually init segments or some
            // kind of metadata segment that we never filter out
            if (segment.isInit || segment.time < 0) {
                return true;
            }
            var time = segment.time, duration = segment.duration, timescale = segment.timescale;
            if (!duration) {
                return true;
            }
            var currentSegment = bookkeeper.hasPlayableSegment(wantedRange, time, duration, timescale);
            // only re-load comparatively-poor bitrates.
            return !currentSegment ||
                (currentSegment.bitrate * BITRATE_REBUFFERING_RATIO) <
                    representation.bitrate;
        }
        /**
         * Append buffer to the bufferingQueue.
         * If it leads to a QuotaExceededError, try to run our custom range
         * _garbage collector_.
         * @returns {Observable}
         */
        function appendDataInBuffer(pipelineData) {
            var segment = pipelineData.segment, parsed = pipelineData.parsed;
            var segmentData = parsed.segmentData, segmentInfos = parsed.segmentInfos;
            if (segment.isInit) {
                initSegmentInfos = segmentInfos;
            }
            /**
             * Validate the segment downloaded:
             *   - remove from the queued segment to re-allow its download
             *   - insert it in the bufferedRanges object
             */
            function validateSegment() {
                // Note: we should also clean when canceled/errored
                // (TODO do it when canceled?)
                queuedSegments.remove(segment.id);
                if (!segment.isInit) {
                    var _a = segmentInfos ?
                        segmentInfos : segment, time = _a.time, duration = _a.duration, timescale = _a.timescale;
                    // current segment timings informations are used to update
                    // bufferedRanges informations
                    bookkeeper.insert(segment, time / timescale, // start
                    duration != null ? (time + duration) / timescale : undefined, // end
                    representation.bitrate);
                }
            }
            /**
             * Append data in the SourceBuffer if we have it.
             * Emit when done.
             * @returns {Observable}
             */
            function appendSegment() {
                var append$ = segmentData != null ?
                    bufferingQueue.appendBuffer(segmentData) : Observable_1.Observable.of(null);
                return append$.do(validateSegment);
            }
            return appendSegment()
                .catch(function (error) {
                if (!error || error.name !== "QuotaExceededError") {
                    queuedSegments.remove(segment.id);
                    throw new errors_1.MediaError("BUFFER_APPEND_ERROR", error, true);
                }
                return gc_1.default(clock$, bufferingQueue)
                    .mergeMap(appendSegment)
                    .catch(function (error2) {
                    queuedSegments.remove(segment.id);
                    throw new errors_1.MediaError("BUFFER_FULL_ERROR", error2, true);
                });
            }).map(function () { return ({
                type: "pipeline",
                value: objectAssign({ bufferType: bufferType }, pipelineData),
            }); });
        }
        /**
         * Get list of segment to injects.
         * @param {Array} combineLatestResult
         * @param {Number} injectCount
         * @returns {Observable|Array.<Segment>}
         */
        function getNeededSegments(timing, bufferGoal, injectCount) {
            var buffered = bufferingQueue.getBuffered();
            bookkeeper.addBufferedInfos(buffered);
            // send a message downstream when bumping on an explicit
            // discontinuity announced in the segment index.
            if (timing.stalled) {
                if (isLive) {
                    var discontinuity = representation.index.checkDiscontinuity(timing.currentTime);
                    if (discontinuity > 0) {
                        messageSubject.next({
                            type: "index-discontinuity",
                            value: { ts: discontinuity + 1 },
                        });
                    }
                }
            }
            var withInitSegment = (injectCount === 0);
            var wantedRange = getWantedBufferRange(buffered, timing, bufferGoal, {
                low: LOW_PADDING,
                high: HIGH_PADDING,
            });
            log_1.default.debug("calculating segments for wanted range", wantedRange);
            var neededSegments = getSegmentsListToInject(representation, wantedRange, timing, withInitSegment).filter(function (segment) { return segmentFilter(segment, wantedRange); });
            log_1.default.debug("segments needed:", !!neededSegments.length, neededSegments);
            // queue all segments injected in the observable
            for (var i = 0; i < neededSegments.length; i++) {
                queuedSegments.add(neededSegments[i].id);
            }
            return Observable_1.Observable.of.apply(Observable_1.Observable, neededSegments);
        }
        /**
         * @param {Object} segment
         * @returns {Observable}
         */
        function loadNeededSegments(segment) {
            return downloader({ segment: segment, representation: representation, init: initSegmentInfos })
                .map(function (args) { return objectAssign({ segment: segment }, args); });
        }
        function onClockTick(_a, i) {
            var timing = _a[0], _wantedBufferAhead = _a[1], _maxBufferBehind = _a[2], _maxBufferAhead = _a[3];
            var bufferGoal = Math.min(_wantedBufferAhead, _maxBufferAhead);
            var loadNeeded$ = getNeededSegments(timing, bufferGoal, i)
                .concatMap(loadNeededSegments);
            var clean$ = cleanBuffer_1.default(bufferingQueue, timing.currentTime, _maxBufferBehind, _maxBufferAhead);
            return Observable_1.Observable.merge(loadNeeded$, clean$);
        }
        var segmentsPipeline = Observable_1.Observable.combineLatest(clock$, wantedBufferAhead, maxBufferBehind, maxBufferAhead)
            .mergeMap(onClockTick)
            .concatMap(appendDataInBuffer);
        return Observable_1.Observable.merge(segmentsPipeline, messageSubject)
            .catch(function (error) {
            // For live adaptations, handle 412 errors as precondition-
            // failed errors, ie: we are requesting for segments before they
            // exist
            var isPreconditionFailedError = (isLive &&
                error.type === errors_1.ErrorTypes.NETWORK_ERROR &&
                error.isHttpError(412));
            if (!isPreconditionFailedError) {
                throw error;
            }
            // 412 Precondition Failed request errors do not cause the
            // buffer to stop but are re-emitted in the stream as
            // "precondition-failed" type. They should be handled re-
            // adapting the live-gap that the player is holding
            return Observable_1.Observable.of({
                type: "precondition-failed",
                value: error,
            })
                .concat(Observable_1.Observable.timer(2000)
                .mergeMap(function () { return createRepresentationBuffer(representation); }));
        })
            .startWith({
            type: "representationChange",
            value: {
                type: bufferType,
                representation: representation,
            },
        });
    }
    return switch$
        .switchMap(createRepresentationBuffer)
        .finally(function () { return bufferingQueue.dispose(); });
}
exports.Buffer = Buffer;
function EmptyBuffer(_a) {
    var bufferType = _a.bufferType;
    return Observable_1.Observable.of({
        type: "representationChange",
        value: {
            type: bufferType,
            representation: null,
        },
    });
}
exports.EmptyBuffer = EmptyBuffer;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Simple hash-based set.
 * @class SimpleSet
 */
var SimpleSet = /** @class */ (function () {
    function SimpleSet() {
        this._hash = {};
    }
    SimpleSet.prototype.add = function (x) {
        this._hash[x] = true;
    };
    SimpleSet.prototype.remove = function (x) {
        delete this._hash[x];
    };
    SimpleSet.prototype.test = function (x) {
        return !!this._hash[x];
    };
    return SimpleSet;
}());
exports.SimpleSet = SimpleSet;


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(15);
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */
function cleanBuffer(qSourceBuffer, // The type of buffer has no importance here
    position, maxBufferBehind, maxBufferAhead) {
    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
        return Observable_1.Observable.empty();
    }
    var cleanedupRanges = [];
    var _a = ranges_1.getInnerAndOuterTimeRanges(qSourceBuffer.getBuffered(), position), innerRange = _a.innerRange, outerRanges = _a.outerRanges;
    var collectBufferBehind = function () {
        if (!isFinite(maxBufferBehind)) {
            return;
        }
        // begin from the oldest
        for (var i = 0; i < outerRanges.length; i++) {
            var outerRange = outerRanges[i];
            if (position - maxBufferBehind >= outerRange.end) {
                cleanedupRanges.push(outerRange);
            }
            else if (position >= outerRange.end &&
                position - maxBufferBehind > outerRange.start &&
                position - maxBufferBehind < outerRange.end) {
                cleanedupRanges.push({
                    start: outerRange.start,
                    end: position - maxBufferBehind,
                });
            }
        }
        if (innerRange) {
            if (position - maxBufferBehind > innerRange.start) {
                cleanedupRanges.push({
                    start: innerRange.start,
                    end: position - maxBufferBehind,
                });
            }
        }
    };
    var collectBufferAhead = function () {
        if (!isFinite(maxBufferAhead)) {
            return;
        }
        // begin from the oldest
        for (var i = 0; i < outerRanges.length; i++) {
            var outerRange = outerRanges[i];
            if (position + maxBufferAhead <= outerRange.start) {
                cleanedupRanges.push(outerRange);
            }
            else if (position <= outerRange.start &&
                position + maxBufferAhead < outerRange.end &&
                position + maxBufferAhead > outerRange.start) {
                cleanedupRanges.push({
                    start: position + maxBufferAhead,
                    end: outerRange.end,
                });
            }
        }
        if (innerRange) {
            if (position + maxBufferAhead < innerRange.end) {
                cleanedupRanges.push({
                    start: position + maxBufferAhead,
                    end: innerRange.end,
                });
            }
        }
    };
    collectBufferBehind();
    collectBufferAhead();
    var clean$ = Observable_1.Observable.from(cleanedupRanges.map(function (range) {
        log_1.default.info("cleaning range from source buffer", range);
        return qSourceBuffer.removeBuffer(range);
    }))
        .concatAll()
        .ignoreElements();
    return clean$; // ignoreElements == the Observerable never emits
}
exports.default = cleanBuffer;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var config_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(15);
var GC_GAP_CALM = config_1.default.BUFFER_GC_GAPS.CALM;
var GC_GAP_BEEFY = config_1.default.BUFFER_GC_GAPS.BEEFY;
/**
 * Buffer garbage collector algorithm. Tries to free up some part of
 * the ranges that are distant from the current playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Range>} - Ranges selected for clean up
 */
function selectGCedRanges(currentTime, buffered, gcGap) {
    var _a = ranges_1.getInnerAndOuterTimeRanges(buffered, currentTime), innerRange = _a.innerRange, outerRanges = _a.outerRanges;
    var cleanedupRanges = [];
    // start by trying to remove all ranges that do not contain the
    // current time and respect the gcGap
    // respect the gcGap? FIXME?
    for (var i = 0; i < outerRanges.length; i++) {
        var outerRange = outerRanges[i];
        if (currentTime - gcGap < outerRange.end) {
            cleanedupRanges.push(outerRange);
        }
        else if (currentTime + gcGap > outerRange.start) {
            cleanedupRanges.push(outerRange);
        }
    }
    // try to clean up some space in the current range
    if (innerRange) {
        log_1.default.debug("buffer: gc removing part of inner range", cleanedupRanges);
        if (currentTime - gcGap > innerRange.start) {
            cleanedupRanges.push({
                start: innerRange.start,
                end: currentTime - gcGap,
            });
        }
        if (currentTime + gcGap < innerRange.end) {
            cleanedupRanges.push({
                start: currentTime + gcGap,
                end: innerRange.end,
            });
        }
    }
    return cleanedupRanges;
}
/**
 * Run the garbage collector.
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 * @param {Observable} timings$
 * @param {QueuedSourceBuffer} bufferingQueue
 * @returns {Observable}
 */
function launchGarbageCollector(timings$, bufferingQueue // The type of buffer has no importance here
) {
    log_1.default.warn("buffer: running garbage collector");
    // wait for next timing event
    return timings$.take(1).mergeMap(function (timing) {
        var buffered = bufferingQueue.getBuffered();
        var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);
        // more aggressive GC if we could not find any range to clean
        if (cleanedupRanges.length === 0) {
            cleanedupRanges =
                selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);
        }
        log_1.default.debug("buffer: gc cleaning", cleanedupRanges);
        return Observable_1.Observable.from(cleanedupRanges.map(function (range) { return bufferingQueue.removeBuffer(range); })).concatAll();
    });
}
exports.default = launchGarbageCollector;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Subject_1 = __webpack_require__(6);
var log_1 = __webpack_require__(1);
var SourceBufferAction;
(function (SourceBufferAction) {
    SourceBufferAction[SourceBufferAction["Append"] = 0] = "Append";
    SourceBufferAction[SourceBufferAction["Remove"] = 1] = "Remove";
})(SourceBufferAction || (SourceBufferAction = {}));
/**
 * Append/Remove from sourceBuffer in a queue.
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 * @class QueuedSourceBuffer
 */
var QueuedSourceBuffer = /** @class */ (function () {
    /**
     * @constructor
     * @param {SourceBuffer} sourceBuffer
     */
    function QueuedSourceBuffer(sourceBuffer) {
        this._buffer = sourceBuffer;
        this._queue = [];
        this._flushing = null;
        this.__onUpdate = this._onUpdate.bind(this);
        this.__onError = this._onError.bind(this);
        this.__flush = this._flush.bind(this);
        this._buffer.addEventListener("update", this.__onUpdate);
        this._buffer.addEventListener("error", this.__onError);
        this._buffer.addEventListener("updateend", this.__flush);
    }
    /**
     * Append media segment to the attached SourceBuffer, in a FIFO queue.
     * @param {ArrayBuffer} buffer
     * @returns {Observable}
     */
    QueuedSourceBuffer.prototype.appendBuffer = function (buffer) {
        return this._queueAction({
            type: SourceBufferAction.Append,
            args: buffer,
        });
    };
    /**
     * Remove data from the attached SourceBuffer, in a FIFO queue.
     * @param {Object} range
     * @param {Number} range.start - start position, in seconds
     * @param {Number} range.end - end position, in seconds
     * @returns {Observable}
     */
    QueuedSourceBuffer.prototype.removeBuffer = function (_a) {
        var start = _a.start, end = _a.end;
        return this._queueAction({
            type: SourceBufferAction.Remove,
            args: { start: start, end: end },
        });
    };
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    QueuedSourceBuffer.prototype.getBuffered = function () {
        return this._buffer.buffered;
    };
    /**
     * Free up ressources used by this class.
     */
    QueuedSourceBuffer.prototype.dispose = function () {
        this._buffer.removeEventListener("update", this.__onUpdate);
        this._buffer.removeEventListener("error", this.__onError);
        this._buffer.removeEventListener("updateend", this.__flush);
        this._queue.length = 0;
        this._flushing = null;
    };
    /**
     * @private
     * @param {Event} evt
     */
    QueuedSourceBuffer.prototype._onUpdate = function (evt) {
        if (this._flushing) {
            this._flushing.next(evt);
            this._flushing.complete();
            this._flushing = null;
        }
    };
    /**
     * @private
     * @param {Error} error
     */
    QueuedSourceBuffer.prototype._onError = function (error) {
        if (this._flushing) {
            this._flushing.error(error);
            this._flushing = null;
        }
    };
    /**
     * Queue a new action.
     * Begin flushing if no action were previously in the queue.
     * @private
     * @param {string} type
     * @param {*} args
     * @returns {Subject} - Can be used to follow the buffer action advancement.
     */
    QueuedSourceBuffer.prototype._queueAction = function (action) {
        var subj = new Subject_1.Subject();
        var queueElement = objectAssign({ subj: subj }, action);
        var length = this._queue.unshift(queueElement);
        if (length === 1) {
            this._flush();
        }
        return subj;
    };
    /**
     * Perform next queued action if one and none are pending.
     * @private
     */
    QueuedSourceBuffer.prototype._flush = function () {
        if (this._flushing || this._queue.length === 0 || this._buffer.updating) {
            return;
        }
        // TODO TypeScrypt do not get the previous length check? Find solution /
        // open issue
        var queueElement = this._queue.pop();
        this._flushing = queueElement.subj;
        try {
            switch (queueElement.type) {
                case SourceBufferAction.Append:
                    log_1.default.debug("pushing data to source buffer", queueElement.args);
                    this._buffer.appendBuffer(queueElement.args);
                    break;
                case SourceBufferAction.Remove:
                    var _a = queueElement.args, start = _a.start, end = _a.end;
                    log_1.default.debug("removing data from source buffer", start, end);
                    this._buffer.remove(start, end);
                    break;
            }
        }
        catch (e) {
            this._onError(e);
        }
    };
    return QueuedSourceBuffer;
}());
exports.default = QueuedSourceBuffer;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(15);
var takeFirstSet_1 = __webpack_require__(267);
var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config_1.default.MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MAX_BUFFERED_DISTANCE = config_1.default.MAX_BUFFERED_DISTANCE, MINIMUM_SEGMENT_SIZE = config_1.default.MINIMUM_SEGMENT_SIZE;
/**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * downloaded, at which bitrate, and which have been garbage-collected since
 * by the browser (and thus should be re-downloaded).
 *
 * @class SegmentBookkeeper
 */
var SegmentBookkeeper = /** @class */ (function () {
    function SegmentBookkeeper() {
        /**
         * The inventory keep track of all the segments which should be currently
         * in the browser's memory.
         * This array contains objects, each being related to a single downloaded
         * segment which is at least partially added in a source buffer.
         * Those objects have the following keys:
         *
         *   - bitrate {Number}: bitrate of the representation corresponding to
         *     the segment.
         *
         *   - start {Number}: time, in seconds, at which the segment should begin
         *     (parsed from the container or from the Segment Object)
         *
         *   - end {Number}: time, in seconds, at which the segment should end
         *     (parsed from the container or from the Segment Object)
         *
         *   - bufferedStart {Number|undefined}: time, in seconds, at which we infer
         *     the segment currently begin in the sourcebuffer
         *
         *   - bufferedEnd {Number|undefined}: time, in seconds, at which we infer
         *     the segment currently end in the sourcebuffer
         *
         *   - segment {Segment}: the corresponding segment object, as downloaded
         *     from the CDN.
         *
         * @type {Array.<Object>}
         */
        this.inventory = [];
    }
    /**
     * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
     * given (coming from the source buffer).
     * @param {TimeRanges}
     *
     * TODO implement management of segments whose end is not known
     */
    SegmentBookkeeper.prototype.addBufferedInfos = function (buffered) {
        var inventory = this.inventory;
        var ranges = ranges_1.convertToRanges(buffered);
        /**
         * Current inventory index considered.
         * @type {Number}
         */
        var inventoryIndex = 0;
        /**
         * Current segmentInfos considered
         * @type {Object}
         */
        var thisSegment = inventory[0];
        var rangesLength = ranges.length;
        for (var i = 0; i < rangesLength; i++) {
            if (thisSegment == null) {
                // If thisSegment is not set, it means that we arrived at the end of
                // our inventory.
                // This TimeRange do not link to any segment and neither will any
                // subsequent one.
                // (It may be linked to another adaptation, for example)
                return;
            }
            var _a = ranges[i], rangeStart = _a.start, rangeEnd = _a.end;
            // if current TimeRange is too small to contain a segment, go to next one
            if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
                continue;
            }
            /**
             * Inventory index of the last segment not contained in the current range.
             * Will be used to know how many segments have been garbage collected.
             * @type {Number}
             */
            var indexBefore = inventoryIndex;
            // Find the first segment either within this TimeRange or past it:
            // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
            // start of that range.
            while (thisSegment &&
                // TODO better way to indicate to typescript that all is well here
                (takeFirstSet_1.default(thisSegment.bufferedEnd, thisSegment.end)
                    - rangeStart)
                    < MINIMUM_SEGMENT_SIZE) {
                thisSegment = inventory[++inventoryIndex];
            }
            /**
             * Contains the end of the last garbage-collected segment before
             * thisSegment.
             * Might be useful to infer later the bufferedStart of thisSegment.
             *
             * -1 if no segment have been garbage-collected before thisSegment.
             * @type {Number}
             */
            var lastDeletedSegmentEnd = -1;
            // remove garbage-collected segments
            // (not in that TimeRange nor in the previous one)
            var numberOfSegmentToDelete = inventoryIndex - indexBefore;
            if (numberOfSegmentToDelete > 0) {
                // last garbage-collected segment
                var lastDeletedSegment = inventory[indexBefore + numberOfSegmentToDelete - 1];
                // TODO better way to indicate to typescript that all is well here
                lastDeletedSegmentEnd = takeFirstSet_1.default(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);
                // mutate inventory
                inventory.splice(indexBefore, numberOfSegmentToDelete);
                inventoryIndex = indexBefore;
            }
            // if no segment is left for that range (or any other one), quit
            if (thisSegment == null) {
                return;
            }
            // Infer the bufferedStart for this segment, and the bufferedStart and
            // bufferedEnd for the following segments included in that range.
            //
            // If the current segment is actually completely outside that range (it
            // is contained in one of the next one), skip that part.
            if (rangeEnd -
                // TODO better way to indicate to typescript that all is well here
                takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start)
                >= MINIMUM_SEGMENT_SIZE) {
                // set the bufferedStart of the first segment in that range
                if (thisSegment.bufferedStart != null &&
                    thisSegment.bufferedStart < rangeStart) {
                    // the segment appears to have been partially garbage collected:
                    // Update bufferedStart
                    thisSegment.bufferedStart = rangeStart;
                }
                else if (thisSegment.bufferedStart == null) {
                    if (lastDeletedSegmentEnd !== -1 &&
                        lastDeletedSegmentEnd > rangeStart &&
                        thisSegment.start - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE) {
                        thisSegment.bufferedStart = lastDeletedSegmentEnd;
                    }
                    else if (thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE) {
                        thisSegment.bufferedStart = rangeStart;
                    }
                    else {
                        thisSegment.bufferedStart = thisSegment.start;
                    }
                }
                thisSegment = inventory[++inventoryIndex];
                // Make contiguous until first segment outside that range
                // (i.e until the start of the next segment can not constitute a segment
                // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
                while (thisSegment &&
                    (rangeEnd -
                        // TODO better way to indicate to typescript that all is well here
                        takeFirstSet_1.default(thisSegment.bufferedStart, thisSegment.start))
                        >= MINIMUM_SEGMENT_SIZE) {
                    var prevSegment = inventory[inventoryIndex - 1];
                    // those segments are contiguous, we have no way to infer their real
                    // end
                    if (prevSegment.bufferedEnd == null) {
                        prevSegment.bufferedEnd = prevSegment.end;
                    }
                    thisSegment.bufferedStart = prevSegment.bufferedEnd;
                    thisSegment = inventory[++inventoryIndex];
                }
            }
            // update the bufferedEnd of the last segment in that range
            var lastSegmentInRange = inventory[inventoryIndex - 1];
            if (lastSegmentInRange) {
                if (lastSegmentInRange.bufferedEnd != null &&
                    lastSegmentInRange.bufferedEnd > rangeEnd) {
                    // the segment appears to have been partially garbage collected:
                    // Update bufferedEnd
                    lastSegmentInRange.bufferedEnd = rangeEnd;
                }
                else if (lastSegmentInRange.bufferedEnd == null) {
                    lastSegmentInRange.bufferedEnd =
                        rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE ?
                            rangeEnd : lastSegmentInRange.end;
                }
            }
        }
        // if we still have segments left, they are not affiliated to any range.
        // They might have been garbage collected, delete them from here.
        if (thisSegment) {
            inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
        }
    };
    /**
     * Add a new segment in the inventory.
     *
     * Note: As new segments can "replace" partially or completely old ones, we
     * have to perform a complex logic and might update previously added segments.
     *
     * @param {Segment} segment
     * @param {Number} start - start time of the segment, in seconds
     * @param {Number|undefined} end - end time of the segment, in seconds. Can
     * be undefined in some rare cases
     * @param {Number} bitrate - bitrate of the representation the segment is in
     */
    SegmentBookkeeper.prototype.insert = function (segment, start, end, bitrate) {
        // TODO (*very* low-priority) manage segments whose end is unknown (rare but
        // could eventually happen).
        // This should be properly managed in this method, but it is not in some
        // other methods of this class, so I decided to not one of those to the
        // inventory by security
        if (false) {
            throw new Error("SegmentBookkeeper: ending time of the segment not defined");
        }
        else if (end == null) {
            // This leads to excessive re-downloads of segment without an ending time.
            return;
        }
        var inventory = this.inventory;
        // infer start and end from the segment data
        // /!\ Can be a little different than their real start/end time in the
        // sourcebuffer.
        // const start = segment.time / segment.timescale;
        // const end = (segment.time + segment.duration) / segment.timescale;
        var newSegment = {
            bitrate: bitrate,
            start: start,
            end: end,
            bufferedStart: undefined,
            bufferedEnd: undefined,
            segment: segment,
        };
        // begin by the end as in most use cases this will be faster
        for (var i = inventory.length - 1; i >= 0; i--) {
            var segmentI = inventory[i];
            if ((segmentI.start /* - SEGMENT_EPSILON */) <= start) {
                if ((segmentI.end /* - SEGMENT_EPSILON */) <= start) {
                    // our segment is after, push it after this one
                    //
                    // Case 1:
                    //   segmentI     : |------|
                    //   newSegment   :        |------|
                    //
                    // Case 2:
                    //   segmentI     : |------|
                    //   newSegment   :          |------|
                    this.inventory.splice(i + 1, 0, newSegment);
                    return;
                }
                else {
                    if (segmentI.start >= (start /* - SEGMENT_EPSILON */)) {
                        // In those cases, replace
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   : |-------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   : |----------|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   : |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   : |------|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   : |???*
                        //
                        // *|??? - unknown end
                        this.inventory.splice(i, 1, newSegment);
                        return;
                    }
                    else {
                        // our segment has a "complex" relation with this one,
                        // update the old one end and add this one after it.
                        //
                        // Case 1:
                        //  segmentI     : |-------|
                        //  newSegment   :    |------|
                        //
                        // Case 2:
                        //  segmentI     : |-------|
                        //  newSegment   :    |----|
                        //
                        // Case 3:
                        //  segmentI     : |-------|
                        //  newSegment   :    |???*
                        //
                        // Case 4:
                        //  segmentI     : |???*
                        //  newSegment   :    |----|
                        //
                        // Case 5:
                        //  segmentI     : |???*
                        //  newSegment   :    |???*
                        //
                        // *|??? - unknown end
                        // (if segment's end is not known yet, it could perfectly
                        // end before the one we're adding now)
                        if (segmentI.end != null) {
                            segmentI.end = start;
                        }
                        this.inventory.splice(i + 1, 0, newSegment);
                        return;
                    }
                }
            }
        }
        // if we got here, we are the first segment
        // check bounds of the previous first segment
        var firstSegment = this.inventory[0];
        if (!firstSegment) {
            this.inventory.push(newSegment);
            return;
        }
        if (end == null) {
            if (firstSegment.start === start) {
                // same beginning, unknown end, just replace
                // Case 1:
                //  firstSegment : |-------|
                //  newSegment   : |???*
                //
                // Case 2:
                //  firstSegment : |???*
                //  newSegment   : |???*
                //
                // *|??? - unknown end
                this.inventory.splice(0, 1, newSegment);
            }
            else {
                // our segment begins before this one, push at the beginning
                // Case 1:
                // firstSegment :   |-------|
                // newSegment   : |???*
                //
                // Case 2:
                // firstSegment :   |???*
                // newSegment   : |???*
                //
                // *|??? - unknown end
                this.inventory.splice(0, 0, newSegment);
            }
            return;
        }
        if (firstSegment.start >= end) {
            // our segment is before, put it before
            // Case 1:
            //  firstSegment :      |----|
            //  newSegment   : |----|
            //
            // Case 2:
            //  firstSegment :        |----|
            //  newSegment   : |----|
            //
            // Case 3:
            //  firstSegment :        |???*
            //  newSegment   : |----|
            //
            // Case 4:
            //  firstSegment :      |???*
            //  newSegment   : |----|
            //
            // *|??? - unknown end
            this.inventory.splice(0, 0, newSegment);
        }
        else if ((firstSegment.end /* - SEGMENT_EPSILON */) <= end) {
            // Our segment is bigger, replace the first
            // Case 1:
            //  firstSegment :   |---|
            //  newSegment   : |-------|
            //
            // Case 2:
            //  firstSegment :   |-----|
            //  newSegment   : |-------|
            this.inventory.splice(0, 1, newSegment);
        }
        else {
            // our segment has a "complex" relation with the first one,
            // update the old one start and add this one before it.
            // Case 1:
            //  firstSegment :    |------|
            //  newSegment   : |------|
            //
            // Case 2:
            // firstSegment :   |???*
            // newSegment   : |-----|
            //
            // *|??? - unknown end
            firstSegment.start = end;
            this.inventory.splice(0, 0, newSegment);
        }
    };
    /**
     * Returns segment infos for a segment corresponding to the given time,
     * duration and timescale.
     *
     * Returns null if either:
     *   - no segment can be linked exactly to the given time/duration
     *   - a segment is linked to this information, but is currently considered
     *     "incomplete" to be playable, in the sourceBuffer. We check if all
     *     needed data for playback (from wanted range) is loaded.
     *
     * The main purpose of this method is to know if the segment asked should be
     * downloaded (or re-downloaded).
     *
     * /!\ Make sure that this class is synchronized with the sourceBuffer
     * (see addBufferedInfos method of the same class) before calling this method,
     * as it depends on it to categorize "incomplete" from "complete" segments.
     *
     * @param {Object} wantedRange
     * @param {Number} time
     * @param {Number} duration
     * @param {Number} timescale
     * @returns {Object|null}
     */
    SegmentBookkeeper.prototype.hasPlayableSegment = function (wantedRange, time, duration, timescale) {
        var inventory = this.inventory;
        for (var i = inventory.length - 1; i >= 0; i--) {
            var currentSegmentI = inventory[i];
            var prevSegmentI = inventory[i - 1];
            var nextSegmentI = inventory[i + 1];
            var segment = currentSegmentI.segment;
            var _time = time;
            var _duration = duration;
            if (segment.timescale !== timescale) {
                // Note: we could get rounding errors here
                _time = (time * segment.timescale) / timescale;
                _duration = (duration * segment.timescale) / timescale;
            }
            if (segment.time === _time && segment.duration === _duration) {
                // false negatives are better than false positives here.
                // When impossible to know, say the segment is not complete
                if (hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI)) {
                    if (hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) {
                        return currentSegmentI;
                    }
                }
            }
        }
        return null;
        // -- Helpers
        /*
         * Check if segment can be evaluated.
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */
        function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
            if ((prevSegmentI && prevSegmentI.bufferedEnd == null) ||
                currentSegmentI.bufferedStart == null) {
                return false;
            }
            if ((nextSegmentI && nextSegmentI.bufferedStart == null) ||
                currentSegmentI.bufferedEnd == null) {
                return false;
            }
            return true;
        }
        /* Returns true if the segment given can be played for the wanted range.
         * @param {Object} _wantedRange
         * @param {Object} currentSegmentI
         * @param {Object} prevSegmentI
         * @param {Object} nextSegmentI
         * @returns {Boolean}
         */
        function hasWantedRange(_wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
            if (!prevSegmentI ||
                prevSegmentI.bufferedEnd == null ||
                currentSegmentI.bufferedStart == null ||
                prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
                if (currentSegmentI.bufferedStart == null) {
                    return false;
                }
                var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
                if (_wantedRange.start > currentSegmentI.start) {
                    var wantedDiff = currentSegmentI.bufferedStart - _wantedRange.start;
                    if (wantedDiff > 0 && timeDiff
                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
                else {
                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
            }
            if (currentSegmentI.end === null) {
                return false;
            }
            else if (!nextSegmentI ||
                nextSegmentI.bufferedStart == null ||
                currentSegmentI.bufferedEnd == null ||
                nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
                if (currentSegmentI.bufferedEnd == null) {
                    return false;
                }
                var timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
                if (_wantedRange.end < currentSegmentI.end) {
                    var wantedDiff = _wantedRange.end - currentSegmentI.bufferedEnd;
                    if (wantedDiff > 0 && timeDiff
                        > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
                else {
                    if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
                        log_1.default.debug("The wanted segment has been garbage collected", currentSegmentI);
                        return false;
                    }
                }
            }
            return true;
        }
    };
    return SegmentBookkeeper;
}());
exports.default = SegmentBookkeeper;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */
function takeFirstSet() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var i = 0;
    var len = args.length;
    while (i < len) {
        if (args[i] != null) {
            return args[i];
        }
        i++;
    }
}
exports.default = takeFirstSet;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * TODO That file here should be progressively removed:
 *   - the net directory contains transport utils which include manifest
 *     parsers.
 *
 *   - the manifest directory defines a common class for manifest and sub-parts
 *     of a manifest.
 *
 * The best may be to have what is returned by net directly fed to the
 * instanciation of the manifest class.
 *
 * Due to that, some parts should be moved to net/, other to manifest/.
 *
 * Kept for now, as it just werks, but this might become a problem for
 * maintability and future evolutions.
 */
var arrayFind = __webpack_require__(17);
var array_includes_1 = __webpack_require__(9);
var compat_1 = __webpack_require__(5);
var errors_1 = __webpack_require__(8);
var manifest_1 = __webpack_require__(269);
var languages_1 = __webpack_require__(34);
var log_1 = __webpack_require__(1);
var url_1 = __webpack_require__(23);
/**
 * Representation keys directly inherited from the adaptation.
 * If any of those keys are in an adaptation but not in one of its
 * representation, it will be inherited.
 */
var representationBaseType = [
    "audioSamplingRate",
    "codecs",
    "codingDependency",
    "frameRate",
    "height",
    "index",
    "maxPlayoutRate",
    "maximumSAPPeriod",
    "mimeType",
    "profiles",
    "segmentProfiles",
    "width",
];
var uniqueId = 0;
var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];
/**
 * @param {Object}
 * @returns {string}
 */
function parseBaseURL(manifest) {
    var baseURL = url_1.normalizeBaseURL(manifest.locations[0]);
    var period = manifest.periods[0];
    if (period && period.baseURL) {
        return url_1.resolveURL(baseURL, period.baseURL);
    }
    return baseURL;
}
/**
 * @param {string} url - the manifest's url
 * @param {Object} manifest - the parsed manifest
 * @param {Array.<Object>|Object} externalTextTracks - Will be added to the
 * manifest as an adaptation.
 * @param {Array.<Object>|Object} externalImageTracks - Will be added to the
 * manifest as an adaptation.
 *
 * @throws MediaError - throw if the manifest has no transportType set
 * @throws MediaError - Throws if one of the periods has no id property defined
 *
 * @throws MediaError - Throws if one of the periods has no adaptation in the
 * types understood by the RxPlayer
 *
 * @throws MediaError - Throws if one of the periods has no representation in a
 * codec supported by the browser
 *
 * @throws MediaError - Throws if one of the adaptations has no id property
 * defined
 *
 * @throws MediaError - Throws if one of the adaptations does not have any type
 *
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object}
 */
function normalizeManifest(url, manifest, externalTextTracks, externalImageTracks) {
    // transportType == "smooth"|"dash"
    if (!manifest.transportType) {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    // TODO cleaner ID
    manifest.id = manifest.id || "gen-manifest-" + uniqueId++;
    // "static"|"dynamic"
    manifest.type = manifest.type || "static";
    manifest.isLive = manifest.type === "dynamic";
    var locations = manifest.locations;
    if (!locations || !locations.length) {
        manifest.locations = [url];
    }
    var rootURL = parseBaseURL(manifest);
    // TODO(pierre): support multi-locations/cdns
    var inherit = {
        rootURL: rootURL,
        baseURL: manifest.baseURL,
        // than manifest.periods[0].baseURL?
        // TODO needed for inheritance?
        isLive: manifest.isLive,
    };
    var periods = manifest.periods.map(function (period) {
        return normalizePeriod(period, inherit, externalTextTracks, externalImageTracks);
    });
    // TODO(pierre): support multiple periods
    var finalManifest = assignAndClone(manifest, periods[0]);
    finalManifest.periods = null;
    if (!finalManifest.duration) {
        finalManifest.duration = Infinity;
    }
    if (finalManifest.isLive) {
        finalManifest.suggestedPresentationDelay =
            finalManifest.suggestedPresentationDelay || 0;
        finalManifest.availabilityStartTime = finalManifest.availabilityStartTime || 0;
    }
    return new manifest_1.default(finalManifest);
}
exports.normalizeManifest = normalizeManifest;
/**
 * @param {Object} period
 * @param {Object} inherit
 * @param {Array.<Object>|Object} [addedTextTracks]
 * @param {Array.<Object>|Object} [addedImageTracks]
 *
 * @throws MediaError - Throws if the period has no id property defined
 *
 * @throws MediaError - Throws if the period has no adaptation in the types
 * understood by the RxPlayer
 *
 * @throws MediaError - Throws if the period has no representation in a codec
 * supported by the browser
 *
 * @throws MediaError - Throws if one of the adaptations has no id property
 * defined
 *
 * @throws MediaError - Throws if one of the adaptations does not have any type
 *
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object} period
 */
function normalizePeriod(period, inherit, externalTextTracks, externalImageTracks) {
    if (typeof period.id === "undefined") {
        // TODO cleaner ID
        period.id = "gen-period-" + uniqueId++;
        // TODO Generate ID higher and throw here?
        // throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    var adaptations = period.adaptations
        .map(function (adaptation) {
        return normalizeAdaptation(adaptation, inherit);
    });
    if (externalTextTracks) {
        adaptations.push.apply(adaptations, normalizeSupplementaryTextTracks(externalTextTracks)
            .map(function (adaptation) { return normalizeAdaptation(adaptation, inherit); }));
    }
    if (externalImageTracks) {
        adaptations.push.apply(adaptations, normalizeSupplementaryImageTracks(externalImageTracks)
            .map(function (adaptation) { return normalizeAdaptation(adaptation, inherit); }));
    }
    // filter out adaptations from unsupported types
    var filteredAdaptations = adaptations.filter(function (adaptation) {
        if (SUPPORTED_ADAPTATIONS_TYPE.indexOf(adaptation.type) < 0) {
            log_1.default.info("not supported adaptation type", adaptation.type);
            return false;
        }
        else {
            return true;
        }
    });
    if (filteredAdaptations.length === 0) {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    var adaptationsByType = {};
    // construct adaptationsByType object
    for (var i = 0; i < filteredAdaptations.length; i++) {
        var adaptation = filteredAdaptations[i];
        var adaptationReps = adaptation.representations;
        var adaptationType = adaptation.type;
        if (!adaptationsByType[adaptationType]) {
            adaptationsByType[adaptationType] = [];
        }
        // only keep adaptations that have at least one representation
        if (adaptationReps.length > 0) {
            adaptationsByType[adaptationType].push(adaptation);
        }
    }
    // TODO Throwing this way is ugly and could not work with future improvements
    // Find better way to really detect if the codecs are incompatible
    for (var adaptationType in adaptationsByType) {
        if (adaptationsByType[adaptationType].length === 0) {
            throw new errors_1.MediaError("MANIFEST_INCOMPATIBLE_CODECS_ERROR", null, true);
        }
    }
    period.adaptations = adaptationsByType;
    return period;
}
/**
 * TODO perform some cleanup like adaptations.index (indexes are
 * in the representations)
 *
 * @param {Object} initialAdaptation
 * @param {Object} inherit
 *
 * @throws MediaError - Throws if the adaptation has no id property defined
 * @throws MediaError - Throws if the adaptation does not have any type
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object} adaptation
 */
function normalizeAdaptation(initialAdaptation, inherit) {
    if (typeof initialAdaptation.id === "undefined") {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    var adaptation = assignAndClone(inherit, initialAdaptation);
    // representations in this adaptation will inherit the props of this object
    var toInheritFromAdaptation = {};
    representationBaseType.forEach(function (baseType) {
        if (baseType in adaptation) {
            toInheritFromAdaptation[baseType] = adaptation[baseType];
        }
    });
    var representations = adaptation.representations
        .map(function (representation) {
        return normalizeRepresentation(representation, toInheritFromAdaptation, adaptation.rootURL, adaptation.baseURL);
    }).sort(function (a, b) {
        return a.bitrate - b.bitrate;
    } // bitrate ascending
    );
    var type = adaptation.type, _a = adaptation.accessibility, accessibility = _a === void 0 ? [] : _a;
    if (!type) {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    switch (type) {
        case "video":
        case "audio":
            representations = representations
                .filter(function (representation) { return compat_1.isCodecSupported(getCodec(representation)); });
            if (type === "audio") {
                var isAudioDescription = array_includes_1.default(accessibility, "visuallyImpaired");
                adaptation.audioDescription = isAudioDescription;
            }
            break;
        case "text":
            var isHardOfHearing = array_includes_1.default(accessibility, "hardOfHearing");
            adaptation.closedCaption = isHardOfHearing;
            break;
    }
    adaptation.representations = representations;
    adaptation.bitrates = representations.map(function (rep) { return rep.bitrate; });
    return adaptation;
}
/**
 * @param {Object} initialRepresentation
 * @param {Object} inherit
 * @param {string} [rootURL]
 * @param {string} [baseURL]
 *
 * @throws MediaError - Throws if the representation has no id property defined
 *
 * @returns {Object}
 */
function normalizeRepresentation(initialRepresentation, inherit, rootURL, baseURL) {
    if (typeof initialRepresentation.id === "undefined") {
        throw new errors_1.MediaError("MANIFEST_PARSE_ERROR", null, true);
    }
    var representation = assignAndClone(inherit, initialRepresentation);
    if (!representation.index) {
        // if we have no index, it must mean the whole file is directly accessible
        // as is. Simulate a "template" for now as it is the most straightforward.
        // TODO own indexType
        representation.index = {
            indexType: "template",
            duration: Number.MAX_VALUE,
            timescale: 1,
            startNumber: 0,
        };
    }
    else if (!representation.index.timescale) {
        representation.index.timescale = 1;
    }
    if (representation.bitrate == null) {
        representation.bitrate = 1;
    }
    else if (representation.bitrate === 0) {
        log_1.default.warn("One of your representation has an invalid bitrate of 0.");
    }
    // Fix issue in some packagers, like GPAC, generating a non
    // compliant mimetype with RFC 6381. Other closed-source packagers
    // may be impacted.
    if (representation.codecs === "mp4a.40.02") {
        representation.codecs = "mp4a.40.2";
    }
    representation.baseURL = url_1.resolveURL(rootURL, baseURL, representation.baseURL);
    representation.codec = representation.codecs;
    return representation;
}
/**
 * Normalize text tracks Object/Array to a normalized manifest adaptation.
 * @param {Array.<Object>|Object} subtitles
 * @returns {Array.<Object>}
 */
function normalizeSupplementaryTextTracks(textTracks) {
    var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
    return _textTracks.reduce(function (allSubs, _a) {
        var mimeType = _a.mimeType, codecs = _a.codecs, url = _a.url, language = _a.language, languages = _a.languages, closedCaption = _a.closedCaption;
        var langsToMapOn = language ? [language] : languages || [];
        return allSubs.concat(langsToMapOn.map(function (_language) { return ({
            // TODO cleaner ID
            id: "gen-text-ada-" + uniqueId++,
            // TODO open a TypeScript issue?
            type: "text",
            language: _language,
            normalizedLanguage: languages_1.normalize(_language),
            accessibility: closedCaption ? ["hardOfHearing"] : [],
            baseURL: url,
            manuallyAdded: true,
            representations: [{
                    // TODO cleaner ID
                    id: "gen-text-rep-" + uniqueId++,
                    mimeType: mimeType,
                    codecs: codecs,
                    index: {
                        indexType: "template",
                        duration: Number.MAX_VALUE,
                        timescale: 1,
                        startNumber: 0,
                    },
                }],
        }); }));
    }, []);
}
/**
 * Normalize image tracks Object/Array to a normalized manifest adaptation.
 * @param {Array.<Object>|Object} images
 * @returns {Array.<Object>}
 */
function normalizeSupplementaryImageTracks(imageTracks) {
    var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
    return _imageTracks.map(function (_a) {
        var mimeType = _a.mimeType, url = _a.url /*, size */;
        return {
            id: "gen-image-ada-" + uniqueId++,
            type: "image",
            baseURL: url,
            manuallyAdded: true,
            representations: [{
                    id: "gen-image-rep-" + uniqueId++,
                    mimeType: mimeType,
                    index: {
                        indexType: "template",
                        duration: Number.MAX_VALUE,
                        timescale: 1,
                        startNumber: 0,
                    },
                }],
        };
    });
}
function assignAndClone() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var res = {};
    for (var i = args.length - 1; i >= 0; i--) {
        var arg = args[i];
        for (var attr in arg) {
            if (res.hasOwnProperty(attr)) {
                continue;
            }
            var val = arg[attr];
            if (val && typeof val === "object") {
                if (val instanceof Date) {
                    res[attr] = new Date(val.getTime());
                }
                else if (Array.isArray(val)) {
                    res[attr] = val.slice(0);
                }
                else {
                    res[attr] = assignAndClone(val);
                }
            }
            else {
                res[attr] = val;
            }
        }
    }
    return res;
}
// TODO Check and re-check the id thing
function updateManifest(oldManifest, newManifest) {
    var oldAdaptations = oldManifest.getAdaptations();
    var newAdaptations = newManifest.getAdaptations();
    var _loop_1 = function (i) {
        var newAdaptation = arrayFind(newAdaptations, function (a) { return a.id === oldAdaptations[i].id; });
        if (!newAdaptation) {
            log_1.default.warn("manifest: adaptation \"" + oldAdaptations[i].id + "\" not found when merging.");
        }
        else {
            var oldRepresentations_1 = oldAdaptations[i].representations;
            var newRepresentations = newAdaptation.representations;
            var _loop_2 = function (j) {
                var newRepresentation = arrayFind(newRepresentations, function (r) { return r.id === oldRepresentations_1[j].id; });
                if (!newRepresentation) {
                    /* tslint:disable:max-line-length */
                    log_1.default.warn("manifest: representation \"" + oldRepresentations_1[j].id + "\" not found when merging.");
                    /* tslint:enable:max-line-length */
                }
                else {
                    oldRepresentations_1[j].index.update(newRepresentation.index);
                }
            };
            for (var j = 0; j < oldRepresentations_1.length; j++) {
                _loop_2(j);
            }
        }
    };
    for (var i = 0; i < oldAdaptations.length; i++) {
        _loop_1(i);
    }
    return oldManifest;
}
exports.updateManifest = updateManifest;
/**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */
function getCodec(representation) {
    var _a = representation.codec, codec = _a === void 0 ? "" : _a, _b = representation.mimeType, mimeType = _b === void 0 ? "" : _b;
    return mimeType + ";codecs=\"" + codec + "\"";
}
exports.getCodec = getCodec;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
var assert_1 = __webpack_require__(2);
var id_1 = __webpack_require__(51);
var adaptation_1 = __webpack_require__(270);
/**
 * Normalized Manifest structure.
 *
 * API Public Properties:
 *   - id {string|Number}
 *   - adaptations {Object}:
 *       adaptations.video {[]Adaptation|undefined}
 *       adaptations.audio {[]Adaptation|undefined}
 *       adaptations.text {[]Adaptation|undefined}
 *       adaptations.image {[]Adaptation|undefined}
 *   - periods {[]Object} TODO
 *   - isLive {Boolean}
 *   - uris {[]string}
 *   - transport {string}
 *
 * API Public Methods:
 *   - getDuration () => {Number} - Returns duration of the entire content, in s
 */
var Manifest = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} [args={}]
     * @param {string|Number} [args.id]
     * @param {string} args.transportType
     * @param {Array.<Object>} args.adaptations
     * @param {string} args.type
     * @param {Array.<string>} args.locations
     * @param {Number} args.duration
     */
    function Manifest(args) {
        var nId = id_1.default();
        this.id = args.id == null ? nId : "" + args.id;
        this.transport = args.transportType || "";
        this.adaptations =
            Object.keys(args.adaptations).reduce(function (acc, val) {
                acc[val] = (args.adaptations[val] || [])
                    .map(function (a) { return new adaptation_1.default(a); });
                return acc;
            }, {}) || [];
        // TODO Real period management
        this.periods = [
            {
                adaptations: this.adaptations,
            },
        ];
        this.isLive = args.type === "dynamic";
        this.uris = args.locations || [];
        // --------- private data
        this._duration = args.duration;
        // Will be needed here
        this.suggestedPresentationDelay = args.suggestedPresentationDelay;
        this.availabilityStartTime = args.availabilityStartTime;
        this.presentationLiveGap = args.presentationLiveGap;
        this.timeShiftBufferDepth = args.timeShiftBufferDepth;
        if (false) {
            assert_1.default(this.suggestedPresentationDelay != null);
            assert_1.default(this.availabilityStartTime != null);
            assert_1.default(this.presentationLiveGap != null);
            assert_1.default(this.timeShiftBufferDepth != null);
        }
    }
    /**
     * @returns {Number}
     */
    Manifest.prototype.getDuration = function () {
        return this._duration;
    };
    Manifest.prototype.getUrl = function () {
        return this.uris[0];
    };
    /**
     * @returns {Array.<Object>}
     */
    Manifest.prototype.getAdaptations = function () {
        var adaptationsByType = this.adaptations;
        if (!adaptationsByType) {
            return [];
        }
        var adaptationsList = [];
        for (var adaptationType in adaptationsByType) {
            if (adaptationsByType.hasOwnProperty(adaptationType)) {
                var adaptations = adaptationsByType[adaptationType];
                adaptationsList.push.apply(adaptationsList, adaptations);
            }
        }
        return adaptationsList;
    };
    Manifest.prototype.getAdaptationsForType = function (adaptationType) {
        var adaptations = this.adaptations[adaptationType];
        return adaptations || [];
    };
    Manifest.prototype.getAdaptation = function (wantedId) {
        return arrayFind(this.getAdaptations(), function (_a) {
            var id = _a.id;
            return wantedId === id;
        });
    };
    Manifest.prototype.updateLiveGap = function (delta) {
        if (this.isLive) {
            if (this.presentationLiveGap) {
                this.presentationLiveGap += delta;
            }
            else {
                this.presentationLiveGap = delta;
            }
        }
    };
    return Manifest;
}());
exports.default = Manifest;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
var objectAssign = __webpack_require__(7);
var id_1 = __webpack_require__(51);
var representation_1 = __webpack_require__(271);
/**
 * Normalized Adaptation structure.
 * @class Adaptation
 */
var Adaptation = /** @class */ (function () {
    /**
     * @constructor
     */
    function Adaptation(args) {
        var _this = this;
        var nId = id_1.default();
        this.id = args.id == null ? nId : "" + args.id;
        this.type = args.type;
        this.representations = Array.isArray(args.representations) ?
            args.representations
                .map(function (r) { return new representation_1.default(objectAssign({ rootId: _this.id }, r)); })
                .sort(function (a, b) { return a.bitrate - b.bitrate; }) : [];
        if (args.language != null) {
            this.language = args.language;
        }
        if (args.normalizedLanguage != null) {
            this.normalizedLanguage = args.normalizedLanguage;
        }
        if (args.closedCaption != null) {
            this.isClosedCaption = args.closedCaption;
        }
        if (args.audioDescription != null) {
            this.isAudioDescription = args.audioDescription;
        }
        // TODO rename both protectionData?
        if (args.contentProtection != null) {
            this.contentProtection = args.contentProtection;
        }
        if (args.smoothProtection != null) {
            this._smoothProtection = args.smoothProtection;
        }
        // for manuallyAdded adaptations (not in the manifest)
        this.manuallyAdded = !!args.manuallyAdded;
        // ---------
        // this._rootURL = args.rootURL;
        // this._baseURL = args.baseURL;
    }
    /**
     * @returns {Array.<Number>}
     */
    Adaptation.prototype.getAvailableBitrates = function () {
        return this.representations
            .map(function (r) { return r.bitrate; });
    };
    /**
     * @param {Number|string} wantedId
     * @returns {Representation}
     */
    Adaptation.prototype.getRepresentation = function (wantedId) {
        return arrayFind(this.representations, function (_a) {
            var id = _a.id;
            return wantedId === id;
        });
    };
    /**
     * @param {Number} bitrate
     * @returns {Representations[]|null}
     */
    Adaptation.prototype.getRepresentationsForBitrate = function (bitrate) {
        return this.representations.filter(function (r) { return r.bitrate === bitrate; }) || null;
    };
    return Adaptation;
}());
exports.default = Adaptation;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var id_1 = __webpack_require__(51);
var representation_index_1 = __webpack_require__(272);
/**
 * Normalized Representation structure.
 * @class Representation
 */
var Representation = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} [args={}]
     * @param {string|Number} [args.id]
     * @param {Number} args.bitrate
     * @param {string} args.codecs
     * @param {Number} args.height
     * @param {Number} args.width
     * @param {string} args.mimeType
     * @param {Object} args.index
     */
    function Representation(args) {
        var nId = id_1.default();
        this.id = (args.id == null ? nId : args.id);
        this.bitrate = args.bitrate;
        this.codec = args.codecs;
        if (args.height != null) {
            this.height = args.height;
        }
        if (args.width != null) {
            this.width = args.width;
        }
        if (args.mimeType != null) {
            this.mimeType = args.mimeType;
        }
        this.index = new representation_index_1.default({
            index: args.index,
            rootId: this.id,
        });
        this.baseURL = args.baseURL;
        // Most of those are for the smooth init segment
        if (args.codecPrivateData != null) {
            this._codecPrivateData = args.codecPrivateData;
        }
        if (args.channels != null) {
            this._channels = args.channels;
        }
        if (args.bitsPerSample != null) {
            this._bitsPerSample = args.bitsPerSample;
        }
        if (args.packetSize != null) {
            this._packetSize = args.packetSize;
        }
        if (args.samplingRate != null) {
            this._samplingRate = args.samplingRate;
        }
        // this._audioSamplingRate = args.audioSamplingRate;
        // this._codingDependency = args.codingDependency;
        // this._frameRate = args.frameRate;
        // this._maxPlayoutRate = args.maxPlayoutRate;
        // this._maximumSAPPeriod = args.maximumSAPPeriod;
        // this._profiles = args.profiles;
        // this._segmentProfiles = args.segmentProfiles;
    }
    return Representation;
}());
exports.default = Representation;


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = __webpack_require__(273);
var RepresentationIndex = /** @class */ (function () {
    /**
     * @constructor
     * @param {Object} args
     * @param {Object} args.index
     * @param {string|Number} args.rootId
     */
    function RepresentationIndex(args) {
        this._index = args.index;
        this._rootId = args.rootId;
        this._indexHelpers = index_1.default(this._index);
    }
    RepresentationIndex.prototype.getInitSegment = function () {
        return this._indexHelpers.getInitSegment(this._rootId, this._index);
    };
    RepresentationIndex.prototype.getSegments = function (up, duration) {
        return this._indexHelpers.getSegments(this._rootId, this._index, up, duration);
    };
    RepresentationIndex.prototype.shouldRefresh = function (parsedSegments, up, to) {
        return this._indexHelpers.shouldRefresh(this._index, parsedSegments, up, to);
    };
    RepresentationIndex.prototype.getFirstPosition = function () {
        return this._indexHelpers.getFirstPosition(this._index);
    };
    RepresentationIndex.prototype.getLastPosition = function () {
        return this._indexHelpers.getLastPosition(this._index);
    };
    RepresentationIndex.prototype.checkDiscontinuity = function (time) {
        return this._indexHelpers.checkDiscontinuity(this._index, time);
    };
    /**
     * Returns time given scaled into seconds.
     * @param {Number} time
     * @returns {Number}
     */
    RepresentationIndex.prototype.scale = function (time) {
        return this._indexHelpers.scale(this._index, time);
    };
    /**
     * Update the timescale used (for all segments).
     * @param {Number} timescale
     */
    RepresentationIndex.prototype.setTimescale = function (timescale) {
        return this._indexHelpers.setTimescale(this._index, timescale);
    };
    RepresentationIndex.prototype._addSegments = function (nextSegments, currentSegment) {
        var addedSegments = [];
        for (var i = 0; i < nextSegments.length; i++) {
            if (this._indexHelpers._addSegmentInfos(this._index, nextSegments[i], currentSegment)) {
                addedSegments.push(nextSegments[i]);
            }
        }
        return addedSegments;
    };
    RepresentationIndex.prototype.update = function (newIndex /* TODO @ index refacto */) {
        this._index = newIndex._index;
    };
    RepresentationIndex.prototype.getType = function () {
        return this._index.indexType || "";
    };
    return RepresentationIndex;
}());
exports.default = RepresentationIndex;


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var indexes = {};
/* tslint:disable no-var-requires */
if (true) {
    indexes.smooth = __webpack_require__(274).default;
}
if (true) {
    indexes.timeline = __webpack_require__(52).default;
    indexes.template = __webpack_require__(275).default;
    indexes.list = __webpack_require__(276).default;
    indexes.base = __webpack_require__(277).default;
}
/* tslint:enable no-var-requires */
/**
 * Indexes have multiple "flavors" depending on the manifest concerned.
 * Here we returns the helpers best adapted to the given index.
 * @param {Object} index
 * @returns {Object|undefined}
 */
function getRightIndexHelpers(index) {
    return indexes[index.indexType];
}
exports.default = getRightIndexHelpers;


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(30);
var timeline_1 = __webpack_require__(52);
exports.default = {
    getSegments: timeline_1.default.getSegments,
    getInitSegment: helpers_1.getInitSegment,
    checkDiscontinuity: timeline_1.default.checkDiscontinuity,
    _addSegmentInfos: timeline_1.default._addSegmentInfos,
    setTimescale: helpers_1.setTimescale,
    scale: helpers_1.scale,
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Object} index
     * @param {Number} time
     * @param {Number} from
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh: function (index, parsedSegments, up, to) {
        var timeline = index.timeline, timescale = index.timescale;
        var lastSegmentInTimeline = timeline[timeline.length - 1];
        if (!lastSegmentInTimeline) {
            return false;
        }
        var repeat = lastSegmentInTimeline.r || 0;
        var endOfLastSegment = lastSegmentInTimeline.ts + repeat * lastSegmentInTimeline.d;
        if (to * timescale < endOfLastSegment) {
            return false;
        }
        if (up * timescale >= endOfLastSegment) {
            return true;
        }
        var lastParsedSegment = parsedSegments[parsedSegments.length - 1];
        if (!lastParsedSegment) {
            return false;
        }
        var startOfLastSegment = lastSegmentInTimeline.ts + repeat * lastSegmentInTimeline.d;
        if (startOfLastSegment > lastParsedSegment.time) {
            return false;
        }
        return true;
    },
    /**
     * Returns first position in index.
     * @param {Object} index
     * @returns {Number}
     */
    getFirstPosition: function (index) {
        if (!index.timeline.length) {
            return undefined;
        }
        return index.timeline[0].ts / index.timescale;
    },
    /**
     * Returns last position in index.
     * @param {Object} index
     * @returns {Number}
     */
    getLastPosition: function (index) {
        if (!index.timeline.length) {
            return undefined;
        }
        var lastTimelineElement = index.timeline[index.timeline.length - 1];
        return (helpers_1.getTimelineRangeEnd(lastTimelineElement) / index.timescale);
    },
};


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO This file should probably be moved somewhere in the net folder
// TODO Should also probably a class implementing an interface e.g.
// IIndexManager (with the index in state?)
var segment_1 = __webpack_require__(35);
var helpers_1 = __webpack_require__(30);
var SegmentTemplateHelpers = {
    getInitSegment: helpers_1.getInitSegment,
    setTimescale: helpers_1.setTimescale,
    scale: helpers_1.scale,
    /**
     * @param {string|Number} repId
     * @param {Object} index
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Segment>}
     */
    getSegments: function (repId, index, _up, _to) {
        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        var duration = index.duration, startNumber = index.startNumber, timescale = index.timescale, media = index.media;
        var segments = [];
        for (var time = up; time <= to; time += duration) {
            var number = Math.floor(time / duration) +
                (startNumber == null ? 1 : startNumber);
            var args = {
                id: "" + repId + "_" + number,
                number: number,
                time: number * duration,
                init: false,
                duration: duration,
                range: null,
                indexRange: null,
                timescale: timescale,
                media: media,
            };
            segments.push(new segment_1.default(args));
        }
        return segments;
    },
    /**
     * Returns first position in index.
     * @returns {undefined}
     */
    getFirstPosition: function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    },
    /**
     * Returns last position in index.
     * @returns {undefined}
     */
    getLastPosition: function () {
        // TODO tslint bug? Document.
        /* tslint:disable return-undefined */
        return undefined;
        /* tslint:enable return-undefined */
    },
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */
    shouldRefresh: function () {
        return false;
    },
    /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {Number}
     */
    checkDiscontinuity: function () {
        return -1;
    },
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * Return false in any case.
     * @returns {Boolean}
     */
    _addSegmentInfos: function () {
        return false;
    },
};
exports.default = SegmentTemplateHelpers;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO This file should probably be moved somewhere in the net folder
// TODO Should also probably a class implementing an interface e.g.
// IIndexManager (with the index in state?)
var segment_1 = __webpack_require__(35);
var helpers_1 = __webpack_require__(30);
/**
 * NEEDED IN INDEX
 * duration
 * list []
 *   ?range
 * timescale
 */
/**
 * Provide helpers for SegmentList-based indexes.
 * @type {Object}
 */
var ListIndexHelpers = {
    getInitSegment: helpers_1.getInitSegment,
    setTimescale: helpers_1.setTimescale,
    scale: helpers_1.scale,
    /**
     * @param {string|Number} repId
     * @param {Object} index
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Segment>}
     */
    getSegments: function (repId, index, _up, _to) {
        var _a = helpers_1.normalizeRange(index, _up, _to), up = _a.up, to = _a.to;
        var duration = index.duration, list = index.list, timescale = index.timescale;
        var length = Math.min(list.length - 1, Math.floor(to / duration));
        var segments = [];
        var i = Math.floor(up / duration);
        while (i <= length) {
            var range = list[i].range;
            var media = list[i].media;
            var args = {
                id: "" + repId + "_" + i,
                time: i * duration,
                init: false,
                range: range,
                duration: duration,
                indexRange: null,
                timescale: timescale,
                media: media,
            };
            segments.push(new segment_1.default(args));
            i++;
        }
        return segments;
    },
    /**
     * Returns first position in index.
     * @returns {Number}
     */
    getFirstPosition: function () {
        return 0;
    },
    /**
     * Returns last position in index.
     * @param {Object} index
     * @returns {Number}
     */
    getLastPosition: function (index) {
        var duration = index.duration, list = index.list;
        return (list.length * duration) / index.timescale;
    },
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Object} index
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh: function (index, _, _up, to) {
        var timescale = index.timescale, duration = index.duration, list = index.list, _a = index.presentationTimeOffset, presentationTimeOffset = _a === void 0 ? 0 : _a;
        var scaledTo = to * timescale - presentationTimeOffset;
        var i = Math.floor(scaledTo / duration);
        return !(i >= 0 && i < list.length);
    },
    /**
     * We do not have to add new segments to SegmentList-based indexes.
     * Return false in any case.
     * @returns {Boolean}
     */
    _addSegmentInfos: function () {
        return false;
    },
    /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {Number}
     */
    checkDiscontinuity: function () {
        return -1;
    },
};
exports.default = ListIndexHelpers;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// TODO This file should probably be moved somewhere in the net folder
// TODO Should also probably a class implementing an interface e.g.
// IIndexManager (with the index in state?)
var helpers_1 = __webpack_require__(30);
var timeline_1 = __webpack_require__(52);
/**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 * TODO weird that everything is inherited from Timeline...
 * Reimplement from scratch
 */
var SegmentBaseHelpers = {
    getInitSegment: helpers_1.getInitSegment,
    setTimescale: helpers_1.setTimescale,
    scale: helpers_1.scale,
    getSegments: timeline_1.default.getSegments,
    getFirstPosition: timeline_1.default.getFirstPosition,
    getLastPosition: timeline_1.default.getLastPosition,
    checkDiscontinuity: timeline_1.default.checkDiscontinuity,
    /**
     * Add a new segment to the index.
     *
     * /!\ Mutate the given index
     * @param {Object} index
     * @param {Object} segmentInfos
     * @param {Number} segmentInfos.timescale
     * @param {Number} segmentInfos.duration
     * @param {Number} segmentInfos.count
     * @param {*} segmentInfos.range - TODO check type
     * @returns {Boolean} - true if the segment has been added
     */
    _addSegmentInfos: function (index, segmentInfos) {
        if (segmentInfos.timescale !== index.timescale) {
            var timescale = index.timescale;
            index.timeline.push({
                ts: (segmentInfos.time / segmentInfos.timescale) * timescale,
                d: (segmentInfos.duration / segmentInfos.timescale) * timescale,
                r: segmentInfos.count,
                range: segmentInfos.range,
            });
        }
        else {
            index.timeline.push({
                ts: segmentInfos.time,
                d: segmentInfos.duration,
                r: segmentInfos.count,
                range: segmentInfos.range,
            });
        }
        return true;
    },
    /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh: function () {
        return false;
    },
};
exports.default = SegmentBaseHelpers;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(6);
var array_includes_1 = __webpack_require__(9);
var castToObservable_1 = __webpack_require__(10);
var noop_1 = __webpack_require__(18);
var rx_tryCatch_1 = __webpack_require__(53);
var config_1 = __webpack_require__(4);
var errors_1 = __webpack_require__(8);
var backoff_1 = __webpack_require__(279);
// TODO Typings is a complete mess in this file.
// Maybe is it too DRY? Refactor.
var DEFAULT_MAXIMUM_RETRY_ON_ERROR = config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR;
var DEFAULT_MAXIMUM_RETRY_ON_OFFLINE = config_1.default.DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;
var MAX_BACKOFF_DELAY_BASE = config_1.default.MAX_BACKOFF_DELAY_BASE, INITIAL_BACKOFF_DELAY_BASE = config_1.default.INITIAL_BACKOFF_DELAY_BASE;
/**
 * Generate a new error from the infos given.
 * Also attach the pipeline type (audio/manifest...) to the _pipelineType_
 * property of the returned error.
 * @param {string} code
 * @param {Error} error
 * @param {Boolean} [fatal=true] - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */
function errorSelector(code, error, fatal) {
    if (fatal === void 0) { fatal = true; }
    if (!errors_1.isKnownError(error)) {
        if (error instanceof errors_1.RequestError) {
            return new errors_1.NetworkError(code, error, fatal);
        }
        return new errors_1.OtherError(code, error, fatal);
    }
    return error;
}
/**
 * Returns function allowing to download the wanted transport object through
 * the resolver -> loader -> parser pipeline.
 *
 * (A transport object can be for example: the manifest, audio and video
 * segments, text, images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *   - each time a request begins (type "request"). This is not emitted if the
 *     value is retrieved from a local js cache. This one emit the payload
 *     as a value.
 *   - each time a request ends (type "metrics"). This one contains
 *     informations about the metrics of the request.
 *   - each time a minor request error is encountered (type "error"). With the
 *     error as a value.
 *   - Lastly, with the obtained data (type "data").
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 * @param {Object} transportObject
 * @param {Function} transportObject.resolver
 * @param {Function} transportObject.loader
 * @param {Function} transportObject.parser
 * @param {Object} [options={}]
 * @param {Number} [options.maxRetry=DEFAULT_MAXIMUM_RETRY_ON_ERROR]
 * @param {Object} [options.cache]
 * @returns {Function}
 */
function createPipeline(_a, options) {
    var resolver = _a.resolver, loader = _a.loader, parser = _a.parser;
    if (options === void 0) { options = {}; }
    var maxRetry = options.maxRetry, cache = options.cache;
    /**
     * Subject that will emit non-fatal errors.
     */
    var retryErrorSubject = new Subject_1.Subject();
    var _resolver = resolver || Observable_1.Observable.of;
    var _loader = loader || Observable_1.Observable.of;
    var _parser = parser || Observable_1.Observable.of;
    var totalRetry = typeof maxRetry === "number" ?
        maxRetry : DEFAULT_MAXIMUM_RETRY_ON_ERROR;
    /**
     * Backoff options given to the backoff retry done with the loader function.
     * @see retryWithBackoff
     */
    var backoffOptions = {
        baseDelay: INITIAL_BACKOFF_DELAY_BASE,
        maxDelay: MAX_BACKOFF_DELAY_BASE,
        maxRetryRegular: totalRetry,
        maxRetryOffline: DEFAULT_MAXIMUM_RETRY_ON_OFFLINE,
        onRetry: function (error) {
            retryErrorSubject
                .next(errorSelector("PIPELINE_LOAD_ERROR", error, false));
        },
    };
    function catchedResolver(pipelineInputData) {
        return rx_tryCatch_1.default(_resolver, pipelineInputData)
            .catch(function (error) {
            throw errorSelector("PIPELINE_RESOLVE_ERROR", error);
        });
    }
    function catchedLoader(resolvedInfos, pipelineInputData) {
        function loaderWithRetry(_resolvedInfos) {
            // TODO do something about bufferdepth to avoid infinite errors?
            return backoff_1.default(rx_tryCatch_1.default(_loader, _resolvedInfos), backoffOptions)
                .catch(function (error) {
                throw errorSelector("PIPELINE_LOAD_ERROR", error);
            })
                .do(function (_a) {
                var type = _a.type, value = _a.value;
                if (type === "response" && cache) {
                    cache.add(_resolvedInfos, value);
                }
            })
                .startWith({
                type: "request",
                value: pipelineInputData,
            });
        }
        var fromCache = cache ? cache.get(resolvedInfos) : null;
        return fromCache === null ?
            loaderWithRetry(resolvedInfos) :
            castToObservable_1.default(fromCache)
                .map(function (response) {
                return {
                    type: "cache",
                    value: response,
                };
            }).catch(function () { return loaderWithRetry(resolvedInfos); });
    }
    function catchedParser(loadedInfos) {
        return rx_tryCatch_1.default(_parser, loadedInfos)
            .catch(function (error) {
            throw errorSelector("PIPELINE_PARSING_ERROR", error);
        });
    }
    return function startPipeline(pipelineInputData) {
        var pipeline$ = catchedResolver(pipelineInputData)
            .mergeMap(function (resolvedInfos) {
            return catchedLoader(resolvedInfos, pipelineInputData)
                .mergeMap(function (_a) {
                var type = _a.type, value = _a.value;
                // "cache": taken from cache
                // "data": no request have been done
                // "response": a request has been done
                if (array_includes_1.default(["cache", "data", "response"], type)) {
                    var loaderResponse = value;
                    var loadedInfos_1 = objectAssign({ response: loaderResponse }, resolvedInfos);
                    // add metrics if a request was made
                    var metrics = type === "response" ?
                        Observable_1.Observable.of({
                            type: "metrics",
                            value: {
                                size: value.size,
                                duration: value.duration,
                            },
                        }) :
                        Observable_1.Observable.empty();
                    return metrics
                        .concat(catchedParser(loadedInfos_1)
                        .map(function (parserResponse) {
                        return {
                            type: "data",
                            value: objectAssign({
                                parsed: parserResponse,
                            }, loadedInfos_1),
                        };
                    }));
                }
                else {
                    return Observable_1.Observable.of({
                        type: type,
                        value: value,
                    });
                }
            });
        }).do(noop_1.default, noop_1.default, function () { retryErrorSubject.complete(); });
        var retryError$ = retryErrorSubject
            .map(function (error) { return ({
            type: "error",
            value: error,
        }); });
        return Observable_1.Observable.merge(pipeline$, retryError$);
    };
}
exports.default = createPipeline;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var errors_1 = __webpack_require__(8);
var backoff_1 = __webpack_require__(91);
/**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
function shouldRetry(error) {
    if (!(error instanceof errors_1.RequestError)) {
        return false;
    }
    if (error.type === errors_1.RequestErrorTypes.ERROR_HTTP_CODE) {
        return error.status >= 500 || error.status === 404;
    }
    return (error.type === errors_1.RequestErrorTypes.TIMEOUT ||
        error.type === errors_1.RequestErrorTypes.ERROR_EVENT);
}
function isOfflineRequestError(error) {
    return error.type === errors_1.RequestErrorTypes.ERROR_EVENT && compat_1.isOffline();
}
/**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable}
 * @param {Object} options
 * @param {Number} options.baseDelay - First delay set when and if:
 *   - the first observable throws
 *   - any observable throws an error which has a type different than the last
 *     one.
 * @param {Number} options.maxDelay - Maximum delay considered for the backoff.
 * Note that this delay is not exact as it will be "fuzzed".
 * @param {Number} options.maxRetryRegular - Maximum number of retry for
 * "regular" errors. That is, errors that are most likely due to the CDN.
 * @param {Number} options.maxRetryOffline - Maximum number of retry for
 * "offline" errors. That is, errors that are most likely due to the user being
 * offline.
 * @param {Function} [options.onRetry] - callback to call as an observable
 * throws. Will be called with two arguments:
 *   - The error thrown by the observable.
 *   - The counter for the current error type.
 * @returns {Observable}
 */
function downloadingBackoff(obs$, options) {
    var baseDelay = options.baseDelay, maxDelay = options.maxDelay, maxRetryRegular = options.maxRetryRegular, maxRetryOffline = options.maxRetryOffline, onRetry = options.onRetry;
    var retryCount = 0;
    var ERROR_TYPES = {
        NONE: 0,
        REGULAR: 1,
        OFFLINE: 2,
    };
    var lastError = ERROR_TYPES.NONE;
    return obs$.catch(function (error, source) {
        if (!shouldRetry(error)) {
            throw error;
        }
        var currentError = error instanceof errors_1.RequestError &&
            isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;
        var maxRetry = currentError === ERROR_TYPES.OFFLINE ?
            maxRetryOffline : maxRetryRegular;
        if (currentError !== lastError) {
            retryCount = 0;
            lastError = currentError;
        }
        if (++retryCount > maxRetry) {
            throw error;
        }
        if (onRetry) {
            onRetry(error, retryCount);
        }
        var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
        var fuzzedDelay = backoff_1.getFuzzedDelay(delay);
        return Observable_1.Observable.timer(fuzzedDelay)
            .mergeMap(function () { return source; });
    });
}
exports.default = downloadingBackoff;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(16);
var errors_1 = __webpack_require__(8);
var log_1 = __webpack_require__(1);
var eme_1 = __webpack_require__(94);
/**
 * Perform EME management if needed.
 * @param {HTMLMediaElement} videoElement
 * @param {Array.<Object>} [keySystems]
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createEMEIfKeySystems(videoElement, keySystems, errorStream) {
    if (keySystems && keySystems.length) {
        return eme_1.createEME(videoElement, keySystems, errorStream);
    }
    else {
        return events_1.onEncrypted$(videoElement).map(function () {
            log_1.default.error("eme: ciphered media and no keySystem passed");
            throw new errors_1.EncryptedMediaError("MEDIA_IS_ENCRYPTED_ERROR", null, true);
        });
    }
}
exports.default = createEMEIfKeySystems;


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var in_memory_1 = __webpack_require__(282);
exports.InMemorySessionsSet = in_memory_1.default;
var persisted_1 = __webpack_require__(283);
exports.PersistedSessionsSet = persisted_1.default;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var castToObservable_1 = __webpack_require__(10);
var log_1 = __webpack_require__(1);
var abstract_1 = __webpack_require__(95);
var hash_init_data_1 = __webpack_require__(96);
/**
 * Set maintaining a representation of all currently loaded
 * MediaKeySessions. This set allow to reuse sessions without re-
 * negotiating a license exchange if the key is already used in a
 * loaded session.
 * @class InMemorySessionsSet
 * @extends SessionSet
 */
var InMemorySessionsSet = /** @class */ (function (_super) {
    __extends(InMemorySessionsSet, _super);
    function InMemorySessionsSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InMemorySessionsSet.prototype.getFirst = function () {
        if (this._entries.length > 0) {
            return this._entries[0].session;
        }
    };
    InMemorySessionsSet.prototype.find = function (func) {
        for (var i = 0; i < this._entries.length; i++) {
            if (func(this._entries[i])) {
                return this._entries[i];
            }
        }
        return null;
    };
    InMemorySessionsSet.prototype.get = function (initData) {
        var hash = hash_init_data_1.default(initData);
        var entry = this.find(function (e) { return e.initData === hash; });
        if (entry) {
            return entry.session;
        }
        else {
            return null;
        }
    };
    InMemorySessionsSet.prototype.add = function (initData, session, sessionEvents) {
        var hash = hash_init_data_1.default(initData);
        var currentSession = this.get(hash);
        if (currentSession) {
            this.deleteAndClose(currentSession);
        }
        var eventSubscription = sessionEvents.connect();
        var entry = {
            session: session,
            initData: hash,
            eventSubscription: eventSubscription,
        };
        log_1.default.debug("eme-mem-store: add session", entry);
        this._entries.push(entry);
    };
    InMemorySessionsSet.prototype.deleteById = function (sessionId) {
        var entry = this.find(function (e) { return e.session.sessionId === sessionId; });
        if (entry) {
            return this.delete(entry.session);
        }
        else {
            return null;
        }
    };
    InMemorySessionsSet.prototype.delete = function (session_) {
        var entry = this.find(function (e) { return e.session === session_; });
        if (!entry) {
            return null;
        }
        var session = entry.session, eventSubscription = entry.eventSubscription;
        log_1.default.debug("eme-mem-store: delete session", entry);
        var idx = this._entries.indexOf(entry);
        this._entries.splice(idx, 1);
        eventSubscription.unsubscribe();
        return session;
    };
    InMemorySessionsSet.prototype.deleteAndClose = function (session_) {
        var session = this.delete(session_);
        if (session) {
            log_1.default.debug("eme-mem-store: close session", session);
            return castToObservable_1.default(session.close())
                .catch(function () { return Observable_1.Observable.of(null); });
        }
        else {
            return Observable_1.Observable.of(null);
        }
    };
    InMemorySessionsSet.prototype.dispose = function () {
        var _this = this;
        var disposed = this._entries.map(function (e) { return _this.deleteAndClose(e.session); });
        this._entries = [];
        return Observable_1.Observable.merge.apply(Observable_1.Observable, disposed);
    };
    return InMemorySessionsSet;
}(abstract_1.default));
exports.default = InMemorySessionsSet;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
var log_1 = __webpack_require__(1);
var abstract_1 = __webpack_require__(95);
var hash_init_data_1 = __webpack_require__(96);
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 */
var PersistedSessionsSet = /** @class */ (function (_super) {
    __extends(PersistedSessionsSet, _super);
    /*
     * @param {Object} storage
     * @param {Function} storage.load
     * @param {Function} storage.save
     */
    function PersistedSessionsSet(storage) {
        var _this = _super.call(this) || this;
        _this.setStorage(storage);
        return _this;
    }
    /**
     * Set a new storage System.
     * storages are user-provided objects which allow to save and load given
     * informations.
     * @param {Object} storage
     * @param {Function} storage.load
     * @param {Function} storage.save
     */
    PersistedSessionsSet.prototype.setStorage = function (storage) {
        if (this._storage === storage) {
            return;
        }
        assert_1.default(storage, "no licenseStorage given for keySystem with persistentLicense");
        assert_1.default.iface(storage, "licenseStorage", { save: "function", load: "function" });
        this._storage = storage;
        try {
            this._entries = this._storage.load();
            assert_1.default(Array.isArray(this._entries));
        }
        catch (e) {
            log_1.default.warn("eme-persitent-store: could not get entries from license storage", e);
            this.dispose();
        }
    };
    /**
     * Retrieve entry (sessionId + initData) based on its initData.
     * @param {Array|TypedArray|Number}  initData
     * @returns {Object|null}
     */
    PersistedSessionsSet.prototype.get = function (initData) {
        var hash = hash_init_data_1.default(initData);
        var entry = this.find(function (e) { return e.initData === hash; });
        return entry || null;
    };
    /**
     * Add a new entry in the storage.
     * @param {Array|TypedArray|Number}  initData
     * @param {MediaKeySession} session
     */
    PersistedSessionsSet.prototype.add = function (initData, session) {
        var sessionId = session && session.sessionId;
        if (!sessionId) {
            return;
        }
        var hash = hash_init_data_1.default(initData);
        var currentEntry = this.get(hash);
        if (currentEntry && currentEntry.sessionId === sessionId) {
            return;
        }
        else if (currentEntry) {
            this.delete(hash);
        }
        log_1.default.info("eme-persitent-store: add new session", sessionId, session);
        this._entries.push({
            sessionId: sessionId,
            initData: hash,
        });
        this._save();
    };
    /**
     * Delete entry (sessionId + initData) based on its initData.
     * @param {Array|TypedArray|Number}  initData
     */
    PersistedSessionsSet.prototype.delete = function (initData) {
        var hash = hash_init_data_1.default(initData);
        var entry = this.find(function (e) { return e.initData === hash; });
        if (entry) {
            log_1.default.warn("eme-persitent-store: delete session from store", entry);
            var idx = this._entries.indexOf(entry);
            this._entries.splice(idx, 1);
            this._save();
        }
    };
    /**
     * Delete all saved entries.
     */
    PersistedSessionsSet.prototype.dispose = function () {
        this._entries = [];
        this._save();
    };
    /**
     * Use the given storage to store the current entries.
     */
    PersistedSessionsSet.prototype._save = function () {
        try {
            this._storage.save(this._entries);
        }
        catch (e) {
            log_1.default.warn("eme-persitent-store: could not save licenses in localStorage");
        }
    };
    return PersistedSessionsSet;
}(abstract_1.default));
exports.default = PersistedSessionsSet;


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var config_1 = __webpack_require__(4);
var array_includes_1 = __webpack_require__(9);
var log_1 = __webpack_require__(1);
var errors_1 = __webpack_require__(8);
var EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config_1.default.EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS = config_1.default.EME_KEY_SYSTEMS;
function getCachedKeySystemAccess(keySystems, instanceInfos) {
    var $keySystem = instanceInfos.$keySystem, $mediaKeys = instanceInfos.$mediaKeys, $mediaKeySystemConfiguration = instanceInfos.$mediaKeySystemConfiguration;
    // NOTE(pierre): alwaysRenew flag is used for IE11 which require the
    // creation of a new MediaKeys instance for each session creation
    if (!$keySystem || !$mediaKeys || compat_1.shouldRenewMediaKeys()) {
        return null;
    }
    if ($mediaKeySystemConfiguration) {
        var configuration_1 = $mediaKeySystemConfiguration;
        var foundKeySystem = keySystems.filter(function (ks) {
            if (ks.type !== $keySystem.type) {
                return false;
            }
            if (ks.persistentLicense &&
                configuration_1.persistentState !== "required") {
                return false;
            }
            if (ks.distinctiveIdentifierRequired &&
                configuration_1.distinctiveIdentifier !== "required") {
                return false;
            }
            return true;
        })[0];
        if (foundKeySystem) {
            return {
                keySystem: foundKeySystem,
                keySystemAccess: new compat_1.KeySystemAccess($keySystem.type, $mediaKeys, $mediaKeySystemConfiguration),
            };
        }
        else {
            return null;
        }
    }
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string} - Either the canonical name, or undefined.
 */
function findKeySystemCanonicalName(ksType) {
    for (var _i = 0, _a = Object.keys(EME_KEY_SYSTEMS); _i < _a.length; _i++) {
        var ksName = _a[_i];
        if (array_includes_1.default(EME_KEY_SYSTEMS[ksName], ksType)) {
            return ksName;
        }
    }
    return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @param {Boolean} [keySystem.persistentLicense]
 * @param {Boolean} [keySystem.persistentStateRequired]
 * @param {Boolean} [keySystem.distinctiveIdentifierRequired]
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */
function buildKeySystemConfigurations(ksName, keySystem) {
    var sessionTypes = ["temporary"];
    var persistentState = "optional";
    var distinctiveIdentifier = "optional";
    if (keySystem.persistentLicense) {
        persistentState = "required";
        sessionTypes.push("persistent-license");
    }
    if (keySystem.persistentStateRequired) {
        persistentState = "required";
    }
    if (keySystem.distinctiveIdentifierRequired) {
        distinctiveIdentifier = "required";
    }
    // Set robustness, in order of consideration:
    //   1. the user specified its own robustnesses
    //   2. a "widevine" key system is used, in that case set the default widevine
    //      robustnesses as defined in the config
    //   3. set an undefined robustness
    var videoRobustnesses = keySystem.videoRobustnesses ||
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
    var audioRobustnesses = keySystem.audioRobustnesses ||
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
    if (!videoRobustnesses.length) {
        videoRobustnesses.push(undefined);
    }
    if (!audioRobustnesses.length) {
        audioRobustnesses.push(undefined);
    }
    // From the W3 EME spec, we have to provide videoCapabilities and
    // audioCapabilities.
    // These capabilities must specify a codec (even though your stream can use
    // a completely different codec afterward).
    // It is also strongly recommended to specify the required security
    // robustness. As we do not want to forbide any security level, we specify
    // every existing security level from highest to lowest so that the best
    // security level is selected.
    // More details here:
    // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
    // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent
    var videoCapabilities = videoRobustnesses.map(function (robustness) { return ({
        contentType: "video/mp4;codecs=\"avc1.4d401e\"",
        robustness: robustness,
    }); });
    var audioCapabilities = audioRobustnesses.map(function (robustness) { return ({
        contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
        robustness: robustness,
    }); });
    // TODO Re-test with a set contentType but an undefined robustness on the
    // STBs on which this problem was found.
    //
    // add another with no {audio,video}Capabilities for some legacy browsers.
    // As of today's spec, this should return NotSupported but the first
    // candidate configuration should be good, so we should have no downside
    // doing that.
    // initDataTypes: ["cenc"],
    // videoCapabilities: undefined,
    // audioCapabilities: undefined,
    // distinctiveIdentifier,
    // persistentState,
    // sessionTypes,
    return [{
            initDataTypes: ["cenc"],
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            distinctiveIdentifier: distinctiveIdentifier,
            persistentState: persistentState,
            sessionTypes: sessionTypes,
        }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */
function findCompatibleKeySystem(keySystems, instanceInfos) {
    // Fast way to find a compatible keySystem if the currently loaded
    // one as exactly the same compatibility options.
    var cachedKeySystemAccess = getCachedKeySystemAccess(keySystems, instanceInfos);
    if (cachedKeySystemAccess) {
        log_1.default.debug("eme: found compatible keySystem quickly", cachedKeySystemAccess);
        return Observable_1.Observable.of(cachedKeySystemAccess);
    }
    /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */
    var keySystemsType = keySystems.reduce(function (arr, keySystem) {
        var ksType;
        if (EME_KEY_SYSTEMS[keySystem.type]) {
            ksType = EME_KEY_SYSTEMS[keySystem.type].map(function (keyType) {
                var keyName = keySystem.type;
                return { keyName: keyName, keyType: keyType, keySystem: keySystem };
            });
        }
        else {
            var keyName = findKeySystemCanonicalName(keySystem.type) || "";
            var keyType = keySystem.type;
            ksType = [{ keyName: keyName, keyType: keyType, keySystem: keySystem }];
        }
        return arr.concat(ksType);
    }, []);
    return Observable_1.Observable.create(function (obs) {
        var disposed = false;
        var sub;
        /**
         * Test the key system as defined in keySystemsType[index].
         * @param {Number} index
         */
        function testKeySystem(index) {
            // completely quit the loop if unsubscribed
            if (disposed) {
                return;
            }
            // if we iterated over the whole keySystemsType Array, quit on error
            if (index >= keySystemsType.length) {
                obs.error(new errors_1.EncryptedMediaError("INCOMPATIBLE_KEYSYSTEMS", null, true));
                return;
            }
            var _a = keySystemsType[index], keyName = _a.keyName, keyType = _a.keyType, keySystem = _a.keySystem;
            var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystem);
            log_1.default.debug("eme: request keysystem access " + keyType + "," +
                (index + 1 + " of " + keySystemsType.length), keySystemConfigurations);
            sub = compat_1.requestMediaKeySystemAccess(keyType, keySystemConfigurations)
                .subscribe(function (keySystemAccess) {
                log_1.default.info("eme: found compatible keysystem", keyType, keySystemConfigurations);
                obs.next({ keySystem: keySystem, keySystemAccess: keySystemAccess });
                obs.complete();
            }, function () {
                log_1.default.debug("eme: rejected access to keysystem", keyType, keySystemConfigurations);
                sub = null;
                testKeySystem(index + 1);
            });
        }
        testKeySystem(0);
        return function () {
            disposed = true;
            if (sub) {
                sub.unsubscribe();
            }
        };
    });
}
exports.findCompatibleKeySystem = findCompatibleKeySystem;
function getKeySystem(instanceInfos) {
    return instanceInfos.$keySystem && instanceInfos.$keySystem.type;
}
exports.getKeySystem = getKeySystem;
exports.default = findCompatibleKeySystem;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var EncryptedMediaError_1 = __webpack_require__(84);
var castToObservable_1 = __webpack_require__(10);
/**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function setServerCertificate(mediaKeys, serverCertificate) {
    return Observable_1.Observable.defer(function () {
        return castToObservable_1.default(mediaKeys.setServerCertificate(serverCertificate))
            .ignoreElements()
            .catch(function (error) {
            throw new EncryptedMediaError_1.default("LICENSE_SERVER_CERTIFICATE_ERROR", error, true);
        });
    });
}
exports.setServerCertificate = setServerCertificate;
/**
 * Call the setCertificate API. If it fails just emit the error through the
 * errorStream and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) {
    return setServerCertificate(mediaKeys, serverCertificate)
        .catch(function (error) {
        error.fatal = false;
        errorStream.next(error);
        return Observable_1.Observable.empty();
    });
}
exports.trySettingServerCertificate = trySettingServerCertificate;
exports.default = setServerCertificate;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var Observable_1 = __webpack_require__(0);
var TimeoutError_1 = __webpack_require__(80);
var errors_1 = __webpack_require__(8);
var array_includes_1 = __webpack_require__(9);
var castToObservable_1 = __webpack_require__(10);
var log_1 = __webpack_require__(1);
var noop_1 = __webpack_require__(18);
var retry_1 = __webpack_require__(90);
var rx_tryCatch_1 = __webpack_require__(53);
var events_1 = __webpack_require__(16);
var constants_1 = __webpack_require__(287);
var globals_1 = __webpack_require__(54);
/**
 * Create the Object emitted by the EME Observable.
 * @param {string} name - name of the event
 * @param {MediaKeySession} session - MediaKeySession concerned
 * @param {Object} [options] - Supplementary data, will be merged with the
 * session information in the returned object.
 * @returns {Object}
 */
function createSessionEvent(name, session, options) {
    return {
        type: "ISessionEvent",
        value: objectAssign({ name: name, session: session }, options),
    };
}
/**
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function sessionEventsHandler(session, keySystem, errorStream) {
    log_1.default.debug("eme: handle message events", session);
    /**
     * @param {Error|Object} error
     * @param {Boolean} fatal
     * @returns {Error|Object}
     */
    function licenseErrorSelector(error, fatal) {
        if (errors_1.isKnownError(error)) {
            if (error.type === errors_1.ErrorTypes.ENCRYPTED_MEDIA_ERROR) {
                error.fatal = fatal;
                return error;
            }
        }
        return new errors_1.EncryptedMediaError("KEY_LOAD_ERROR", error, fatal);
    }
    var getLicenseRetryOptions = {
        totalRetry: 2,
        retryDelay: 200,
        errorSelector: function (error) { return licenseErrorSelector(error, true); },
        onRetry: function (error) { return errorStream.next(licenseErrorSelector(error, false)); },
    };
    var keyErrors = events_1.onKeyError$(session).map(function (error) {
        throw new errors_1.EncryptedMediaError("KEY_ERROR", error, true);
    });
    var keyStatusesChanges = events_1.onKeyStatusesChange$(session)
        .mergeMap(function (keyStatusesEvent) {
        log_1.default.debug("eme: keystatuseschange event", session, keyStatusesEvent);
        // find out possible errors associated with this event
        session.keyStatuses.forEach(function (keyStatus, keyId) {
            // Hack present because the order of the arguments has changed in spec
            // and is not the same between some versions of Edge and Chrome.
            if (constants_1.KEY_STATUS_ERRORS[keyId]) {
                throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", keyId, true);
            }
            else if (constants_1.KEY_STATUS_ERRORS[keyStatus]) {
                throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", keyStatus, true);
            }
        });
        var license = rx_tryCatch_1.default(function () {
            if (keySystem && keySystem.onKeyStatusesChange) {
                return castToObservable_1.default(keySystem.onKeyStatusesChange(keyStatusesEvent, session));
            }
            else {
                return Observable_1.Observable.empty();
            }
        });
        if (license) {
            return license.catch(function (error) {
                throw new errors_1.EncryptedMediaError("KEY_STATUS_CHANGE_ERROR", error, true);
            });
        }
        log_1.default.info("eme: keystatuseschange event not handled");
        return Observable_1.Observable.empty();
    });
    var keyMessages = events_1.onKeyMessage$(session)
        .mergeMap(function (messageEvent) {
        var message = new Uint8Array(messageEvent.message);
        var messageType = messageEvent.messageType || "license-request";
        log_1.default.debug("eme: event message type " + messageType, session, messageEvent);
        var getLicense = Observable_1.Observable.defer(function () {
            return castToObservable_1.default(keySystem.getLicense(message, messageType))
                .timeout(10 * 1000)
                .catch(function (error) {
                if (error instanceof TimeoutError_1.TimeoutError) {
                    throw new errors_1.EncryptedMediaError("KEY_LOAD_TIMEOUT", null, false);
                }
                else {
                    throw error;
                }
            });
        });
        return retry_1.retryWithBackoff(getLicense, getLicenseRetryOptions);
    });
    var sessionUpdates = Observable_1.Observable.merge(keyMessages, keyStatusesChanges)
        .concatMap(function (res) {
        log_1.default.debug("eme: update session", res);
        return castToObservable_1.default(session.update(res))
            .catch(function (error) {
            throw new errors_1.EncryptedMediaError("KEY_UPDATE_ERROR", error, true);
        })
            .mapTo(createSessionEvent("session-update", session, { updatedWith: res }));
    });
    var sessionEvents = Observable_1.Observable.merge(sessionUpdates, keyErrors);
    if (session.closed) {
        return sessionEvents.takeUntil(castToObservable_1.default(session.closed));
    }
    else {
        return sessionEvents;
    }
}
/**
 * Create Key MediaKeySessionType and link MediaKeySession events to the right events
 * handlers.
 * @param {MediaKeys} mediaKeys
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {Object} keySystem
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSession(mediaKeys, sessionType, keySystem, initData, errorStream) {
    log_1.default.debug("eme: create a new " + sessionType + " session");
    var session = mediaKeys.createSession(sessionType);
    var sessionEvents = sessionEventsHandler(session, keySystem, errorStream)
        .finally(function () {
        globals_1.$loadedSessions.deleteAndClose(session);
        globals_1.$storedSessions.delete(initData);
    })
        .publish();
    return { session: session, sessionEvents: sessionEvents };
}
/**
 * Create a MediaKeySession and manage it (generate the request, manage
 * communications...).
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream) {
    var _a = createSession(mediaKeys, sessionType, keySystem, initData, errorStream), session = _a.session, sessionEvents = _a.sessionEvents;
    globals_1.$loadedSessions.add(initData, session, sessionEvents);
    log_1.default.debug("eme: generate request", initDataType, initData);
    var generateRequest = castToObservable_1.default(session.generateRequest(initDataType, initData))
        .catch(function (error) {
        throw new errors_1.EncryptedMediaError("KEY_GENERATE_REQUEST_ERROR", error, false);
    })
        .do(function () {
        if (sessionType === "persistent-license") {
            globals_1.$storedSessions.add(initData, session);
        }
    })
        .mapTo(createSessionEvent("generated-request", session, { initData: initData, initDataType: initDataType }));
    return Observable_1.Observable.merge(sessionEvents, generateRequest);
}
/**
 * Create a session, if it fails due to a session.generateRequest error, retry
 * in certain cases.
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream) {
    return createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream)
        .catch(function (error) {
        if (error.code !== errors_1.ErrorCodes.KEY_GENERATE_REQUEST_ERROR) {
            throw error;
        }
        // TODO In that case, the first in $loadedSessions could be this session,
        // is this wanted?
        var firstLoadedSession = globals_1.$loadedSessions.getFirst();
        if (!firstLoadedSession) {
            throw error;
        }
        log_1.default.warn("eme: could not create a new session, " +
            "retry after closing a currently loaded session", error);
        return globals_1.$loadedSessions.deleteAndClose(firstLoadedSession)
            .mergeMap(function () {
            return createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream);
        });
    });
}
/**
 * Create persistent MediaKeySession and load data from a sessionId.
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} storedSessionId
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createPersistentSessionAndLoad(mediaKeys, keySystem, storedSessionId, initDataType, initData, errorStream) {
    log_1.default.debug("eme: load persisted session", storedSessionId);
    var sessionType = "persistent-license";
    var _a = createSession(mediaKeys, sessionType, keySystem, initData, errorStream), session = _a.session, sessionEvents = _a.sessionEvents;
    return castToObservable_1.default(session.load(storedSessionId))
        .catch(function () { return Observable_1.Observable.of(false); })
        .mergeMap(function (success) {
        if (success) {
            globals_1.$loadedSessions.add(initData, session, sessionEvents);
            globals_1.$storedSessions.add(initData, session);
            return sessionEvents
                .startWith(createSessionEvent("loaded-session", session, { storedSessionId: storedSessionId }));
        }
        else {
            // Failed. Try to create a new persistent session from scratch
            log_1.default.warn("eme: no data stored for the loaded session, do fallback", storedSessionId);
            globals_1.$loadedSessions.deleteById(storedSessionId);
            globals_1.$storedSessions.delete(initData);
            if (session.sessionId) {
                castToObservable_1.default(session.remove())
                    .subscribe(noop_1.default, function (e) {
                    log_1.default.warn("Failed to remove session:" + e.message);
                });
            }
            return createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream).startWith(createSessionEvent("loaded-session-failed", session, { storedSessionId: storedSessionId }));
        }
    });
}
/**
 * Create MediaKeySession and react to its events.
 * @param {MediaKeys} mediaKeys
 * @param {MediaKeySystemConfiguration} mksConfig
 * @param {Object} keySystem
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function manageSessionCreation(mediaKeys, mksConfig, keySystem, initDataType, initData, errorStream) {
    return Observable_1.Observable.defer(function () {
        // reuse currently loaded sessions without making a new key request
        var loadedSession = globals_1.$loadedSessions.get(initData);
        if (loadedSession && loadedSession.sessionId) {
            log_1.default.debug("eme: reuse loaded session", loadedSession.sessionId);
            return Observable_1.Observable.of(createSessionEvent("reuse-session", loadedSession));
        }
        var sessionType = "temporary"; // (default value)
        var sessionTypes = mksConfig.sessionTypes;
        var hasPersistence = (sessionTypes && array_includes_1.default(sessionTypes, "persistent-license"));
        if (hasPersistence && keySystem.persistentLicense) {
            sessionType = "persistent-license";
            // if a persisted session exists in the store associated to this initData,
            // we reuse it without a new license request through the `load` method.
            var storedEntry = globals_1.$storedSessions.get(initData);
            if (storedEntry) {
                return createPersistentSessionAndLoad(mediaKeys, keySystem, storedEntry.sessionId, initDataType, initData, errorStream);
            }
        }
        // we have a fresh session without persisted informations and need
        // to make a new key request that we will associate to this session
        return createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream);
    });
}
exports.default = manageSessionCreation;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-object-literal-type-assertion */
exports.KEY_STATUS_ERRORS = {
    expired: true,
    "internal-error": true,
};
/* tslint:enable no-object-literal-type-assertion */


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
var globals_1 = __webpack_require__(54);
/**
 * Set the MediaKeys object on the videoElement.
 * @param {MediaKeys} mediaKeys
 * @param {Object} mksConfig - MediaKeySystemConfiguration used
 * @param {HTMLMediaElement} video
 * @param {Object} keySystem
 * @param {Object} instceInfos
 * @returns {Observable}
 */
function setMediaKeysObs(mediaKeys, mksConfig, video, keySystem, instceInfos) {
    return Observable_1.Observable.defer(function () {
        var $videoElement = instceInfos.$videoElement, $mediaKeys = instceInfos.$mediaKeys;
        var oldVideoElement = $videoElement;
        var oldMediaKeys = $mediaKeys;
        instceInfos.$mediaKeys = mediaKeys;
        instceInfos.$mediaKeySystemConfiguration = mksConfig;
        instceInfos.$keySystem = keySystem;
        instceInfos.$videoElement = video;
        if (video.mediaKeys === mediaKeys) {
            return Observable_1.Observable.of(mediaKeys);
        }
        if (oldMediaKeys && oldMediaKeys !== mediaKeys) {
            // if we change our mediaKeys singleton, we need to dispose all existing
            // sessions linked to the previous one.
            globals_1.$loadedSessions.dispose();
        }
        var mediaKeysSetter;
        if ((oldVideoElement && oldVideoElement !== video)) {
            log_1.default.debug("eme: unlink old video element and set mediakeys");
            mediaKeysSetter = compat_1.setMediaKeys(oldVideoElement, null)
                .concat(compat_1.setMediaKeys(video, mediaKeys));
        }
        else {
            log_1.default.debug("eme: set mediakeys");
            mediaKeysSetter = compat_1.setMediaKeys(video, mediaKeys);
        }
        return mediaKeysSetter.mapTo(mediaKeys);
    });
}
exports.setMediaKeys = setMediaKeysObs;
function disposeMediaKeys(videoElement) {
    if (videoElement) {
        return compat_1.setMediaKeys(videoElement, null);
    }
    return Observable_1.Observable.empty();
}
exports.disposeMediaKeys = disposeMediaKeys;
exports.default = setMediaKeysObs;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(26);
var log_1 = __webpack_require__(1);
var rx_onEvent_1 = __webpack_require__(47);
/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the videoElement.
 * @see MediaError
 * @returns {Observable}
 */
function createMediaErrorStream(videoElement) {
    return rx_onEvent_1.default(videoElement, "error").mergeMap(function () {
        var errorCode = videoElement.error.code;
        var errorDetail;
        switch (errorCode) {
            case 1:
                errorDetail = "MEDIA_ERR_ABORTED";
                break;
            case 2:
                errorDetail = "MEDIA_ERR_NETWORK";
                break;
            case 3:
                errorDetail = "MEDIA_ERR_DECODE";
                break;
            case 4:
                errorDetail = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                break;
            default:
                errorDetail = "MEDIA_ERR_UNKNOWN";
                break;
        }
        log_1.default.error("stream: video element MEDIA_ERR(" + errorDetail + ")");
        throw new MediaError_1.default(errorDetail, null, true);
    });
}
exports.default = createMediaErrorStream;


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var timings_1 = __webpack_require__(55);
var DEFAULT_LIVE_GAP = config_1.default.DEFAULT_LIVE_GAP;
/**
 * Returns the calculated initial time for the stream described by the given
 * manifest:
 *   1. if a start time is defined by user, calculate video starting time from
 *      the manifest informations
 *   2. else if the video is live, use the live edge and suggested delays from
 *      it
 *   3. else returns 0 (beginning)
 *
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */
function getInitialTime(manifest, startAt) {
    if (startAt) {
        var _a = timings_1.getBufferLimits(manifest), min = _a[0], max = _a[1];
        if (startAt.position != null) {
            return Math.max(Math.min(startAt.position, max), min);
        }
        else if (startAt.wallClockTime != null) {
            var position = manifest.isLive ?
                startAt.wallClockTime - (manifest.availabilityStartTime || 0) :
                startAt.wallClockTime;
            return Math.max(Math.min(position, max), min);
        }
        else if (startAt.fromFirstPosition != null) {
            var fromFirstPosition = startAt.fromFirstPosition;
            return fromFirstPosition <= 0 ?
                min : Math.min(min + fromFirstPosition, max);
        }
        else if (startAt.fromLastPosition != null) {
            var fromLastPosition = startAt.fromLastPosition;
            return fromLastPosition >= 0 ?
                max : Math.max(min, max + fromLastPosition);
        }
        else if (startAt.percentage != null) {
            var percentage = startAt.percentage;
            if (percentage > 100) {
                return max;
            }
            else if (percentage < 0) {
                return min;
            }
            var ratio = +percentage / 100;
            var extent = max - min;
            return min + extent * ratio;
        }
    }
    if (manifest.isLive) {
        var sgp = manifest.suggestedPresentationDelay;
        return timings_1.getMaximumBufferPosition(manifest) -
            (sgp == null ? DEFAULT_LIVE_GAP : sgp);
    }
    return 0;
}
exports.default = getInitialTime;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var compat_1 = __webpack_require__(5);
var MediaError_1 = __webpack_require__(26);
var log_1 = __webpack_require__(1);
/**
 * Side effect that set the media duration in the mediaSource. This side
 * effect occurs when we receive the "sourceopen" from the
 * mediaSource.
 * @param {MediaSource} mediaSource
 * @param {Object} manifest
 */
function setDurationToMediaSource(mediaSource, duration) {
    var newDuration = duration === Infinity ?
        Number.MAX_VALUE : duration;
    if (mediaSource.duration !== newDuration) {
        mediaSource.duration = newDuration;
        log_1.default.info("set duration", mediaSource.duration);
    }
}
exports.setDurationToMediaSource = setDurationToMediaSource;
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * video element's src attribute.
 *
 * Returns an Observable which emits one time when done an object with the
 * following properties:
 *
 *   - src {string} - the src given
 *
 *   - mediaSource {MediaSource|null} - the MediaSource instance. Can be null
 *     in the case no MediaSource is needed.
 *
 * This Observable never completes. It can throw if MediaSource is needed but
 * is not available in the current environment.
 *
 * On unsubscription, the video.src is cleaned, MediaSource sourcenuffers and
 * customBuffers are aborted and some minor cleaning is done.
 *
 * @param {string} url
 * @param {HTMLMediaElement} video
 * @param {Boolean} withMediaSource
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.custom
 * @param {Object} sourceBufferMemory.native
 * @returns {Observable}
 */
function createAndPlugMediaSource(url, video, withMediaSource, sourceBufferMemory) {
    return Observable_1.Observable.create(function (observer) {
        var mediaSource;
        var objectURL;
        var nativeBuffers = sourceBufferMemory.native, customBuffers = sourceBufferMemory.custom;
        function resetMediaElement() {
            if (mediaSource && mediaSource.readyState !== "closed") {
                var readyState = mediaSource.readyState, sourceBuffers = mediaSource.sourceBuffers;
                for (var i = 0; i < sourceBuffers.length; i++) {
                    var sourceBuffer = sourceBuffers[i];
                    try {
                        if (readyState === "open") {
                            log_1.default.info("aborting previous source buffer", sourceBuffer);
                            sourceBuffer.abort();
                        }
                        mediaSource.removeSourceBuffer(sourceBuffer);
                    }
                    catch (e) {
                        log_1.default.warn("error while disposing souceBuffer", e);
                    }
                }
            }
            for (var _i = 0, _a = Object.keys(nativeBuffers); _i < _a.length; _i++) {
                var bufferType = _a[_i];
                // TODO TypeScript is too Dumb here
                delete nativeBuffers[bufferType];
            }
            for (var _b = 0, _c = Object.keys(customBuffers); _b < _c.length; _b++) {
                var bufferType = _c[_b];
                var sourceBuffer = customBuffers[bufferType];
                try {
                    sourceBuffer.abort();
                }
                catch (e) {
                    log_1.default.warn("error while disposing souceBuffer", e);
                }
                delete customBuffers[bufferType];
            }
            compat_1.clearVideoSrc(video);
            if (objectURL) {
                try {
                    log_1.default.debug("revoking previous URL");
                    URL.revokeObjectURL(objectURL);
                }
                catch (e) {
                    log_1.default.warn("error while revoking ObjectURL", e);
                }
            }
            mediaSource = null;
            objectURL = null;
        }
        // make sure the media has been correctly reset
        resetMediaElement();
        if (withMediaSource) {
            if (!compat_1.MediaSource_) {
                throw new MediaError_1.default("MEDIA_SOURCE_NOT_SUPPORTED", null, true);
            }
            log_1.default.info("creating MediaSource");
            mediaSource = new compat_1.MediaSource_();
            objectURL = URL.createObjectURL(mediaSource);
        }
        else {
            mediaSource = null;
            objectURL = url;
        }
        log_1.default.info("attaching MediaSource URL to video element", objectURL);
        video.src = objectURL;
        observer.next({ url: url, mediaSource: mediaSource });
        return resetMediaElement;
    });
}
exports.createAndPlugMediaSource = createAndPlugMediaSource;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = __webpack_require__(6);
/**
 * Process a pipeline observable to adapt it to the Stream way:
 *   - use the network$ subject for network metrics (bandwitdh mesure)
 *   - use the requests subject for network requests and their progress
 *   - use the warning$ subject for retries' error messages
 *   - only emit the data
 *
 * @param {string} pipelineType
 * @param {Observable} pipeline$
 * @param {Subject} network$
 * @param {Subject} warning$
 * @returns {Observable}
 */
function processPipeline(pipelineType, pipeline$, network$, requests$, warning$) {
    var request$;
    var segmentId;
    return pipeline$
        .filter(function (_a) {
        var type = _a.type, value = _a.value;
        if (type === "data" || type === "cache") {
            return true;
        }
        // -- SIDE EFFECTS --
        // ugly to do side effect in a filter, but heh
        if (type === "error") {
            // value is an Error. Add the pipeline type information to it.
            value.pipelineType = pipelineType;
            warning$.next(value);
        }
        else if (pipelineType !== "manifest") {
            switch (type) {
                case "metrics": {
                    // format it for ABR Handling
                    network$.next({ type: pipelineType, value: value });
                    break;
                }
                case "request": {
                    // format it for ABR Handling if the right format
                    var segment = value && value.segment;
                    if (segment != null && segment.duration != null) {
                        var duration = segment.duration / segment.timescale;
                        var time = segment.time / segment.timescale;
                        segmentId = segment.id;
                        var segmentInfos = {
                            duration: duration,
                            time: time,
                            requestTimestamp: Date.now(),
                            id: segmentId,
                        };
                        request$ = new Subject_1.Subject();
                        requests$.next(request$);
                        request$.next({
                            type: pipelineType,
                            event: "requestBegin",
                            value: segmentInfos,
                        });
                    }
                    break;
                }
                case "progress": {
                    if (value.size === value.totalSize) {
                        return false;
                    }
                    if (segmentId != null) {
                        var progressInfos = {
                            duration: value.duration,
                            size: value.size,
                            totalSize: value.totalSize,
                            timestamp: Date.now(),
                            id: segmentId,
                        };
                        if (request$ != null) {
                            request$.next({
                                type: pipelineType,
                                event: "progress",
                                value: progressInfos,
                            });
                        }
                    }
                    break;
                }
            }
        }
        return false;
    })
        .map(function (_a) {
        var value = _a.value;
        return value;
    }) // take only value from data/cache events
        .finally(function () {
        if (request$ != null) {
            if (pipelineType !== "manifest" && segmentId != null) {
                request$.next({
                    type: pipelineType,
                    event: "requestEnd",
                    value: { id: segmentId },
                });
            }
            request$.complete();
        }
    })
        .share(); // avoid multiple side effects if multiple subs
}
exports.default = processPipeline;


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MediaError_1 = __webpack_require__(26);
var log_1 = __webpack_require__(1);
var image_1 = __webpack_require__(294);
var text_1 = __webpack_require__(295);
var time_ranges_1 = __webpack_require__(97);
exports.ICustomTimeRanges = time_ranges_1.default;
/**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" source buffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */
function shouldHaveNativeSourceBuffer(bufferType) {
    return bufferType === "audio" || bufferType === "video";
}
exports.shouldHaveNativeSourceBuffer = shouldHaveNativeSourceBuffer;
/**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} bufferType - The "type" of SourceBuffer (audio/video...)
 * @param {string} codec
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.native
 * @returns {SourceBuffer}
 */
function addNativeSourceBuffer(mediaSource, bufferType, codec, _a) {
    var native = _a.native;
    if (native[bufferType] == null) {
        log_1.default.info("adding native sourcebuffer with type", codec);
        native[bufferType] = mediaSource.addSourceBuffer(codec);
    }
    // TODO is TypeScript playing Dumb here?
    return native[bufferType];
}
exports.addNativeSourceBuffer = addNativeSourceBuffer;
/**
 * Creates a new SourceBuffer.
 * Can be a native one (audio/video) as well as a custom one (image/text).
 * @throws MediaError - The type of bugger given is unknown.
 * @param {HTMLMediaElement} video
 * @param {MediaSource} mediaSource
 * @param {string} bufferType
 * @param {string} codex
 * @param {Object} custom
 * @param {Object} custom
 * @returns {SourceBuffer|AbstractSourceBuffer}
 */
function createSourceBuffer(video, mediaSource, bufferType, codec, sourceBufferMemory, options) {
    if (options === void 0) { options = {}; }
    var sourceBuffer;
    if (shouldHaveNativeSourceBuffer(bufferType)) {
        sourceBuffer =
            addNativeSourceBuffer(mediaSource, bufferType, codec, sourceBufferMemory);
    }
    else {
        var custom = sourceBufferMemory.custom;
        var oldSourceBuffer = custom[bufferType];
        if (oldSourceBuffer) {
            try {
                oldSourceBuffer.abort();
            }
            catch (e) {
                log_1.default.warn(e);
            }
            finally {
                delete custom[bufferType];
            }
        }
        if (bufferType === "text") {
            log_1.default.info("add text sourcebuffer", codec);
            if (options.textTrackMode === "html") {
                sourceBuffer = new text_1.HTMLTextSourceBuffer(codec, video, options.textTrackElement);
            }
            else {
                sourceBuffer = new text_1.NativeTextSourceBuffer(codec, video, options.hideNativeSubtitle);
            }
        }
        else if (bufferType === "image") {
            log_1.default.info("add image sourcebuffer", codec);
            sourceBuffer = new image_1.default(codec);
        }
        else {
            log_1.default.error("unknown buffer type " + bufferType);
            throw new MediaError_1.default("BUFFER_TYPE_UNKNOWN", null, true);
        }
        custom[bufferType] = sourceBuffer;
    }
    return sourceBuffer;
}
exports.createSourceBuffer = createSourceBuffer;
/**
 * Abort and remove the SourceBuffer given.
 * @param {HTMLMediaElement} video
 * @param {MediaSource} mediaSource
 * @param {string} bufferType
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.native
 * @param {Object} sourceBufferMemory.custom
 */
function disposeSourceBuffer(_video, mediaSource, bufferType, sourceBufferMemory) {
    var native = sourceBufferMemory.native, custom = sourceBufferMemory.custom;
    var oldSourceBuffer;
    var isNative = shouldHaveNativeSourceBuffer(bufferType);
    if (isNative) {
        // TODO 2Smart4TypeScript here. Find another way.
        oldSourceBuffer = native[bufferType];
        delete native[bufferType];
    }
    else {
        oldSourceBuffer = custom[bufferType];
        delete custom[bufferType];
    }
    if (oldSourceBuffer) {
        try {
            oldSourceBuffer.abort();
            if (isNative) {
                log_1.default.info("removing native sourcebuffer", bufferType);
                // TODO once again, we outsmart TypeScript here.
                mediaSource.removeSourceBuffer(oldSourceBuffer);
            }
        }
        catch (e) {
            log_1.default.warn(e);
        }
    }
}
exports.disposeSourceBuffer = disposeSourceBuffer;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var abstract_1 = __webpack_require__(56);
// TODO
var ImageSourceBuffer = /** @class */ (function (_super) {
    __extends(ImageSourceBuffer, _super);
    function ImageSourceBuffer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageSourceBuffer.prototype._append = function () {
        // TODO: handle live case.
        // We suppose here that the first received bsi includes all images
        this.buffered.insert(0, Number.MAX_VALUE);
    };
    /* tslint:disable no-empty */
    ImageSourceBuffer.prototype._remove = function () { };
    /* tslint:enable no-empty */
    /* tslint:disable no-empty */
    ImageSourceBuffer.prototype._abort = function () { };
    return ImageSourceBuffer;
}(abstract_1.AbstractSourceBuffer));
exports.default = ImageSourceBuffer;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Feature switching the HTML TextTrack implementation
var HAS_HTML_MODE = true ||
    true ||
    true ||
    true;
var HAS_NATIVE_MODE = true ||
    true ||
    true ||
    true;
/* tslint:disable no-var-requires */
var HTMLTextSourceBuffer = HAS_HTML_MODE ?
    __webpack_require__(296).default :
    function () {
        throw new Error("Cannot display HTML subtitles: feature not activated.");
    };
exports.HTMLTextSourceBuffer = HTMLTextSourceBuffer;
var NativeTextSourceBuffer = HAS_NATIVE_MODE ?
    __webpack_require__(313).default :
    function () {
        throw new Error("Cannot display native subtitles: feature not activated.");
    };
exports.NativeTextSourceBuffer = NativeTextSourceBuffer;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var Subject_1 = __webpack_require__(6);
var config_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var events_1 = __webpack_require__(16);
var abstract_1 = __webpack_require__(56);
var buffer_manager_1 = __webpack_require__(297);
var parsers_1 = __webpack_require__(298);
var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config_1.default.MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;
/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function generateClock(videoElement) {
    var seeking$ = events_1.onSeeking$(videoElement);
    var seeked$ = events_1.onSeeked$(videoElement);
    var ended$ = events_1.onEnded$(videoElement);
    var manualRefresh$ = Observable_1.Observable.merge(seeked$, ended$);
    var autoRefresh$ = Observable_1.Observable
        .interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)
        .startWith(null);
    // TODO Better way to express that
    return manualRefresh$
        .startWith(null)
        .switchMapTo(autoRefresh$.mapTo(true)
        .takeUntil(seeking$)
        .concat(Observable_1.Observable.of(false)));
}
/**
 * @param {Element} element
 * @param {Element|null} [child]
 */
function safelyRemoveChild(element, child) {
    if (child) {
        try {
            element.removeChild(child);
        }
        catch (e) {
            log_1.default.warn("Can't remove text track: not in the element.");
        }
    }
}
/**
 * Source buffer to display TextTracks in the given HTML element.
 * @class HTMLTextTrackSourceBuffer
 */
var HTMLTextTrackSourceBuffer = /** @class */ (function (_super) {
    __extends(HTMLTextTrackSourceBuffer, _super);
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {HTMLTrackElement} textTrackElement
     */
    function HTMLTextTrackSourceBuffer(codec, videoElement, textTrackElement) {
        var _this = this;
        log_1.default.debug("creating html text track source buffer");
        _this = _super.call(this, codec) || this;
        _this._videoElement = videoElement;
        _this._textTrackElement = textTrackElement;
        _this._destroy$ = new Subject_1.Subject();
        _this._buffer = new buffer_manager_1.default();
        _this._currentElement = null;
        generateClock(_this._videoElement)
            .takeUntil(_this._destroy$)
            .subscribe(function (shouldDisplay) {
            if (!shouldDisplay) {
                safelyRemoveChild(textTrackElement, _this._currentElement);
                _this._currentElement = null;
                return;
            }
            // to spread the time error, we divide the regular chosen interval.
            // As the clock is also based on real video events, we cannot just
            // divide by two the regular interval.
            var time = Math.max(_this._videoElement.currentTime -
                MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 3000, 0);
            var cue = _this._buffer.get(time);
            if (!cue) {
                safelyRemoveChild(textTrackElement, _this._currentElement);
                _this._currentElement = null;
                return;
            }
            else if (_this._currentElement === cue.element) {
                return;
            }
            safelyRemoveChild(textTrackElement, _this._currentElement);
            _this._currentElement = cue.element;
            textTrackElement.appendChild(_this._currentElement);
        });
        return _this;
    }
    /**
     * Append text tracks.
     * @param {Object} data
     * @param {string} data.type
     * @param {string} data.data
     * @param {string} data.language
     * @param {Number} data.timescale
     * @param {Number} data.start
     * @param {Number} data.timeOffset
     * @param {Number|undefined} data.end
     */
    HTMLTextTrackSourceBuffer.prototype._append = function (data) {
        log_1.default.debug("appending new html text tracks", data);
        var timescale = data.timescale, // timescale for the start and end
        timescaledStart = data.start, // exact beginning to which the track applies
        timescaledEnd = data.end, // exact end to which the track applies
        dataString = data.data, // text track content. Should be a string
        type = data.type, // type of texttracks (e.g. "ttml" or "vtt")
        language = data.language, // language the texttrack is in
        timeOffset = data.timeOffset;
        if (timescaledEnd && timescaledEnd - timescaledStart <= 0) {
            // this is accepted for error resilience, just skip that case.
            /* tslint:disable:max-line-length */
            log_1.default.warn("Invalid text track appended: the start time is inferior or equal to the end time.");
            /* tslint:enable:max-line-length */
            return;
        }
        var startTime = timescaledStart / timescale;
        var endTime = timescaledEnd != null ?
            timescaledEnd / timescale : undefined;
        var cues = parsers_1.default(type, dataString, timeOffset, language);
        var start = startTime;
        var end = endTime != null ? endTime : cues[cues.length - 1].end;
        this._buffer.insert(cues, start, end);
        this.buffered.insert(start, end);
    };
    /**
     * @param {Number} from
     * @param {Number} to
     */
    HTMLTextTrackSourceBuffer.prototype._remove = function (from, to) {
        log_1.default.debug("removing html text track data", from, to);
        this._buffer.remove(from, to);
    };
    /**
     * Free up ressources from this sourceBuffer
     */
    HTMLTextTrackSourceBuffer.prototype._abort = function () {
        log_1.default.debug("aborting html text track source buffer");
        this._destroy$.next();
        this._destroy$.complete();
        safelyRemoveChild(this._textTrackElement, this._currentElement);
    };
    return HTMLTextTrackSourceBuffer;
}(abstract_1.AbstractSourceBuffer));
exports.default = HTMLTextTrackSourceBuffer;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(2);
/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * source buffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the source buffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the source buffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function areNearlyEqual(a, b) {
    return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}
/**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesBefore(cues, time) {
    for (var i = 0; i < cues.length; i++) {
        var cue = cues[i];
        if (time < cue.end) {
            return cues.slice(0, i);
        }
    }
    return cues.slice();
}
/**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesAfter(cues, time) {
    for (var i = 0; i < cues.length; i++) {
        var cue = cues[i];
        if (time < cue.end) {
            return cues.slice(i + 1, cues.length);
        }
    }
    return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */
function removeCuesInfosBetween(cuesInfos, start, end) {
    var cuesInfos1 = {
        start: cuesInfos.start,
        end: start,
        cues: getCuesBefore(cuesInfos.cues, start),
    };
    var cuesInfos2 = {
        start: end,
        end: cuesInfos.end,
        cues: getCuesAfter(cuesInfos.cues, end),
    };
    return [cuesInfos1, cuesInfos2];
}
/**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */
var TextBufferManager = /** @class */ (function () {
    function TextBufferManager() {
        this._cuesBuffer = [];
    }
    /**
     * Get corresponding cue for the given time.
     * A cue is an object with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * We do not mutate individual cue here.
     * That is, if the ``get`` method returns the same cue's reference than a
     * previous ``get`` call, its properties are guaranteed to have the exact same
     * values than before, if you did not mutate it on your side.
     * The inverse is true, if the values are the same than before, the reference
     * will stay the same (this is useful to easily check if the DOM should be
     * updated, for example).
     *
     * @param {Number} time
     * @returns {HTMLElement|undefined} - The cue to display
     */
    TextBufferManager.prototype.get = function (time) {
        var cuesBuffer = this._cuesBuffer;
        // begins at the end as most of the time the player will ask for the last
        // CuesGroup
        for (var i = cuesBuffer.length - 1; i >= 0; i--) {
            var cues = cuesBuffer[i].cues;
            for (var j = cues.length - 1; j >= 0; j--) {
                var cue = cues[j];
                if (time >= cue.start) {
                    if (time < cue.end) {
                        return cue;
                    }
                    else {
                        return undefined;
                    }
                }
            }
        }
        return undefined;
    };
    /**
     * Remove cue from a certain range of time.
     * @param {Number} from
     * @param {Number} to
     */
    TextBufferManager.prototype.remove = function (from, _to) {
        if (false) {
            assert_1.default(from >= 0);
            assert_1.default(_to >= 0);
            assert_1.default(_to > from);
        }
        var to = Math.max(from, _to);
        var cuesBuffer = this._cuesBuffer;
        var len = cuesBuffer.length;
        for (var i = 0; i < len; i++) {
            var startCuesInfos = cuesBuffer[i];
            if (startCuesInfos.end >= to) {
                var _a = removeCuesInfosBetween(startCuesInfos, from, to), cuesInfos1 = _a[0], cuesInfos2 = _a[1];
                this._cuesBuffer[i] = cuesInfos1;
                cuesBuffer.splice(i + 1, 0, cuesInfos2);
                return;
            }
            else {
                startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
                startCuesInfos.end = from;
            }
            for (var j = i + 1; j < len; j++) {
                var endCuesInfos = cuesBuffer[i];
                if (to < endCuesInfos.end) {
                    cuesBuffer.splice(i + 1, j - (i + 1));
                    endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to);
                    endCuesInfos.start = to;
                    return;
                }
            }
            cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
            return;
        }
    };
    /**
     * Insert new cues in our text buffer.
     * cues is an array of objects with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * @param {Array.<Object>} cues - CuesGroups, array of objects with the
     * following properties:
     *   - start {Number}: the time at which the cue will start to be displayed
     *   - end {Number}: the time at which the cue will end to be displayed
     *   - cue {HTMLElement}: The cue
     * @param {Number} start - Start time at which the CuesGroup applies.
     * This is different than the start of the first cue to display in it, this
     * has more to do with the time at which the _text segment_ starts.
     * @param {Number} end - End time at which the CuesGroup applies.
     * This is different than the end of the last cue to display in it, this
     * has more to do with the time at which the _text segment_ ends.
     *
     * TODO add securities to ensure that:
     *   - the start of a CuesGroup is inferior or equal to the start of the first
     *     cue in it
     *   - the end of a CuesGroup is superior or equal to the end of the last
     *     cue in it
     * If those requirements are not met, we could delete some cues when adding
     * a CuesGroup before/after. Find a solution.
     */
    TextBufferManager.prototype.insert = function (cues, start, end) {
        var cuesBuffer = this._cuesBuffer;
        var cuesInfosToInsert = { start: start, end: end, cues: cues };
        for (var i = 0; i < cuesBuffer.length; i++) {
            var cuesInfos = cuesBuffer[i];
            if (start < cuesInfos.end) {
                if (areNearlyEqual(start, cuesInfos.start)) {
                    if (areNearlyEqual(end, cuesInfos.end)) {
                        // exact same segment
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |AAAAA|
                        // Which means:
                        //   1. replace the current cue with ours
                        cuesBuffer[i] = cuesInfosToInsert;
                        return;
                    }
                    else if (end < cuesInfos.end) {
                        // our cue overlaps with the current one:
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBBBBB|
                        //   Result:          |AAAAABBB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    // our cue goes beyond the current one:
                    //   ours:            |AAAAAAA|
                    //   the current one: |BBBB|
                    //   Result:          |AAAAAAA|
                    // Here we have to delete any cuesInfos which end before ours end,
                    // and see about the following one.
                    do {
                        cuesBuffer.splice(i, 1);
                        cuesInfos = cuesBuffer[i];
                    } while (cuesInfos && end > cuesInfos.end);
                    if (!cuesInfos) {
                        // There was no more cue, add ours
                        cuesBuffer[i] = cuesInfosToInsert;
                        return;
                    }
                    else if (areNearlyEqual(end, cuesInfos.end)) {
                        cuesBuffer[i] = cuesInfosToInsert; // replace
                        return;
                    }
                    // else -> end < cuesInfos.end (overlapping case)
                    //   ours:            |AAAAA|
                    //   the current one: |BBBBBBBB|
                    //   Result:          |AAAAABBB|
                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                    cuesInfos.start = end;
                    cuesBuffer.splice(i, 0, cuesInfosToInsert);
                    return;
                }
                else if (start < cuesInfos.start) {
                    if (end < cuesInfos.start) {
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    else if (areNearlyEqual(end, cuesInfos.start)) {
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    // our cue overlaps the current one:
                    //   ours:            |AAAAAAA|
                    //   the current one:     |BBBBB|
                    //   Result:          |AAAAAAABB|
                    // Which means:
                    //   1. remove some cues at the start of the current one
                    //   2. update start of current one
                    //   3. add ours before the current one
                    cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                    cuesInfos.start = end;
                    cuesBuffer.splice(i, 0, cuesInfosToInsert);
                    return;
                }
                // else -> start > cuesInfos.start
                if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) {
                    // our cue overlaps the current one:
                    //   ours:              |AAAAAA|
                    //   the current one: |BBBBB|
                    //   Result:          |BBAAAAAA|
                    //   - or -
                    //   ours:              |AAAA|
                    //   the current one: |BBBBBB|
                    //   Result:          |BBAAAA|
                    // Which means:
                    //   1. remove some cues at the end of the current one
                    //   2. update end of current one
                    //   3. add ours after current one
                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
                    cuesInfos.end = start;
                    cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                    return;
                }
                // else -> end < cuesInfos.end
                // our cue is in the current one:
                //   ours:              |AAA|
                //   the current one: |BBBBBBB|
                //   Result:          |BBAAABB|
                // Which means:
                //   1. split current one in two parts based on our cue.
                //   2. insert our cue into it.
                var _a = removeCuesInfosBetween(cuesInfos, start, end), cuesInfos1 = _a[0], cuesInfos2 = _a[1];
                this._cuesBuffer[i] = cuesInfos1;
                cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                cuesBuffer.splice(i + 2, 0, cuesInfos2);
                return;
            }
        }
        // no cues group has the end after our current start.
        // These cues should be the last one
        cuesBuffer.push(cuesInfosToInsert);
    };
    return TextBufferManager;
}());
exports.default = TextBufferManager;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var htmlParsers = {};
/* tslint:disable no-var-requires */
if (true) {
    htmlParsers.sami =
        __webpack_require__(299).default;
}
if (true) {
    htmlParsers.ttml =
        __webpack_require__(300).default;
}
if (true) {
    htmlParsers.srt =
        __webpack_require__(306).default;
}
if (true) {
    htmlParsers.vtt =
        __webpack_require__(307).default;
}
/* tslint:enable no-var-requires */
/**
 * @param {string} type
 * @param {string} data
 * @param {Number} timeOffset
 * @param {string} [language]
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToElements(type, data, timeOffset, language) {
    log_1.default.debug("finding parser for html text tracks:", type);
    var parser = htmlParsers[type];
    if (!parser) {
        throw new Error("no parser found for the given text track");
    }
    log_1.default.debug("parser found, parsing...");
    var parsed = parser(data, timeOffset, language);
    log_1.default.debug("parsed successfully!", parsed);
    return parsed;
}
exports.default = parseTextTrackToElements;


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.
var assert_1 = __webpack_require__(2);
var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    var langs = {};
    var m;
    while ((m = ruleRe.exec(str))) {
        var name_1 = m[1];
        var lang = getCSSProperty(m[2], "lang");
        if (name_1 != null && lang != null) {
            langs[lang] = name_1;
        }
    }
    return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */
function getPCSSRules(str) {
    var pRuleRegex = /p\s*{([^}]*)}/gi;
    var rule = pRuleRegex.exec(str);
    if (!rule) {
        return "";
    }
    return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
    return matches ? matches[1] : null;
}
/**
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */
function parseSami(smi, timeOffset, lang) {
    var syncOpen = /<sync[ >]/ig;
    var syncClose = /<sync[ >]|<\/body>/ig;
    var subs = [];
    var styleMatches = smi.match(STYLE);
    var css = styleMatches ? styleMatches[1] : "";
    var up;
    var to = syncClose.exec(smi);
    var langs = getClassNameByLang(css);
    var pCSS = getPCSSRules(css);
    var klass = langs[lang];
    assert_1.default(klass, "sami: could not find lang " + lang + " in CSS");
    for (;;) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (!up && !to) {
            break;
        }
        if (!up || !to || up.index >= to.index) {
            throw new Error("parse error");
        }
        var str = smi.slice(up.index, to.index);
        var tim = str.match(START);
        if (!tim) {
            throw new Error("parse error (sync time attribute)");
        }
        var start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return subs;
    function appendToSubs(lines, start) {
        var i = lines.length;
        while (--i >= 0) {
            var paragraphInfos = lines[i].match(PARAG);
            if (!paragraphInfos) {
                continue;
            }
            var className = paragraphInfos[1], txt = paragraphInfos[2];
            if (klass !== className) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                var wrapperEl = document.createElement("DIV");
                wrapperEl.className = "rxp-texttrack-region";
                var divEl = document.createElement("DIV");
                divEl.className = "rxp-texttrack-div";
                divEl.style.position = "absolute";
                divEl.style.bottom = "0";
                divEl.style.width = "100%";
                divEl.style.color = "#fff";
                divEl.style.textShadow = "-1px -1px 0 #000," +
                    "1px -1px 0 #000," +
                    "-1px 1px 0 #000," +
                    "1px 1px 0 #000";
                var pEl = document.createElement("div");
                pEl.className = "rxp-texttrack-p";
                if (pCSS) {
                    pEl.style.cssText = pCSS;
                }
                var textEls = txt.split(BR);
                for (var j = 0; j < textEls.length; j++) {
                    if (j) {
                        pEl.appendChild(document.createElement("BR"));
                    }
                    var spanEl = document.createElement("SPAN");
                    spanEl.className = "rxp-texttrack-span";
                    spanEl.textContent = decodeEntities(textEls[j]);
                    pEl.appendChild(spanEl);
                }
                divEl.appendChild(pEl);
                wrapperEl.appendChild(divEl);
                subs.push({
                    element: wrapperEl,
                    start: start + timeOffset,
                    end: -1,
                });
            }
        }
    }
}
exports.default = parseSami;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
var objectAssign = __webpack_require__(7);
var getParameters_1 = __webpack_require__(98);
var getParentElementsByTagName_1 = __webpack_require__(57);
var nodes_1 = __webpack_require__(99);
var style_1 = __webpack_require__(58);
var constants_1 = __webpack_require__(302);
var parseCue_1 = __webpack_require__(303);
/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseTTMLStringToDIV(str, timeOffset) {
    var ret = [];
    var xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml) {
        var tts = xml.getElementsByTagName("tt");
        var tt = tts[0];
        if (!tt) {
            throw new Error("invalid XML");
        }
        var body = nodes_1.getBodyNode(tt);
        var styleNodes = nodes_1.getStyleNodes(tt);
        var regionNodes = nodes_1.getRegionNodes(tt);
        var textNodes = nodes_1.getTextNodes(tt);
        var params = getParameters_1.default(tt);
        // construct styles array based on the xml as an optimization
        var styles = [];
        for (var i = 0; i <= styleNodes.length - 1; i++) {
            var styleNode = styleNodes[i];
            if (styleNode instanceof Element) {
                var styleID = styleNode.getAttribute("xml:id");
                if (styleID !== null) {
                    // TODO styles referencing other styles
                    styles.push({
                        id: styleID,
                        style: style_1.getStylingFromElement(styleNode),
                    });
                }
            }
        }
        // construct regions array based on the xml as an optimization
        var regions = [];
        var _loop_1 = function (i) {
            var regionNode = regionNodes[i];
            if (regionNode instanceof Element) {
                var regionID = regionNode.getAttribute("xml:id");
                if (regionID !== null) {
                    var regionStyle = style_1.getStylingFromElement(regionNode);
                    var associatedStyle_1 = regionNode.getAttribute("style");
                    if (associatedStyle_1) {
                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });
                        if (style) {
                            regionStyle = objectAssign({}, style.style, regionStyle);
                        }
                    }
                    regions.push({
                        id: regionID,
                        style: regionStyle,
                    });
                }
            }
        };
        for (var i = 0; i <= regionNodes.length - 1; i++) {
            _loop_1(i);
        }
        // Computing the style takes a lot of ressources.
        // To avoid too much re-computation, let's compute the body style right
        // now and do the rest progressively.
        // TODO Compute corresponding CSS style here (as soon as we now the TTML
        // style) to speed up the process even
        // more.
        var bodyStyle = body !== null ?
            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [body], styles, regions) :
            style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [], styles, regions);
        for (var i = 0; i < textNodes.length; i++) {
            var paragraph = textNodes[i];
            if (paragraph instanceof Element) {
                var divs = getParentElementsByTagName_1.default(paragraph, "div");
                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(constants_1.STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
                var cue = parseCue_1.default(paragraph, timeOffset, styles, regions, body, paragraphStyle, params);
                if (cue) {
                    ret.push(cue);
                }
            }
        }
    }
    return ret;
}
exports.default = parseTTMLStringToDIV;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// inspired from MDN polyfill, but ponyfilled instead
function startsWith(completeString, searchString, position) {
    if (typeof String.prototype.startsWith === "function") {
        return completeString.startsWith(searchString, position);
    }
    return completeString
        .substr(position || 0, searchString.length) === searchString;
}
exports.default = startsWith;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.STYLE_ATTRIBUTES = [
    "backgroundColor",
    "color",
    "direction",
    "display",
    "displayAlign",
    "extent",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lineHeight",
    "opacity",
    "origin",
    "overflow",
    "padding",
    "textAlign",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
    "writingMode",
];


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var getTimeDelimiters_1 = __webpack_require__(100);
var createElement_1 = __webpack_require__(305);
/**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Element} body
 * @param {Object} styleBase
 * @param {Object} ttParams
 * @returns {Object|null}
 */
function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams) {
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent || "")) {
        return null;
    }
    var _a = getTimeDelimiters_1.default(paragraph, ttParams), start = _a.start, end = _a.end;
    var element = createElement_1.default(paragraph, body, regions, styles, styleBase, ttParams.spaceStyle === "default");
    return {
        start: start + offset,
        end: end + offset,
        element: element,
    };
}
exports.default = parseCue;


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var regexps_1 = __webpack_require__(59);
/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */
function parseTime(text, ttParams) {
    if (regexps_1.REGXP_TIME_COLON_FRAMES.test(text)) {
        return parseColonTimeWithFrames(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_COLON.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON, text);
    }
    else if (regexps_1.REGXP_TIME_COLON_MS.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_COLON_MS, text);
    }
    else if (regexps_1.REGXP_TIME_FRAMES.test(text)) {
        return parseFramesTime(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_TICK.test(text)) {
        return parseTickTime(ttParams, text);
    }
    else if (regexps_1.REGXP_TIME_HMS.test(text)) {
        return parseTimeFromRegExp(regexps_1.REGXP_TIME_HMS, text);
    }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseFramesTime(ttParams, text) {
    // 75f or 75.5f
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_FRAMES.exec(text);
    var frames = Number(results[1]);
    return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseTickTime(ttParams, text) {
    // 50t or 50.5t
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_TICK.exec(text);
    var ticks = Number(results[1]);
    return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseColonTimeWithFrames(ttParams, text) {
    // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
    // (We cast as we're sure the regexp is respected here)
    var results = regexps_1.REGXP_TIME_COLON_FRAMES.exec(text);
    var hours = Number(results[1]);
    var minutes = Number(results[2]);
    var seconds = Number(results[3]);
    var frames = Number(results[4]);
    var subframes = Number(results[5]) || 0;
    frames += subframes / ttParams.subFrameRate;
    seconds += frames / ttParams.frameRate;
    return seconds + (minutes * 60) + (hours * 3600);
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */
function parseTimeFromRegExp(regex, text) {
    var results = regex.exec(text);
    if (results === null || results[0] === "") {
        return null;
    }
    // This capture is optional, but will still be in the array as undefined,
    // default to 0.
    var hours = Number(results[1]) || 0;
    var minutes = Number(results[2]) || 0;
    var seconds = Number(results[3]) || 0;
    var miliseconds = Number(results[4]) || 0;
    return (miliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);
}
exports.default = parseTime;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var getParentElementsByTagName_1 = __webpack_require__(57);
var regexps_1 = __webpack_require__(59);
var style_1 = __webpack_require__(58);
// import getAttributeInElements from "../getAttributeInElements";
// Styling which can be applied to <span> from any level upper.
// Added here as an optimization
var SPAN_LEVEL_ATTRIBUTES = [
    "color",
    "direction",
    "display",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
];
/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
function ttmlColorToCSSColor(color) {
    // TODO check all possible color fomats
    var regRes;
    regRes = regexps_1.REGXP_8_HEX_COLOR.exec(color);
    if (regRes != null) {
        return "rgba(" +
            parseInt(regRes[1], 16) + "," +
            parseInt(regRes[2], 16) + "," +
            parseInt(regRes[3], 16) + "," +
            parseInt(regRes[4], 16) / 255 + ")";
    }
    regRes = regexps_1.REGXP_4_HEX_COLOR.exec(color);
    if (regRes != null) {
        return "rgba(" +
            parseInt(regRes[1] + regRes[1], 16) + "," +
            parseInt(regRes[2] + regRes[2], 16) + "," +
            parseInt(regRes[3] + regRes[3], 16) + "," +
            parseInt(regRes[4] + regRes[4], 16) / 255 + ")";
    }
    return color;
}
/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
    return "-1px -1px " + thickness + " " + color + "," +
        ("1px -1px " + thickness + " " + color + ",") +
        ("-1px 1px " + thickness + " " + color + ",") +
        ("1px 1px " + thickness + " " + color);
}
// TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)
/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */
function applyTextStyle(element, style) {
    // applies to span
    var color = style.color;
    if (color) {
        element.style.color = ttmlColorToCSSColor(color);
    }
    // applies to body, div, p, region, span
    var backgroundColor = style.backgroundColor;
    if (backgroundColor) {
        element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
    }
    // applies to span
    var wrapOption = style.wrapOption;
    if (wrapOption && wrapOption === "noWrap") {
        element.style.whiteSpace = "nowrap";
    }
    // applies to span
    var textOutline = style.textOutline;
    if (textOutline) {
        var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
        var len = outlineData.length;
        if (len === 3) {
            var outlineColor = ttmlColorToCSSColor(outlineData[0]);
            var thickness = outlineData[1];
            element.style.textShadow =
                generateCSSTextOutline(outlineColor, thickness);
        }
        else if (color && len === 1) {
            var thickness = outlineData[0];
            element.style.textShadow = generateCSSTextOutline(color, thickness);
        }
        else if (len === 2) {
            var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
            var isFirstArgANumber = /^[0-9]/.test(outlineData[0]);
            // XOR-ing to be sure we get what we have
            if (isFirstArgAColor !== isFirstArgANumber) {
                if (isFirstArgAColor) {
                    var outlineColor = ttmlColorToCSSColor(outlineData[0]);
                    var thickness = outlineData[1];
                    element.style.textShadow =
                        generateCSSTextOutline(outlineColor, thickness);
                }
                else if (color) {
                    var thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, thickness);
                }
            }
        }
    }
    // applies to span
    var textDecoration = style.textDecoration;
    if (textDecoration) {
        switch (textDecoration) {
            case "noUnderline":
            case "noLineThrough":
            case "noOverline":
                element.style.textDecoration = "none";
                break;
            case "lineThrough":
                element.style.textDecoration = "line-through";
                break;
            default:
                element.style.textDecoration = textDecoration;
                break;
        }
    }
    // applies to span
    var fontFamily = style.fontFamily;
    if (fontFamily) {
        switch (fontFamily) {
            case "proportionalSansSerif":
                element.style.fontFamily =
                    "Arial, Helvetica, Liberation Sans, sans-serif";
                break;
            // TODO monospace or sans-serif or font with both?
            case "monospaceSansSerif":
            case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;
            case "monospaceSerif":
            case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;
            // TODO font with both?
            case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;
            default:
                element.style.fontFamily = fontFamily;
        }
    }
    // applies to span
    var fontStyle = style.fontStyle;
    if (fontStyle) {
        element.style.fontStyle = fontStyle;
    }
    // applies to span
    var fontWeight = style.fontWeight;
    if (fontWeight) {
        element.style.fontWeight = fontWeight;
    }
    // applies to span
    var fontSize = style.fontSize;
    if (fontSize) {
        // TODO Check if formats are always really 1:1
        element.style.fontSize = fontSize;
    }
    // applies to p, span
    var direction = style.direction;
    if (direction) {
        element.style.direction = direction;
    }
    // applies to p, span
    var unicodeBidi = style.unicodeBidi;
    if (unicodeBidi) {
        switch (unicodeBidi) {
            case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;
            case "embed":
                element.style.unicodeBidi = "embed";
                break;
            default:
                element.style.unicodeBidi = "normal";
        }
    }
    // applies to body, div, p, region, span
    var visibility = style.visibility;
    if (visibility) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    var display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */
function applyGeneralStyle(element, style) {
    // applies to tt, region
    var extent = style.extent;
    if (extent) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);
        if (results != null) {
            element.style.width = results[1] + "%";
            element.style.height = results[2] + "%";
        }
    }
    // applies to region
    var writingMode = style.writingMode;
    if (writingMode) {
        // TODO
    }
    // applies to region
    var overflow = style.overflow;
    element.style.overflow = overflow || "hidden";
    // applies to region
    var padding = style.padding;
    if (padding) {
        element.style.padding = padding;
    }
    // applies to region
    var origin = style.origin;
    if (origin) {
        var resultsPercent = regexps_1.REGXP_PERCENT_VALUES.exec(origin);
        if (resultsPercent != null) {
            element.style.position = "relative";
            element.style.left = resultsPercent[1] + "%";
            element.style.top = resultsPercent[2] + "%";
        }
        else {
            // TODO also px
        }
    }
    // applies to region
    var displayAlign = style.displayAlign;
    element.style.display = "flex";
    element.style.flexDirection = "column";
    if (displayAlign) {
        switch (displayAlign) {
            case "before":
                element.style.justifyContent = "flex-start";
                break;
            case "center":
                element.style.justifyContent = "center";
                break;
            case "after":
                element.style.justifyContent = "flex-end";
                break;
        }
    }
    // applies to region
    var opacity = style.opacity;
    if (opacity) {
        element.style.opacity = opacity;
    }
    // applies to body, div, p, region, span
    var visibility = style.visibility;
    if (visibility) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    var display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */
function applyPStyle(element, style) {
    // applies to body, div, p, region, span
    var paragraphBackgroundColor = style.backgroundColor;
    if (paragraphBackgroundColor) {
        element.style.backgroundColor =
            ttmlColorToCSSColor(paragraphBackgroundColor);
    }
    // applies to p
    var lineHeight = style.lineHeight;
    if (lineHeight) {
        element.style.lineHeight = lineHeight;
    }
    // applies to p
    var textAlign = style.textAlign;
    if (textAlign) {
        switch (textAlign) {
            case "center":
                element.style.textAlign = "center";
                break;
            case "left":
            case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;
            case "right":
            case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
                break;
        }
    }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Array.<Element>} spans - <span> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} p - <p> tag which contain the element.
 * @param {Array.<Element>} divs - <div> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} body - <body> tag which contain the element.
 * @param {Array.<Object>} regions - Every <region> tag which can apply to
 * this element.
 * @param {Array.<Object>} styles - Every <style> tag which can apply to
 * this element.
 * @param {Boolean} shouldTrimWhiteSpaceParam - True if the space should be
 * trimmed by default. From the <tt> xml:space parameter.
 * @returns {HTMLElement}
 */
function createTextElement(el, style, shouldTrimWhiteSpaceParam) {
    var textElement = document.createElement("span");
    var textContent = el.textContent || "";
    var shouldTrimWhiteSpace = shouldTrimWhiteSpaceParam;
    // TODO Also parse it from parent elements
    // const spaceAttr = getAttributeInElements("xml:space", [
    //   ...spans, p, ...divs, body,
    // ]);
    // const shouldTrimWhiteSpace = spaceAttr ?
    //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
    if (shouldTrimWhiteSpace) {
        // 1. Trim leading and trailing whitespace.
        // 2. Collapse multiple spaces into one.
        var trimmed = textContent.trim();
        trimmed = trimmed.replace(/\s+/g, " ");
        textContent = trimmed;
    }
    textElement.innerHTML = textContent;
    textElement.className = "rxp-texttrack-span";
    applyTextStyle(textElement, style);
    return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */
function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding array of HTMLElement in order.
     * @param {Node} node - the node in question
     * @param {Object} style - the current state of the style for the node.
     * /!\ The style object can be mutated, provide a copy of it.
     * @param {Array.<Element>} spans - The spans parent of this node.
     * @returns {Array.<HTMLElement>}
     */
    function loop(node, style, spans) {
        var childNodes = node.childNodes;
        var elements = [];
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                var backgroundColor = style_1.getStylingAttributes(["backgroundColor"], spans, styles, regions).backgroundColor;
                if (backgroundColor) {
                    style.backgroundColor = backgroundColor;
                }
                else {
                    delete style.backgroundColor;
                }
                var el = createTextElement(currentNode, style, shouldTrimWhiteSpace);
                elements.push(el);
            }
            else if (currentNode.nodeName === "br") {
                var br = document.createElement("BR");
                elements.push(br);
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.childNodes.length > 0) {
                // compute the new applyable style
                var newStyle = objectAssign({}, style, style_1.getStylingAttributes(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
                elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans)));
            }
        }
        return elements;
    }
    return loop(paragraph, objectAssign({}, paragraphStyle), []);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} styles
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {HTMLElement}
 */
function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    var divs = getParentElementsByTagName_1.default(paragraph, "div");
    var parentElement = document.createElement("DIV");
    parentElement.className = "rxp-texttrack-region";
    applyGeneralStyle(parentElement, paragraphStyle);
    if (body) {
        // applies to body, div, p, region, span
        var bodyBackgroundColor = style_1.getStylingAttributes(["backgroundColor"], divs.concat([body]), styles, regions).bodyBackgroundColor;
        if (bodyBackgroundColor) {
            parentElement.style.backgroundColor =
                ttmlColorToCSSColor(bodyBackgroundColor);
        }
    }
    var pElement = document.createElement("p");
    pElement.className = "rxp-texttrack-p";
    applyPStyle(pElement, paragraphStyle);
    var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);
    for (var i = 0; i < textContent.length; i++) {
        pElement.appendChild(textContent[i]);
    }
    // NOTE:
    // The following code is for the inclusion of div elements. This has no
    // advantage for now, and might only with future evolutions.
    // (This is only an indication of what the base of the code could look like).
    // if (divs.length) {
    //   let container = parentElement;
    //   for (let i = divs.length - 1; i >= 0; i--) {
    //     // TODO manage style at div level?
    //     // They are: visibility, display and backgroundColor
    //     // All these do not have any difference if applied to the <p> element
    //     // instead of the div.
    //     // The advantage might only be for multiple <p> elements dispatched
    //     // in multiple div Which we do not manage anyway for now.
    //     const divEl = document.createElement("DIV");
    //     divEl.className = "rxp-texttrack-div";
    //     container.appendChild(divEl);
    //     container = divEl;
    //   }
    //   container.appendChild(pElement);
    //   parentElement.appendChild(container);
    // } else {
    //   parentElement.appendChild(pElement);
    // }
    parentElement.appendChild(pElement);
    return parentElement;
}
exports.default = createElement;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.
var parseTimestamp_1 = __webpack_require__(101);
/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseSRTStringToHTML(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    var lines = srtStr.split(/\r\n|\n|\r/);
    var cueBlocks = [];
    for (var i = 0; i < lines.length; i++) {
        if (lines[i]) {
            var startingI = i;
            i++;
            while (lines[i]) {
                i++;
            }
            cueBlocks.push(lines.slice(startingI, i));
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseSRTStringToHTML;
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */
function parseCue(cueLines, timeOffset) {
    var _a = cueLines[1].split(" --> "), startString = _a[0], endString = _a[1];
    var payloadLines = cueLines.slice(2, cueLines.length);
    if (!startString || !endString || !payloadLines.length) {
        return null;
    }
    var start = parseTimestamp_1.default(startString);
    var end = parseTimestamp_1.default(endString);
    if (start == null || end == null) {
        return null;
    }
    var pEl = document.createElement("div");
    pEl.className = "rxp-texttrack-p";
    pEl.style.fontSize = "28px";
    pEl.style.position = "absolute";
    pEl.style.bottom = "5%";
    pEl.style.width = "100%";
    pEl.style.textAlign = "center";
    pEl.style.color = "#fff";
    pEl.style.textShadow = "-1px -1px 2px #000," +
        "1px -1px 2px #000," +
        "-1px 1px 2px #000," +
        "1px 1px 2px #000";
    for (var i = 0; i < payloadLines.length; i++) {
        if (i) {
            pEl.appendChild(document.createElement("br"));
        }
        var span = generateSpansFromSRTText(payloadLines[i]);
        pEl.appendChild(span);
    }
    return {
        start: start + timeOffset,
        end: end + timeOffset,
        element: pEl,
    };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */
function generateSpansFromSRTText(text) {
    var secureDiv = document.createElement("div");
    secureDiv.innerHTML = text;
    var _loop = function (node) {
        var childNodes = node.childNodes;
        var span = document.createElement("span");
        span.className = "rxp-texttrack-span";
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                span.innerHTML += currentNode.textContent;
            }
            else if (currentNode.nodeName === "B") {
                var spanChild = _loop(currentNode);
                spanChild.style.fontWeight = "bold";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "I") {
                var spanChild = _loop(currentNode);
                spanChild.style.fontStyle = "italic";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "U") {
                var spanChild = _loop(currentNode);
                spanChild.style.textDecoration = "underline";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "FONT" &&
                currentNode.color != null) {
                // TODO loop through attributes to find color?
                var spanChild = _loop(currentNode);
                spanChild.style.color = currentNode.color;
                span.appendChild(spanChild);
            }
            else {
                var spanChild = _loop(currentNode);
                span.appendChild(spanChild);
            }
        }
        return span;
    };
    return _loop(secureDiv);
}


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var formatCueLineToHTML_1 = __webpack_require__(308);
var parseStyleBlock_1 = __webpack_require__(309);
var parseTimeCode_1 = __webpack_require__(310);
var utils_1 = __webpack_require__(312);
/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @param {string} text
 * @param {Number} timeOffset
 * @return {Array.<Object>}
 * @throws Error - Throws if the given WebVTT string is invalid.
 */
function parseWebVTT(text, timeOffset) {
    var newLineChar = /\r\n|\n|\r/g;
    var linified = text.split(newLineChar);
    var cuesArray = [];
    var styleElements = [];
    if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) {
        throw new Error("Can't parse WebVTT: Invalid File.");
    }
    var firstLineAfterHeader = utils_1.getFirstLineAfterHeader(linified);
    for (var i = firstLineAfterHeader; i < linified.length; i++) {
        if (utils_1.isStartOfStyleBlock(linified[i])) {
            var startOfStyleBlock = i;
            i++;
            // continue incrementing i until either:
            //   - empty line
            //   - end of file
            while (!(linified[i].length === 0)) {
                i++;
            }
            var styleBlock = linified.slice(startOfStyleBlock, i);
            var parsedStyles = parseStyleBlock_1.default(styleBlock);
            styleElements.push.apply(styleElements, parsedStyles);
        }
    }
    // Parse cues, format and apply style.
    for (var i = firstLineAfterHeader; i < linified.length; i++) {
        if (!(linified[i].length === 0)) {
            if (utils_1.isStartOfCueBlock(linified[i])) {
                var startOfCueBlock = i;
                i++;
                // continue incrementing i until either:
                //   - empty line
                //   - end of file
                while (!(linified[i].length === 0)) {
                    i++;
                }
                var cueBlock = linified.slice(startOfCueBlock, i);
                var cue = parseCue(cueBlock, timeOffset, styleElements);
                if (cue) {
                    cuesArray.push(cue);
                }
            }
            else {
                while (!(linified[i].length === 0)) {
                    i++;
                }
            }
        }
    }
    return cuesArray;
}
exports.default = parseWebVTT;
/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} styleElements
 * @returns {Object|undefined}
 */
function parseCue(cueBlock, timeOffset, styleElements) {
    var region = document.createElement("div");
    var regionAttr = document.createAttribute("style");
    var index = 0;
    regionAttr.value =
        "width:100%; \
    height:100%; \
    display:flex; \
    flex-direction:column; \
    justify-content:flex-end; \
    align-items:center;";
    region.setAttributeNode(regionAttr);
    // Get Header. It may be a class name associated with cue.
    var header = cueBlock[index];
    index++;
    // Get time ranges.
    var timeCodes = cueBlock[index];
    var range = parseTimeCode_1.default(timeCodes);
    if (!range || range.start === undefined || range.end === undefined) {
        log_1.default.warn("VTT: Invalid cue, the timecode line could not be parsed.");
        return undefined; // cancel if we do not find the start or end of this cue
    }
    index++;
    // Get content, format and apply style.
    var pElement = document.createElement("p");
    var pAttr = document.createAttribute("style");
    pAttr.value = "text-align:center";
    pElement.setAttributeNode(pAttr);
    var spanElement = document.createElement("span");
    var attr = document.createAttribute("style");
    // set color and background-color default values, as indicated in:
    // https://www.w3.org/TR/webvtt1/#applying-css-properties
    attr.value =
        "background-color:rgba(0,0,0,0.8); \
    color:white;";
    spanElement.setAttributeNode(attr);
    var styles = styleElements
        .filter(function (styleElement) {
        return (styleElement.className === header && !styleElement.isGlobalStyle) ||
            styleElement.isGlobalStyle;
    }).map(function (styleElement) { return styleElement.styleContent; });
    if (styles) {
        attr.value += styles.join();
        spanElement.setAttributeNode(attr);
    }
    while (cueBlock[index]) {
        if (spanElement.childNodes.length !== 0) {
            spanElement.appendChild(document.createElement("br"));
        }
        formatCueLineToHTML_1.default(cueBlock[index], styleElements)
            .forEach(function (child) {
            spanElement.appendChild(child);
        });
        index++;
    }
    region.appendChild(pElement);
    pElement.appendChild(spanElement);
    return {
        start: range.start + timeOffset,
        end: range.end + timeOffset,
        element: region,
    };
}


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array_includes_1 = __webpack_require__(9);
/**
 * Format WebVTT tags and classes into usual HTML.
 * <b *> => <b>
 * <u *> => <u>
 * <i *> => <i>
 * <c.class *> => <c.class>
 * Style is inserted if associated to tag or class.
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<Node>}
 */
function formatCueLineToHTML(text, styleElements) {
    var HTMLTags = ["u", "i", "b"];
    var webVTTTags = ["u", "i", "b", "c", "#text"];
    var styleClasses = styleElements.map(function (styleElement) { return styleElement.className; });
    var filtered = text
        .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "")
        .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
    var parser = new DOMParser();
    var parsedWebVTT = parser.parseFromString(filtered, "text/html");
    var nodes = parsedWebVTT.body.childNodes;
    /**
     * Apply styles to specifig tag in children nodes.
     * (e.g. If class "b" has style, then : <b style="content">
     * )
     * Change class tags into span with associated style, or text*
     * First it was: <c.class>...</c>. Then <class></class>.
     * Finally <span style="content"></span> or text.
     * @param {Array.<Node>} childNodes
     * @returns {Array.<Node>}
     */
    function parseNode(nodeToParse) {
        var parsedNodeArray = [];
        for (var i = 0; i < nodeToParse.length; i++) {
            parsedNodeArray[i] = createStyleElement(nodeToParse[i]);
        }
        /**
         * Construct an HTMLElement/TextNode representing the given node and apply
         * the right styling on it.
         * @param {Node} baseNode
         * @returns {Node}
         */
        function createStyleElement(baseNode) {
            var mainTag = baseNode.nodeName.toLowerCase().split(".")[0];
            var nodeWithStyle;
            if (array_includes_1.default(webVTTTags, mainTag)) {
                if (mainTag === "#text") {
                    nodeWithStyle = document.createTextNode(baseNode.wholeText);
                }
                else {
                    var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
                    var classIndexes_1 = [];
                    nodeClasses.forEach(function (nodeClass) {
                        if (styleClasses.indexOf(nodeClass) !== -1) {
                            classIndexes_1.push(styleClasses.indexOf(nodeClass));
                        }
                    });
                    if (classIndexes_1.length !== 0) {
                        var attr_1 = document.createAttribute("style");
                        classIndexes_1.forEach(function (index) {
                            attr_1.value += styleElements[index].styleContent;
                        });
                        var nameClass = array_includes_1.default(HTMLTags, mainTag) ? mainTag : "span";
                        nodeWithStyle = document.createElement(nameClass);
                        nodeWithStyle.setAttributeNode(attr_1);
                    }
                    else {
                        var elementTag = !array_includes_1.default(HTMLTags, mainTag) ? "span" : mainTag;
                        nodeWithStyle = document.createElement(elementTag);
                    }
                    for (var j = 0; j < baseNode.childNodes.length; j++) {
                        nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));
                    }
                }
            }
            else {
                nodeWithStyle = document.createElement("span");
                for (var j = 0; j < baseNode.childNodes.length; j++) {
                    nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));
                }
            }
            return nodeWithStyle;
        }
        return parsedNodeArray;
    }
    return parseNode(nodes);
}
exports.default = formatCueLineToHTML;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @return {Array.<Object>} styleElements
 */
function parseStyleBlock(styleBlock) {
    var styleElements = [];
    var index = 1;
    var classNames = [];
    if (styleBlock[index].match(/::cue {/)) {
        classNames.push({ isGlobalStyle: true });
        index++;
    }
    else {
        var cueClassLine = void 0;
        while (cueClassLine = styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/)) {
            classNames.push({
                className: cueClassLine[1],
                isGlobalStyle: false,
            });
            index++;
        }
    }
    var styleContent = "";
    while (!(styleBlock[index].match(/}/)
        || styleBlock[index].length === 0)) {
        styleContent += styleBlock[index];
        index++;
    }
    classNames.forEach(function (name) {
        styleElements.push({
            className: name.className,
            isGlobalStyle: name.isGlobalStyle,
            styleContent: styleContent.replace(/\s/g, ""),
        });
    });
    return styleElements;
}
exports.default = parseStyleBlock;


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var parseTimestamp_1 = __webpack_require__(311);
/**
 * Parse the VTT timecode line given and construct an object with two
 * properties:
 *   - start {Number|undefined}: the corresponding start time in seconds
 *   - end {Number|undefined}: the corresponding end time in seconds
 * @example
 * ```js
 * parseTimeCode("00:02:30 --> 00:03:00");
 * // -> {
 * //      start: 150,
 * //      end: 180,
 * //    }
 * ```
 * @param {string} text
 * @returns {Object|undefined}
 */
function parseTimeCode(text) {
    var tsRegex = "((?:[0-9]{2}\:)?[0-9]{2}:[0-9]{2}.[0-9]{2,3})";
    var startEndRegex = tsRegex + "(?:\ |\t)-->(?:\ |\t)" + tsRegex;
    var ranges = text.match(startEndRegex);
    if (ranges && ranges.length >= 3) {
        var start = parseTimestamp_1.default(ranges[1]);
        var end = parseTimestamp_1.default(ranges[2]);
        return { start: start, end: end };
    }
}
exports.default = parseTimeCode;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":").reverse();
    if (splittedTS[2] || splittedTS[1]) {
        var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0;
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[0].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}
exports.default = parseTimestamp;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
function getFirstLineAfterHeader(linified) {
    var i = 0;
    while (i < linified.length) {
        if (linified[i] === "") {
            return i + 1;
        }
        i++;
    }
    return i;
}
exports.getFirstLineAfterHeader = getFirstLineAfterHeader;
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfStyleBlock(text) {
    return /^STYLE( .*)?$/g.test(text);
}
exports.isStartOfStyleBlock = isStartOfStyleBlock;
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfNoteBlock(text) {
    return /^NOTE( .*)?$/g.test(text);
}
exports.isStartOfNoteBlock = isStartOfNoteBlock;
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfRegionBlock(text) {
    return /^REGION( .*)?$/g.test(text);
}
exports.isStartOfRegionBlock = isStartOfRegionBlock;
/**
 * Returns true if the given line looks like the beginning of a cue block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfCueBlock(text) {
    return (!isStartOfNoteBlock(text) &&
        !isStartOfStyleBlock(text) &&
        !isStartOfRegionBlock(text)) &&
        text.length !== 0;
}
exports.isStartOfCueBlock = isStartOfCueBlock;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var log_1 = __webpack_require__(1);
var abstract_1 = __webpack_require__(56);
var parsers_1 = __webpack_require__(314);
/**
 * Source buffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextTrackSourceBuffer
 * @extends AbstractSourceBuffer
 */
var NativeTextTrackSourceBuffer = /** @class */ (function (_super) {
    __extends(NativeTextTrackSourceBuffer, _super);
    /**
     * @param {string} codec
     * @param {HTMLMediaElement} videoElement
     * @param {Boolean} hideNativeSubtitle
     */
    function NativeTextTrackSourceBuffer(codec, videoElement, hideNativeSubtitle) {
        var _this = this;
        log_1.default.debug("creating native text track source buffer");
        _this = _super.call(this, codec) || this;
        var _a = compat_1.addTextTrack(videoElement, hideNativeSubtitle), track = _a.track, trackElement = _a.trackElement;
        _this._videoElement = videoElement;
        _this._track = track;
        _this._trackElement = trackElement;
        return _this;
    }
    /**
     * Append text tracks.
     * @param {Object} data
     * @param {string} data.data
     * @param {string} data.language
     * @param {Number} data.timescale
     * @param {Number} data.start
     * @param {Number} data.timeOffset
     * @param {Number|undefined} data.end
     */
    NativeTextTrackSourceBuffer.prototype._append = function (data) {
        log_1.default.debug("appending new native text tracks", data);
        var timescale = data.timescale, // timescale for the start and end
        timescaledStart = data.start, // exact beginning to which the track applies
        timescaledEnd = data.end, // exact end to which the track applies
        dataString = data.data, // text track content. Should be a string
        type = data.type, // type of texttracks (e.g. "ttml" or "vtt")
        language = data.language, // language the texttrack is in
        timeOffset = data.timeOffset;
        if (timescaledEnd != null && timescaledEnd - timescaledStart <= 0) {
            // this is accepted for error resilience, just skip that case.
            log_1.default.warn("Invalid subtitles appended");
            return;
        }
        var startTime = timescaledStart / timescale;
        var endTime = timescaledEnd != null ?
            timescaledEnd / timescale : undefined;
        var cues = parsers_1.default(type, dataString, timeOffset, language);
        if (cues.length > 0) {
            var firstCue = cues[0];
            // NOTE(compat): cleanup all current cues if the newly added
            // ones are in the past. this is supposed to fix an issue on
            // IE/Edge.
            var currentCues = this._track.cues;
            if (currentCues.length > 0) {
                if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
                    this._remove(firstCue.startTime, +Infinity);
                }
            }
            for (var i = 0; i < cues.length; i++) {
                this._track.addCue(cues[i]);
            }
            this.buffered.insert(startTime, endTime != null ? endTime : cues[cues.length - 1].endTime);
        }
        else if (endTime != null) {
            this.buffered.insert(startTime, endTime);
        }
    };
    /**
     * @param {Number} from
     * @param {Number} to
     */
    NativeTextTrackSourceBuffer.prototype._remove = function (from, to) {
        log_1.default.debug("removing native text track data", from, to);
        var track = this._track;
        var cues = track.cues;
        for (var i = cues.length - 1; i >= 0; i--) {
            var cue = cues[i];
            var startTime = cue.startTime, endTime = cue.endTime;
            if (startTime >= from && startTime <= to && endTime <= to) {
                track.removeCue(cue);
            }
        }
        this.buffered.remove(from, to);
    };
    NativeTextTrackSourceBuffer.prototype._abort = function () {
        log_1.default.debug("aborting native text track source buffer");
        var _a = this, _trackElement = _a._trackElement, _videoElement = _a._videoElement;
        if (_trackElement && _videoElement &&
            _videoElement.hasChildNodes()) {
            try {
                _videoElement.removeChild(_trackElement);
            }
            catch (e) {
                log_1.default.warn("Can't remove track element from the video");
            }
        }
        if (this._track) {
            this._track.mode = "disabled";
        }
        if (this._trackElement) {
            this._trackElement.innerHTML = "";
        }
    };
    return NativeTextTrackSourceBuffer;
}(abstract_1.AbstractSourceBuffer));
exports.default = NativeTextTrackSourceBuffer;


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = __webpack_require__(1);
var nativeParsers = {};
/* tslint:disable no-var-requires */
if (true) {
    nativeParsers.vtt =
        __webpack_require__(315).default;
}
if (true) {
    nativeParsers.ttml =
        __webpack_require__(316).default;
}
if (true) {
    nativeParsers.sami =
        __webpack_require__(317).default;
}
if (true) {
    nativeParsers.srt =
        __webpack_require__(318).default;
}
/* tslint:enable no-var-requires */
/**
 * @param {string} type
 * @param {string} data
 * @param {Number} timeOffset
 * @param {string} [language]
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToCues(type, data, timeOffset, language) {
    log_1.default.debug("finding parser for native text tracks:", type);
    var parser = nativeParsers[type];
    if (!parser) {
        throw new Error("no parser found for the given text track");
    }
    log_1.default.debug("parser found, parsing...");
    var parsed = parser(data, timeOffset, language);
    log_1.default.debug("parsed successfully!", parsed);
    return parsed;
}
exports.default = parseTextTrackToCues;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var array_includes_1 = __webpack_require__(9);
var index_1 = __webpack_require__(5);
// Simple VTT to VTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.
/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseVTTStringToVTTCues(vttStr, timeOffset) {
    // WEBVTT authorize CRLF, LF or CR as line terminators
    var lines = vttStr.split(/\r\n|\n|\r/);
    if (!(/^WEBVTT($| |\t)/.test(lines[0]))) {
        throw new Error("Can't parse WebVTT: Invalid file.");
    }
    var cueBlocks = [];
    for (var i = 1; i < lines.length; i++) {
        if (isStartOfCueBlock(lines[i])) {
            var startingI = i;
            i++;
            // continue incrementing i until either:
            //   - empty line
            //   - end
            while (lines[i]) {
                i++;
            }
            cueBlocks.push(lines.slice(startingI, i));
        }
        else if (lines[i]) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            while (lines[i]) {
                i++;
            }
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseVTTStringToVTTCues;
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {string} line
 * @returns {Boolean}
 */
function isStartOfCueBlock(line) {
    // checked cases:
    //   - empty lines
    //   - start of a comment
    //   - start of a region
    //   - start of a style
    // Anything else should be a cue. TODO re-check with the spec
    if (!line || /^(NOTE)|(REGION)|(STYLE)($| |\t)/.test(line)) {
        return false;
    }
    return true;
}
/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {TextTrackCue|VTTCue}
 */
function parseCue(cueLines, timeOffset) {
    var timingRegexp = /-->/;
    var timeString;
    var payloadLines;
    if (!timingRegexp.test(cueLines[0])) {
        if (!timingRegexp.test(cueLines[1])) {
            // not a cue
            return null;
        }
        timeString = cueLines[1];
        payloadLines = cueLines.slice(2, cueLines.length);
    }
    else {
        timeString = cueLines[0];
        payloadLines = cueLines.slice(1, cueLines.length);
    }
    var timeAndSettings = parseTimeAndSettings(timeString);
    if (!timeAndSettings) {
        return null;
    }
    var start = timeAndSettings.start, end = timeAndSettings.end, settings = timeAndSettings.settings;
    var payload = payloadLines.join("\n");
    var cue = index_1.makeCue(start + timeOffset, end + timeOffset, payload);
    if (cue && cue instanceof VTTCue) {
        setSettingsOnCue(settings, cue);
    }
    return cue;
}
/**
 * Parse a single WEBVTT timestamp into seconds
 * @param {string} timestampString
 * @returns {Number}
 */
function parseTimestamp(timestampString) {
    var splittedTS = timestampString.split(":");
    if (splittedTS.length === 3) {
        var hours = parseInt(splittedTS[0], 10);
        var minutes = parseInt(splittedTS[1], 10);
        var seconds = parseFloat(splittedTS[2]);
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
    else if (splittedTS.length === 2) {
        var minutes = parseInt(splittedTS[0], 10);
        var seconds = parseFloat(splittedTS[1]);
        if (isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return minutes * 60 + seconds;
    }
}
/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
function parseSettings(settingsString) {
    var splittedSettings = settingsString.split(/ |\t/);
    return splittedSettings.reduce(function (acc, setting) {
        var splittedSetting = setting.split(":");
        if (splittedSetting.length === 2) {
            acc[splittedSetting[0]] = splittedSetting[1];
        }
        return acc;
    }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */
function parseTimeAndSettings(timeString) {
    /*
     * RegExp for the timestamps + settings line.
     *
     * Capture groups:
     *   1 -> start timestamp
     *   2 -> end timestamp
     *   3 - settings
     * @type {RegExp}
     */
    var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
    var matches = timeString.match(lineRegex);
    if (!matches) {
        return null;
    }
    var start = parseTimestamp(matches[1]);
    var end = parseTimestamp(matches[2]);
    if (start == null || end == null) {
        return null;
    }
    var settings = parseSettings(matches[3]);
    return {
        start: start,
        end: end,
        settings: settings,
    };
}
/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {VTTCue|TextTrackCue} cue
 */
function setSettingsOnCue(settings, cue) {
    if (settings.vertical &&
        (settings.vertical === "rl" || settings.vertical === "lr")) {
        cue.vertical = settings.vertical;
    }
    if (settings.line) {
        /**
         * Capture groups:
         *   1 -> percentage position
         *   2 -> optional decimals from percentage position
         *   3 -> optional follow-up of the string indicating alignment value
         *   4 -> alignment value
         * @type {RegExp}
         */
        var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
        var percentageMatches = settings.line.match(percentagePosition);
        if (percentageMatches) {
            cue.line = percentageMatches[1];
            cue.snapToLines = false;
            if (array_includes_1.default(["start", "center", "end"], percentageMatches[4])) {
                cue.lineAlign = percentageMatches[4];
            }
        }
        else {
            /**
             * Capture groups:
             *   1 -> line number
             *   2 -> optional follow-up of the string indicating alignment value
             *   3 -> alignment value
             * @type {RegExp}
             */
            var linePosition = /^(-?\d+)(,([a-z]+))?/;
            var lineMatches = settings.line.match(linePosition);
            if (lineMatches) {
                cue.line = lineMatches[1];
                cue.snapToLines = true;
                if (array_includes_1.default(["start", "center", "end"], lineMatches[3])) {
                    cue.lineAlign = lineMatches[3];
                }
            }
        }
    }
    if (settings.position) {
        var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
        var positionArr = positionRegex.exec(settings.position);
        if (positionArr && positionArr.length >= 2) {
            var position = parseInt(positionArr[1], 10);
            if (!isNaN(position)) {
                cue.position = position;
                if (positionArr[2] != null) {
                    cue.positionAlign = positionArr[2];
                }
            }
        }
    }
    if (settings.size) {
        cue.size = settings.size;
    }
    if (settings.align &&
        array_includes_1.default(["start", "center", "end", "left"], settings.align)) {
        cue.align = settings.align;
    }
}


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
var objectAssign = __webpack_require__(7);
var compat_1 = __webpack_require__(5);
var getParameters_1 = __webpack_require__(98);
var getParentElementsByTagName_1 = __webpack_require__(57);
var getTimeDelimiters_1 = __webpack_require__(100);
var nodes_1 = __webpack_require__(99);
var regexps_1 = __webpack_require__(59);
var style_1 = __webpack_require__(58);
/**
 * Style attributes currently used.
 */
var WANTED_STYLE_ATTRIBUTES = [
    "extent",
    "writingMode",
    "origin",
    "align",
];
/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_LIGN_ALIGN = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end",
};
/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_POSITION_ALIGN = {
    left: "line-left",
    center: "center",
    right: "line-right",
};
/**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseTTMLStringToVTT(str, timeOffset) {
    var ret = [];
    var xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml) {
        var tts = xml.getElementsByTagName("tt");
        var tt = tts[0];
        if (!tt) {
            throw new Error("invalid XML");
        }
        var body = nodes_1.getBodyNode(tt);
        var styleNodes = nodes_1.getStyleNodes(tt);
        var regionNodes = nodes_1.getRegionNodes(tt);
        var textNodes = nodes_1.getTextNodes(tt);
        var params = getParameters_1.default(tt);
        // construct styles array based on the xml as an optimization
        var styles = [];
        for (var i = 0; i <= styleNodes.length - 1; i++) {
            // TODO styles referencing other styles
            var styleNode = styleNodes[i];
            if (styleNode instanceof Element) {
                var styleID = styleNode.getAttribute("xml:id");
                if (styleID != null) {
                    styles.push({
                        id: styleID,
                        style: style_1.getStylingFromElement(styleNode),
                    });
                }
            }
        }
        // construct regions array based on the xml as an optimization
        var regions = [];
        var _loop_1 = function (i) {
            var regionNode = regionNodes[i];
            if (regionNode instanceof Element) {
                var regionID = regionNode.getAttribute("xml:id");
                if (regionID != null) {
                    var regionStyle = style_1.getStylingFromElement(regionNode);
                    var associatedStyle_1 = regionNode.getAttribute("style");
                    if (associatedStyle_1) {
                        var style = arrayFind(styles, function (x) { return x.id === associatedStyle_1; });
                        if (style) {
                            regionStyle = objectAssign({}, style.style, regionStyle);
                        }
                    }
                    regions.push({
                        id: regionID,
                        style: regionStyle,
                    });
                }
            }
        };
        for (var i = 0; i <= regionNodes.length - 1; i++) {
            _loop_1(i);
        }
        // Computing the style takes a lot of ressources.
        // To avoid too much re-computation, let's compute the body style right
        // now and do the rest progressively.
        var bodyStyle = body ?
            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [body], styles, regions) :
            style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [], styles, regions);
        for (var i = 0; i < textNodes.length; i++) {
            var paragraph = textNodes[i];
            if (paragraph instanceof Element) {
                var divs = getParentElementsByTagName_1.default(paragraph, "div");
                var paragraphStyle = objectAssign({}, bodyStyle, style_1.getStylingAttributes(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
                var cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params);
                if (cue) {
                    ret.push(cue);
                }
            }
        }
    }
    return ret;
}
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @returns {TextTrackCue|null}
 */
function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params) {
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent || "")) {
        return null;
    }
    var _a = getTimeDelimiters_1.default(paragraph, params), start = _a.start, end = _a.end;
    var text = generateTextContent(paragraph, params.spaceStyle === "default");
    var cue = compat_1.makeCue(start + offset, end + offset, text);
    if (!cue) {
        return null;
    }
    if (cue instanceof VTTCue) {
        addStyle(cue, paragraphStyle);
    }
    return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {string}
 */
function generateTextContent(paragraph, shouldTrimWhiteSpace) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding string.
     * @param {Node} node - the node in question
     * @returns {string}
     */
    function loop(node) {
        var childNodes = node.childNodes;
        var text = "";
        for (var i = 0; i < childNodes.length; i++) {
            var currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                var textContent = currentNode.textContent || "";
                // TODO Also parse it from parent elements
                // const spaceAttr = getAttribute("xml:space", [
                //   ...spans, p, ...divs, body,
                // ]);
                // const shouldTrimWhiteSpace = spaceAttr ?
                //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
                if (shouldTrimWhiteSpace) {
                    // 1. Trim leading and trailing whitespace.
                    // 2. Collapse multiple spaces into one.
                    var trimmed = textContent.trim();
                    trimmed = trimmed.replace(/\s+/g, " ");
                    textContent = trimmed;
                }
                text += textContent;
            }
            else if (currentNode.nodeName === "br") {
                text += "\n";
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.childNodes.length > 0) {
                text += loop(currentNode);
            }
        }
        return text;
    }
    return loop(paragraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */
function addStyle(cue, style) {
    var extent = style.extent;
    if (extent) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(extent);
        if (results != null) {
            // Use width value of the extent attribute for size.
            // Height value is ignored.
            cue.size = Number(results[1]);
        }
    }
    var writingMode = style.writingMode;
    var isVerticalText = true;
    switch (writingMode) {
        case "tb":
        case "tblr":
            cue.vertical = "lr";
            break;
        case "tbrl":
            cue.vertical = "rl";
            break;
        default:
            isVerticalText = false;
            break;
    }
    var origin = style.origin;
    if (origin) {
        var results = regexps_1.REGXP_PERCENT_VALUES.exec(origin);
        if (results != null) {
            // for vertical text use first coordinate of tts:origin
            // to represent line of the cue and second - for position.
            // Otherwise (horizontal), use them the other way around.
            if (isVerticalText) {
                // TODO check and uncomment
                // cue.position = Number(results[2]);
                // cue.line = Number(results[1]);
            }
            else {
                // TODO check and uncomment
                // cue.position = Number(results[1]);
                // cue.line = Number(results[2]);
            }
            // A boolean indicating whether the line is an integer
            // number of lines (using the line dimensions of the first
            // line of the cue), or whether it is a percentage of the
            // dimension of the video. The flag is set to true when lines
            // are counted, and false otherwise.
            // TODO check and uncomment
            // cue.snapToLines = false;
        }
    }
    var align = style.align;
    if (align) {
        cue.align = align;
        if (align === "center") {
            if (cue.align !== "center") {
                // Workaround for a Chrome bug http://crbug.com/663797
                // Chrome does not support align = "center"
                cue.align = "middle";
            }
            cue.position = "auto";
        }
        cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "";
        cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "";
    }
}
exports.default = parseTTMLStringToVTT;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var compat_1 = __webpack_require__(5);
var assert_1 = __webpack_require__(2);
var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
function createCuesFromArray(cuesArray) {
    var nativeCues = [];
    for (var i = 0; i < cuesArray.length; i++) {
        var _a = cuesArray[i], start = _a.start, end = _a.end, text = _a.text;
        if (text && end != null) {
            var cue = compat_1.makeCue(start, end, text);
            if (cue != null) {
                nativeCues.push(cue);
            }
        }
    }
    return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    var langs = {};
    var m;
    while ((m = ruleRe.exec(str))) {
        var name_1 = m[1];
        var lang = getCSSProperty(m[2], "lang");
        if (name_1 != null && lang != null) {
            langs[lang] = name_1;
        }
    }
    return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
    return matches ? matches[1] : null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(BR, "\n")
        .replace(HTML_ENTITIES, function (_, $1) { return String.fromCharCode($1); });
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSami(smi, timeOffset, lang) {
    var syncOpen = /<sync[ >]/ig;
    var syncClose = /<sync[ >]|<\/body>/ig;
    var subs = [];
    var styleMatches = smi.match(STYLE);
    var css = styleMatches ? styleMatches[1] : "";
    var up;
    var to = syncClose.exec(smi);
    var langs = getClassNameByLang(css);
    var klass = langs[lang];
    assert_1.default(klass, "sami: could not find lang " + lang + " in CSS");
    for (;;) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (!up && !to) {
            break;
        }
        if (!up || !to || up.index >= to.index) {
            throw new Error("parse error");
        }
        var str = smi.slice(up.index, to.index);
        var tim = str.match(START);
        if (!tim) {
            throw new Error("parse error (sync time attribute)");
        }
        var start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return createCuesFromArray(subs);
    function appendToSubs(lines, start) {
        var i = lines.length;
        var m;
        while (--i >= 0) {
            m = lines[i].match(PARAG);
            if (!m) {
                continue;
            }
            var kl = m[1], txt = m[2];
            if (klass !== kl) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                subs.push({
                    text: decodeEntities(txt),
                    start: start + timeOffset,
                });
            }
        }
    }
}
exports.default = parseSami;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation
var index_1 = __webpack_require__(5);
var parseTimestamp_1 = __webpack_require__(101);
/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSRTStringToVTTCues(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    var lines = srtStr.split(/\r\n|\n|\r/);
    var cueBlocks = [];
    for (var i = 0; i < lines.length; i++) {
        if (lines[i]) {
            var startingI = i;
            i++;
            while (lines[i]) {
                i++;
            }
            cueBlocks.push(lines.slice(startingI, i));
        }
    }
    var cues = [];
    for (var i = 0; i < cueBlocks.length; i++) {
        var cue = parseCue(cueBlocks[i], timeOffset);
        if (cue) {
            cues.push(cue);
        }
    }
    return cues;
}
exports.default = parseSRTStringToVTTCues;
/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {TextTrackCue|VTTCue|null}
 */
function parseCue(cueLines, timeOffset) {
    var _a = cueLines[1].split(" --> "), startString = _a[0], endString = _a[1];
    var payloadLines = cueLines.slice(2, cueLines.length);
    if (!startString || !endString || !payloadLines.length) {
        return null;
    }
    var start = parseTimestamp_1.default(startString);
    var end = parseTimestamp_1.default(endString);
    if (start == null || end == null) {
        return null;
    }
    var payload = payloadLines.join("\n");
    return index_1.makeCue(start + timeOffset, end + timeOffset, payload);
}


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var log_1 = __webpack_require__(1);
/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} videoElement
 * @param {BehaviorSubject} speed$ - emit speed set by the user
 * @param {Observable} clock$
 * @param {Object} options
 * @param {Boolean} [options.pauseWhenStalled=true] - true if the player
 * stalling should lead to a pause until it un-stalls.
 * @returns {Observable}
 */
var speedManager = function (videoElement, speed$, clock$, _a) {
    var _b = _a.pauseWhenStalled, pauseWhenStalled = _b === void 0 ? true : _b;
    var forcePause$;
    if (!pauseWhenStalled) {
        forcePause$ = Observable_1.Observable.of(false);
    }
    else {
        forcePause$ = clock$
            .pairwise()
            .map(function (_a) {
            var prevTiming = _a[0], timing = _a[1];
            var isStalled = timing.stalled;
            var wasStalled = prevTiming.stalled;
            if (!wasStalled !== !isStalled || // xor
                (wasStalled && isStalled && wasStalled.state !== isStalled.state)) {
                return !wasStalled;
            }
        })
            .filter(function (val) { return val != null; })
            .startWith(false);
    }
    return forcePause$
        .switchMap(function (shouldForcePause) {
        if (shouldForcePause) {
            return Observable_1.Observable.defer(function () {
                log_1.default.info("pause playback to build buffer");
                videoElement.playbackRate = 0;
                return Observable_1.Observable.of(0);
            });
        }
        return speed$
            .do(function (speed) {
            log_1.default.info("resume playback speed", speed);
            videoElement.playbackRate = speed;
        });
    });
};
exports.default = speedManager;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(4);
var log_1 = __webpack_require__(1);
var ranges_1 = __webpack_require__(15);
var compat_1 = __webpack_require__(5);
var DISCONTINUITY_THRESHOLD = config_1.default.DISCONTINUITY_THRESHOLD;
/**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} videoElement
 * @param {Manifest} manifest
 * @param {Observable} timings$
 * @returns {Observable}
 */
function StallingManager(videoElement, _manifest, timings$) {
    return timings$
        .do(function (timing) {
        if (!timing.stalled) {
            return;
        }
        // Perform various checks to try to get out of the stalled state:
        //   1. is it a browser bug? -> force seek at the same current time
        //   2. is it a short discontinuity? -> Seek at the beginning of the
        //                                      next range
        //   3. are we before the buffer depth? -> Seek a little after it
        var buffered = timing.buffered, currentTime = timing.currentTime;
        var nextRangeGap = ranges_1.getNextRangeGap(buffered, currentTime);
        // Discontinuity check in case we are close a buffer but still
        // calculate a stalled state. This is useful for some
        // implementation that might drop an injected segment, or in
        // case of small discontinuity in the stream.
        if (compat_1.isPlaybackStuck(timing.currentTime, timing.currentRange, timing.state, !!timing.stalled)) {
            log_1.default.warn("after freeze seek", currentTime, timing.currentRange);
            videoElement.currentTime = currentTime;
        }
        else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
            var seekTo = (currentTime + nextRangeGap + 1 / 60);
            log_1.default.warn("discontinuity seek", currentTime, nextRangeGap, seekTo);
            videoElement.currentTime = seekTo;
        }
    })
        .share()
        .map(function (timing) { return timing.stalled; })
        .distinctUntilChanged(function (wasStalled, isStalled) {
        return !wasStalled && !isStalled ||
            (!!wasStalled && !!isStalled && wasStalled.state === isStalled.state);
    });
}
exports.default = StallingManager;


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var timings_1 = __webpack_require__(55);
/**
 * TODO I'm not sure that's useful here.
 * seek gap in seconds.
 */
var SEEK_GAP = 2;
/**
 * Observable emitting each time the player is in a true seeking state.
 * That is, the player is seeking and no buffer has been constructed for this
 * range yet.
 * @param {Observable} timingsSampling - the timings observable emitting every
 * seeking events.
 * @returns {Observable}
 */
function seekingsSampler(timingsSampling) {
    return timingsSampling
        .filter(function (timing) {
        return timing.state === "seeking" &&
            (timing.bufferGap === Infinity ||
                // TODO I don't think that's possible here:
                // the gap is based on the current position and the difference
                // between it and the end of the range this position is in.
                // I don't see how it could be negative.
                // It is Infinity when no range is found for the current position
                timing.bufferGap < -SEEK_GAP);
    })
        .skip(1)
        .map(function () { return null; })
        .startWith(null); // TODO Why starting with somthing?
}
/**
 * Create timings and seekings Observables:
 *   - timings is the given timings observable with added informations.
 *   - seekings emits each time the player go in a seeking state.
 * @param {Object} manifest
 * @returns {Object}
 */
function createTimingsAndSeekingsObservables(manifest, timings) {
    var augmentedTimings = timings.map(function (timing) {
        return objectAssign({
            liveGap: manifest.isLive ?
                timings_1.getMaximumBufferPosition(manifest) - timing.currentTime :
                Infinity,
        }, timing);
    });
    var seekings = seekingsSampler(augmentedTimings);
    return {
        timings: augmentedTimings,
        seekings: seekings,
    };
}
exports.default = createTimingsAndSeekingsObservables;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This file declares constants useful for every API files
 */
/**
 * Player state dictionnary
 * @type {Object}
 */
exports.PLAYER_STATES = {
    STOPPED: "STOPPED",
    LOADED: "LOADED",
    LOADING: "LOADING",
    PLAYING: "PLAYING",
    PAUSED: "PAUSED",
    ENDED: "ENDED",
    BUFFERING: "BUFFERING",
    SEEKING: "SEEKING",
};


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var arrayFind = __webpack_require__(17);
/**
 * Try to find the given track config in the adaptations given:
 *
 * If no track config return null.
 * If no adaptation are found return undefined.
 *
 * @param {Array.<Object>} adaptations
 * @param {Object} trackConfig
 * @param {string} trackConfig.language
 * @param {string} trackConfig.normalized
 * @param {Boolean} trackConfig.closedCaption
 * @return {null|undefined|Object}
 */
var findTextAdaptation = function (adaptations, trackConfig) {
    if (!trackConfig) {
        return null;
    }
    if (!adaptations.length) {
        return void 0;
    }
    var foundTextTrack = arrayFind(adaptations, function (textAdaptation) {
        return trackConfig.normalized === textAdaptation.normalizedLanguage &&
            trackConfig.closedCaption === textAdaptation.isClosedCaption;
    });
    return foundTextTrack;
};
/**
 * Try to find the given track config in the adaptations given:
 *
 * If no track config return null.
 * If no adaptation are found return undefined.
 *
 * @param {Array.<Object>} adaptations
 * @param {Object} trackConfig
 * @param {string} trackConfig.language
 * @param {string} trackConfig.normalized
 * @param {string} trackConfig.audioDescription
 * @return {null|undefined|Object}
 */
var findAudioAdaptation = function (adaptations, trackConfig) {
    if (!adaptations.length || !trackConfig) {
        return undefined;
    }
    var foundAudioTrack = arrayFind(adaptations, function (audioAdaptation) {
        return trackConfig.normalized === audioAdaptation.normalizedLanguage &&
            trackConfig.audioDescription === audioAdaptation.isAudioDescription;
    });
    return foundAudioTrack;
};
/**
 * # LanguageManager
 *
 * ## Overview
 *
 * Takes in the text and audio adaptations parsed from a manifest and provide
 * various methods and properties to set/get the right adaption based on a
 * language configuration.
 */
var LanguageManager = /** @class */ (function () {
    /**
     * @constructor
     *
     * @param {Object} adaptations
     * @param {Array.<Adaptation>} adaptations.audio - The different audio
     * adaptations available right now.
     * Can be updated through the updateAdaptations method.
     * @param {Array.<Adaptation>} adaptations.text - The different text
     * adaptations available right now.
     * Can be updated through the updateAdaptations method.
     *
     * @param {Object} adaptations$
     * @param {Subject} adaptations$.audio$ - Subject through which the chosen
     * audio adaptation will be emitted.
     * @param {Subject} adaptations$.text$ - Subject through which the chosen
     * text adaptation will be emitted
     */
    function LanguageManager(_a, _b) {
        var text = _a.text, audio = _a.audio;
        var text$ = _b.text$, audio$ = _b.audio$;
        /**
         * The currently chosen audio adaptation.
         * undefined if none chosen yet
         * null if the audio track is disabled
         * @type {Adaptation|undefined|null}
         */
        this._currentAudioAdaptation = undefined;
        /**
         * The currently chosen text adaptation.
         * undefined if none chosen yet
         * null if the text track is disabled
         * @type {Adaptation|undefined|null}
         */
        this._currentTextAdaptation = undefined;
        /**
         * Every audio adaptations available.
         * @type {Array.<Adaptation>}
         */
        this._audioAdaptations = audio || [];
        /**
         * Every text adaptations available.
         * @type {Array.<Adaptation>}
         */
        this._textAdaptations = text || [];
        this._text$ = text$;
        this._audio$ = audio$;
    }
    /**
     * Update the adaptations in the current content.
     * Try to find the same adaptations than the ones previously chosen.
     * @param {Object} adaptationsObject
     * @param {Array.<Object>} audioAdaptationsObject.audio - The audio
     * adaptations available.
     * @param {Array.<Object>} audioAdaptationsObject.text - The text
     * adaptations available.
     */
    LanguageManager.prototype.updateAdaptations = function (_a) {
        var text = _a.text, audio = _a.audio;
        this._audioAdaptations = audio || [];
        this._textAdaptations = text || [];
        var currentAudioAdaptation = this._currentAudioAdaptation;
        // if not set, it either means it is deactivated (null) or that is not set
        // (undefined). In both cases, we don't want to update the adaptation here.
        if (currentAudioAdaptation) {
            // try to find the same adaptation than the current one
            var currentAudioId_1 = currentAudioAdaptation.id;
            var audioAdaptationFound = arrayFind(this._audioAdaptations, function (_a) {
                var id = _a.id;
                return id === currentAudioId_1;
            });
            if (!audioAdaptationFound) {
                var foundTrack = findAudioAdaptation(this._audioAdaptations, {
                    // TODO AudioAdaptation type
                    language: currentAudioAdaptation.language || "",
                    normalized: currentAudioAdaptation.normalizedLanguage || "",
                    audioDescription: !!currentAudioAdaptation.isAudioDescription,
                });
                var chosenTrack = foundTrack || this._audioAdaptations[0] || null;
                if (this._currentAudioAdaptation !== chosenTrack) {
                    this._currentAudioAdaptation = chosenTrack;
                    this._audio$.next(this._currentAudioAdaptation);
                }
            }
        }
        var currentTextAdaptation = this._currentTextAdaptation;
        // if not set, it either means it is deactivated (null) or that is not set
        // (undefined). In both cases, we don't want to update the adaptation here.
        if (currentTextAdaptation) {
            // try to find the same adaptation than the current one
            var currentTextId_1 = currentTextAdaptation.id;
            var textAdaptationFound = arrayFind(this._textAdaptations, function (_a) {
                var id = _a.id;
                return id === currentTextId_1;
            });
            if (!textAdaptationFound) {
                var foundTrack = 
                // TODO TextAdaptation type
                findTextAdaptation(this._textAdaptations, {
                    language: currentTextAdaptation.language || "",
                    normalized: currentTextAdaptation.normalizedLanguage || "",
                    closedCaption: !!currentTextAdaptation.isClosedCaption,
                });
                var chosenTrack = foundTrack || this._textAdaptations[0];
                if (this._currentTextAdaptation !== chosenTrack) {
                    this._currentTextAdaptation = chosenTrack;
                    this._text$.next(this._currentTextAdaptation);
                }
            }
        }
    };
    /**
     * Set the audio track based on an optional given configuration.
     *
     * If no configuration is provided, set the first adaptation found.
     * If the given configuration is ``null``, disable the audio track.
     *
     * Else, If it fails to find one matching the wanted criteria, set the first
     * adaptation found instead.
     * If there is no available audio adaptation at all, disable the audio track.
     * @param {Object|null} [wantedTrack]
     * @param {string} wantedTrack.language
     * @param {string} wantedTrack.normalized
     * @param {Boolean} wantedTrack.audioDescription
     */
    LanguageManager.prototype.setInitialAudioTrack = function (wantedTrack) {
        var chosenAdaptation;
        if (wantedTrack) {
            chosenAdaptation =
                findAudioAdaptation(this._audioAdaptations, wantedTrack);
        }
        else if (wantedTrack === null) {
            chosenAdaptation = null;
        }
        if (chosenAdaptation === undefined) {
            chosenAdaptation = this._audioAdaptations[0] || null;
        }
        if (chosenAdaptation !== this._currentAudioAdaptation) {
            this._currentAudioAdaptation = chosenAdaptation;
            this._audio$.next(this._currentAudioAdaptation);
        }
    };
    /**
     * Set the text track based on an optional given configuration.
     * If the given configuration is not defined or null, disable the text track.
     * Else, If it fails to find one matching the wanted criteria, disable the
     * text track.
     * @param {Object|null|undefined} wantedTrack
     * @param {string} wantedTrack.language
     * @param {string} wantedTrack.normalized
     * @param {Boolean} wantedTrack.closedCaption
     */
    LanguageManager.prototype.setInitialTextTrack = function (wantedTrack) {
        var chosenAdaptation = wantedTrack ?
            findTextAdaptation(this._textAdaptations, wantedTrack) || null :
            null;
        if (chosenAdaptation !== this._currentTextAdaptation) {
            this._currentTextAdaptation = chosenAdaptation;
            this._text$.next(this._currentTextAdaptation);
        }
    };
    /**
     * Set audio track based on the ID of its adaptation.
     * @param {string|Number} wantedId - adaptation id of the wanted track
     * @throws Error - Throws if the given id is not found in any audio adaptation
     */
    LanguageManager.prototype.setAudioTrackByID = function (wantedId) {
        var foundTrack = arrayFind(this._audioAdaptations, function (_a) {
            var id = _a.id;
            return id === wantedId;
        });
        if (foundTrack === undefined) {
            throw new Error("Audio Track not found.");
        }
        if (this._currentAudioAdaptation !== foundTrack) {
            this._currentAudioAdaptation = foundTrack;
            this._audio$.next(this._currentAudioAdaptation);
        }
    };
    /**
     * Set text track based on the ID of its adaptation.
     * @param {string|Number} wantedId - adaptation id of the wanted track
     * @throws Error - Throws if the given id is not found in any text adaptation
     */
    LanguageManager.prototype.setTextTrackByID = function (wantedId) {
        var foundTrack = arrayFind(this._textAdaptations, function (_a) {
            var id = _a.id;
            return id === wantedId;
        });
        if (foundTrack === undefined) {
            throw new Error("Text Track not found.");
        }
        if (this._currentTextAdaptation !== foundTrack) {
            this._currentTextAdaptation = foundTrack;
            this._text$.next(this._currentTextAdaptation);
        }
    };
    /**
     * Disable the current audio track.
     */
    LanguageManager.prototype.disableAudioTrack = function () {
        if (this._currentAudioAdaptation === null) {
            return;
        }
        this._currentAudioAdaptation = null;
        this._audio$.next(this._currentAudioAdaptation);
    };
    /**
     * Disable the current text track.
     */
    LanguageManager.prototype.disableTextTrack = function () {
        if (this._currentTextAdaptation === null) {
            return;
        }
        this._currentTextAdaptation = null;
        this._text$.next(this._currentTextAdaptation);
    };
    /**
     * Returns an object describing the current audio track.
     * This object has the following keys:
     *   - language {string}
     *   - normalized {string}
     *   - audioDescription {Boolean}
     *   - id {number|string}
     *
     * Returns null is the the current audio track is disabled or not
     * set yet.
     * @returns {Object|null}
     */
    LanguageManager.prototype.getCurrentAudioTrack = function () {
        var adaptation = this._currentAudioAdaptation;
        if (!adaptation) {
            return null;
        }
        return {
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            audioDescription: !!adaptation.isAudioDescription,
            id: adaptation.id,
        };
    };
    /**
     * Returns an object describing the current text track.
     * This object has the following keys:
     *   - language {string}
     *   - normalized {string}
     *   - closedCaption {Boolean}
     *   - id {number|string}
     *
     * Returns null is the the current text track is disabled or not
     * set yet.
     * @returns {Object|null}
     */
    LanguageManager.prototype.getCurrentTextTrack = function () {
        var adaptation = this._currentTextAdaptation;
        if (!adaptation) {
            return null;
        }
        return {
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            closedCaption: !!adaptation.isClosedCaption,
            id: adaptation.id,
        };
    };
    /**
     * Returns all available audio tracks, as an array of objects.
     * Those objects have the following keys:
     *   - language {string}
     *   - normalized {string}
     *   - audioDescription {Boolean}
     *   - id {number|string}
     *   - active {Boolean}
     * @returns {Array.<Object>}
     */
    LanguageManager.prototype.getAvailableAudioTracks = function () {
        var currentTrack = this._currentAudioAdaptation;
        var currentId = currentTrack && currentTrack.id;
        return this._audioAdaptations
            .map(function (adaptation) { return ({
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            audioDescription: !!adaptation.isAudioDescription,
            id: adaptation.id,
            active: currentId == null ? false : currentId === adaptation.id,
        }); });
    };
    /**
     * Returns all available text tracks, as an array of objects.
     * Those objects have the following keys:
     *   - language {string}
     *   - normalized {string}
     *   - closedCaption {Boolean}
     *   - id {number|string}
     *   - active {Boolean}
     * @returns {Array.<Object>}
     */
    LanguageManager.prototype.getAvailableTextTracks = function () {
        var currentTrack = this._currentTextAdaptation;
        var currentId = currentTrack && currentTrack.id;
        return this._textAdaptations
            .map(function (adaptation) { return ({
            language: adaptation.language || "",
            normalized: adaptation.normalizedLanguage || "",
            closedCaption: !!adaptation.isClosedCaption,
            id: adaptation.id,
            active: currentId == null ? false : currentId === adaptation.id,
        }); });
    };
    return LanguageManager;
}());
exports.default = LanguageManager;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = __webpack_require__(0);
var ReplaySubject_1 = __webpack_require__(46);
var objectAssign = __webpack_require__(7);
var config_1 = __webpack_require__(4);
var ranges_1 = __webpack_require__(15);
var SAMPLING_INTERVAL_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_NO_MEDIASOURCE = config_1.default.SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_AFTER_SEEKING_GAP = config_1.default.RESUME_AFTER_SEEKING_GAP, RESUME_AFTER_BUFFERING_GAP = config_1.default.RESUME_AFTER_BUFFERING_GAP, STALL_GAP = config_1.default.STALL_GAP;
/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */
var SCANNED_VIDEO_EVENTS = [
    "canplay",
    "play",
    "progress",
    "seeking",
    "seeked",
    "loadedmetadata",
];
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @returns {Boolean}
 */
function getResumeGap(stalled) {
    if (!stalled) {
        return 0;
    }
    return stalled.state === "seeking"
        ? RESUME_AFTER_SEEKING_GAP
        : RESUME_AFTER_BUFFERING_GAP;
}
/**
 * TODO I just don't get it for this one.
 * gap + range.end ??? HELP
 * @param {Number} gap
 * @param {Object} range
 * @param {Number} duration
 * @returns {Boolean}
 */
function isEnding(bufferGap, currentRange, duration) {
    return currentRange != null &&
        (duration - (bufferGap + currentRange.end)) <= STALL_GAP;
}
/**
 * Generate a basic timings object from the video element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} video
 * @param {string} name
 * @returns {Object}
 */
function getTimings(video, name) {
    var currentTime = video.currentTime, paused = video.paused, playbackRate = video.playbackRate, readyState = video.readyState, buffered = video.buffered, duration = video.duration;
    return {
        currentTime: currentTime,
        buffered: buffered,
        duration: duration,
        bufferGap: ranges_1.getLeftSizeOfRange(buffered, currentTime),
        state: name,
        playbackRate: playbackRate,
        currentRange: ranges_1.getRange(buffered, currentTime),
        readyState: readyState,
        paused: paused,
    };
}
/**
 * Infer stalled status of the video based on:
 *   - the return of the function getTimings
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */
function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
    var currentState = currentTimings.state, currentTime = currentTimings.currentTime, bufferGap = currentTimings.bufferGap, currentRange = currentTimings.currentRange, duration = currentTimings.duration, paused = currentTimings.paused, readyState = currentTimings.readyState;
    var prevStalled = prevTimings.stalled, prevState = prevTimings.state, prevTime = prevTimings.currentTime;
    var ending = isEnding(bufferGap, currentRange, duration);
    var canStall = (readyState >= 1 &&
        currentState !== "loadedmetadata" &&
        !prevStalled &&
        !ending);
    var shouldStall;
    var shouldUnstall;
    if (withMediaSource) {
        if (canStall &&
            (bufferGap <= STALL_GAP || bufferGap === Infinity || readyState === 1)) {
            shouldStall = true;
        }
        else if (prevStalled &&
            readyState > 1 &&
            bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending)) {
            shouldUnstall = true;
        }
    }
    else {
        if (canStall &&
            (!paused && currentState === "timeupdate" &&
                prevState === "timeupdate" && currentTime === prevTime ||
                currentState === "seeking" && bufferGap === Infinity)) {
            shouldStall = true;
        }
        else if (prevStalled &&
            (currentState !== "seeking" && currentTime !== prevTime ||
                currentState === "canplay" ||
                bufferGap < Infinity &&
                    (bufferGap > getResumeGap(prevStalled) || ending))) {
            shouldUnstall = true;
        }
    }
    if (shouldStall) {
        return { state: currentState, timestamp: Date.now() };
    }
    else if (shouldUnstall) {
        return null;
    }
    else {
        return prevStalled;
    }
}
/**
 * Timings observable.
 *
 * This streams samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * video duration
 *
 * In addition to sampling, this stream also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to <video>
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} video
 * @param {Object} options
 * @returns {Observable}
 */
function createTimingsSampler(video, _a) {
    var withMediaSource = _a.withMediaSource;
    return Observable_1.Observable.create(function (obs) {
        var lastTimings = objectAssign(getTimings(video, "init"), { stalled: null });
        /**
         * Emit timings sample.
         * Meant to be used as a callback on various async events.
         * @param {Event} [evt] - The Event which triggered the callback, if one.
         */
        function emitSample(evt) {
            var timingEventType = evt && evt.type || "timeupdate";
            var videoTimings = getTimings(video, timingEventType);
            var stalledState = getStalledStatus(lastTimings, videoTimings, withMediaSource);
            // /!\ Mutate videoTimings
            lastTimings = objectAssign(videoTimings, { stalled: stalledState });
            obs.next(lastTimings);
        }
        var interval = withMediaSource
            ? SAMPLING_INTERVAL_MEDIASOURCE
            : SAMPLING_INTERVAL_NO_MEDIASOURCE;
        var intervalID = setInterval(emitSample, interval);
        SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
            return video.addEventListener(eventName, emitSample);
        });
        obs.next(lastTimings);
        return function () {
            clearInterval(intervalID);
            SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
                return video.removeEventListener(eventName, emitSample);
            });
        };
    })
        .multicast(function () { return new ReplaySubject_1.ReplaySubject(1); })
        .refCount();
}
exports.default = createTimingsSampler;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var objectAssign = __webpack_require__(7);
var config_1 = __webpack_require__(4);
var languages_1 = __webpack_require__(34);
var log_1 = __webpack_require__(1);
var DEFAULT_AUTO_PLAY = config_1.default.DEFAULT_AUTO_PLAY, DEFAULT_INITIAL_BITRATES = config_1.default.DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH = config_1.default.DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MAX_BITRATES = config_1.default.DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD = config_1.default.DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND = config_1.default.DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE = config_1.default.DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_TEXT_TRACK_MODE = config_1.default.DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN = config_1.default.DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD = config_1.default.DEFAULT_WANTED_BUFFER_AHEAD;
/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object} [options={}]
 * @returns {Object}
 */
function parseConstructorOptions(options) {
    var maxBufferAhead;
    var maxBufferBehind;
    var wantedBufferAhead;
    var limitVideoWidth;
    var throttleWhenHidden;
    var videoElement;
    var initialVideoBitrate;
    var initialAudioBitrate;
    var maxAudioBitrate;
    var maxVideoBitrate;
    if (options.maxBufferAhead == null) {
        maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
    }
    else {
        maxBufferAhead = Number(options.maxBufferAhead);
        if (isNaN(maxBufferAhead)) {
            throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
        }
    }
    if (options.maxBufferBehind == null) {
        maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
    }
    else {
        maxBufferBehind = Number(options.maxBufferBehind);
        if (isNaN(maxBufferBehind)) {
            throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
        }
    }
    if (options.wantedBufferAhead == null) {
        wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
    }
    else {
        wantedBufferAhead = Number(options.wantedBufferAhead);
        if (isNaN(wantedBufferAhead)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    limitVideoWidth = options.limitVideoWidth == null ?
        DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;
    throttleWhenHidden = options.throttleWhenHidden == null ?
        DEFAULT_THROTTLE_WHEN_HIDDEN : !!options.throttleWhenHidden;
    if (options.videoElement == null) {
        videoElement = document.createElement("video");
    }
    else if (options.videoElement instanceof HTMLMediaElement) {
        videoElement = options.videoElement;
    }
    else {
        /* tslint:disable:max-line-length */
        throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
        /* tslint:enable:max-line-length */
    }
    if (options.initialVideoBitrate == null) {
        initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
    }
    else {
        initialVideoBitrate = Number(options.initialVideoBitrate);
        if (isNaN(initialVideoBitrate)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    if (options.initialAudioBitrate == null) {
        initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
    }
    else {
        initialAudioBitrate = Number(options.initialAudioBitrate);
        if (isNaN(initialAudioBitrate)) {
            /* tslint:disable:max-line-length */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* tslint:enable:max-line-length */
        }
    }
    if (options.maxVideoBitrate == null) {
        maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
    }
    else {
        maxVideoBitrate = Number(options.maxVideoBitrate);
        if (isNaN(maxVideoBitrate)) {
            throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
        }
    }
    if (options.maxAudioBitrate == null) {
        maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
    }
    else {
        maxAudioBitrate = Number(options.maxAudioBitrate);
        if (isNaN(maxAudioBitrate)) {
            throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
        }
    }
    return {
        maxBufferAhead: maxBufferAhead,
        maxBufferBehind: maxBufferBehind,
        limitVideoWidth: limitVideoWidth,
        videoElement: videoElement,
        wantedBufferAhead: wantedBufferAhead,
        throttleWhenHidden: throttleWhenHidden,
        initialAudioBitrate: initialAudioBitrate,
        initialVideoBitrate: initialVideoBitrate,
        maxAudioBitrate: maxAudioBitrate,
        maxVideoBitrate: maxVideoBitrate,
    };
}
exports.parseConstructorOptions = parseConstructorOptions;
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object} [options={}]
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */
function parseLoadVideoOptions(options) {
    var url;
    var transport;
    var autoPlay;
    var keySystems;
    var transportOptions;
    var supplementaryTextTracks;
    var supplementaryImageTracks;
    var textTrackMode;
    var textTrackElement;
    var defaultAudioTrack;
    var defaultTextTrack;
    var hideNativeSubtitle;
    var startAt;
    if (!options || options.url == null) {
        throw new Error("No url set on loadVideo");
    }
    else {
        url = String(options.url);
    }
    if (options.transport == null) {
        throw new Error("No transport set on loadVideo");
    }
    else {
        transport = String(options.transport);
    }
    autoPlay = options.autoPlay == null ?
        DEFAULT_AUTO_PLAY : !!options.autoPlay;
    if (options.keySystems == null) {
        keySystems = [];
    }
    else {
        keySystems = Array.isArray(options.keySystems) ?
            options.keySystems : [options.keySystems];
        for (var _i = 0, keySystems_1 = keySystems; _i < keySystems_1.length; _i++) {
            var keySystem = keySystems_1[_i];
            if (typeof keySystem.type !== "string" ||
                typeof keySystem.getLicense !== "function") {
                throw new Error("Invalid key system given: Missing type string or " +
                    "getLicense callback");
            }
        }
    }
    transportOptions = options.transportOptions;
    if (options.supplementaryTextTracks == null) {
        supplementaryTextTracks = [];
    }
    else {
        supplementaryTextTracks =
            Array.isArray(options.supplementaryTextTracks) ?
                options.supplementaryTextTracks : [options.supplementaryTextTracks];
        for (var _a = 0, supplementaryTextTracks_1 = supplementaryTextTracks; _a < supplementaryTextTracks_1.length; _a++) {
            var supplementaryTextTrack = supplementaryTextTracks_1[_a];
            if (typeof supplementaryTextTrack.closedCaption !== "boolean") {
                supplementaryTextTrack.closedCaption = !!supplementaryTextTrack.closedCaption;
            }
            if (typeof supplementaryTextTrack.language !== "string" ||
                typeof supplementaryTextTrack.mimeType !== "string" ||
                typeof supplementaryTextTrack.url !== "string") {
                /* tslint:disable:max-line-length */
                throw new Error("Invalid supplementary text track given. Missing either language, mimetype or url");
                /* tslint:enable:max-line-length */
            }
        }
    }
    if (options.supplementaryImageTracks == null) {
        supplementaryImageTracks = [];
    }
    else {
        supplementaryImageTracks =
            Array.isArray(options.supplementaryImageTracks) ?
                options.supplementaryImageTracks : [options.supplementaryImageTracks];
        for (var _b = 0, supplementaryImageTracks_1 = supplementaryImageTracks; _b < supplementaryImageTracks_1.length; _b++) {
            var supplementaryImageTrack = supplementaryImageTracks_1[_b];
            if (typeof supplementaryImageTrack.mimeType !== "string" ||
                typeof supplementaryImageTrack.url !== "string") {
                /* tslint:disable:max-line-length */
                throw new Error("Invalid supplementary image track given. Missing either mimetype or url");
                /* tslint:enable:max-line-length */
            }
        }
    }
    if (options.textTrackMode == null) {
        textTrackMode = DEFAULT_TEXT_TRACK_MODE;
    }
    else {
        if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
            throw new Error("Invalid textTrackMode.");
        }
        textTrackMode = options.textTrackMode;
    }
    defaultAudioTrack = languages_1.normalizeAudioTrack(options.defaultAudioTrack);
    defaultTextTrack = languages_1.normalizeTextTrack(options.defaultTextTrack);
    hideNativeSubtitle = options.hideNativeSubtitle == null ?
        !DEFAULT_SHOW_NATIVE_SUBTITLE : !!options.hideNativeSubtitle;
    if (textTrackMode === "html") {
        // TODO Better way to express that in TypeScript?
        if (options.textTrackElement == null) {
            /* tslint:disable:max-line-length */
            throw new Error("You have to provide a textTrackElement in \"html\" textTrackMode.");
            /* tslint:enable:max-line-length */
        }
        else if (!(options.textTrackElement instanceof HTMLElement)) {
            throw new Error("textTrackElement should be an HTMLElement.");
        }
        else {
            textTrackElement = options.textTrackElement;
        }
    }
    else if (options.textTrackElement != null) {
        /* tslint:disable:max-line-length */
        log_1.default.warn("You have set a textTrackElement without being in an \"html\" textTrackMode. It will be ignored.");
        /* tslint:enable:max-line-length */
    }
    if (options.startAt != null) {
        // TODO Better way to express that in TypeScript?
        if (options.startAt.wallClockTime
            instanceof Date) {
            var wallClockTime = options.startAt
                .wallClockTime.getTime() / 1000;
            startAt = objectAssign({}, options.startAt, { wallClockTime: wallClockTime });
        }
        else {
            startAt = options.startAt;
        }
    }
    // TODO without cast
    /* tslint:disable no-object-literal-type-assertion */
    return {
        url: url,
        transport: transport,
        autoPlay: autoPlay,
        keySystems: keySystems,
        transportOptions: transportOptions,
        supplementaryTextTracks: supplementaryTextTracks,
        supplementaryImageTracks: supplementaryImageTracks,
        textTrackMode: textTrackMode,
        textTrackElement: textTrackElement,
        defaultAudioTrack: defaultAudioTrack,
        defaultTextTrack: defaultTextTrack,
        hideNativeSubtitle: hideNativeSubtitle,
        startAt: startAt,
    };
    /* tslint:enable no-object-literal-type-assertion */
}
exports.parseLoadVideoOptions = parseLoadVideoOptions;


/***/ })
/******/ ]);
});