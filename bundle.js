/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 401);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.moment = factory();
})(this, function () {
    'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function some(fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    var some$1 = some;

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

            if (m._strict) {
                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (_typeof(arguments[i]) === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function keys(obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var keys$1 = keys;

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({ unit: u, priority: priorities[u] });
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if ((typeof units === 'undefined' ? 'undefined' : _typeof(units)) === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function func() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1 = /\d/; //       0 - 9
    var match2 = /\d\d/; //      00 - 99
    var match3 = /\d{3}/; //     000 - 999
    var match4 = /\d{4}/; //    0000 - 9999
    var match6 = /[+-]?\d{6}/; // -999999 - 999999
    var match1to2 = /\d\d?/; //       0 - 99
    var match3to4 = /\d\d\d\d?/; //     999 - 9999
    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3 = /\d{1,3}/; //       0 - 999
    var match1to4 = /\d{1,4}/; //       0 - 9999
    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf
    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function func(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function indexOf(o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    var indexOf$1 = indexOf;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf$1.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf$1.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf$1.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf$1.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,

        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays : this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf$1.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf$1.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf$1.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf$1.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf$1.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // months
    // week
    // weekdays
    // meridiem
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                __webpack_require__(842)("./" + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    if (!localeFamilies[config.parentLocale]) {
                        localeFamilies[config.parentLocale] = [];
                    }
                    localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config
                    });
                    return null;
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys$1(locales);
    }

    function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

    // iso time formats and regexes
    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var string, match, dayFormat, dateFormat, timeFormat, tzFormat;
        var timezones = {
            ' GMT': ' +0000',
            ' EDT': ' -0400',
            ' EST': ' -0500',
            ' CDT': ' -0500',
            ' CST': ' -0600',
            ' MDT': ' -0600',
            ' MST': ' -0700',
            ' PDT': ' -0700',
            ' PST': ' -0800'
        };
        var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
        var timezone, timezoneIndex;

        string = config._i.replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
        match = basicRfcRegex.exec(string);

        if (match) {
            dayFormat = match[1] ? 'ddd' + (match[1].length === 5 ? ', ' : ' ') : '';
            dateFormat = 'D MMM ' + (match[2].length > 10 ? 'YYYY ' : 'YY ');
            timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            if (match[1]) {
                // day of week given
                var momentDate = new Date(match[2]);
                var momentDay = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][momentDate.getDay()];

                if (match[1].substr(0, 3) !== momentDay) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return;
                }
            }

            switch (match[5].length) {
                case 2:
                    // military
                    if (timezoneIndex === 0) {
                        timezone = ' +0000';
                    } else {
                        timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                        timezone = (timezoneIndex < 0 ? ' -' : ' +') + ('' + timezoneIndex).replace(/^-?/, '0').match(/..$/)[0] + '00';
                    }
                    break;
                case 4:
                    // Zone
                    timezone = timezones[match[5]];
                    break;
                default:
                    // UT or +/-9999
                    timezone = timezones[' GMT'];
            }
            match[5] = timezone;
            config._i = match.splice(1).join('');
            tzFormat = ' ZZ';
            config._f = dayFormat + dateFormat + timeFormat + tzFormat;
            configFromStringAndFormat(config);
            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || format === undefined && input === '') {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    });

    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function now() {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,

        // matching against regexp is expensive, do it on demand
        match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if ((typeof duration === 'undefined' ? 'undefined' : _typeof(duration)) === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = { milliseconds: 0, months: 0 };

        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val;val = period;period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),

        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString() {
        if (!this.isValid()) {
            return null;
        }
        var m = this.clone().utc();
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        }
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });

    function localeData() {
        return this._locale;
    }

    function startOf(units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
            /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
            /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
            /* falls through */
            case 'hour':
                this.minutes(0);
            /* falls through */
            case 'minute':
                this.seconds(0);
            /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, units === 'isoWeek' ? 'week' : units).subtract(1, 'ms');
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;

    // Year
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;

    // Week Year
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    proto.quarter = proto.quarters = getSetQuarter;

    // Month
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;

    // Week
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;

    // Hour
    proto.hour = proto.hours = getSetHour;

    // Minute
    proto.minute = proto.minutes = getSetMinute;

    // Second
    proto.second = proto.seconds = getSetSecond;

    // Millisecond
    proto.millisecond = proto.milliseconds = getSetMillisecond;

    // Offset
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;

    // Timezone
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;

    // Deprecations
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;

    // Month
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;

    // Week
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    // Hours
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44, // a few seconds to seconds
        s: 45, // seconds to minute
        m: 45, // minutes to hour
        h: 22, // hours to day
        d: 26, // days to month
        M: 11 // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    // Deprecations
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.18.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    return hooks;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(353)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var core = __webpack_require__(36);
var hide = __webpack_require__(24);
var redefine = __webpack_require__(25);
var ctx = __webpack_require__(33);
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root_1 = __webpack_require__(51);
var toSubscriber_1 = __webpack_require__(744);
var observable_1 = __webpack_require__(141);
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;
//# sourceMappingURL=Observable.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(8);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(87);
module.exports.easing = __webpack_require__(436);
module.exports.canvas = __webpack_require__(435);
module.exports.options = __webpack_require__(437);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(665);
} else {
  module.exports = require('./cjs/react.development.js');
}

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);

module.exports = {
	/**
  * @private
  */
	_set: function _set(scope, values) {
		return helpers.merge(this[scope] || (this[scope] = {}), values);
	}
};

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Levels = {
  NONE: 0,
  ERROR: 1,
  WARNING: 2,
  INFO: 3,
  DEBUG: 4
};

function log() {}
function noop() {}

var currentLevel = 0;

log.LEVELS = Object.keys(Levels);
log.error = noop;
log.warn = noop;
log.info = noop;
log.debug = noop;

log.setLevel = function (levelStr) {
  var level = void 0;
  var foundLevel = Levels[levelStr];
  if (foundLevel) {
    level = foundLevel;
    currentLevel = levelStr;
  } else {
    // either 0 or not found
    level = 0;
    currentLevel = "NONE";
  }

  /* eslint-disable no-console */
  log.error = level >= Levels.ERROR ? console.error.bind(console) : noop;
  log.warn = level >= Levels.WARNING ? console.warn.bind(console) : noop;
  log.info = level >= Levels.INFO ? console.info.bind(console) : noop;
  log.debug = level >= Levels.DEBUG ? console.log.bind(console) : noop;
  /* eslint-enable no-console */
};

log.getLevel = function () {
  return currentLevel;
};

/* harmony default export */ __webpack_exports__["a"] = (log);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(99)('wks');
var uid = __webpack_require__(65);
var _Symbol = __webpack_require__(5).Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function AssertionError(message) {
  this.name = "AssertionError";
  this.message = message;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, AssertionError);
  }
}
AssertionError.prototype = new Error();

/**
 * @param {*} value
 * @param {string} message
 * @throws AssertionError - Throws if the value given is falsy
 */
function assert(value, message) {
  if (!value) {
    throw new AssertionError(message);
  }
}

assert.equal = function (a, b, message) {
  return assert(a === b, message);
};

/**
 * @param {Object} o
 * @param {string} name - name of the _interface_
 * @param {Object} iface - Contains the checked keynames of O and link them
 * to their types (obtained through the typeof operator).
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */
assert.iface = function (o, name, iface) {
  assert(o, name + " should be an object");
  for (var k in iface) {
    assert.equal(_typeof(o[k]), iface[k], name + " should have property " + k + " as a " + iface[k]);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (assert);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(7)(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(3);
var IE8_DOM_DEFINE = __webpack_require__(194);
var toPrimitive = __webpack_require__(40);
var dP = Object.defineProperty;

exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(39);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = __webpack_require__(144);
var Subscription_1 = __webpack_require__(50);
var Observer_1 = __webpack_require__(336);
var rxSubscriber_1 = __webpack_require__(142);
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function wrappedComplete() {
                    return _this._complete.call(_this._context);
                };
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);
//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(37);
module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var Subscriber_1 = __webpack_require__(16);
var Subscription_1 = __webpack_require__(50);
var ObjectUnsubscribedError_1 = __webpack_require__(143);
var SubjectSubscription_1 = __webpack_require__(338);
var rxSubscriber_1 = __webpack_require__(142);
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;
//# sourceMappingURL=Subject.js.map

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = ({
  /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
  DEFAULT_UNMUTED_VOLUME: 0.1,

  /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
  DEFAULT_TEXT_TRACK_MODE: "native",

  /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
  DEFAULT_AUTO_PLAY: false,

  /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
  DEFAULT_SHOW_NATIVE_SUBTITLE: true,

  /*
   * Default buffer goal in seconds. Once this amount of time reached ahead in
   * the buffer, the player won't automatically download segments.
   * @type {Number}
   */
  DEFAULT_WANTED_BUFFER_AHEAD: 30,

  /*
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_AHEAD: Infinity,

  /*
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_BEHIND: Infinity,

  /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
  DEFAULT_INITIAL_BITRATES: {
    audio: 0, // only "audio" segments
    video: 0, // only "video" segments
    other: 0 // tracks which are not audio/video (text images).
    // Though those are generally at a single bitrate, so no adaptive
    // mechanism is triggered for them.
  },

  /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MAX_BITRATES: {
    audio: Infinity, // only "audio" segments
    video: Infinity, // only "video" segments
    other: Infinity // tracks which are not audio/video
    // Though those are generally at a single bitrate, so no
    // adaptive mechanism is triggered for them.
  },

  /**
   * Buffer threshold ratio used as a lower bound margin to find the suitable
   * representation.
   * @param {Number}
   */
  DEFAULT_ADAPTIVE_BUFFER_THRESHOLD: 0.3,

  /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video. Allow to enforce specific optimizations when the
   * page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
  INACTIVITY_DELAY: 60 * 1000,

  /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_WHEN_HIDDEN: false,

  /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   * @type {Boolean}
   */
  DEFAULT_LIMIT_VIDEO_WIDTH: false,

  /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
  DEFAULT_LIVE_GAP: 10,

  /**
   * Default value for a manifest's suggested presentation delay if not
   * specified in the manifest.
   * @type {Object}
   */
  DEFAULT_SUGGESTED_PRESENTATION_DELAY: {
    SMOOTH: 10,
    DASH: 10
  },

  /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
  DISCONTINUITY_THRESHOLD: 1,

  /**
   * Time before the end of a video (in seconds) at which the player should
   * automatically stop.
   * It happens often that the video gets stuck 100 to 300 ms before the end,
   * especially on IE11 and Edge
   * @type {Number}
   */
  END_OF_PLAY: 0.5,

  /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
  BITRATE_REBUFFERING_RATIO: 1.5,

  /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the source buffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
  BUFFER_GC_GAPS: {
    /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
    CALM: 240,

    /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
    BEEFY: 30
  },

  /**
   * The default number of times a pipeline request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR: 4,

  /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
  DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE: Infinity,

  /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  INITIAL_BACKOFF_DELAY_BASE: 200,

  /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  MAX_BACKOFF_DELAY_BASE: 3000,

  /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
  SAMPLING_INTERVAL_MEDIASOURCE: 1000,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
  SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,

  /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_TOTAL_BYTES: 200e3,

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_CHUNK_SIZE: 16e3,

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Number}
   */
  ABR_STARVATION_FACTOR: 0.85,

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Number}
   */
  ABR_REGULAR_FACTOR: 0.98,

  /**
   * If a SourceBuffer has less than this amount of seconds ahead of the current
   * position in its buffer, the ABR manager will go into starvation mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this mode:
   *   - the bandwidth considered will be a little lower than the one estimated
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   * @type {Number}
   */
  ABR_STARVATION_GAP: 5,

  OUT_OF_STARVATION_GAP: 7,

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the stream.
   * @type {Number}
   */
  RESUME_AFTER_SEEKING_GAP: 0.5,

  /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
  RESUME_AFTER_BUFFERING_GAP: 5,

  /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
  STALL_GAP: 0.5,

  /**
   * Maximum difference allowed between a segment _announced_ start (what the
   * rx-player infers to be the starting time) and its _real_  current starting
   * time in the source buffer, in seconds, until the segment is considered
   * "incomplete".
   * Same for the ending time announced and its effective end time in the source
   * buffer.
   *
   * If the difference is bigger than this value, the segment will be considered
   * incomplete (e.g. considered as partially garbage-collected) and as such
   * might be re-downloaded.
   *
   * Keeping a too high value might lead to incomplete segments being wrongly
   * considered as complete (and thus not be re-downloaded, this could lead the
   * player to stall).
   * Note that in a worst-case scenario this can happen for the end of a segment
   * and the start of the contiguous segment, leading to a discontinuity two
   * times this value.
   *
   * Keeping a too low value might lead to re-downloading the same segment
   * multiple times (when the start and end times are badly estimated) as they
   * will wrongly believed to be partially garbage-collected.
   *
   * If a segment has a perfect continuity with a previous/following one in the
   * source buffer the start/end of it will not be checked. This allows to limit
   * the number of time this error-prone logic is applied.
   *
   * Note that in most cases, the rx-player's start and end times estimations
   * are __really__ close to what they really are in the sourcebuffer (we
   * usually have a difference in the order of 10^-7), as time information is
   * most of the time directly parsed from the media container.
   *
   * @type {Number}
   */
  MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.12,

  /**
   * The maximum time, in seconds, the real buffered time in the sourcebuffer
   * can be superior to the time inferred by the rx-player (the "real" buffered
   * start inferior to the inferred start and the "real" buffered end superior
   * to the inferred end).
   * This limit allows to avoid resizing too much downloaded segments because
   * no other segment is linked to a buffered part.
   *
   * Setting a value too high can lead to parts of the source buffer being
   * linked to the wrong segments.
   * Setting a value too low can lead to parts of the source buffer not being
   * linked to the concerned segment.
   * @type {Number}
   */
  MAX_BUFFERED_DISTANCE: 0.1,

  /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
  MINIMUM_SEGMENT_SIZE: 0.3,

  /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
  MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 100,

  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO"],

  /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */
  EME_KEY_SYSTEMS: {
    clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
    widevine: ["com.widevine.alpha"],
    playready: ["com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready"]
  }
});

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return addTextTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return canPlay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return canSeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return clearVideoSrc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return isCodecSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return isOffline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return isPlaybackStuck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return makeCue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return shouldRenewMediaKeys; });
/* unused harmony export onSourceOpen$ */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_rx_onEvent_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_log_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__fullscreen_js__ = __webpack_require__(747);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__eme__ = __webpack_require__(745);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_4__constants_js__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_7__eme__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_4__constants_js__["a"]; });
/* unused harmony reexport VTTCue_ */
/* unused harmony reexport events */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_6__fullscreen_js__["a"]; });
/* unused harmony reexport isFirefox */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_6__fullscreen_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_4__constants_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_6__fullscreen_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_7__eme__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_7__eme__["c"]; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











function isCodecSupported(codec) {
  return !!__WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* MediaSource_ */] && __WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* MediaSource_ */].isTypeSupported(codec);
}

function shouldRenewMediaKeys() {
  return __WEBPACK_IMPORTED_MODULE_4__constants_js__["b" /* isIE */];
}

/**
 * Wait for the MediaSource's sourceopen event and emit. Emit immediatelly if
 * already received.
 * @param {MediaSource}
 * @returns {Observable}
 */
function onSourceOpen$(mediaSource) {
  if (mediaSource.readyState == "open") {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);
  } else {
    return __WEBPACK_IMPORTED_MODULE_5__events_js__["g" /* onSourceOpen$ */](mediaSource).take(1);
  }
}

/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metatada are loaded).
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function canSeek(videoElement) {
  if (videoElement.readyState >= __WEBPACK_IMPORTED_MODULE_4__constants_js__["c" /* READY_STATES */].HAVE_METADATA) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);
  } else {
    return __WEBPACK_IMPORTED_MODULE_5__events_js__["h" /* onLoadedMetadata$ */](videoElement).take(1);
  }
}

/**
 * Returns ane observable emitting a single time, as soon as a play is possible.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function canPlay(videoElement) {
  if (videoElement.readyState >= __WEBPACK_IMPORTED_MODULE_4__constants_js__["c" /* READY_STATES */].HAVE_ENOUGH_DATA) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);
  } else {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_rx_onEvent_js__["a" /* default */])(videoElement, "canplay").take(1);
  }
}

// TODO Lacking side-effect?
if (window.WebKitSourceBuffer && !window.WebKitSourceBuffer.prototype.addEventListener) {

  var SourceBuffer = window.WebKitSourceBuffer;
  var SBProto = SourceBuffer.prototype;

  for (var fnNAme in __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].prototype) {
    SBProto[fnNAme] = __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].prototype[fnNAme];
  }

  SBProto.__listeners = [];

  SBProto.appendBuffer = function (data) {
    if (this.updating) {
      throw new Error("updating");
    }
    this.trigger("updatestart");
    this.updating = true;
    try {
      this.append(data);
    } catch (error) {
      this.__emitUpdate("error", error);
      return;
    }
    this.__emitUpdate("update");
  };

  SBProto.__emitUpdate = function (eventName, val) {
    var _this = this;

    setTimeout(function () {
      _this.trigger(eventName, val);
      _this.updating = false;
      _this.trigger("updateend");
    }, 0);
  };
}

function addTextTrack(video, hidden) {
  var track = void 0,
      trackElement = void 0;
  var kind = "subtitles";
  if (__WEBPACK_IMPORTED_MODULE_4__constants_js__["b" /* isIE */]) {
    var tracksLength = video.textTracks.length;
    track = tracksLength > 0 ? video.textTracks[tracksLength - 1] : video.addTextTrack(kind);
    track.mode = hidden ? track.HIDDEN : track.SHOWING;
  } else {
    // there is no removeTextTrack method... so we need to reuse old
    // text-tracks objects and clean all its pending cues
    trackElement = document.createElement("track");
    video.appendChild(trackElement);
    track = trackElement.track;
    trackElement.kind = kind;
    track.mode = hidden ? "hidden" : "showing";
  }
  return { track: track, trackElement: trackElement };
}

/**
 * firefox fix: sometimes the stream can be stalled, even if we are in a
 * buffer.
 * @param {Object} timing
 * @returns {Boolean}
 */
function isPlaybackStuck(timing) {
  var FREEZE_THRESHOLD = 10; // video freeze threshold in seconds
  return __WEBPACK_IMPORTED_MODULE_4__constants_js__["d" /* isFirefox */] && timing.stalled && timing.state === "timeupdate" && timing.range && timing.range.end - timing.currentTime > FREEZE_THRESHOLD;
}

/*
 * Clear video src attribute.
 *
 * On IE11,  video.src = "" is not sufficient as it
 * does not clear properly the current MediaKey Session.
 * Microsoft recommended to use video.removeAttr("src").
 * @param {HTMLMediaElement} video
 */
function clearVideoSrc(video) {
  video.src = "";
  video.removeAttribute("src");
}

/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
  return navigator.onLine === false;
}

/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {TextTrackCue} or null if the parameters were invalid.
 */
function makeCue(startTime, endTime, payload) {
  if (startTime >= endTime) {

    // IE/Edge will throw in this case.
    // See issue #501
    __WEBPACK_IMPORTED_MODULE_3__utils_log_js__["a" /* default */].warn("Invalid cue times: " + startTime + " - " + endTime);
    return null;
  }

  return new __WEBPACK_IMPORTED_MODULE_4__constants_js__["e" /* VTTCue_ */](startTime, endTime, payload);
}



/***/ }),
/* 23 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(14);
var createDesc = __webpack_require__(61);
module.exports = __webpack_require__(13) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var hide = __webpack_require__(24);
var has = __webpack_require__(23);
var SRC = __webpack_require__(65)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(36).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var fails = __webpack_require__(7);
var defined = __webpack_require__(37);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



/**
 * Higher Order component which link module(s) state to your component's prop.
 *
 * The module(s) concerned should be in your component's prop, named as you
 * wish.
 *
 * The state listened to and the corresponding prop passed to your component
 * is done when calling withModuleState.
 *
 * @example
 * ```js
 * import MyComponent from "./MyComponent.js";
 *
 * const MyEnhancedComponent = withModuleState({
 *   moduleA: {
 *     name_of_the_wanted_state_in_module_A: "wanted_resulting_prop_name",
 *     stateA1: "stateA1Prop",
 *     stateA2: "stateA2Prop",
 *   },
 *
 *   moduleB: {
 *     // Most of the time you might want to name them the same
 *     stateB1: "stateB1",
 *     stateB2: "stateB2",
 *   },
 * })(MyComponent);
 *
 * ReactDOM.render(
 *   <MyEnhancedComponent
 *     moduleA={moduleA}
 *     moduleB={moduleB}
 *   />, el);
 *
 * // in __MyComponent__, the corresponding state will be available in
 * // this.props (example: this.props.stateA1Prop). Those will be binded to the
 * // module's state, so updates will be repercuted on your module.
 *
 * // Note that module can be removed and added to the MyEnhancedComponent props
 * // component without problems. State subscriptions will be unlinked/relinked.
 * ```
 * @param {Object} moduleState
 * @returns {Function}
 */
var withModulesState = function withModulesState(modulesState) {
  return function (Comp) {
    var modulesProps = Object.keys(modulesState);
    var modulesSubscriptions = {};
    return function (_React$Component) {
      _inherits(_class, _React$Component);

      function _class() {
        _classCallCheck(this, _class);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

        _this.state = {};

        modulesProps.forEach(function (moduleProp) {
          if (!_this.props[moduleProp]) {
            return;
          }

          var translations = modulesState[modulesProps];
          var module = _this.props[moduleProp];
          var wantedProps = Object.keys(modulesState[moduleProp]);
          wantedProps.forEach(function (state) {
            _this.state[translations[state]] = module.get(state);
          });
        });
        return _this;
      }

      _class.prototype.componentDidMount = function componentDidMount() {
        var _this2 = this;

        modulesProps.forEach(function (moduleProp) {
          if (!_this2.props[moduleProp]) {
            return;
          }

          modulesSubscriptions[moduleProp] = [];

          var translations = modulesState[modulesProps];
          var module = _this2.props[moduleProp];
          var wantedProps = Object.keys(modulesState[moduleProp]);
          wantedProps.forEach(function (state) {
            var sub = module.$get(state).subscribe(function (val) {
              var _this2$setState;

              return _this2.setState((_this2$setState = {}, _this2$setState[translations[state]] = val, _this2$setState));
            });

            modulesSubscriptions[moduleProp].push(sub);
          });
        });
      };

      _class.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var _this3 = this;

        modulesProps.forEach(function (moduleProp) {
          if (!nextProps[moduleProp]) {
            if (modulesSubscriptions[moduleProp]) {
              modulesSubscriptions[moduleProp].forEach(function (sub) {
                return sub.unsubscribe();
              });
              delete modulesSubscriptions[moduleProp];
            }
            return;
          }

          if (!modulesSubscriptions[moduleProp]) {
            modulesSubscriptions[moduleProp] = [];
            var translations = modulesState[modulesProps];
            var module = nextProps[moduleProp];
            var wantedProps = Object.keys(modulesState[moduleProp]);
            wantedProps.forEach(function (state) {
              var sub = module.$get(state).subscribe(function (val) {
                var _this3$setState;

                return _this3.setState((_this3$setState = {}, _this3$setState[translations[state]] = val, _this3$setState));
              });

              modulesSubscriptions[moduleProp].push(sub);
            });
          }
        });
      };

      _class.prototype.componentWillUnmount = function componentWillUnmount() {
        Object.keys(modulesSubscriptions).forEach(function (moduleProp) {
          modulesSubscriptions[moduleProp].forEach(function (sub) {
            return sub.unsubscribe();
          });
          delete modulesSubscriptions[moduleProp];
        });
      };

      _class.prototype.render = function render() {
        var newProps = Object.assign({}, this.props, this.state);
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Comp, newProps);
      };

      return _class;
    }(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);
  };
};

/* harmony default export */ __webpack_exports__["a"] = (withModulesState);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(78);
var createDesc = __webpack_require__(61);
var toIObject = __webpack_require__(30);
var toPrimitive = __webpack_require__(40);
var has = __webpack_require__(23);
var IE8_DOM_DEFINE = __webpack_require__(194);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(23);
var toObject = __webpack_require__(17);
var IE_PROTO = __webpack_require__(125)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(77);
var defined = __webpack_require__(37);
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var color = __webpack_require__(184);
var helpers = __webpack_require__(4);

function interpolate(start, view, model, ease) {
	var keys = Object.keys(model);
	var i, ilen, key, actual, origin, target, type, c0, c1;

	for (i = 0, ilen = keys.length; i < ilen; ++i) {
		key = keys[i];

		target = model[key];

		// if a value is added to the model after pivot() has been called, the view
		// doesn't contain it, so let's initialize the view to the target value.
		if (!view.hasOwnProperty(key)) {
			view[key] = target;
		}

		actual = view[key];

		if (actual === target || key[0] === '_') {
			continue;
		}

		if (!start.hasOwnProperty(key)) {
			start[key] = actual;
		}

		origin = start[key];

		type = typeof target === 'undefined' ? 'undefined' : _typeof(target);

		if (type === (typeof origin === 'undefined' ? 'undefined' : _typeof(origin))) {
			if (type === 'string') {
				c0 = color(origin);
				if (c0.valid) {
					c1 = color(target);
					if (c1.valid) {
						view[key] = c1.mix(c0, ease).rgbString();
						continue;
					}
				}
			} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
				view[key] = origin + (target - origin) * ease;
				continue;
			}
		}

		view[key] = target;
	}
}

var Element = function Element(configuration) {
	helpers.extend(this, configuration);
	this.initialize.apply(this, arguments);
};

helpers.extend(Element.prototype, {

	initialize: function initialize() {
		this.hidden = false;
	},

	pivot: function pivot() {
		var me = this;
		if (!me._view) {
			me._view = helpers.clone(me._model);
		}
		me._start = {};
		return me;
	},

	transition: function transition(ease) {
		var me = this;
		var model = me._model;
		var start = me._start;
		var view = me._view;

		// No animation -> No Transition
		if (!model || ease === 1) {
			me._view = model;
			me._start = null;
			return me;
		}

		if (!view) {
			view = me._view = {};
		}

		if (!start) {
			start = me._start = {};
		}

		interpolate(start, view, model, ease);

		return me;
	},

	tooltipPosition: function tooltipPosition() {
		return {
			x: this._model.x,
			y: this._model.y
		};
	},

	hasValue: function hasValue() {
		return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
	}
});

Element.extend = helpers.inherits;

module.exports = Element;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(21);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(7);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
  });
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(33);
var IObject = __webpack_require__(77);
var toObject = __webpack_require__(17);
var toLength = __webpack_require__(15);
var asc = __webpack_require__(110);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),
/* 37 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(1);
var core = __webpack_require__(36);
var fails = __webpack_require__(7);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),
/* 39 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(8);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Map = __webpack_require__(215);
var $export = __webpack_require__(1);
var shared = __webpack_require__(99)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(218))());

var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }return keyMetadata;
};
var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};
var toMetaKey = function toMetaKey(it) {
  return it === undefined || (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : String(it);
};
var exp = function exp(O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (__webpack_require__(13)) {
  var LIBRARY = __webpack_require__(57);
  var global = __webpack_require__(5);
  var fails = __webpack_require__(7);
  var $export = __webpack_require__(1);
  var $typed = __webpack_require__(101);
  var $buffer = __webpack_require__(131);
  var ctx = __webpack_require__(33);
  var anInstance = __webpack_require__(55);
  var propertyDesc = __webpack_require__(61);
  var hide = __webpack_require__(24);
  var redefineAll = __webpack_require__(62);
  var toInteger = __webpack_require__(39);
  var toLength = __webpack_require__(15);
  var toIndex = __webpack_require__(213);
  var toAbsoluteIndex = __webpack_require__(64);
  var toPrimitive = __webpack_require__(40);
  var has = __webpack_require__(23);
  var classof = __webpack_require__(76);
  var isObject = __webpack_require__(8);
  var toObject = __webpack_require__(17);
  var isArrayIter = __webpack_require__(117);
  var create = __webpack_require__(58);
  var getPrototypeOf = __webpack_require__(29);
  var gOPN = __webpack_require__(59).f;
  var getIterFn = __webpack_require__(133);
  var uid = __webpack_require__(65);
  var wks = __webpack_require__(11);
  var createArrayMethod = __webpack_require__(35);
  var createArrayIncludes = __webpack_require__(88);
  var speciesConstructor = __webpack_require__(100);
  var ArrayIterators = __webpack_require__(134);
  var Iterators = __webpack_require__(68);
  var $iterDetect = __webpack_require__(94);
  var setSpecies = __webpack_require__(63);
  var arrayFill = __webpack_require__(109);
  var arrayCopyWithin = __webpack_require__(186);
  var $DP = __webpack_require__(14);
  var $GOPD = __webpack_require__(28);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function validate(it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) {
      result[index] = list[index++];
    }return result;
  };

  var addGetter = function addGetter(it, key, internal) {
    dP(it, key, { get: function get() {
        return this._d[internal];
      } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of() /* ...items */{
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) {
      result[index] = arguments[index++];
    }return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) {
      this[offset + index] = src[index++];
    }
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function isTAIndex(target, key) {
    return isObject(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function constructor() {/* noop */},
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function get() {
      return this[TYPED_ARRAY];
    }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function getter(that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function setter(that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function addElement(that, index) {
      dP(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) {
          addElement(that, index++);
        }
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function get() {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {/* empty */};

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isKnownError; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EncryptedMediaError_js__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__IndexError_js__ = __webpack_require__(794);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MediaError_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NetworkError_js__ = __webpack_require__(795);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__OtherError_js__ = __webpack_require__(796);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RequestError_js__ = __webpack_require__(797);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__constants_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__constants_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_0__constants_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__EncryptedMediaError_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_2__IndexError_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__MediaError_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_4__NetworkError_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_5__OtherError_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_6__RequestError_js__["a"]; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * Whether the error given has a type defined here.
 * @param {Error} error
 * @returns {Boolean}
 */
function isKnownError(error) {
  return !!error && !!error.type && __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].keys.indexOf(error.type) >= 0;
}



/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// inspired from MDN polyfill, but ponyfilled instead
/* harmony default export */ __webpack_exports__["a"] = (function (arr, searchElement, fromIndex) {
  if (typeof Array.prototype.includes === "function") {
    return arr.includes(searchElement, fromIndex);
  }

  var len = arr.length >>> 0;

  if (len === 0) {
    return false;
  }

  var n = fromIndex | 0;
  var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

  var areTheSame = function areTheSame(x, y) {
    return x === y ||
    // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
  };

  while (k < len) {
    if (areTheSame(arr[k], searchElement)) {
      return true;
    }
    k++;
  }

  return false;
});

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = castToObservable;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Try to cast the given value into an observable.
 * StraightForward - test first for an Observable then for a Promise.
 * @param {Observable|Function|*}
 * @returns {Observable}
 */
function castToObservable(value) {
  if (value instanceof __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"]) {
    return value;
  }

  if (value && typeof value.subscribe == "function") {
    return new __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"](function (obs) {
      var sub = value.subscribe(function (val) {
        return obs.next(val);
      }, function (err) {
        return obs.error(err);
      }, function () {
        return obs.complete();
      });

      return function () {
        if (sub && sub.dispose) {
          sub.dispose();
        } else if (sub && sub.unsubscribe) {
          sub.unsubscribe();
        }
      };
    });
  }

  if (value && typeof value.then == "function") {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].fromPromise(value);
  }

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(value);
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};
module.exports.Arc = __webpack_require__(431);
module.exports.Line = __webpack_require__(432);
module.exports.Point = __webpack_require__(433);
module.exports.Rectangle = __webpack_require__(434);

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(11)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(24)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var META = __webpack_require__(65)('meta');
var isObject = __webpack_require__(8);
var has = __webpack_require__(23);
var setDesc = __webpack_require__(14).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(7)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {} // weak collections IDs
    } });
};
var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
    // return object ID
  }return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;
//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = __webpack_require__(80);
var isObject_1 = __webpack_require__(350);
var isFunction_1 = __webpack_require__(144);
var tryCatch_1 = __webpack_require__(145);
var errorObject_1 = __webpack_require__(103);
var UnsubscriptionError_1 = __webpack_require__(743);
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}
//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// CommonJS / Node have global context exposed as "global" variable.
// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
// the global "global" var for now.

var __window = typeof window !== 'undefined' && window;
var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
var __global = typeof global !== 'undefined' && global;
var _root = __window || __global || __self;
exports.root = _root;
// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
// This is needed when used with angular/tsickle which inserts a goog.module statement.
// Wrap in IIFE
(function () {
    if (!_root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
})();
//# sourceMappingURL=root.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(146)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root_1 = __webpack_require__(51);
var isArrayLike_1 = __webpack_require__(347);
var isPromise_1 = __webpack_require__(351);
var isObject_1 = __webpack_require__(350);
var Observable_1 = __webpack_require__(2);
var iterator_1 = __webpack_require__(140);
var InnerSubscriber_1 = __webpack_require__(666);
var observable_1 = __webpack_require__(141);
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;
//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isInBackground$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return videoWidth$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return onPlayPause$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return onTextTrackChanges$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return onLoadedMetadata$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return onSeeking$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return onSeeked$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return onEnded$; });
/* unused harmony export onTimeUpdate$ */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return onFullscreenChange$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return onSourceOpen$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return onEncrypted$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return onKeyMessage$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return onKeyAdded$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return onKeyError$; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return onKeyStatusesChange$; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_rx_onEvent_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(147);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */










var INACTIVITY_DELAY = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].INACTIVITY_DELAY;
var pixelRatio = window.devicePixelRatio || 1;

function isEventSupported(element, eventNameSuffix) {
  var clone = document.createElement(element.tagName);
  var eventName = "on" + eventNameSuffix;
  if (eventName in clone) {
    return true;
  } else {
    clone.setAttribute(eventName, "return;");
    return typeof clone[eventName] == "function";
  }
}

function findSupportedEvent(element, eventNames) {
  return eventNames.filter(function (name) {
    return isEventSupported(element, name);
  })[0];
}

function eventPrefixed(eventNames, prefixes) {
  return eventNames.reduce(function (parent, name) {
    return parent.concat((prefixes || __WEBPACK_IMPORTED_MODULE_4__constants_js__["h" /* BROWSER_PREFIXES */]).map(function (p) {
      return p + name;
    }));
  }, []);
}

function compatibleListener(eventNames, prefixes) {
  var mem = void 0;
  eventNames = eventPrefixed(eventNames, prefixes);
  return function (element) {
    // if the element is a HTMLElement we can detect
    // the supported event, and memoize it in `mem`
    if (element instanceof __WEBPACK_IMPORTED_MODULE_4__constants_js__["i" /* HTMLElement_ */]) {
      if (typeof mem == "undefined") {
        mem = findSupportedEvent(element, eventNames) || null;
      }

      if (mem) {
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].fromEvent(element, mem);
      } else {
        if (true) {
          __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("compat: element <" + element.tagName + "> does not support any of these events: " + eventNames.join(", "));
        }
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].never();
      }
    }

    // otherwise, we need to listen to all the events
    // and merge them into one observable sequence
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_rx_onEvent_js__["a" /* default */])(element, eventNames);
  };
}

/**
 * Returns an observable:
 *   - emitting true when the visibility of document changes to hidden
 *   - emitting false when the visibility of document changes to visible
 * @returns {Observable}
 */
var visibilityChange = function visibilityChange() {
  var prefix = void 0;
  if (document.hidden != null) {
    prefix = "";
  } else if (document.mozHidden != null) {
    prefix = "moz";
  } else if (document.msHidden != null) {
    prefix = "ms";
  } else if (document.webkitHidden != null) {
    prefix = "webkit";
  }

  var hidden = prefix ? prefix + "Hidden" : "hidden";
  var visibilityChangeEvent = prefix + "visibilitychange";

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_rx_onEvent_js__["a" /* default */])(document, visibilityChangeEvent).map(function () {
    return document[hidden];
  });
};

var videoSizeChange = function videoSizeChange() {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_rx_onEvent_js__["a" /* default */])(window, "resize");
};

var isVisible = visibilityChange() // emit false when visible
.filter(function (x) {
  return x === false;
});

// Emit true if the visibility changed to hidden since 60s
var isHidden = visibilityChange().debounceTime(INACTIVITY_DELAY).filter(function (x) {
  return x === true;
});

var isInBackground$ = function isInBackground$() {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(isVisible, isHidden).startWith(false);
};

var videoWidth$ = function videoWidth$(videoElement) {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].interval(20000), videoSizeChange().debounceTime(500)).startWith("init") // emit on subscription
  .map(function () {
    return videoElement.clientWidth * pixelRatio;
  }).distinctUntilChanged();
};

var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
var onSeeking$ = compatibleListener(["seeking"]);
var onSeeked$ = compatibleListener(["seeked"]);
var onEnded$ = compatibleListener(["ended"]);
var onTimeUpdate$ = compatibleListener(["timeupdate"]);
var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"],

// On IE11, fullscreen change events is called MSFullscreenChange
__WEBPACK_IMPORTED_MODULE_4__constants_js__["h" /* BROWSER_PREFIXES */].concat("MS"));

var onPlayPause$ = compatibleListener(["play", "pause"]);
var onTextTrackChanges$ = compatibleListener(["addtrack", "removetrack"]);

var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
var onEncrypted$ = compatibleListener(["encrypted", "needkey"]);
var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
var onKeyError$ = compatibleListener(["keyerror", "error"]);
var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export areRangesNearlyContiguous */
/* unused harmony export areRangesOverlapping */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return convertToRanges; });
/* unused harmony export findOverlappingRange */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getInnerAndOuterTimeRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getLeftSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getNextRangeGap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getPlayedSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return insertInto; });
/* unused harmony export isAfter */
/* unused harmony export isBefore */
/* unused harmony export isTimeInRange */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return keepRangeIntersection; });
/* unused harmony export mergeContiguousRanges */
/* unused harmony export removeEmptyRanges */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */

// Factor for rounding errors
var EPSILON = 1 / 60;

/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function nearlyEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}

/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */
function createRangeUnion(range1, range2) {
  var start = Math.min(range1.start, range2.start);
  var end = Math.max(range1.end, range2.end);
  return { start: start, end: end };
}

/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Boolean}
 */
function removeEmptyRanges(ranges) {
  for (var index = 0; index < ranges.length; index++) {
    var range = ranges[index];
    if (range.start === range.end) {
      ranges.splice(index++, 1);
    }
  }
  return ranges;
}

/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function mergeContiguousRanges(ranges) {
  for (var index = 1; index < ranges.length; index++) {
    var prevRange = ranges[index - 1];
    var currRange = ranges[index];
    if (areRangesNearlyContiguous(prevRange, currRange)) {
      var unionRange = createRangeUnion(prevRange, currRange);
      ranges.splice(--index, 2, unionRange);
    }
  }
  return ranges;
}

/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isAfter(range1, range2) {
  return range1.start >= range2.end;
}

/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isBefore(range1, range2) {
  return range1.end <= range2.start;
}

/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */
function isTimeInRange(_ref, time) {
  var start = _ref.start,
      end = _ref.end;

  return start <= time && time < end;
}

/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesOverlapping(range1, range2) {
  return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
}

/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesNearlyContiguous(range1, range2) {
  return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
}

/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */
function convertToRanges(timeRanges) {
  var ranges = [];
  for (var i = 0; i < timeRanges.length; i++) {
    ranges.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return ranges;
}

/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */
function getRange(timeRanges, time) {
  for (var i = timeRanges.length - 1; i >= 0; i--) {
    var start = timeRanges.start(i);
    if (time >= start) {
      var end = timeRanges.end(i);
      if (time < end) {
        return {
          start: start,
          end: end
        };
      }
    }
  }
  return null;
}

/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */
function getNextRangeGap(timeRanges, time) {
  var len = timeRanges.length;
  for (var i = 0; i < len; i++) {
    var start = timeRanges.start(i);
    if (time < start) {
      return start - time;
    }
  }
  return Infinity;
}

/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */
function getInnerAndOuterTimeRanges(timeRanges, time) {
  var innerRange = null;
  var outerRanges = [];
  for (var i = timeRanges.length - 1; i >= 0; i--) {
    var start = timeRanges.start(i);
    var end = timeRanges.end(i);
    if (time < start || time >= end) {
      outerRanges.push({ start: start, end: end });
    } else {
      innerRange = { start: start, end: end };
    }
  }
  return { outerRanges: outerRanges, innerRange: innerRange };
}

/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range ? range.end - range.start : 0;
}

/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getPlayedSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range ? currentTime - range.start : 0;
}

/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getLeftSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range ? range.end - currentTime : Infinity;
}

/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAdd
 * @returns {Array.<Object>}
 */
function insertInto(ranges, rangeToAdd) {
  if (rangeToAdd.start === rangeToAdd.end) {
    return ranges;
  }

  // For each present range check if we need to:
  // - In case we are overlapping or contiguous:
  //   - if added range has the same bitrate as the overlapped or
  //     contiguous one, we can merge themcurrentRange
  //   - if added range has a different bitrate we need to insert it
  //     in place
  // - Need to insert in place, we we are completely, not overlapping
  //   and not contiguous in between two ranges.

  var index = 0;
  for (; index < ranges.length; index++) {
    var range = ranges[index];

    var overlapping = areRangesOverlapping(rangeToAdd, range);
    var contiguous = areRangesNearlyContiguous(rangeToAdd, range);

    // We assume ranges are ordered and two ranges can not be
    // completely overlapping.
    if (overlapping || contiguous) {
      rangeToAdd = createRangeUnion(rangeToAdd, range);
      ranges.splice(index--, 1);
    } else {
      // Check the case for which there is no more to do
      if (index === 0) {
        if (isBefore(rangeToAdd, ranges[0])) {
          // First index, and we are completely before that range (and
          // not contiguous, nor overlapping). We just need to be
          // inserted here.
          break;
        }
      } else {
        if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {
          // We are exactly after the current previous range, and
          // before the current range, while not overlapping with none
          // of them. Insert here.
          break;
        }
      }
    }
  }

  // Now that we are sure we don't overlap with any range, just add it.
  ranges.splice(index, 0, rangeToAdd);

  return mergeContiguousRanges(removeEmptyRanges(ranges));
}

/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Object|null}
 */
function findOverlappingRange(range, ranges) {
  for (var i = 0; i < ranges.length; i++) {
    if (areRangesOverlapping(range, ranges[i])) {
      return ranges[i];
    }
  }
  return null;
}

/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * /!\ Mutates the ranges1 array given
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */
function keepRangeIntersection(ranges1, ranges2) {
  for (var i = 0; i < ranges1.length; i++) {
    var range = ranges1[i];
    var overlappingRange = findOverlappingRange(range, ranges2);
    if (!overlappingRange) {
      ranges1.splice(i--, 1);
    } else if (overlappingRange.start > range.start) {
      range.start = overlappingRange.start;
    } else if (overlappingRange.end < range.end) {
      range.end = overlappingRange.end;
    }
  }
  return ranges1;
}



/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(33);
var call = __webpack_require__(197);
var isArrayIter = __webpack_require__(117);
var anObject = __webpack_require__(3);
var toLength = __webpack_require__(15);
var getIterFn = __webpack_require__(133);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(3);
var dPs = __webpack_require__(203);
var enumBugKeys = __webpack_require__(113);
var IE_PROTO = __webpack_require__(125)('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(112)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(115).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(205);
var hiddenKeys = __webpack_require__(113).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(205);
var enumBugKeys = __webpack_require__(113);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(25);
module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }return target;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var dP = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(13);
var SPECIES = __webpack_require__(11)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(39);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 65 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var ScalarObservable_1 = __webpack_require__(137);
var EmptyObservable_1 = __webpack_require__(79);
var isScheduler_1 = __webpack_require__(72);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;
//# sourceMappingURL=ArrayObservable.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function find(array, predicate, context) {
  if (typeof Array.prototype.find === 'function') {
    return array.find(predicate, context);
  }

  context = context || this;
  var length = array.length;
  var i;

  if (typeof predicate !== 'function') {
    throw new TypeError(predicate + ' is not a function');
  }

  for (i = 0; i < length; i++) {
    if (predicate.call(context, array[i], i, array)) {
      return array[i];
    }
  }
}

module.exports = find;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(14).f;
var has = __webpack_require__(23);
var TAG = __webpack_require__(11)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var defined = __webpack_require__(37);
var fails = __webpack_require__(7);
var spaces = __webpack_require__(129);
var space = '[' + spaces + ']';
var non = '\u200B\x85';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(8);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;
//# sourceMappingURL=isScheduler.js.map

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return RequestErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ErrorCodes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_listToMap_js__ = __webpack_require__(838);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var ErrorTypes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_listToMap_js__["a" /* default */])(["NETWORK_ERROR", "MEDIA_ERROR", "ENCRYPTED_MEDIA_ERROR", "INDEX_ERROR", "OTHER_ERROR"]);

var RequestErrorTypes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_listToMap_js__["a" /* default */])(["TIMEOUT", "ERROR_EVENT", "ERROR_HTTP_CODE", "PARSE_ERROR"]);

var ErrorCodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_listToMap_js__["a" /* default */])(["PIPELINE_RESOLVE_ERROR", "PIPELINE_LOAD_ERROR", "PIPELINE_PARSING_ERROR", "MANIFEST_PARSE_ERROR", "MANIFEST_INCOMPATIBLE_CODECS_ERROR", "MEDIA_IS_ENCRYPTED_ERROR", "KEY_ERROR", "KEY_STATUS_CHANGE_ERROR", "KEY_UPDATE_ERROR", "KEY_LOAD_ERROR", "KEY_LOAD_TIMEOUT", "KEY_GENERATE_REQUEST_ERROR", "INCOMPATIBLE_KEYSYSTEMS", "LICENSE_SERVER_CERTIFICATE_ERROR", "BUFFER_APPEND_ERROR", "BUFFER_FULL_ERROR", "BUFFER_TYPE_UNKNOWN", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_SOURCE_NOT_SUPPORTED", "MEDIA_KEYS_NOT_SUPPORTED", "OUT_OF_INDEX_ERROR", "UNKNOWN_INDEX"]);



/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeBaseURL; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Scheme part of an url (e.g. "http://").
 */
var schemeRe = /^(?:[a-z]+:)?\/\//i;

/**
 * Captures "/../" or "/./".
 */
var selfDirRe = /\/\.{1,2}\//;

/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
function _normalizeUrl(url) {
  // fast path if no ./ or ../ are present in the url
  if (!selfDirRe.test(url)) {
    return url;
  }

  var newUrl = [];
  var oldUrl = url.split("/");
  for (var i = 0, l = oldUrl.length; i < l; i++) {
    if (oldUrl[i] == "..") {
      newUrl.pop();
    } else if (oldUrl[i] == ".") {
      continue;
    } else {
      newUrl.push(oldUrl[i]);
    }
  }

  return newUrl.join("/");
}

/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */
function resolveURL() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var len = args.length;
  if (len === 0) {
    return "";
  }

  var base = "";
  for (var i = 0; i < len; i++) {
    var part = args[i];
    if (typeof part !== "string" || part === "") {
      continue;
    }
    if (schemeRe.test(part)) {
      base = part;
    } else {
      // trim if begins with "/"
      if (part[0] === "/") {
        part = part.substr(1);
      }

      // trim if ends with "/"
      if (base[base.length - 1] === "/") {
        base = base.substr(0, base.length - 1);
      }

      base = base + "/" + part;
    }
  }

  return _normalizeUrl(base);
}

/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */
function normalizeBaseURL(url) {
  var slash = url.lastIndexOf("/");
  if (slash >= 0) {
    return url.substring(0, slash + 1);
  } else {
    return url;
  }
}



/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);

/**
 * Namespace to hold static tick generation functions
 * @namespace Chart.Ticks
 */
module.exports = {
	/**
  * Namespace to hold generators for different types of ticks
  * @namespace Chart.Ticks.generators
  */
	generators: {
		/**
   * Interface for the options provided to the numeric tick generator
   * @interface INumericTickGenerationOptions
   */
		/**
   * The maximum number of ticks to display
   * @name INumericTickGenerationOptions#maxTicks
   * @type Number
   */
		/**
   * The distance between each tick.
   * @name INumericTickGenerationOptions#stepSize
   * @type Number
   * @optional
   */
		/**
   * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
   * @name INumericTickGenerationOptions#min
   * @type Number
   * @optional
   */
		/**
   * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
   * @name INumericTickGenerationOptions#max
   * @type Number
   * @optional
   */

		/**
   * Generate a set of linear ticks
   * @method Chart.Ticks.generators.linear
   * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
   * @param dataRange {IRange} the range of the data
   * @returns {Array<Number>} array of tick values
   */
		linear: function linear(generationOptions, dataRange) {
			var ticks = [];
			// To get a "nice" value for the tick spacing, we will use the appropriately named
			// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
			// for details.

			var spacing;
			if (generationOptions.stepSize && generationOptions.stepSize > 0) {
				spacing = generationOptions.stepSize;
			} else {
				var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
				spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
			}
			var niceMin = Math.floor(dataRange.min / spacing) * spacing;
			var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

			// If min, max and stepSize is set and they make an evenly spaced scale use it.
			if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
				// If very close to our whole number, use it.
				if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
					niceMin = generationOptions.min;
					niceMax = generationOptions.max;
				}
			}

			var numSpaces = (niceMax - niceMin) / spacing;
			// If very close to our rounded value, use it.
			if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
				numSpaces = Math.round(numSpaces);
			} else {
				numSpaces = Math.ceil(numSpaces);
			}

			// Put the values into the ticks array
			ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
			for (var j = 1; j < numSpaces; ++j) {
				ticks.push(niceMin + j * spacing);
			}
			ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

			return ticks;
		},

		/**
   * Generate a set of logarithmic ticks
   * @method Chart.Ticks.generators.logarithmic
   * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
   * @param dataRange {IRange} the range of the data
   * @returns {Array<Number>} array of tick values
   */
		logarithmic: function logarithmic(generationOptions, dataRange) {
			var ticks = [];
			var valueOrDefault = helpers.valueOrDefault;

			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph
			var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

			var endExp = Math.floor(helpers.log10(dataRange.max));
			var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
			var exp, significand;

			if (tickVal === 0) {
				exp = Math.floor(helpers.log10(dataRange.minNotZero));
				significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

				ticks.push(tickVal);
				tickVal = significand * Math.pow(10, exp);
			} else {
				exp = Math.floor(helpers.log10(tickVal));
				significand = Math.floor(tickVal / Math.pow(10, exp));
			}

			do {
				ticks.push(tickVal);

				++significand;
				if (significand === 10) {
					significand = 1;
					++exp;
				}

				tickVal = significand * Math.pow(10, exp);
			} while (exp < endExp || exp === endExp && significand < endSignificand);

			var lastTick = valueOrDefault(generationOptions.max, tickVal);
			ticks.push(lastTick);

			return ticks;
		}
	},

	/**
  * Namespace to hold formatters for different types of ticks
  * @namespace Chart.Ticks.formatters
  */
	formatters: {
		/**
   * Formatter for value labels
   * @method Chart.Ticks.formatters.values
   * @param value the value to display
   * @return {String|Array} the label to display
   */
		values: function values(value) {
			return helpers.isArray(value) ? value : '' + value;
		},

		/**
   * Formatter for linear numeric ticks
   * @method Chart.Ticks.formatters.linear
   * @param tickValue {Number} the value to be formatted
   * @param index {Number} the position of the tickValue parameter in the ticks array
   * @param ticks {Array<Number>} the list of ticks being converted
   * @return {String} string representation of the tickValue parameter
   */
		linear: function linear(tickValue, index, ticks) {
			// If we have lots of ticks, don't use the ones
			var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

			// If we have a number like 2.5 as the delta, figure out how many decimal places we need
			if (Math.abs(delta) > 1) {
				if (tickValue !== Math.floor(tickValue)) {
					// not an integer
					delta = tickValue - Math.floor(tickValue);
				}
			}

			var logDelta = helpers.log10(Math.abs(delta));
			var tickString = '';

			if (tickValue !== 0) {
				var numDecimal = -1 * Math.floor(logDelta);
				numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
				tickString = tickValue.toFixed(numDecimal);
			} else {
				tickString = '0'; // never show decimal places for 0
			}

			return tickString;
		},

		logarithmic: function logarithmic(tickValue, index, ticks) {
			var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));

			if (tickValue === 0) {
				return '0';
			} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
				return tickValue.toExponential();
			}
			return '';
		}
	}
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(32);
var TAG = __webpack_require__(11)('toStringTag');
// ES3 wrong here
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? cof(O)
  // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(32);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 78 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;
//# sourceMappingURL=EmptyObservable.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};
//# sourceMappingURL=isArray.js.map

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errorMessage_js__ = __webpack_require__(82);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @class MediaError
 */
function MediaError(code, reason, fatal) {
  this.name = "MediaError";
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].MEDIA_ERROR;

  this.reason = reason;
  this.code = __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* ErrorCodes */][code];
  this.fatal = fatal;
  this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, this.reason);
}
MediaError.prototype = new Error();

/* harmony default export */ __webpack_exports__["a"] = (MediaError);

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = errorMessage;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
  if (!reason) {
    return name + " (" + code + ")";
  } else {
    switch (typeof reason === "undefined" ? "undefined" : _typeof(reason)) {

      case "string":
        return name + " (" + code + ") " + reason;

      default:
        return name + " (" + code + ") " + reason.message;
    }
  }
}

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return normalizeRange; });
/* unused harmony export getTimelineRangeStart */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getTimelineRangeEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInitSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setTimescale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return scale; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__segment_js__ = __webpack_require__(104);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} ts
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
var normalizeRange = function normalizeRange(index, ts, duration) {
  var pto = index.presentationTimeOffset || 0;
  var timescale = index.timescale || 1;

  return {
    up: ts * timescale - pto,
    to: (ts + duration) * timescale - pto
  };
};

/**
 * Get start of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute start time of the range
 */
var getTimelineRangeStart = function getTimelineRangeStart(_ref) {
  var ts = _ref.ts,
      d = _ref.d,
      r = _ref.r;
  return d === -1 ? ts : ts + r * d;
};

/**
 * Get end of the given index range, timescaled.
 * @param {Object} range
 * @param {Number} range.ts - the range's start time
 * @param {Number} range.d - the range's duration
 * @param {Number} range.r - the range's count. 0 for a single element, 1 for
 * 2 elements etc.
 * @returns {Number} - absolute end time of the range
 */
var getTimelineRangeEnd = function getTimelineRangeEnd(_ref2) {
  var ts = _ref2.ts,
      d = _ref2.d,
      r = _ref2.r;
  return d === -1 ? ts : ts + (r + 1) * d;
};

/**
 * Construct init segment for the given index.
 * @param {string} rootId
 * @param {Object} index
 * @param {Number} index.timescale
 * @param {Object} [index.initialization={}]
 * @param {Array.<Number>|null} [index.initialization.range=null]
 * @param {Array.<Number>|null} [index.initialization.indexRange=null]
 * @param {string} [index.initialization.media]
 * @returns {Segment}
 */
var getInitSegment = function getInitSegment(rootId, index) {
  var _index$initialization = index.initialization,
      initialization = _index$initialization === undefined ? {} : _index$initialization;


  var args = {
    id: "" + rootId + "_init",
    init: true,
    range: initialization.range || null,
    indexRange: index.indexRange || null,
    media: initialization.media,
    timescale: index.timescale
  };
  return new __WEBPACK_IMPORTED_MODULE_1__segment_js__["a" /* default */](args);
};

/**
 * Update the timescale used (for all segments).
 * TODO This should probably update all previous segments to the newly set
 * Timescale.
 *
 * /!\ Mutates the given index
 * @param {Object} index
 * @param {Number} timescale
 * @returns {Object}
 */
var setTimescale = function setTimescale(index, timescale) {
  if (true) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(typeof timescale == "number");
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(timescale > 0);
  }

  if (index.timescale !== timescale) {
    index.timescale = timescale;
  }

  return index;
};

/**
 * Re-scale a given time from timescaled information to second-based.
 * @param {Object} index
 * @param {Number} time
 * @returns {Number}
 */
var scale = function scale(index, time) {
  if (true) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(index.timescale > 0);
  }

  return time / index.timescale;
};



/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export totalBytes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return strToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bytesToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return bytesToUTF16Str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return hexToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return bytesToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return be2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return be3toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return be4toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return be8toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return le2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return le4toi; });
/* unused harmony export le8toi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return itobe2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return itobe4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return itobe8; });
/* unused harmony export itole2 */
/* unused harmony export itole4 */
/* unused harmony export itole8 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return guidToUuid; });
/* unused harmony export toBase64URL */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assert__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns total bytes in an array of ArrayBuffer.
 * @param {Array.<ArrayBuffer>} arr
 * @returns {Number}
 */
function totalBytes(arr) {
  var tot = 0;
  for (var i = 0; i < arr.length; i++) {
    tot += arr[i].byteLength;
  }
  return tot;
}

/**
 * Returns Uint8Array from UTF16 string.
 * /!\ Take only the first byte from each UTF16 code.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    arr[i] = str.charCodeAt(i) & 0xFF;
  }
  return arr;
}

/**
 * construct string from unicode values.
 * /!\ does not support non-UCS-2 values
 * @param {TypedArray} bytes
 * @returns {string}
 */
function bytesToStr(bytes) {
  return String.fromCharCode.apply(null, bytes);
}

/**
 * construct string from unicode values.
 * Only use every other byte for each UTF-16 character.
 * /!\ does not support non-UCS-2 values
 * @param {TypedArray} bytes
 * @returns {string}
 */
function bytesToUTF16Str(bytes) {
  var str = "";
  var len = bytes.length;
  for (var i = 0; i < len; i += 2) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}

/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */
function hexToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len / 2);
  for (var i = 0, j = 0; i < len; i += 2, j++) {
    arr[j] = parseInt(str.substr(i, 2), 16) & 0xFF;
  }
  return arr;
}

/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {TypedArray} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */
function bytesToHex(bytes, sep) {
  if (!sep) {
    sep = "";
  }

  var hex = "";
  for (var i = 0; i < bytes.byteLength; i++) {
    hex += (bytes[i] >>> 4).toString(16);
    hex += (bytes[i] & 0xF).toString(16);
    if (sep.length && i < bytes.byteLength - 1) {
      hex += sep;
    }
  }
  return hex;
}

/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|TypedArray)} arguments
 * @returns {Uint8Array}
 */
function concat() {
  var l = arguments.length;
  var i = -1;
  var len = 0;
  var arg = void 0;
  while (++i < l) {
    arg = arguments[i];
    len += typeof arg === "number" ? arg : arg.length;
  }
  var arr = new Uint8Array(len);
  var off = 0;
  i = -1;
  while (++i < l) {
    arg = arguments[i];
    if (typeof arg === "number") {
      off += arg;
    } else if (arg.length > 0) {
      arr.set(arg, off);
      off += arg.length;
    }
  }
  return arr;
}

/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function be2toi(bytes, off) {
  return (bytes[0 + off] << 8) + (bytes[1 + off] << 0);
}

/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function be3toi(bytes, off) {
  return bytes[0 + off] * 0x0010000 + bytes[1 + off] * 0x0000100 + bytes[2 + off];
}

/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function be4toi(bytes, off) {
  return bytes[0 + off] * 0x1000000 + bytes[1 + off] * 0x0010000 + bytes[2 + off] * 0x0000100 + bytes[3 + off];
}

/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function be8toi(bytes, off) {
  return (bytes[0 + off] * 0x1000000 + bytes[1 + off] * 0x0010000 + bytes[2 + off] * 0x0000100 + bytes[3 + off]) * 0x100000000 + bytes[4 + off] * 0x1000000 + bytes[5 + off] * 0x0010000 + bytes[6 + off] * 0x0000100 + bytes[7 + off];
}

/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe2(num) {
  return new Uint8Array([num >>> 8 & 0xFF, num & 0xFF]);
}

/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe4(num) {
  return new Uint8Array([num >>> 24 & 0xFF, num >>> 16 & 0xFF, num >>> 8 & 0xFF, num & 0xFF]);
}

/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h >>> 24 & 0xFF, h >>> 16 & 0xFF, h >>> 8 & 0xFF, h & 0xFF, l >>> 24 & 0xFF, l >>> 16 & 0xFF, l >>> 8 & 0xFF, l & 0xFF]);
}

/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function le2toi(bytes, off) {
  return (bytes[0 + off] << 0) + (bytes[1 + off] << 8);
}

/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function le4toi(bytes, off) {
  return bytes[0 + off] + bytes[1 + off] * 0x0000100 + bytes[2 + off] * 0x0010000 + bytes[3 + off] * 0x1000000;
}

/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {TypedArray} bytes
 * @param {Number} off - The offset (from the start of the given array)
 * @returns {Number}
 */
function le8toi(bytes, off) {
  return bytes[0 + off] + bytes[1 + off] * 0x0000100 + bytes[2 + off] * 0x0010000 + bytes[3 + off] * 0x1000000 + (bytes[4 + off] + bytes[5 + off] * 0x0000100 + bytes[6 + off] * 0x0010000 + bytes[7 + off] * 0x1000000) * 0x100000000;
}

/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole2(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF]);
}

/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole4(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF, num >>> 16 & 0xFF, num >>> 24 & 0xFF]);
}

/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h & 0xFF, h >>> 8 & 0xFF, h >>> 16 & 0xFF, h >>> 24 & 0xFF, l & 0xFF, l >>> 8 & 0xFF, l >>> 16 & 0xFF, l >>> 24 & 0xFF]);
}

/**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */
function guidToUuid(uuid) {
  __WEBPACK_IMPORTED_MODULE_0__assert__["a" /* default */].equal(uuid.length, 16, "UUID length should be 16");
  var buf = strToBytes(uuid);

  var p1A = buf[0];
  var p1B = buf[1];
  var p1C = buf[2];
  var p1D = buf[3];
  var p2A = buf[4];
  var p2B = buf[5];
  var p3A = buf[6];
  var p3B = buf[7];
  var p4 = buf.subarray(8, 10);
  var p5 = buf.subarray(10, 16);

  var ord = new Uint8Array(16);
  ord[0] = p1D;ord[1] = p1C;ord[2] = p1B;ord[3] = p1A; // swap32 BE -> LE
  ord[4] = p2B;ord[5] = p2A; // swap16 BE -> LE
  ord[6] = p3B;ord[7] = p3A; // swap16 BE -> LE
  ord.set(p4, 8);
  ord.set(p5, 10);

  return bytesToHex(ord);
}

/**
 * Creates a base-64 encoded ASCII string from a string of binary data, with
 * possible trailing equal sign(s) stripped.
 * @param {string}
 * @returns {string}
 */
function toBase64URL(str) {
  return btoa(str).replace(/\=+$/, "");
}



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/**
 * Generic Button React component.
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      onClick = _ref.onClick,
      value = _ref.value,
      disabled = _ref.disabled;

  if (disabled) {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "button",
      {
        disabled: true,
        className: className + " disabled"
      },
      value
    );
  }

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "button",
    {
      className: className,
      onClick: onClick
    },
    value
  );
});

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Select_jsx__ = __webpack_require__(177);



/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      _ref$name = _ref.name,
      name = _ref$name === undefined ? "" : _ref$name,
      onChange = _ref.onChange,
      _ref$options = _ref.options,
      options = _ref$options === undefined ? [] : _ref$options,
      selected = _ref.selected,
      disabled = _ref.disabled;
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: "knob " + className },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      { className: "knob-name" },
      name
    ),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__Select_jsx__["a" /* default */], {
      className: "knob-value",
      onChange: onChange,
      options: options,
      selected: selected,
      disabled: disabled
    })
  );
});

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @namespace Chart.helpers
 */

var helpers = {
	/**
  * An empty function that can be used, for example, for optional callback.
  */
	noop: function noop() {},

	/**
  * Returns a unique id, sequentially generated from a global variable.
  * @returns {Number}
  * @function
  */
	uid: function () {
		var id = 0;
		return function () {
			return id++;
		};
	}(),

	/**
  * Returns true if `value` is neither null nor undefined, else returns false.
  * @param {*} value - The value to test.
  * @returns {Boolean}
  * @since 2.7.0
  */
	isNullOrUndef: function isNullOrUndef(value) {
		return value === null || typeof value === 'undefined';
	},

	/**
  * Returns true if `value` is an array, else returns false.
  * @param {*} value - The value to test.
  * @returns {Boolean}
  * @function
  */
	isArray: Array.isArray ? Array.isArray : function (value) {
		return Object.prototype.toString.call(value) === '[object Array]';
	},

	/**
  * Returns true if `value` is an object (excluding null), else returns false.
  * @param {*} value - The value to test.
  * @returns {Boolean}
  * @since 2.7.0
  */
	isObject: function isObject(value) {
		return value !== null && Object.prototype.toString.call(value) === '[object Object]';
	},

	/**
  * Returns `value` if defined, else returns `defaultValue`.
  * @param {*} value - The value to return if defined.
  * @param {*} defaultValue - The value to return if `value` is undefined.
  * @returns {*}
  */
	valueOrDefault: function valueOrDefault(value, defaultValue) {
		return typeof value === 'undefined' ? defaultValue : value;
	},

	/**
  * Returns value at the given `index` in array if defined, else returns `defaultValue`.
  * @param {Array} value - The array to lookup for value at `index`.
  * @param {Number} index - The index in `value` to lookup for value.
  * @param {*} defaultValue - The value to return if `value[index]` is undefined.
  * @returns {*}
  */
	valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
		return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
	},

	/**
  * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
  * value returned by `fn`. If `fn` is not a function, this method returns undefined.
  * @param {Function} fn - The function to call.
  * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
  * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
  * @returns {*}
  */
	callback: function callback(fn, args, thisArg) {
		if (fn && typeof fn.call === 'function') {
			return fn.apply(thisArg, args);
		}
	},

	/**
  * Note(SB) for performance sake, this method should only be used when loopable type
  * is unknown or in none intensive code (not called often and small loopable). Else
  * it's preferable to use a regular for() loop and save extra function calls.
  * @param {Object|Array} loopable - The object or array to be iterated.
  * @param {Function} fn - The function to call for each item.
  * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
  * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
  */
	each: function each(loopable, fn, thisArg, reverse) {
		var i, len, keys;
		if (helpers.isArray(loopable)) {
			len = loopable.length;
			if (reverse) {
				for (i = len - 1; i >= 0; i--) {
					fn.call(thisArg, loopable[i], i);
				}
			} else {
				for (i = 0; i < len; i++) {
					fn.call(thisArg, loopable[i], i);
				}
			}
		} else if (helpers.isObject(loopable)) {
			keys = Object.keys(loopable);
			len = keys.length;
			for (i = 0; i < len; i++) {
				fn.call(thisArg, loopable[keys[i]], keys[i]);
			}
		}
	},

	/**
  * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
  * @see http://stackoverflow.com/a/14853974
  * @param {Array} a0 - The array to compare
  * @param {Array} a1 - The array to compare
  * @returns {Boolean}
  */
	arrayEquals: function arrayEquals(a0, a1) {
		var i, ilen, v0, v1;

		if (!a0 || !a1 || a0.length !== a1.length) {
			return false;
		}

		for (i = 0, ilen = a0.length; i < ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];

			if (v0 instanceof Array && v1 instanceof Array) {
				if (!helpers.arrayEquals(v0, v1)) {
					return false;
				}
			} else if (v0 !== v1) {
				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}

		return true;
	},

	/**
  * Returns a deep copy of `source` without keeping references on objects and arrays.
  * @param {*} source - The value to clone.
  * @returns {*}
  */
	clone: function clone(source) {
		if (helpers.isArray(source)) {
			return source.map(helpers.clone);
		}

		if (helpers.isObject(source)) {
			var target = {};
			var keys = Object.keys(source);
			var klen = keys.length;
			var k = 0;

			for (; k < klen; ++k) {
				target[keys[k]] = helpers.clone(source[keys[k]]);
			}

			return target;
		}

		return source;
	},

	/**
  * The default merger when Chart.helpers.merge is called without merger option.
  * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
  * @private
  */
	_merger: function _merger(key, target, source, options) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.merge(tval, sval, options);
		} else {
			target[key] = helpers.clone(sval);
		}
	},

	/**
  * Merges source[key] in target[key] only if target[key] is undefined.
  * @private
  */
	_mergerIf: function _mergerIf(key, target, source) {
		var tval = target[key];
		var sval = source[key];

		if (helpers.isObject(tval) && helpers.isObject(sval)) {
			helpers.mergeIf(tval, sval);
		} else if (!target.hasOwnProperty(key)) {
			target[key] = helpers.clone(sval);
		}
	},

	/**
  * Recursively deep copies `source` properties into `target` with the given `options`.
  * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
  * @param {Object} target - The target object in which all sources are merged into.
  * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
  * @param {Object} [options] - Merging options:
  * @param {Function} [options.merger] - The merge method (key, target, source, options)
  * @returns {Object} The `target` object.
  */
	merge: function merge(target, source, options) {
		var sources = helpers.isArray(source) ? source : [source];
		var ilen = sources.length;
		var merge, i, keys, klen, k;

		if (!helpers.isObject(target)) {
			return target;
		}

		options = options || {};
		merge = options.merger || helpers._merger;

		for (i = 0; i < ilen; ++i) {
			source = sources[i];
			if (!helpers.isObject(source)) {
				continue;
			}

			keys = Object.keys(source);
			for (k = 0, klen = keys.length; k < klen; ++k) {
				merge(keys[k], target, source, options);
			}
		}

		return target;
	},

	/**
  * Recursively deep copies `source` properties into `target` *only* if not defined in target.
  * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
  * @param {Object} target - The target object in which all sources are merged into.
  * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
  * @returns {Object} The `target` object.
  */
	mergeIf: function mergeIf(target, source) {
		return helpers.merge(target, source, { merger: helpers._mergerIf });
	}
};

module.exports = helpers;

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.callback instead.
 * @function Chart.helpers.callCallback
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
helpers.callCallback = helpers.callback;

/**
 * Provided for backward compatibility, use Array.prototype.indexOf instead.
 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
 * @function Chart.helpers.indexOf
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.indexOf = function (array, item, fromIndex) {
	return Array.prototype.indexOf.call(array, item, fromIndex);
};

/**
 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
 * @function Chart.helpers.getValueOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueOrDefault = helpers.valueOrDefault;

/**
 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
 * @function Chart.helpers.getValueAtIndexOrDefault
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(30);
var toLength = __webpack_require__(15);
var toAbsoluteIndex = __webpack_require__(64);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(25);
var redefineAll = __webpack_require__(62);
var meta = __webpack_require__(48);
var forOf = __webpack_require__(56);
var anInstance = __webpack_require__(55);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(7);
var $iterDetect = __webpack_require__(94);
var setToStringTag = __webpack_require__(69);
var inheritIfRequired = __webpack_require__(116);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);return this;
    });
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) {
        $instance[ADDER](index, index);
      }return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__(24);
var redefine = __webpack_require__(25);
var fails = __webpack_require__(7);
var defined = __webpack_require__(37);
var wks = __webpack_require__(11);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () {
      return 7;
    };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    }
    // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(3);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(32);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(8);
var cof = __webpack_require__(32);
var MATCH = __webpack_require__(11)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(11)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods

module.exports = __webpack_require__(57) || !__webpack_require__(7)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () {/* empty */});
  delete __webpack_require__(5)[K];
});

/***/ }),
/* 96 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(1);
var aFunction = __webpack_require__(21);
var ctx = __webpack_require__(33);
var forOf = __webpack_require__(56);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(1);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = Array(length);
      while (length--) {
        A[length] = arguments[length];
      }return new this(A);
    } });
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(3);
var aFunction = __webpack_require__(21);
var SPECIES = __webpack_require__(11)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var hide = __webpack_require__(24);
var uid = __webpack_require__(65);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AsyncAction_1 = __webpack_require__(344);
var AsyncScheduler_1 = __webpack_require__(345);
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };
//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Segment =
/**
 * @constructor
 * @param {Object} [args={}]
 * @param {string|Number} [args.id]
 * @param {Number} [args.duration]
 * @param {Boolean} [args.init=false]
 * @param {Number} [args.time]
 * @param {Array.<Number>} [args.range]
 * @param {Array.<Number>} [args.indexRange]
 * @param {Number} [args.number]
 * @param {Number} [args.timescale]
 * @param {string} [args.media]
 */
function Segment() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Segment);

  this.id = args.id;
  this.duration = args.duration;
  this.isInit = !!args.init;
  this.range = args.range;
  this.time = args.time;
  this.indexRange = args.indexRange;
  this.number = args.number;
  this.timescale = args.timescale == null ? 1 : args.timescale;
  this.media = args.media;
};

/* harmony default export */ __webpack_exports__["a"] = (Segment);

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toWallClockTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromWallClockTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getMinimumBufferPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getMaximumBufferPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getBufferLimits; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO methods of manifest class?
 */

function toWallClockTime(position, manifest) {
  return new Date((position + manifest.availabilityStartTime) * 1000);
}

/**
 * TODO This function should have more of a seekTo kind of name
 * ``fromWallClockTime`` should probably just do:
 * ```js
 * (timeInSeconds, manifest) => {
 *   return timeInSeconds - manifest.availabilityStartTime;
 * };
 * ```
 * It should be the exact opposite of ``toWallClockTime``
 */
function fromWallClockTime(timeInMs, manifest) {
  return normalizeWallClockTime(timeInMs, manifest) / 1000 - manifest.availabilityStartTime;
}

/**
 * TODO This function should have more of a seekTo kind of name
 */
function normalizeWallClockTime(timeInMs, manifest) {
  var suggestedPresentationDelay = manifest.suggestedPresentationDelay,
      presentationLiveGap = manifest.presentationLiveGap,
      timeShiftBufferDepth = manifest.timeShiftBufferDepth;


  if (typeof timeInMs != "number") {
    timeInMs = timeInMs.getTime();
  }

  var now = Date.now();
  var max = now - (presentationLiveGap + suggestedPresentationDelay) * 1000;
  var min = now - timeShiftBufferDepth * 1000;
  return Math.max(Math.min(timeInMs, max), min);
}

function getMinimumBufferPosition(manifest) {
  // we have to know both the min and the max to be sure
  var _getBufferLimits = getBufferLimits(manifest),
      min = _getBufferLimits[0];

  return min;
}

/**
 * Get maximum position to which we should be able to construct a buffer.
 * @param {Manifest} manifest
 * @returns {Number}
 */
function getMaximumBufferPosition(manifest) {
  if (!manifest.isLive) {
    return manifest.getDuration();
  }

  var availabilityStartTime = manifest.availabilityStartTime,
      presentationLiveGap = manifest.presentationLiveGap;

  var now = Date.now() / 1000;
  return now - availabilityStartTime - presentationLiveGap;
}

function getBufferLimits(manifest) {
  // TODO use RTT for the manifest request + 3 or something
  var BUFFER_DEPTH_SECURITY = 5;

  if (!manifest.isLive) {
    return [0, manifest.getDuration()];
  }

  var availabilityStartTime = manifest.availabilityStartTime,
      presentationLiveGap = manifest.presentationLiveGap,
      timeShiftBufferDepth = manifest.timeShiftBufferDepth;


  var now = Date.now() / 1000;
  var max = now - availabilityStartTime - presentationLiveGap;
  return [Math.min(max, max - timeShiftBufferDepth + BUFFER_DEPTH_SECURITY), max];
}



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMDHDTimescale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return parseTfdt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDurationFromTrun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parseSidx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getMdat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return patchPssh; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_bytes__ = __webpack_require__(84);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Find the right atom (box) in an isobmff file from its hexa-encoded name.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {Number} - offset where the corresponding box is (starting with its
 * size), 0 if not found.
 */
function findAtom(buf, atomName) {
  var l = buf.length;
  var i = 0;

  var name = void 0,
      size = void 0;
  while (i + 8 < l) {
    size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, i);
    name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, i + 4);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(size > 0, "out of range size");
    if (name === atomName) {
      break;
    } else {
      i += size;
    }
  }

  if (i >= l) {
    return -1;
  }

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(i + size <= l, "atom out of range");
  return i;
}

/**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} offset
 * @returns {Object|null} {Array.<Object>} - Informations about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */
function parseSidx(buf, offset) {
  var index = findAtom(buf, 0x73696478 /* "sidx" */);
  if (index == -1) {
    return null;
  }

  var size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, index);
  var pos = index + /* size */4 + /* name */4;

  /* version(8) */
  /* flags(24) */
  /* reference_ID(32); */
  /* timescale(32); */
  var version = buf[pos];pos += 4 + 4;
  var timescale = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos);pos += 4;

  /* earliest_presentation_time(32 / 64) */
  /* first_offset(32 / 64) */
  var time = void 0;
  if (version === 0) {
    time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos);pos += 4;
    offset += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos) + size;pos += 4;
  } else if (version === 1) {
    time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["f" /* be8toi */])(buf, pos);pos += 8;
    offset += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["f" /* be8toi */])(buf, pos) + size;pos += 8;
  } else {
    return null;
  }

  var segments = [];

  /* reserved(16) */
  /* reference_count(16) */
  pos += 2;
  var count = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["g" /* be2toi */])(buf, pos);
  pos += 2;
  while (--count >= 0) {
    /* reference_type(1) */
    /* reference_size(31) */
    /* segment_duration(32) */
    /* sap..(32) */
    var refChunk = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos);
    pos += 4;
    var refType = (refChunk & 0x80000000) >>> 31;
    var refSize = refChunk & 0x7fffffff;

    // when set to 1 indicates that the reference is to a sidx, else to media
    if (refType == 1) {
      throw new Error("not implemented");
    }

    var d = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos);
    pos += 4;

    // let sapChunk = be4toi(buf, pos + 8);
    pos += 4;

    // TODO(pierre): handle sap
    // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
    // let sapType = (sapChunk & 0x70000000) >>> 28;
    // let sapDelta = sapChunk & 0x0FFFFFFF;

    var ts = time;
    segments.push({
      time: ts,
      duration: d,
      count: 0,
      timescale: timescale,
      range: [offset, offset + refSize - 1]
    });

    time += d;
    offset += refSize;
  }

  return segments;
}

/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function parseTfdt(buffer) {
  var moof = getAtomContent(buffer, 0x6d6f6f66 /* moof */);
  if (!moof) {
    return -1;
  }

  var traf = getAtomContent(moof, 0x74726166 /* traf */);
  if (!traf) {
    return -1;
  }

  var index = findAtom(traf, 0x74666474 /* tfdt */);
  if (index == -1) {
    return -1;
  }

  var pos = index + /* size */4 + /* name */4;
  var version = traf[pos];pos += 4;
  if (version > 1) {
    return -1;
  }

  return version ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["f" /* be8toi */])(traf, pos) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(traf, pos);
}

function getDefaultDurationFromTFHDInTRAF(traf) {
  var index = findAtom(traf, 0x74666864 /* tfhd */);
  if (index == -1) {
    return -1;
  }

  var pos = index + /* size */4 + /* name */4 + /* version */1;

  var flags = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["h" /* be3toi */])(traf, pos);

  var hasBaseDataOffset = flags & 0x000001;
  var hasSampleDescriptionIndex = flags & 0x000002;
  var hasDefaultSampleDuration = flags & 0x000008;

  if (!hasDefaultSampleDuration) {
    return -1;
  }

  pos += 4;

  if (hasBaseDataOffset) {
    pos += 8;
  }

  if (hasSampleDescriptionIndex) {
    pos += 4;
  }

  var defaultDuration = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(traf, pos);

  return defaultDuration;
}

function getDurationFromTrun(buffer) {
  var moof = getAtomContent(buffer, 0x6d6f6f66 /* moof */);
  if (!moof) {
    return -1;
  }

  var traf = getAtomContent(moof, 0x74726166 /* traf */);
  if (!traf) {
    return -1;
  }

  var index = findAtom(traf, 0x7472756e /* tfdt */);
  if (index == -1) {
    return -1;
  }

  var pos = index + /* size */4 + /* name */4;
  var version = traf[pos];pos += 1;
  if (version > 1) {
    return -1;
  }
  var flags = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["h" /* be3toi */])(traf, pos);pos += 3;
  var hasSampleDuration = flags & 0x000100;

  var defaultDuration = 0;
  if (!hasSampleDuration) {
    defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
    if (defaultDuration >= 0) {
      return defaultDuration;
    }
    return -1;
  }

  var hasDataOffset = flags & 0x000001;
  var hasFirstSampleFlags = flags & 0x000004;
  var hasSampleSize = flags & 0x000200;
  var hasSampleFlags = flags & 0x000400;
  var hasSampleCompositionOffset = flags & 0x000800;

  var sampleCounts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(traf, pos);pos += 4;

  if (hasDataOffset) {
    pos += 4;
  }

  if (hasFirstSampleFlags) {
    pos += 4;
  }

  var i = sampleCounts;
  var duration = 0;
  while (i--) {
    if (hasSampleDuration) {
      duration += __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(traf, pos);
      pos += 4;
    } else {
      duration += defaultDuration;
    }
    if (hasSampleSize) {
      pos += 4;
    }
    if (hasSampleFlags) {
      pos += 4;
    }
    if (hasSampleCompositionOffset) {
      pos += 4;
    }
  }

  return duration;
}

/**
 * Get various informations from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */
function getMDHDTimescale(buffer) {
  var moov = getAtomContent(buffer, 0x6d6f6f76 /* moov */);
  if (!moov) {
    return -1;
  }
  var trak = getAtomContent(moov, 0x7472616b /* "trak" */);
  if (index == -1) {
    return -1;
  }

  var mdia = getAtomContent(trak, 0x6d646961 /* "mdia" */);
  if (index == -1) {
    return -1;
  }

  var index = findAtom(mdia, 0x6d646864 /* "mdhd" */);
  if (index / -1) {
    return -1;
  }

  var pos = index + /* size */4 + /* name */4;

  var version = mdia[pos];pos += 4;
  if (version === 1) {
    pos += 16;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(mdia, pos);
  } else if (version == 0) {
    pos += 8;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(mdia, pos);
  } else {
    return -1;
  }
}

/**
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} atomName - the 'name' of the box (e.g. 'sidx' or 'moov'),
 * hexa encoded
 * @returns {UInt8Array|null}
 */
function getAtomContent(buf, atomName) {
  var l = buf.length;
  var i = 0;

  var name = void 0,
      size = void 0;
  while (i + 8 < l) {
    size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, i);
    name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, i + 4);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(size > 0, "out of range size");
    if (name === atomName) {
      break;
    } else {
      i += size;
    }
  }

  if (i < l) {
    return buf.subarray(i + 8, i + size);
  } else {
    return null;
  }
}

/**
 * @param {Uint8Array} buf - The isobmff
 * @returns {Uint8Array|null} - Content of the mdat atom, null if not found
 */
function getMdat(buf) {
  return getAtomContent(buf, 0x6D646174 /* "mdat" */);
}

/**
 * Create a new _Atom_ (isobmff box).
 * @param {string} name - The box name (e.g. sidx, moov, pssh etc.)
 * @param {Uint8Array} buff - The box's content
 */
function Atom(name, buff) {
  var len = buff.length + 8;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["i" /* concat */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["j" /* itobe4 */])(len), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["b" /* strToBytes */])(name), buff);
}

/**
 * Returns a PSSH Atom from a systemId and private data.
 * @param {Object} args
 * @returns {Uint8Array}
 */
function createPssh(_ref) {
  var systemId = _ref.systemId,
      privateData = _ref.privateData;

  systemId = systemId.replace(/-/g, "");

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(systemId.length === 32);
  return Atom("pssh", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["i" /* concat */])(4, // 4 initial zeroed bytes
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["k" /* hexToBytes */])(systemId), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["j" /* itobe4 */])(privateData.length), privateData));
}

/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the pssList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} pssList - The content protections under the form of
 * objects containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {*}: private data associated.
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */
function patchPssh(buf, pssList) {
  if (!pssList || !pssList.length) {
    return buf;
  }

  var pos = findAtom(buf, 0x6d6f6f76 /* = "moov" */);
  if (pos == -1) {
    return buf;
  }

  var size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["e" /* be4toi */])(buf, pos); // size of the "moov" box
  var moov = buf.subarray(pos, pos + size);

  var newmoov = [moov];
  for (var i = 0; i < pssList.length; i++) {
    newmoov.push(createPssh(pssList[i]));
  }

  newmoov = __WEBPACK_IMPORTED_MODULE_1__utils_bytes__["i" /* concat */].apply(null, newmoov);
  newmoov.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["j" /* itobe4 */])(newmoov.length), 0); // overwrite "moov" length

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_bytes__["i" /* concat */])(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));
}



/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__assert__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function EventEmitter() {
  this.__listeners = {};
}

EventEmitter.prototype.addEventListener = function (evt, fn) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__assert__["a" /* default */])(typeof fn == "function", "eventemitter: second argument should be a function");
  if (!this.__listeners[evt]) {
    this.__listeners[evt] = [];
  }
  this.__listeners[evt].push(fn);
};

EventEmitter.prototype.removeEventListener = function (evt, fn) {
  if (arguments.length === 0) {
    this.__listeners = {};
    return;
  }
  if (!this.__listeners.hasOwnProperty(evt)) {
    return;
  }
  if (arguments.length === 1) {
    delete this.__listeners[evt];
    return;
  }
  var listeners = this.__listeners[evt];
  var index = listeners.indexOf(fn);
  if (~index) {
    listeners.splice(index, 1);
  }
  if (!listeners.length) {
    delete this.__listeners[evt];
  }
};

EventEmitter.prototype.trigger = function (evt, arg) {
  if (!this.__listeners.hasOwnProperty(evt)) {
    return;
  }
  var listeners = this.__listeners[evt].slice();
  listeners.forEach(function (listener) {
    try {
      listener(arg);
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_0__log__["a" /* default */].error(e, e.stack);
    }
  });
};

// aliases
EventEmitter.prototype.on = EventEmitter.prototype.addEventListener;
EventEmitter.prototype.off = EventEmitter.prototype.removeEventListener;

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return normalizeAudioTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return normalizeTextTrack; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ISO_639_1_to_ISO_639_3_js__ = __webpack_require__(836);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ISO_639_2_to_ISO_639_3_js__ = __webpack_require__(837);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeTextTrack(_language) {
  if (_language != null) {
    var language = void 0,
        closedCaption = void 0;
    if (typeof _language === "string") {
      language = _language;
      closedCaption = false;
    } else {
      language = _language.language;
      closedCaption = !!_language.closedCaption;
    }

    return {
      language: language,
      closedCaption: closedCaption,
      normalized: normalize(language)
    };
  }
  return _language;
}

/**
 * Normalize audio track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 * @param {Object|string} _language
 * @returns {Object|null|undefined}
 */
function normalizeAudioTrack(_language) {
  if (_language != null) {
    var language = void 0,
        audioDescription = void 0;
    if (typeof _language === "string") {
      language = _language;
      audioDescription = false;
    } else {
      language = _language.language;
      audioDescription = !!_language.audioDescription;
    }

    return {
      language: language,
      audioDescription: audioDescription,
      normalized: normalize(language)
    };
  }
  return _language;
}

/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
function normalize(_language) {
  if (_language == null || _language === "") {
    return "";
  }
  var fields = ("" + _language).toLowerCase().split("-");
  var base = fields[0];
  var normalizedBase = normalizeBase(base);
  if (normalizedBase) {
    fields[0] = normalizedBase;
  }
  return fields.join("-");
}

/**
 * Normalize language into an ISO639-3 format.
 * @param {string} base
 * @returns {string}
 */
function normalizeBase(base) {
  var result = void 0;
  if (base.length === 2) {
    result = __WEBPACK_IMPORTED_MODULE_0__ISO_639_1_to_ISO_639_3_js__["a" /* default */][base];
  } else if (base.length === 3) {
    result = __WEBPACK_IMPORTED_MODULE_1__ISO_639_2_to_ISO_639_3_js__["a" /* default */][base];
  }
  return result || base;
}



/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(17);
var toAbsoluteIndex = __webpack_require__(64);
var toLength = __webpack_require__(15);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) {
    O[index++] = value;
  }return O;
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(454);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(14);
var createDesc = __webpack_require__(61);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(8);
var document = __webpack_require__(5).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 113 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(11)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {/* empty */}
  }return true;
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(5).document;
module.exports = document && document.documentElement;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(8);
var setPrototypeOf = __webpack_require__(124).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }return that;
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(68);
var ITERATOR = __webpack_require__(11)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(58);
var descriptor = __webpack_require__(61);
var setToStringTag = __webpack_require__(69);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(24)(IteratorPrototype, __webpack_require__(11)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(57);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(25);
var hide = __webpack_require__(24);
var has = __webpack_require__(23);
var Iterators = __webpack_require__(68);
var $iterCreate = __webpack_require__(118);
var setToStringTag = __webpack_require__(69);
var getPrototypeOf = __webpack_require__(29);
var ITERATOR = __webpack_require__(11)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 120 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1
// Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
// Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 121 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var macrotask = __webpack_require__(130).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(32)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    };
    // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function notify() {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function notify() {
      promise.then(flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    }last = task;
  };
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(21);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(8);
var anObject = __webpack_require__(3);
var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(33)(Function.call, __webpack_require__(28).f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(99)('keys');
var uid = __webpack_require__(65);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(39);
var defined = __webpack_require__(37);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(93);
var defined = __webpack_require__(37);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(39);
var defined = __webpack_require__(37);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }return res;
};

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(33);
var invoke = __webpack_require__(195);
var html = __webpack_require__(115);
var cel = __webpack_require__(112);
var global = __webpack_require__(5);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function run() {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(32)(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var DESCRIPTORS = __webpack_require__(13);
var LIBRARY = __webpack_require__(57);
var $typed = __webpack_require__(101);
var hide = __webpack_require__(24);
var redefineAll = __webpack_require__(62);
var fails = __webpack_require__(7);
var anInstance = __webpack_require__(55);
var toInteger = __webpack_require__(39);
var toLength = __webpack_require__(15);
var toIndex = __webpack_require__(213);
var gOPN = __webpack_require__(59).f;
var dP = __webpack_require__(14).f;
var arrayFill = __webpack_require__(109);
var setToStringTag = __webpack_require__(69);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function get() {
      return this[internal];
    } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) {
    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var core = __webpack_require__(36);
var LIBRARY = __webpack_require__(57);
var wksExt = __webpack_require__(214);
var defineProperty = __webpack_require__(14).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(76);
var ITERATOR = __webpack_require__(11)('iterator');
var Iterators = __webpack_require__(68);
module.exports = __webpack_require__(36).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(47);
var step = __webpack_require__(198);
var Iterators = __webpack_require__(68);
var toIObject = __webpack_require__(30);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(119)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(18);
var ObjectUnsubscribedError_1 = __webpack_require__(143);
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function get() {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        } else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject);
exports.BehaviorSubject = BehaviorSubject;
//# sourceMappingURL=BehaviorSubject.js.map

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;
//# sourceMappingURL=ScalarObservable.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;
//# sourceMappingURL=mergeAll.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ConnectableObservable_1 = __webpack_require__(694);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
exports.MulticastOperator = MulticastOperator;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root_1 = __webpack_require__(51);
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;
//# sourceMappingURL=iterator.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root_1 = __webpack_require__(51);
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;
//# sourceMappingURL=observable.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root_1 = __webpack_require__(51);
var _Symbol = root_1.root.Symbol;
exports.rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;
//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorObject_1 = __webpack_require__(103);
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;
//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return BROWSER_PREFIXES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return HTMLElement_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return HTMLVideoElement_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaSource_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return MediaKeys_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isIE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return READY_STATES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return VTTCue_; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__ = __webpack_require__(81);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var win = window;
var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
var HTMLElement_ = win.HTMLElement;
var HTMLVideoElement_ = win.HTMLVideoElement;
var VTTCue_ = win.VTTCue || win.TextTrackCue;

var MediaSource_ = win.MediaSource || win.MozMediaSource || win.WebKitMediaSource || win.MSMediaSource;

var MediaKeys_ = win.MediaKeys || win.MozMediaKeys || win.WebKitMediaKeys || win.MSMediaKeys;

if (!MediaKeys_) {
  var noMediaKeys = function noMediaKeys() {
    throw new __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__["a" /* default */]("MEDIA_KEYS_NOT_SUPPORTED", null, true);
  };

  MediaKeys_ = {
    create: noMediaKeys,
    isTypeSupported: noMediaKeys
  };
}

// true for IE / Edge
var isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName == "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent);

var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;

var READY_STATES = {
  HAVE_NOTHING: 0,
  HAVE_METADATA: 1,
  HAVE_CURRENT_DATA: 2,
  HAVE_FUTURE_DATA: 3,
  HAVE_ENOUGH_DATA: 4
};



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PLAYER_STATES; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file declares constants useful for every API files
 */

/**
 * Player state dictionnary
 * @type {Object}
 */
var PLAYER_STATES = {
  STOPPED: "STOPPED",
  LOADED: "LOADED",
  LOADING: "LOADING",
  PLAYING: "PLAYING",
  PAUSED: "PAUSED",
  ENDED: "ENDED",
  BUFFERING: "BUFFERING",
  SEEKING: "SEEKING"
};

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return $storedSessions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return $loadedSessions; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sessions_set__ = __webpack_require__(770);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var emptyStorage = {
  load: function load() {
    return [];
  },
  save: function save() {}
};

var $storedSessions = new __WEBPACK_IMPORTED_MODULE_0__sessions_set__["a" /* PersistedSessionsSet */](emptyStorage);
var $loadedSessions = new __WEBPACK_IMPORTED_MODULE_0__sessions_set__["b" /* InMemorySessionsSet */]();

if (true) {
  window.$loadedSessions = $loadedSessions;
  window.$storedSessions = $storedSessions;
}



/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AbstractSourceBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_eventemitter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_rx_tryCatch_js__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__time_ranges_js__ = __webpack_require__(790);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */

var AbstractSourceBuffer = function (_EventEmitter) {
  _inherits(AbstractSourceBuffer, _EventEmitter);

  function AbstractSourceBuffer(codec) {
    _classCallCheck(this, AbstractSourceBuffer);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.codec = codec;
    _this.updating = false;
    _this.readyState = "opened";
    _this.buffered = new __WEBPACK_IMPORTED_MODULE_4__time_ranges_js__["a" /* default */]();
    return _this;
  }

  /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append segment.
   * @param {*} data
   */


  AbstractSourceBuffer.prototype.appendBuffer = function appendBuffer(data) {
    var _this2 = this;

    this._lock(function () {
      return _this2._append(data);
    });
  };

  /**
   * Mimic the SourceBuffer _remove_ method: remove segment.
   * @param {Number} from
   * @param {Number} to
   */


  AbstractSourceBuffer.prototype.remove = function remove(from, to) {
    var _this3 = this;

    this._lock(function () {
      return _this3._remove(from, to);
    });
  };

  /**
   * Mimic the SourceBuffer _abort_ method.
   */


  AbstractSourceBuffer.prototype.abort = function abort() {
    this.remove(0, Infinity);
    this.updating = false;
    this.readyState = "closed";
    this._abort();
  };

  AbstractSourceBuffer.prototype._append = function _append() /* data */{}; // to implement, called on appendBuffer


  AbstractSourceBuffer.prototype._remove = function _remove() /* from, to */{}; // to implement, called on remove


  AbstractSourceBuffer.prototype._abort = function _abort() {}; // to implement, called on abort

  /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */


  AbstractSourceBuffer.prototype._lock = function _lock(func) {
    var _this4 = this;

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(!this.updating, "updating");
    this.updating = true;
    this.trigger("updatestart");
    var result = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_rx_tryCatch_js__["a" /* default */])(function () {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_castToObservable_js__["a" /* default */])(func());
    });
    result.subscribe(function () {
      return setTimeout(function () {
        return _this4._unlock("update");
      }, 0);
    }, function (e) {
      return setTimeout(function () {
        return _this4._unlock("error", e);
      }, 0);
    });
  };

  /**
   * Free the lock and trigger the right events.
   * @param {string} eventName
   * @param {*} value - value sent with the given event.
   */


  AbstractSourceBuffer.prototype._unlock = function _unlock(eventName, value) {
    this.updating = false;
    this.trigger(eventName, value);
    this.trigger("updateend");
  };

  return AbstractSourceBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__utils_eventemitter__["a" /* default */]);



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errorMessage_js__ = __webpack_require__(82);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @class EncryptedMediaError
 */
function EncryptedMediaError(code, reason, fatal) {
  this.name = "EncryptedMediaError";
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].ENCRYPTED_MEDIA_ERROR;

  this.reason = reason;
  this.code = __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* ErrorCodes */][code];
  this.fatal = fatal;
  this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, this.reason);
}
EncryptedMediaError.prototype = new Error();

/* harmony default export */ __webpack_exports__["a"] = (EncryptedMediaError);

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__segment_js__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers_js__ = __webpack_require__(83);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} ts
 * @returns {Number}
 */
var getSegmentIndex = function getSegmentIndex(index, ts) {
  var timeline = index.timeline;


  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;
    if (timeline[mid].ts < ts) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
};

/**
 * @param {Number} ts
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
var getSegmentNumber = function getSegmentNumber(ts, up, duration) {
  var diff = up - ts;
  if (diff > 0) {
    return Math.floor(diff / duration);
  } else {
    return 0;
  }
};

/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} seg
 * @param {Number} seg.ts - beginning timescaled timestamp
 * @param {Number} seg.d - timescaled duration of the segment
 * @param {Object} nextSeg
 * @param {Number} nextSeg.t - TODO check that one
 * @returns {Number}
 */
var calculateRepeat = function calculateRepeat(seg, nextSeg) {
  var rep = seg.r || 0;

  // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  if (rep < 0) {
    var repEnd = nextSeg ? nextSeg.t : Infinity;
    rep = Math.ceil((repEnd - seg.ts) / seg.d) - 1;
  }

  return rep;
};

var SegmentTimelineHelpers = {
  getInitSegment: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["a" /* getInitSegment */],
  setTimescale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["b" /* setTimescale */],
  scale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["c" /* scale */],

  /**
   * @param {string|Number} repId
   * @param {Object} index
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Segment>}
   */
  getSegments: function getSegments(repId, index, _up, _to) {
    var _normalizeRange = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["d" /* normalizeRange */])(index, _up, _to),
        up = _normalizeRange.up,
        to = _normalizeRange.to;

    var timeline = index.timeline,
        timescale = index.timescale,
        media = index.media;

    var segments = [];

    var timelineLength = timeline.length;
    var timelineIndex = getSegmentIndex(index, up) - 1;
    // TODO(pierre): use @maxSegmentDuration if possible
    var maxDuration = timeline.length && timeline[0].d || 0;

    loop: for (;;) {
      if (++timelineIndex >= timelineLength) {
        break;
      }

      var segmentRange = timeline[timelineIndex];
      var d = segmentRange.d,
          ts = segmentRange.ts,
          range = segmentRange.range;

      maxDuration = Math.max(maxDuration, d);

      // live-added segments have @d attribute equals to -1
      if (d < 0) {
        if (ts + maxDuration < to) {
          var args = {
            id: "" + repId + "_" + ts,
            time: ts,
            init: false,
            range: range,
            duration: undefined,
            indexRange: null,
            timescale: timescale,
            media: media
          };
          segments.push(new __WEBPACK_IMPORTED_MODULE_0__segment_js__["a" /* default */](args));
        }
        break;
      }

      var repeat = calculateRepeat(segmentRange, timeline[timelineIndex + 1]);
      var segmentNumber = getSegmentNumber(ts, up, d);
      var segmentTime = void 0;
      while ((segmentTime = ts + segmentNumber * d) < to) {
        if (segmentNumber++ <= repeat) {
          var _args = {
            id: "" + repId + "_" + segmentTime,
            time: segmentTime,
            init: false,
            range: range,
            duration: d,
            indexRange: null,
            timescale: timescale,
            media: media
          };
          segments.push(new __WEBPACK_IMPORTED_MODULE_0__segment_js__["a" /* default */](_args));
        } else {
          continue loop;
        }
      }

      break;
    }

    return segments;
  },


  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * @param {Object} index
   * @param {Number} time
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */
  shouldRefresh: function shouldRefresh(index, time, up, to) {
    var timeline = index.timeline,
        timescale = index.timescale,
        _index$presentationTi = index.presentationTimeOffset,
        presentationTimeOffset = _index$presentationTi === undefined ? 0 : _index$presentationTi;


    var scaledTo = to * timescale - presentationTimeOffset;

    var last = timeline[timeline.length - 1];
    if (!last) {
      return false;
    }

    if (last.d < 0) {
      last = { ts: last.ts, d: 0, r: last.r };
    }

    return !(scaledTo <= __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(last));
  },


  /**
   * Returns first position in index.
   * @param {Object} index
   * @returns {Number}
   */
  getFirstPosition: function getFirstPosition(index) {
    if (!index.timeline.length) {
      return undefined;
    }
    return index.timeline[0].ts / index.timescale;
  },


  /**
   * Returns last position in index.
   * @param {Object} index
   * @returns {Number}
   */
  getLastPosition: function getLastPosition(index) {
    if (!index.timeline.length) {
      return undefined;
    }
    var lastTimelineElement = index.timeline[index.timeline.length - 1];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(lastTimelineElement) / index.timescale;
  },


  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Object} index
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting ts
   * for the next (discontinuited) range. If not this is equal to -1.
   */
  checkDiscontinuity: function checkDiscontinuity(index, _time) {
    var timeline = index.timeline,
        _index$timescale = index.timescale,
        timescale = _index$timescale === undefined ? 1 : _index$timescale;

    var time = _time * timescale;

    if (time <= 0) {
      return -1;
    }

    var segmentIndex = getSegmentIndex(index, time);
    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return -1;
    }

    var range = timeline[segmentIndex];
    if (range.d === -1) {
      return -1;
    }

    var rangeUp = range.ts;
    var rangeTo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(range);
    var nextRange = timeline[segmentIndex + 1];

    // when we are actually inside the found range and this range has
    // an explicit discontinuity with the next one
    if (rangeTo !== nextRange.ts && time >= rangeUp && time <= rangeTo && rangeTo - time < timescale) {
      return nextRange.ts / timescale;
    }

    return -1;
  },


  /**
   * Add a new segment to the index.
   *
   * /!\ Mutate the given index
   * @param {Object} index
   * @param {Object} newSegment
   * @param {Number} newSegment.timescale
   * @param {Number} newSegment.time
   * @param {Number} newSegment.duration
   * @param {Object} currentSegment
   * @param {Number} currentSegment.timescale
   * @param {Number} currentSegment.time
   * @returns {Boolean} - true if the segment has been added
   */
  _addSegmentInfos: function _addSegmentInfos(index, newSegment, currentSegment) {
    var timeline = index.timeline,
        timescale = index.timescale;

    var timelineLength = timeline.length;
    var last = timeline[timelineLength - 1];

    var scaledNewSegment = newSegment.timescale === timescale ? {
      time: newSegment.time,
      duration: newSegment.duration
    } : {
      time: newSegment.time / newSegment.timescale * timescale,
      duration: newSegment.duration / newSegment.timescale * timescale
    };

    var scaledCurrentTime = void 0;

    if (currentSegment) {
      scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale;
    }

    // in some circumstances, the new segment informations are only
    // duration informations that we can use to deduct the ts of the
    // next segment. this is the case where the new segment are
    // associated to a current segment and have the same ts
    var shouldDeductNextSegment = scaledCurrentTime != null && scaledNewSegment.time === scaledCurrentTime;
    if (shouldDeductNextSegment) {
      var newSegmentTs = scaledNewSegment.time + scaledNewSegment.duration;
      var lastSegmentTs = last.ts + last.d * last.r;
      var tsDiff = newSegmentTs - lastSegmentTs;

      if (tsDiff <= 0) {
        // same segment / behind the last
        return false;
      }

      // try to use the compact notation with @r attribute on the last
      // to elements of the timeline if we find out they have the same
      // duration
      if (last.d === -1) {
        var prev = timeline[timelineLength - 2];
        if (prev && prev.d === tsDiff) {
          prev.r++;
          timeline.pop();
        } else {
          last.d = tsDiff;
        }
      }

      index.timeline.push({
        d: -1,
        ts: newSegmentTs,
        r: 0
      });
      return true;
    }

    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    else if (scaledNewSegment.time >= __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(last)) {
        if (last.d === scaledNewSegment.duration) {
          last.r++;
        } else {
          index.timeline.push({
            d: scaledNewSegment.duration,
            ts: scaledNewSegment.time,
            r: 0
          });
        }
        return true;
      }

    return false;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (SegmentTimelineHelpers);

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_request__ = __webpack_require__(160);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function mapRequestResponses(_ref) {
  var type = _ref.type,
      value = _ref.value;

  if (type === "response") {
    return {
      type: "response",
      value: {
        responseData: value.responseData,
        size: value.size,
        duration: value.receivedTime - value.sentTime,
        url: value.url
      }
    };
  }

  return {
    type: "progress",
    value: {
      size: value.loadedSize,
      totalSize: value.totalSize,
      duration: value.currentTime - value.sentTime,
      url: value.url
    }
  };
}

function doParsedRequest(requestData) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_request__["a" /* default */])(requestData).map(mapRequestResponses);
}

/* harmony default export */ __webpack_exports__["a"] = (doParsedRequest);

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export pad */
/* unused harmony export processFormatedToken */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return replaceTokens; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isMP4EmbeddedTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return byteRange; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */
function pad(n, l) {
  n = n.toString();
  if (n.length >= l) {
    return n;
  }
  var arr = new Array(l + 1).join("0") + n;
  return arr.slice(-l);
}

/**
 * Add formatting when asked in a token (add padding to numbers).
 * @param {string|Number} replacer - the token value
 * @returns {Function} - @see replaceTokens
 */
function processFormatedToken(replacer) {
  return function (match, format, widthStr) {
    var width = widthStr ? parseInt(widthStr, 10) : 1;
    return pad("" + replacer, width);
  };
}

/**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {Segment} segment
 * @returns {string}
 */
function replaceTokens(path, segment, representation) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, representation.id).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(representation.bitrate)).replace(/\$Number(|\%0(\d+)d)\$/g, processFormatedToken(segment.number)).replace(/\$Time(|\%0(\d+)d)\$/g, processFormatedToken(segment.time));
  }
}

/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Segment} segment - __TextTrack__ segment
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
  return representation.mimeType === "application/mp4";
}

/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>}
 * @returns {string}
 */
function byteRange(_ref) {
  var start = _ref[0],
      end = _ref[1];

  if (!end || end === Infinity) {
    return "bytes=" + +start + "-";
  } else {
    return "bytes=" + +start + "-" + +end;
  }
}



/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_bytes__ = __webpack_require__(84);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */
var SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */
var boxNamesMem = {};

/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
function boxName(str) {
  if (boxNamesMem[str]) {
    return boxNamesMem[str];
  }

  var nameInBytes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(str);
  boxNamesMem[str] = nameInBytes;
  return nameInBytes;
}

/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */
function Atom(name, buff) {
  if (true) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(name.length === 4);
  }

  var len = buff.length + 8;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(len), boxName(name), buff);
}

function readUuid(buf, id1, id2, id3, id4) {
  var l = buf.length;
  var i = 0,
      len = void 0;
  while (i < l) {
    len = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i);
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 4) === 0x75756964 /* === "uuid" */ && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 8) === id1 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 12) === id2 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 16) === id3 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 20) === id4) {
      return buf.subarray(i + 24, i + len);
    }
    i += len;
  }
}

function findAtom(buf, atomName) {
  var l = buf.length;
  var i = 0;

  var name = void 0,
      size = void 0;
  while (i + 8 < l) {
    size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i);
    name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(buf, i + 4);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(size > 0, "smooth: out of range size");
    if (name === atomName) {
      break;
    } else {
      i += size;
    }
  }

  if (i < l) {
    return buf.subarray(i + 8, i + size);
  } else {
    return null;
  }
}

var atoms = {
  mult: function mult(name, children) {
    return Atom(name, __WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */].apply(null, children));
  },


  /**
   * @param {string} name - "avc1" or "encv"
   * @param {Number} drefIdx - shall be 1
   * @param {Number} width
   * @param {Number} height
   * @param {Number} hRes - horizontal resolution, eg 72
   * @param {Number} vRes - horizontal resolution, eg 72
   * @param {Number} colorDepth - eg 24
   * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
   * @param {Uint8Array} sinf - Uint8Array representing the sinf atom,
   * only if name == "encv"
   */
  avc1encv: function avc1encv(name, drefIdx, width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(name === "avc1" || name === "encv", "should be avc1 or encv atom");
    }
    return Atom(name, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(6, // 6 bytes reserved
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(drefIdx), 16, // drefIdx + QuickTime reserved, zeroes
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(width), // size 2 w
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(height), // size 2 h
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(hRes), 2, // reso 4 h
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
    [0, 1, encName.length], // frame count (default 1)
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(encName), // 1byte len + encoder name str
    31 - encName.length, // + padding
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(colorDepth), // color depth
    [0xFF, 0xFF], // reserved ones
    avcc, // avcc atom,
    name === "encv" ? sinf : []));
  },


  /**
   * @param {string} spsHex
   * @param {string} ppsHex
   * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
   * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
   * 1, "68ef3880")
   */
  avcc: function avcc(sps, pps, nalLen) {
    var nal = nalLen === 2 ? 0x1 : nalLen === 4 ? 0x3 : 0x0;

    // Deduce AVC Profile from SPS
    var h264Profile = sps[1];
    var h264CompatibleProfile = sps[2];
    var h264Level = sps[3];

    return Atom("avcC", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])([1, h264Profile, h264CompatibleProfile, h264Level, 0x3F << 2 | nal, 0xE0 | 1], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(sps.length), sps, [1], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(pps.length), pps));
  },
  dref: function dref(url) {
    // only one description here... FIXME
    return Atom("dref", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(7, [1], url));
  },


  /**
   * @param {Number} stream
   * @param {string} codecPrivateData - hex string
   * eg: esds(1, 98800, "1190")
   */
  esds: function esds(stream, codecPrivateData) {
    return Atom("esds", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(4, [0x03, 0x19], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(codecPrivateData), [0x06, 0x01, 0x02]));
  },


  /**
   * @param {string} dataFormat - four letters (eg "avc1")
   */
  frma: function frma(dataFormat) {
    if (true) {
      __WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */].equal(dataFormat.length, 4, "wrong data format length");
    }
    return Atom("frma", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(dataFormat));
  },
  free: function free(length) {
    return Atom("free", new Uint8Array(length - 8));
  },
  ftyp: function ftyp(majorBrand, brands) {
    return Atom("ftyp", __WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */].apply(null, [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(majorBrand), [0, 0, 0, 1]].concat(brands.map(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */]))));
  },


  /**
   * @param {string} type - "video" or "audio"
   */
  hdlr: function hdlr(type) {
    var name = void 0,
        handlerName = void 0;

    switch (type) {
      case "video":
        name = "vide";
        handlerName = "VideoHandler";
        break;
      case "audio":
        name = "soun";
        handlerName = "SoundHandler";
        break;
      default:
        name = "hint";
        handlerName = "";
        break;
    }

    return Atom("hdlr", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(8, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(name), 12, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(handlerName), 1 // handler name is C-style string (0 terminated)
    ));
  },
  mdhd: function mdhd(timescale) {
    return Atom("mdhd", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(12, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(timescale), 8));
  },
  moof: function moof(mfhd, traf) {
    return atoms.mult("moof", [mfhd, traf]);
  },


  /**
   * @param {string} name - "mp4a" or "enca"
   * @param {Number} drefIdx
   * @param {Number} channelsCount
   * @param {Number} sampleSize
   * @param {Number} packetSize
   * @param {Number} sampleRate
   * @param {Uint8Array} esds - Uint8Array representing the esds atom
   * @param {Uint8Array} sinf Uint8Array representing the sinf atom,
   * only if name == "enca"
   */
  mp4aenca: function mp4aenca(name, drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
    return Atom(name, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(6, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(drefIdx), 8, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(channelsCount), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(sampleSize), 2, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(packetSize), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(sampleRate), 2, esds, name === "enca" ? sinf : []));
  },
  mvhd: function mvhd(timescale, trackId) {
    return Atom("mvhd", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(12, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(timescale), 4, [0, 1], 2, // we assume rate = 1;
    [1, 0], 10, // we assume volume = 100%;
    [0, 1], 14, // default matrix
    [0, 1], 14, // default matrix
    [64, 0, 0, 0], 26, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(trackId + 1) // next trackId (=trackId + 1);
    ));
  },


  /**
   * @param {string} systemId - Hex string representing the CDM, 16 bytes.
   * @param {Uint8Array} privateData - Data associated to protection specific
   * system.
   * @param {[]Uint8Array} keyIds - List of key ids contained in the PSSH
   */
  pssh: function pssh(systemId) {
    var privateData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var keyIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    systemId = systemId.replace(/-/g, "");

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(systemId.length === 32, "wrong system id length");

    var version = void 0;
    var kidList = void 0;
    var kidCount = keyIds.length;
    if (kidCount > 0) {
      version = 1;
      kidList = __WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */].apply(null, [__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(kidCount)].concat(keyIds));
    } else {
      version = 0;
      kidList = [];
    }

    return Atom("pssh", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])([version, 0, 0, 0], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(systemId), kidList, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(privateData.length), privateData));
  },
  saio: function saio(mfhd, tfhd, tfdt, trun) {
    return Atom("saio", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(4, [0, 0, 0, 1], // ??
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
  },


  /**
   * @param {Uint8Array} sencData - including 8 bytes flags and entries count
   */
  saiz: function saiz(senc) {
    if (senc.length === 0) {
      return Atom("saiz", new Uint8Array());
    }

    var flags = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(senc, 0);
    var entries = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(senc, 4);

    var arr = new Uint8Array(9 + entries);
    arr.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(entries), 5);

    var i = 9;
    var j = 8;
    var pairsCnt = void 0;
    var pairsLen = void 0;
    while (j < senc.length) {
      j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
      // if we have extradata for each entry
      if ((flags & 0x2) === 0x2) {
        pairsLen = 2;
        pairsCnt = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["g" /* be2toi */])(senc, j);
        j += 2 + pairsCnt * 6;
      } else {
        pairsCnt = 0;
        pairsLen = 0;
      }
      arr[i] = pairsCnt * 6 + 8 + pairsLen;
      i++;
    }

    return Atom("saiz", arr);
  },


  /**
   * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
   * @param {Number} schemeVersion - eg 65536
   */
  schm: function schm(schemeType, schemeVersion) {
    if (true) {
      __WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */].equal(schemeType.length, 4, "wrong scheme type length");
    }
    return Atom("schm", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(4, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(schemeType), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(schemeVersion)));
  },
  senc: function senc(buf) {
    return Atom("senc", buf);
  },
  smhd: function smhd() {
    return Atom("smhd", new Uint8Array(8));
  },


  /**
   * @param {Array} representations - arrays of Uint8Array, typically [avc1]
   * or [encv, avc1]
   * @returns {Uint8Array}
   */
  stsd: function stsd(reps) {
    // only one description here... FIXME
    return Atom("stsd", __WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */].apply(null, [7, [reps.length]].concat(reps)));
  },
  tkhd: function tkhd(width, height, trackId) {
    return Atom("tkhd", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(1 + 2 + 4), 8, // we assume track is enabled,
    // in media and in preview.
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(trackId), 20, // we assume trackId = 1;
    [1, 0, 0, 0], // we assume volume = 100%;
    [0, 1, 0, 0], 12, // default matrix
    [0, 1, 0, 0], 12, // default matrix
    [64, 0, 0, 0], // ??
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(width), 2, // width (TODO handle fixed)
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(height), 2 // height (TODO handle fixed)
    ));
  },
  trex: function trex(trackId) {
    // default sample desc idx = 1
    return Atom("trex", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(4, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(trackId), [0, 0, 0, 1], 12));
  },
  tfdt: function tfdt(decodeTime) {
    return Atom("tfdt", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])([1, 0, 0, 0], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["o" /* itobe8 */])(decodeTime)));
  },


  /**
   * @param {Number} algId - eg 1
   * @param {Number} ivSize - eg 8
   * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
   */
  tenc: function tenc(algId, ivSize, keyId) {
    if (true) {
      __WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */].equal(keyId.length, 32, "wrong default KID length");
    }
    return Atom("tenc", __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(6, [algId, ivSize], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(keyId)));
  },
  traf: function traf(tfhd, tfdt, trun, senc, mfhd) {
    var trafs = [tfhd, tfdt, trun];
    if (senc) {
      trafs.push(atoms.senc(senc), atoms.saiz(senc), atoms.saio(mfhd, tfhd, tfdt, trun));
    }
    return atoms.mult("traf", trafs);
  },
  trun: function trun(oldtrun) {
    var headersLast = oldtrun[11];
    var hasDataOffset = headersLast & 0x01;
    if (hasDataOffset) {
      return oldtrun;
    }

    // If no dataoffset is present, we change the headers and add one
    var trun = new Uint8Array(oldtrun.length + 4);
    trun.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(oldtrun.length + 4), 0);
    trun.set(oldtrun.subarray(4, 16), 4); // name + (version + headers) +
    // samplecount
    trun[11] = trun[11] | 0x01; // add data offset header info
    trun.set([0, 0, 0, 0], 16); // data offset
    trun.set(oldtrun.subarray(16, oldtrun.length), 20);
    return trun;
  },
  vmhd: function vmhd() {
    var arr = new Uint8Array(12);
    arr[3] = 1; // QuickTime...
    return Atom("vmhd", arr);
  }
};

var reads = {
  traf: function traf(buff) {
    var moof = findAtom(buff, 0x6D6F6F66);
    if (moof) {
      return findAtom(moof, 0x74726166);
    } else {
      return null;
    }
  },


  /**
   * Extract senc data (derived from UUID MS Atom)
   * @param {Uint8Array} traf
   */
  senc: function senc(traf) {
    return readUuid(traf, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
  },


  /**
   * Extract tfxd data (derived from UUID MS Atom)
   * @param {Uint8Array} traf
   */
  tfxd: function tfxd(traf) {
    return readUuid(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);
  },


  /**
   * Extract tfrf data (derived from UUID MS Atom)
   * @param {Uint8Array} traf
   */
  tfrf: function tfrf(traf) {
    return readUuid(traf, 0xD4807EF2, 0XCA394695, 0X8E5426CB, 0X9E46A79F);
  },
  mdat: function mdat(buff) {
    return findAtom(buff, 0x6D646174 /* "mdat" */);
  }
};

/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 */
function aacesHeader(type, frequency, chans) {
  var freq = SAMPLING_FREQUENCIES.indexOf(frequency);
  if (true) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(freq >= 0, "non supported frequency"); // TODO : handle Idx = 15...
  }
  var val = void 0;
  val = (type & 0x3F) << 0x4;
  val = (val | freq & 0x1F) << 0x4;
  val = (val | chans & 0x1F) << 0x3;
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["p" /* bytesToHex */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["n" /* itobe2 */])(val));
}

function moovChildren(mvhd, mvex, trak, pssList) {
  var moov = [mvhd, mvex, trak];
  pssList.forEach(function (pss) {
    var pssh = atoms.pssh(pss.systemId, pss.privateData, pss.keyIds);
    moov.push(pssh);
  });
  return moov;
}

function patchTrunDataOffset(segment, trunoffset, dataOffset) {
  // patch trun dataoffset with new moof atom size
  segment.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["j" /* itobe4 */])(dataOffset), trunoffset + 16);
}

function createNewSegment(segment, newmoof, oldmoof, trunoffset) {
  var segmentlen = segment.length;
  var newmooflen = newmoof.length;
  var oldmooflen = oldmoof.length;
  var mdat = segment.subarray(oldmooflen, segmentlen);
  var newSegment = new Uint8Array(newmooflen + (segmentlen - oldmooflen));
  newSegment.set(newmoof, 0);
  newSegment.set(mdat, newmooflen);
  patchTrunDataOffset(newSegment, trunoffset, newmoof.length + 8);
  return newSegment;
}

function patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset) {
  var free = oldmoof.length - newmoof.length;
  segment.set(newmoof, 0);
  segment.set(atoms.free(free), newmoof.length);
  patchTrunDataOffset(segment, trunoffset, newmoof.length + 8 + free);
  return segment;
}

/**
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {

  var stbl = atoms.mult("stbl", [stsd, Atom("stts", new Uint8Array(0x08)), Atom("stsc", new Uint8Array(0x08)), Atom("stsz", new Uint8Array(0x0c)), Atom("stco", new Uint8Array(0x08))]);

  var url = Atom("url ", new Uint8Array([0, 0, 0, 1]));
  var dref = atoms.dref(url);
  var dinf = atoms.mult("dinf", [dref]);
  var minf = atoms.mult("minf", [mhd, dinf, stbl]);
  var hdlr = atoms.hdlr(type);
  var mdhd = atoms.mdhd(timescale); //this one is really important
  var mdia = atoms.mult("mdia", [mdhd, hdlr, minf]);
  var tkhd = atoms.tkhd(width, height, 1);
  var trak = atoms.mult("trak", [tkhd, mdia]);
  var trex = atoms.trex(1);
  var mvex = atoms.mult("mvex", [trex]);
  var mvhd = atoms.mvhd(timescale, 1); // in fact, we don't give a sh** about
  // this value :O

  var moov = atoms.mult("moov", moovChildren(mvhd, mvex, trak, pssList));
  var ftyp = atoms.ftyp("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])(ftyp, moov);
}

// TODO
/* harmony default export */ __webpack_exports__["a"] = ({
  getMdat: reads.mdat,
  getTraf: reads.traf,

  parseTfrf: function parseTfrf(traf) {
    var tfrf = reads.tfrf(traf);
    if (!tfrf) {
      return [];
    }

    var frags = [];
    var version = tfrf[0];
    var fragCount = tfrf[4];
    for (var i = 0; i < fragCount; i++) {
      var duration = void 0,
          time = void 0;
      if (version == 1) {
        time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["f" /* be8toi */])(tfrf, 16 * i + 5);
        duration = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["f" /* be8toi */])(tfrf, 16 * i + 5 + 8);
      } else {
        time = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(tfrf, 8 * i + 5);
        duration = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(tfrf, 8 * i + 5 + 4);
      }
      frags.push({
        time: time,
        duration: duration
      });
    }
    return frags;
  },
  parseTfxd: function parseTfxd(traf) {
    var tfxd = reads.tfxd(traf);
    if (tfxd) {
      return {
        duration: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["f" /* be8toi */])(tfxd, 12),
        time: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["f" /* be8toi */])(tfxd, 4)
      };
    }
  },


  /**
   * Return full Init segment as Uint8Array
   *
   * @param {Number} timescale - lowest number, this one will be set into mdhd
   * *10000 in mvhd, e.g. 1000
   * @param {Number} width
   * @param {Number} height
   * @param {Number} hRes
   * @param {Number} vRes
   * @param {Number} nalLength (1, 2 or 4)
   * @param {string} codecPrivateData
   * @param {string} keyId - hex string representing the key Id,
   * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
   * @param {Array.<Object>} [pssList] - List of dict, example:
   * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
   * @returns {Uint8Array}
   */
  createVideoInitSegment: function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {

    if (!pssList) {
      pssList = [];
    }

    var _codecPrivateData$spl = codecPrivateData.split("00000001"),
        spsHex = _codecPrivateData$spl[1],
        ppsHex = _codecPrivateData$spl[2];

    var sps = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(spsHex);
    var pps = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(ppsHex);

    // TODO NAL length is forced to 4
    var avcc = atoms.avcc(sps, pps, nalLength);
    var stsd = void 0;
    if (!pssList.length) {
      var avc1 = atoms.avc1encv("avc1", // name
      1, // drefIdx
      width, height, hRes, vRes, "AVC Coding", // encName
      24, // color depth
      avcc);
      stsd = atoms.stsd([avc1]);
    } else {
      var tenc = atoms.tenc(1, 8, keyId);
      var schi = atoms.mult("schi", [tenc]);
      var schm = atoms.schm("cenc", 65536);
      var frma = atoms.frma("avc1");
      var sinf = atoms.mult("sinf", [frma, schm, schi]);
      var encv = atoms.avc1encv("encv", 1, width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
      stsd = atoms.stsd([encv]);
    }

    return createInitSegment(timescale, "video", stsd, atoms.vmhd(), width, height, pssList);
  },


  /**
   * Return full Init segment as Uint8Array
   *
   * @param {Number} channelsCount
   * @param {Number} sampleSize
   * @param {Number} packetSize
   * @param {Number} sampleRate
   * @param {string} codecPrivateData
   * @param {Array } [pssList] - List of dict, example:
   * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF"}
   * @param {string} keyId - hex string representing the key Id, 32 chars.
   * eg. a800dbed49c12c4cb8e0b25643844b9b
   * @returns {Uint8Array}
   */
  createAudioInitSegment: function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {

    if (!pssList) {
      pssList = [];
    }
    if (!codecPrivateData) {
      codecPrivateData = aacesHeader(2, sampleRate, channelsCount);
    }

    var esds = atoms.esds(1, codecPrivateData);
    var stsd = void 0;
    if (!pssList.length) {
      var mp4a = atoms.mp4aenca("mp4a", 1, channelsCount, sampleSize, packetSize, sampleRate, esds);
      stsd = atoms.stsd([mp4a]);
    } else {
      var tenc = atoms.tenc(1, 8, keyId);
      var schi = atoms.mult("schi", [tenc]);
      var schm = atoms.schm("cenc", 65536);
      var frma = atoms.frma("mp4a");
      var sinf = atoms.mult("sinf", [frma, schm, schi]);
      var enca = atoms.mp4aenca("enca", 1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
      stsd = atoms.stsd([enca]);
    }

    return createInitSegment(timescale, "audio", stsd, atoms.smhd(), 0, 0, pssList);
  },


  /**
   * Add decodeTime info in a segment (tfdt box)
   */
  patchSegment: function patchSegment(segment, decodeTime) {
    if (true) {
      // TODO handle segments with styp/free...
      var name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["a" /* bytesToStr */])(segment.subarray(4, 8));
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(name === "moof");
    }

    var oldmoof = segment.subarray(0, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(segment, 0));
    var newtfdt = atoms.tfdt(decodeTime);

    // reads [moof[mfhd|traf[tfhd|trun|..]]]
    var tfdtlen = newtfdt.length;
    var mfhdlen = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(oldmoof, 8);
    var traflen = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(oldmoof, 8 + mfhdlen);
    var tfhdlen = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(oldmoof, 8 + mfhdlen + 8);
    var trunlen = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["e" /* be4toi */])(oldmoof, 8 + mfhdlen + 8 + tfhdlen);
    var oldmfhd = oldmoof.subarray(8, 8 + mfhdlen);
    var oldtraf = oldmoof.subarray(8 + mfhdlen + 8, 8 + mfhdlen + 8 + traflen - 8);
    var oldtfhd = oldtraf.subarray(0, tfhdlen);
    var oldtrun = oldtraf.subarray(tfhdlen, tfhdlen + trunlen);

    // force trackId=1 since trackIds are not always reliable...
    oldtfhd.set([0, 0, 0, 1], 12);

    var oldsenc = reads.senc(oldtraf);

    // writes [moof[mfhd|traf[tfhd|tfdt|trun|senc|saiz|saio]]]
    var newtrun = atoms.trun(oldtrun);
    var newtraf = atoms.traf(oldtfhd, newtfdt, newtrun, oldsenc, oldmfhd);
    var newmoof = atoms.moof(oldmfhd, newtraf);

    var trunoffset = 8 + mfhdlen + 8 + tfhdlen + tfdtlen;
    // TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
    // try to put free atom inside traf children
    if (__WEBPACK_IMPORTED_MODULE_0__compat__["r" /* isIE */]) {
      return createNewSegment(segment, newmoof, oldmoof, trunoffset);
    } else {
      if (oldmoof.length - newmoof.length >= 8 /* minimum "free" atom size */) {
          return patchSegmentInPlace(segment, newmoof, oldmoof, trunoffset);
        } else {
        return createNewSegment(segment, newmoof, oldmoof, trunoffset);
      }
    }
  }
});

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getParentElementsByTagName;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
  if (!(element.parentNode instanceof Element)) {
    return [];
  }

  function constructArray(_element) {
    var elements = [];
    if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
      elements.push(_element);
    }

    var parentNode = _element.parentNode;
    if (parentNode instanceof Element) {
      elements.push.apply(elements, constructArray(parentNode));
    }

    return elements;
  }
  return constructArray(element.parentNode);
}

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REGXP_PERCENT_VALUES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return REGXP_TIME_COLON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REGXP_TIME_COLON_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return REGXP_TIME_COLON_MS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return REGXP_TIME_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return REGXP_TIME_HMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return REGXP_TIME_TICK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return REGXP_4_HEX_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return REGXP_8_HEX_COLOR; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;

/**
 * @type {RegExp}
 * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
 */
var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;

/**
 * @type {RegExp}
 * @example 01:02:43.0345555 or 02:43.03
 */
var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;

/**
 * @type {RegExp}
 * @example 75f or 75.5f
 */
var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;

/**
 * @type {RegExp}
 * @example 50t or 50.5t
 */
var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;

/**
 * @type {RegExp}
 * @example 3.45h, 3m or 4.20s
 */
var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;

/**
 * @type {RegExp}
 * @example 50% 10%
 */
var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;

var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;



/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getStylingAttributes;
/* harmony export (immutable) */ __webpack_exports__["a"] = getStylingFromElement;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__ = __webpack_require__(44);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retrieve the attributes given in arguments in the given elements and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given elements in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Element>} elements
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
function getStylingAttributes(attributes, elements, styles, regions) {
  var currentStyle = {};
  var leftAttributes = attributes.slice();
  for (var i = 0; i <= elements.length - 1; i++) {
    var element = elements[i];
    if (element) {
      var _ret = function () {
        var styleID = undefined;
        var regionID = undefined;

        // 1. the style is directly set on a "tts:" attribute
        for (var _i = 0; _i <= element.attributes.length - 1; _i++) {
          var attribute = element.attributes[_i];
          var name = attribute.name;
          if (name === "style") {
            styleID = attribute.value;
          } else if (name === "region") {
            regionID = attribute.value;
          } else {
            var nameWithoutTTS = name.substr(4);
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__["a" /* default */])(leftAttributes, nameWithoutTTS)) {
              currentStyle[attribute.name] = attribute.value;
              leftAttributes.splice(_i, 1);
              if (!leftAttributes.length) {
                return {
                  v: currentStyle
                };
              }
            }
          }
        }

        // 2. the style is referenced on a "style" attribute
        if (styleID) {
          var style = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(styles, function (x) {
            return x.id === styleID;
          });
          if (style) {
            for (var _i2 = 0; _i2 <= leftAttributes.length - 1; _i2++) {
              var _attribute = leftAttributes[_i2];
              if (!currentStyle[_attribute]) {
                if (style.style[_attribute]) {
                  currentStyle[_attribute] = style.style[_attribute];
                  leftAttributes.splice(_i2, 1);
                  if (!leftAttributes.length) {
                    return {
                      v: currentStyle
                    };
                  }
                  _i2--;
                }
              }
            }
          }
        }

        // 3. the element reference a region (which can have a value for the
        //    corresponding style)
        if (regionID) {
          var region = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(regions, function (x) {
            return x.id === regionID;
          });
          if (region) {
            for (var _i3 = 0; _i3 <= leftAttributes.length - 1; _i3++) {
              var _attribute2 = leftAttributes[_i3];
              if (!currentStyle[_attribute2]) {
                if (region.style[_attribute2]) {
                  currentStyle[_attribute2] = region.style[_attribute2];
                  leftAttributes.splice(_i3, 1);
                  if (!leftAttributes.length) {
                    return {
                      v: currentStyle
                    };
                  }
                  _i3--;
                }
              }
            }
          }
        }
      }();

      if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    }
  }
  return currentStyle;
}

/**
 * Returns the styling directly linked to an element.
 * @param {Element} element
 * @returns {Object}
 */
function getStylingFromElement(element) {
  var currentStyle = {};
  for (var i = 0; i <= element.attributes.length - 1; i++) {
    var styleAttribute = element.attributes[i];
    if (styleAttribute.name.startsWith("tts")) {
      var nameWithoutTTS = styleAttribute.name.substr(4);
      currentStyle[nameWithoutTTS] = styleAttribute.value;
    }
  }
  return currentStyle;
}

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var _lastId = 0;

var generateNewId = function generateNewId() {
  var newId = 0;
  if (_lastId < Number.MAX_VALUE) {
    newId = _lastId + 1;
  }
  _lastId = newId;
  return "" + newId;
};

/* harmony default export */ __webpack_exports__["a"] = (generateNewId);

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(43);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var toJSONForIE = function toJSONForIE(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
};

/**
 * # request function
 *
 * Translate AJAX Requests into Rx.js Observables.
 *
 * ## Overview
 *
 * Perform the request on subscription, the Rx.js way.
 * Emit progress and response. Throw if an error happened or if the status code
 * is not in the 200 range. Complete after emitting the response.
 * Abort the xhr on unsubscription.
 *
 * ## Emitted Objects
 *
 * The emitted objects are under the following form:
 *   {
 *     type {string}: the type of event
 *     value {Object}: the event value
 *   }
 *
 * The type of event can either be "progress" or "response". The value is under
 * a different form depending on the type.
 *
 * For "progress" events, the value should be the following object:
 *   {
 *     url {string}: url on which the request is being done
 *     sentTime {Number}: timestamp at which the request was sent.
 *     currentTime {Number}: timestamp at which the progress event was
 *                           triggered
 *     loadedSize {Number}: current size downloaded, in bytes (without
 *                          overhead)
 *     totalSize {Number|undefined}: total size to download, in bytes
 *                                   (without overhead)
 *   }
 *
 * For "response" events, the value should be the following object:
 *   {
 *     status {Number}: xhr status code
 *     url {string}: url on which the request was done
 *     responseType {string}: the responseType of the request
 *                            (e.g. "json", "document"...)
 *     sentTime {Number}: timestamp at which the request was sent.
 *     receivedTime {Number}: timestamp at which the response was received.
 *     size {Number}: size of the received data, in bytes
 *     responseData {*}: Data in the response. Format depends on the
 *                       responseType.
 *   }
 *
 * For any succesful request you should have 0+ "progress" events and 1
 * "response" event.
 *
 * ## Errors
 *
 * Several errors can be emitted (the Rx.js way). Namely:
 *   - timeout error (code RequestErrorTypes.TIMEOUT_ERROR)
 *   - parse error (code RequestErrorTypes.PARSE_ERROR)
 *   - http code error (RequestErrorTypes.ERROR_HTTP_CODE)
 *   - error from the xhr's "error" event (RequestErrorTypes.ERROR_EVENT)
 *
 * @param {Object} options
 * @param {string} options.url
 * @param {Object} [options.headers]
 * @param {string} [options.method="GET"]
 * @param {string} [options.responseType="json"]
 * @param {Number} [options.timeout=30000]
 * @param {Boolean} [options.ignoreProgressEvents]
 * @param {*} [options.body]
 *
 * @returns {Observable}
 */

/* harmony default export */ __webpack_exports__["a"] = (function (options) {
  var request = {
    url: "",
    headers: null,
    method: "GET",
    responseType: "json",
    timeout: 30 * 1000,
    body: undefined
  };

  for (var prop in request) {
    if (options.hasOwnProperty(prop)) {
      request[prop] = options[prop];
    }
  }

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
    var url = request.url,
        headers = request.headers,
        method = request.method,
        responseType = request.responseType,
        timeout = request.timeout,
        body = request.body;

    var xhr = new XMLHttpRequest();
    xhr.open(method, url, true);

    if (timeout >= 0) {
      xhr.timeout = timeout;
    }

    xhr.responseType = responseType;

    if (xhr.responseType === "document") {
      xhr.overrideMimeType("text/xml");
    }

    if (headers) {
      for (var key in headers) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }

    var sentTime = Date.now();

    xhr.onerror = function onXHRError() {
      var errorCode = __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].ERROR_EVENT;
      obs.error(new __WEBPACK_IMPORTED_MODULE_1__errors__["h" /* RequestError */](xhr, url, errorCode));
    };

    xhr.ontimeout = function onXHRTimeout() {
      var errorCode = __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].TIMEOUT;
      obs.error(new __WEBPACK_IMPORTED_MODULE_1__errors__["h" /* RequestError */](xhr, url, errorCode));
    };

    if (!options.ignoreProgressEvents) {
      xhr.onprogress = function onXHRProgress(event) {
        obs.next({
          type: "progress",
          value: {
            url: url,
            sentTime: sentTime,
            currentTime: Date.now(),
            loadedSize: event.loaded,
            totalSize: event.total
          }
        });
      };
    }

    xhr.onload = function onXHRLoad(event) {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          var receivedTime = Date.now();
          var totalSize = event.total;
          var status = xhr.status;
          var _responseType = xhr.responseType;
          var _url = xhr.responseURL || url;

          var responseData = void 0;
          if (_responseType === "json") {
            // IE bug where response is string with responseType json
            if (typeof xhr.response != "string") {
              responseData = xhr.response;
            } else {
              responseData = toJSONForIE(xhr.responseText);
            }
          } else {
            responseData = xhr.response;
          }

          if (responseData == null) {
            var errorCode = __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].PARSE_ERROR;
            obs.error(new __WEBPACK_IMPORTED_MODULE_1__errors__["h" /* RequestError */](xhr, _url, errorCode));
            return;
          }

          obs.next({
            type: "response",
            value: {
              status: status,
              url: _url,
              responseType: _responseType,
              sentTime: sentTime,
              receivedTime: receivedTime,
              size: totalSize,
              responseData: responseData
            }
          });
          obs.complete();
        } else {
          var _errorCode = __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].ERROR_HTTP_CODE;
          obs.error(new __WEBPACK_IMPORTED_MODULE_1__errors__["h" /* RequestError */](xhr, url, _errorCode));
        }
      }
    };

    if (body !== undefined) {
      xhr.send(body);
    } else {
      xhr.send();
    }

    return function () {
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
});

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = onEvent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns a fromEvent on the given element for the given event(s).
 * @param {Element}
 * @param {Array.<string>|string}
 * @returns {Observable}
 */
function onEvent(elt, evts) {
  if (Array.isArray(evts)) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge.apply(null, evts.map(function (evt) {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].fromEvent(elt, evt);
    }));
  } else {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].fromEvent(elt, evts);
  }
}

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = tryCatch;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */
function tryCatch(func, args) {
  try {
    return func(args);
  } catch (e) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].throw(e);
  }
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var combineLatest_1 = __webpack_require__(703);
Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var interval_1 = __webpack_require__(709);
Observable_1.Observable.interval = interval_1.interval;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var catch_1 = __webpack_require__(715);
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;
//# sourceMappingURL=catch.js.map

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var concat_1 = __webpack_require__(340);
Observable_1.Observable.prototype.concat = concat_1.concat;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var distinctUntilChanged_1 = __webpack_require__(720);
Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var do_1 = __webpack_require__(721);
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;
//# sourceMappingURL=do.js.map

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var filter_1 = __webpack_require__(722);
Observable_1.Observable.prototype.filter = filter_1.filter;
//# sourceMappingURL=filter.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var map_1 = __webpack_require__(725);
Observable_1.Observable.prototype.map = map_1.map;
//# sourceMappingURL=map.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var mergeMap_1 = __webpack_require__(342);
Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var skip_1 = __webpack_require__(731);
Observable_1.Observable.prototype.skip = skip_1.skip;
//# sourceMappingURL=skip.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var startWith_1 = __webpack_require__(732);
Observable_1.Observable.prototype.startWith = startWith_1.startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var switchMap_1 = __webpack_require__(733);
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var take_1 = __webpack_require__(735);
Observable_1.Observable.prototype.take = take_1.take;
//# sourceMappingURL=take.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var takeUntil_1 = __webpack_require__(736);
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/**
 * Simple select list. Call the onChange call back on choice with the index of
 * the option chosen in argument.
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      onChange = _ref.onChange,
      selected = _ref.selected,
      _ref$options = _ref.options,
      options = _ref$options === undefined ? [] : _ref$options,
      disabled = _ref.disabled;

  var optionsEl = options.map(function (val, index) {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "option",
      {
        key: index,
        value: index,
        selected: selected === index ? "selected" : ""
      },
      val
    );
  });

  var selectEl = disabled ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "select",
    { disabled: "disabled", onChange: onChange },
    optionsEl
  ) : __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "select",
    { onChange: onChange },
    optionsEl
  );

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "section",
    { className: "select " + className },
    selectEl
  );
});

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = tranlasteLanguageCode;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assets_languages_js__ = __webpack_require__(375);


function tranlasteLanguageCode(langCode) {
  if (!langCode) {
    return "unknown";
  }
  return __WEBPACK_IMPORTED_MODULE_0__assets_languages_js__["a" /* default */][langCode.toLowerCase()] || langCode;
}

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);



/**
 * Homemade redux and r9webapp-core inspired state management architecture.
 *
 * This function creates a new module (defined in the modules directory) and
 * give it the payload in argument.
 *
 * The module can send state updates at any time, through its state Object,
 * and returns an Object containing functions: the actions.
 *
 * The actions can then be called through the dispatch function returned here.
 *
 * As an example is simpler for everyone:
 * @example
 * ```js
 * // 1 - The module
 * const TodoList = ({ state }, { maxLength }) => {
 *   // initial state
 *   state.set({
 *     todos: [],
 *   });
 *
 *   let lastTodoId = 0;
 *   return {
 *
 *     // add a todo if max length is not yet reached
 *     ADD_TODO: function(text) {
 *       const currentTodos = state.get("todos");
 *       if (currentTodos.length >= maxLength) {
 *         return -1;
 *       }
 *
 *       const id = lastTodoId++;
 *
 *       // update state
 *       state.set({
 *         todos: [
 *           ...currentTodos,
 *           { id, text },
 *         ],
 *       });
 *
 *       // return id so it's easier to retrieve for the caller
 *       return id;
 *     },
 *
 *     // remove a todo thanks to its id
 *     REMOVE_TODO function(todoId) {
 *       const currentTodos = state.get("todos");
 *
 *       const index = currentTodos
 *        .findIndex(({ id }) => id === todoId);
 *
 *        if (index < 0) {
 *          // this can help the caller to realize that the todo did not exist
 *          return false;
 *        }
 *
 *        // cleaner to clone
 *        const todosClone = [ ...currentTodos ];
 *        todosClone.splice(index, 1);
 *
 *        state.set({
 *          todos: todosClone,
 *        });
 *        return true;
 *     },
 *   };
 * };
 *
 * // 2 - The interactions with it
 * const todoList = createModule(TodoList, { maxLength: 2 });
 *
 * // display todos when they change ($get is asynchronous, get is synchronous)
 * todoList.$get("todos")
 *   .subscribe(todos => {
 *     display(todos);
 *   });
 * console.log(todoList.get("todos").length); // 0
 *
 * const firstId = todoList.dispatch("ADD_TODO", "do something");
 * console.log(todoList.get("todos").length); // 1
 *
 * todoList.dispatch("ADD_TODO", "do another thing");
 * console.log(todoList.get("todos").length); // 2
 *
 * todoList.dispatch("ADD_TODO", "yet another");
 * console.log(todoList.get("todos").length); // still 2 - as it's the max
 *                                            // length set
 *
 * // remove the first todo created
 * todoList.dispatch("REMOVE_TODO", firstId);
 * console.log(todoList.get("todos").length); // back to 1
 *
 * todoList.destroy(); // cleanup and stop $get subscriptions
 * ```
 *
 * @param {Function} module
 * @param {*} payload
 * @returns {Object} - Object with the following functions:
 *
 *   - dispatch: call an action from the module. Takes the name of the action
 *     (a string) + an eventual payload in argument. Returns what the action
 *     returns.
 *
 *   - get: get the entire module state, or the property named after the
 *     argument (a string).
 *
 *   - $get: same as get, but returns an observable instead. Start emitting at
 *     the first change (I do not know yet if it's better to first emit the
 *     initial value immediately).
 *
 *   - destroy: destroy the module. Completes all subscriptions.
 */
var createModule = function createModule(module, payload) {
  if (typeof module !== "function") {
    throw new Error("A module should be a function");
  }

  var moduleState = {};
  var $destroy = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]();
  var $updates = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]().takeUntil($destroy);

  var getFromModule = function getFromModule() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!args.length) {
      return moduleState;
    }
    if (args.length === 1) {
      return moduleState[args[0]];
    }
    return args.map(function (arg) {
      return moduleState[arg];
    });
  };

  var $getFromModule = function $getFromModule() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (!args.length) {
      return $updates;
    }

    if (args.length === 1) {
      return $updates.map(function (state) {
        return state[args];
      }).distinctUntilChanged();
    }

    var observables = args.map(function (arg) {
      return $updates.map(function (state) {
        return state[arg];
      }).distinctUntilChanged();
    });

    return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].combineLatest.apply(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"], observables);
  };

  var moduleArgs = {
    state: {
      get: getFromModule,
      set: function set(arg) {
        var newState = Object.assign(moduleState, arg);
        $updates.next(newState);
      }
    },
    $destroy: $destroy
  };

  var moduleActions = module(moduleArgs, payload);

  return {
    dispatch: function dispatch(actionName, payload) {
      if (!moduleActions || typeof moduleActions[actionName] !== "function") {
        throw new Error("The " + actionName + " action does not exist on this module.");
      }
      return moduleActions[actionName](payload);
    },

    get: getFromModule,
    $get: $getFromModule,
    destroy: function destroy() {
      $destroy.next();
      $destroy.complete();
    }
  };
};



/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (arr, predicate, ctx) {
	if (typeof Array.prototype.findIndex === 'function') {
		return arr.findIndex(predicate, ctx);
	}

	if (typeof predicate !== 'function') {
		throw new TypeError('predicate must be a function');
	}

	var list = Object(arr);
	var len = list.length;

	if (len === 0) {
		return -1;
	}

	for (var i = 0; i < len; i++) {
		if (predicate.call(ctx, list[i], i, list)) {
			return i;
		}
	}

	return -1;
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @namespace Chart
 */
var Chart = __webpack_require__(425)();

Chart.helpers = __webpack_require__(4);

// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
__webpack_require__(424)(Chart);

Chart.defaults = __webpack_require__(9);
Chart.Element = __webpack_require__(31);
Chart.elements = __webpack_require__(46);
Chart.Interaction = __webpack_require__(182);
Chart.platform = __webpack_require__(183);

__webpack_require__(427)(Chart);
__webpack_require__(421)(Chart);
__webpack_require__(422)(Chart);
__webpack_require__(423)(Chart);
__webpack_require__(426)(Chart);
__webpack_require__(429)(Chart);
__webpack_require__(428)(Chart);
__webpack_require__(430)(Chart);

__webpack_require__(445)(Chart);
__webpack_require__(443)(Chart);
__webpack_require__(444)(Chart);
__webpack_require__(446)(Chart);
__webpack_require__(447)(Chart);
__webpack_require__(448)(Chart);

// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
__webpack_require__(414)(Chart);
__webpack_require__(415)(Chart);
__webpack_require__(416)(Chart);
__webpack_require__(417)(Chart);
__webpack_require__(418)(Chart);
__webpack_require__(419)(Chart);
__webpack_require__(420)(Chart);

__webpack_require__(407)(Chart);
__webpack_require__(408)(Chart);
__webpack_require__(409)(Chart);
__webpack_require__(410)(Chart);
__webpack_require__(411)(Chart);
__webpack_require__(412)(Chart);
__webpack_require__(413)(Chart);

// Loading built-it plugins
var plugins = [];

plugins.push(__webpack_require__(440)(Chart), __webpack_require__(441)(Chart), __webpack_require__(442)(Chart));

Chart.plugins.register(plugins);

Chart.platform.initialize();

module.exports = Chart;
if (typeof window !== 'undefined') {
  window.Chart = Chart;
}

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.canvas instead.
 * @namespace Chart.canvasHelpers
 * @deprecated since version 2.6.0
 * @todo remove at version 3
 * @private
 */
Chart.canvasHelpers = Chart.helpers.canvas;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);

/**
 * Helper function to get relative position for an event
 * @param {Event|IEvent} event - The event to get the position for
 * @param {Chart} chart - The chart
 * @returns {Point} the event position
 */
function getRelativePosition(e, chart) {
	if (e.native) {
		return {
			x: e.x,
			y: e.y
		};
	}

	return helpers.getRelativePosition(e, chart);
}

/**
 * Helper function to traverse all of the visible elements in the chart
 * @param chart {chart} the chart
 * @param handler {Function} the callback to execute for each visible item
 */
function parseVisibleItems(chart, handler) {
	var datasets = chart.data.datasets;
	var meta, i, j, ilen, jlen;

	for (i = 0, ilen = datasets.length; i < ilen; ++i) {
		if (!chart.isDatasetVisible(i)) {
			continue;
		}

		meta = chart.getDatasetMeta(i);
		for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
			var element = meta.data[j];
			if (!element._view.skip) {
				handler(element);
			}
		}
	}
}

/**
 * Helper function to get the items that intersect the event position
 * @param items {ChartElement[]} elements to filter
 * @param position {Point} the point to be nearest to
 * @return {ChartElement[]} the nearest items
 */
function getIntersectItems(chart, position) {
	var elements = [];

	parseVisibleItems(chart, function (element) {
		if (element.inRange(position.x, position.y)) {
			elements.push(element);
		}
	});

	return elements;
}

/**
 * Helper function to get the items nearest to the event position considering all visible items in teh chart
 * @param chart {Chart} the chart to look at elements from
 * @param position {Point} the point to be nearest to
 * @param intersect {Boolean} if true, only consider items that intersect the position
 * @param distanceMetric {Function} function to provide the distance between points
 * @return {ChartElement[]} the nearest items
 */
function getNearestItems(chart, position, intersect, distanceMetric) {
	var minDistance = Number.POSITIVE_INFINITY;
	var nearestItems = [];

	parseVisibleItems(chart, function (element) {
		if (intersect && !element.inRange(position.x, position.y)) {
			return;
		}

		var center = element.getCenterPoint();
		var distance = distanceMetric(position, center);

		if (distance < minDistance) {
			nearestItems = [element];
			minDistance = distance;
		} else if (distance === minDistance) {
			// Can have multiple items at the same distance in which case we sort by size
			nearestItems.push(element);
		}
	});

	return nearestItems;
}

/**
 * Get a distance metric function for two points based on the
 * axis mode setting
 * @param {String} axis the axis mode. x|y|xy
 */
function getDistanceMetricForAxis(axis) {
	var useX = axis.indexOf('x') !== -1;
	var useY = axis.indexOf('y') !== -1;

	return function (pt1, pt2) {
		var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
		var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
		return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	};
}

function indexMode(chart, e, options) {
	var position = getRelativePosition(e, chart);
	// Default axis for index mode is 'x' to match old behaviour
	options.axis = options.axis || 'x';
	var distanceMetric = getDistanceMetricForAxis(options.axis);
	var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
	var elements = [];

	if (!items.length) {
		return [];
	}

	chart.data.datasets.forEach(function (dataset, datasetIndex) {
		if (chart.isDatasetVisible(datasetIndex)) {
			var meta = chart.getDatasetMeta(datasetIndex);
			var element = meta.data[items[0]._index];

			// don't count items that are skipped (null data)
			if (element && !element._view.skip) {
				elements.push(element);
			}
		}
	});

	return elements;
}

/**
 * @interface IInteractionOptions
 */
/**
 * If true, only consider items that intersect the point
 * @name IInterfaceOptions#boolean
 * @type Boolean
 */

/**
 * Contains interaction related functions
 * @namespace Chart.Interaction
 */
module.exports = {
	// Helper function for different modes
	modes: {
		single: function single(chart, e) {
			var position = getRelativePosition(e, chart);
			var elements = [];

			parseVisibleItems(chart, function (element) {
				if (element.inRange(position.x, position.y)) {
					elements.push(element);
					return elements;
				}
			});

			return elements.slice(0, 1);
		},

		/**
   * @function Chart.Interaction.modes.label
   * @deprecated since version 2.4.0
   * @todo remove at version 3
   * @private
   */
		label: indexMode,

		/**
   * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
   * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
   * @function Chart.Interaction.modes.index
   * @since v2.4.0
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @param options {IInteractionOptions} options to use during interaction
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		index: indexMode,

		/**
   * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
   * If the options.intersect is false, we find the nearest item and return the items in that dataset
   * @function Chart.Interaction.modes.dataset
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @param options {IInteractionOptions} options to use during interaction
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		dataset: function dataset(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

			if (items.length > 0) {
				items = chart.getDatasetMeta(items[0]._datasetIndex).data;
			}

			return items;
		},

		/**
   * @function Chart.Interaction.modes.x-axis
   * @deprecated since version 2.4.0. Use index mode and intersect == true
   * @todo remove at version 3
   * @private
   */
		'x-axis': function xAxis(chart, e) {
			return indexMode(chart, e, { intersect: true });
		},

		/**
   * Point mode returns all elements that hit test based on the event position
   * of the event
   * @function Chart.Interaction.modes.intersect
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		point: function point(chart, e) {
			var position = getRelativePosition(e, chart);
			return getIntersectItems(chart, position);
		},

		/**
   * nearest mode returns the element closest to the point
   * @function Chart.Interaction.modes.intersect
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @param options {IInteractionOptions} options to use
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		nearest: function nearest(chart, e, options) {
			var position = getRelativePosition(e, chart);
			options.axis = options.axis || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

			// We have multiple items at the same distance from the event. Now sort by smallest
			if (nearestItems.length > 1) {
				nearestItems.sort(function (a, b) {
					var sizeA = a.getArea();
					var sizeB = b.getArea();
					var ret = sizeA - sizeB;

					if (ret === 0) {
						// if equal sort by dataset index
						ret = a._datasetIndex - b._datasetIndex;
					}

					return ret;
				});
			}

			// Return only 1 item
			return nearestItems.slice(0, 1);
		},

		/**
   * x mode returns the elements that hit-test at the current x coordinate
   * @function Chart.Interaction.modes.x
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @param options {IInteractionOptions} options to use
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		x: function x(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function (element) {
				if (element.inXRange(position.x)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		},

		/**
   * y mode returns the elements that hit-test at the current y coordinate
   * @function Chart.Interaction.modes.y
   * @param chart {chart} the chart we are returning items from
   * @param e {Event} the event we are find things at
   * @param options {IInteractionOptions} options to use
   * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
   */
		y: function y(chart, e, options) {
			var position = getRelativePosition(e, chart);
			var items = [];
			var intersectsItem = false;

			parseVisibleItems(chart, function (element) {
				if (element.inYRange(position.y)) {
					items.push(element);
				}

				if (element.inRange(position.x, position.y)) {
					intersectsItem = true;
				}
			});

			// If we want to trigger on an intersect and we don't have any items
			// that intersect the position, return nothing
			if (options.intersect && !intersectsItem) {
				items = [];
			}
			return items;
		}
	}
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);
var basic = __webpack_require__(438);
var dom = __webpack_require__(439);

// @TODO Make possible to select another platform at build time.
var implementation = dom._enabled ? dom : basic;

/**
 * @namespace Chart.platform
 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
 * @since 2.4.0
 */
module.exports = helpers.extend({
	/**
  * @since 2.7.0
  */
	initialize: function initialize() {},

	/**
  * Called at chart construction time, returns a context2d instance implementing
  * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
  * @param {*} item - The native item from which to acquire context (platform specific)
  * @param {Object} options - The chart options
  * @returns {CanvasRenderingContext2D} context2d instance
  */
	acquireContext: function acquireContext() {},

	/**
  * Called at chart destruction time, releases any resources associated to the context
  * previously returned by the acquireContext() method.
  * @param {CanvasRenderingContext2D} context - The context2d instance
  * @returns {Boolean} true if the method succeeded, else false
  */
	releaseContext: function releaseContext() {},

	/**
  * Registers the specified listener on the given chart.
  * @param {Chart} chart - Chart from which to listen for event
  * @param {String} type - The ({@link IEvent}) type to listen for
  * @param {Function} listener - Receives a notification (an object that implements
  * the {@link IEvent} interface) when an event of the specified type occurs.
  */
	addEventListener: function addEventListener() {},

	/**
  * Removes the specified listener previously registered with addEventListener.
  * @param {Chart} chart -Chart from which to remove the listener
  * @param {String} type - The ({@link IEvent}) type to remove
  * @param {Function} listener - The listener function to remove from the event target.
  */
	removeEventListener: function removeEventListener() {}

}, implementation);

/**
 * @interface IPlatform
 * Allows abstracting platform dependencies away from the chart
 * @borrows Chart.platform.acquireContext as acquireContext
 * @borrows Chart.platform.releaseContext as releaseContext
 * @borrows Chart.platform.addEventListener as addEventListener
 * @borrows Chart.platform.removeEventListener as removeEventListener
 */

/**
 * @interface IEvent
 * @prop {String} type - The event type name, possible values are:
 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
 */

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* MIT license */
var convert = __webpack_require__(451);
var string = __webpack_require__(449);

var Color = function Color(obj) {
	if (obj instanceof Color) {
		return obj;
	}
	if (!(this instanceof Color)) {
		return new Color(obj);
	}

	this.valid = false;
	this.values = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		hsv: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		alpha: 1
	};

	// parse Color() argument
	var vals;
	if (typeof obj === 'string') {
		vals = string.getRgba(obj);
		if (vals) {
			this.setValues('rgb', vals);
		} else if (vals = string.getHsla(obj)) {
			this.setValues('hsl', vals);
		} else if (vals = string.getHwb(obj)) {
			this.setValues('hwb', vals);
		}
	} else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
		vals = obj;
		if (vals.r !== undefined || vals.red !== undefined) {
			this.setValues('rgb', vals);
		} else if (vals.l !== undefined || vals.lightness !== undefined) {
			this.setValues('hsl', vals);
		} else if (vals.v !== undefined || vals.value !== undefined) {
			this.setValues('hsv', vals);
		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
			this.setValues('hwb', vals);
		} else if (vals.c !== undefined || vals.cyan !== undefined) {
			this.setValues('cmyk', vals);
		}
	}
};

Color.prototype = {
	isValid: function isValid() {
		return this.valid;
	},
	rgb: function rgb() {
		return this.setSpace('rgb', arguments);
	},
	hsl: function hsl() {
		return this.setSpace('hsl', arguments);
	},
	hsv: function hsv() {
		return this.setSpace('hsv', arguments);
	},
	hwb: function hwb() {
		return this.setSpace('hwb', arguments);
	},
	cmyk: function cmyk() {
		return this.setSpace('cmyk', arguments);
	},

	rgbArray: function rgbArray() {
		return this.values.rgb;
	},
	hslArray: function hslArray() {
		return this.values.hsl;
	},
	hsvArray: function hsvArray() {
		return this.values.hsv;
	},
	hwbArray: function hwbArray() {
		var values = this.values;
		if (values.alpha !== 1) {
			return values.hwb.concat([values.alpha]);
		}
		return values.hwb;
	},
	cmykArray: function cmykArray() {
		return this.values.cmyk;
	},
	rgbaArray: function rgbaArray() {
		var values = this.values;
		return values.rgb.concat([values.alpha]);
	},
	hslaArray: function hslaArray() {
		var values = this.values;
		return values.hsl.concat([values.alpha]);
	},
	alpha: function alpha(val) {
		if (val === undefined) {
			return this.values.alpha;
		}
		this.setValues('alpha', val);
		return this;
	},

	red: function red(val) {
		return this.setChannel('rgb', 0, val);
	},
	green: function green(val) {
		return this.setChannel('rgb', 1, val);
	},
	blue: function blue(val) {
		return this.setChannel('rgb', 2, val);
	},
	hue: function hue(val) {
		if (val) {
			val %= 360;
			val = val < 0 ? 360 + val : val;
		}
		return this.setChannel('hsl', 0, val);
	},
	saturation: function saturation(val) {
		return this.setChannel('hsl', 1, val);
	},
	lightness: function lightness(val) {
		return this.setChannel('hsl', 2, val);
	},
	saturationv: function saturationv(val) {
		return this.setChannel('hsv', 1, val);
	},
	whiteness: function whiteness(val) {
		return this.setChannel('hwb', 1, val);
	},
	blackness: function blackness(val) {
		return this.setChannel('hwb', 2, val);
	},
	value: function value(val) {
		return this.setChannel('hsv', 2, val);
	},
	cyan: function cyan(val) {
		return this.setChannel('cmyk', 0, val);
	},
	magenta: function magenta(val) {
		return this.setChannel('cmyk', 1, val);
	},
	yellow: function yellow(val) {
		return this.setChannel('cmyk', 2, val);
	},
	black: function black(val) {
		return this.setChannel('cmyk', 3, val);
	},

	hexString: function hexString() {
		return string.hexString(this.values.rgb);
	},
	rgbString: function rgbString() {
		return string.rgbString(this.values.rgb, this.values.alpha);
	},
	rgbaString: function rgbaString() {
		return string.rgbaString(this.values.rgb, this.values.alpha);
	},
	percentString: function percentString() {
		return string.percentString(this.values.rgb, this.values.alpha);
	},
	hslString: function hslString() {
		return string.hslString(this.values.hsl, this.values.alpha);
	},
	hslaString: function hslaString() {
		return string.hslaString(this.values.hsl, this.values.alpha);
	},
	hwbString: function hwbString() {
		return string.hwbString(this.values.hwb, this.values.alpha);
	},
	keyword: function keyword() {
		return string.keyword(this.values.rgb, this.values.alpha);
	},

	rgbNumber: function rgbNumber() {
		var rgb = this.values.rgb;
		return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
	},

	luminosity: function luminosity() {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.values.rgb;
		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
		}
		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function contrast(color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();
		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}
		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function level(color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return contrastRatio >= 4.5 ? 'AA' : '';
	},

	dark: function dark() {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.values.rgb;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function light() {
		return !this.dark();
	},

	negate: function negate() {
		var rgb = [];
		for (var i = 0; i < 3; i++) {
			rgb[i] = 255 - this.values.rgb[i];
		}
		this.setValues('rgb', rgb);
		return this;
	},

	lighten: function lighten(ratio) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	darken: function darken(ratio) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	saturate: function saturate(ratio) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	desaturate: function desaturate(ratio) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},

	whiten: function whiten(ratio) {
		var hwb = this.values.hwb;
		hwb[1] += hwb[1] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	blacken: function blacken(ratio) {
		var hwb = this.values.hwb;
		hwb[2] += hwb[2] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},

	greyscale: function greyscale() {
		var rgb = this.values.rgb;
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		this.setValues('rgb', [val, val, val]);
		return this;
	},

	clearer: function clearer(ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha - alpha * ratio);
		return this;
	},

	opaquer: function opaquer(ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha + alpha * ratio);
		return this;
	},

	rotate: function rotate(degrees) {
		var hsl = this.values.hsl;
		var hue = (hsl[0] + degrees) % 360;
		hsl[0] = hue < 0 ? 360 + hue : hue;
		this.setValues('hsl', hsl);
		return this;
	},

	/**
  * Ported from sass implementation in C
  * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
  */
	mix: function mix(mixinColor, weight) {
		var color1 = this;
		var color2 = mixinColor;
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
	},

	toJSON: function toJSON() {
		return this.rgb();
	},

	clone: function clone() {
		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
		// making the final build way to big to embed in Chart.js. So let's do it manually,
		// assuming that values to clone are 1 dimension arrays containing only numbers,
		// except 'alpha' which is a number.
		var result = new Color();
		var source = this.values;
		var target = result.values;
		var value, type;

		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				value = source[prop];
				type = {}.toString.call(value);
				if (type === '[object Array]') {
					target[prop] = value.slice(0);
				} else if (type === '[object Number]') {
					target[prop] = value;
				} else {
					console.error('unexpected color value:', value);
				}
			}
		}

		return result;
	}
};

Color.prototype.spaces = {
	rgb: ['red', 'green', 'blue'],
	hsl: ['hue', 'saturation', 'lightness'],
	hsv: ['hue', 'saturation', 'value'],
	hwb: ['hue', 'whiteness', 'blackness'],
	cmyk: ['cyan', 'magenta', 'yellow', 'black']
};

Color.prototype.maxes = {
	rgb: [255, 255, 255],
	hsl: [360, 100, 100],
	hsv: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues = function (space) {
	var values = this.values;
	var vals = {};

	for (var i = 0; i < space.length; i++) {
		vals[space.charAt(i)] = values[space][i];
	}

	if (values.alpha !== 1) {
		vals.a = values.alpha;
	}

	// {r: 255, g: 255, b: 255, a: 0.4}
	return vals;
};

Color.prototype.setValues = function (space, vals) {
	var values = this.values;
	var spaces = this.spaces;
	var maxes = this.maxes;
	var alpha = 1;
	var i;

	this.valid = true;

	if (space === 'alpha') {
		alpha = vals;
	} else if (vals.length) {
		// [10, 10, 10]
		values[space] = vals.slice(0, space.length);
		alpha = vals[space.length];
	} else if (vals[space.charAt(0)] !== undefined) {
		// {r: 10, g: 10, b: 10}
		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[space.charAt(i)];
		}

		alpha = vals.a;
	} else if (vals[spaces[space][0]] !== undefined) {
		// {red: 10, green: 10, blue: 10}
		var chans = spaces[space];

		for (i = 0; i < space.length; i++) {
			values[space][i] = vals[chans[i]];
		}

		alpha = vals.alpha;
	}

	values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

	if (space === 'alpha') {
		return false;
	}

	var capped;

	// cap values of the space prior converting all values
	for (i = 0; i < space.length; i++) {
		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
		values[space][i] = Math.round(capped);
	}

	// convert to all the other color spaces
	for (var sname in spaces) {
		if (sname !== space) {
			values[sname] = convert[space][sname](values[space]);
		}
	}

	return true;
};

Color.prototype.setSpace = function (space, args) {
	var vals = args[0];

	if (vals === undefined) {
		// color.rgb()
		return this.getValues(space);
	}

	// color.rgb(10, 10, 10)
	if (typeof vals === 'number') {
		vals = Array.prototype.slice.call(args);
	}

	this.setValues(space, vals);
	return this;
};

Color.prototype.setChannel = function (space, index, val) {
	var svalues = this.values[space];
	if (val === undefined) {
		// color.red()
		return svalues[index];
	} else if (val === svalues[index]) {
		// color.red(color.red())
		return this;
	}

	// color.red(100)
	svalues[index] = val;
	this.setValues(space, svalues);

	return this;
};

if (typeof window !== 'undefined') {
	window.Color = Color;
}

module.exports = Color;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(32);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(17);
var toAbsoluteIndex = __webpack_require__(64);
var toLength = __webpack_require__(15);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }return O;
};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(56);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(21);
var toObject = __webpack_require__(17);
var IObject = __webpack_require__(77);
var toLength = __webpack_require__(15);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (; isRight ? index >= 0 : length > index; index += i) {
    if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
  }return memo;
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(21);
var isObject = __webpack_require__(8);
var invoke = __webpack_require__(195);
var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) {
      n[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function bound() /* args... */{
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(14).f;
var create = __webpack_require__(58);
var redefineAll = __webpack_require__(62);
var ctx = __webpack_require__(33);
var anInstance = __webpack_require__(55);
var forOf = __webpack_require__(56);
var $iterDefine = __webpack_require__(119);
var step = __webpack_require__(198);
var setSpecies = __webpack_require__(63);
var DESCRIPTORS = __webpack_require__(13);
var fastKey = __webpack_require__(48).fastKey;
var validate = __webpack_require__(71);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = create(null); // index
      that._f = undefined; // first entry
      that._l = undefined; // last entry
      that[SIZE] = 0; // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function get() {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
      // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key, // <- key
        v: value, // <- value
        p: prev = that._l, // <- previous entry
        n: undefined, // <- next entry
        r: false // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    }return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind; // kind
      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(76);
var from = __webpack_require__(187);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(62);
var getWeak = __webpack_require__(48).getWeak;
var anObject = __webpack_require__(3);
var isObject = __webpack_require__(8);
var anInstance = __webpack_require__(55);
var forOf = __webpack_require__(56);
var createArrayMethod = __webpack_require__(35);
var $has = __webpack_require__(23);
var validate = __webpack_require__(71);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = id++; // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(92);
var isObject = __webpack_require__(8);
var toLength = __webpack_require__(15);
var ctx = __webpack_require__(33);
var IS_CONCAT_SPREADABLE = __webpack_require__(11)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(13) && !__webpack_require__(7)(function () {
  return Object.defineProperty(__webpack_require__(112)('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),
/* 195 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(8);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(3);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(121);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),
/* 200 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 201 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0
  // eslint-disable-next-line no-self-compare
  || x != x
  // eslint-disable-next-line no-self-compare
  || inLow != inLow
  // eslint-disable-next-line no-self-compare
  || inHigh != inHigh
  // eslint-disable-next-line no-self-compare
  || outLow != outLow
  // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)

var getKeys = __webpack_require__(60);
var gOPS = __webpack_require__(96);
var pIE = __webpack_require__(78);
var toObject = __webpack_require__(17);
var IObject = __webpack_require__(77);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(7)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(14);
var anObject = __webpack_require__(3);
var getKeys = __webpack_require__(60);

module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }return O;
};

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(30);
var gOPN = __webpack_require__(59).f;
var toString = {}.toString;

var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(23);
var toIObject = __webpack_require__(30);
var arrayIndexOf = __webpack_require__(88)(false);
var IE_PROTO = __webpack_require__(125)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(60);
var toIObject = __webpack_require__(30);
var isEnum = __webpack_require__(78).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }return result;
  };
};

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(59);
var gOPS = __webpack_require__(96);
var anObject = __webpack_require__(3);
var Reflect = __webpack_require__(5).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(5).parseFloat;
var $trim = __webpack_require__(70).trim;

module.exports = 1 / $parseFloat(__webpack_require__(129) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(5).parseInt;
var $trim = __webpack_require__(70).trim;
var ws = __webpack_require__(129);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 210 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(3);
var isObject = __webpack_require__(8);
var newPromiseCapability = __webpack_require__(123);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(15);
var repeat = __webpack_require__(128);
var defined = __webpack_require__(37);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(39);
var toLength = __webpack_require__(15);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(11);

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(190);
var validate = __webpack_require__(71);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(89)(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(14).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(91)
});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(190);
var validate = __webpack_require__(71);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(89)(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__(35)(0);
var redefine = __webpack_require__(25);
var meta = __webpack_require__(48);
var assign = __webpack_require__(202);
var weak = __webpack_require__(192);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(7);
var validate = __webpack_require__(71);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(89)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
        // store all the rest on native weakmap
      }return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (false) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var af = moment.defineLocale('af', {
        months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM: function isPM(input) {
            return (/^nm$/i.test(input)
            );
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Vandag om] LT',
            nextDay: '[Mre om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[Gister om] LT',
            lastWeek: '[Laas] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'oor %s',
            past: '%s gelede',
            s: '\'n paar sekondes',
            m: '\'n minuut',
            mm: '%d minute',
            h: '\'n uur',
            hh: '%d ure',
            d: '\'n dag',
            dd: '%d dae',
            M: '\'n maand',
            MM: '%d maande',
            y: '\'n jaar',
            yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week: {
            dow: 1, // Maandag is die eerste dag van die week.
            doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;
});

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var arDz = moment.defineLocale('ar-dz', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return arDz;
});

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var arKw = moment.defineLocale('ar-kw', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return arKw;
});

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '1',
        '2': '2',
        '3': '3',
        '4': '4',
        '5': '5',
        '6': '6',
        '7': '7',
        '8': '8',
        '9': '9',
        '0': '0'
    };
    var pluralForm = function pluralForm(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    };
    var plurals = {
        s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    };
    var pluralize = function pluralize(u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    };
    var months = ['', '', '', '', '', '', '', '', '', '', '', ''];

    var arLy = moment.defineLocale('ar-ly', {
        months: months,
        monthsShort: months,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y')
        },
        preparse: function preparse(string) {
            return string.replace(/\u200f/g, '').replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return arLy;
});

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var arMa = moment.defineLocale('ar-ma', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return arMa;
});

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var arSa = moment.defineLocale('ar-sa', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return arSa;
});

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var arTn = moment.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arTn;
});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };
    var pluralForm = function pluralForm(n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    };
    var plurals = {
        s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    };
    var pluralize = function pluralize(u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    };
    var months = ['  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '  ', '  ', '  '];

    var ar = moment.defineLocale('ar', {
        months: months,
        monthsShort: months,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y')
        },
        preparse: function preparse(string) {
            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ar;
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = moment.defineLocale('az', {
        months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[bugn saat] LT',
            nextDay: '[sabah saat] LT',
            nextWeek: '[gln hft] dddd [saat] LT',
            lastDay: '[dnn] LT',
            lastWeek: '[ken hft] dddd [saat] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s vvl',
            s: 'birne saniyy',
            m: 'bir dqiq',
            mm: '%d dqiq',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gn',
            dd: '%d gn',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir il',
            yy: '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM: function isPM(input) {
            return (/^(gndz|axam)$/.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return az;
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        } else if (key === 'h') {
            return withoutSuffix ? '' : '';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months: {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort: '___________'.split('_'),
        weekdays: {
            format: '______'.split('_'),
            standalone: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY .',
            LLL: 'D MMMM YYYY ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function nextWeek() {
                return '[] dddd [] LT';
            },
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s ',
            s: ' ',
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithPlural,
            hh: relativeTimeWithPlural,
            d: '',
            dd: relativeTimeWithPlural,
            M: '',
            MM: relativeTimeWithPlural,
            y: '',
            yy: relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM: function isPM(input) {
            return (/^(|)$/.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-' : number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return be;
});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var bg = moment.defineLocale('bg', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: ' ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function ordinal(number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bg;
});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = moment.defineLocale('bn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bn;
});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = moment.defineLocale('bo', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: '[], LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bo;
});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h[e]mm A',
            LTS: 'h[e]mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D [a viz] MMMM YYYY',
            LLL: 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar: {
            sameDay: '[Hiziv da] LT',
            nextDay: '[Warc\'hoazh da] LT',
            nextWeek: 'dddd [da] LT',
            lastDay: '[Dec\'h da] LT',
            lastWeek: 'dddd [paset da] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'a-benn %s',
            past: '%s \'zo',
            s: 'un nebeud segondenno',
            m: 'ur vunutenn',
            mm: relativeTimeWithMutation,
            h: 'un eur',
            hh: '%d eur',
            d: 'un devezh',
            dd: relativeTimeWithMutation,
            M: 'ur miz',
            MM: relativeTimeWithMutation,
            y: 'ur bloaz',
            yy: specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
        ordinal: function ordinal(number) {
            var output = number === 1 ? 'a' : 'vet';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juer u] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return bs;
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ca = moment.defineLocale('ca', {
        months: {
            standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
            format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact: true,
        weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: '[el] D MMMM [de] YYYY',
            ll: 'D MMM YYYY',
            LLL: '[el] D MMMM [de] YYYY [a les] H:mm',
            lll: 'D MMM YYYY, H:mm',
            LLLL: '[el] dddd D MMMM [de] YYYY [a les] H:mm',
            llll: 'ddd D MMM YYYY, H:mm'
        },
        calendar: {
            sameDay: function sameDay() {
                return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextDay: function nextDay() {
                return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextWeek: function nextWeek() {
                return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastDay: function lastDay() {
                return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastWeek: function lastWeek() {
                return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'd\'aqu %s',
            past: 'fa %s',
            s: 'uns segons',
            m: 'un minut',
            mm: '%d minuts',
            h: 'una hora',
            hh: '%d hores',
            d: 'un dia',
            dd: '%d dies',
            M: 'un mes',
            MM: '%d mesos',
            y: 'un any',
            yy: '%d anys'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal: function ordinal(number, period) {
            var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;
});

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
    var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
    function plural(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';
            case 'm':
                // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
            case 'mm':
                // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':
                // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh':
                // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':
                // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'den' : 'dnem';
            case 'dd':
                // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dn');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':
                // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'msc' : 'mscem';
            case 'MM':
                // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'msce' : 'msc');
                } else {
                    return result + 'msci';
                }
                break;
            case 'y':
                // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokem';
            case 'yy':
                // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months: months,
        monthsShort: monthsShort,
        monthsParse: function (months, monthsShort) {
            var i,
                _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(months, monthsShort),
        shortMonthsParse: function (monthsShort) {
            var i,
                _shortMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
            }
            return _shortMonthsParse;
        }(monthsShort),
        longMonthsParse: function (months) {
            var i,
                _longMonthsParse = [];
            for (i = 0; i < 12; i++) {
                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
            }
            return _longMonthsParse;
        }(months),
        weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm',
            l: 'D. M. YYYY'
        },
        calendar: {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[v nedli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve stedu v] LT';
                    case 4:
                        return '[ve tvrtek v] LT';
                    case 5:
                        return '[v ptek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                        return '[minulou nedli v] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [v] LT';
                    case 3:
                        return '[minulou stedu v] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'ped %s',
            s: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var cv = moment.defineLocale('cv', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'YYYY [] MMMM [] D[-]',
            LLL: 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar: {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: function future(output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past: '%s ',
            s: '- ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-/,
        ordinal: '%d-',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return cv;
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function ordinal(number) {
            var b = number,
                output = '',
                lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
            'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
            ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var da = moment.defineLocale('da', {
        months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'p dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[i] dddd[s kl.] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'f sekunder',
            m: 'et minut',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dage',
            M: 'en mned',
            MM: '%d mneder',
            y: 'et r',
            yy: '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deAt;
});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    // based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH.mm',
            LLLL: 'dddd, D. MMMM YYYY HH.mm'
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deCh;
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = ['', '', '', '', '', '', '', '', '', '', '', ''];
    var weekdays = ['', '', '', '', '', '', ''];

    var dv = moment.defineLocale('dv', {
        months: months,
        monthsShort: months,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: '______'.split('_'),
        longDateFormat: {

            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/M/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: ' %d',
            h: '',
            hh: ' %d',
            d: '',
            dd: ' %d',
            M: '',
            MM: ' %d',
            y: '',
            yy: ' %d'
        },
        preparse: function preparse(string) {
            return string.replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/,/g, '');
        },
        week: {
            dow: 7, // Sunday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return dv;
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    var el = moment.defineLocale('el', {
        monthsNominativeEl: '___________'.split('_'),
        monthsGenitiveEl: '___________'.split('_'),
        months: function months(momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (/D/.test(format.substring(0, format.indexOf('MMMM')))) {
                // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM: function isPM(input) {
            return (input + '').toLowerCase()[0] === '';
        },
        meridiemParse: /[]\.??\.?/i,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl: {
            sameDay: '[ {}] LT',
            nextDay: '[ {}] LT',
            nextWeek: 'dddd [{}] LT',
            lastDay: '[ {}] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse: 'L'
        },
        calendar: function calendar(key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', hours % 12 === 1 ? '' : '');
        },
        relativeTime: {
            future: ' %s',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var enAu = moment.defineLocale('en-au', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enAu;
});

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var enCa = moment.defineLocale('en-ca', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'YYYY-MM-DD',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        }
    });

    return enCa;
});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var enGb = moment.defineLocale('en-gb', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enGb;
});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var enIe = moment.defineLocale('en-ie', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enIe;
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var enNz = moment.defineLocale('en-nz', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enNz;
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var eo = moment.defineLocale('eo', {
        months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
        weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
        weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D[-a de] MMMM, YYYY',
            LLL: 'D[-a de] MMMM, YYYY HH:mm',
            LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function isPM(input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar: {
            sameDay: '[Hodia je] LT',
            nextDay: '[Morga je] LT',
            nextWeek: 'dddd [je] LT',
            lastDay: '[Hiera je] LT',
            lastWeek: '[pasinta] dddd [je] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'post %s',
            past: 'anta %s',
            s: 'sekundoj',
            m: 'minuto',
            mm: '%d minutoj',
            h: 'horo',
            hh: '%d horoj',
            d: 'tago', //ne 'diurno', ar estas uzita por proksimumo
            dd: '%d tagoj',
            M: 'monato',
            MM: '%d monatoj',
            y: 'jaro',
            yy: '%d jaroj'
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: '%da',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eo;
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
    var _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var esDo = moment.defineLocale('es-do', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort: function monthsShort(m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return _monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY h:mm A',
            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar: {
            sameDay: function sameDay() {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function nextDay() {
                return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function nextWeek() {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function lastDay() {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function lastWeek() {
                return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un da',
            dd: '%d das',
            M: 'un mes',
            MM: '%d meses',
            y: 'un ao',
            yy: '%d aos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return esDo;
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
    var _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var es = moment.defineLocale('es', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort: function monthsShort(m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return _monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar: {
            sameDay: function sameDay() {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function nextDay() {
                return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function nextWeek() {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function lastDay() {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function lastWeek() {
                return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un da',
            dd: '%d das',
            M: 'un mes',
            MM: '%d meses',
            y: 'un ao',
            yy: '%d aos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;
});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'm': ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h': ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd': ['he peva', 'ks pev'],
            'M': ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y': ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[Tna,] LT',
            nextDay: '[Homme,] LT',
            nextWeek: '[Jrgmine] dddd LT',
            lastDay: '[Eile,] LT',
            lastWeek: '[Eelmine] dddd LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s prast',
            past: '%s tagasi',
            s: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: '%d peva',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var eu = moment.defineLocale('eu', {
        months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact: true,
        weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY[ko] MMMM[ren] D[a]',
            LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l: 'YYYY-M-D',
            ll: 'YYYY[ko] MMM D[a]',
            lll: 'YYYY[ko] MMM D[a] HH:mm',
            llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar: {
            sameDay: '[gaur] LT[etan]',
            nextDay: '[bihar] LT[etan]',
            nextWeek: 'dddd LT[etan]',
            lastDay: '[atzo] LT[etan]',
            lastWeek: '[aurreko] dddd LT[etan]',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s barru',
            past: 'duela %s',
            s: 'segundo batzuk',
            m: 'minutu bat',
            mm: '%d minutu',
            h: 'ordu bat',
            hh: '%d ordu',
            d: 'egun bat',
            dd: '%d egun',
            M: 'hilabete bat',
            MM: '%d hilabete',
            y: 'urte bat',
            yy: '%d urte'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return eu;
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = moment.defineLocale('fa', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647'.split('_'),
        weekdaysShort: '\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function isPM(input) {
            return (/  /.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[-]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return fa;
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
    var numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'pivn' : 'piv';
            case 'dd':
                result = isFuture ? 'pivn' : 'piv';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }

    var fi = moment.defineLocale('fi', {
        months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'Do MMMM[ta] YYYY',
            LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l: 'D.M.YYYY',
            ll: 'Do MMM YYYY',
            lll: 'Do MMM YYYY, [klo] HH.mm',
            llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar: {
            sameDay: '[tnn] [klo] LT',
            nextDay: '[huomenna] [klo] LT',
            nextWeek: 'dddd [klo] LT',
            lastDay: '[eilen] [klo] LT',
            lastWeek: '[viime] dddd[na] [klo] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s pst',
            past: '%s sitten',
            s: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var fo = moment.defineLocale('fo', {
        months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ dag kl.] LT',
            nextDay: '[ morgin kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[ gjr kl.] LT',
            lastWeek: '[sstu] dddd [kl] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'um %s',
            past: '%s sani',
            s: 'f sekund',
            m: 'ein minutt',
            mm: '%d minuttir',
            h: 'ein tmi',
            hh: '%d tmar',
            d: 'ein dagur',
            dd: '%d dagar',
            M: 'ein mnai',
            MM: '%d mnair',
            y: 'eitt r',
            yy: '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var frCa = moment.defineLocale('fr-ca', {
        months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Aujourdhui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        }
    });

    return frCa;
});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var frCh = moment.defineLocale('fr-ch', {
        months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Aujourdhui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return frCh;
});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var fr = moment.defineLocale('fr', {
        months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Aujourdhui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;
});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
    var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort: function monthsShort(m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'oer %s',
            past: '%s lyn',
            s: 'in pear sekonden',
            m: 'ien mint',
            mm: '%d minuten',
            h: 'ien oere',
            hh: '%d oeren',
            d: 'ien dei',
            dd: '%d dagen',
            M: 'ien moanne',
            MM: '%d moannen',
            y: 'ien jier',
            yy: '%d jierren'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;
});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = ['Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'];

    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[An-diugh aig] LT',
            nextDay: '[A-mireach aig] LT',
            nextWeek: 'dddd [aig] LT',
            lastDay: '[An-d aig] LT',
            lastWeek: 'dddd [seo chaidh] [aig] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'ann an %s',
            past: 'bho chionn %s',
            s: 'beagan diogan',
            m: 'mionaid',
            mm: '%d mionaidean',
            h: 'uair',
            hh: '%d uairean',
            d: 'latha',
            dd: '%d latha',
            M: 'mos',
            MM: '%d mosan',
            y: 'bliadhna',
            yy: '%d bliadhna'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function ordinal(number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;
});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var gl = moment.defineLocale('gl', {
        months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
        weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar: {
            sameDay: function sameDay() {
                return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function nextDay() {
                return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function nextWeek() {
                return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
            },
            lastDay: function lastDay() {
                return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
            },
            lastWeek: function lastWeek() {
                return '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: function future(str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past: 'hai %s',
            s: 'uns segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'unha hora',
            hh: '%d horas',
            d: 'un da',
            dd: '%d das',
            M: 'un mes',
            MM: '%d meses',
            y: 'un ano',
            yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gl;
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['thodde secondanim', 'thodde second'],
            'm': ['eka mintan', 'ek minute'],
            'mm': [number + ' mintanim', number + ' mintam'],
            'h': ['eka horan', 'ek hor'],
            'hh': [number + ' horanim', number + ' hor'],
            'd': ['eka disan', 'ek dis'],
            'dd': [number + ' disanim', number + ' dis'],
            'M': ['eka mhoinean', 'ek mhoino'],
            'MM': [number + ' mhoineanim', number + ' mhoine'],
            'y': ['eka vorsan', 'ek voros'],
            'yy': [number + ' vorsanim', number + ' vorsam']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
        weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm [vazta]',
            LTS: 'A h:mm:ss [vazta]',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY A h:mm [vazta]',
            LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
        },
        calendar: {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Ieta to] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fatlo] dddd[,] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s adim',
            s: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokalli') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokalli';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        }
    });

    return gomLatn;
});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var he = moment.defineLocale('he', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D []MMMM YYYY',
            LLL: 'D []MMMM YYYY HH:mm',
            LLLL: 'dddd, D []MMMM YYYY HH:mm',
            l: 'D/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ]LT',
            nextDay: '[ ]LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ]LT',
            lastWeek: '[] dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: ' ',
            m: '',
            mm: '%d ',
            h: '',
            hh: function hh(number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d: '',
            dd: function dd(number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M: '',
            MM: function MM(number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y: '',
            yy: function yy(number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM: function isPM(input) {
            return (/^("| |)$/.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 5) {
                return ' ';
            } else if (hour < 10) {
                return '';
            } else if (hour < 12) {
                return isLower ? '"' : ' ';
            } else if (hour < 18) {
                return isLower ? '"' : ' ';
            } else {
                return '';
            }
        }
    });

    return he;
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = moment.defineLocale('hi', {
        months: '___________'.split('_'),
        monthsShort: '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: '  ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hi;
});

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months: {
            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juer u] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hr;
});

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
            case 's':
                return isFuture || withoutSuffix ? 'nhny msodperc' : 'nhny msodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort: 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'YYYY.MM.DD.',
            LL: 'YYYY. MMMM D.',
            LLL: 'YYYY. MMMM D. H:mm',
            LLLL: 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function isPM(input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar: {
            sameDay: '[ma] LT[-kor]',
            nextDay: '[holnap] LT[-kor]',
            nextWeek: function nextWeek() {
                return week.call(this, true);
            },
            lastDay: '[tegnap] LT[-kor]',
            lastWeek: function lastWeek() {
                return week.call(this, false);
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s mlva',
            past: '%s',
            s: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return hu;
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var hyAm = moment.defineLocale('hy-am', {
        months: {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY .',
            LLL: 'D MMMM YYYY ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function nextWeek() {
                return 'dddd [ ] LT';
            },
            lastWeek: function lastWeek() {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: '  ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        meridiemParse: /|||/,
        isPM: function isPM(input) {
            return (/^(|)$/.test(input)
            );
        },
        meridiem: function meridiem(hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-';
                    }
                    return number + '-';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return hyAm;
});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var id = moment.defineLocale('id', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Besok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kemarin pukul] LT',
            lastWeek: 'dddd [lalu pukul] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lalu',
            s: 'beberapa detik',
            m: 'semenit',
            mm: '%d menit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return id;
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
            case 'm':
                return withoutSuffix ? 'mnta' : 'mntu';
            case 'mm':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
                } else if (withoutSuffix) {
                    return result + 'mnta';
                }
                return result + 'mntu';
            case 'hh':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dgum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mnuur';
                }
                return isFuture ? 'mnu' : 'mnui';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mnuir';
                    }
                    return result + (isFuture ? 'mnui' : 'mnuum');
                } else if (withoutSuffix) {
                    return result + 'mnuur';
                }
                return result + (isFuture ? 'mnu' : 'mnui');
            case 'y':
                return withoutSuffix || isFuture ? 'r' : 'ri';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');
                }
                return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = moment.defineLocale('is', {
        months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar: {
            sameDay: '[ dag kl.] LT',
            nextDay: '[ morgun kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[ gr kl.] LT',
            lastWeek: '[sasta] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'eftir %s',
            past: 'fyrir %s san',
            s: translate,
            m: translate,
            mm: translate,
            h: 'klukkustund',
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var it = moment.defineLocale('it', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: function future(s) {
                return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past: '%s fa',
            s: 'alcuni secondi',
            m: 'un minuto',
            mm: '%d minuti',
            h: 'un\'ora',
            hh: '%d ore',
            d: 'un giorno',
            dd: '%d giorni',
            M: 'un mese',
            MM: '%d mesi',
            y: 'un anno',
            yy: '%d anni'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;
});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ja = moment.defineLocale('ja', {
        months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYYMD',
            LLL: 'YYYYMD HH:mm',
            LLLL: 'YYYYMD HH:mm dddd',
            l: 'YYYY/MM/DD',
            ll: 'YYYYMD',
            lll: 'YYYYMD HH:mm',
            llll: 'YYYYMD HH:mm dddd'
        },
        meridiemParse: /|/i,
        isPM: function isPM(input) {
            return input === '';
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: '[]dddd LT',
            lastDay: '[] LT',
            lastWeek: '[]dddd LT',
            sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '1',
            mm: '%d',
            h: '1',
            hh: '%d',
            d: '1',
            dd: '%d',
            M: '1',
            MM: '%d',
            y: '1',
            yy: '%d'
        }
    });

    return ja;
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var jv = moment.defineLocale('jv', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar: {
            sameDay: '[Dinten puniko pukul] LT',
            nextDay: '[Mbenjang pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kala wingi pukul] LT',
            lastWeek: 'dddd [kepengker pukul] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'wonten ing %s',
            past: '%s ingkang kepengker',
            s: 'sawetawis detik',
            m: 'setunggal menit',
            mm: '%d menit',
            h: 'setunggal jam',
            hh: '%d jam',
            d: 'sedinten',
            dd: '%d dinten',
            M: 'sewulan',
            MM: '%d wulan',
            y: 'setaun',
            yy: '%d taun'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return jv;
});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ka = moment.defineLocale('ka', {
        months: {
            standalone: '___________'.split('_'),
            format: '___________'.split('_')
        },
        monthsShort: '___________'.split('_'),
        weekdays: {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /(|)/
        },
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
            sameDay: '[] LT[-]',
            nextDay: '[] LT[-]',
            lastDay: '[] LT[-]',
            nextWeek: '[] dddd LT[-]',
            lastWeek: '[] dddd LT-',
            sameElse: 'L'
        },
        relativeTime: {
            future: function future(s) {
                return (/(|||)/.test(s) ? s.replace(/$/, '') : s + ''
                );
            },
            past: function past(s) {
                if (/(||||)/.test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if (//.test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s: ' ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal: function ordinal(number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
                return '-' + number;
            }
            return number + '-';
        },
        week: {
            dow: 1,
            doy: 7
        }
    });

    return ka;
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var kk = moment.defineLocale('kk', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: '[ ] dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function ordinal(number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return kk;
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var km = moment.defineLocale('km', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var kn = moment.defineLocale('kn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal: function ordinal(number) {
            return number + '';
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return kn;
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ko = moment.defineLocale('ko', {
        months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'YYYY.MM.DD',
            LL: 'YYYY MMMM D',
            LLL: 'YYYY MMMM D A h:mm',
            LLLL: 'YYYY MMMM D dddd A h:mm',
            l: 'YYYY.MM.DD',
            ll: 'YYYY MMMM D',
            lll: 'YYYY MMMM D A h:mm',
            llll: 'YYYY MMMM D dddd A h:mm'
        },
        calendar: {
            sameDay: ' LT',
            nextDay: ' LT',
            nextWeek: 'dddd LT',
            lastDay: ' LT',
            lastWeek: ' dddd LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            ss: '%d',
            m: '1',
            mm: '%d',
            h: ' ',
            hh: '%d',
            d: '',
            dd: '%d',
            M: ' ',
            MM: '%d',
            y: ' ',
            yy: '%d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        meridiemParse: /|/,
        isPM: function isPM(token) {
            return token === '';
        },
        meridiem: function meridiem(hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    return ko;
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var ky = moment.defineLocale('ky', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: '[ ] dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
        ordinal: function ordinal(number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ky;
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10,
                firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact: true,
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function lastWeek() {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: 'e puer Sekonnen',
            m: processRelativeTime,
            mm: '%d Minutten',
            h: processRelativeTime,
            hh: '%d Stonnen',
            d: processRelativeTime,
            dd: '%d Deeg',
            M: processRelativeTime,
            MM: '%d Mint',
            y: processRelativeTime,
            yy: '%d Joer'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var lo = moment.defineLocale('lo', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return input === '';
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: '[]dddd[] LT',
            lastDay: '[] LT',
            lastWeek: '[]dddd[] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /()\d{1,2}/,
        ordinal: function ordinal(number) {
            return '' + number;
        }
    });

    return lo;
});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var units = {
        'm': 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h': 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd': 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M': 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y': 'metai_met_metus',
        'yy': 'metai_met_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
        return number % 10 === 0 || number > 10 && number < 20;
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months: {
            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays: {
            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY [m.] MMMM D [d.]',
            LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l: 'YYYY-MM-DD',
            ll: 'YYYY [m.] MMMM D [d.]',
            lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar: {
            sameDay: '[iandien] LT',
            nextDay: '[Rytoj] LT',
            nextWeek: 'dddd LT',
            lastDay: '[Vakar] LT',
            lastWeek: '[Prajus] dddd LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'po %s',
            past: 'prie %s',
            s: translateSeconds,
            m: translateSingular,
            mm: translate,
            h: translateSingular,
            hh: translate,
            d: translateSingular,
            dd: translate,
            M: translateSingular,
            MM: translate,
            y: translateSingular,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function ordinal(number) {
            return number + '-oji';
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var units = {
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = moment.defineLocale('lv', {
        months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY.',
            LL: 'YYYY. [gada] D. MMMM',
            LLL: 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar: {
            sameDay: '[odien pulksten] LT',
            nextDay: '[Rt pulksten] LT',
            nextWeek: 'dddd [pulksten] LT',
            lastDay: '[Vakar pulksten] LT',
            lastWeek: '[Pagju] dddd [pulksten] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'pc %s',
            past: 'pirms %s',
            s: relativeSeconds,
            m: relativeTimeWithSingular,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithSingular,
            hh: relativeTimeWithPlural,
            d: relativeTimeWithSingular,
            dd: relativeTimeWithPlural,
            M: relativeTimeWithSingular,
            MM: relativeTimeWithPlural,
            y: relativeTimeWithSingular,
            yy: relativeTimeWithPlural
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jue u] LT',
            lastWeek: function lastWeek() {
                var lastWeekDays = ['[prole] [nedjelje] [u] LT', '[prolog] [ponedjeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srijede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'nekoliko sekundi',
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mjesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return me;
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
        weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hkona ruarua',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mi;
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var mk = moment.defineLocale('mk', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: 'e_o_____a'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: '[] dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: ' ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function ordinal(number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mk;
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ml = moment.defineLocale('ml', {
        months: '___________'.split('_'),
        monthsShort: '._._._.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm -',
            LTS: 'A h:mm:ss -',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm -',
            LLLL: 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        meridiemParse: /|| ||/i,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' && hour >= 4 || meridiem === ' ' || meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    return ml;
});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's':
                    output = ' ';break;
                case 'm':
                    output = ' ';break;
                case 'mm':
                    output = '%d ';break;
                case 'h':
                    output = ' ';break;
                case 'hh':
                    output = '%d ';break;
                case 'd':
                    output = ' ';break;
                case 'dd':
                    output = '%d ';break;
                case 'M':
                    output = ' ';break;
                case 'MM':
                    output = '%d ';break;
                case 'y':
                    output = ' ';break;
                case 'yy':
                    output = '%d ';break;
            }
        } else {
            switch (string) {
                case 's':
                    output = ' ';break;
                case 'm':
                    output = ' ';break;
                case 'mm':
                    output = '%d ';break;
                case 'h':
                    output = ' ';break;
                case 'hh':
                    output = '%d ';break;
                case 'd':
                    output = ' ';break;
                case 'dd':
                    output = '%d ';break;
                case 'M':
                    output = ' ';break;
                case 'MM':
                    output = '%d ';break;
                case 'y':
                    output = ' ';break;
                case 'yy':
                    output = '%d ';break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months: '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return mr;
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var msMy = moment.defineLocale('ms-my', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return msMy;
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ms = moment.defineLocale('ms', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ms;
});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = moment.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return my;
});

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var nb = moment.defineLocale('nb', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact: true,
        weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
        weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'noen sekunder',
            m: 'ett minutt',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dager',
            M: 'en mned',
            MM: '%d mneder',
            y: 'ett r',
            yy: '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = moment.defineLocale('ne', {
        months: '___________'.split('_'),
        monthsShort: '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '._._._._._._.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: '[] dddd[,] LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd[,] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ne;
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
    var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort: function monthsShort(m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            m: 'n minuut',
            mm: '%d minuten',
            h: 'n uur',
            hh: '%d uur',
            d: 'n dag',
            dd: '%d dagen',
            M: 'n maand',
            MM: '%d maanden',
            y: 'n jaar',
            yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nlBe;
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
    var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort: function monthsShort(m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            m: 'n minuut',
            mm: '%d minuten',
            h: 'n uur',
            hh: '%d uur',
            d: 'n dag',
            dd: '%d dagen',
            M: 'n maand',
            MM: '%d maanden',
            y: 'n jaar',
            yy: '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function ordinal(number) {
            return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var nn = moment.defineLocale('nn', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort: 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin: 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar: {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'om %s',
            past: '%s sidan',
            s: 'nokre sekund',
            m: 'eit minutt',
            mm: '%d minutt',
            h: 'ein time',
            hh: '%d timar',
            d: 'ein dag',
            dd: '%d dagar',
            M: 'ein mnad',
            MM: '%d mnader',
            y: 'eit r',
            yy: '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;
});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return paIn;
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
    var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'm':
                return withoutSuffix ? 'minuta' : 'minut';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix ? 'godzina' : 'godzin';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesice' : 'miesicy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months: function months(momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
        weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                        return '[W zesz niedziel o] LT';
                    case 3:
                        return '[W zesz rod o] LT';
                    case 6:
                        return '[W zesz sobot o] LT';
                    default:
                        return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: '%s temu',
            s: 'kilka sekund',
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: '1 dzie',
            dd: '%d dni',
            M: 'miesic',
            MM: translate,
            y: 'rok',
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ptBr = moment.defineLocale('pt-br', {
        months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar: {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function lastWeek() {
                return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'em %s',
            past: '%s atrs',
            s: 'poucos segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            M: 'um ms',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d'
    });

    return ptBr;
});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var pt = moment.defineLocale('pt', {
        months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function lastWeek() {
                return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'em %s',
            past: 'h %s',
            s: 'segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            M: 'um ms',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': 'minute',
            'hh': 'ore',
            'dd': 'zile',
            'MM': 'luni',
            'yy': 'ani'
        },
            separator = ' ';
        if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'peste %s',
            past: '%s n urm',
            s: 'cteva secunde',
            m: 'un minut',
            mm: relativeTimeWithPlural,
            h: 'o or',
            hh: relativeTimeWithPlural,
            d: 'o zi',
            dd: relativeTimeWithPlural,
            M: 'o lun',
            MM: relativeTimeWithPlural,
            y: 'un an',
            yy: relativeTimeWithPlural
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ro;
});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

    // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months: {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort: {
            //  CLDR  "."  ".",        ?
            format: '._._._.____._._._._.'.split('_'),
            standalone: '._.__.____._._._._.'.split('_')
        },
        weekdays: {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        //    ,   ,  ,  4 ,      
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //  
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //    
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

        // ,     
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY .',
            LLL: 'D MMMM YYYY ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function nextWeek(now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            lastWeek: function lastWeek(now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s ',
            s: ' ',
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: '',
            hh: relativeTimeWithPlural,
            d: '',
            dd: relativeTimeWithPlural,
            M: '',
            MM: relativeTimeWithPlural,
            y: '',
            yy: relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM: function isPM(input) {
            return (/^(|)$/.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-';
                case 'D':
                    return number + '-';
                case 'w':
                case 'W':
                    return number + '-';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ru;
});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = ['', '', '', '', '', '', '', '', '', '', '', ''];
    var days = ['', '', '', '', '', '', ''];

    var sd = moment.defineLocale('sd', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd [  ] LT',
            lastDay: '[] LT',
            lastWeek: '[ ] dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/,/g, '');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sd;
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var se = moment.defineLocale('se', {
        months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
        monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
        weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
        weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
        weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'MMMM D. [b.] YYYY',
            LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar: {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s geaes',
            past: 'mait %s',
            s: 'moadde sekunddat',
            m: 'okta minuhta',
            mm: '%d minuhtat',
            h: 'okta diimmu',
            hh: '%d diimmut',
            d: 'okta beaivi',
            dd: '%d beaivvit',
            M: 'okta mnnu',
            MM: '%d mnut',
            y: 'okta jahki',
            yy: '%d jagit'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    /*jshint -W100*/

    var si = moment.defineLocale('si', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'a h:mm',
            LTS: 'a h:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY MMMM D',
            LLL: 'YYYY MMMM D, a h:mm',
            LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar: {
            sameDay: '[] LT[]',
            nextDay: '[] LT[]',
            nextWeek: 'dddd LT[]',
            lastDay: '[] LT[]',
            lastWeek: '[] dddd LT[]',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s ',
            s: ' ',
            m: '',
            mm: ' %d',
            h: '',
            hh: ' %d',
            d: '',
            dd: ' %d',
            M: '',
            MM: ' %d',
            y: '',
            yy: ' %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal: function ordinal(number) {
            return number + ' ';
        },
        meridiemParse: / | |.|../,
        isPM: function isPM(input) {
            return input === '..' || input === ' ';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    return si;
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
    var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return n > 1 && n < 5;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';
            case 'm':
                // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';
            case 'mm':
                // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minty' : 'mint');
                } else {
                    return result + 'mintami';
                }
                break;
            case 'h':
                // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh':
                // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodn');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':
                // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'de' : 'dom';
            case 'dd':
                // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dn');
                } else {
                    return result + 'dami';
                }
                break;
            case 'M':
                // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
            case 'MM':
                // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
                break;
            case 'y':
                // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokom';
            case 'yy':
                // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
                break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months: months,
        monthsShort: monthsShort,
        weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[v nedeu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo tvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                        return '[minul nedeu o] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [o] LT';
                    case 3:
                        return '[minul stredu o] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [o] LT';
                    case 6:
                        return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'pred %s',
            s: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danes ob] LT',
            nextDay: '[jutri ob] LT',

            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay: '[veraj ob] LT',
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                        return '[prejnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'ez %s',
            past: 'pred %s',
            s: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sl;
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var sq = moment.defineLocale('sq', {
        months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function isPM(input) {
            return input.charAt(0) === 'M';
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Sot n] LT',
            nextDay: '[Nesr n] LT',
            nextWeek: 'dddd [n] LT',
            lastDay: '[Dje n] LT',
            lastWeek: 'dddd [e kaluar n] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'n %s',
            past: '%s m par',
            s: 'disa sekonda',
            m: 'nj minut',
            mm: '%d minuta',
            h: 'nj or',
            hh: '%d or',
            d: 'nj dit',
            dd: '%d dit',
            M: 'nj muaj',
            MM: '%d muaj',
            y: 'nj vit',
            yy: '%d vite'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var translator = {
        words: { //Different grammatical cases
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: '___________'.split('_'),
        monthsShort: '._._._.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[] [] [] LT';
                    case 3:
                        return '[] [] [] LT';
                    case 6:
                        return '[] [] [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            lastDay: '[ ] LT',
            lastWeek: function lastWeek() {
                var lastWeekDays = ['[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT'];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: ' ',
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: '',
            dd: translator.translate,
            M: '',
            MM: translator.translate,
            y: '',
            yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return srCyrl;
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function translate(number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function nextWeek() {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jue u] LT',
            lastWeek: function lastWeek() {
                var lastWeekDays = ['[prole] [nedelje] [u] LT', '[prolog] [ponedeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: 'za %s',
            past: 'pre %s',
            s: 'nekoliko sekundi',
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sr;
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var ss = moment.defineLocale('ss', {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
            sameDay: '[Namuhla nga] LT',
            nextDay: '[Kusasa nga] LT',
            nextWeek: 'dddd [nga] LT',
            lastDay: '[Itolo nga] LT',
            lastWeek: 'dddd [leliphelile] [nga] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'nga %s',
            past: 'wenteka nga %s',
            s: 'emizuzwana lomcane',
            m: 'umzuzu',
            mm: '%d emizuzu',
            h: 'lihora',
            hh: '%d emahora',
            d: 'lilanga',
            dd: '%d emalanga',
            M: 'inyanga',
            MM: '%d tinyanga',
            y: 'umnyaka',
            yy: '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var sv = moment.defineLocale('sv', {
        months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd D MMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'om %s',
            past: 'fr %s sedan',
            s: 'ngra sekunder',
            m: 'en minut',
            mm: '%d minuter',
            h: 'en timme',
            hh: '%d timmar',
            d: 'en dag',
            dd: '%d dagar',
            M: 'en mnad',
            MM: '%d mnader',
            y: 'ett r',
            yy: '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'e' : b === 1 ? 'a' : b === 2 ? 'a' : b === 3 ? 'e' : 'e';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var sw = moment.defineLocale('sw', {
        months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[leo saa] LT',
            nextDay: '[kesho saa] LT',
            nextWeek: '[wiki ijayo] dddd [saat] LT',
            lastDay: '[jana] LT',
            lastWeek: '[wiki iliyopita] dddd [saat] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s baadaye',
            past: 'tokea %s',
            s: 'hivi punde',
            m: 'dakika moja',
            mm: 'dakika %d',
            h: 'saa limoja',
            hh: 'masaa %d',
            d: 'siku moja',
            dd: 'masiku %d',
            M: 'mwezi mmoja',
            MM: 'miezi %d',
            y: 'mwaka mmoja',
            yy: 'miaka %d'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return sw;
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
    var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ta = moment.defineLocale('ta', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, HH:mm',
            LLLL: 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[ ] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: '  ',
            m: ' ',
            mm: '%d ',
            h: '  ',
            hh: '%d  ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number) {
            return number + '';
        },
        preparse: function preparse(string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function postformat(string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' '; // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ta;
});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var te = moment.defineLocale('te', {
        months: '___________'.split('_'),
        monthsShort: '._.__.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        meridiemParse: /|||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return te;
});

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var tet = moment.defineLocale('tet', {
        months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
        weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
        weekdaysMin: 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'iha %s',
            past: '%s liuba',
            s: 'minutu balun',
            m: 'minutu ida',
            mm: 'minutus %d',
            h: 'horas ida',
            hh: 'horas %d',
            d: 'loron ida',
            dd: 'loron %d',
            M: 'fulan ida',
            MM: 'fulan %d',
            y: 'tinan ida',
            yy: 'tinan %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tet;
});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var th = moment.defineLocale('th', {
        months: '___________'.split('_'),
        monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'), // yes, three characters difference
        weekdaysMin: '._._._._._._.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY  H:mm',
            LLLL: 'dddd D MMMM YYYY  H:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return input === '';
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd[ ] LT',
            lastDay: '[ ] LT',
            lastWeek: '[]dddd[ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d '
        }
    });

    return th;
});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var tlPh = moment.defineLocale('tl-ph', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'MM/D/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY HH:mm',
            LLLL: 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar: {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'sa loob ng %s',
            past: '%s ang nakalipas',
            s: 'ilang segundo',
            m: 'isang minuto',
            mm: '%d minuto',
            h: 'isang oras',
            hh: '%d oras',
            d: 'isang araw',
            dd: '%d araw',
            M: 'isang buwan',
            MM: '%d buwan',
            y: 'isang taon',
            yy: '%d taon'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlPh;
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor(number % 1000 / 100),
            ten = Math.floor(number % 100 / 10),
            one = number % 10,
            word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[one];
        }
        return word === '' ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
        monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
        monthsParseExact: true,
        weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[DaHjaj] LT',
            nextDay: '[waleS] LT',
            nextWeek: 'LLL',
            lastDay: '[waHu] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime: {
            future: translateFuture,
            past: translatePast,
            s: 'puS lup',
            m: 'wa tup',
            mm: translate,
            h: 'wa rep',
            hh: translate,
            d: 'wa jaj',
            dd: translate,
            M: 'wa jar',
            MM: translate,
            y: 'wa DIS',
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;
});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = moment.defineLocale('tr', {
        months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[bugn saat] LT',
            nextDay: '[yarn saat] LT',
            nextWeek: '[haftaya] dddd [saat] LT',
            lastDay: '[dn] LT',
            lastWeek: '[geen hafta] dddd [saat] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s nce',
            s: 'birka saniye',
            m: 'bir dakika',
            mm: '%d dakika',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gn',
            dd: '%d gn',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir yl',
            yy: '%d yl'
        },
        dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return number + '\'nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tr;
});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.

    var tzl = moment.defineLocale('tzl', {
        months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM [dallas] YYYY',
            LLL: 'D. MMMM [dallas] YYYY HH.mm',
            LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function isPM(input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar: {
            sameDay: '[oxhi ] LT',
            nextDay: '[dem ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ieiri ] LT',
            lastWeek: '[sr el] dddd [lasteu ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'osprei %s',
            past: 'ja%s',
            s: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', '' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', '' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
    }

    return tzl;
});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var tzmLatn = moment.defineLocale('tzm-latn', {
        months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'dadkh s yan %s',
            past: 'yan %s',
            s: 'imik',
            m: 'minu',
            mm: '%d minu',
            h: 'saa',
            hh: '%d tassain',
            d: 'ass',
            dd: '%d ossan',
            M: 'ayowr',
            MM: '%d iyyirn',
            y: 'asgas',
            yy: '%d isgasn'
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzmLatn;
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var tzm = moment.defineLocale('tzm', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '   %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d o',
            M: 'o',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return tzm;
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        } else if (key === 'h') {
            return withoutSuffix ? '' : '';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        };

        if (!m) {
            return weekdays['nominative'];
        }

        var nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months: {
            'format': '___________'.split('_'),
            'standalone': '___________'.split('_')
        },
        monthsShort: '___________'.split('_'),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY .',
            LLL: 'D MMMM YYYY ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar: {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function lastWeek() {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: '%s ',
            s: ' ',
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: '',
            hh: relativeTimeWithPlural,
            d: '',
            dd: relativeTimeWithPlural,
            M: '',
            MM: relativeTimeWithPlural,
            y: '',
            yy: relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function isPM(input) {
            return (/^(|)$/.test(input)
            );
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return uk;
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var months = ['', '', '', '', '', '', '', '', '', '', '', ''];
    var days = ['', '', '', '', '', '', ''];

    var ur = moment.defineLocale('ur', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function isPM(input) {
            return '' === input;
        },
        meridiem: function meridiem(hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[  ] LT',
            lastWeek: '[] dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function preparse(string) {
            return string.replace(//g, ',');
        },
        postformat: function postformat(string) {
            return string.replace(/,/g, '');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ur;
});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var uzLatn = moment.defineLocale('uz-latn', {
        months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm'
        },
        calendar: {
            sameDay: '[Bugun soat] LT [da]',
            nextDay: '[Ertaga] LT [da]',
            nextWeek: 'dddd [kuni soat] LT [da]',
            lastDay: '[Kecha soat] LT [da]',
            lastWeek: '[O\'tgan] dddd [kuni soat] LT [da]',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'Yaqin %s ichida',
            past: 'Bir necha %s oldin',
            s: 'soniya',
            m: 'bir daqiqa',
            mm: '%d daqiqa',
            h: 'bir soat',
            hh: '%d soat',
            d: 'bir kun',
            dd: '%d kun',
            M: 'bir oy',
            MM: '%d oy',
            y: 'bir yil',
            yy: '%d yil'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return uzLatn;
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var uz = moment.defineLocale('uz', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd [ ] LT []',
            lastDay: '[ ] LT []',
            lastWeek: '[] dddd [ ] LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: '  %s ',
            s: '',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var vi = moment.defineLocale('vi', {
        months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact: true,
        weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function isPM(input) {
            return (/^ch$/i.test(input)
            );
        },
        meridiem: function meridiem(hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [nm] YYYY',
            LLL: 'D MMMM [nm] YYYY HH:mm',
            LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
            l: 'DD/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ti',
            past: '%s trc',
            s: 'vi giy',
            m: 'mt pht',
            mm: '%d pht',
            h: 'mt gi',
            hh: '%d gi',
            d: 'mt ngy',
            dd: '%d ngy',
            M: 'mt thng',
            MM: '%d thng',
            y: 'mt nm',
            yy: '%d nm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function ordinal(number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;
});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var xPseudo = moment.defineLocale('x-pseudo', {
        months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
        monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
        monthsParseExact: true,
        weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
        weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
        weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[T~d~ t] LT',
            nextDay: '[T~m~rr~w t] LT',
            nextWeek: 'dddd [t] LT',
            lastDay: '[~st~rd~ t] LT',
            lastWeek: '[L~st] dddd [t] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '~ %s',
            past: '%s ~g',
            s: ' ~fw ~sc~ds',
            m: ' ~m~t',
            mm: '%d m~~ts',
            h: '~ h~r',
            hh: '%d h~rs',
            d: ' ~d',
            dd: '%d d~s',
            M: ' ~m~th',
            MM: '%d m~t~hs',
            y: ' ~r',
            yy: '%d ~rs'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function ordinal(number) {
            var b = number % 10,
                output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return xPseudo;
});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var yo = moment.defineLocale('yo', {
        months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
        monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
        weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
        weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
        weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A'
        },
        calendar: {
            sameDay: '[Oni ni] LT',
            nextDay: '[la ni] LT',
            nextWeek: 'dddd [s ton\'b] [ni] LT',
            lastDay: '[Ana ni] LT',
            lastWeek: 'dddd [s tol] [ni] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'ni %s',
            past: '%s kja',
            s: 'isju aaya die',
            m: 'isju kan',
            mm: 'isju %d',
            h: 'wakati kan',
            hh: 'wakati %d',
            d: 'j kan',
            dd: 'j %d',
            M: 'osu kan',
            MM: 'osu %d',
            y: 'dun kan',
            yy: 'dun %d'
        },
        dayOfMonthOrdinalParse: /j\s\d{1,2}/,
        ordinal: 'j %d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return yo;
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var zhCn = moment.defineLocale('zh-cn', {
        months: '___________'.split('_'),
        monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYYMMMD',
            LL: 'YYYYMMMD',
            LLL: 'YYYYMMMDAhmm',
            LLLL: 'YYYYMMMDddddAhmm',
            l: 'YYYYMMMD',
            ll: 'YYYYMMMD',
            lll: 'YYYYMMMD HH:mm',
            llll: 'YYYYMMMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[]LT',
            nextDay: '[]LT',
            nextWeek: '[]ddddLT',
            lastDay: '[]LT',
            lastWeek: '[]ddddLT',
            sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d '
        },
        week: {
            // GB/T 7408-1994ISO 8601:1988
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zhCn;
});

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var zhHk = moment.defineLocale('zh-hk', {
        months: '___________'.split('_'),
        monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYYMMMD',
            LL: 'YYYYMMMD',
            LLL: 'YYYYMMMD HH:mm',
            LLLL: 'YYYYMMMDdddd HH:mm',
            l: 'YYYYMMMD',
            ll: 'YYYYMMMD',
            lll: 'YYYYMMMD HH:mm',
            llll: 'YYYYMMMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[]LT',
            nextDay: '[]LT',
            nextWeek: '[]ddddLT',
            lastDay: '[]LT',
            lastWeek: '[]ddddLT',
            sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d '
        }
    });

    return zhHk;
});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(0)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.moment);
})(this, function (moment) {
    'use strict';

    var zhTw = moment.defineLocale('zh-tw', {
        months: '___________'.split('_'),
        monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYYMMMD',
            LL: 'YYYYMMMD',
            LLL: 'YYYYMMMD HH:mm',
            LLLL: 'YYYYMMMDdddd HH:mm',
            l: 'YYYYMMMD',
            ll: 'YYYYMMMD',
            lll: 'YYYYMMMD HH:mm',
            llll: 'YYYYMMMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function meridiemHour(hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function meridiem(hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[]LT',
            nextDay: '[]LT',
            nextWeek: '[]ddddLT',
            lastDay: '[]LT',
            lastWeek: '[]ddddLT',
            sameElse: 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function ordinal(number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '1 ',
            mm: '%d ',
            h: '1 ',
            hh: '%d ',
            d: '1 ',
            dd: '%d ',
            M: '1 ',
            MM: '%d ',
            y: '1 ',
            yy: '%d '
        }
    });

    return zhTw;
});

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};
//# sourceMappingURL=Observer.js.map

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(18);
var queue_1 = __webpack_require__(741);
var Subscription_1 = __webpack_require__(50);
var observeOn_1 = __webpack_require__(343);
var ObjectUnsubscribedError_1 = __webpack_require__(143);
var SubjectSubscription_1 = __webpack_require__(338);
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscription = Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        } else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if (now - _events[spliceCount].time < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject);
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}();
//# sourceMappingURL=ReplaySubject.js.map

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(50);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;
//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(51);
var Observable_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {PromiseLike<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        } else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable);
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}
//# sourceMappingURL=PromiseObservable.js.map

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var isScheduler_1 = __webpack_require__(72);
var ArrayObservable_1 = __webpack_require__(66);
var mergeAll_1 = __webpack_require__(138);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;
//# sourceMappingURL=concat.js.map

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var ArrayObservable_1 = __webpack_require__(66);
var mergeAll_1 = __webpack_require__(138);
var isScheduler_1 = __webpack_require__(72);
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = __webpack_require__(52);
var OuterSubscriber_1 = __webpack_require__(49);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;
//# sourceMappingURL=mergeMap.js.map

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var Notification_1 = __webpack_require__(667);
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}
exports.observeOn = observeOn;
var ObserveOnOperator = function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}();
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber);
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}();
exports.ObserveOnMessage = ObserveOnMessage;
//# sourceMappingURL=observeOn.js.map

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(51);
var Action_1 = __webpack_require__(738);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;
//# sourceMappingURL=AsyncAction.js.map

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = __webpack_require__(668);
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;
//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error);
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=TimeoutError.js.map

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};
//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;
//# sourceMappingURL=isDate.js.map

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray_1 = __webpack_require__(80);
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
exports.isNumeric = isNumeric;
;
//# sourceMappingURL=isNumeric.js.map

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;
//# sourceMappingURL=isObject.js.map

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;
//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* tslint:disable:no-empty */

function noop() {}
exports.noop = noop;
//# sourceMappingURL=noop.js.map

/***/ }),
/* 353 */
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 354 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MockMediaKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return requestMediaKeySystemAccess; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_bytes__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__constants_js__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__keySystemAccess_js__ = __webpack_require__(355);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













// Wrap "MediaKeys.prototype.update" form an event based system to a
// Promise based function.
function wrapUpdate(memUpdate, sessionObj) {
  function KeySessionError() {
    var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (err.errorCode) {
      err = {
        systemCode: err.systemCode,
        code: err.errorCode.code
      };
    }
    this.name = "KeySessionError";
    this.mediaKeyError = err;
    this.message = "MediaKeyError code:" + err.code + " and systemCode:" + err.systemCode;
  }
  KeySessionError.prototype = new Error();

  return function (license, sessionId) {
    var session = typeof sessionObj == "function" ? sessionObj.call(this) : this;

    var keys = __WEBPACK_IMPORTED_MODULE_7__events_js__["i" /* onKeyAdded$ */](session);
    var errs = __WEBPACK_IMPORTED_MODULE_7__events_js__["j" /* onKeyError$ */](session).map(function (evt) {
      throw new KeySessionError(session.error || evt);
    });

    try {
      memUpdate.call(this, license, sessionId);
      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(keys, errs).take(1);
    } catch (e) {
      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].throw(e);
    }
  };
}

var requestMediaKeySystemAccess = void 0;
if (navigator.requestMediaKeySystemAccess) {
  requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(navigator.requestMediaKeySystemAccess(a, b));
  };
}

var MockMediaKeys = function MockMediaKeys() {};

// Browser without any MediaKeys object: A mock for MediaKey and
// MediaKeySession are created, and the <video>.addKey api is used to
// pass the license.
//
// This is for Chrome with unprefixed EME api
if (!requestMediaKeySystemAccess && __WEBPACK_IMPORTED_MODULE_6__constants_js__["f" /* HTMLVideoElement_ */].prototype.webkitGenerateKeyRequest) {
  // Mock MediaKeySession interface for old chrome implementation
  // of the EME specifications
  var MockMediaKeySession = function MockMediaKeySession(video, keySystem) {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].call(this);

    this.sessionId = "";
    this._vid = video;
    this._key = keySystem;
    this._con = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(__WEBPACK_IMPORTED_MODULE_7__events_js__["k" /* onKeyMessage$ */](video), __WEBPACK_IMPORTED_MODULE_7__events_js__["i" /* onKeyAdded$ */](video), __WEBPACK_IMPORTED_MODULE_7__events_js__["j" /* onKeyError$ */](video)).subscribe(function (evt) {
      return _this.trigger(evt.type, evt);
    });
  };

  MockMediaKeySession.prototype = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({
    generateRequest: function generateRequest(initDataType, initData) {
      this._vid.webkitGenerateKeyRequest(this._key, initData);
    },

    update: wrapUpdate(function (license, sessionId) {
      if (this._key.indexOf("clearkey") >= 0) {
        var json = JSON.parse(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_bytes__["a" /* bytesToStr */])(license));
        var key = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_bytes__["b" /* strToBytes */])(atob(json.keys[0].k));
        var kid = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_bytes__["b" /* strToBytes */])(atob(json.keys[0].kid));
        this._vid.webkitAddKey(this._key, key, kid, sessionId);
      } else {
        this._vid.webkitAddKey(this._key, license, null, sessionId);
      }
      this.sessionId = sessionId;
    }),

    close: function close() {
      if (this._con) {
        this._con.unsubscribe();
      }
      this._con = null;
      this._vid = null;
    }
  }, __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].prototype);

  MockMediaKeys = function MockMediaKeys(keySystem) {
    this.ks_ = keySystem;
  };

  MockMediaKeys.prototype = {
    _setVideo: function _setVideo(vid) {
      this._vid = vid;
    },
    createSession: function createSession() /* sessionType */{
      return new MockMediaKeySession(this._vid, this.ks_);
    }
  };

  var isTypeSupported = function isTypeSupported(keyType) {
    // get any <video> element from the DOM or create one
    // and try the `canPlayType` method
    var video = document.querySelector("video") || document.createElement("video");
    if (video && video.canPlayType) {
      return !!video.canPlayType("video/mp4", keyType);
    } else {
      return false;
    }
  };

  requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
    if (!isTypeSupported(keyType)) {
      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].throw();
    }

    for (var i = 0; i < keySystemConfigurations.length; i++) {
      var keySystemConfiguration = keySystemConfigurations[i];
      var videoCapabilities = keySystemConfiguration.videoCapabilities,
          audioCapabilities = keySystemConfiguration.audioCapabilities,
          initDataTypes = keySystemConfiguration.initDataTypes,
          sessionTypes = keySystemConfiguration.sessionTypes,
          distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier,
          persistentState = keySystemConfiguration.persistentState;


      var supported = true;
      supported = supported && (!initDataTypes || !!initDataTypes.filter(function (initDataType) {
        return initDataType === "cenc";
      })[0]);
      supported = supported && (!sessionTypes || sessionTypes.filter(function (sessionType) {
        return sessionType === "temporary";
      }).length === sessionTypes.length);
      supported = supported && distinctiveIdentifier !== "required";
      supported = supported && persistentState !== "required";

      if (supported) {
        var keySystemConfigurationResponse = {
          videoCapabilities: videoCapabilities,
          audioCapabilities: audioCapabilities,
          initDataTypes: ["cenc"],
          distinctiveIdentifier: "not-allowed",
          persistentState: "not-allowed",
          sessionTypes: ["temporary"]
        };

        return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of(new __WEBPACK_IMPORTED_MODULE_8__keySystemAccess_js__["a" /* default */](keyType, new MockMediaKeys(keyType), keySystemConfigurationResponse));
      }
    }

    return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].throw();
  };
}

// A MediaKeys object exist (or a mock) but no create function is
// available. We need to add recent apis using Promises to mock the
// most recent MediaKeys apis.
// This is for IE11
else if (__WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */] && !requestMediaKeySystemAccess) {
    var SessionProxy = function SessionProxy(mk) {
      __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].call(this);
      this.sessionId = "";
      this._mk = mk;
    };

    SessionProxy.prototype = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({
      generateRequest: function generateRequest(initDataType, initData) {
        var _this2 = this;

        this._ss = this._mk.memCreateSession("video/mp4", initData);
        this._con = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(__WEBPACK_IMPORTED_MODULE_7__events_js__["k" /* onKeyMessage$ */](this._ss), __WEBPACK_IMPORTED_MODULE_7__events_js__["i" /* onKeyAdded$ */](this._ss), __WEBPACK_IMPORTED_MODULE_7__events_js__["j" /* onKeyError$ */](this._ss)).subscribe(function (evt) {
          return _this2.trigger(evt.type, evt);
        });
      },

      update: wrapUpdate(function (license, sessionId) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_assert__["a" /* default */])(this._ss);
        this._ss.update(license, sessionId);
        this.sessionId = sessionId;
      }, function () {
        return this._ss;
      }),

      close: function close() {
        if (this._ss) {
          this._ss.close();
          this._ss = null;
        }
        if (this._con) {
          this._con.unsubscribe();
          this._con = null;
        }
      }
    }, __WEBPACK_IMPORTED_MODULE_2__utils_eventemitter__["a" /* default */].prototype);

    if (!__WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype) {
      __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype = {};
    }

    // on IE11, each created session needs to be created on a new
    // MediaKeys object
    __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype.alwaysRenew = true;
    __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype.memCreateSession = __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype.createSession;
    __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].prototype.createSession = function () {
      return new SessionProxy(this);
    };

    requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
      if (!__WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */].isTypeSupported(keyType)) {
        return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].throw();
      }

      for (var i = 0; i < keySystemConfigurations.length; i++) {
        var keySystemConfiguration = keySystemConfigurations[i];
        var videoCapabilities = keySystemConfiguration.videoCapabilities,
            audioCapabilities = keySystemConfiguration.audioCapabilities,
            initDataTypes = keySystemConfiguration.initDataTypes,
            distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;


        var supported = true;
        supported = supported && (!initDataTypes || !!initDataTypes.filter(function (idt) {
          return idt === "cenc";
        })[0]);
        supported = supported && distinctiveIdentifier !== "required";

        if (supported) {
          var keySystemConfigurationResponse = {
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            initDataTypes: ["cenc"],
            distinctiveIdentifier: "not-allowed",
            persistentState: "required",
            sessionTypes: ["temporary", "persistent-license"]
          };

          return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of(new __WEBPACK_IMPORTED_MODULE_8__keySystemAccess_js__["a" /* default */](keyType, new __WEBPACK_IMPORTED_MODULE_6__constants_js__["g" /* MediaKeys_ */](keyType), keySystemConfigurationResponse));
        }
      }

      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].throw();
    };
  }



/***/ }),
/* 355 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// @implement interface MediaKeySystemAccess

var KeySystemAccess = function () {
  function KeySystemAccess(keyType, mediaKeys, mediaKeySystemConfiguration) {
    _classCallCheck(this, KeySystemAccess);

    this._keyType = keyType;
    this._mediaKeys = mediaKeys;
    this._configuration = mediaKeySystemConfiguration;
  }

  KeySystemAccess.prototype.createMediaKeys = function createMediaKeys() {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(this._mediaKeys);
  };

  KeySystemAccess.prototype.getConfiguration = function getConfiguration() {
    return this._configuration;
  };

  _createClass(KeySystemAccess, [{
    key: "keySystem",
    get: function get() {
      return this._keyType;
    }
  }]);

  return KeySystemAccess;
}();

/* harmony default export */ __webpack_exports__["a"] = (KeySystemAccess);

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
var EWMA = function () {
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // (half-life = log(1/2) / log(Decay Factor)
    this._alpha = Math.exp(Math.log(0.5) / halfLife);

    this._lastEstimate = 0;

    this._totalWeight = 0;
  }

  EWMA.prototype.addSample = function addSample(weight, value) {
    var adjAlpha = Math.pow(this._alpha, weight);
    var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;
    if (!isNaN(newEstimate)) {
      this._lastEstimate = newEstimate;
      this._totalWeight += weight;
    }
  };

  EWMA.prototype.getEstimate = function getEstimate() {
    var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
    return this._lastEstimate / zeroFactor;
  };

  return EWMA;
}();

/* harmony default export */ __webpack_exports__["a"] = (EWMA);

/***/ }),
/* 357 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return createEME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getCurrentKeySystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dispose; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__globals_js__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__server_certificate_js__ = __webpack_require__(767);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__set_media_keys_js__ = __webpack_require__(772);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__session_js__ = __webpack_require__(768);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__key_system_js__ = __webpack_require__(766);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















// Persisted singleton instance of MediaKeys. We do not allow multiple
// CDM instances.
var instanceInfos = {
  $mediaKeys: null, // MediaKeys instance
  $mediaKeySystemConfiguration: null, // active MediaKeySystemConfiguration
  $keySystem: null,
  $videoElement: null
};

/**
 * Call the createMediaKeys API and cast it to an observable.
 * @param {MediaKeySystemAccess} keySystemAccess
 * @returns {Observable}
 */
function createMediaKeysObs(keySystemAccess) {
  // MediaKeySystemAccess.prototype.createMediaKeys returns a promise
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_castToObservable_js__["a" /* default */])(keySystemAccess.createMediaKeys());
}

/**
 * Function triggered when both:
 *   - the ``encrypted`` event has been received.
 *   - a compatible key system configuration has been found.
 *
 * Calls all subsequent EME APIs.
 * @param {MediaEncryptedEvent} encryptedEvent
 * @param {Object} compatibleKeySystem
 * @param {MediaKeySystemAccess} compatibleKeySystem.keySystemAccess
 * @param {Object} compatibleKeySystem.keySystem - config given by the user
 * @returns {Observable}
 */
function handleEncryptedEvents(encryptedEvent, _ref, video, errorStream) {
  var keySystem = _ref.keySystem,
      keySystemAccess = _ref.keySystemAccess;

  if (keySystem.persistentLicense) {
    __WEBPACK_IMPORTED_MODULE_5__globals_js__["a" /* $storedSessions */].setStorage(keySystem.licenseStorage);
  }

  __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("eme: encrypted event", encryptedEvent);
  return createMediaKeysObs(keySystemAccess).mergeMap(function (mediaKeys) {
    // set server certificate if set in API
    var serverCertificate = keySystem.serverCertificate;

    var setCertificate$ = serverCertificate && typeof mediaKeys.setServerCertificate === "function" ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__server_certificate_js__["a" /* trySettingServerCertificate */])(mediaKeys, serverCertificate, errorStream) : __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();

    var mksConfig = keySystemAccess.getConfiguration();

    var setMediaKeys$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__set_media_keys_js__["a" /* default */])(mediaKeys, mksConfig, video, keySystem, instanceInfos);

    var initData = new Uint8Array(encryptedEvent.initData);
    var manageSessionCreation$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__session_js__["a" /* default */])(mediaKeys, mksConfig, keySystem, encryptedEvent.initDataType, initData, errorStream);

    return setCertificate$.concat(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(setMediaKeys$, manageSessionCreation$));
  });
}

/**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} video
 * @param {Object} keySystems
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createEME(video, keySystems, errorStream) {
  if (true) {
    keySystems.forEach(function (ks) {
      return __WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */].iface(ks, "keySystem", {
        getLicense: "function",
        type: "string"
      });
    });
  }

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__compat_events_js__["f" /* onEncrypted$ */])(video), // wait for "encrypted" event
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__key_system_js__["a" /* default */])(keySystems, instanceInfos)).take(1).mergeMap(function (_ref2) {
    var evt = _ref2[0],
        ks = _ref2[1];

    return handleEncryptedEvents(evt, ks, video, errorStream);
  });
}

/**
 * Free up all ressources taken by the EME management.
 */
function dispose() {
  // Remove MediaKey before to prevent MediaKey error
  // if other instance is creating after dispose
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__set_media_keys_js__["b" /* disposeMediaKeys */])(instanceInfos.$videoElement).subscribe(function () {});
  instanceInfos.$mediaKeys = null;
  instanceInfos.$keySystem = null;
  instanceInfos.$videoElement = null;
  instanceInfos.$mediaKeySystemConfiguration = null;
  __WEBPACK_IMPORTED_MODULE_5__globals_js__["b" /* $loadedSessions */].dispose();
}

/**
 * Returns the name of the current key system used.
 * @returns {string}
 */
function getCurrentKeySystem() {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__key_system_js__["b" /* getKeySystem */])(instanceInfos);
}



/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SessionSet = function () {
  function SessionSet() {
    _classCallCheck(this, SessionSet);

    this._entries = [];
  }

  SessionSet.prototype.find = function find(func) {
    for (var i = 0; i < this._entries.length; i++) {
      if (func(this._entries[i]) === true) {
        return this._entries[i];
      }
    }
    return null;
  };

  return SessionSet;
}();

/* harmony default export */ __webpack_exports__["a"] = (SessionSet);

/***/ }),
/* 359 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert given buffer to a 32bit integer hash
 * @param {Array|TypedArray} buffer
 * @returns {Number}
 */
function hashBuffer(buffer) {
  var hash = 0;
  var char = void 0;
  for (var i = 0; i < buffer.length; i++) {
    char = buffer[i];
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

/**
 * Convert given init data to a 32bit integer hash
 * @param {Array|TypedArray|number} buffer
 * @returns {Number}
 */
function hashInitData(initData) {
  if (typeof initData == "number") {
    return initData;
  } else {
    return hashBuffer(initData);
  }
}

/* harmony default export */ __webpack_exports__["a"] = (hashInitData);

/***/ }),
/* 360 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parsers_containers_isobmff_js__ = __webpack_require__(106);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Get precize start and duration of a segment from ISOBMFF.
 *   1. get start from tfdt
 *   2. get duration from trun
 *   3. if at least one is missing, get both informations from sidx
 *   4. As a fallback take segment infos.
 * @param {Segment} segment
 * @param {UInt8Array} buffer - The entire isobmff container
 * @param {Array.<Object>} [sidxSegments=[]] - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {Object} initInfos
 * @returns {Object}
 */
function getISOBMFFTimingInfos(segment, buffer, sidxSegments, initInfos) {
  if (!sidxSegments) {
    sidxSegments = [];
  }
  var startTime = void 0,
      duration = void 0;

  var decodeTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parsers_containers_isobmff_js__["e" /* parseTfdt */])(buffer);
  var trunDuration = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parsers_containers_isobmff_js__["f" /* getDurationFromTrun */])(buffer);

  var timescale = initInfos && initInfos.timescale > 0 ? initInfos.timescale : segment.timescale;

  // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.
  var maxDecodeTimeDelta = void 0;

  // Scaled start time and duration as announced in the segment data
  var segmentDuration = void 0,
      segmentStart = void 0;

  if (timescale === segment.timescale) {
    maxDecodeTimeDelta = Math.min(0.9 * timescale, segment.duration / 4);
    segmentStart = segment.time;
    segmentDuration = segment.duration;
  } else {
    maxDecodeTimeDelta = Math.min(0.9 * timescale, segment.duration / segment.timescale * timescale / 4);
    segmentStart = segment.time / segment.timescale * timescale;
    segmentDuration = segment.duration / segment.timescale * timescale;
  }

  if (decodeTime >= 0 && (segmentStart == null || Math.abs(decodeTime - segmentStart) <= maxDecodeTimeDelta)) {
    startTime = decodeTime;
  }

  if (trunDuration >= 0 && (segmentDuration == null || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
    duration = trunDuration;
  }

  if (startTime == null) {
    if (sidxSegments.length === 1) {
      var sidxStart = sidxSegments[0].time;
      if (sidxStart >= 0 && (segmentStart == null || Math.abs(segmentStart - sidxStart) <= maxDecodeTimeDelta)) {
        var sidxTimescale = sidxSegments[0].timescale;
        if (sidxTimescale != null && sidxTimescale !== timescale) {
          startTime = sidxStart / sidxTimescale * timescale;
        } else {
          startTime = sidxStart;
        }
      } else {
        startTime = segmentStart;
      }
    } else {
      startTime = segmentStart;
    }
  }

  if (duration == null) {
    if (sidxSegments.length === 1) {
      var sidxDuration = sidxSegments[0].duration;
      if (sidxDuration >= 0 && (segmentDuration == null || Math.abs(segmentDuration - sidxDuration) <= maxDecodeTimeDelta)) {
        var _sidxTimescale = sidxSegments[0].timescale;
        if (_sidxTimescale != null && _sidxTimescale !== timescale) {
          duration = sidxDuration / _sidxTimescale * timescale;
        } else {
          duration = sidxDuration;
        }
      } else {
        duration = segmentDuration;
      }
    } else {
      duration = segmentDuration;
    }
  }

  if (true) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(startTime != null);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(duration != null);
  }

  return {
    timescale: timescale,
    time: startTime || 0,
    duration: duration || 0
  };
}

/* harmony default export */ __webpack_exports__["a"] = (getISOBMFFTimingInfos);

/***/ }),
/* 361 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return parseString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return parseFrameRate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return parseByteRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return parseBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return parseDateTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return parseDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return parseIntOrBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return parseRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return reduceChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getLastLiveTimeReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isHardOfHearing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isVisuallyImpaired; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return inferAdaptationType; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// XML-Schema
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>




var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
var frameRateRe = /([0-9]+)(\/([0-9]+))?/;

var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];

/**
 * @param {Object} index
 * @returns {Number}
 */
function calculateIndexLastLiveTimeReference(index) {
  if (index.indexType === "timeline") {
    var _index$timeline = index.timeline[index.timeline.length - 1],
        ts = _index$timeline.ts,
        r = _index$timeline.r,
        d = _index$timeline.d;

    // TODO FIXME does that make sense?

    var securityTime = Math.min(Math.max(d / index.timescale, 5), 10);
    return (ts + (r + 1) * d) / index.timescale - securityTime;
  }
  // By default (e.g. for templates), live Edge is right now - 5s
  return Date.now() / 1000 - 5;
}

/**
 * Parse MPD string attributes.
 * @param {string} str
 * @returns {string} - the same string
 */
function parseString(str) {
  return str;
}

/**
 * Parse MPD boolean attributes.
 * @param {string}
 * @returns {Boolean}
 */
function parseBoolean(str) {
  return str == "true";
}

/**
 * Parse some MPD attributes.
 * @param {string}
 * @returns {Boolean|Number}
 */
function parseIntOrBoolean(str) {
  if (str == "true") {
    return true;
  }
  if (str == "false") {
    return false;
  }
  return parseInt(str);
}

/**
 * Parse MPD date attributes.
 * @param {string}
 * @returns {Date}
 */
function parseDateTime(str) {
  return new Date(Date.parse(str));
}

/**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string}
 * @returns {Number}
 */
function parseDuration(date) {
  if (!date) {
    return 0;
  }

  var match = iso8601Duration.exec(date);
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(match, date + " is not a valid ISO8601 duration");

  return parseFloat(match[2] || 0) * 365 * 24 * 60 * 60 + parseFloat(match[4] || 0) * 30 * 24 * 60 * 60 + // not precise +
  parseFloat(match[6] || 0) * 24 * 60 * 60 + parseFloat(match[8] || 0) * 60 * 60 + parseFloat(match[10] || 0) * 60 + parseFloat(match[12] || 0);
}

/**
 * Parse MPD frame rate attributes.
 * -1 if the frameRate could not be parsed,
 * @param {string} str
 * @returns {Number}
 */
function parseFrameRate(str) {
  var match = frameRateRe.exec(str);
  if (!match) {
    return -1;
  }

  var nom = parseInt(match[1]) || 0;
  var den = parseInt(match[2]) || 0;
  return den > 0 ? nom / den : nom;
}

/**
 * Parse MPD ratio attributes.
 * @param {string} str
 * @returns {string}
 */
function parseRatio(str) {
  return str;
}

/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */
function parseByteRange(str) {
  var match = rangeRe.exec(str);
  if (!match) {
    return null;
  } else {
    return [+match[1], +match[2]];
  }
}

/**
 * Reduce on each immediate children from the Document object given.
 * @param {Document} root
 * @param {Function} fn - Will be called on each children with the following
 * arguments:
 *   1. the reducer's accumulator
 *   2. the current node's name
 *   3. the current node Document Object
 * @param {*} init - the initial value for the accumulator
 * @returns {*} - the accumulator
 */
function reduceChildren(root, fn, init) {
  var node = root.firstElementChild,
      r = init;
  while (node) {
    r = fn(r, node.nodeName, node);
    node = node.nextElementSibling;
  }
  return r;
}

/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isVisuallyImpaired(accessibility) {
  if (!accessibility) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === 1;
}

/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Object} adaptation
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
function inferAdaptationType(adaptation) {
  var _adaptation$mimeType = adaptation.mimeType,
      mimeType = _adaptation$mimeType === undefined ? "" : _adaptation$mimeType;

  var topLevel = mimeType.split("/")[0];
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(KNOWN_ADAPTATION_TYPES, topLevel)) {
    return topLevel;
  }

  if (mimeType === "application/bif") {
    return "image";
  }

  if (mimeType === "application/ttml+xml") {
    return "text";
  }

  // manage DASH-IF mp4-embedded subtitles and metadata
  if (mimeType === "application/mp4") {
    var role = adaptation.role;

    if (role) {
      if (role.schemeIdUri === "urn:mpeg:dash:role:2011" && role.value === "subtitle") {
        return "text";
      }
    }
    return "metadata";
  }

  // take 1st representation's mimetype as default
  var _adaptation$represent = adaptation.representations,
      representations = _adaptation$represent === undefined ? [] : _adaptation$represent;

  if (representations.length) {
    var firstReprMimeType = representations[0].mimeType;
    var _topLevel = firstReprMimeType.split("/")[0];
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(KNOWN_ADAPTATION_TYPES, _topLevel)) {
      return _topLevel;
    }
  }

  // TODO infer from representations' codecs?
  return "unknown";
}

/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isHardOfHearing(accessibility) {
  if (!accessibility) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === 2;
}

/**
 * Returns "last time of reference" from the adaptation given, considering a
 * live content.
 * Undefined if a time could not be found.
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 *
 * This is done to calculate a liveGap which is valid for the whole manifest,
 * even in weird ones.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
var getLastLiveTimeReference = function getLastLiveTimeReference(adaptation) {
  // Here's how we do, for each possibility:
  //  1. only the adaptation has an index (no representation has):
  //    - returns the index last time reference
  //
  //  2. every representations have an index:
  //    - returns minimum for every representations
  //
  //  3. not all representations have an index but the adaptation has
  //    - returns minimum between all representations and the adaptation
  //
  //  4. no index for 1+ representation(s) and no adaptation index:
  //    - returns undefined
  //
  //  5. Invalid index found somewhere:
  //    - returns undefined

  if (!adaptation) {
    return;
  }

  var representations = adaptation.representations || [];
  var representationsWithIndex = representations.filter(function (r) {
    return r && r.index;
  });

  if (!representations.length) {
    return calculateIndexLastLiveTimeReference(adaptation.index);
  }

  var representationsMin = Math.min.apply(Math, representationsWithIndex.map(function (r) {
    return calculateIndexLastLiveTimeReference(r.index);
  }));

  // should not happen, means invalid index data has been found
  if (isNaN(representationsMin)) {
    return;
  }

  if (representations.length === representationsWithIndex.length) {
    return representationsMin;
  }

  if (adaptation.index) {
    var adaptationRef = calculateIndexLastLiveTimeReference(adaptation.index);
    return Math.min(representationsMin, adaptationRef);
  }
};



/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_request__ = __webpack_require__(160);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function mapRequestResponses(_ref) {
  var type = _ref.type,
      value = _ref.value;

  if (type === "response") {
    return {
      type: "response",
      value: {
        responseData: value.responseData,
        size: value.size,
        duration: value.receivedTime - value.sentTime,
        url: value.url
      }
    };
  }

  return {
    type: "progress",
    value: {
      size: value.loadedSize,
      totalSize: value.totalSize,
      duration: value.currentTime - value.sentTime,
      url: value.url
    }
  };
}

function doParsedRequest(requestData) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_request__["a" /* default */])(requestData).map(mapRequestResponses);
}

/* harmony default export */ __webpack_exports__["a"] = (doParsedRequest);

/***/ }),
/* 363 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return byteRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return extractISML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return extractToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return replaceToken; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return resolveManifest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return buildSegmentURL; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ISM_REG = /\.(isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;

function byteRange(_ref) {
  var start = _ref[0],
      end = _ref[1];

  if (!end || end === Infinity) {
    return "bytes=" + +start + "-";
  } else {
    return "bytes=" + +start + "-" + +end;
  }
}

/**
 * TODO Remove this logic completely from the player
 */
function extractISML(_ref2) {
  var responseData = _ref2.responseData;

  return responseData.getElementsByTagName("media")[0].getAttribute("src");
}

/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */
function extractToken(url) {
  var tokenMatch = url.match(TOKEN_REG);
  return tokenMatch && tokenMatch[1] || "";
}

/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */
function replaceToken(url, token) {
  if (token) {
    return url.replace(TOKEN_REG, "?token=" + token);
  } else {
    return url.replace(TOKEN_REG, "");
  }
}

function resolveManifest(url) {
  var ismMatch = url.match(ISM_REG);
  if (ismMatch) {
    return url.replace(ismMatch[1], ismMatch[1] + "/manifest");
  } else {
    return url;
  }
}

function buildSegmentURL(url, representation, segment) {
  return url.replace(/\{bitrate\}/g, representation.bitrate).replace(/\{start time\}/g, segment.time);
}



/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_bytes__ = __webpack_require__(84);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */
function parseBif(buf) {
  var pos = 0;

  var length = buf.length;
  var fileFormat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["a" /* bytesToStr */])(buf.subarray(pos, pos + 8));pos += 8;

  var minorVersion = buf[pos];pos += 1;
  var majorVersion = buf[pos];pos += 1;
  var patchVersion = buf[pos];pos += 1;
  var increVersion = buf[pos];pos += 1;

  var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");

  var imageCount = buf[pos] + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["c" /* le4toi */])(buf, pos + 1);pos += 4;
  var timescale = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["c" /* le4toi */])(buf, pos);pos += 4;

  var format = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["a" /* bytesToStr */])(buf.subarray(pos, pos + 4));pos += 4;

  var width = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["d" /* le2toi */])(buf, pos);pos += 2;
  var height = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["d" /* le2toi */])(buf, pos);pos += 2;

  var aspectRatio = [buf[pos], buf[pos + 1]].join(":");pos += 2;

  var isVod = buf[pos] === 1;pos += 1;

  // bytes 0x1F to 0x40 is unused data for now
  pos = 0x40;

  var thumbs = [];
  var currentImage = void 0,
      currentTs = 0;

  if (!imageCount) {
    throw new Error("bif: no images to parse");
  }

  while (pos < length) {
    var currentImageIndex = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["c" /* le4toi */])(buf, pos);pos += 4;
    var currentImageOffset = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_bytes__["c" /* le4toi */])(buf, pos);pos += 4;

    if (currentImage) {
      var index = currentImage.index;
      var duration = timescale;
      var ts = currentTs;
      var data = buf.subarray(currentImage.offset, currentImageOffset);

      thumbs.push({ index: index, duration: duration, ts: ts, data: data });

      currentTs += timescale;
    }

    if (currentImageIndex === 0xffffffff) {
      break;
    }

    currentImage = {
      index: currentImageIndex,
      offset: currentImageOffset
    };
  }

  return {
    fileFormat: fileFormat,
    version: version,
    imageCount: imageCount,
    timescale: timescale,
    format: format,
    width: width,
    height: height,
    aspectRatio: aspectRatio,
    isVod: isVod,
    thumbs: thumbs
  };
}

/* harmony default export */ __webpack_exports__["a"] = (parseBif);

/***/ }),
/* 365 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTimestamp;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number}
 */
function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":");
  if (splittedTS[2]) {
    var hours = parseInt(splittedTS[0], 10);
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[2].replace(",", "."), 10);
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return;
    }
    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}

/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getParameters;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns global parameters from a TTML Document
 * TODO Missing parameters.
 * @param {Node} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object} params
 * @returns {Number} params.frameRate
 * @returns {Number} params.subFrameRate
 * @returns {Number} params.tickRate
 * @returns {string} params.spaceStyle
 */
function getParameters(tt) {
  var parsedFrameRate = tt.getAttribute("ttp:frameRate");
  var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
  var parsedTickRate = tt.getAttribute("ttp:tickRate");
  var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
  var parsedSpaceStyle = tt.getAttribute("xml:space");

  if (parsedSpaceStyle && parsedSpaceStyle !== "default" && parsedSpaceStyle !== "preserve") {
    throw new Error("Invalid spacing style");
  }

  var nbFrameRate = Number(parsedFrameRate) || 30;
  var nbSubFrameRate = Number(parsedSubFrameRate) || 1;
  var nbTickRate = Number(parsedTickRate) || 0;

  var tickRate = nbTickRate;
  var frameRate = nbFrameRate;
  var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
  var spaceStyle = parsedSpaceStyle || "default";

  if (nbTickRate === 0) {
    tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : 1;
  }

  if (parsedFrameRateMultiplier) {
    var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
    if (multiplierResults) {
      var numerator = Number(multiplierResults[1]);
      var denominator = Number(multiplierResults[2]);
      var multiplierNum = numerator / denominator;
      frameRate = nbFrameRate * multiplierNum;
    }
  }

  return {
    tickRate: tickRate,
    frameRate: frameRate,
    subFrameRate: subFrameRate,
    spaceStyle: spaceStyle
  };
}

/***/ }),
/* 367 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getTimeDelimiters;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__time_parsing_js__ = __webpack_require__(830);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
function getTimeDelimiters(element, ttParams) {
  var beginAttr = element.getAttribute("begin");
  var durationAttr = element.getAttribute("dur");
  var endAttr = element.getAttribute("end");

  var start = beginAttr ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__time_parsing_js__["a" /* default */])(beginAttr, ttParams) : null;
  var duration = durationAttr ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__time_parsing_js__["a" /* default */])(durationAttr, ttParams) : null;
  var parsedEnd = endAttr ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__time_parsing_js__["a" /* default */])(endAttr, ttParams) : null;
  if (start == null || parsedEnd == null && duration == null) {
    throw new Error("Invalid text cue");
  }

  var end = parsedEnd == null ? start + duration : parsedEnd;
  return { start: start, end: end };
}

/***/ }),
/* 368 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBodyNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getStyleNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getRegionNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTextNodes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} tt
 * @returns {Array.<Element>}
 */
function getBodyNode(tt) {
  return tt.getElementsByTagName("body")[0];
}

/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getStyleNodes(tt) {
  return tt.getElementsByTagName("style");
}

/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getRegionNodes(tt) {
  return tt.getElementsByTagName("region");
}

/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getTextNodes(tt) {
  return tt.getElementsByTagName("p");
}



/***/ }),
/* 369 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getFuzzedDelay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBackedoffDelay; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FUZZ_FACTOR = 0.3;

/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */
function getFuzzedDelay(retryDelay) {
  var fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
  return retryDelay * (1.0 + fuzzingFactor); // Max 1.3 Min 0.7
}

/**
 * Calculate a "backed off" fuzzed delay.
 * That is, a delay augmented depending on the current retry count.
 * @param {Number} retryDelay
 * @param {Number} [retryCount=1]
 * @returns {Number}
 */
function getBackedoffDelay(retryDelay) {
  var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));
}



/***/ }),
/* 370 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return retryWithBackoff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return retryableFuncWithBackoff; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__backoff__ = __webpack_require__(369);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Simple debounce implementation.
 * @param {Function} fn
 * @param {Number} delay
 * @returns {Function}
 */
function debounce(fn, delay) {
  var timer = 0;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(fn, delay);
  };
}

/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options
 * @param {Number} options.retryDelay - The initial delay, in ms.
 * This delay will be fuzzed to fall under the range +-30% each time a new retry
 * is done.
 * Then, this delay will be multiplied by 2^(n-1), n being the counter of retry
 * we performed (beginning at 1 for the first retry).
 * @param {Number} options.totalRetry - The amount of time we should retry. 0
 * means no retry, 1 means a single retry, Infinity means infinite retry etc.
 * If the observable still fails after this number of retry, the error will
 * be throwed through this observable.
 * @param {Number} [options.resetDelay] - Delay in ms since a retry after which
 * the counter of retry will be reset if the observable wasn't retried a new
 * time. 0 / undefined means no delay will be applied.
 * @param {Function} [options.shouldRetry] - Function which will receive the
 * observable error each time it fails, and should return a boolean. If this
 * boolean is false, the error will be directly thrown (without anymore retry).
 * @param {Function} [options.onRetry] - Function which will be triggered at
 * each retry. Will receive two arguments:
 *   1. The observable error
 *   2. The current retry count, beginning at 1 for the first retry
 * @param {Function} [options.errorSelector]
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryWithBackoff(obs$, options) {
  var retryDelay = options.retryDelay,
      totalRetry = options.totalRetry,
      shouldRetry = options.shouldRetry,
      resetDelay = options.resetDelay,
      errorSelector = options.errorSelector,
      onRetry = options.onRetry;


  var retryCount = 0;
  var debounceRetryCount = void 0;
  if (resetDelay > 0) {
    debounceRetryCount = debounce(function () {
      return retryCount = 0;
    }, resetDelay);
  }

  return obs$.catch(function (error, source) {
    var wantRetry = !shouldRetry || shouldRetry(error);
    if (!wantRetry || retryCount++ >= totalRetry) {
      if (errorSelector) {
        throw errorSelector(error, retryCount);
      } else {
        throw error;
      }
    }

    if (onRetry) {
      onRetry(error, retryCount);
    }

    var fuzzedDelay = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__backoff__["a" /* getBackedoffDelay */])(retryDelay, retryCount);
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].timer(fuzzedDelay).mergeMap(function () {
      debounceRetryCount && debounceRetryCount();
      return source;
    });
  });
}

/**
 * Same than retryWithBackoff, only with a function returning an observable
 * instead of an observable.
 * @param {Function} fn - Function returning an Observable which
 * will (well, might) be retried.
 * @param {Object} options
 * @param {Number} options.retryDelay
 * @param {Number} options.totalRetry
 * @param {Number} [options.resetDelay]
 * @param {Function} [options.shouldRetry]
 * @param {Function} [options.errorSelector]
 * @param {Function} [options.onRetry]
 * @returns {Function} - take in argument fn's arguments, returns
 * an Observable.
 */
function retryableFuncWithBackoff(fn, options) {
  var retryDelay = options.retryDelay,
      totalRetry = options.totalRetry,
      shouldRetry = options.shouldRetry,
      resetDelay = options.resetDelay,
      errorSelector = options.errorSelector,
      onRetry = options.onRetry;


  var retryCount = 0;
  var debounceRetryCount = void 0;
  if (resetDelay > 0) {
    debounceRetryCount = debounce(function () {
      return retryCount = 0;
    }, resetDelay);
  }

  return function doRetry() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return fn.apply(undefined, args).catch(function (error) {
      var wantRetry = !shouldRetry || shouldRetry(error);
      if (!wantRetry || retryCount++ >= totalRetry) {
        if (errorSelector) {
          throw errorSelector(error, retryCount);
        } else {
          throw error;
        }
      }

      if (onRetry) {
        onRetry(error, retryCount);
      }

      var fuzzedDelay = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__backoff__["a" /* getBackedoffDelay */])(retryDelay, retryCount);
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].timer(fuzzedDelay).mergeMap(function () {
        debounceRetryCount && debounceRetryCount();
        return doRetry.apply(undefined, args);
      });
    });
  };
}



/***/ }),
/* 371 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export stringFromCharCode */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return stringFromUTF8; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates a new string from the given array of char codes.
 *
 * @param {TypedArray} args
 * @returns {string}
 */
function stringFromCharCode(args) {
  var max = 16000;
  var ret = "";
  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max);
    ret += String.fromCharCode.apply(null, subArray);
  }
  return ret;
}

/**
 * Creates a string from the given buffer as UTF-8 encoding.
 *
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */
function stringFromUTF8(data) {
  if (!data) {
    return "";
  }

  var uint8 = new Uint8Array(data);

  // If present, strip off the UTF-8 BOM.
  if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {
    uint8 = uint8.subarray(3);
  }

  // http://stackoverflow.com/a/13691499
  var utf8 = stringFromCharCode(uint8);

  // This converts each character in the string to an escape sequence.  If the
  // character is in the ASCII range, it is not converted; otherwise it is
  // converted to a URI escape sequence.
  // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
  // TODO "escape" is deprecated, provide a ponyfill?
  var escaped = escape(utf8);

  // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
  // correct character.
  // Example: "g#%E3%82%AC" -> "g#"
  return decodeURIComponent(escaped);
}



/***/ }),
/* 372 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Title_jsx__ = __webpack_require__(381);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Player_jsx__ = __webpack_require__(389);




/* harmony default export */ __webpack_exports__["a"] = (function () {
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    null,
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Title_jsx__["a" /* default */], { title: "Rx Player Demo" }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__Player_jsx__["a" /* default */], null)
  );
});

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(652);

__webpack_require__(406);

__webpack_require__(453);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(146)))

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (false) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(664);
} else {
  module.exports = require('./cjs/react-dom.development.js');
}

/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Note: totally overkill
/* harmony default export */ __webpack_exports__["a"] = ({
  aaa: "Ghotuo",
  aab: "Alumu-Tesu",
  aac: "Ari",
  aad: "Amal",
  aae: "Arbresh Albanian",
  aaf: "Aranadan",
  aag: "Ambrak",
  aah: "Abu' Arapesh",
  aai: "Arifama-Miniafia",
  aak: "Ankave",
  aal: "Afade",
  aan: "Anamb",
  aao: "Algerian Saharan Arabic",
  aap: "Par Arra",
  aaq: "Eastern Abnaki",
  aar: "Afar",
  aas: "Aasx",
  aat: "Arvanitika Albanian",
  aau: "Abau",
  aaw: "Solong",
  aax: "Mandobo Atas",
  aaz: "Amarasi",
  aba: "Ab",
  abb: "Bankon",
  abc: "Ambala Ayta",
  abd: "Manide",
  abe: "Western Abnaki",
  abf: "Abai Sungai",
  abg: "Abaga",
  abh: "Tajiki Arabic",
  abi: "Abidji",
  abj: "Aka-Bea",
  abk: "Abkhazian",
  abl: "Lampung Nyo",
  abm: "Abanyom",
  abn: "Abua",
  abo: "Abon",
  abp: "Abellen Ayta",
  abq: "Abaza",
  abr: "Abron",
  abs: "Ambonese Malay",
  abt: "Ambulas",
  abu: "Abure",
  abv: "Baharna Arabic",
  abw: "Pal",
  abx: "Inabaknon",
  aby: "Aneme Wake",
  abz: "Abui",
  aca: "Achagua",
  acb: "nc",
  acd: "Gikyode",
  ace: "Achinese",
  acf: "Saint Lucian Creole French",
  ach: "Acoli",
  aci: "Aka-Cari",
  ack: "Aka-Kora",
  acl: "Akar-Bale",
  acm: "Mesopotamian Arabic",
  acn: "Achang",
  acp: "Eastern Acipa",
  acq: "Ta'izzi-Adeni Arabic",
  acr: "Achi",
  acs: "Acro",
  act: "Achterhoeks",
  acu: "Achuar-Shiwiar",
  acv: "Achumawi",
  acw: "Hijazi Arabic",
  acx: "Omani Arabic",
  acy: "Cypriot Arabic",
  acz: "Acheron",
  ada: "Adangme",
  adb: "Adabe",
  add: "Dzodinka",
  ade: "Adele",
  adf: "Dhofari Arabic",
  adg: "Andegerebinha",
  adh: "Adhola",
  adi: "Adi",
  adj: "Adioukrou",
  adl: "Galo",
  adn: "Adang",
  ado: "Abu",
  adq: "Adangbe",
  adr: "Adonara",
  ads: "Adamorobe Sign Language",
  adt: "Adnyamathanha",
  adu: "Aduge",
  adw: "Amundava",
  adx: "Amdo Tibetan",
  ady: "Adyghe",
  adz: "Adzera",
  aea: "Areba",
  aeb: "Tunisian Arabic",
  aec: "Saidi Arabic",
  aed: "Argentine Sign Language",
  aee: "Northeast Pashai",
  aek: "Haeke",
  ael: "Ambele",
  aem: "Arem",
  aen: "Armenian Sign Language",
  aeq: "Aer",
  aer: "Eastern Arrernte",
  aes: "Alsea",
  aeu: "Akeu",
  aew: "Ambakich",
  aey: "Amele",
  aez: "Aeka",
  afb: "Gulf Arabic",
  afd: "Andai",
  afe: "Putukwam",
  afg: "Afghan Sign Language",
  afh: "Afrihili",
  afi: "Akrukay",
  afk: "Nanubae",
  afn: "Defaka",
  afo: "Eloyi",
  afp: "Tapei",
  afr: "Afrikaans",
  afs: "Afro-Seminole Creole",
  aft: "Afitti",
  afu: "Awutu",
  afz: "Obokuitai",
  aga: "Aguano",
  agb: "Legbo",
  agc: "Agatu",
  agd: "Agarabi",
  age: "Angal",
  agf: "Arguni",
  agg: "Angor",
  agh: "Ngelima",
  agi: "Agariya",
  agj: "Argobba",
  agk: "Isarog Agta",
  agl: "Fembe",
  agm: "Angaataha",
  agn: "Agutaynen",
  ago: "Tainae",
  agq: "Aghem",
  agr: "Aguaruna",
  ags: "Esimbi",
  agt: "Central Cagayan Agta",
  agu: "Aguacateco",
  agv: "Remontado Dumagat",
  agw: "Kahua",
  agx: "Aghul",
  agy: "Southern Alta",
  agz: "Mt. Iriga Agta",
  aha: "Ahanta",
  ahb: "Axamb",
  ahg: "Qimant",
  ahh: "Aghu",
  ahi: "Tiagbamrin Aizi",
  ahk: "Akha",
  ahl: "Igo",
  ahm: "Mobumrin Aizi",
  ahn: "hn",
  aho: "Ahom",
  ahp: "Aproumu Aizi",
  ahr: "Ahirani",
  ahs: "Ashe",
  aht: "Ahtena",
  aia: "Arosi",
  aib: "Ainu (China)",
  aic: "Ainbai",
  aid: "Alngith",
  aie: "Amara",
  aif: "Agi",
  aig: "Antigua and Barbuda Creole English",
  aih: "Ai-Cham",
  aii: "Assyrian Neo-Aramaic",
  aij: "Lishanid Noshan",
  aik: "Ake",
  ail: "Aimele",
  aim: "Aimol",
  ain: "Ainu (Japan)",
  aio: "Aiton",
  aip: "Burumakok",
  aiq: "Aimaq",
  air: "Airoran",
  ais: "Nataoran Amis",
  ait: "Arikem",
  aiw: "Aari",
  aix: "Aighon",
  aiy: "Ali",
  aja: "Aja (Sudan)",
  ajg: "Aja (Benin)",
  aji: "Aji",
  ajn: "Andajin",
  ajp: "South Levantine Arabic",
  ajt: "Judeo-Tunisian Arabic",
  aju: "Judeo-Moroccan Arabic",
  ajw: "Ajawa",
  ajz: "Amri Karbi",
  aka: "Akan",
  akb: "Batak Angkola",
  akc: "Mpur",
  akd: "Ukpet-Ehom",
  ake: "Akawaio",
  akf: "Akpa",
  akg: "Anakalangu",
  akh: "Angal Heneng",
  aki: "Aiome",
  akj: "Aka-Jeru",
  akk: "Akkadian",
  akl: "Aklanon",
  akm: "Aka-Bo",
  ako: "Akurio",
  akp: "Siwu",
  akq: "Ak",
  akr: "Araki",
  aks: "Akaselem",
  akt: "Akolet",
  aku: "Akum",
  akv: "Akhvakh",
  akw: "Akwa",
  akx: "Aka-Kede",
  aky: "Aka-Kol",
  akz: "Alabama",
  ala: "Alago",
  alc: "Qawasqar",
  ald: "Alladian",
  ale: "Aleut",
  alf: "Alege",
  alh: "Alawa",
  ali: "Amaimon",
  alj: "Alangan",
  alk: "Alak",
  all: "Allar",
  alm: "Amblong",
  aln: "Gheg Albanian",
  alo: "Larike-Wakasihu",
  alp: "Alune",
  alq: "Algonquin",
  alr: "Alutor",
  als: "Tosk Albanian",
  alt: "Southern Altai",
  alu: "'Are'are",
  alw: "Alaba-Kabeena",
  alx: "Amol",
  aly: "Alyawarr",
  alz: "Alur",
  ama: "Amanay",
  amb: "Ambo",
  amc: "Amahuaca",
  ame: "Yanesha'",
  amf: "Hamer-Banna",
  amg: "Amurdak",
  amh: "Amharic",
  ami: "Amis",
  amj: "Amdang",
  amk: "Ambai",
  aml: "War-Jaintia",
  amm: "Ama (Papua New Guinea)",
  amn: "Amanab",
  amo: "Amo",
  amp: "Alamblak",
  amq: "Amahai",
  amr: "Amarakaeri",
  ams: "Southern Amami-Oshima",
  amt: "Amto",
  amu: "Guerrero Amuzgo",
  amv: "Ambelau",
  amw: "Western Neo-Aramaic",
  amx: "Anmatyerre",
  amy: "Ami",
  amz: "Atampaya",
  ana: "Andaqui",
  anb: "Andoa",
  anc: "Ngas",
  and: "Ansus",
  ane: "Xrc",
  anf: "Animere",
  ang: "Old English (ca. 450-1100)",
  anh: "Nend",
  ani: "Andi",
  anj: "Anor",
  ank: "Goemai",
  anl: "Anu-Hkongso Chin",
  anm: "Anal",
  ann: "Obolo",
  ano: "Andoque",
  anp: "Angika",
  anq: "Jarawa (India)",
  anr: "Andh",
  ans: "Anserma",
  ant: "Antakarinya",
  anu: "Anuak",
  anv: "Denya",
  anw: "Anaang",
  anx: "Andra-Hus",
  any: "Anyin",
  anz: "Anem",
  aoa: "Angolar",
  aob: "Abom",
  aoc: "Pemon",
  aod: "Andarum",
  aoe: "Angal Enen",
  aof: "Bragat",
  aog: "Angoram",
  aoh: "Arma",
  aoi: "Anindilyakwa",
  aoj: "Mufian",
  aok: "Arh",
  aol: "Alor",
  aom: "mie",
  aon: "Bumbita Arapesh",
  aor: "Aore",
  aos: "Taikat",
  aot: "Atong (India)",
  aou: "A'ou",
  aox: "Atorada",
  aoz: "Uab Meto",
  apb: "Sa'a",
  apc: "North Levantine Arabic",
  apd: "Sudanese Arabic",
  ape: "Bukiyip",
  apf: "Pahanan Agta",
  apg: "Ampanang",
  aph: "Athpariya",
  api: "Apiak",
  apj: "Jicarilla Apache",
  apk: "Kiowa Apache",
  apl: "Lipan Apache",
  apm: "Mescalero-Chiricahua Apache",
  apn: "Apinay",
  apo: "Ambul",
  app: "Apma",
  apq: "A-Pucikwar",
  apr: "Arop-Lokep",
  aps: "Arop-Sissano",
  apt: "Apatani",
  apu: "Apurin",
  apv: "Alapmunte",
  apw: "Western Apache",
  apx: "Aputai",
  apy: "Apala",
  apz: "Safeyoka",
  aqc: "Archi",
  aqd: "Ampari Dogon",
  aqg: "Arigidi",
  aqm: "Atohwaim",
  aqn: "Northern Alta",
  aqp: "Atakapa",
  aqr: "Arh",
  aqt: "Angait",
  aqz: "Akuntsu",
  ara: "Arabic",
  arb: "Standard Arabic",
  arc: "Official Aramaic (700-300 BCE)",
  ard: "Arabana",
  are: "Western Arrarnta",
  arg: "Aragonese",
  arh: "Arhuaco",
  ari: "Arikara",
  arj: "Arapaso",
  ark: "Arikap",
  arl: "Arabela",
  arn: "Mapudungun",
  aro: "Araona",
  arp: "Arapaho",
  arq: "Algerian Arabic",
  arr: "Karo (Brazil)",
  ars: "Najdi Arabic",
  aru: "Aru (Amazonas State)",
  arv: "Arbore",
  arw: "Arawak",
  arx: "Aru (Rodonia State)",
  ary: "Moroccan Arabic",
  arz: "Egyptian Arabic",
  asa: "Asu (Tanzania)",
  asb: "Assiniboine",
  asc: "Casuarina Coast Asmat",
  asd: "Asas",
  ase: "American Sign Language",
  asf: "Australian Sign Language",
  asg: "Cishingini",
  ash: "Abishira",
  asi: "Buruwai",
  asj: "Sari",
  ask: "Ashkun",
  asl: "Asilulu",
  asm: "Assamese",
  asn: "Xing Asurin",
  aso: "Dano",
  asp: "Algerian Sign Language",
  asq: "Austrian Sign Language",
  asr: "Asuri",
  ass: "Ipulo",
  ast: "Asturian",
  asu: "Tocantins Asurini",
  asv: "Asoa",
  asw: "Australian Aborigines Sign Language",
  asx: "Muratayak",
  asy: "Yaosakor Asmat",
  asz: "As",
  ata: "Pele-Ata",
  atb: "Zaiwa",
  atc: "Atsahuaca",
  atd: "Ata Manobo",
  ate: "Atemble",
  atg: "Ivbie North-Okpela-Arhe",
  ati: "Atti",
  atj: "Atikamekw",
  atk: "Ati",
  atl: "Mt. Iraya Agta",
  atm: "Ata",
  atn: "Ashtiani",
  ato: "Atong (Cameroon)",
  atp: "Pudtol Atta",
  atq: "Aralle-Tabulahan",
  atr: "Waimiri-Atroari",
  ats: "Gros Ventre",
  att: "Pamplona Atta",
  atu: "Reel",
  atv: "Northern Altai",
  atw: "Atsugewi",
  atx: "Arutani",
  aty: "Aneityum",
  atz: "Arta",
  aua: "Asumboa",
  aub: "Alugu",
  auc: "Waorani",
  aud: "Anuta",
  aug: "Aguna",
  auh: "Aushi",
  aui: "Anuki",
  auj: "Awjilah",
  auk: "Heyo",
  aul: "Aulua",
  aum: "Asu (Nigeria)",
  aun: "Molmo One",
  auo: "Auyokawa",
  aup: "Makayam",
  auq: "Anus",
  aur: "Aruek",
  aut: "Austral",
  auu: "Auye",
  auw: "Awyi",
  aux: "Aur",
  auy: "Awiyaana",
  auz: "Uzbeki Arabic",
  ava: "Avaric",
  avb: "Avau",
  avd: "Alviri-Vidari",
  ave: "Avestan",
  avi: "Avikam",
  avk: "Kotava",
  avl: "Eastern Egyptian Bedawi Arabic",
  avm: "Angkamuthi",
  avn: "Avatime",
  avo: "Agavotaguerra",
  avs: "Aushiri",
  avt: "Au",
  avu: "Avokaya",
  avv: "Av-Canoeiro",
  awa: "Awadhi",
  awb: "Awa (Papua New Guinea)",
  awc: "Cicipu",
  awe: "Awet",
  awg: "Anguthimri",
  awh: "Awbono",
  awi: "Aekyom",
  awk: "Awabakal",
  awm: "Arawum",
  awn: "Awngi",
  awo: "Awak",
  awr: "Awera",
  aws: "South Awyu",
  awt: "Arawet",
  awu: "Central Awyu",
  awv: "Jair Awyu",
  aww: "Awun",
  awx: "Awara",
  awy: "Edera Awyu",
  axb: "Abipon",
  axe: "Ayerrerenge",
  axg: "Mato Grosso Arra",
  axk: "Yaka (Central African Republic)",
  axl: "Lower Southern Aranda",
  axm: "Middle Armenian",
  axx: "Xrgur",
  aya: "Awar",
  ayb: "Ayizo Gbe",
  ayc: "Southern Aymara",
  ayd: "Ayabadhu",
  aye: "Ayere",
  ayg: "Ginyanga",
  ayh: "Hadrami Arabic",
  ayi: "Leyigha",
  ayk: "Akuku",
  ayl: "Libyan Arabic",
  aym: "Aymara",
  ayn: "Sanaani Arabic",
  ayo: "Ayoreo",
  ayp: "North Mesopotamian Arabic",
  ayq: "Ayi (Papua New Guinea)",
  ayr: "Central Aymara",
  ays: "Sorsogon Ayta",
  ayt: "Magbukun Ayta",
  ayu: "Ayu",
  ayy: "Tayabas Ayta",
  ayz: "Mai Brat",
  aza: "Azha",
  azb: "South Azerbaijani",
  azd: "Eastern Durango Nahuatl",
  aze: "Azerbaijani",
  azg: "San Pedro Amuzgos Amuzgo",
  azj: "North Azerbaijani",
  azm: "Ipalapa Amuzgo",
  azn: "Western Durango Nahuatl",
  azo: "Awing",
  azt: "Faire Atta",
  azz: "Highland Puebla Nahuatl",
  baa: "Babatana",
  bab: "Bainouk-Gunyuo",
  bac: "Badui",
  bae: "Bar",
  baf: "Nubaca",
  bag: "Tuki",
  bah: "Bahamas Creole English",
  baj: "Barakai",
  bak: "Bashkir",
  bal: "Baluchi",
  bam: "Bambara",
  ban: "Balinese",
  bao: "Waimaha",
  bap: "Bantawa",
  bar: "Bavarian",
  bas: "Basa (Cameroon)",
  bau: "Bada (Nigeria)",
  bav: "Vengo",
  baw: "Bambili-Bambui",
  bax: "Bamun",
  bay: "Batuley",
  bba: "Baatonum",
  bbb: "Barai",
  bbc: "Batak Toba",
  bbd: "Bau",
  bbe: "Bangba",
  bbf: "Baibai",
  bbg: "Barama",
  bbh: "Bugan",
  bbi: "Barombi",
  bbj: "Ghoml'",
  bbk: "Babanki",
  bbl: "Bats",
  bbm: "Babango",
  bbn: "Uneapa",
  bbo: "Northern Bobo Madar",
  bbp: "West Central Banda",
  bbq: "Bamali",
  bbr: "Girawa",
  bbs: "Bakpinka",
  bbt: "Mburku",
  bbu: "Kulung (Nigeria)",
  bbv: "Karnai",
  bbw: "Baba",
  bbx: "Bubia",
  bby: "Befang",
  bbz: "Babalia Creole Arabic",
  bca: "Central Bai",
  bcb: "Bainouk-Samik",
  bcc: "Southern Balochi",
  bcd: "North Babar",
  bce: "Bamenyam",
  bcf: "Bamu",
  bcg: "Baga Pokur",
  bch: "Bariai",
  bci: "Baoul",
  bcj: "Bardi",
  bck: "Bunaba",
  bcl: "Central Bikol",
  bcm: "Bannoni",
  bcn: "Bali (Nigeria)",
  bco: "Kaluli",
  bcp: "Bali (Democratic Republic of Congo)",
  bcq: "Bench",
  bcr: "Babine",
  bcs: "Kohumono",
  bct: "Bendi",
  bcu: "Awad Bing",
  bcv: "Shoo-Minda-Nye",
  bcw: "Bana",
  bcy: "Bacama",
  bcz: "Bainouk-Gunyaamolo",
  bda: "Bayot",
  bdb: "Basap",
  bdc: "Ember-Baud",
  bdd: "Bunama",
  bde: "Bade",
  bdf: "Biage",
  bdg: "Bonggi",
  bdh: "Baka (Sudan)",
  bdi: "Burun",
  bdj: "Bai",
  bdk: "Budukh",
  bdl: "Indonesian Bajau",
  bdm: "Buduma",
  bdn: "Baldemu",
  bdo: "Morom",
  bdp: "Bende",
  bdq: "Bahnar",
  bdr: "West Coast Bajau",
  bds: "Burunge",
  bdt: "Bokoto",
  bdu: "Oroko",
  bdv: "Bodo Parja",
  bdw: "Baham",
  bdx: "Budong-Budong",
  bdy: "Bandjalang",
  bdz: "Badeshi",
  bea: "Beaver",
  beb: "Bebele",
  bec: "Iceve-Maci",
  bed: "Bedoanas",
  bee: "Byangsi",
  bef: "Benabena",
  beg: "Belait",
  beh: "Biali",
  bei: "Bekati'",
  bej: "Beja",
  bek: "Bebeli",
  bel: "Belarusian",
  bem: "Bemba (Zambia)",
  ben: "Bengali",
  beo: "Beami",
  bep: "Besoa",
  beq: "Beembe",
  bes: "Besme",
  bet: "Guiberoua Bte",
  beu: "Blagar",
  bev: "Daloa Bt",
  bew: "Betawi",
  bex: "Jur Modo",
  bey: "Beli (Papua New Guinea)",
  bez: "Bena (Tanzania)",
  bfa: "Bari",
  bfb: "Pauri Bareli",
  bfc: "Panyi Bai",
  bfd: "Bafut",
  bfe: "Betaf",
  bff: "Bofi",
  bfg: "Busang Kayan",
  bfh: "Blafe",
  bfi: "British Sign Language",
  bfj: "Bafanji",
  bfk: "Ban Khor Sign Language",
  bfl: "Banda-Ndl",
  bfm: "Mmen",
  bfn: "Bunak",
  bfo: "Malba Birifor",
  bfp: "Beba",
  bfq: "Badaga",
  bfr: "Bazigar",
  bfs: "Southern Bai",
  bft: "Balti",
  bfu: "Gahri",
  bfw: "Bondo",
  bfx: "Bantayanon",
  bfy: "Bagheli",
  bfz: "Mahasu Pahari",
  bga: "Gwamhi-Wuri",
  bgb: "Bobongko",
  bgc: "Haryanvi",
  bgd: "Rathwi Bareli",
  bge: "Bauria",
  bgf: "Bangandu",
  bgg: "Bugun",
  bgi: "Giangan",
  bgj: "Bangolan",
  bgk: "Bit",
  bgl: "Bo (Laos)",
  bgn: "Western Balochi",
  bgo: "Baga Koga",
  bgp: "Eastern Balochi",
  bgq: "Bagri",
  bgr: "Bawm Chin",
  bgs: "Tagabawa",
  bgt: "Bughotu",
  bgu: "Mbongno",
  bgv: "Warkay-Bipim",
  bgw: "Bhatri",
  bgx: "Balkan Gagauz Turkish",
  bgy: "Benggoi",
  bgz: "Banggai",
  bha: "Bharia",
  bhb: "Bhili",
  bhc: "Biga",
  bhd: "Bhadrawahi",
  bhe: "Bhaya",
  bhf: "Odiai",
  bhg: "Binandere",
  bhh: "Bukharic",
  bhi: "Bhilali",
  bhj: "Bahing",
  bhl: "Bimin",
  bhm: "Bathari",
  bhn: "Bohtan Neo-Aramaic",
  bho: "Bhojpuri",
  bhp: "Bima",
  bhq: "Tukang Besi South",
  bhr: "Bara Malagasy",
  bhs: "Buwal",
  bht: "Bhattiyali",
  bhu: "Bhunjia",
  bhv: "Bahau",
  bhw: "Biak",
  bhx: "Bhalay",
  bhy: "Bhele",
  bhz: "Bada (Indonesia)",
  bia: "Badimaya",
  bib: "Bissa",
  bic: "Bikaru",
  bid: "Bidiyo",
  bie: "Bepour",
  bif: "Biafada",
  big: "Biangai",
  bij: "Vaghat-Ya-Bijim-Legeri",
  bik: "Bikol",
  bil: "Bile",
  bim: "Bimoba",
  bin: "Bini",
  bio: "Nai",
  bip: "Bila",
  biq: "Bipi",
  bir: "Bisorio",
  bis: "Bislama",
  bit: "Berinomo",
  biu: "Biete",
  biv: "Southern Birifor",
  biw: "Kol (Cameroon)",
  bix: "Bijori",
  biy: "Birhor",
  biz: "Baloi",
  bja: "Budza",
  bjb: "Banggarla",
  bjc: "Bariji",
  bje: "Biao-Jiao Mien",
  bjf: "Barzani Jewish Neo-Aramaic",
  bjg: "Bidyogo",
  bjh: "Bahinemo",
  bji: "Burji",
  bjj: "Kanauji",
  bjk: "Barok",
  bjl: "Bulu (Papua New Guinea)",
  bjm: "Bajelani",
  bjn: "Banjar",
  bjo: "Mid-Southern Banda",
  bjp: "Fanamaket",
  bjr: "Binumarien",
  bjs: "Bajan",
  bjt: "Balanta-Ganja",
  bju: "Busuu",
  bjv: "Bedjond",
  bjw: "Bakw",
  bjx: "Banao Itneg",
  bjy: "Bayali",
  bjz: "Baruga",
  bka: "Kyak",
  bkc: "Baka (Cameroon)",
  bkd: "Binukid",
  bkf: "Beeke",
  bkg: "Buraka",
  bkh: "Bakoko",
  bki: "Baki",
  bkj: "Pande",
  bkk: "Brokskat",
  bkl: "Berik",
  bkm: "Kom (Cameroon)",
  bkn: "Bukitan",
  bko: "Kwa'",
  bkp: "Boko (Democratic Republic of Congo)",
  bkq: "Bakair",
  bkr: "Bakumpai",
  bks: "Northern Sorsoganon",
  bkt: "Boloki",
  bku: "Buhid",
  bkv: "Bekwarra",
  bkw: "Bekwel",
  bkx: "Baikeno",
  bky: "Bokyi",
  bkz: "Bungku",
  bla: "Siksika",
  blb: "Bilua",
  blc: "Bella Coola",
  bld: "Bolango",
  ble: "Balanta-Kentohe",
  blf: "Buol",
  blg: "Balau",
  blh: "Kuwaa",
  bli: "Bolia",
  blj: "Bolongan",
  blk: "Pa'o Karen",
  bll: "Biloxi",
  blm: "Beli (Sudan)",
  bln: "Southern Catanduanes Bikol",
  blo: "Anii",
  blp: "Blablanga",
  blq: "Baluan-Pam",
  blr: "Blang",
  bls: "Balaesang",
  blt: "Tai Dam",
  blv: "Kibala",
  blw: "Balangao",
  blx: "Mag-Indi Ayta",
  bly: "Notre",
  blz: "Balantak",
  bma: "Lame",
  bmb: "Bembe",
  bmc: "Biem",
  bmd: "Baga Manduri",
  bme: "Limassa",
  bmf: "Bom-Kim",
  bmg: "Bamwe",
  bmh: "Kein",
  bmi: "Bagirmi",
  bmj: "Bote-Majhi",
  bmk: "Ghayavi",
  bml: "Bomboli",
  bmm: "Northern Betsimisaraka Malagasy",
  bmn: "Bina (Papua New Guinea)",
  bmo: "Bambalang",
  bmp: "Bulgebi",
  bmq: "Bomu",
  bmr: "Muinane",
  bms: "Bilma Kanuri",
  bmt: "Biao Mon",
  bmu: "Somba-Siawari",
  bmv: "Bum",
  bmw: "Bomwali",
  bmx: "Baimak",
  bmz: "Baramu",
  bna: "Bonerate",
  bnb: "Bookan",
  bnc: "Bontok",
  bnd: "Banda (Indonesia)",
  bne: "Bintauna",
  bnf: "Masiwang",
  bng: "Benga",
  bni: "Bangi",
  bnj: "Eastern Tawbuid",
  bnk: "Bierebo",
  bnl: "Boon",
  bnm: "Batanga",
  bnn: "Bunun",
  bno: "Bantoanon",
  bnp: "Bola",
  bnq: "Bantik",
  bnr: "Butmas-Tur",
  bns: "Bundeli",
  bnu: "Bentong",
  bnv: "Bonerif",
  bnw: "Bisis",
  bnx: "Bangubangu",
  bny: "Bintulu",
  bnz: "Beezen",
  boa: "Bora",
  bob: "Aweer",
  bod: "Tibetan",
  boe: "Mundabli",
  bof: "Bolon",
  bog: "Bamako Sign Language",
  boh: "Boma",
  boi: "Barbareo",
  boj: "Anjam",
  bok: "Bonjo",
  bol: "Bole",
  bom: "Berom",
  bon: "Bine",
  boo: "Tiemacw Bozo",
  bop: "Bonkiman",
  boq: "Bogaya",
  bor: "Borro",
  bos: "Bosnian",
  bot: "Bongo",
  bou: "Bondei",
  bov: "Tuwuli",
  bow: "Rema",
  box: "Buamu",
  boy: "Bodo (Central African Republic)",
  boz: "Tiyaxo Bozo",
  bpa: "Daakaka",
  bpb: "Barbacoas",
  bpd: "Banda-Banda",
  bpg: "Bonggo",
  bph: "Botlikh",
  bpi: "Bagupi",
  bpj: "Binji",
  bpk: "Orowe",
  bpl: "Broome Pearling Lugger Pidgin",
  bpm: "Biyom",
  bpn: "Dzao Min",
  bpo: "Anasi",
  bpp: "Kaure",
  bpq: "Banda Malay",
  bpr: "Koronadal Blaan",
  bps: "Sarangani Blaan",
  bpt: "Barrow Point",
  bpu: "Bongu",
  bpv: "Bian Marind",
  bpw: "Bo (Papua New Guinea)",
  bpx: "Palya Bareli",
  bpy: "Bishnupriya",
  bpz: "Bilba",
  bqa: "Tchumbuli",
  bqb: "Bagusa",
  bqc: "Boko (Benin)",
  bqd: "Bung",
  bqf: "Baga Kaloum",
  bqg: "Bago-Kusuntu",
  bqh: "Baima",
  bqi: "Bakhtiari",
  bqj: "Bandial",
  bqk: "Banda-Mbrs",
  bql: "Bilakura",
  bqm: "Wumboko",
  bqn: "Bulgarian Sign Language",
  bqo: "Balo",
  bqp: "Busa",
  bqq: "Biritai",
  bqr: "Burusu",
  bqs: "Bosngun",
  bqt: "Bamukumbit",
  bqu: "Boguru",
  bqv: "Koro Wachi",
  bqw: "Buru (Nigeria)",
  bqx: "Baangi",
  bqy: "Bengkala Sign Language",
  bqz: "Bakaka",
  bra: "Braj",
  brb: "Lave",
  brc: "Berbice Creole Dutch",
  brd: "Baraamu",
  bre: "Breton",
  brf: "Bera",
  brg: "Baure",
  brh: "Brahui",
  bri: "Mokpwe",
  brj: "Bieria",
  brk: "Birked",
  brl: "Birwa",
  brm: "Barambu",
  brn: "Boruca",
  bro: "Brokkat",
  brp: "Barapasi",
  brq: "Breri",
  brr: "Birao",
  brs: "Baras",
  brt: "Bitare",
  bru: "Eastern Bru",
  brv: "Western Bru",
  brw: "Bellari",
  brx: "Bodo (India)",
  bry: "Burui",
  brz: "Bilbil",
  bsa: "Abinomn",
  bsb: "Brunei Bisaya",
  bsc: "Bassari",
  bse: "Wushi",
  bsf: "Bauchi",
  bsg: "Bashkardi",
  bsh: "Kati",
  bsi: "Bassossi",
  bsj: "Bangwinji",
  bsk: "Burushaski",
  bsl: "Basa-Gumna",
  bsm: "Busami",
  bsn: "Barasana-Eduria",
  bso: "Buso",
  bsp: "Baga Sitemu",
  bsq: "Bassa",
  bsr: "Bassa-Kontagora",
  bss: "Akoose",
  bst: "Basketo",
  bsu: "Bahonsuai",
  bsv: "Baga Soban",
  bsw: "Baiso",
  bsx: "Yangkam",
  bsy: "Sabah Bisaya",
  bta: "Bata",
  btc: "Bati (Cameroon)",
  btd: "Batak Dairi",
  bte: "Gamo-Ningi",
  btf: "Birgit",
  btg: "Gagnoa Bt",
  bth: "Biatah Bidayuh",
  bti: "Burate",
  btj: "Bacanese Malay",
  btm: "Batak Mandailing",
  btn: "Ratagnon",
  bto: "Rinconada Bikol",
  btp: "Budibud",
  btq: "Batek",
  btr: "Baetora",
  bts: "Batak Simalungun",
  btt: "Bete-Bendi",
  btu: "Batu",
  btv: "Bateri",
  btw: "Butuanon",
  btx: "Batak Karo",
  bty: "Bobot",
  btz: "Batak Alas-Kluet",
  bua: "Buriat",
  bub: "Bua",
  buc: "Bushi",
  bud: "Ntcham",
  bue: "Beothuk",
  buf: "Bushoong",
  bug: "Buginese",
  buh: "Younuo Bunu",
  bui: "Bongili",
  buj: "Basa-Gurmana",
  buk: "Bugawac",
  bul: "Bulgarian",
  bum: "Bulu (Cameroon)",
  bun: "Sherbro",
  buo: "Terei",
  bup: "Busoa",
  buq: "Brem",
  bus: "Bokobaru",
  but: "Bungain",
  buu: "Budu",
  buv: "Bun",
  buw: "Bubi",
  bux: "Boghom",
  buy: "Bullom So",
  buz: "Bukwen",
  bva: "Barein",
  bvb: "Bube",
  bvc: "Baelelea",
  bvd: "Baeggu",
  bve: "Berau Malay",
  bvf: "Boor",
  bvg: "Bonkeng",
  bvh: "Bure",
  bvi: "Belanda Viri",
  bvj: "Baan",
  bvk: "Bukat",
  bvl: "Bolivian Sign Language",
  bvm: "Bamunka",
  bvn: "Buna",
  bvo: "Bolgo",
  bvp: "Bumang",
  bvq: "Birri",
  bvr: "Burarra",
  bvt: "Bati (Indonesia)",
  bvu: "Bukit Malay",
  bvv: "Baniva",
  bvw: "Boga",
  bvx: "Dibole",
  bvy: "Baybayanon",
  bvz: "Bauzi",
  bwa: "Bwatoo",
  bwb: "Namosi-Naitasiri-Serua",
  bwc: "Bwile",
  bwd: "Bwaidoka",
  bwe: "Bwe Karen",
  bwf: "Boselewa",
  bwg: "Barwe",
  bwh: "Bishuo",
  bwi: "Baniwa",
  bwj: "L L Bwamu",
  bwk: "Bauwaki",
  bwl: "Bwela",
  bwm: "Biwat",
  bwn: "Wunai Bunu",
  bwo: "Boro (Ethiopia)",
  bwp: "Mandobo Bawah",
  bwq: "Southern Bobo Madar",
  bwr: "Bura-Pabir",
  bws: "Bomboma",
  bwt: "Bafaw-Balong",
  bwu: "Buli (Ghana)",
  bww: "Bwa",
  bwx: "Bu-Nao Bunu",
  bwy: "Cwi Bwamu",
  bwz: "Bwisi",
  bxa: "Tairaha",
  bxb: "Belanda Bor",
  bxc: "Molengue",
  bxd: "Pela",
  bxe: "Birale",
  bxf: "Bilur",
  bxg: "Bangala",
  bxh: "Buhutu",
  bxi: "Pirlatapa",
  bxj: "Bayungu",
  bxk: "Bukusu",
  bxl: "Jalkunan",
  bxm: "Mongolia Buriat",
  bxn: "Burduna",
  bxo: "Barikanchi",
  bxp: "Bebil",
  bxq: "Beele",
  bxr: "Russia Buriat",
  bxs: "Busam",
  bxu: "China Buriat",
  bxv: "Berakou",
  bxw: "Bankagooma",
  bxz: "Binahari",
  bya: "Batak",
  byb: "Bikya",
  byc: "Ubaghara",
  byd: "Benyadu'",
  bye: "Pouye",
  byf: "Bete",
  byg: "Baygo",
  byh: "Bhujel",
  byi: "Buyu",
  byj: "Bina (Nigeria)",
  byk: "Biao",
  byl: "Bayono",
  bym: "Bidyara",
  byn: "Bilin",
  byo: "Biyo",
  byp: "Bumaji",
  byq: "Basay",
  byr: "Baruya",
  bys: "Burak",
  byt: "Berti",
  byv: "Medumba",
  byw: "Belhariya",
  byx: "Qaqet",
  byz: "Banaro",
  bza: "Bandi",
  bzb: "Andio",
  bzc: "Southern Betsimisaraka Malagasy",
  bzd: "Bribri",
  bze: "Jenaama Bozo",
  bzf: "Boikin",
  bzg: "Babuza",
  bzh: "Mapos Buang",
  bzi: "Bisu",
  bzj: "Belize Kriol English",
  bzk: "Nicaragua Creole English",
  bzl: "Boano (Sulawesi)",
  bzm: "Bolondo",
  bzn: "Boano (Maluku)",
  bzo: "Bozaba",
  bzp: "Kemberano",
  bzq: "Buli (Indonesia)",
  bzr: "Biri",
  bzs: "Brazilian Sign Language",
  bzt: "Brithenig",
  bzu: "Burmeso",
  bzv: "Naami",
  bzw: "Basa (Nigeria)",
  bzx: "Klngaxo Bozo",
  bzy: "Obanliku",
  bzz: "Evant",
  caa: "Chort",
  cab: "Garifuna",
  cac: "Chuj",
  cad: "Caddo",
  cae: "Lehar",
  caf: "Southern Carrier",
  cag: "Nivacl",
  cah: "Cahuarano",
  caj: "Chan",
  cak: "Kaqchikel",
  cal: "Carolinian",
  cam: "Cemuh",
  can: "Chambri",
  cao: "Chcobo",
  cap: "Chipaya",
  caq: "Car Nicobarese",
  car: "Galibi Carib",
  cas: "Tsiman",
  cat: "Catalan",
  cav: "Cavinea",
  caw: "Callawalla",
  cax: "Chiquitano",
  cay: "Cayuga",
  caz: "Canichana",
  cbb: "Cabiyar",
  cbc: "Carapana",
  cbd: "Carijona",
  cbg: "Chimila",
  cbi: "Chachi",
  cbj: "Ede Cabe",
  cbk: "Chavacano",
  cbl: "Bualkhaw Chin",
  cbn: "Nyahkur",
  cbo: "Izora",
  cbq: "Tsucuba",
  cbr: "Cashibo-Cacataibo",
  cbs: "Cashinahua",
  cbt: "Chayahuita",
  cbu: "Candoshi-Shapra",
  cbv: "Cacua",
  cbw: "Kinabalian",
  cby: "Carabayo",
  cca: "Cauca",
  ccc: "Chamicuro",
  ccd: "Cafundo Creole",
  cce: "Chopi",
  ccg: "Samba Daka",
  cch: "Atsam",
  ccj: "Kasanga",
  ccl: "Cutchi-Swahili",
  ccm: "Malaccan Creole Malay",
  cco: "Comaltepec Chinantec",
  ccp: "Chakma",
  ccr: "Cacaopera",
  cda: "Choni",
  cde: "Chenchu",
  cdf: "Chiru",
  cdg: "Chamari",
  cdh: "Chambeali",
  cdi: "Chodri",
  cdj: "Churahi",
  cdm: "Chepang",
  cdn: "Chaudangsi",
  cdo: "Min Dong Chinese",
  cdr: "Cinda-Regi-Tiyal",
  cds: "Chadian Sign Language",
  cdy: "Chadong",
  cdz: "Koda",
  cea: "Lower Chehalis",
  ceb: "Cebuano",
  ceg: "Chamacoco",
  cek: "Eastern Khumi Chin",
  cen: "Cen",
  ces: "Czech",
  cet: "Centm",
  cfa: "Dijim-Bwilim",
  cfd: "Cara",
  cfg: "Como Karim",
  cfm: "Falam Chin",
  cga: "Changriwa",
  cgc: "Kagayanen",
  cgg: "Chiga",
  cgk: "Chocangacakha",
  cha: "Chamorro",
  chb: "Chibcha",
  chc: "Catawba",
  chd: "Highland Oaxaca Chontal",
  che: "Chechen",
  chf: "Tabasco Chontal",
  chg: "Chagatai",
  chh: "Chinook",
  chj: "Ojitln Chinantec",
  chk: "Chuukese",
  chl: "Cahuilla",
  chm: "Mari (Russia)",
  chn: "Chinook jargon",
  cho: "Choctaw",
  chp: "Chipewyan",
  chq: "Quiotepec Chinantec",
  chr: "Cherokee",
  cht: "Choln",
  chu: "Church Slavic",
  chv: "Chuvash",
  chw: "Chuwabu",
  chx: "Chantyal",
  chy: "Cheyenne",
  chz: "Ozumacn Chinantec",
  cia: "Cia-Cia",
  cib: "Ci Gbe",
  cic: "Chickasaw",
  cid: "Chimariko",
  cie: "Cineni",
  cih: "Chinali",
  cik: "Chitkuli Kinnauri",
  cim: "Cimbrian",
  cin: "Cinta Larga",
  cip: "Chiapanec",
  cir: "Tiri",
  ciw: "Chippewa",
  ciy: "Chaima",
  cja: "Western Cham",
  cje: "Chru",
  cjh: "Upper Chehalis",
  cji: "Chamalal",
  cjk: "Chokwe",
  cjm: "Eastern Cham",
  cjn: "Chenapian",
  cjo: "Ashninka Pajonal",
  cjp: "Cabcar",
  cjs: "Shor",
  cjv: "Chuave",
  cjy: "Jinyu Chinese",
  ckb: "Central Kurdish",
  ckh: "Chak",
  ckl: "Cibak",
  ckn: "Kaang Chin",
  cko: "Anufo",
  ckq: "Kajakse",
  ckr: "Kairak",
  cks: "Tayo",
  ckt: "Chukot",
  cku: "Koasati",
  ckv: "Kavalan",
  ckx: "Caka",
  cky: "Cakfem-Mushere",
  ckz: "Cakchiquel-Quich Mixed Language",
  cla: "Ron",
  clc: "Chilcotin",
  cld: "Chaldean Neo-Aramaic",
  cle: "Lealao Chinantec",
  clh: "Chilisso",
  cli: "Chakali",
  clj: "Laitu Chin",
  clk: "Idu-Mishmi",
  cll: "Chala",
  clm: "Clallam",
  clo: "Lowland Oaxaca Chontal",
  clt: "Lautu Chin",
  clu: "Caluyanun",
  clw: "Chulym",
  cly: "Eastern Highland Chatino",
  cma: "Maa",
  cme: "Cerma",
  cmg: "Classical Mongolian",
  cmi: "Ember-Cham",
  cml: "Campalagian",
  cmm: "Michigamea",
  cmn: "Mandarin Chinese",
  cmo: "Central Mnong",
  cmr: "Mro-Khimi Chin",
  cms: "Messapic",
  cmt: "Camtho",
  cna: "Changthang",
  cnb: "Chinbon Chin",
  cnc: "Cng",
  cng: "Northern Qiang",
  cnh: "Hakha Chin",
  cni: "Ashninka",
  cnk: "Khumi Chin",
  cnl: "Lalana Chinantec",
  cno: "Con",
  cns: "Central Asmat",
  cnt: "Tepetotutla Chinantec",
  cnu: "Chenoua",
  cnw: "Ngawn Chin",
  cnx: "Middle Cornish",
  coa: "Cocos Islands Malay",
  cob: "Chicomuceltec",
  coc: "Cocopa",
  cod: "Cocama-Cocamilla",
  coe: "Koreguaje",
  cof: "Colorado",
  cog: "Chong",
  coh: "Chonyi-Dzihana-Kauma",
  coj: "Cochimi",
  cok: "Santa Teresa Cora",
  col: "Columbia-Wenatchi",
  com: "Comanche",
  con: "Cofn",
  coo: "Comox",
  cop: "Coptic",
  coq: "Coquille",
  cor: "Cornish",
  cos: "Corsican",
  cot: "Caquinte",
  cou: "Wamey",
  cov: "Cao Miao",
  cow: "Cowlitz",
  cox: "Nanti",
  coz: "Chochotec",
  cpa: "Palantla Chinantec",
  cpb: "Ucayali-Yura Ashninka",
  cpc: "Ajyninka Apurucayali",
  cpg: "Cappadocian Greek",
  cpi: "Chinese Pidgin English",
  cpn: "Cherepon",
  cpo: "Kpeego",
  cps: "Capiznon",
  cpu: "Pichis Ashninka",
  cpx: "Pu-Xian Chinese",
  cpy: "South Ucayali Ashninka",
  cqd: "Chuanqiandian Cluster Miao",
  cra: "Chara",
  crb: "Island Carib",
  crc: "Lonwolwol",
  crd: "Coeur d'Alene",
  cre: "Cree",
  crf: "Caramanta",
  crg: "Michif",
  crh: "Crimean Tatar",
  cri: "Sotomense",
  crj: "Southern East Cree",
  crk: "Plains Cree",
  crl: "Northern East Cree",
  crm: "Moose Cree",
  crn: "El Nayar Cora",
  cro: "Crow",
  crq: "Iyo'wujwa Chorote",
  crr: "Carolina Algonquian",
  crs: "Seselwa Creole French",
  crt: "Iyojwa'ja Chorote",
  crv: "Chaura",
  crw: "Chrau",
  crx: "Carrier",
  cry: "Cori",
  crz: "Cruzeo",
  csa: "Chiltepec Chinantec",
  csb: "Kashubian",
  csc: "Catalan Sign Language",
  csd: "Chiangmai Sign Language",
  cse: "Czech Sign Language",
  csf: "Cuba Sign Language",
  csg: "Chilean Sign Language",
  csh: "Asho Chin",
  csi: "Coast Miwok",
  csj: "Songlai Chin",
  csk: "Jola-Kasa",
  csl: "Chinese Sign Language",
  csm: "Central Sierra Miwok",
  csn: "Colombian Sign Language",
  cso: "Sochiapam Chinantec",
  csq: "Croatia Sign Language",
  csr: "Costa Rican Sign Language",
  css: "Southern Ohlone",
  cst: "Northern Ohlone",
  csv: "Sumtu Chin",
  csw: "Swampy Cree",
  csy: "Siyin Chin",
  csz: "Coos",
  cta: "Tataltepec Chatino",
  ctc: "Chetco",
  ctd: "Tedim Chin",
  cte: "Tepinapa Chinantec",
  ctg: "Chittagonian",
  cth: "Thaiphum Chin",
  ctl: "Tlacoatzintepec Chinantec",
  ctm: "Chitimacha",
  ctn: "Chhintange",
  cto: "Ember-Cato",
  ctp: "Western Highland Chatino",
  cts: "Northern Catanduanes Bikol",
  ctt: "Wayanad Chetti",
  ctu: "Chol",
  ctz: "Zacatepec Chatino",
  cua: "Cua",
  cub: "Cubeo",
  cuc: "Usila Chinantec",
  cug: "Chungmboko",
  cuh: "Chuka",
  cui: "Cuiba",
  cuj: "Mashco Piro",
  cuk: "San Blas Kuna",
  cul: "Culina",
  cuo: "Cumanagoto",
  cup: "Cupeo",
  cuq: "Cun",
  cur: "Chhulung",
  cut: "Teutila Cuicatec",
  cuu: "Tai Ya",
  cuv: "Cuvok",
  cuw: "Chukwa",
  cux: "Tepeuxila Cuicatec",
  cvg: "Chug",
  cvn: "Valle Nacional Chinantec",
  cwa: "Kabwa",
  cwb: "Maindo",
  cwd: "Woods Cree",
  cwe: "Kwere",
  cwg: "Chewong",
  cwt: "Kuwaataay",
  cya: "Nopala Chatino",
  cyb: "Cayubaba",
  cym: "Welsh",
  cyo: "Cuyonon",
  czh: "Huizhou Chinese",
  czk: "Knaanic",
  czn: "Zenzontepec Chatino",
  czo: "Min Zhong Chinese",
  czt: "Zotung Chin",
  daa: "Dangalat",
  dac: "Dambi",
  dad: "Marik",
  dae: "Duupa",
  dag: "Dagbani",
  dah: "Gwahatike",
  dai: "Day",
  daj: "Dar Fur Daju",
  dak: "Dakota",
  dal: "Dahalo",
  dam: "Damakawa",
  dan: "Danish",
  dao: "Daai Chin",
  daq: "Dandami Maria",
  dar: "Dargwa",
  das: "Daho-Doo",
  dau: "Dar Sila Daju",
  dav: "Taita",
  daw: "Davawenyo",
  dax: "Dayi",
  daz: "Dao",
  dba: "Bangime",
  dbb: "Deno",
  dbd: "Dadiya",
  dbe: "Dabe",
  dbf: "Edopi",
  dbg: "Dogul Dom Dogon",
  dbi: "Doka",
  dbj: "Ida'an",
  dbl: "Dyirbal",
  dbm: "Duguri",
  dbn: "Duriankere",
  dbo: "Dulbu",
  dbp: "Duwai",
  dbq: "Daba",
  dbr: "Dabarre",
  dbt: "Ben Tey Dogon",
  dbu: "Bondum Dom Dogon",
  dbv: "Dungu",
  dbw: "Bankan Tey Dogon",
  dby: "Dibiyaso",
  dcc: "Deccan",
  dcr: "Negerhollands",
  dda: "Dadi Dadi",
  ddd: "Dongotono",
  dde: "Doondo",
  ddg: "Fataluku",
  ddi: "West Goodenough",
  ddj: "Jaru",
  ddn: "Dendi (Benin)",
  ddo: "Dido",
  ddr: "Dhudhuroa",
  dds: "Donno So Dogon",
  ddw: "Dawera-Daweloor",
  dec: "Dagik",
  ded: "Dedua",
  dee: "Dewoin",
  def: "Dezfuli",
  deg: "Degema",
  deh: "Dehwari",
  dei: "Demisa",
  dek: "Dek",
  del: "Delaware",
  dem: "Dem",
  den: "Slave (Athapascan)",
  dep: "Pidgin Delaware",
  deq: "Dendi (Central African Republic)",
  der: "Deori",
  des: "Desano",
  deu: "German",
  dev: "Domung",
  dez: "Dengese",
  dga: "Southern Dagaare",
  dgb: "Bunoge Dogon",
  dgc: "Casiguran Dumagat Agta",
  dgd: "Dagaari Dioula",
  dge: "Degenan",
  dgg: "Doga",
  dgh: "Dghwede",
  dgi: "Northern Dagara",
  dgk: "Dagba",
  dgl: "Andaandi",
  dgn: "Dagoman",
  dgo: "Dogri (individual language)",
  dgr: "Dogrib",
  dgs: "Dogoso",
  dgt: "Ndra'ngith",
  dgu: "Degaru",
  dgw: "Daungwurrung",
  dgx: "Doghoro",
  dgz: "Daga",
  dhd: "Dhundari",
  dhg: "Dhangu-Djangu",
  dhi: "Dhimal",
  dhl: "Dhalandji",
  dhm: "Zemba",
  dhn: "Dhanki",
  dho: "Dhodia",
  dhr: "Dhargari",
  dhs: "Dhaiso",
  dhu: "Dhurga",
  dhv: "Dehu",
  dhw: "Dhanwar (Nepal)",
  dhx: "Dhungaloo",
  dia: "Dia",
  dib: "South Central Dinka",
  dic: "Lakota Dida",
  did: "Didinga",
  dif: "Dieri",
  dig: "Digo",
  dih: "Kumiai",
  dii: "Dimbong",
  dij: "Dai",
  dik: "Southwestern Dinka",
  dil: "Dilling",
  dim: "Dime",
  din: "Dinka",
  dio: "Dibo",
  dip: "Northeastern Dinka",
  diq: "Dimli (individual language)",
  dir: "Dirim",
  dis: "Dimasa",
  dit: "Dirari",
  diu: "Diriku",
  div: "Dhivehi",
  diw: "Northwestern Dinka",
  dix: "Dixon Reef",
  diy: "Diuwe",
  diz: "Ding",
  dja: "Djadjawurrung",
  djb: "Djinba",
  djc: "Dar Daju Daju",
  djd: "Djamindjung",
  dje: "Zarma",
  djf: "Djangun",
  dji: "Djinang",
  djj: "Djeebbana",
  djk: "Eastern Maroon Creole",
  djm: "Jamsay Dogon",
  djn: "Djauan",
  djo: "Jangkang",
  djr: "Djambarrpuyngu",
  dju: "Kapriman",
  djw: "Djawi",
  dka: "Dakpakha",
  dkk: "Dakka",
  dkr: "Kuijau",
  dks: "Southeastern Dinka",
  dkx: "Mazagway",
  dlg: "Dolgan",
  dlk: "Dahalik",
  dlm: "Dalmatian",
  dln: "Darlong",
  dma: "Duma",
  dmb: "Mombo Dogon",
  dmc: "Gavak",
  dmd: "Madhi Madhi",
  dme: "Dugwor",
  dmg: "Upper Kinabatangan",
  dmk: "Domaaki",
  dml: "Dameli",
  dmm: "Dama",
  dmo: "Kemedzung",
  dmr: "East Damar",
  dms: "Dampelas",
  dmu: "Dubu",
  dmv: "Dumpas",
  dmw: "Mudburra",
  dmx: "Dema",
  dmy: "Demta",
  dna: "Upper Grand Valley Dani",
  dnd: "Daonda",
  dne: "Ndendeule",
  dng: "Dungan",
  dni: "Lower Grand Valley Dani",
  dnj: "Dan",
  dnk: "Dengka",
  dnn: "Dzngoo",
  dnr: "Danaru",
  dnt: "Mid Grand Valley Dani",
  dnu: "Danau",
  dnv: "Danu",
  dnw: "Western Dani",
  dny: "Den",
  doa: "Dom",
  dob: "Dobu",
  doc: "Northern Dong",
  doe: "Doe",
  dof: "Domu",
  doh: "Dong",
  doi: "Dogri (macrolanguage)",
  dok: "Dondo",
  dol: "Doso",
  don: "Toura (Papua New Guinea)",
  doo: "Dongo",
  dop: "Lukpa",
  doq: "Dominican Sign Language",
  dor: "Dori'o",
  dos: "Dogos",
  dot: "Dass",
  dov: "Dombe",
  dow: "Doyayo",
  dox: "Bussa",
  doy: "Dompo",
  doz: "Dorze",
  dpp: "Papar",
  drb: "Dair",
  drc: "Minderico",
  drd: "Darmiya",
  dre: "Dolpo",
  drg: "Rungus",
  dri: "C'Lela",
  drl: "Paakantyi",
  drn: "West Damar",
  dro: "Daro-Matu Melanau",
  drq: "Dura",
  drr: "Dororo",
  drs: "Gedeo",
  drt: "Drents",
  dru: "Rukai",
  dry: "Darai",
  dsb: "Lower Sorbian",
  dse: "Dutch Sign Language",
  dsh: "Daasanach",
  dsi: "Disa",
  dsl: "Danish Sign Language",
  dsn: "Dusner",
  dso: "Desiya",
  dsq: "Tadaksahak",
  dta: "Daur",
  dtb: "Labuk-Kinabatangan Kadazan",
  dtd: "Ditidaht",
  dth: "Adithinngithigh",
  dti: "Ana Tinga Dogon",
  dtk: "Tene Kan Dogon",
  dtm: "Tomo Kan Dogon",
  dtn: "Daatsiin",
  dto: "Tommo So Dogon",
  dtp: "Kadazan Dusun",
  dtr: "Lotud",
  dts: "Toro So Dogon",
  dtt: "Toro Tegu Dogon",
  dtu: "Tebul Ure Dogon",
  dty: "Dotyali",
  dua: "Duala",
  dub: "Dubli",
  duc: "Duna",
  dud: "Hun-Saare",
  due: "Umiray Dumaget Agta",
  duf: "Dumbea",
  dug: "Duruma",
  duh: "Dungra Bhil",
  dui: "Dumun",
  duk: "Uyajitaya",
  dul: "Alabat Island Agta",
  dum: "Middle Dutch (ca. 1050-1350)",
  dun: "Dusun Deyah",
  duo: "Dupaninan Agta",
  dup: "Duano",
  duq: "Dusun Malang",
  dur: "Dii",
  dus: "Dumi",
  duu: "Drung",
  duv: "Duvle",
  duw: "Dusun Witu",
  dux: "Duungooma",
  duy: "Dicamay Agta",
  duz: "Duli-Gey",
  dva: "Duau",
  dwa: "Diri",
  dwr: "Dawro",
  dws: "Dutton World Speedwords",
  dwu: "Dhuwal",
  dww: "Dawawa",
  dwy: "Dhuwaya",
  dya: "Dyan",
  dyb: "Dyaberdyaber",
  dyd: "Dyugun",
  dyg: "Villa Viciosa Agta",
  dyi: "Djimini Senoufo",
  dym: "Yanda Dom Dogon",
  dyn: "Dyangadi",
  dyo: "Jola-Fonyi",
  dyu: "Dyula",
  dyy: "Dyaabugay",
  dza: "Tunzu",
  dze: "Djiwarli",
  dzg: "Dazaga",
  dzl: "Dzalakha",
  dzn: "Dzando",
  dzo: "Dzongkha",
  eaa: "Karenggapa",
  ebg: "Ebughu",
  ebk: "Eastern Bontok",
  ebo: "Teke-Ebo",
  ebr: "Ebri",
  ebu: "Embu",
  ecr: "Eteocretan",
  ecs: "Ecuadorian Sign Language",
  ecy: "Eteocypriot",
  eee: "E",
  efa: "Efai",
  efe: "Efe",
  efi: "Efik",
  ega: "Ega",
  egl: "Emilian",
  ego: "Eggon",
  egy: "Egyptian (Ancient)",
  ehu: "Ehueun",
  eip: "Eipomek",
  eit: "Eitiep",
  eiv: "Askopan",
  eja: "Ejamat",
  eka: "Ekajuk",
  ekc: "Eastern Karnic",
  eke: "Ekit",
  ekg: "Ekari",
  eki: "Eki",
  ekk: "Standard Estonian",
  ekl: "Kol (Bangladesh)",
  ekm: "Elip",
  eko: "Koti",
  ekp: "Ekpeye",
  ekr: "Yace",
  eky: "Eastern Kayah",
  ele: "Elepi",
  elh: "El Hugeirat",
  eli: "Nding",
  elk: "Elkei",
  ell: "Modern Greek (1453-)",
  elm: "Eleme",
  elo: "El Molo",
  elu: "Elu",
  elx: "Elamite",
  ema: "Emai-Iuleha-Ora",
  emb: "Embaloh",
  eme: "Emerillon",
  emg: "Eastern Meohang",
  emi: "Mussau-Emira",
  emk: "Eastern Maninkakan",
  emm: "Mamulique",
  emn: "Eman",
  emp: "Northern Ember",
  ems: "Pacific Gulf Yupik",
  emu: "Eastern Muria",
  emw: "Emplawas",
  emx: "Erromintxela",
  emy: "Epigraphic Mayan",
  ena: "Apali",
  enb: "Markweeta",
  enc: "En",
  end: "Ende",
  enf: "Forest Enets",
  eng: "English",
  enh: "Tundra Enets",
  enl: "Enlhet",
  enm: "Middle English (1100-1500)",
  enn: "Engenni",
  eno: "Enggano",
  enq: "Enga",
  enr: "Emumu",
  enu: "Enu",
  env: "Enwan (Edu State)",
  enw: "Enwan (Akwa Ibom State)",
  enx: "Enxet",
  eot: "Beti (Cte d'Ivoire)",
  epi: "Epie",
  epo: "Esperanto",
  era: "Eravallan",
  erg: "Sie",
  erh: "Eruwa",
  eri: "Ogea",
  erk: "South Efate",
  ero: "Horpa",
  err: "Erre",
  ers: "Ersu",
  ert: "Eritai",
  erw: "Erokwanas",
  ese: "Ese Ejja",
  esg: "Aheri Gondi",
  esh: "Eshtehardi",
  esi: "North Alaskan Inupiatun",
  esk: "Northwest Alaska Inupiatun",
  esl: "Egypt Sign Language",
  esm: "Esuma",
  esn: "Salvadoran Sign Language",
  eso: "Estonian Sign Language",
  esq: "Esselen",
  ess: "Central Siberian Yupik",
  est: "Estonian",
  esu: "Central Yupik",
  esy: "Eskayan",
  etb: "Etebi",
  etc: "Etchemin",
  eth: "Ethiopian Sign Language",
  etn: "Eton (Vanuatu)",
  eto: "Eton (Cameroon)",
  etr: "Edolo",
  ets: "Yekhee",
  ett: "Etruscan",
  etu: "Ejagham",
  etx: "Eten",
  etz: "Semimi",
  eus: "Basque",
  eve: "Even",
  evh: "Uvbie",
  evn: "Evenki",
  ewe: "Ewe",
  ewo: "Ewondo",
  ext: "Extremaduran",
  eya: "Eyak",
  eyo: "Keiyo",
  eza: "Ezaa",
  eze: "Uzekwe",
  faa: "Fasu",
  fab: "Fa d'Ambu",
  fad: "Wagi",
  faf: "Fagani",
  fag: "Finongan",
  fah: "Baissa Fali",
  fai: "Faiwol",
  faj: "Faita",
  fak: "Fang (Cameroon)",
  fal: "South Fali",
  fam: "Fam",
  fan: "Fang (Equatorial Guinea)",
  fao: "Faroese",
  fap: "Palor",
  far: "Fataleka",
  fas: "Persian",
  fat: "Fanti",
  fau: "Fayu",
  fax: "Fala",
  fay: "Southwestern Fars",
  faz: "Northwestern Fars",
  fbl: "West Albay Bikol",
  fcs: "Quebec Sign Language",
  fer: "Feroge",
  ffi: "Foia Foia",
  ffm: "Maasina Fulfulde",
  fgr: "Fongoro",
  fia: "Nobiin",
  fie: "Fyer",
  fij: "Fijian",
  fil: "Filipino",
  fin: "Finnish",
  fip: "Fipa",
  fir: "Firan",
  fit: "Tornedalen Finnish",
  fiw: "Fiwaga",
  fkk: "Kirya-Konzl",
  fkv: "Kven Finnish",
  fla: "Kalispel-Pend d'Oreille",
  flh: "Foau",
  fli: "Fali",
  fll: "North Fali",
  fln: "Flinders Island",
  flr: "Fuliiru",
  fly: "Flaaitaal",
  fmp: "Fe'fe'",
  fmu: "Far Western Muria",
  fnb: "Fanbak",
  fng: "Fanagalo",
  fni: "Fania",
  fod: "Foodo",
  foi: "Foi",
  fom: "Foma",
  fon: "Fon",
  for: "Fore",
  fos: "Siraya",
  fpe: "Fernando Po Creole English",
  fqs: "Fas",
  fra: "French",
  frc: "Cajun French",
  frd: "Fordata",
  frk: "Frankish",
  frm: "Middle French (ca. 1400-1600)",
  fro: "Old French (842-ca. 1400)",
  frp: "Arpitan",
  frq: "Forak",
  frr: "Northern Frisian",
  frs: "Eastern Frisian",
  frt: "Fortsenal",
  fry: "Western Frisian",
  fse: "Finnish Sign Language",
  fsl: "French Sign Language",
  fss: "Finland-Swedish Sign Language",
  fub: "Adamawa Fulfulde",
  fuc: "Pulaar",
  fud: "East Futuna",
  fue: "Borgu Fulfulde",
  fuf: "Pular",
  fuh: "Western Niger Fulfulde",
  fui: "Bagirmi Fulfulde",
  fuj: "Ko",
  ful: "Fulah",
  fum: "Fum",
  fun: "Fulni",
  fuq: "Central-Eastern Niger Fulfulde",
  fur: "Friulian",
  fut: "Futuna-Aniwa",
  fuu: "Furu",
  fuv: "Nigerian Fulfulde",
  fuy: "Fuyug",
  fvr: "Fur",
  fwa: "Fwi",
  fwe: "Fwe",
  gaa: "Ga",
  gab: "Gabri",
  gac: "Mixed Great Andamanese",
  gad: "Gaddang",
  gae: "Guarequena",
  gaf: "Gende",
  gag: "Gagauz",
  gah: "Alekano",
  gai: "Borei",
  gaj: "Gadsup",
  gak: "Gamkonora",
  gal: "Galolen",
  gam: "Kandawo",
  gan: "Gan Chinese",
  gao: "Gants",
  gap: "Gal",
  gaq: "Gata'",
  gar: "Galeya",
  gas: "Adiwasi Garasia",
  gat: "Kenati",
  gau: "Mudhili Gadaba",
  gaw: "Nobonob",
  gax: "Borana-Arsi-Guji Oromo",
  gay: "Gayo",
  gaz: "West Central Oromo",
  gba: "Gbaya (Central African Republic)",
  gbb: "Kaytetye",
  gbd: "Karadjeri",
  gbe: "Niksek",
  gbf: "Gaikundi",
  gbg: "Gbanziri",
  gbh: "Defi Gbe",
  gbi: "Galela",
  gbj: "Bodo Gadaba",
  gbk: "Gaddi",
  gbl: "Gamit",
  gbm: "Garhwali",
  gbn: "Mo'da",
  gbo: "Northern Grebo",
  gbp: "Gbaya-Bossangoa",
  gbq: "Gbaya-Bozoum",
  gbr: "Gbagyi",
  gbs: "Gbesi Gbe",
  gbu: "Gagadu",
  gbv: "Gbanu",
  gbw: "Gabi-Gabi",
  gbx: "Eastern Xwla Gbe",
  gby: "Gbari",
  gbz: "Zoroastrian Dari",
  gcc: "Mali",
  gcd: "Ganggalida",
  gce: "Galice",
  gcf: "Guadeloupean Creole French",
  gcl: "Grenadian Creole English",
  gcn: "Gaina",
  gcr: "Guianese Creole French",
  gct: "Colonia Tovar German",
  gda: "Gade Lohar",
  gdb: "Pottangi Ollar Gadaba",
  gdc: "Gugu Badhun",
  gdd: "Gedaged",
  gde: "Gude",
  gdf: "Guduf-Gava",
  gdg: "Ga'dang",
  gdh: "Gadjerawang",
  gdi: "Gundi",
  gdj: "Gurdjar",
  gdk: "Gadang",
  gdl: "Dirasha",
  gdm: "Laal",
  gdn: "Umanakaina",
  gdo: "Ghodoberi",
  gdq: "Mehri",
  gdr: "Wipi",
  gds: "Ghandruk Sign Language",
  gdt: "Kungardutyi",
  gdu: "Gudu",
  gdx: "Godwari",
  gea: "Geruma",
  geb: "Kire",
  gec: "Gboloo Grebo",
  ged: "Gade",
  geg: "Gengle",
  geh: "Hutterite German",
  gei: "Gebe",
  gej: "Gen",
  gek: "Ywom",
  gel: "ut-Ma'in",
  geq: "Geme",
  ges: "Geser-Gorom",
  gev: "Eviya",
  gew: "Gera",
  gex: "Garre",
  gey: "Enya",
  gez: "Geez",
  gfk: "Patpatar",
  gft: "Gafat",
  gga: "Gao",
  ggb: "Gbii",
  ggd: "Gugadj",
  gge: "Guragone",
  ggg: "Gurgula",
  ggk: "Kungarakany",
  ggl: "Ganglau",
  ggt: "Gitua",
  ggu: "Gagu",
  ggw: "Gogodala",
  gha: "Ghadams",
  ghc: "Hiberno-Scottish Gaelic",
  ghe: "Southern Ghale",
  ghh: "Northern Ghale",
  ghk: "Geko Karen",
  ghl: "Ghulfan",
  ghn: "Ghanongga",
  gho: "Ghomara",
  ghr: "Ghera",
  ghs: "Guhu-Samane",
  ght: "Kuke",
  gia: "Kitja",
  gib: "Gibanawa",
  gic: "Gail",
  gid: "Gidar",
  gie: "Gaogbo",
  gig: "Goaria",
  gih: "Githabul",
  gil: "Gilbertese",
  gim: "Gimi (Eastern Highlands)",
  gin: "Hinukh",
  gip: "Gimi (West New Britain)",
  giq: "Green Gelao",
  gir: "Red Gelao",
  gis: "North Giziga",
  git: "Gitxsan",
  giu: "Mulao",
  giw: "White Gelao",
  gix: "Gilima",
  giy: "Giyug",
  giz: "South Giziga",
  gji: "Geji",
  gjk: "Kachi Koli",
  gjm: "Gunditjmara",
  gjn: "Gonja",
  gjr: "Gurindji Kriol",
  gju: "Gujari",
  gka: "Guya",
  gke: "Ndai",
  gkn: "Gokana",
  gko: "Kok-Nar",
  gkp: "Guinea Kpelle",
  gku: "Ungkue",
  gla: "Scottish Gaelic",
  glc: "Bon Gula",
  gld: "Nanai",
  gle: "Irish",
  glg: "Galician",
  glh: "Northwest Pashai",
  gli: "Guliguli",
  glj: "Gula Iro",
  glk: "Gilaki",
  gll: "Garlali",
  glo: "Galambu",
  glr: "Glaro-Twabo",
  glu: "Gula (Chad)",
  glv: "Manx",
  glw: "Glavda",
  gly: "Gule",
  gma: "Gambera",
  gmb: "Gula'alaa",
  gmd: "Mghd",
  gmg: "Magyi",
  gmh: "Middle High German (ca. 1050-1500)",
  gml: "Middle Low German",
  gmm: "Gbaya-Mbodomo",
  gmn: "Gimnime",
  gmu: "Gumalu",
  gmv: "Gamo",
  gmx: "Magoma",
  gmy: "Mycenaean Greek",
  gmz: "Mgbolizhia",
  gna: "Kaansa",
  gnb: "Gangte",
  gnc: "Guanche",
  gnd: "Zulgo-Gemzek",
  gne: "Ganang",
  gng: "Ngangam",
  gnh: "Lere",
  gni: "Gooniyandi",
  gnk: "//Gana",
  gnl: "Gangulu",
  gnm: "Ginuman",
  gnn: "Gumatj",
  gno: "Northern Gondi",
  gnq: "Gana",
  gnr: "Gureng Gureng",
  gnt: "Guntai",
  gnu: "Gnau",
  gnw: "Western Bolivian Guaran",
  gnz: "Ganzi",
  goa: "Guro",
  gob: "Playero",
  goc: "Gorakor",
  god: "Godi",
  goe: "Gongduk",
  gof: "Gofa",
  gog: "Gogo",
  goh: "Old High German (ca. 750-1050)",
  goi: "Gobasi",
  goj: "Gowlan",
  gok: "Gowli",
  gol: "Gola",
  gom: "Goan Konkani",
  gon: "Gondi",
  goo: "Gone Dau",
  gop: "Yeretuar",
  goq: "Gorap",
  gor: "Gorontalo",
  gos: "Gronings",
  got: "Gothic",
  gou: "Gavar",
  gow: "Gorowa",
  gox: "Gobu",
  goy: "Goundo",
  goz: "Gozarkhani",
  gpa: "Gupa-Abawa",
  gpe: "Ghanaian Pidgin English",
  gpn: "Taiap",
  gqa: "Ga'anda",
  gqi: "Guiqiong",
  gqn: "Guana (Brazil)",
  gqr: "Gor",
  gqu: "Qau",
  gra: "Rajput Garasia",
  grb: "Grebo",
  grc: "Ancient Greek (to 1453)",
  grd: "Guruntum-Mbaaru",
  grg: "Madi",
  grh: "Gbiri-Niragu",
  gri: "Ghari",
  grj: "Southern Grebo",
  grm: "Kota Marudu Talantang",
  grn: "Guarani",
  gro: "Groma",
  grq: "Gorovu",
  grr: "Taznatit",
  grs: "Gresi",
  grt: "Garo",
  gru: "Kistane",
  grv: "Central Grebo",
  grw: "Gweda",
  grx: "Guriaso",
  gry: "Barclayville Grebo",
  grz: "Guramalum",
  gse: "Ghanaian Sign Language",
  gsg: "German Sign Language",
  gsl: "Gusilay",
  gsm: "Guatemalan Sign Language",
  gsn: "Nema",
  gso: "Southwest Gbaya",
  gsp: "Wasembo",
  gss: "Greek Sign Language",
  gsw: "Swiss German",
  gta: "Guat",
  gtu: "Aghu-Tharnggala",
  gua: "Shiki",
  gub: "Guajajra",
  guc: "Wayuu",
  gud: "Yocobou Dida",
  gue: "Gurinji",
  guf: "Gupapuyngu",
  gug: "Paraguayan Guaran",
  guh: "Guahibo",
  gui: "Eastern Bolivian Guaran",
  guj: "Gujarati",
  guk: "Gumuz",
  gul: "Sea Island Creole English",
  gum: "Guambiano",
  gun: "Mby Guaran",
  guo: "Guayabero",
  gup: "Gunwinggu",
  guq: "Ach",
  gur: "Farefare",
  gus: "Guinean Sign Language",
  gut: "Malku Jaka",
  guu: "Yanomam",
  guw: "Gun",
  gux: "Gourmanchma",
  guz: "Gusii",
  gva: "Guana (Paraguay)",
  gvc: "Guanano",
  gve: "Duwet",
  gvf: "Golin",
  gvj: "Guaj",
  gvl: "Gulay",
  gvm: "Gurmana",
  gvn: "Kuku-Yalanji",
  gvo: "Gavio Do Jiparan",
  gvp: "Par Gavio",
  gvr: "Gurung",
  gvs: "Gumawana",
  gvy: "Guyani",
  gwa: "Mbato",
  gwb: "Gwa",
  gwc: "Kalami",
  gwd: "Gawwada",
  gwe: "Gweno",
  gwf: "Gowro",
  gwg: "Moo",
  gwi: "Gwichin",
  gwj: "/Gwi",
  gwm: "Awngthim",
  gwn: "Gwandara",
  gwr: "Gwere",
  gwt: "Gawar-Bati",
  gwu: "Guwamu",
  gww: "Kwini",
  gwx: "Gua",
  gxx: "W Southern",
  gya: "Northwest Gbaya",
  gyb: "Garus",
  gyd: "Kayardild",
  gye: "Gyem",
  gyf: "Gungabula",
  gyg: "Gbayi",
  gyi: "Gyele",
  gyl: "Gayil",
  gym: "Ngbere",
  gyn: "Guyanese Creole English",
  gyr: "Guarayu",
  gyy: "Gunya",
  gza: "Ganza",
  gzi: "Gazi",
  gzn: "Gane",
  haa: "Han",
  hab: "Hanoi Sign Language",
  hac: "Gurani",
  had: "Hatam",
  hae: "Eastern Oromo",
  haf: "Haiphong Sign Language",
  hag: "Hanga",
  hah: "Hahon",
  hai: "Haida",
  haj: "Hajong",
  hak: "Hakka Chinese",
  hal: "Halang",
  ham: "Hewa",
  han: "Hangaza",
  hao: "Hak",
  hap: "Hupla",
  haq: "Ha",
  har: "Harari",
  has: "Haisla",
  hat: "Haitian",
  hau: "Hausa",
  hav: "Havu",
  haw: "Hawaiian",
  hax: "Southern Haida",
  hay: "Haya",
  haz: "Hazaragi",
  hba: "Hamba",
  hbb: "Huba",
  hbn: "Heiban",
  hbo: "Ancient Hebrew",
  hbs: "Serbo-Croatian",
  hbu: "Habu",
  hca: "Andaman Creole Hindi",
  hch: "Huichol",
  hdn: "Northern Haida",
  hds: "Honduras Sign Language",
  hdy: "Hadiyya",
  hea: "Northern Qiandong Miao",
  heb: "Hebrew",
  hed: "Herd",
  heg: "Helong",
  heh: "Hehe",
  hei: "Heiltsuk",
  hem: "Hemba",
  her: "Herero",
  hgm: "Hai//om",
  hgw: "Haigwai",
  hhi: "Hoia Hoia",
  hhr: "Kerak",
  hhy: "Hoyahoya",
  hia: "Lamang",
  hib: "Hibito",
  hid: "Hidatsa",
  hif: "Fiji Hindi",
  hig: "Kamwe",
  hih: "Pamosu",
  hii: "Hinduri",
  hij: "Hijuk",
  hik: "Seit-Kaitetu",
  hil: "Hiligaynon",
  hin: "Hindi",
  hio: "Tsoa",
  hir: "Himarim",
  hit: "Hittite",
  hiw: "Hiw",
  hix: "Hixkaryna",
  hji: "Haji",
  hka: "Kahe",
  hke: "Hunde",
  hkk: "Hunjara-Kaina Ke",
  hks: "Hong Kong Sign Language",
  hla: "Halia",
  hlb: "Halbi",
  hld: "Halang Doan",
  hle: "Hlersu",
  hlt: "Matu Chin",
  hlu: "Hieroglyphic Luwian",
  hma: "Southern Mashan Hmong",
  hmb: "Humburi Senni Songhay",
  hmc: "Central Huishui Hmong",
  hmd: "Large Flowery Miao",
  hme: "Eastern Huishui Hmong",
  hmf: "Hmong Don",
  hmg: "Southwestern Guiyang Hmong",
  hmh: "Southwestern Huishui Hmong",
  hmi: "Northern Huishui Hmong",
  hmj: "Ge",
  hmk: "Maek",
  hml: "Luopohe Hmong",
  hmm: "Central Mashan Hmong",
  hmn: "Hmong",
  hmo: "Hiri Motu",
  hmp: "Northern Mashan Hmong",
  hmq: "Eastern Qiandong Miao",
  hmr: "Hmar",
  hms: "Southern Qiandong Miao",
  hmt: "Hamtai",
  hmu: "Hamap",
  hmv: "Hmong D",
  hmw: "Western Mashan Hmong",
  hmy: "Southern Guiyang Hmong",
  hmz: "Hmong Shua",
  hna: "Mina (Cameroon)",
  hnd: "Southern Hindko",
  hne: "Chhattisgarhi",
  hnh: "//Ani",
  hni: "Hani",
  hnj: "Hmong Njua",
  hnn: "Hanunoo",
  hno: "Northern Hindko",
  hns: "Caribbean Hindustani",
  hnu: "Hung",
  hoa: "Hoava",
  hob: "Mari (Madang Province)",
  hoc: "Ho",
  hod: "Holma",
  hoe: "Horom",
  hoh: "Hobyt",
  hoi: "Holikachuk",
  hoj: "Hadothi",
  hol: "Holu",
  hom: "Homa",
  hoo: "Holoholo",
  hop: "Hopi",
  hor: "Horo",
  hos: "Ho Chi Minh City Sign Language",
  hot: "Hote",
  hov: "Hovongan",
  how: "Honi",
  hoy: "Holiya",
  hoz: "Hozo",
  hpo: "Hpon",
  hps: "Hawai'i Sign Language (HSL)",
  hra: "Hrangkhol",
  hrc: "Niwer Mil",
  hre: "Hre",
  hrk: "Haruku",
  hrm: "Horned Miao",
  hro: "Haroi",
  hrp: "Nhirrpi",
  hrt: "Hrtevin",
  hru: "Hruso",
  hrv: "Croatian",
  hrw: "Warwar Feni",
  hrx: "Hunsrik",
  hrz: "Harzani",
  hsb: "Upper Sorbian",
  hsh: "Hungarian Sign Language",
  hsl: "Hausa Sign Language",
  hsn: "Xiang Chinese",
  hss: "Harsusi",
  hti: "Hoti",
  hto: "Minica Huitoto",
  hts: "Hadza",
  htu: "Hitu",
  htx: "Middle Hittite",
  hub: "Huambisa",
  huc: "Err:510",
  hud: "Huaulu",
  hue: "San Francisco Del Mar Huave",
  huf: "Humene",
  hug: "Huachipaeri",
  huh: "Huilliche",
  hui: "Huli",
  huj: "Northern Guiyang Hmong",
  huk: "Hulung",
  hul: "Hula",
  hum: "Hungana",
  hun: "Hungarian",
  huo: "Hu",
  hup: "Hupa",
  huq: "Tsat",
  hur: "Halkomelem",
  hus: "Huastec",
  hut: "Humla",
  huu: "Murui Huitoto",
  huv: "San Mateo Del Mar Huave",
  huw: "Hukumina",
  hux: "Npode Huitoto",
  huy: "Hulaul",
  huz: "Hunzib",
  hvc: "Haitian Vodoun Culture Language",
  hve: "San Dionisio Del Mar Huave",
  hvk: "Haveke",
  hvn: "Sabu",
  hvv: "Santa Mara Del Mar Huave",
  hwa: "Wan",
  hwc: "Hawai'i Creole English",
  hwo: "Hwana",
  hya: "Hya",
  hye: "Armenian",
  iai: "Iaai",
  ian: "Iatmul",
  iar: "Purari",
  iba: "Iban",
  ibb: "Ibibio",
  ibd: "Iwaidja",
  ibe: "Akpes",
  ibg: "Ibanag",
  ibh: "Bih",
  ibl: "Ibaloi",
  ibm: "Agoi",
  ibn: "Ibino",
  ibo: "Igbo",
  ibr: "Ibuoro",
  ibu: "Ibu",
  iby: "Ibani",
  ica: "Ede Ica",
  ich: "Etkywan",
  icl: "Icelandic Sign Language",
  icr: "Islander Creole English",
  ida: "Idakho-Isukha-Tiriki",
  idb: "Indo-Portuguese",
  idc: "Idon",
  idd: "Ede Idaca",
  ide: "Idere",
  idi: "Idi",
  ido: "Ido",
  idr: "Indri",
  ids: "Idesa",
  idt: "Idat",
  idu: "Idoma",
  ifa: "Amganad Ifugao",
  ifb: "Batad Ifugao",
  ife: "If",
  iff: "Ifo",
  ifk: "Tuwali Ifugao",
  ifm: "Teke-Fuumu",
  ifu: "Mayoyao Ifugao",
  ify: "Keley-I Kallahan",
  igb: "Ebira",
  ige: "Igede",
  igg: "Igana",
  igl: "Igala",
  igm: "Kanggape",
  ign: "Ignaciano",
  igo: "Isebe",
  igs: "Interglossa",
  igw: "Igwe",
  ihb: "Iha Based Pidgin",
  ihi: "Ihievbe",
  ihp: "Iha",
  ihw: "Bidhawal",
  iii: "Sichuan Yi",
  iin: "Thiin",
  ijc: "Izon",
  ije: "Biseni",
  ijj: "Ede Ije",
  ijn: "Kalabari",
  ijs: "Southeast Ijo",
  ike: "Eastern Canadian Inuktitut",
  iki: "Iko",
  ikk: "Ika",
  ikl: "Ikulu",
  iko: "Olulumo-Ikom",
  ikp: "Ikpeshi",
  ikr: "Ikaranggal",
  iks: "Inuit Sign Language",
  ikt: "Inuinnaqtun",
  iku: "Inuktitut",
  ikv: "Iku-Gora-Ankwa",
  ikw: "Ikwere",
  ikx: "Ik",
  ikz: "Ikizu",
  ila: "Ile Ape",
  ilb: "Ila",
  ile: "Interlingue",
  ilg: "Garig-Ilgar",
  ili: "Ili Turki",
  ilk: "Ilongot",
  ilm: "Iranun (Malaysia)",
  ilo: "Iloko",
  ilp: "Iranun (Philippines)",
  ils: "International Sign",
  ilu: "Ili'uun",
  ilv: "Ilue",
  ima: "Mala Malasar",
  imi: "Anamgura",
  iml: "Miluk",
  imn: "Imonda",
  imo: "Imbongu",
  imr: "Imroing",
  ims: "Marsian",
  imy: "Milyan",
  ina: "Interlingua (International Auxiliary Language Association)",
  inb: "Inga",
  ind: "Indonesian",
  ing: "Degexit'an",
  inh: "Ingush",
  inj: "Jungle Inga",
  inl: "Indonesian Sign Language",
  inm: "Minaean",
  inn: "Isinai",
  ino: "Inoke-Yate",
  inp: "Iapari",
  ins: "Indian Sign Language",
  int: "Intha",
  inz: "Ineseo",
  ior: "Inor",
  iou: "Tuma-Irumu",
  iow: "Iowa-Oto",
  ipi: "Ipili",
  ipk: "Inupiaq",
  ipo: "Ipiko",
  iqu: "Iquito",
  iqw: "Ikwo",
  ire: "Iresim",
  irh: "Irarutu",
  iri: "Irigwe",
  irk: "Iraqw",
  irn: "Irntxe",
  irr: "Ir",
  iru: "Irula",
  irx: "Kamberau",
  iry: "Iraya",
  isa: "Isabi",
  isc: "Isconahua",
  isd: "Isnag",
  ise: "Italian Sign Language",
  isg: "Irish Sign Language",
  ish: "Esan",
  isi: "Nkem-Nkum",
  isk: "Ishkashimi",
  isl: "Icelandic",
  ism: "Masimasi",
  isn: "Isanzu",
  iso: "Isoko",
  isr: "Israeli Sign Language",
  ist: "Istriot",
  isu: "Isu (Menchum Division)",
  ita: "Italian",
  itb: "Binongan Itneg",
  itd: "Southern Tidung",
  ite: "Itene",
  iti: "Inlaod Itneg",
  itk: "Judeo-Italian",
  itl: "Itelmen",
  itm: "Itu Mbon Uzo",
  ito: "Itonama",
  itr: "Iteri",
  its: "Isekiri",
  itt: "Maeng Itneg",
  itv: "Itawit",
  itw: "Ito",
  itx: "Itik",
  ity: "Moyadan Itneg",
  itz: "Itz",
  ium: "Iu Mien",
  ivb: "Ibatan",
  ivv: "Ivatan",
  iwk: "I-Wak",
  iwm: "Iwam",
  iwo: "Iwur",
  iws: "Sepik Iwam",
  ixc: "Ixcatec",
  ixl: "Ixil",
  iya: "Iyayu",
  iyo: "Mesaka",
  iyx: "Yaka (Congo)",
  izh: "Ingrian",
  izr: "Izere",
  izz: "Izii",
  jaa: "Jamamad",
  jab: "Hyam",
  jac: "Popti'",
  jad: "Jahanka",
  jae: "Yabem",
  jaf: "Jara",
  jah: "Jah Hut",
  jaj: "Zazao",
  jak: "Jakun",
  jal: "Yalahatan",
  jam: "Jamaican Creole English",
  jan: "Jandai",
  jao: "Yanyuwa",
  jaq: "Yaqay",
  jas: "New Caledonian Javanese",
  jat: "Jakati",
  jau: "Yaur",
  jav: "Javanese",
  jax: "Jambi Malay",
  jay: "Yan-nhangu",
  jaz: "Jawe",
  jbe: "Judeo-Berber",
  jbi: "Badjiri",
  jbj: "Arandai",
  jbk: "Barikewa",
  jbn: "Nafusi",
  jbo: "Lojban",
  jbr: "Jofotek-Bromnya",
  jbt: "Jabut",
  jbu: "Jukun Takum",
  jbw: "Yawijibaya",
  jcs: "Jamaican Country Sign Language",
  jct: "Krymchak",
  jda: "Jad",
  jdg: "Jadgali",
  jdt: "Judeo-Tat",
  jeb: "Jebero",
  jee: "Jerung",
  jeh: "Jeh",
  jei: "Yei",
  jek: "Jeri Kuo",
  jel: "Yelmek",
  jen: "Dza",
  jer: "Jere",
  jet: "Manem",
  jeu: "Jonkor Bourmataguil",
  jgb: "Ngbee",
  jge: "Judeo-Georgian",
  jgk: "Gwak",
  jgo: "Ngomba",
  jhi: "Jehai",
  jhs: "Jhankot Sign Language",
  jia: "Jina",
  jib: "Jibu",
  jic: "Tol",
  jid: "Bu",
  jie: "Jilbe",
  jig: "Djingili",
  jih: "sTodsde",
  jii: "Jiiddu",
  jil: "Jilim",
  jim: "Jimi (Cameroon)",
  jio: "Jiamao",
  jiq: "Guanyinqiao",
  jit: "Jita",
  jiu: "Youle Jinuo",
  jiv: "Shuar",
  jiy: "Buyuan Jinuo",
  jje: "Jejueo",
  jjr: "Bankal",
  jka: "Kaera",
  jkm: "Mobwa Karen",
  jko: "Kubo",
  jkp: "Paku Karen",
  jkr: "Koro (India)",
  jku: "Labir",
  jle: "Ngile",
  jls: "Jamaican Sign Language",
  jma: "Dima",
  jmb: "Zumbun",
  jmc: "Machame",
  jmd: "Yamdena",
  jmi: "Jimi (Nigeria)",
  jml: "Jumli",
  jmn: "Makuri Naga",
  jmr: "Kamara",
  jms: "Mashi (Nigeria)",
  jmw: "Mouwase",
  jmx: "Western Juxtlahuaca Mixtec",
  jna: "Jangshung",
  jnd: "Jandavra",
  jng: "Yangman",
  jni: "Janji",
  jnj: "Yemsa",
  jnl: "Rawat",
  jns: "Jaunsari",
  job: "Joba",
  jod: "Wojenaka",
  jog: "Jogi",
  jor: "Jor",
  jos: "Jordanian Sign Language",
  jow: "Jowulu",
  jpa: "Jewish Palestinian Aramaic",
  jpn: "Japanese",
  jpr: "Judeo-Persian",
  jqr: "Jaqaru",
  jra: "Jarai",
  jrb: "Judeo-Arabic",
  jrr: "Jiru",
  jrt: "Jorto",
  jru: "Japrera",
  jsl: "Japanese Sign Language",
  jua: "Jma",
  jub: "Wannu",
  juc: "Jurchen",
  jud: "Worodougou",
  juh: "Hne",
  jui: "Ngadjuri",
  juk: "Wapan",
  jul: "Jirel",
  jum: "Jumjum",
  jun: "Juang",
  juo: "Jiba",
  jup: "Hupd",
  jur: "Jurna",
  jus: "Jumla Sign Language",
  jut: "Jutish",
  juu: "Ju",
  juw: "Wpha",
  juy: "Juray",
  jvd: "Javindo",
  jvn: "Caribbean Javanese",
  jwi: "Jwira-Pepesa",
  jya: "Jiarong",
  jye: "Judeo-Yemeni Arabic",
  jyy: "Jaya",
  kaa: "Kara-Kalpak",
  kab: "Kabyle",
  kac: "Kachin",
  kad: "Adara",
  kae: "Ketangalan",
  kaf: "Katso",
  kag: "Kajaman",
  kah: "Kara (Central African Republic)",
  kai: "Karekare",
  kaj: "Jju",
  kak: "Kalanguya",
  kal: "Kalaallisut",
  kam: "Kamba (Kenya)",
  kan: "Kannada",
  kao: "Xaasongaxango",
  kap: "Bezhta",
  kaq: "Capanahua",
  kas: "Kashmiri",
  kat: "Georgian",
  kau: "Kanuri",
  kav: "Katukna",
  kaw: "Kawi",
  kax: "Kao",
  kay: "Kamayur",
  kaz: "Kazakh",
  kba: "Kalarko",
  kbb: "Kaxuina",
  kbc: "Kadiwu",
  kbd: "Kabardian",
  kbe: "Kanju",
  kbg: "Khamba",
  kbh: "Cams",
  kbi: "Kaptiau",
  kbj: "Kari",
  kbk: "Grass Koiari",
  kbl: "Kanembu",
  kbm: "Iwal",
  kbn: "Kare (Central African Republic)",
  kbo: "Keliko",
  kbp: "Kabiy",
  kbq: "Kamano",
  kbr: "Kafa",
  kbs: "Kande",
  kbt: "Abadi",
  kbu: "Kabutra",
  kbv: "Dera (Indonesia)",
  kbw: "Kaiep",
  kbx: "Ap Ma",
  kby: "Manga Kanuri",
  kbz: "Duhwa",
  kca: "Khanty",
  kcb: "Kawacha",
  kcc: "Lubila",
  kcd: "Ngklmpw Kanum",
  kce: "Kaivi",
  kcf: "Ukaan",
  kcg: "Tyap",
  kch: "Vono",
  kci: "Kamantan",
  kcj: "Kobiana",
  kck: "Kalanga",
  kcl: "Kela (Papua New Guinea)",
  kcm: "Gula (Central African Republic)",
  kcn: "Nubi",
  kco: "Kinalakna",
  kcp: "Kanga",
  kcq: "Kamo",
  kcr: "Katla",
  kcs: "Koenoem",
  kct: "Kaian",
  kcu: "Kami (Tanzania)",
  kcv: "Kete",
  kcw: "Kabwari",
  kcx: "Kachama-Ganjule",
  kcy: "Korandje",
  kcz: "Konongo",
  kda: "Worimi",
  kdc: "Kutu",
  kdd: "Yankunytjatjara",
  kde: "Makonde",
  kdf: "Mamusi",
  kdg: "Seba",
  kdh: "Tem",
  kdi: "Kumam",
  kdj: "Karamojong",
  kdk: "Num",
  kdl: "Tsikimba",
  kdm: "Kagoma",
  kdn: "Kunda",
  kdp: "Kaningdon-Nindem",
  kdq: "Koch",
  kdr: "Karaim",
  kdt: "Kuy",
  kdu: "Kadaru",
  kdw: "Koneraw",
  kdx: "Kam",
  kdy: "Keder",
  kdz: "Kwaja",
  kea: "Kabuverdianu",
  keb: "Kl",
  kec: "Keiga",
  ked: "Kerewe",
  kee: "Eastern Keres",
  kef: "Kpessi",
  keg: "Tese",
  keh: "Keak",
  kei: "Kei",
  kej: "Kadar",
  kek: "Kekch",
  kel: "Kela (Democratic Republic of Congo)",
  kem: "Kemak",
  ken: "Kenyang",
  keo: "Kakwa",
  kep: "Kaikadi",
  keq: "Kamar",
  ker: "Kera",
  kes: "Kugbo",
  ket: "Ket",
  keu: "Akebu",
  kev: "Kanikkaran",
  kew: "West Kewa",
  kex: "Kukna",
  key: "Kupia",
  kez: "Kukele",
  kfa: "Kodava",
  kfb: "Northwestern Kolami",
  kfc: "Konda-Dora",
  kfd: "Korra Koraga",
  kfe: "Kota (India)",
  kff: "Koya",
  kfg: "Kudiya",
  kfh: "Kurichiya",
  kfi: "Kannada Kurumba",
  kfj: "Kemiehua",
  kfk: "Kinnauri",
  kfl: "Kung",
  kfm: "Khunsari",
  kfn: "Kuk",
  kfo: "Koro (Cte d'Ivoire)",
  kfp: "Korwa",
  kfq: "Korku",
  kfr: "Kachhi",
  kfs: "Bilaspuri",
  kft: "Kanjari",
  kfu: "Katkari",
  kfv: "Kurmukar",
  kfw: "Kharam Naga",
  kfx: "Kullu Pahari",
  kfy: "Kumaoni",
  kfz: "Koromf",
  kga: "Koyaga",
  kgb: "Kawe",
  kge: "Komering",
  kgf: "Kube",
  kgg: "Kusunda",
  kgi: "Selangor Sign Language",
  kgj: "Gamale Kham",
  kgk: "Kaiw",
  kgl: "Kunggari",
  kgm: "Karipna",
  kgn: "Karingani",
  kgo: "Krongo",
  kgp: "Kaingang",
  kgq: "Kamoro",
  kgr: "Abun",
  kgs: "Kumbainggar",
  kgt: "Somyev",
  kgu: "Kobol",
  kgv: "Karas",
  kgw: "Karon Dori",
  kgx: "Kamaru",
  kgy: "Kyerung",
  kha: "Khasi",
  khb: "L",
  khc: "Tukang Besi North",
  khd: "Bdi Kanum",
  khe: "Korowai",
  khf: "Khuen",
  khg: "Khams Tibetan",
  khh: "Kehu",
  khj: "Kuturmi",
  khk: "Halh Mongolian",
  khl: "Lusi",
  khm: "Central Khmer",
  khn: "Khandesi",
  kho: "Khotanese",
  khp: "Kapori",
  khq: "Koyra Chiini Songhay",
  khr: "Kharia",
  khs: "Kasua",
  kht: "Khamti",
  khu: "Nkhumbi",
  khv: "Khvarshi",
  khw: "Khowar",
  khx: "Kanu",
  khy: "Kele (Democratic Republic of Congo)",
  khz: "Keapara",
  kia: "Kim",
  kib: "Koalib",
  kic: "Kickapoo",
  kid: "Koshin",
  kie: "Kibet",
  kif: "Eastern Parbate Kham",
  kig: "Kimaama",
  kih: "Kilmeri",
  kii: "Kitsai",
  kij: "Kilivila",
  kik: "Kikuyu",
  kil: "Kariya",
  kim: "Karagas",
  kin: "Kinyarwanda",
  kio: "Kiowa",
  kip: "Sheshi Kham",
  kiq: "Kosadle",
  kir: "Kirghiz",
  kis: "Kis",
  kit: "Agob",
  kiu: "Kirmanjki (individual language)",
  kiv: "Kimbu",
  kiw: "Northeast Kiwai",
  kix: "Khiamniungan Naga",
  kiy: "Kirikiri",
  kiz: "Kisi",
  kja: "Mlap",
  kjb: "Q'anjob'al",
  kjc: "Coastal Konjo",
  kjd: "Southern Kiwai",
  kje: "Kisar",
  kjf: "Khalaj",
  kjg: "Khmu",
  kjh: "Khakas",
  kji: "Zabana",
  kjj: "Khinalugh",
  kjk: "Highland Konjo",
  kjl: "Western Parbate Kham",
  kjm: "Khng",
  kjn: "Kunjen",
  kjo: "Harijan Kinnauri",
  kjp: "Pwo Eastern Karen",
  kjq: "Western Keres",
  kjr: "Kurudu",
  kjs: "East Kewa",
  kjt: "Phrae Pwo Karen",
  kju: "Kashaya",
  kjv: "Kaikavian Literary Language",
  kjx: "Ramopa",
  kjy: "Erave",
  kjz: "Bumthangkha",
  kka: "Kakanda",
  kkb: "Kwerisa",
  kkc: "Odoodee",
  kkd: "Kinuku",
  kke: "Kakabe",
  kkf: "Kalaktang Monpa",
  kkg: "Mabaka Valley Kalinga",
  kkh: "Khn",
  kki: "Kagulu",
  kkj: "Kako",
  kkk: "Kokota",
  kkl: "Kosarek Yale",
  kkm: "Kiong",
  kkn: "Kon Keu",
  kko: "Karko",
  kkp: "Gugubera",
  kkq: "Kaiku",
  kkr: "Kir-Balar",
  kks: "Giiwo",
  kkt: "Koi",
  kku: "Tumi",
  kkv: "Kangean",
  kkw: "Teke-Kukuya",
  kkx: "Kohin",
  kky: "Guguyimidjir",
  kkz: "Kaska",
  kla: "Klamath-Modoc",
  klb: "Kiliwa",
  klc: "Kolbila",
  kld: "Gamilaraay",
  kle: "Kulung (Nepal)",
  klf: "Kendeje",
  klg: "Tagakaulo",
  klh: "Weliki",
  kli: "Kalumpang",
  klj: "Turkic Khalaj",
  klk: "Kono (Nigeria)",
  kll: "Kagan Kalagan",
  klm: "Migum",
  kln: "Kalenjin",
  klo: "Kapya",
  klp: "Kamasa",
  klq: "Rumu",
  klr: "Khaling",
  kls: "Kalasha",
  klt: "Nukna",
  klu: "Klao",
  klv: "Maskelynes",
  klw: "Tado",
  klx: "Koluwawa",
  kly: "Kalao",
  klz: "Kabola",
  kma: "Konni",
  kmb: "Kimbundu",
  kmc: "Southern Dong",
  kmd: "Majukayang Kalinga",
  kme: "Bakole",
  kmf: "Kare (Papua New Guinea)",
  kmg: "Kte",
  kmh: "Kalam",
  kmi: "Kami (Nigeria)",
  kmj: "Kumarbhag Paharia",
  kmk: "Limos Kalinga",
  kml: "Tanudan Kalinga",
  kmm: "Kom (India)",
  kmn: "Awtuw",
  kmo: "Kwoma",
  kmp: "Gimme",
  kmq: "Kwama",
  kmr: "Northern Kurdish",
  kms: "Kamasau",
  kmt: "Kemtuik",
  kmu: "Kanite",
  kmv: "Karipna Creole French",
  kmw: "Komo (Democratic Republic of Congo)",
  kmx: "Waboda",
  kmy: "Koma",
  kmz: "Khorasani Turkish",
  kna: "Dera (Nigeria)",
  knb: "Lubuagan Kalinga",
  knc: "Central Kanuri",
  knd: "Konda",
  kne: "Kankanaey",
  knf: "Mankanya",
  kng: "Koongo",
  kni: "Kanufi",
  knj: "Western Kanjobal",
  knk: "Kuranko",
  knl: "Keninjal",
  knm: "Kanamar",
  knn: "Konkani (individual language)",
  kno: "Kono (Sierra Leone)",
  knp: "Kwanja",
  knq: "Kintaq",
  knr: "Kaningra",
  kns: "Kensiu",
  knt: "Panoan Katukna",
  knu: "Kono (Guinea)",
  knv: "Tabo",
  knw: "Kung-Ekoka",
  knx: "Kendayan",
  kny: "Kanyok",
  knz: "Kalams",
  koa: "Konomala",
  koc: "Kpati",
  kod: "Kodi",
  koe: "Kacipo-Balesi",
  kof: "Kubi",
  kog: "Cogui",
  koh: "Koyo",
  koi: "Komi-Permyak",
  kok: "Konkani (macrolanguage)",
  kol: "Kol (Papua New Guinea)",
  kom: "Komi",
  kon: "Kongo",
  koo: "Konzo",
  kop: "Waube",
  koq: "Kota (Gabon)",
  kor: "Korean",
  kos: "Kosraean",
  kot: "Lagwan",
  kou: "Koke",
  kov: "Kudu-Camo",
  kow: "Kugama",
  koy: "Koyukon",
  koz: "Korak",
  kpa: "Kutto",
  kpb: "Mullu Kurumba",
  kpc: "Curripaco",
  kpd: "Koba",
  kpe: "Kpelle",
  kpf: "Komba",
  kpg: "Kapingamarangi",
  kph: "Kplang",
  kpi: "Kofei",
  kpj: "Karaj",
  kpk: "Kpan",
  kpl: "Kpala",
  kpm: "Koho",
  kpn: "Kepkiriwt",
  kpo: "Ikposo",
  kpq: "Korupun-Sela",
  kpr: "Korafe-Yegha",
  kps: "Tehit",
  kpt: "Karata",
  kpu: "Kafoa",
  kpv: "Komi-Zyrian",
  kpw: "Kobon",
  kpx: "Mountain Koiali",
  kpy: "Koryak",
  kpz: "Kupsabiny",
  kqa: "Mum",
  kqb: "Kovai",
  kqc: "Doromu-Koki",
  kqd: "Koy Sanjaq Surat",
  kqe: "Kalagan",
  kqf: "Kakabai",
  kqg: "Khe",
  kqh: "Kisankasa",
  kqi: "Koitabu",
  kqj: "Koromira",
  kqk: "Kotafon Gbe",
  kql: "Kyenele",
  kqm: "Khisa",
  kqn: "Kaonde",
  kqo: "Eastern Krahn",
  kqp: "Kimr",
  kqq: "Krenak",
  kqr: "Kimaragang",
  kqs: "Northern Kissi",
  kqt: "Klias River Kadazan",
  kqu: "Seroa",
  kqv: "Okolod",
  kqw: "Kandas",
  kqx: "Mser",
  kqy: "Koorete",
  kqz: "Korana",
  kra: "Kumhali",
  krb: "Karkin",
  krc: "Karachay-Balkar",
  krd: "Kairui-Midiki",
  kre: "Panar",
  krf: "Koro (Vanuatu)",
  krh: "Kurama",
  kri: "Krio",
  krj: "Kinaray-A",
  krk: "Kerek",
  krl: "Karelian",
  krn: "Sapo",
  krp: "Korop",
  krr: "Krung",
  krs: "Gbaya (Sudan)",
  krt: "Tumari Kanuri",
  kru: "Kurukh",
  krv: "Kavet",
  krw: "Western Krahn",
  krx: "Karon",
  kry: "Kryts",
  krz: "Sota Kanum",
  ksa: "Shuwa-Zamani",
  ksb: "Shambala",
  ksc: "Southern Kalinga",
  ksd: "Kuanua",
  kse: "Kuni",
  ksf: "Bafia",
  ksg: "Kusaghe",
  ksh: "Klsch",
  ksi: "Krisa",
  ksj: "Uare",
  ksk: "Kansa",
  ksl: "Kumalu",
  ksm: "Kumba",
  ksn: "Kasiguranin",
  kso: "Kofa",
  ksp: "Kaba",
  ksq: "Kwaami",
  ksr: "Borong",
  kss: "Southern Kisi",
  kst: "Winy",
  ksu: "Khamyang",
  ksv: "Kusu",
  ksw: "S'gaw Karen",
  ksx: "Kedang",
  ksy: "Kharia Thar",
  ksz: "Kodaku",
  kta: "Katua",
  ktb: "Kambaata",
  ktc: "Kholok",
  ktd: "Kokata",
  kte: "Nubri",
  ktf: "Kwami",
  ktg: "Kalkutung",
  kth: "Karanga",
  kti: "North Muyu",
  ktj: "Plapo Krumen",
  ktk: "Kaniet",
  ktl: "Koroshi",
  ktm: "Kurti",
  ktn: "Karitina",
  kto: "Kuot",
  ktp: "Kaduo",
  ktq: "Katabaga",
  kts: "South Muyu",
  ktt: "Ketum",
  ktu: "Kituba (Democratic Republic of Congo)",
  ktv: "Eastern Katu",
  ktw: "Kato",
  ktx: "Kaxarar",
  kty: "Kango (Bas-Ul District)",
  ktz: "Ju/'hoan",
  kua: "Kuanyama",
  kub: "Kutep",
  kuc: "Kwinsu",
  kud: "'Auhelawa",
  kue: "Kuman (Papua New Guinea)",
  kuf: "Western Katu",
  kug: "Kupa",
  kuh: "Kushi",
  kui: "Kuikro-Kalaplo",
  kuj: "Kuria",
  kuk: "Kepo'",
  kul: "Kulere",
  kum: "Kumyk",
  kun: "Kunama",
  kuo: "Kumukio",
  kup: "Kunimaipa",
  kuq: "Karipuna",
  kur: "Kurdish",
  kus: "Kusaal",
  kut: "Kutenai",
  kuu: "Upper Kuskokwim",
  kuv: "Kur",
  kuw: "Kpagua",
  kux: "Kukatja",
  kuy: "Kuuku-Ya'u",
  kuz: "Kunza",
  kva: "Bagvalal",
  kvb: "Kubu",
  kvc: "Kove",
  kvd: "Kui (Indonesia)",
  kve: "Kalabakan",
  kvf: "Kabalai",
  kvg: "Kuni-Boazi",
  kvh: "Komodo",
  kvi: "Kwang",
  kvj: "Psikye",
  kvk: "Korean Sign Language",
  kvl: "Kayaw",
  kvm: "Kendem",
  kvn: "Border Kuna",
  kvo: "Dobel",
  kvp: "Kompane",
  kvq: "Geba Karen",
  kvr: "Kerinci",
  kvt: "Lahta Karen",
  kvu: "Yinbaw Karen",
  kvv: "Kola",
  kvw: "Wersing",
  kvx: "Parkari Koli",
  kvy: "Yintale Karen",
  kvz: "Tsakwambo",
  kwa: "Dw",
  kwb: "Kwa",
  kwc: "Likwala",
  kwd: "Kwaio",
  kwe: "Kwerba",
  kwf: "Kwara'ae",
  kwg: "Sara Kaba Deme",
  kwh: "Kowiai",
  kwi: "Awa-Cuaiquer",
  kwj: "Kwanga",
  kwk: "Kwakiutl",
  kwl: "Kofyar",
  kwm: "Kwambi",
  kwn: "Kwangali",
  kwo: "Kwomtari",
  kwp: "Kodia",
  kwr: "Kwer",
  kws: "Kwese",
  kwt: "Kwesten",
  kwu: "Kwakum",
  kwv: "Sara Kaba N",
  kww: "Kwinti",
  kwx: "Khirwar",
  kwy: "San Salvador Kongo",
  kwz: "Kwadi",
  kxa: "Kairiru",
  kxb: "Krobu",
  kxc: "Konso",
  kxd: "Brunei",
  kxf: "Manumanaw Karen",
  kxh: "Karo (Ethiopia)",
  kxi: "Keningau Murut",
  kxj: "Kulfa",
  kxk: "Zayein Karen",
  kxl: "Nepali Kurux",
  kxm: "Northern Khmer",
  kxn: "Kanowit-Tanjong Melanau",
  kxo: "Kano",
  kxp: "Wadiyara Koli",
  kxq: "Smrky Kanum",
  kxr: "Koro (Papua New Guinea)",
  kxs: "Kangjia",
  kxt: "Koiwat",
  kxu: "Kui (India)",
  kxv: "Kuvi",
  kxw: "Konai",
  kxx: "Likuba",
  kxy: "Kayong",
  kxz: "Kerewo",
  kya: "Kwaya",
  kyb: "Butbut Kalinga",
  kyc: "Kyaka",
  kyd: "Karey",
  kye: "Krache",
  kyf: "Kouya",
  kyg: "Keyagana",
  kyh: "Karok",
  kyi: "Kiput",
  kyj: "Karao",
  kyk: "Kamayo",
  kyl: "Kalapuya",
  kym: "Kpatili",
  kyn: "Northern Binukidnon",
  kyo: "Kelon",
  kyp: "Kang",
  kyq: "Kenga",
  kyr: "Kuruya",
  kys: "Baram Kayan",
  kyt: "Kayagar",
  kyu: "Western Kayah",
  kyv: "Kayort",
  kyw: "Kudmali",
  kyx: "Rapoisi",
  kyy: "Kambaira",
  kyz: "Kayab",
  kza: "Western Karaboro",
  kzb: "Kaibobo",
  kzc: "Bondoukou Kulango",
  kzd: "Kadai",
  kze: "Kosena",
  kzf: "Da'a Kaili",
  kzg: "Kikai",
  kzi: "Kelabit",
  kzk: "Kazukuru",
  kzl: "Kayeli",
  kzm: "Kais",
  kzn: "Kokola",
  kzo: "Kaningi",
  kzp: "Kaidipang",
  kzq: "Kaike",
  kzr: "Karang",
  kzs: "Sugut Dusun",
  kzu: "Kayupulau",
  kzv: "Komyandaret",
  kzw: "Karir-Xoc",
  kzx: "Kamarian",
  kzy: "Kango (Tshopo District)",
  kzz: "Kalabra",
  laa: "Southern Subanen",
  lab: "Linear A",
  lac: "Lacandon",
  lad: "Ladino",
  lae: "Pattani",
  laf: "Lafofa",
  lag: "Langi",
  lah: "Lahnda",
  lai: "Lambya",
  laj: "Lango (Uganda)",
  lak: "Laka (Nigeria)",
  lal: "Lalia",
  lam: "Lamba",
  lan: "Laru",
  lao: "Lao",
  lap: "Laka (Chad)",
  laq: "Qabiao",
  lar: "Larteh",
  las: "Lama (Togo)",
  lat: "Latin",
  lau: "Laba",
  lav: "Latvian",
  law: "Lauje",
  lax: "Tiwa",
  lay: "Lama Bai",
  laz: "Aribwatsa",
  lba: "Lui",
  lbb: "Label",
  lbc: "Lakkia",
  lbe: "Lak",
  lbf: "Tinani",
  lbg: "Laopang",
  lbi: "La'bi",
  lbj: "Ladakhi",
  lbk: "Central Bontok",
  lbl: "Libon Bikol",
  lbm: "Lodhi",
  lbn: "Lamet",
  lbo: "Laven",
  lbq: "Wampar",
  lbr: "Lohorung",
  lbs: "Libyan Sign Language",
  lbt: "Lachi",
  lbu: "Labu",
  lbv: "Lavatbura-Lamusong",
  lbw: "Tolaki",
  lbx: "Lawangan",
  lby: "Lamu-Lamu",
  lbz: "Lardil",
  lcc: "Legenyem",
  lcd: "Lola",
  lce: "Loncong",
  lcf: "Lubu",
  lch: "Luchazi",
  lcl: "Lisela",
  lcm: "Tungag",
  lcp: "Western Lawa",
  lcq: "Luhu",
  lcs: "Lisabata-Nuniali",
  lda: "Kla-Dan",
  ldb: "Duya",
  ldd: "Luri",
  ldg: "Lenyima",
  ldh: "Lamja-Dengsa-Tola",
  ldi: "Laari",
  ldj: "Lemoro",
  ldk: "Leelau",
  ldl: "Kaan",
  ldm: "Landoma",
  ldn: "Ladan",
  ldo: "Loo",
  ldp: "Tso",
  ldq: "Lufu",
  lea: "Lega-Shabunda",
  leb: "Lala-Bisa",
  lec: "Leco",
  led: "Lendu",
  lee: "Lyl",
  lef: "Lelemi",
  leh: "Lenje",
  lei: "Lemio",
  lej: "Lengola",
  lek: "Leipon",
  lel: "Lele (Democratic Republic of Congo)",
  lem: "Nomaande",
  len: "Lenca",
  leo: "Leti (Cameroon)",
  lep: "Lepcha",
  leq: "Lembena",
  ler: "Lenkau",
  les: "Lese",
  let: "Lesing-Gelimi",
  leu: "Kara (Papua New Guinea)",
  lev: "Lamma",
  lew: "Ledo Kaili",
  lex: "Luang",
  ley: "Lemolang",
  lez: "Lezghian",
  lfa: "Lefa",
  lfn: "Lingua Franca Nova",
  lga: "Lungga",
  lgb: "Laghu",
  lgg: "Lugbara",
  lgh: "Laghuu",
  lgi: "Lengilu",
  lgk: "Lingarak",
  lgl: "Wala",
  lgm: "Lega-Mwenga",
  lgn: "T'apo",
  lgq: "Logba",
  lgr: "Lengo",
  lgt: "Pahi",
  lgu: "Longgu",
  lgz: "Ligenza",
  lha: "Laha (Viet Nam)",
  lhh: "Laha (Indonesia)",
  lhi: "Lahu Shi",
  lhl: "Lahul Lohar",
  lhm: "Lhomi",
  lhn: "Lahanan",
  lhp: "Lhokpu",
  lhs: "Mlahs",
  lht: "Lo-Toga",
  lhu: "Lahu",
  lia: "West-Central Limba",
  lib: "Likum",
  lic: "Hlai",
  lid: "Nyindrou",
  lie: "Likila",
  lif: "Limbu",
  lig: "Ligbi",
  lih: "Lihir",
  lij: "Ligurian",
  lik: "Lika",
  lil: "Lillooet",
  lim: "Limburgan",
  lin: "Lingala",
  lio: "Liki",
  lip: "Sekpele",
  liq: "Libido",
  lir: "Liberian English",
  lis: "Lisu",
  lit: "Lithuanian",
  liu: "Logorik",
  liv: "Liv",
  liw: "Col",
  lix: "Liabuku",
  liy: "Banda-Bambari",
  liz: "Libinza",
  lja: "Golpa",
  lje: "Rampi",
  lji: "Laiyolo",
  ljl: "Li'o",
  ljp: "Lampung Api",
  ljw: "Yirandali",
  ljx: "Yuru",
  lka: "Lakalei",
  lkb: "Kabras",
  lkc: "Kucong",
  lkd: "Lakond",
  lke: "Kenyi",
  lkh: "Lakha",
  lki: "Laki",
  lkj: "Remun",
  lkl: "Laeko-Libuat",
  lkm: "Kalaamaya",
  lkn: "Lakon",
  lko: "Khayo",
  lkr: "Pri",
  lks: "Kisa",
  lkt: "Lakota",
  lku: "Kungkari",
  lky: "Lokoya",
  lla: "Lala-Roba",
  llb: "Lolo",
  llc: "Lele (Guinea)",
  lld: "Ladin",
  lle: "Lele (Papua New Guinea)",
  llf: "Hermit",
  llg: "Lole",
  llh: "Lamu",
  lli: "Teke-Laali",
  llj: "Ladji Ladji",
  llk: "Lelak",
  lll: "Lilau",
  llm: "Lasalimu",
  lln: "Lele (Chad)",
  llo: "Khlor",
  llp: "North Efate",
  llq: "Lolak",
  lls: "Lithuanian Sign Language",
  llu: "Lau",
  llx: "Lauan",
  lma: "East Limba",
  lmb: "Merei",
  lmc: "Limilngan",
  lmd: "Lumun",
  lme: "Pv",
  lmf: "South Lembata",
  lmg: "Lamogai",
  lmh: "Lambichhong",
  lmi: "Lombi",
  lmj: "West Lembata",
  lmk: "Lamkang",
  lml: "Hano",
  lmn: "Lambadi",
  lmo: "Lombard",
  lmp: "Limbum",
  lmq: "Lamatuka",
  lmr: "Lamalera",
  lmu: "Lamenu",
  lmv: "Lomaiviti",
  lmw: "Lake Miwok",
  lmx: "Laimbue",
  lmy: "Lamboya",
  lmz: "Lumbee",
  lna: "Langbashe",
  lnb: "Mbalanhu",
  lnd: "Lundayeh",
  lng: "Langobardic",
  lnh: "Lanoh",
  lni: "Daantanai'",
  lnj: "Leningitij",
  lnl: "South Central Banda",
  lnm: "Langam",
  lnn: "Lorediakarkar",
  lno: "Lango (Sudan)",
  lns: "Lamnso'",
  lnu: "Longuda",
  lnw: "Lanima",
  lnz: "Lonzo",
  loa: "Loloda",
  lob: "Lobi",
  loc: "Inonhan",
  loe: "Saluan",
  lof: "Logol",
  log: "Logo",
  loh: "Narim",
  loi: "Loma (Cte d'Ivoire)",
  loj: "Lou",
  lok: "Loko",
  lol: "Mongo",
  lom: "Loma (Liberia)",
  lon: "Malawi Lomwe",
  loo: "Lombo",
  lop: "Lopa",
  loq: "Lobala",
  lor: "Tn",
  los: "Loniu",
  lot: "Otuho",
  lou: "Louisiana Creole",
  lov: "Lopi",
  low: "Tampias Lobu",
  lox: "Loun",
  loy: "Loke",
  loz: "Lozi",
  lpa: "Lelepa",
  lpe: "Lepki",
  lpn: "Long Phuri Naga",
  lpo: "Lipo",
  lpx: "Lopit",
  lra: "Rara Bakati'",
  lrc: "Northern Luri",
  lre: "Laurentian",
  lrg: "Laragia",
  lri: "Marachi",
  lrk: "Loarki",
  lrl: "Lari",
  lrm: "Marama",
  lrn: "Lorang",
  lro: "Laro",
  lrr: "Southern Yamphu",
  lrt: "Larantuka Malay",
  lrv: "Larevat",
  lrz: "Lemerig",
  lsa: "Lasgerdi",
  lsd: "Lishana Deni",
  lse: "Lusengo",
  lsg: "Lyons Sign Language",
  lsh: "Lish",
  lsi: "Lashi",
  lsl: "Latvian Sign Language",
  lsm: "Saamia",
  lso: "Laos Sign Language",
  lsp: "Panamanian Sign Language",
  lsr: "Aruop",
  lss: "Lasi",
  lst: "Trinidad and Tobago Sign Language",
  lsy: "Mauritian Sign Language",
  ltc: "Late Middle Chinese",
  ltg: "Latgalian",
  lth: "Thur",
  lti: "Leti (Indonesia)",
  ltn: "Latund",
  lto: "Tsotso",
  lts: "Tachoni",
  ltu: "Latu",
  ltz: "Luxembourgish",
  lua: "Luba-Lulua",
  lub: "Luba-Katanga",
  luc: "Aringa",
  lud: "Ludian",
  lue: "Luvale",
  luf: "Laua",
  lug: "Ganda",
  lui: "Luiseno",
  luj: "Luna",
  luk: "Lunanakha",
  lul: "Olu'bo",
  lum: "Luimbi",
  lun: "Lunda",
  luo: "Luo (Kenya and Tanzania)",
  lup: "Lumbu",
  luq: "Lucumi",
  lur: "Laura",
  lus: "Lushai",
  lut: "Lushootseed",
  luu: "Lumba-Yakkha",
  luv: "Luwati",
  luw: "Luo (Cameroon)",
  luy: "Luyia",
  luz: "Southern Luri",
  lva: "Maku'a",
  lvk: "Lavukaleve",
  lvs: "Standard Latvian",
  lvu: "Levuka",
  lwa: "Lwalu",
  lwe: "Lewo Eleng",
  lwg: "Wanga",
  lwh: "White Lachi",
  lwl: "Eastern Lawa",
  lwm: "Laomian",
  lwo: "Luwo",
  lwt: "Lewotobi",
  lwu: "Lawu",
  lww: "Lewo",
  lya: "Layakha",
  lyg: "Lyngngam",
  lyn: "Luyana",
  lzh: "Literary Chinese",
  lzl: "Litzlitz",
  lzn: "Leinong Naga",
  lzz: "Laz",
  maa: "San Jernimo Tecatl Mazatec",
  mab: "Yutanduchi Mixtec",
  mad: "Madurese",
  mae: "Bo-Rukul",
  maf: "Mafa",
  mag: "Magahi",
  mah: "Marshallese",
  mai: "Maithili",
  maj: "Jalapa De Daz Mazatec",
  mak: "Makasar",
  mal: "Malayalam",
  mam: "Mam",
  man: "Mandingo",
  maq: "Chiquihuitln Mazatec",
  mar: "Marathi",
  mas: "Masai",
  mat: "San Francisco Matlatzinca",
  mau: "Huautla Mazatec",
  mav: "Sater-Maw",
  maw: "Mampruli",
  max: "North Moluccan Malay",
  maz: "Central Mazahua",
  mba: "Higaonon",
  mbb: "Western Bukidnon Manobo",
  mbc: "Macushi",
  mbd: "Dibabawon Manobo",
  mbe: "Molale",
  mbf: "Baba Malay",
  mbh: "Mangseng",
  mbi: "Ilianen Manobo",
  mbj: "Nadb",
  mbk: "Malol",
  mbl: "Maxakal",
  mbm: "Ombamba",
  mbn: "Macagun",
  mbo: "Mbo (Cameroon)",
  mbp: "Malayo",
  mbq: "Maisin",
  mbr: "Nukak Mak",
  mbs: "Sarangani Manobo",
  mbt: "Matigsalug Manobo",
  mbu: "Mbula-Bwazza",
  mbv: "Mbulungish",
  mbw: "Maring",
  mbx: "Mari (East Sepik Province)",
  mby: "Memoni",
  mbz: "Amoltepec Mixtec",
  mca: "Maca",
  mcb: "Machiguenga",
  mcc: "Bitur",
  mcd: "Sharanahua",
  mce: "Itundujia Mixtec",
  mcf: "Matss",
  mcg: "Mapoyo",
  mch: "Maquiritari",
  mci: "Mese",
  mcj: "Mvanip",
  mck: "Mbunda",
  mcl: "Macaguaje",
  mcm: "Malaccan Creole Portuguese",
  mcn: "Masana",
  mco: "Coatln Mixe",
  mcp: "Makaa",
  mcq: "Ese",
  mcr: "Menya",
  mcs: "Mambai",
  mct: "Mengisa",
  mcu: "Cameroon Mambila",
  mcv: "Minanibai",
  mcw: "Mawa (Chad)",
  mcx: "Mpiemo",
  mcy: "South Watut",
  mcz: "Mawan",
  mda: "Mada (Nigeria)",
  mdb: "Morigi",
  mdc: "Male (Papua New Guinea)",
  mdd: "Mbum",
  mde: "Maba (Chad)",
  mdf: "Moksha",
  mdg: "Massalat",
  mdh: "Maguindanaon",
  mdi: "Mamvu",
  mdj: "Mangbetu",
  mdk: "Mangbutu",
  mdl: "Maltese Sign Language",
  mdm: "Mayogo",
  mdn: "Mbati",
  mdp: "Mbala",
  mdq: "Mbole",
  mdr: "Mandar",
  mds: "Maria (Papua New Guinea)",
  mdt: "Mbere",
  mdu: "Mboko",
  mdv: "Santa Luca Monteverde Mixtec",
  mdw: "Mbosi",
  mdx: "Dizin",
  mdy: "Male (Ethiopia)",
  mdz: "Suru Do Par",
  mea: "Menka",
  meb: "Ikobi",
  mec: "Mara",
  med: "Melpa",
  mee: "Mengen",
  mef: "Megam",
  meh: "Southwestern Tlaxiaco Mixtec",
  mei: "Midob",
  mej: "Meyah",
  mek: "Mekeo",
  mel: "Central Melanau",
  mem: "Mangala",
  men: "Mende (Sierra Leone)",
  meo: "Kedah Malay",
  mep: "Miriwung",
  meq: "Merey",
  mer: "Meru",
  mes: "Masmaje",
  met: "Mato",
  meu: "Motu",
  mev: "Mano",
  mew: "Maaka",
  mey: "Hassaniyya",
  mez: "Menominee",
  mfa: "Pattani Malay",
  mfb: "Bangka",
  mfc: "Mba",
  mfd: "Mendankwe-Nkwen",
  mfe: "Morisyen",
  mff: "Naki",
  mfg: "Mogofin",
  mfh: "Matal",
  mfi: "Wandala",
  mfj: "Mefele",
  mfk: "North Mofu",
  mfl: "Putai",
  mfm: "Marghi South",
  mfn: "Cross River Mbembe",
  mfo: "Mbe",
  mfp: "Makassar Malay",
  mfq: "Moba",
  mfr: "Marithiel",
  mfs: "Mexican Sign Language",
  mft: "Mokerang",
  mfu: "Mbwela",
  mfv: "Mandjak",
  mfw: "Mulaha",
  mfx: "Melo",
  mfy: "Mayo",
  mfz: "Mabaan",
  mga: "Middle Irish (900-1200)",
  mgb: "Mararit",
  mgc: "Morokodo",
  mgd: "Moru",
  mge: "Mango",
  mgf: "Maklew",
  mgg: "Mpumpong",
  mgh: "Makhuwa-Meetto",
  mgi: "Lijili",
  mgj: "Abureni",
  mgk: "Mawes",
  mgl: "Maleu-Kilenge",
  mgm: "Mambae",
  mgn: "Mbangi",
  mgo: "Meta'",
  mgp: "Eastern Magar",
  mgq: "Malila",
  mgr: "Mambwe-Lungu",
  mgs: "Manda (Tanzania)",
  mgt: "Mongol",
  mgu: "Mailu",
  mgv: "Matengo",
  mgw: "Matumbi",
  mgy: "Mbunga",
  mgz: "Mbugwe",
  mha: "Manda (India)",
  mhb: "Mahongwe",
  mhc: "Mocho",
  mhd: "Mbugu",
  mhe: "Besisi",
  mhf: "Mamaa",
  mhg: "Margu",
  mhi: "Ma'di",
  mhj: "Mogholi",
  mhk: "Mungaka",
  mhl: "Mauwake",
  mhm: "Makhuwa-Moniga",
  mhn: "Mcheno",
  mho: "Mashi (Zambia)",
  mhp: "Balinese Malay",
  mhq: "Mandan",
  mhr: "Eastern Mari",
  mhs: "Buru (Indonesia)",
  mht: "Mandahuaca",
  mhu: "Digaro-Mishmi",
  mhw: "Mbukushu",
  mhx: "Maru",
  mhy: "Ma'anyan",
  mhz: "Mor (Mor Islands)",
  mia: "Miami",
  mib: "Atatlhuca Mixtec",
  mic: "Mi'kmaq",
  mid: "Mandaic",
  mie: "Ocotepec Mixtec",
  mif: "Mofu-Gudur",
  mig: "San Miguel El Grande Mixtec",
  mih: "Chayuco Mixtec",
  mii: "Chigmecatitln Mixtec",
  mij: "Abar",
  mik: "Mikasuki",
  mil: "Peoles Mixtec",
  mim: "Alacatlatzala Mixtec",
  min: "Minangkabau",
  mio: "Pinotepa Nacional Mixtec",
  mip: "Apasco-Apoala Mixtec",
  miq: "Mskito",
  mir: "Isthmus Mixe",
  mis: "Uncoded languages",
  mit: "Southern Puebla Mixtec",
  miu: "Cacaloxtepec Mixtec",
  miw: "Akoye",
  mix: "Mixtepec Mixtec",
  miy: "Ayutla Mixtec",
  miz: "Coatzospan Mixtec",
  mjb: "Makalero",
  mjc: "San Juan Colorado Mixtec",
  mjd: "Northwest Maidu",
  mje: "Muskum",
  mjg: "Tu",
  mjh: "Mwera (Nyasa)",
  mji: "Kim Mun",
  mjj: "Mawak",
  mjk: "Matukar",
  mjl: "Mandeali",
  mjm: "Medebur",
  mjn: "Ma (Papua New Guinea)",
  mjo: "Malankuravan",
  mjp: "Malapandaram",
  mjq: "Malaryan",
  mjr: "Malavedan",
  mjs: "Miship",
  mjt: "Sauria Paharia",
  mju: "Manna-Dora",
  mjv: "Mannan",
  mjw: "Karbi",
  mjx: "Mahali",
  mjy: "Mahican",
  mjz: "Majhi",
  mka: "Mbre",
  mkb: "Mal Paharia",
  mkc: "Siliput",
  mkd: "Macedonian",
  mke: "Mawchi",
  mkf: "Miya",
  mkg: "Mak (China)",
  mki: "Dhatki",
  mkj: "Mokilese",
  mkk: "Byep",
  mkl: "Mokole",
  mkm: "Moklen",
  mkn: "Kupang Malay",
  mko: "Mingang Doso",
  mkp: "Moikodi",
  mkq: "Bay Miwok",
  mkr: "Malas",
  mks: "Silacayoapan Mixtec",
  mkt: "Vamale",
  mku: "Konyanka Maninka",
  mkv: "Mafea",
  mkw: "Kituba (Congo)",
  mkx: "Kinamiging Manobo",
  mky: "East Makian",
  mkz: "Makasae",
  mla: "Malo",
  mlb: "Mbule",
  mlc: "Cao Lan",
  mle: "Manambu",
  mlf: "Mal",
  mlg: "Malagasy",
  mlh: "Mape",
  mli: "Malimpung",
  mlj: "Miltu",
  mlk: "Ilwana",
  mll: "Malua Bay",
  mlm: "Mulam",
  mln: "Malango",
  mlo: "Mlomp",
  mlp: "Bargam",
  mlq: "Western Maninkakan",
  mlr: "Vame",
  mls: "Masalit",
  mlt: "Maltese",
  mlu: "To'abaita",
  mlv: "Motlav",
  mlw: "Moloko",
  mlx: "Malfaxal",
  mlz: "Malaynon",
  mma: "Mama",
  mmb: "Momina",
  mmc: "Michoacn Mazahua",
  mmd: "Maonan",
  mme: "Mae",
  mmf: "Mundat",
  mmg: "North Ambrym",
  mmh: "Mehinku",
  mmi: "Musar",
  mmj: "Majhwar",
  mmk: "Mukha-Dora",
  mml: "Man Met",
  mmm: "Maii",
  mmn: "Mamanwa",
  mmo: "Mangga Buang",
  mmp: "Siawi",
  mmq: "Musak",
  mmr: "Western Xiangxi Miao",
  mmt: "Malalamai",
  mmu: "Mmaala",
  mmv: "Miriti",
  mmw: "Emae",
  mmx: "Madak",
  mmy: "Migaama",
  mmz: "Mabaale",
  mna: "Mbula",
  mnb: "Muna",
  mnc: "Manchu",
  mnd: "Mond",
  mne: "Naba",
  mnf: "Mundani",
  mng: "Eastern Mnong",
  mnh: "Mono (Democratic Republic of Congo)",
  mni: "Manipuri",
  mnj: "Munji",
  mnk: "Mandinka",
  mnl: "Tiale",
  mnm: "Mapena",
  mnn: "Southern Mnong",
  mnp: "Min Bei Chinese",
  mnq: "Minriq",
  mnr: "Mono (USA)",
  mns: "Mansi",
  mnu: "Mer",
  mnv: "Rennell-Bellona",
  mnw: "Mon",
  mnx: "Manikion",
  mny: "Manyawa",
  mnz: "Moni",
  moa: "Mwan",
  moc: "Mocov",
  mod: "Mobilian",
  moe: "Montagnais",
  mog: "Mongondow",
  moh: "Mohawk",
  moi: "Mboi",
  moj: "Monzombo",
  mok: "Morori",
  mom: "Mangue",
  mon: "Mongolian",
  moo: "Monom",
  mop: "Mopn Maya",
  moq: "Mor (Bomberai Peninsula)",
  mor: "Moro",
  mos: "Mossi",
  mot: "Bar",
  mou: "Mogum",
  mov: "Mohave",
  mow: "Moi (Congo)",
  mox: "Molima",
  moy: "Shekkacho",
  moz: "Mukulu",
  mpa: "Mpoto",
  mpb: "Mullukmulluk",
  mpc: "Mangarayi",
  mpd: "Machinere",
  mpe: "Majang",
  mpg: "Marba",
  mph: "Maung",
  mpi: "Mpade",
  mpj: "Martu Wangka",
  mpk: "Mbara (Chad)",
  mpl: "Middle Watut",
  mpm: "Yosonda Mixtec",
  mpn: "Mindiri",
  mpo: "Miu",
  mpp: "Migabac",
  mpq: "Mats",
  mpr: "Vangunu",
  mps: "Dadibi",
  mpt: "Mian",
  mpu: "Makurp",
  mpv: "Mungkip",
  mpw: "Mapidian",
  mpx: "Misima-Panaeati",
  mpy: "Mapia",
  mpz: "Mpi",
  mqa: "Maba (Indonesia)",
  mqb: "Mbuko",
  mqc: "Mangole",
  mqe: "Matepi",
  mqf: "Momuna",
  mqg: "Kota Bangun Kutai Malay",
  mqh: "Tlazoyaltepec Mixtec",
  mqi: "Mariri",
  mqj: "Mamasa",
  mqk: "Rajah Kabunsuwan Manobo",
  mql: "Mbelime",
  mqm: "South Marquesan",
  mqn: "Moronene",
  mqo: "Modole",
  mqp: "Manipa",
  mqq: "Minokok",
  mqr: "Mander",
  mqs: "West Makian",
  mqt: "Mok",
  mqu: "Mandari",
  mqv: "Mosimo",
  mqw: "Murupi",
  mqx: "Mamuju",
  mqy: "Manggarai",
  mqz: "Pano",
  mra: "Mlabri",
  mrb: "Marino",
  mrc: "Maricopa",
  mrd: "Western Magar",
  mre: "Martha's Vineyard Sign Language",
  mrf: "Elseng",
  mrg: "Mising",
  mrh: "Mara Chin",
  mri: "Maori",
  mrj: "Western Mari",
  mrk: "Hmwaveke",
  mrl: "Mortlockese",
  mrm: "Merlav",
  mrn: "Cheke Holo",
  mro: "Mru",
  mrp: "Morouas",
  mrq: "North Marquesan",
  mrr: "Maria (India)",
  mrs: "Maragus",
  mrt: "Marghi Central",
  mru: "Mono (Cameroon)",
  mrv: "Mangareva",
  mrw: "Maranao",
  mrx: "Maremgi",
  mry: "Mandaya",
  mrz: "Marind",
  msa: "Malay (macrolanguage)",
  msb: "Masbatenyo",
  msc: "Sankaran Maninka",
  msd: "Yucatec Maya Sign Language",
  mse: "Musey",
  msf: "Mekwei",
  msg: "Moraid",
  msh: "Masikoro Malagasy",
  msi: "Sabah Malay",
  msj: "Ma (Democratic Republic of Congo)",
  msk: "Mansaka",
  msl: "Molof",
  msm: "Agusan Manobo",
  msn: "Vurs",
  mso: "Mombum",
  msp: "Maritsau",
  msq: "Caac",
  msr: "Mongolian Sign Language",
  mss: "West Masela",
  msu: "Musom",
  msv: "Maslam",
  msw: "Mansoanka",
  msx: "Moresada",
  msy: "Aruamu",
  msz: "Momare",
  mta: "Cotabato Manobo",
  mtb: "Anyin Morofo",
  mtc: "Munit",
  mtd: "Mualang",
  mte: "Mono (Solomon Islands)",
  mtf: "Murik (Papua New Guinea)",
  mtg: "Una",
  mth: "Munggui",
  mti: "Maiwa (Papua New Guinea)",
  mtj: "Moskona",
  mtk: "Mbe'",
  mtl: "Montol",
  mtm: "Mator",
  mtn: "Matagalpa",
  mto: "Totontepec Mixe",
  mtp: "Wich Lhamts Nocten",
  mtq: "Muong",
  mtr: "Mewari",
  mts: "Yora",
  mtt: "Mota",
  mtu: "Tututepec Mixtec",
  mtv: "Asaro'o",
  mtw: "Southern Binukidnon",
  mtx: "Tida Mixtec",
  mty: "Nabi",
  mua: "Mundang",
  mub: "Mubi",
  muc: "Ajumbu",
  mud: "Mednyj Aleut",
  mue: "Media Lengua",
  mug: "Musgu",
  muh: "Mnd",
  mui: "Musi",
  muj: "Mabire",
  muk: "Mugom",
  mul: "Multiple languages",
  mum: "Maiwala",
  muo: "Nyong",
  mup: "Malvi",
  muq: "Eastern Xiangxi Miao",
  mur: "Murle",
  mus: "Creek",
  mut: "Western Muria",
  muu: "Yaaku",
  muv: "Muthuvan",
  mux: "Bo-Ung",
  muy: "Muyang",
  muz: "Mursi",
  mva: "Manam",
  mvb: "Mattole",
  mvd: "Mamboru",
  mve: "Marwari (Pakistan)",
  mvf: "Peripheral Mongolian",
  mvg: "Yucuae Mixtec",
  mvh: "Mulgi",
  mvi: "Miyako",
  mvk: "Mekmek",
  mvl: "Mbara (Australia)",
  mvm: "Muya",
  mvn: "Minaveha",
  mvo: "Marovo",
  mvp: "Duri",
  mvq: "Moere",
  mvr: "Marau",
  mvs: "Massep",
  mvt: "Mpotovoro",
  mvu: "Marfa",
  mvv: "Tagal Murut",
  mvw: "Machinga",
  mvx: "Meoswar",
  mvy: "Indus Kohistani",
  mvz: "Mesqan",
  mwa: "Mwatebu",
  mwb: "Juwal",
  mwc: "Are",
  mwe: "Mwera (Chimwera)",
  mwf: "Murrinh-Patha",
  mwg: "Aiklep",
  mwh: "Mouk-Aria",
  mwi: "Labo",
  mwk: "Kita Maninkakan",
  mwl: "Mirandese",
  mwm: "Sar",
  mwn: "Nyamwanga",
  mwo: "Central Maewo",
  mwp: "Kala Lagaw Ya",
  mwq: "Mn Chin",
  mwr: "Marwari",
  mws: "Mwimbi-Muthambi",
  mwt: "Moken",
  mwu: "Mittu",
  mwv: "Mentawai",
  mww: "Hmong Daw",
  mwx: "Mediak",
  mwy: "Mosiro",
  mwz: "Moingi",
  mxa: "Northwest Oaxaca Mixtec",
  mxb: "Tezoatln Mixtec",
  mxc: "Manyika",
  mxd: "Modang",
  mxe: "Mele-Fila",
  mxf: "Malgbe",
  mxg: "Mbangala",
  mxh: "Mvuba",
  mxi: "Mozarabic",
  mxj: "Miju-Mishmi",
  mxk: "Monumbo",
  mxl: "Maxi Gbe",
  mxm: "Meramera",
  mxn: "Moi (Indonesia)",
  mxo: "Mbowe",
  mxp: "Tlahuitoltepec Mixe",
  mxq: "Juquila Mixe",
  mxr: "Murik (Malaysia)",
  mxs: "Huitepec Mixtec",
  mxt: "Jamiltepec Mixtec",
  mxu: "Mada (Cameroon)",
  mxv: "Metlatnoc Mixtec",
  mxw: "Namo",
  mxx: "Mahou",
  mxy: "Southeastern Nochixtln Mixtec",
  mxz: "Central Masela",
  mya: "Burmese",
  myb: "Mbay",
  myc: "Mayeka",
  myd: "Maramba",
  mye: "Myene",
  myf: "Bambassi",
  myg: "Manta",
  myh: "Makah",
  myi: "Mina (India)",
  myj: "Mangayat",
  myk: "Mamara Senoufo",
  myl: "Moma",
  mym: "Me'en",
  myo: "Anfillo",
  myp: "Pirah",
  myr: "Muniche",
  mys: "Mesmes",
  myu: "Munduruk",
  myv: "Erzya",
  myw: "Muyuw",
  myx: "Masaaba",
  myy: "Macuna",
  myz: "Classical Mandaic",
  mza: "Santa Mara Zacatepec Mixtec",
  mzb: "Tumzabt",
  mzc: "Madagascar Sign Language",
  mzd: "Malimba",
  mze: "Morawa",
  mzg: "Monastic Sign Language",
  mzh: "Wich Lhamts Gisnay",
  mzi: "Ixcatln Mazatec",
  mzj: "Manya",
  mzk: "Nigeria Mambila",
  mzl: "Mazatln Mixe",
  mzm: "Mumuye",
  mzn: "Mazanderani",
  mzo: "Matipuhy",
  mzp: "Movima",
  mzq: "Mori Atas",
  mzr: "Marbo",
  mzs: "Macanese",
  mzt: "Mintil",
  mzu: "Inapang",
  mzv: "Manza",
  mzw: "Deg",
  mzx: "Mawayana",
  mzy: "Mozambican Sign Language",
  mzz: "Maiadomu",
  naa: "Namla",
  nab: "Southern Nambikura",
  nac: "Narak",
  nae: "Naka'ela",
  naf: "Nabak",
  nag: "Naga Pidgin",
  naj: "Nalu",
  nak: "Nakanai",
  nal: "Nalik",
  nam: "Ngan'gityemerri",
  nan: "Min Nan Chinese",
  nao: "Naaba",
  nap: "Neapolitan",
  naq: "Khoekhoe",
  nar: "Iguta",
  nas: "Naasioi",
  nat: "Cahungwarya",
  nau: "Nauru",
  nav: "Navajo",
  naw: "Nawuri",
  nax: "Nakwi",
  nay: "Narrinyeri",
  naz: "Coatepec Nahuatl",
  nba: "Nyemba",
  nbb: "Ndoe",
  nbc: "Chang Naga",
  nbd: "Ngbinda",
  nbe: "Konyak Naga",
  nbg: "Nagarchal",
  nbh: "Ngamo",
  nbi: "Mao Naga",
  nbj: "Ngarinman",
  nbk: "Nake",
  nbl: "South Ndebele",
  nbm: "Ngbaka Ma'bo",
  nbn: "Kuri",
  nbo: "Nkukoli",
  nbp: "Nnam",
  nbq: "Nggem",
  nbr: "Numana-Nunku-Gbantu-Numbu",
  nbs: "Namibian Sign Language",
  nbt: "Na",
  nbu: "Rongmei Naga",
  nbv: "Ngamambo",
  nbw: "Southern Ngbandi",
  nby: "Ningera",
  nca: "Iyo",
  ncb: "Central Nicobarese",
  ncc: "Ponam",
  ncd: "Nachering",
  nce: "Yale",
  ncf: "Notsi",
  ncg: "Nisga'a",
  nch: "Central Huasteca Nahuatl",
  nci: "Classical Nahuatl",
  ncj: "Northern Puebla Nahuatl",
  nck: "Nakara",
  ncl: "Michoacn Nahuatl",
  ncm: "Nambo",
  ncn: "Nauna",
  nco: "Sibe",
  ncp: "Ndaktup",
  ncq: "Northern Katang",
  ncr: "Ncane",
  ncs: "Nicaraguan Sign Language",
  nct: "Chothe Naga",
  ncu: "Chumburung",
  ncx: "Central Puebla Nahuatl",
  ncz: "Natchez",
  nda: "Ndasa",
  ndb: "Kenswei Nsei",
  ndc: "Ndau",
  ndd: "Nde-Nsele-Nta",
  nde: "North Ndebele",
  ndf: "Nadruvian",
  ndg: "Ndengereko",
  ndh: "Ndali",
  ndi: "Samba Leko",
  ndj: "Ndamba",
  ndk: "Ndaka",
  ndl: "Ndolo",
  ndm: "Ndam",
  ndn: "Ngundi",
  ndo: "Ndonga",
  ndp: "Ndo",
  ndq: "Ndombe",
  ndr: "Ndoola",
  nds: "Low German",
  ndt: "Ndunga",
  ndu: "Dugun",
  ndv: "Ndut",
  ndw: "Ndobo",
  ndx: "Nduga",
  ndy: "Lutos",
  ndz: "Ndogo",
  nea: "Eastern Ngad'a",
  neb: "Toura (Cte d'Ivoire)",
  nec: "Nedebang",
  ned: "Nde-Gbite",
  nee: "Nlmwa-Nixumwak",
  nef: "Nefamese",
  neg: "Negidal",
  neh: "Nyenkha",
  nei: "Neo-Hittite",
  nej: "Neko",
  nek: "Neku",
  nem: "Nemi",
  nen: "Nengone",
  neo: "N-Meo",
  nep: "Nepali (macrolanguage)",
  neq: "North Central Mixe",
  ner: "Yahadian",
  nes: "Bhoti Kinnauri",
  net: "Nete",
  neu: "Neo",
  nev: "Nyaheun",
  new: "Newari",
  nex: "Neme",
  ney: "Neyo",
  nez: "Nez Perce",
  nfa: "Dhao",
  nfd: "Ahwai",
  nfl: "Ayiwo",
  nfr: "Nafaanra",
  nfu: "Mfumte",
  nga: "Ngbaka",
  ngb: "Northern Ngbandi",
  ngc: "Ngombe (Democratic Republic of Congo)",
  ngd: "Ngando (Central African Republic)",
  nge: "Ngemba",
  ngg: "Ngbaka Manza",
  ngh: "N/u",
  ngi: "Ngizim",
  ngj: "Ngie",
  ngk: "Dalabon",
  ngl: "Lomwe",
  ngm: "Ngatik Men's Creole",
  ngn: "Ngwo",
  ngo: "Ngoni",
  ngp: "Ngulu",
  ngq: "Ngurimi",
  ngr: "Engdewu",
  ngs: "Gvoko",
  ngt: "Kriang",
  ngu: "Guerrero Nahuatl",
  ngv: "Nagumi",
  ngw: "Ngwaba",
  ngx: "Nggwahyi",
  ngy: "Tibea",
  ngz: "Ngungwel",
  nha: "Nhanda",
  nhb: "Beng",
  nhc: "Tabasco Nahuatl",
  nhd: "Chirip",
  nhe: "Eastern Huasteca Nahuatl",
  nhf: "Nhuwala",
  nhg: "Tetelcingo Nahuatl",
  nhh: "Nahari",
  nhi: "Zacatln-Ahuacatln-Tepetzintla Nahuatl",
  nhk: "Isthmus-Cosoleacaque Nahuatl",
  nhm: "Morelos Nahuatl",
  nhn: "Central Nahuatl",
  nho: "Takuu",
  nhp: "Isthmus-Pajapan Nahuatl",
  nhq: "Huaxcaleca Nahuatl",
  nhr: "Naro",
  nht: "Ometepec Nahuatl",
  nhu: "Noone",
  nhv: "Temascaltepec Nahuatl",
  nhw: "Western Huasteca Nahuatl",
  nhx: "Isthmus-Mecayapan Nahuatl",
  nhy: "Northern Oaxaca Nahuatl",
  nhz: "Santa Mara La Alta Nahuatl",
  nia: "Nias",
  nib: "Nakame",
  nid: "Ngandi",
  nie: "Niellim",
  nif: "Nek",
  nig: "Ngalakan",
  nih: "Nyiha (Tanzania)",
  nii: "Nii",
  nij: "Ngaju",
  nik: "Southern Nicobarese",
  nil: "Nila",
  nim: "Nilamba",
  nin: "Ninzo",
  nio: "Nganasan",
  niq: "Nandi",
  nir: "Nimboran",
  nis: "Nimi",
  nit: "Southeastern Kolami",
  niu: "Niuean",
  niv: "Gilyak",
  niw: "Nimo",
  nix: "Hema",
  niy: "Ngiti",
  niz: "Ningil",
  nja: "Nzanyi",
  njb: "Nocte Naga",
  njd: "Ndonde Hamba",
  njh: "Lotha Naga",
  nji: "Gudanji",
  njj: "Njen",
  njl: "Njalgulgule",
  njm: "Angami Naga",
  njn: "Liangmai Naga",
  njo: "Ao Naga",
  njr: "Njerep",
  njs: "Nisa",
  njt: "Ndyuka-Trio Pidgin",
  nju: "Ngadjunmaya",
  njx: "Kunyi",
  njy: "Njyem",
  njz: "Nyishi",
  nka: "Nkoya",
  nkb: "Khoibu Naga",
  nkc: "Nkongho",
  nkd: "Koireng",
  nke: "Duke",
  nkf: "Inpui Naga",
  nkg: "Nekgini",
  nkh: "Khezha Naga",
  nki: "Thangal Naga",
  nkj: "Nakai",
  nkk: "Nokuku",
  nkm: "Namat",
  nkn: "Nkangala",
  nko: "Nkonya",
  nkp: "Niuatoputapu",
  nkq: "Nkami",
  nkr: "Nukuoro",
  nks: "North Asmat",
  nkt: "Nyika (Tanzania)",
  nku: "Bouna Kulango",
  nkv: "Nyika (Malawi and Zambia)",
  nkw: "Nkutu",
  nkx: "Nkoroo",
  nkz: "Nkari",
  nla: "Ngombale",
  nlc: "Nalca",
  nld: "Dutch",
  nle: "East Nyala",
  nlg: "Gela",
  nli: "Grangali",
  nlj: "Nyali",
  nlk: "Ninia Yali",
  nll: "Nihali",
  nlo: "Ngul",
  nlq: "Lao Naga",
  nlu: "Nchumbulu",
  nlv: "Orizaba Nahuatl",
  nlw: "Walangama",
  nlx: "Nahali",
  nly: "Nyamal",
  nlz: "Nalgo",
  nma: "Maram Naga",
  nmb: "Big Nambas",
  nmc: "Ngam",
  nmd: "Ndumu",
  nme: "Mzieme Naga",
  nmf: "Tangkhul Naga (India)",
  nmg: "Kwasio",
  nmh: "Monsang Naga",
  nmi: "Nyam",
  nmj: "Ngombe (Central African Republic)",
  nmk: "Namakura",
  nml: "Ndemli",
  nmm: "Manangba",
  nmn: "!X",
  nmo: "Moyon Naga",
  nmp: "Nimanbur",
  nmq: "Nambya",
  nmr: "Nimbari",
  nms: "Letemboi",
  nmt: "Namonuito",
  nmu: "Northeast Maidu",
  nmv: "Ngamini",
  nmw: "Nimoa",
  nmx: "Nama (Papua New Guinea)",
  nmy: "Namuyi",
  nmz: "Nawdm",
  nna: "Nyangumarta",
  nnb: "Nande",
  nnc: "Nancere",
  nnd: "West Ambae",
  nne: "Ngandyera",
  nnf: "Ngaing",
  nng: "Maring Naga",
  nnh: "Ngiemboon",
  nni: "North Nuaulu",
  nnj: "Nyangatom",
  nnk: "Nankina",
  nnl: "Northern Rengma Naga",
  nnm: "Namia",
  nnn: "Ngete",
  nno: "Norwegian Nynorsk",
  nnp: "Wancho Naga",
  nnq: "Ngindo",
  nnr: "Narungga",
  nns: "Ningye",
  nnt: "Nanticoke",
  nnu: "Dwang",
  nnv: "Nugunu (Australia)",
  nnw: "Southern Nuni",
  nny: "Nyangga",
  nnz: "Nda'nda'",
  noa: "Woun Meu",
  nob: "Norwegian Bokml",
  noc: "Nuk",
  nod: "Northern Thai",
  noe: "Nimadi",
  nof: "Nomane",
  nog: "Nogai",
  noh: "Nomu",
  noi: "Noiri",
  noj: "Nonuya",
  nok: "Nooksack",
  nol: "Nomlaki",
  nom: "Nocamn",
  non: "Old Norse",
  nop: "Numanggang",
  noq: "Ngongo",
  nor: "Norwegian",
  nos: "Eastern Nisu",
  not: "Nomatsiguenga",
  nou: "Ewage-Notu",
  nov: "Novial",
  now: "Nyambo",
  noy: "Noy",
  noz: "Nayi",
  npa: "Nar Phu",
  npb: "Nupbikha",
  npg: "Ponyo-Gongwang Naga",
  nph: "Phom Naga",
  npi: "Nepali (individual language)",
  npl: "Southeastern Puebla Nahuatl",
  npn: "Mondropolon",
  npo: "Pochuri Naga",
  nps: "Nipsan",
  npu: "Puimei Naga",
  npx: "Noipx",
  npy: "Napu",
  nqg: "Southern Nago",
  nqk: "Kura Ede Nago",
  nql: "Ngendelengo",
  nqm: "Ndom",
  nqn: "Nen",
  nqo: "N'Ko",
  nqq: "Kyan-Karyaw Naga",
  nqy: "Akyaung Ari Naga",
  nra: "Ngom",
  nrb: "Nara",
  nrc: "Noric",
  nre: "Southern Rengma Naga",
  nrf: "Jrriais",
  nrg: "Narango",
  nri: "Chokri Naga",
  nrk: "Ngarla",
  nrl: "Ngarluma",
  nrm: "Narom",
  nrn: "Norn",
  nrp: "North Picene",
  nrr: "Norra",
  nrt: "Northern Kalapuya",
  nru: "Narua",
  nrx: "Ngurmbur",
  nrz: "Lala",
  nsa: "Sangtam Naga",
  nsc: "Nshi",
  nsd: "Southern Nisu",
  nse: "Nsenga",
  nsf: "Northwestern Nisu",
  nsg: "Ngasa",
  nsh: "Ngoshie",
  nsi: "Nigerian Sign Language",
  nsk: "Naskapi",
  nsl: "Norwegian Sign Language",
  nsm: "Sumi Naga",
  nsn: "Nehan",
  nso: "Pedi",
  nsp: "Nepalese Sign Language",
  nsq: "Northern Sierra Miwok",
  nsr: "Maritime Sign Language",
  nss: "Nali",
  nst: "Tase Naga",
  nsu: "Sierra Negra Nahuatl",
  nsv: "Southwestern Nisu",
  nsw: "Navut",
  nsx: "Nsongo",
  nsy: "Nasal",
  nsz: "Nisenan",
  ntd: "Northern Tidung",
  nte: "Nathembo",
  ntg: "Ngantangarra",
  nti: "Natioro",
  ntj: "Ngaanyatjarra",
  ntk: "Ikoma-Nata-Isenye",
  ntm: "Nateni",
  nto: "Ntomba",
  ntp: "Northern Tepehuan",
  ntr: "Delo",
  ntu: "Natgu",
  ntw: "Nottoway",
  ntx: "Tangkhul Naga (Myanmar)",
  nty: "Mantsi",
  ntz: "Natanzi",
  nua: "Yuanga",
  nuc: "Nukuini",
  nud: "Ngala",
  nue: "Ngundu",
  nuf: "Nusu",
  nug: "Nungali",
  nuh: "Ndunda",
  nui: "Ngumbi",
  nuj: "Nyole",
  nuk: "Nuu-chah-nulth",
  nul: "Nusa Laut",
  num: "Niuafo'ou",
  nun: "Anong",
  nuo: "Ngun",
  nup: "Nupe-Nupe-Tako",
  nuq: "Nukumanu",
  nur: "Nukuria",
  nus: "Nuer",
  nut: "Nung (Viet Nam)",
  nuu: "Ngbundu",
  nuv: "Northern Nuni",
  nuw: "Nguluwan",
  nux: "Mehek",
  nuy: "Nunggubuyu",
  nuz: "Tlamacazapa Nahuatl",
  nvh: "Nasarian",
  nvm: "Namiae",
  nvo: "Nyokon",
  nwa: "Nawathinehena",
  nwb: "Nyabwa",
  nwc: "Classical Newari",
  nwe: "Ngwe",
  nwg: "Ngayawung",
  nwi: "Southwest Tanna",
  nwm: "Nyamusa-Molo",
  nwo: "Nauo",
  nwr: "Nawaru",
  nwx: "Middle Newar",
  nwy: "Nottoway-Meherrin",
  nxa: "Nauete",
  nxd: "Ngando (Democratic Republic of Congo)",
  nxe: "Nage",
  nxg: "Ngad'a",
  nxi: "Nindi",
  nxk: "Koki Naga",
  nxl: "South Nuaulu",
  nxm: "Numidian",
  nxn: "Ngawun",
  nxo: "Ndambomo",
  nxq: "Naxi",
  nxr: "Ninggerum",
  nxu: "Narau",
  nxx: "Nafri",
  nya: "Nyanja",
  nyb: "Nyangbo",
  nyc: "Nyanga-li",
  nyd: "Nyore",
  nye: "Nyengo",
  nyf: "Giryama",
  nyg: "Nyindu",
  nyh: "Nyigina",
  nyi: "Ama (Sudan)",
  nyj: "Nyanga",
  nyk: "Nyaneka",
  nyl: "Nyeu",
  nym: "Nyamwezi",
  nyn: "Nyankole",
  nyo: "Nyoro",
  nyp: "Nyang'i",
  nyq: "Nayini",
  nyr: "Nyiha (Malawi)",
  nys: "Nyunga",
  nyt: "Nyawaygi",
  nyu: "Nyungwe",
  nyv: "Nyulnyul",
  nyw: "Nyaw",
  nyx: "Nganyaywana",
  nyy: "Nyakyusa-Ngonde",
  nza: "Tigon Mbembe",
  nzb: "Njebi",
  nzi: "Nzima",
  nzk: "Nzakara",
  nzm: "Zeme Naga",
  nzs: "New Zealand Sign Language",
  nzu: "Teke-Nzikou",
  nzy: "Nzakambay",
  nzz: "Nanga Dama Dogon",
  oaa: "Orok",
  oac: "Oroch",
  oar: "Old Aramaic (up to 700 BCE)",
  oav: "Old Avar",
  obi: "Obispeo",
  obk: "Southern Bontok",
  obl: "Oblo",
  obm: "Moabite",
  obo: "Obo Manobo",
  obr: "Old Burmese",
  obt: "Old Breton",
  obu: "Obulom",
  oca: "Ocaina",
  och: "Old Chinese",
  oci: "Occitan (post 1500)",
  oco: "Old Cornish",
  ocu: "Atzingo Matlatzinca",
  oda: "Odut",
  odk: "Od",
  odt: "Old Dutch",
  odu: "Odual",
  ofo: "Ofo",
  ofs: "Old Frisian",
  ofu: "Efutop",
  ogb: "Ogbia",
  ogc: "Ogbah",
  oge: "Old Georgian",
  ogg: "Ogbogolo",
  ogo: "Khana",
  ogu: "Ogbronuagum",
  oht: "Old Hittite",
  ohu: "Old Hungarian",
  oia: "Oirata",
  oin: "Inebu One",
  ojb: "Northwestern Ojibwa",
  ojc: "Central Ojibwa",
  ojg: "Eastern Ojibwa",
  oji: "Ojibwa",
  ojp: "Old Japanese",
  ojs: "Severn Ojibwa",
  ojv: "Ontong Java",
  ojw: "Western Ojibwa",
  oka: "Okanagan",
  okb: "Okobo",
  okd: "Okodia",
  oke: "Okpe (Southwestern Edo)",
  okg: "Koko Babangk",
  okh: "Koresh-e Rostam",
  oki: "Okiek",
  okj: "Oko-Juwoi",
  okk: "Kwamtim One",
  okl: "Old Kentish Sign Language",
  okm: "Middle Korean (10th-16th cent.)",
  okn: "Oki-No-Erabu",
  oko: "Old Korean (3rd-9th cent.)",
  okr: "Kirike",
  oks: "Oko-Eni-Osayen",
  oku: "Oku",
  okv: "Orokaiva",
  okx: "Okpe (Northwestern Edo)",
  ola: "Walungge",
  old: "Mochi",
  ole: "Olekha",
  olk: "Olkol",
  olm: "Oloma",
  olo: "Livvi",
  olr: "Olrat",
  olt: "Old Lithuanian",
  olu: "Kuvale",
  oma: "Omaha-Ponca",
  omb: "East Ambae",
  omc: "Mochica",
  omg: "Omagua",
  omi: "Omi",
  omk: "Omok",
  oml: "Ombo",
  omn: "Minoan",
  omo: "Utarmbung",
  omp: "Old Manipuri",
  omr: "Old Marathi",
  omt: "Omotik",
  omu: "Omurano",
  omw: "South Tairora",
  omx: "Old Mon",
  ona: "Ona",
  onb: "Lingao",
  one: "Oneida",
  ong: "Olo",
  oni: "Onin",
  onj: "Onjob",
  onk: "Kabore One",
  onn: "Onobasulu",
  ono: "Onondaga",
  onp: "Sartang",
  onr: "Northern One",
  ons: "Ono",
  ont: "Ontenu",
  onu: "Unua",
  onw: "Old Nubian",
  onx: "Onin Based Pidgin",
  ood: "Tohono O'odham",
  oog: "Ong",
  oon: "nge",
  oor: "Oorlams",
  oos: "Old Ossetic",
  opa: "Okpamheri",
  opk: "Kopkaka",
  opm: "Oksapmin",
  opo: "Opao",
  opt: "Opata",
  opy: "Ofay",
  ora: "Oroha",
  orc: "Orma",
  ore: "Orejn",
  org: "Oring",
  orh: "Oroqen",
  ori: "Oriya (macrolanguage)",
  orm: "Oromo",
  orn: "Orang Kanaq",
  oro: "Orokolo",
  orr: "Oruma",
  ors: "Orang Seletar",
  ort: "Adivasi Oriya",
  oru: "Ormuri",
  orv: "Old Russian",
  orw: "Oro Win",
  orx: "Oro",
  ory: "Odia",
  orz: "Ormu",
  osa: "Osage",
  osc: "Oscan",
  osi: "Osing",
  oso: "Ososo",
  osp: "Old Spanish",
  oss: "Ossetian",
  ost: "Osatu",
  osu: "Southern One",
  osx: "Old Saxon",
  ota: "Ottoman Turkish (1500-1928)",
  otb: "Old Tibetan",
  otd: "Ot Danum",
  ote: "Mezquital Otomi",
  oti: "Oti",
  otk: "Old Turkish",
  otl: "Tilapa Otomi",
  otm: "Eastern Highland Otomi",
  otn: "Tenango Otomi",
  otq: "Quertaro Otomi",
  otr: "Otoro",
  ots: "Estado de Mxico Otomi",
  ott: "Temoaya Otomi",
  otu: "Otuke",
  otw: "Ottawa",
  otx: "Texcatepec Otomi",
  oty: "Old Tamil",
  otz: "Ixtenco Otomi",
  oua: "Tagargrent",
  oub: "Glio-Oubi",
  oue: "Oune",
  oui: "Old Uighur",
  oum: "Ouma",
  ovd: "Elfdalian",
  owi: "Owiniga",
  owl: "Old Welsh",
  oyb: "Oy",
  oyd: "Oyda",
  oym: "Wayampi",
  oyy: "Oya'oya",
  ozm: "Koonzime",
  pab: "Parecs",
  pac: "Pacoh",
  pad: "Paumar",
  pae: "Pagibete",
  paf: "Paranawt",
  pag: "Pangasinan",
  pah: "Tenharim",
  pai: "Pe",
  pak: "Parakan",
  pal: "Pahlavi",
  pam: "Pampanga",
  pan: "Panjabi",
  pao: "Northern Paiute",
  pap: "Papiamento",
  paq: "Parya",
  par: "Panamint",
  pas: "Papasena",
  pat: "Papitalai",
  pau: "Palauan",
  pav: "Pakasnovos",
  paw: "Pawnee",
  pax: "Pankarar",
  pay: "Pech",
  paz: "Pankarar",
  pbb: "Pez",
  pbc: "Patamona",
  pbe: "Mezontla Popoloca",
  pbf: "Coyotepec Popoloca",
  pbg: "Paraujano",
  pbh: "E'apa Woromaipu",
  pbi: "Parkwa",
  pbl: "Mak (Nigeria)",
  pbn: "Kpasam",
  pbo: "Papel",
  pbp: "Badyara",
  pbr: "Pangwa",
  pbs: "Central Pame",
  pbt: "Southern Pashto",
  pbu: "Northern Pashto",
  pbv: "Pnar",
  pby: "Pyu (Papua New Guinea)",
  pca: "Santa Ins Ahuatempan Popoloca",
  pcb: "Pear",
  pcc: "Bouyei",
  pcd: "Picard",
  pce: "Ruching Palaung",
  pcf: "Paliyan",
  pcg: "Paniya",
  pch: "Pardhan",
  pci: "Duruwa",
  pcj: "Parenga",
  pck: "Paite Chin",
  pcl: "Pardhi",
  pcm: "Nigerian Pidgin",
  pcn: "Piti",
  pcp: "Pacahuara",
  pcw: "Pyapun",
  pda: "Anam",
  pdc: "Pennsylvania German",
  pdi: "Pa Di",
  pdn: "Podena",
  pdo: "Padoe",
  pdt: "Plautdietsch",
  pdu: "Kayan",
  pea: "Peranakan Indonesian",
  peb: "Eastern Pomo",
  ped: "Mala (Papua New Guinea)",
  pee: "Taje",
  pef: "Northeastern Pomo",
  peg: "Pengo",
  peh: "Bonan",
  pei: "Chichimeca-Jonaz",
  pej: "Northern Pomo",
  pek: "Penchal",
  pel: "Pekal",
  pem: "Phende",
  peo: "Old Persian (ca. 600-400 B.C.)",
  pep: "Kunja",
  peq: "Southern Pomo",
  pes: "Iranian Persian",
  pev: "Pmono",
  pex: "Petats",
  pey: "Petjo",
  pez: "Eastern Penan",
  pfa: "Pfang",
  pfe: "Peere",
  pfl: "Pfaelzisch",
  pga: "Sudanese Creole Arabic",
  pgd: "Gndhr",
  pgg: "Pangwali",
  pgi: "Pagi",
  pgk: "Rerep",
  pgl: "Primitive Irish",
  pgn: "Paelignian",
  pgs: "Pangseng",
  pgu: "Pagu",
  pgz: "Papua New Guinean Sign Language",
  pha: "Pa-Hng",
  phd: "Phudagi",
  phg: "Phuong",
  phh: "Phukha",
  phk: "Phake",
  phl: "Phalura",
  phm: "Phimbi",
  phn: "Phoenician",
  pho: "Phunoi",
  phq: "Phana'",
  phr: "Pahari-Potwari",
  pht: "Phu Thai",
  phu: "Phuan",
  phv: "Pahlavani",
  phw: "Phangduwali",
  pia: "Pima Bajo",
  pib: "Yine",
  pic: "Pinji",
  pid: "Piaroa",
  pie: "Piro",
  pif: "Pingelapese",
  pig: "Pisabo",
  pih: "Pitcairn-Norfolk",
  pii: "Pini",
  pij: "Pijao",
  pil: "Yom",
  pim: "Powhatan",
  pin: "Piame",
  pio: "Piapoco",
  pip: "Pero",
  pir: "Piratapuyo",
  pis: "Pijin",
  pit: "Pitta Pitta",
  piu: "Pintupi-Luritja",
  piv: "Pileni",
  piw: "Pimbwe",
  pix: "Piu",
  piy: "Piya-Kwonci",
  piz: "Pije",
  pjt: "Pitjantjatjara",
  pka: "Ardhamgadh Prkrit",
  pkb: "Pokomo",
  pkc: "Paekche",
  pkg: "Pak-Tong",
  pkh: "Pankhu",
  pkn: "Pakanha",
  pko: "Pkoot",
  pkp: "Pukapuka",
  pkr: "Attapady Kurumba",
  pks: "Pakistan Sign Language",
  pkt: "Maleng",
  pku: "Paku",
  pla: "Miani",
  plb: "Polonombauk",
  plc: "Central Palawano",
  pld: "Polari",
  ple: "Palu'e",
  plg: "Pilag",
  plh: "Paulohi",
  pli: "Pali",
  plj: "Polci",
  plk: "Kohistani Shina",
  pll: "Shwe Palaung",
  pln: "Palenquero",
  plo: "Oluta Popoluca",
  plp: "Palpa",
  plq: "Palaic",
  plr: "Palaka Senoufo",
  pls: "San Marcos Tlacoyalco Popoloca",
  plt: "Plateau Malagasy",
  plu: "Palikr",
  plv: "Southwest Palawano",
  plw: "Brooke's Point Palawano",
  ply: "Bolyu",
  plz: "Paluan",
  pma: "Paama",
  pmb: "Pambia",
  pmd: "Pallanganmiddang",
  pme: "Pwaamei",
  pmf: "Pamona",
  pmh: "Mhrri Prkrit",
  pmi: "Northern Pumi",
  pmj: "Southern Pumi",
  pmk: "Pamlico",
  pml: "Lingua Franca",
  pmm: "Pomo",
  pmn: "Pam",
  pmo: "Pom",
  pmq: "Northern Pame",
  pmr: "Paynamar",
  pms: "Piemontese",
  pmt: "Tuamotuan",
  pmw: "Plains Miwok",
  pmx: "Poumei Naga",
  pmy: "Papuan Malay",
  pmz: "Southern Pame",
  pna: "Punan Bah-Biau",
  pnb: "Western Panjabi",
  pnc: "Pannei",
  pne: "Western Penan",
  png: "Pongu",
  pnh: "Penrhyn",
  pni: "Aoheng",
  pnj: "Pinjarup",
  pnk: "Paunaka",
  pnl: "Paleni",
  pnm: "Punan Batu 1",
  pnn: "Pinai-Hagahai",
  pno: "Panobo",
  pnp: "Pancana",
  pnq: "Pana (Burkina Faso)",
  pnr: "Panim",
  pns: "Ponosakan",
  pnt: "Pontic",
  pnu: "Jiongnai Bunu",
  pnv: "Pinigura",
  pnw: "Panytyima",
  pnx: "Phong-Kniang",
  pny: "Pinyin",
  pnz: "Pana (Central African Republic)",
  poc: "Poqomam",
  poe: "San Juan Atzingo Popoloca",
  pof: "Poke",
  pog: "Potigura",
  poh: "Poqomchi'",
  poi: "Highland Popoluca",
  pok: "Pokang",
  pol: "Polish",
  pom: "Southeastern Pomo",
  pon: "Pohnpeian",
  poo: "Central Pomo",
  pop: "Pwapw",
  poq: "Texistepec Popoluca",
  por: "Portuguese",
  pos: "Sayula Popoluca",
  pot: "Potawatomi",
  pov: "Upper Guinea Crioulo",
  pow: "San Felipe Otlaltepec Popoloca",
  pox: "Polabian",
  poy: "Pogolo",
  ppe: "Papi",
  ppi: "Paipai",
  ppk: "Uma",
  ppl: "Pipil",
  ppm: "Papuma",
  ppn: "Papapana",
  ppo: "Folopa",
  ppp: "Pelende",
  ppq: "Pei",
  pps: "San Lus Temalacayuca Popoloca",
  ppt: "Pare",
  ppu: "Papora",
  pqa: "Pa'a",
  pqm: "Malecite-Passamaquoddy",
  prc: "Parachi",
  prd: "Parsi-Dari",
  pre: "Principense",
  prf: "Paranan",
  prg: "Prussian",
  prh: "Porohanon",
  pri: "Paic",
  prk: "Parauk",
  prl: "Peruvian Sign Language",
  prm: "Kibiri",
  prn: "Prasuni",
  pro: "Old Provenal (to 1500)",
  prp: "Parsi",
  prq: "Ashninka Peren",
  prr: "Puri",
  prs: "Dari",
  prt: "Phai",
  pru: "Puragi",
  prw: "Parawen",
  prx: "Purik",
  prz: "Providencia Sign Language",
  psa: "Asue Awyu",
  psc: "Persian Sign Language",
  psd: "Plains Indian Sign Language",
  pse: "Central Malay",
  psg: "Penang Sign Language",
  psh: "Southwest Pashai",
  psi: "Southeast Pashai",
  psl: "Puerto Rican Sign Language",
  psm: "Pauserna",
  psn: "Panasuan",
  pso: "Polish Sign Language",
  psp: "Philippine Sign Language",
  psq: "Pasi",
  psr: "Portuguese Sign Language",
  pss: "Kaulong",
  pst: "Central Pashto",
  psu: "Sauraseni Prkrit",
  psw: "Port Sandwich",
  psy: "Piscataway",
  pta: "Pai Tavytera",
  pth: "Patax H-Ha-He",
  pti: "Pintiini",
  ptn: "Patani",
  pto: "Zo'",
  ptp: "Patep",
  ptq: "Pattapu",
  ptr: "Piamatsina",
  ptt: "Enrekang",
  ptu: "Bambam",
  ptv: "Port Vato",
  ptw: "Pentlatch",
  pty: "Pathiya",
  pua: "Western Highland Purepecha",
  pub: "Purum",
  puc: "Punan Merap",
  pud: "Punan Aput",
  pue: "Puelche",
  puf: "Punan Merah",
  pug: "Phuie",
  pui: "Puinave",
  puj: "Punan Tubu",
  pum: "Puma",
  puo: "Puoc",
  pup: "Pulabu",
  puq: "Puquina",
  pur: "Purubor",
  pus: "Pushto",
  put: "Putoh",
  puu: "Punu",
  puw: "Puluwatese",
  pux: "Puare",
  puy: "Purisimeo",
  pwa: "Pawaia",
  pwb: "Panawa",
  pwg: "Gapapaiwa",
  pwi: "Patwin",
  pwm: "Molbog",
  pwn: "Paiwan",
  pwo: "Pwo Western Karen",
  pwr: "Powari",
  pww: "Pwo Northern Karen",
  pxm: "Quetzaltepec Mixe",
  pye: "Pye Krumen",
  pym: "Fyam",
  pyn: "Poyanwa",
  pys: "Paraguayan Sign Language",
  pyu: "Puyuma",
  pyx: "Pyu (Myanmar)",
  pyy: "Pyen",
  pzn: "Para Naga",
  qaa: "Original audio",
  qad: "Audio Description",
  qua: "Quapaw",
  qub: "Huallaga Hunuco Quechua",
  quc: "K'iche'",
  qud: "Caldern Highland Quichua",
  que: "Quechua",
  quf: "Lambayeque Quechua",
  qug: "Chimborazo Highland Quichua",
  quh: "South Bolivian Quechua",
  qui: "Quileute",
  quk: "Chachapoyas Quechua",
  qul: "North Bolivian Quechua",
  qum: "Sipacapense",
  qun: "Quinault",
  qup: "Southern Pastaza Quechua",
  quq: "Quinqui",
  qur: "Yanahuanca Pasco Quechua",
  qus: "Santiago del Estero Quichua",
  quv: "Sacapulteco",
  quw: "Tena Lowland Quichua",
  qux: "Yauyos Quechua",
  quy: "Ayacucho Quechua",
  quz: "Cusco Quechua",
  qva: "Ambo-Pasco Quechua",
  qvc: "Cajamarca Quechua",
  qve: "Eastern Apurmac Quechua",
  qvh: "Huamales-Dos de Mayo Hunuco Quechua",
  qvi: "Imbabura Highland Quichua",
  qvj: "Loja Highland Quichua",
  qvl: "Cajatambo North Lima Quechua",
  qvm: "Margos-Yarowilca-Lauricocha Quechua",
  qvn: "North Junn Quechua",
  qvo: "Napo Lowland Quechua",
  qvp: "Pacaraos Quechua",
  qvs: "San Martn Quechua",
  qvw: "Huaylla Wanca Quechua",
  qvy: "Queyu",
  qvz: "Northern Pastaza Quichua",
  qwa: "Corongo Ancash Quechua",
  qwc: "Classical Quechua",
  qwh: "Huaylas Ancash Quechua",
  qwm: "Kuman (Russia)",
  qws: "Sihuas Ancash Quechua",
  qwt: "Kwalhioqua-Tlatskanai",
  qxa: "Chiquin Ancash Quechua",
  qxc: "Chincha Quechua",
  qxh: "Panao Hunuco Quechua",
  qxl: "Salasaca Highland Quichua",
  qxn: "Northern Conchucos Ancash Quechua",
  qxo: "Southern Conchucos Ancash Quechua",
  qxp: "Puno Quechua",
  qxq: "Qashqa'i",
  qxr: "Caar Highland Quichua",
  qxs: "Southern Qiang",
  qxt: "Santa Ana de Tusi Pasco Quechua",
  qxu: "Arequipa-La Unin Quechua",
  qxw: "Jauja Wanca Quechua",
  qya: "Quenya",
  qyp: "Quiripi",
  raa: "Dungmali",
  rab: "Camling",
  rac: "Rasawa",
  rad: "Rade",
  raf: "Western Meohang",
  rag: "Logooli",
  rah: "Rabha",
  rai: "Ramoaaina",
  raj: "Rajasthani",
  rak: "Tulu-Bohuai",
  ral: "Ralte",
  ram: "Canela",
  ran: "Riantana",
  rao: "Rao",
  rap: "Rapanui",
  raq: "Saam",
  rar: "Rarotongan",
  ras: "Tegali",
  rat: "Razajerdi",
  rau: "Raute",
  rav: "Sampang",
  raw: "Rawang",
  rax: "Rang",
  ray: "Rapa",
  raz: "Rahambuu",
  rbb: "Rumai Palaung",
  rbk: "Northern Bontok",
  rbl: "Miraya Bikol",
  rbp: "Barababaraba",
  rcf: "Runion Creole French",
  rdb: "Rudbari",
  rea: "Rerau",
  reb: "Rembong",
  ree: "Rejang Kayan",
  reg: "Kara (Tanzania)",
  rei: "Reli",
  rej: "Rejang",
  rel: "Rendille",
  rem: "Remo",
  ren: "Rengao",
  rer: "Rer Bare",
  res: "Reshe",
  ret: "Retta",
  rey: "Reyesano",
  rga: "Roria",
  rge: "Romano-Greek",
  rgk: "Rangkas",
  rgn: "Romagnol",
  rgr: "Resgaro",
  rgs: "Southern Roglai",
  rgu: "Ringgou",
  rhg: "Rohingya",
  rhp: "Yahang",
  ria: "Riang (India)",
  rif: "Tarifit",
  ril: "Riang (Myanmar)",
  rim: "Nyaturu",
  rin: "Nungu",
  rir: "Ribun",
  rit: "Ritarungo",
  riu: "Riung",
  rjg: "Rajong",
  rji: "Raji",
  rjs: "Rajbanshi",
  rka: "Kraol",
  rkb: "Rikbaktsa",
  rkh: "Rakahanga-Manihiki",
  rki: "Rakhine",
  rkm: "Marka",
  rkt: "Rangpuri",
  rkw: "Arakwal",
  rma: "Rama",
  rmb: "Rembarunga",
  rmc: "Carpathian Romani",
  rmd: "Traveller Danish",
  rme: "Angloromani",
  rmf: "Kalo Finnish Romani",
  rmg: "Traveller Norwegian",
  rmh: "Murkim",
  rmi: "Lomavren",
  rmk: "Romkun",
  rml: "Baltic Romani",
  rmm: "Roma",
  rmn: "Balkan Romani",
  rmo: "Sinte Romani",
  rmp: "Rempi",
  rmq: "Cal",
  rms: "Romanian Sign Language",
  rmt: "Domari",
  rmu: "Tavringer Romani",
  rmv: "Romanova",
  rmw: "Welsh Romani",
  rmx: "Romam",
  rmy: "Vlax Romani",
  rmz: "Marma",
  rnd: "Ruund",
  rng: "Ronga",
  rnl: "Ranglong",
  rnn: "Roon",
  rnp: "Rongpo",
  rnr: "Nari Nari",
  rnw: "Rungwa",
  rob: "Tae'",
  roc: "Cacgia Roglai",
  rod: "Rogo",
  roe: "Ronji",
  rof: "Rombo",
  rog: "Northern Roglai",
  roh: "Romansh",
  rol: "Romblomanon",
  rom: "Romany",
  ron: "Romanian",
  roo: "Rotokas",
  rop: "Kriol",
  ror: "Rongga",
  rou: "Runga",
  row: "Dela-Oenale",
  rpn: "Repanbitip",
  rpt: "Rapting",
  rri: "Ririo",
  rro: "Waima",
  rrt: "Arritinngithigh",
  rsb: "Romano-Serbian",
  rsl: "Russian Sign Language",
  rsm: "Miriwoong Sign Language",
  rtc: "Rungtu Chin",
  rth: "Ratahan",
  rtm: "Rotuman",
  rts: "Yurats",
  rtw: "Rathawi",
  rub: "Gungu",
  ruc: "Ruuli",
  rue: "Rusyn",
  ruf: "Luguru",
  rug: "Roviana",
  ruh: "Ruga",
  rui: "Rufiji",
  ruk: "Che",
  run: "Rundi",
  ruo: "Istro Romanian",
  rup: "Macedo-Romanian",
  ruq: "Megleno Romanian",
  rus: "Russian",
  rut: "Rutul",
  ruu: "Lanas Lobu",
  ruy: "Mala (Nigeria)",
  ruz: "Ruma",
  rwa: "Rawo",
  rwk: "Rwa",
  rwm: "Amba (Uganda)",
  rwo: "Rawa",
  rwr: "Marwari (India)",
  rxd: "Ngardi",
  rxw: "Karuwali",
  ryn: "Northern Amami-Oshima",
  rys: "Yaeyama",
  ryu: "Central Okinawan",
  rzh: "Rzi",
  saa: "Saba",
  sab: "Buglere",
  sac: "Meskwaki",
  sad: "Sandawe",
  sae: "Saban",
  saf: "Safaliba",
  sag: "Sango",
  sah: "Yakut",
  saj: "Sahu",
  sak: "Sake",
  sam: "Samaritan Aramaic",
  san: "Sanskrit",
  sao: "Sause",
  saq: "Samburu",
  sar: "Saraveca",
  sas: "Sasak",
  sat: "Santali",
  sau: "Saleman",
  sav: "Saafi-Saafi",
  saw: "Sawi",
  sax: "Sa",
  say: "Saya",
  saz: "Saurashtra",
  sba: "Ngambay",
  sbb: "Simbo",
  sbc: "Kele (Papua New Guinea)",
  sbd: "Southern Samo",
  sbe: "Saliba",
  sbf: "Chabu",
  sbg: "Seget",
  sbh: "Sori-Harengan",
  sbi: "Seti",
  sbj: "Surbakhal",
  sbk: "Safwa",
  sbl: "Botolan Sambal",
  sbm: "Sagala",
  sbn: "Sindhi Bhil",
  sbo: "Sabm",
  sbp: "Sangu (Tanzania)",
  sbq: "Sileibi",
  sbr: "Sembakung Murut",
  sbs: "Subiya",
  sbt: "Kimki",
  sbu: "Stod Bhoti",
  sbv: "Sabine",
  sbw: "Simba",
  sbx: "Seberuang",
  sby: "Soli",
  sbz: "Sara Kaba",
  scb: "Chut",
  sce: "Dongxiang",
  scf: "San Miguel Creole French",
  scg: "Sanggau",
  sch: "Sakachep",
  sci: "Sri Lankan Creole Malay",
  sck: "Sadri",
  scl: "Shina",
  scn: "Sicilian",
  sco: "Scots",
  scp: "Helambu Sherpa",
  scq: "Sa'och",
  scs: "North Slavey",
  sct: "Southern Katang",
  scu: "Shumcho",
  scv: "Sheni",
  scw: "Sha",
  scx: "Sicel",
  sda: "Toraja-Sa'dan",
  sdb: "Shabak",
  sdc: "Sassarese Sardinian",
  sde: "Surubu",
  sdf: "Sarli",
  sdg: "Savi",
  sdh: "Southern Kurdish",
  sdj: "Suundi",
  sdk: "Sos Kundi",
  sdl: "Saudi Arabian Sign Language",
  sdm: "Semandang",
  sdn: "Gallurese Sardinian",
  sdo: "Bukar-Sadung Bidayuh",
  sdp: "Sherdukpen",
  sdr: "Oraon Sadri",
  sds: "Sened",
  sdt: "Shuadit",
  sdu: "Sarudu",
  sdx: "Sibu Melanau",
  sdz: "Sallands",
  sea: "Semai",
  seb: "Shempire Senoufo",
  sec: "Sechelt",
  sed: "Sedang",
  see: "Seneca",
  sef: "Cebaara Senoufo",
  seg: "Segeju",
  seh: "Sena",
  sei: "Seri",
  sej: "Sene",
  sek: "Sekani",
  sel: "Selkup",
  sen: "Nanerig Snoufo",
  seo: "Suarmin",
  sep: "Sct Snoufo",
  seq: "Senara Snoufo",
  ser: "Serrano",
  ses: "Koyraboro Senni Songhai",
  set: "Sentani",
  seu: "Serui-Laut",
  sev: "Nyarafolo Senoufo",
  sew: "Sewa Bay",
  sey: "Secoya",
  sez: "Senthang Chin",
  sfb: "Langue des signes de Belgique Francophone",
  sfe: "Eastern Subanen",
  sfm: "Small Flowery Miao",
  sfs: "South African Sign Language",
  sfw: "Sehwi",
  sga: "Old Irish (to 900)",
  sgb: "Mag-antsi Ayta",
  sgc: "Kipsigis",
  sgd: "Surigaonon",
  sge: "Segai",
  sgg: "Swiss-German Sign Language",
  sgh: "Shughni",
  sgi: "Suga",
  sgj: "Surgujia",
  sgk: "Sangkong",
  sgm: "Singa",
  sgp: "Singpho",
  sgr: "Sangisari",
  sgs: "Samogitian",
  sgt: "Brokpake",
  sgu: "Salas",
  sgw: "Sebat Bet Gurage",
  sgx: "Sierra Leone Sign Language",
  sgy: "Sanglechi",
  sgz: "Sursurunga",
  sha: "Shall-Zwall",
  shb: "Ninam",
  shc: "Sonde",
  shd: "Kundal Shahi",
  she: "Sheko",
  shg: "Shua",
  shh: "Shoshoni",
  shi: "Tachelhit",
  shj: "Shatt",
  shk: "Shilluk",
  shl: "Shendu",
  shm: "Shahrudi",
  shn: "Shan",
  sho: "Shanga",
  shp: "Shipibo-Conibo",
  shq: "Sala",
  shr: "Shi",
  shs: "Shuswap",
  sht: "Shasta",
  shu: "Chadian Arabic",
  shv: "Shehri",
  shw: "Shwai",
  shx: "She",
  shy: "Tachawit",
  shz: "Syenara Senoufo",
  sia: "Akkala Sami",
  sib: "Sebop",
  sid: "Sidamo",
  sie: "Simaa",
  sif: "Siamou",
  sig: "Paasaal",
  sih: "Zire",
  sii: "Shom Peng",
  sij: "Numbami",
  sik: "Sikiana",
  sil: "Tumulung Sisaala",
  sim: "Mende (Papua New Guinea)",
  sin: "Sinhala",
  sip: "Sikkimese",
  siq: "Sonia",
  sir: "Siri",
  sis: "Siuslaw",
  siu: "Sinagen",
  siv: "Sumariup",
  siw: "Siwai",
  six: "Sumau",
  siy: "Sivandi",
  siz: "Siwi",
  sja: "Epena",
  sjb: "Sajau Basap",
  sjd: "Kildin Sami",
  sje: "Pite Sami",
  sjg: "Assangori",
  sjk: "Kemi Sami",
  sjl: "Sajalong",
  sjm: "Mapun",
  sjn: "Sindarin",
  sjo: "Xibe",
  sjp: "Surjapuri",
  sjr: "Siar-Lak",
  sjs: "Senhaja De Srair",
  sjt: "Ter Sami",
  sju: "Ume Sami",
  sjw: "Shawnee",
  ska: "Skagit",
  skb: "Saek",
  skc: "Ma Manda",
  skd: "Southern Sierra Miwok",
  ske: "Seke (Vanuatu)",
  skf: "Sakirabi",
  skg: "Sakalava Malagasy",
  skh: "Sikule",
  ski: "Sika",
  skj: "Seke (Nepal)",
  skm: "Kutong",
  skn: "Kolibugan Subanon",
  sko: "Seko Tengah",
  skp: "Sekapan",
  skq: "Sininkere",
  skr: "Saraiki",
  sks: "Maia",
  skt: "Sakata",
  sku: "Sakao",
  skv: "Skou",
  skw: "Skepi Creole Dutch",
  skx: "Seko Padang",
  sky: "Sikaiana",
  skz: "Sekar",
  slc: "Sliba",
  sld: "Sissala",
  sle: "Sholaga",
  slf: "Swiss-Italian Sign Language",
  slg: "Selungai Murut",
  slh: "Southern Puget Sound Salish",
  sli: "Lower Silesian",
  slj: "Salum",
  slk: "Slovak",
  sll: "Salt-Yui",
  slm: "Pangutaran Sama",
  sln: "Salinan",
  slp: "Lamaholot",
  slq: "Salchuq",
  slr: "Salar",
  sls: "Singapore Sign Language",
  slt: "Sila",
  slu: "Selaru",
  slv: "Slovenian",
  slw: "Sialum",
  slx: "Salampasu",
  sly: "Selayar",
  slz: "Ma'ya",
  sma: "Southern Sami",
  smb: "Simbari",
  smc: "Som",
  smd: "Sama",
  sme: "Northern Sami",
  smf: "Auwe",
  smg: "Simbali",
  smh: "Samei",
  smj: "Lule Sami",
  smk: "Bolinao",
  sml: "Central Sama",
  smm: "Musasa",
  smn: "Inari Sami",
  smo: "Samoan",
  smp: "Samaritan",
  smq: "Samo",
  smr: "Simeulue",
  sms: "Skolt Sami",
  smt: "Simte",
  smu: "Somray",
  smv: "Samvedi",
  smw: "Sumbawa",
  smx: "Samba",
  smy: "Semnani",
  smz: "Simeku",
  sna: "Shona",
  snb: "Sebuyau",
  snc: "Sinaugoro",
  snd: "Sindhi",
  sne: "Bau Bidayuh",
  snf: "Noon",
  sng: "Sanga (Democratic Republic of Congo)",
  sni: "Sensi",
  snj: "Riverain Sango",
  snk: "Soninke",
  snl: "Sangil",
  snm: "Southern Ma'di",
  snn: "Siona",
  sno: "Snohomish",
  snp: "Siane",
  snq: "Sangu (Gabon)",
  snr: "Sihan",
  sns: "South West Bay",
  snu: "Senggi",
  snv: "Sa'ban",
  snw: "Selee",
  snx: "Sam",
  sny: "Saniyo-Hiyewe",
  snz: "Sinsauru",
  soa: "Thai Song",
  sob: "Sobei",
  soc: "So (Democratic Republic of Congo)",
  sod: "Songoora",
  soe: "Songomeno",
  sog: "Sogdian",
  soh: "Aka",
  soi: "Sonha",
  soj: "Soi",
  sok: "Sokoro",
  sol: "Solos",
  som: "Somali",
  soo: "Songo",
  sop: "Songe",
  soq: "Kanasi",
  sor: "Somrai",
  sos: "Seeku",
  sot: "Southern Sotho",
  sou: "Southern Thai",
  sov: "Sonsorol",
  sow: "Sowanda",
  sox: "Swo",
  soy: "Miyobe",
  soz: "Temi",
  spa: "Spanish",
  spb: "Sepa (Indonesia)",
  spc: "Sap",
  spd: "Saep",
  spe: "Sepa (Papua New Guinea)",
  spg: "Sian",
  spi: "Saponi",
  spk: "Sengo",
  spl: "Selepet",
  spm: "Akukem",
  spn: "Sanapan",
  spo: "Spokane",
  spp: "Supyire Senoufo",
  spq: "Loreto-Ucayali Spanish",
  spr: "Saparua",
  sps: "Saposa",
  spt: "Spiti Bhoti",
  spu: "Sapuan",
  spv: "Sambalpuri",
  spx: "South Picene",
  spy: "Sabaot",
  sqa: "Shama-Sambuga",
  sqh: "Shau",
  sqi: "Albanian",
  sqk: "Albanian Sign Language",
  sqm: "Suma",
  sqn: "Susquehannock",
  sqo: "Sorkhei",
  sqq: "Sou",
  sqr: "Siculo Arabic",
  sqs: "Sri Lankan Sign Language",
  sqt: "Soqotri",
  squ: "Squamish",
  sra: "Saruga",
  srb: "Sora",
  src: "Logudorese Sardinian",
  srd: "Sardinian",
  sre: "Sara",
  srf: "Nafi",
  srg: "Sulod",
  srh: "Sarikoli",
  sri: "Siriano",
  srk: "Serudung Murut",
  srl: "Isirawa",
  srm: "Saramaccan",
  srn: "Sranan Tongo",
  sro: "Campidanese Sardinian",
  srp: "Serbian",
  srq: "Sirion",
  srr: "Serer",
  srs: "Sarsi",
  srt: "Sauri",
  sru: "Suru",
  srv: "Southern Sorsoganon",
  srw: "Serua",
  srx: "Sirmauri",
  sry: "Sera",
  srz: "Shahmirzadi",
  ssb: "Southern Sama",
  ssc: "Suba-Simbiti",
  ssd: "Siroi",
  sse: "Balangingi",
  ssf: "Thao",
  ssg: "Seimat",
  ssh: "Shihhi Arabic",
  ssi: "Sansi",
  ssj: "Sausi",
  ssk: "Sunam",
  ssl: "Western Sisaala",
  ssm: "Semnam",
  ssn: "Waata",
  sso: "Sissano",
  ssp: "Spanish Sign Language",
  ssq: "So'a",
  ssr: "Swiss-French Sign Language",
  sss: "S",
  sst: "Sinasina",
  ssu: "Susuami",
  ssv: "Shark Bay",
  ssw: "Swati",
  ssx: "Samberigi",
  ssy: "Saho",
  ssz: "Sengseng",
  sta: "Settla",
  stb: "Northern Subanen",
  std: "Sentinel",
  ste: "Liana-Seti",
  stf: "Seta",
  stg: "Trieng",
  sth: "Shelta",
  sti: "Bulo Stieng",
  stj: "Matya Samo",
  stk: "Arammba",
  stl: "Stellingwerfs",
  stm: "Setaman",
  stn: "Owa",
  sto: "Stoney",
  stp: "Southeastern Tepehuan",
  stq: "Saterfriesisch",
  str: "Straits Salish",
  sts: "Shumashti",
  stt: "Budeh Stieng",
  stu: "Samtao",
  stv: "Silt'e",
  stw: "Satawalese",
  sty: "Siberian Tatar",
  sua: "Sulka",
  sub: "Suku",
  suc: "Western Subanon",
  sue: "Suena",
  sug: "Suganga",
  sui: "Suki",
  suj: "Shubi",
  suk: "Sukuma",
  sun: "Sundanese",
  suq: "Suri",
  sur: "Mwaghavul",
  sus: "Susu",
  sut: "Subtiaba",
  suv: "Puroik",
  suw: "Sumbwa",
  sux: "Sumerian",
  suy: "Suy",
  suz: "Sunwar",
  sva: "Svan",
  svb: "Ulau-Suain",
  svc: "Vincentian Creole English",
  sve: "Serili",
  svk: "Slovakian Sign Language",
  svm: "Slavomolisano",
  svs: "Savosavo",
  svx: "Skalvian",
  swa: "Swahili (macrolanguage)",
  swb: "Maore Comorian",
  swc: "Congo Swahili",
  swe: "Swedish",
  swf: "Sere",
  swg: "Swabian",
  swh: "Swahili (individual language)",
  swi: "Sui",
  swj: "Sira",
  swk: "Malawi Sena",
  swl: "Swedish Sign Language",
  swm: "Samosa",
  swn: "Sawknah",
  swo: "Shanenawa",
  swp: "Suau",
  swq: "Sharwa",
  swr: "Saweru",
  sws: "Seluwasan",
  swt: "Sawila",
  swu: "Suwawa",
  swv: "Shekhawati",
  sww: "Sowa",
  swx: "Suruah",
  swy: "Sarua",
  sxb: "Suba",
  sxc: "Sicanian",
  sxe: "Sighu",
  sxg: "Shixing",
  sxk: "Southern Kalapuya",
  sxl: "Selian",
  sxm: "Samre",
  sxn: "Sangir",
  sxo: "Sorothaptic",
  sxr: "Saaroa",
  sxs: "Sasaru",
  sxu: "Upper Saxon",
  sxw: "Saxwe Gbe",
  sya: "Siang",
  syb: "Central Subanen",
  syc: "Classical Syriac",
  syi: "Seki",
  syk: "Sukur",
  syl: "Sylheti",
  sym: "Maya Samo",
  syn: "Senaya",
  syo: "Suoy",
  syr: "Syriac",
  sys: "Sinyar",
  syw: "Kagate",
  syx: "Samay",
  syy: "Al-Sayyid Bedouin Sign Language",
  sza: "Semelai",
  szb: "Ngalum",
  szc: "Semaq Beri",
  szd: "Seru",
  sze: "Seze",
  szg: "Sengele",
  szl: "Silesian",
  szn: "Sula",
  szp: "Suabo",
  szs: "Solomon Islands Sign Language",
  szv: "Isu (Fako Division)",
  szw: "Sawai",
  taa: "Lower Tanana",
  tab: "Tabassaran",
  tac: "Lowland Tarahumara",
  tad: "Tause",
  tae: "Tariana",
  taf: "Tapirap",
  tag: "Tagoi",
  tah: "Tahitian",
  taj: "Eastern Tamang",
  tak: "Tala",
  tal: "Tal",
  tam: "Tamil",
  tan: "Tangale",
  tao: "Yami",
  tap: "Taabwa",
  taq: "Tamasheq",
  tar: "Central Tarahumara",
  tas: "Tay Boi",
  tat: "Tatar",
  tau: "Upper Tanana",
  tav: "Tatuyo",
  taw: "Tai",
  tax: "Tamki",
  tay: "Atayal",
  taz: "Tocho",
  tba: "Aikan",
  tbb: "Tapeba",
  tbc: "Takia",
  tbd: "Kaki Ae",
  tbe: "Tanimbili",
  tbf: "Mandara",
  tbg: "North Tairora",
  tbh: "Thurawal",
  tbi: "Gaam",
  tbj: "Tiang",
  tbk: "Calamian Tagbanwa",
  tbl: "Tboli",
  tbm: "Tagbu",
  tbn: "Barro Negro Tunebo",
  tbo: "Tawala",
  tbp: "Taworta",
  tbr: "Tumtum",
  tbs: "Tanguat",
  tbt: "Tembo (Kitembo)",
  tbu: "Tubar",
  tbv: "Tobo",
  tbw: "Tagbanwa",
  tbx: "Kapin",
  tby: "Tabaru",
  tbz: "Ditammari",
  tca: "Ticuna",
  tcb: "Tanacross",
  tcc: "Datooga",
  tcd: "Tafi",
  tce: "Southern Tutchone",
  tcf: "Malinaltepec Me'phaa",
  tcg: "Tamagario",
  tch: "Turks And Caicos Creole English",
  tci: "Wra",
  tck: "Tchitchege",
  tcl: "Taman (Myanmar)",
  tcm: "Tanahmerah",
  tcn: "Tichurong",
  tco: "Taungyo",
  tcp: "Tawr Chin",
  tcq: "Kaiy",
  tcs: "Torres Strait Creole",
  tct: "T'en",
  tcu: "Southeastern Tarahumara",
  tcw: "Tecpatln Totonac",
  tcx: "Toda",
  tcy: "Tulu",
  tcz: "Thado Chin",
  tda: "Tagdal",
  tdb: "Panchpargania",
  tdc: "Ember-Tad",
  tdd: "Tai Na",
  tde: "Tiranige Diga Dogon",
  tdf: "Talieng",
  tdg: "Western Tamang",
  tdh: "Thulung",
  tdi: "Tomadino",
  tdj: "Tajio",
  tdk: "Tambas",
  tdl: "Sur",
  tdm: "Taruma",
  tdn: "Tondano",
  tdo: "Teme",
  tdq: "Tita",
  tdr: "Todrah",
  tds: "Doutai",
  tdt: "Tetun Dili",
  tdv: "Toro",
  tdx: "Tandroy-Mahafaly Malagasy",
  tdy: "Tadyawan",
  tea: "Temiar",
  teb: "Tetete",
  tec: "Terik",
  ted: "Tepo Krumen",
  tee: "Huehuetla Tepehua",
  tef: "Teressa",
  teg: "Teke-Tege",
  teh: "Tehuelche",
  tei: "Torricelli",
  tek: "Ibali Teke",
  tel: "Telugu",
  tem: "Timne",
  ten: "Tama (Colombia)",
  teo: "Teso",
  tep: "Tepecano",
  teq: "Temein",
  ter: "Tereno",
  tes: "Tengger",
  tet: "Tetum",
  teu: "Soo",
  tev: "Teor",
  tew: "Tewa (USA)",
  tex: "Tennet",
  tey: "Tulishi",
  tfi: "Tofin Gbe",
  tfn: "Tanaina",
  tfo: "Tefaro",
  tfr: "Teribe",
  tft: "Ternate",
  tga: "Sagalla",
  tgb: "Tobilung",
  tgc: "Tigak",
  tgd: "Ciwogai",
  tge: "Eastern Gorkha Tamang",
  tgf: "Chalikha",
  tgh: "Tobagonian Creole English",
  tgi: "Lawunuia",
  tgj: "Tagin",
  tgk: "Tajik",
  tgl: "Tagalog",
  tgn: "Tandaganon",
  tgo: "Sudest",
  tgp: "Tangoa",
  tgq: "Tring",
  tgr: "Tareng",
  tgs: "Nume",
  tgt: "Central Tagbanwa",
  tgu: "Tanggu",
  tgv: "Tingui-Boto",
  tgw: "Tagwana Senoufo",
  tgx: "Tagish",
  tgy: "Togoyo",
  tgz: "Tagalaka",
  tha: "Thai",
  thd: "Thayore",
  the: "Chitwania Tharu",
  thf: "Thangmi",
  thh: "Northern Tarahumara",
  thi: "Tai Long",
  thk: "Tharaka",
  thl: "Dangaura Tharu",
  thm: "Aheu",
  thn: "Thachanadan",
  thp: "Thompson",
  thq: "Kochila Tharu",
  thr: "Rana Tharu",
  ths: "Thakali",
  tht: "Tahltan",
  thu: "Thuri",
  thv: "Tahaggart Tamahaq",
  thw: "Thudam",
  thy: "Tha",
  thz: "Tayart Tamajeq",
  tia: "Tidikelt Tamazight",
  tic: "Tira",
  tif: "Tifal",
  tig: "Tigre",
  tih: "Timugon Murut",
  tii: "Tiene",
  tij: "Tilung",
  tik: "Tikar",
  til: "Tillamook",
  tim: "Timbe",
  tin: "Tindi",
  tio: "Teop",
  tip: "Trimuris",
  tiq: "Tifo",
  tir: "Tigrinya",
  tis: "Masadiit Itneg",
  tit: "Tinigua",
  tiu: "Adasen",
  tiv: "Tiv",
  tiw: "Tiwi",
  tix: "Southern Tiwa",
  tiy: "Tiruray",
  tiz: "Tai Hongjin",
  tja: "Tajuasohn",
  tjg: "Tunjung",
  tji: "Northern Tujia",
  tjl: "Tai Laing",
  tjm: "Timucua",
  tjn: "Tonjon",
  tjo: "Temacine Tamazight",
  tjs: "Southern Tujia",
  tju: "Tjurruru",
  tjw: "Djabwurrung",
  tka: "Truk",
  tkb: "Buksa",
  tkd: "Tukudede",
  tke: "Takwane",
  tkf: "Tukumanfd",
  tkg: "Tesaka Malagasy",
  tkl: "Tokelau",
  tkm: "Takelma",
  tkn: "Toku-No-Shima",
  tkp: "Tikopia",
  tkq: "Tee",
  tkr: "Tsakhur",
  tks: "Takestani",
  tkt: "Kathoriya Tharu",
  tku: "Upper Necaxa Totonac",
  tkv: "Mur Pano",
  tkw: "Teanu",
  tkx: "Tangko",
  tkz: "Takua",
  tla: "Southwestern Tepehuan",
  tlb: "Tobelo",
  tlc: "Yecuatla Totonac",
  tld: "Talaud",
  tlf: "Telefol",
  tlg: "Tofanma",
  tlh: "Klingon",
  tli: "Tlingit",
  tlj: "Talinga-Bwisi",
  tlk: "Taloki",
  tll: "Tetela",
  tlm: "Tolomako",
  tln: "Talondo'",
  tlo: "Talodi",
  tlp: "Filomena Mata-Coahuitln Totonac",
  tlq: "Tai Loi",
  tlr: "Talise",
  tls: "Tambotalo",
  tlt: "Sou Nama",
  tlu: "Tulehu",
  tlv: "Taliabu",
  tlx: "Khehek",
  tly: "Talysh",
  tma: "Tama (Chad)",
  tmb: "Katbol",
  tmc: "Tumak",
  tmd: "Haruai",
  tme: "Trememb",
  tmf: "Toba-Maskoy",
  tmg: "Ternateo",
  tmh: "Tamashek",
  tmi: "Tutuba",
  tmj: "Samarokena",
  tmk: "Northwestern Tamang",
  tml: "Tamnim Citak",
  tmm: "Tai Thanh",
  tmn: "Taman (Indonesia)",
  tmo: "Temoq",
  tmq: "Tumleo",
  tmr: "Jewish Babylonian Aramaic (ca. 200-1200 CE)",
  tms: "Tima",
  tmt: "Tasmate",
  tmu: "Iau",
  tmv: "Tembo (Motembo)",
  tmw: "Temuan",
  tmy: "Tami",
  tmz: "Tamanaku",
  tna: "Tacana",
  tnb: "Western Tunebo",
  tnc: "Tanimuca-Retuar",
  tnd: "Angosturas Tunebo",
  tng: "Tobanga",
  tnh: "Maiani",
  tni: "Tandia",
  tnk: "Kwamera",
  tnl: "Lenakel",
  tnm: "Tabla",
  tnn: "North Tanna",
  tno: "Toromono",
  tnp: "Whitesands",
  tnq: "Taino",
  tnr: "Mnik",
  tns: "Tenis",
  tnt: "Tontemboan",
  tnu: "Tay Khang",
  tnv: "Tangchangya",
  tnw: "Tonsawang",
  tnx: "Tanema",
  tny: "Tongwe",
  tnz: "Ten'edn",
  tob: "Toba",
  toc: "Coyutla Totonac",
  tod: "Toma",
  tof: "Gizrra",
  tog: "Tonga (Nyasa)",
  toh: "Gitonga",
  toi: "Tonga (Zambia)",
  toj: "Tojolabal",
  tol: "Tolowa",
  tom: "Tombulu",
  ton: "Tonga (Tonga Islands)",
  too: "Xicotepec De Jurez Totonac",
  top: "Papantla Totonac",
  toq: "Toposa",
  tor: "Togbo-Vara Banda",
  tos: "Highland Totonac",
  tou: "Tho",
  tov: "Upper Taromi",
  tow: "Jemez",
  tox: "Tobian",
  toy: "Topoiyo",
  toz: "To",
  tpa: "Taupota",
  tpc: "Azoy Me'phaa",
  tpe: "Tippera",
  tpf: "Tarpia",
  tpg: "Kula",
  tpi: "Tok Pisin",
  tpj: "Tapiet",
  tpk: "Tupinikin",
  tpl: "Tlacoapa Me'phaa",
  tpm: "Tampulma",
  tpn: "Tupinamb",
  tpo: "Tai Pao",
  tpp: "Pisaflores Tepehua",
  tpq: "Tukpa",
  tpr: "Tupar",
  tpt: "Tlachichilco Tepehua",
  tpu: "Tampuan",
  tpv: "Tanapag",
  tpw: "Tup",
  tpx: "Acatepec Me'phaa",
  tpy: "Trumai",
  tpz: "Tinputz",
  tqb: "Temb",
  tql: "Lehali",
  tqm: "Turumsa",
  tqn: "Tenino",
  tqo: "Toaripi",
  tqp: "Tomoip",
  tqq: "Tunni",
  tqr: "Torona",
  tqt: "Western Totonac",
  tqu: "Touo",
  tqw: "Tonkawa",
  tra: "Tirahi",
  trb: "Terebu",
  trc: "Copala Triqui",
  trd: "Turi",
  tre: "East Tarangan",
  trf: "Trinidadian Creole English",
  trg: "Lishn Didn",
  trh: "Turaka",
  tri: "Tri",
  trj: "Toram",
  trl: "Traveller Scottish",
  trm: "Tregami",
  trn: "Trinitario",
  tro: "Tarao Naga",
  trp: "Kok Borok",
  trq: "San Martn Itunyoso Triqui",
  trr: "Taushiro",
  trs: "Chicahuaxtla Triqui",
  trt: "Tunggare",
  tru: "Turoyo",
  trv: "Taroko",
  trw: "Torwali",
  trx: "Tringgus-Sembaan Bidayuh",
  try: "Turung",
  trz: "Tor",
  tsa: "Tsaangi",
  tsb: "Tsamai",
  tsc: "Tswa",
  tsd: "Tsakonian",
  tse: "Tunisian Sign Language",
  tsg: "Tausug",
  tsh: "Tsuvan",
  tsi: "Tsimshian",
  tsj: "Tshangla",
  tsk: "Tseku",
  tsl: "Ts'n-Lao",
  tsm: "Turkish Sign Language",
  tsn: "Tswana",
  tso: "Tsonga",
  tsp: "Northern Toussian",
  tsq: "Thai Sign Language",
  tsr: "Akei",
  tss: "Taiwan Sign Language",
  tst: "Tondi Songway Kiini",
  tsu: "Tsou",
  tsv: "Tsogo",
  tsw: "Tsishingini",
  tsx: "Mubami",
  tsy: "Tebul Sign Language",
  tsz: "Purepecha",
  tta: "Tutelo",
  ttb: "Gaa",
  ttc: "Tektiteko",
  ttd: "Tauade",
  tte: "Bwanabwana",
  ttf: "Tuotomb",
  ttg: "Tutong",
  tth: "Upper Ta'oih",
  tti: "Tobati",
  ttj: "Tooro",
  ttk: "Totoro",
  ttl: "Totela",
  ttm: "Northern Tutchone",
  ttn: "Towei",
  tto: "Lower Ta'oih",
  ttp: "Tombelala",
  ttq: "Tawallammat Tamajaq",
  ttr: "Tera",
  tts: "Northeastern Thai",
  ttt: "Muslim Tat",
  ttu: "Torau",
  ttv: "Titan",
  ttw: "Long Wat",
  tty: "Sikaritai",
  ttz: "Tsum",
  tua: "Wiarumus",
  tub: "Tbatulabal",
  tuc: "Mutu",
  tud: "Tux",
  tue: "Tuyuca",
  tuf: "Central Tunebo",
  tug: "Tunia",
  tuh: "Taulil",
  tui: "Tupuri",
  tuj: "Tugutil",
  tuk: "Turkmen",
  tul: "Tula",
  tum: "Tumbuka",
  tun: "Tunica",
  tuo: "Tucano",
  tuq: "Tedaga",
  tur: "Turkish",
  tus: "Tuscarora",
  tuu: "Tututni",
  tuv: "Turkana",
  tux: "Tuxinwa",
  tuy: "Tugen",
  tuz: "Turka",
  tva: "Vaghua",
  tvd: "Tsuvadi",
  tve: "Te'un",
  tvk: "Southeast Ambrym",
  tvl: "Tuvalu",
  tvm: "Tela-Masbuar",
  tvn: "Tavoyan",
  tvo: "Tidore",
  tvs: "Taveta",
  tvt: "Tutsa Naga",
  tvu: "Tunen",
  tvw: "Sedoa",
  tvy: "Timor Pidgin",
  twa: "Twana",
  twb: "Western Tawbuid",
  twc: "Teshenawa",
  twd: "Twents",
  twe: "Tewa (Indonesia)",
  twf: "Northern Tiwa",
  twg: "Tereweng",
  twh: "Tai Dn",
  twi: "Twi",
  twl: "Tawara",
  twm: "Tawang Monpa",
  twn: "Twendi",
  two: "Tswapong",
  twp: "Ere",
  twq: "Tasawaq",
  twr: "Southwestern Tarahumara",
  twt: "Turiwra",
  twu: "Termanu",
  tww: "Tuwari",
  twx: "Tewe",
  twy: "Tawoyan",
  txa: "Tombonuo",
  txb: "Tokharian B",
  txc: "Tsetsaut",
  txe: "Totoli",
  txg: "Tangut",
  txh: "Thracian",
  txi: "Ikpeng",
  txj: "Tarjumo",
  txm: "Tomini",
  txn: "West Tarangan",
  txo: "Toto",
  txq: "Tii",
  txr: "Tartessian",
  txs: "Tonsea",
  txt: "Citak",
  txu: "Kayap",
  txx: "Tatana",
  txy: "Tanosy Malagasy",
  tya: "Tauya",
  tye: "Kyanga",
  tyh: "O'du",
  tyi: "Teke-Tsaayi",
  tyj: "Tai Do",
  tyl: "Thu Lao",
  tyn: "Kombai",
  typ: "Thaypan",
  tyr: "Tai Daeng",
  tys: "Ty Sa Pa",
  tyt: "Ty Tac",
  tyu: "Kua",
  tyv: "Tuvinian",
  tyx: "Teke-Tyee",
  tyz: "Ty",
  tza: "Tanzanian Sign Language",
  tzh: "Tzeltal",
  tzj: "Tz'utujil",
  tzl: "Talossan",
  tzm: "Central Atlas Tamazight",
  tzn: "Tugun",
  tzo: "Tzotzil",
  tzx: "Tabriak",
  uam: "Uamu",
  uan: "Kuan",
  uar: "Tairuma",
  uba: "Ubang",
  ubi: "Ubi",
  ubl: "Buhi'non Bikol",
  ubr: "Ubir",
  ubu: "Umbu-Ungu",
  uby: "Ubykh",
  uda: "Uda",
  ude: "Udihe",
  udg: "Muduga",
  udi: "Udi",
  udj: "Ujir",
  udl: "Wuzlam",
  udm: "Udmurt",
  udu: "Uduk",
  ues: "Kioko",
  ufi: "Ufim",
  uga: "Ugaritic",
  ugb: "Kuku-Ugbanh",
  uge: "Ughele",
  ugn: "Ugandan Sign Language",
  ugo: "Ugong",
  ugy: "Uruguayan Sign Language",
  uha: "Uhami",
  uhn: "Damal",
  uig: "Uighur",
  uis: "Uisai",
  uiv: "Iyive",
  uji: "Tanjijili",
  uka: "Kaburi",
  ukg: "Ukuriguma",
  ukh: "Ukhwejo",
  ukk: "Muak Sa-aak",
  ukl: "Ukrainian Sign Language",
  ukp: "Ukpe-Bayobiri",
  ukq: "Ukwa",
  ukr: "Ukrainian",
  uks: "Urub-Kaapor Sign Language",
  uku: "Ukue",
  ukw: "Ukwuani-Aboh-Ndoni",
  uky: "Kuuk-Yak",
  ula: "Fungwa",
  ulb: "Ulukwumi",
  ulc: "Ulch",
  ule: "Lule",
  ulf: "Usku",
  uli: "Ulithian",
  ulk: "Meriam",
  ull: "Ullatan",
  ulm: "Ulumanda'",
  uln: "Unserdeutsch",
  ulu: "Uma' Lung",
  ulw: "Ulwa",
  uma: "Umatilla",
  umb: "Umbundu",
  umc: "Marrucinian",
  umd: "Umbindhamu",
  umg: "Umbuygamu",
  umi: "Ukit",
  umm: "Umon",
  umn: "Makyan Naga",
  umo: "Umotna",
  ump: "Umpila",
  umr: "Umbugarla",
  ums: "Pendau",
  umu: "Munsee",
  una: "North Watut",
  und: "Undetermined",
  une: "Uneme",
  ung: "Ngarinyin",
  unk: "Enawen-Naw",
  unm: "Unami",
  unn: "Kurnai",
  unr: "Mundari",
  unu: "Unubahe",
  unx: "Munda",
  unz: "Unde Kaili",
  upi: "Umeda",
  upv: "Uripiv-Wala-Rano-Atchin",
  ura: "Urarina",
  urb: "Urub-Kaapor",
  urc: "Urningangg",
  urd: "Urdu",
  ure: "Uru",
  urf: "Uradhi",
  urg: "Urigina",
  urh: "Urhobo",
  uri: "Urim",
  urk: "Urak Lawoi'",
  url: "Urali",
  urm: "Urapmin",
  urn: "Uruangnirin",
  uro: "Ura (Papua New Guinea)",
  urp: "Uru-Pa-In",
  urr: "Lehalurup",
  urt: "Urat",
  uru: "Urumi",
  urv: "Uruava",
  urw: "Sop",
  urx: "Urimo",
  ury: "Orya",
  urz: "Uru-Eu-Wau-Wau",
  usa: "Usarufa",
  ush: "Ushojo",
  usi: "Usui",
  usk: "Usaghade",
  usp: "Uspanteco",
  usu: "Uya",
  uta: "Otank",
  ute: "Ute-Southern Paiute",
  utp: "Amba (Solomon Islands)",
  utr: "Etulo",
  utu: "Utu",
  uum: "Urum",
  uun: "Kulon-Pazeh",
  uur: "Ura (Vanuatu)",
  uuu: "U",
  uve: "West Uvean",
  uvh: "Uri",
  uvl: "Lote",
  uwa: "Kuku-Uwanh",
  uya: "Doko-Uyanga",
  uzb: "Uzbek",
  uzn: "Northern Uzbek",
  uzs: "Southern Uzbek",
  vaa: "Vaagri Booli",
  vae: "Vale",
  vaf: "Vafsi",
  vag: "Vagla",
  vah: "Varhadi-Nagpuri",
  vai: "Vai",
  vaj: "Sekele",
  val: "Vehes",
  vam: "Vanimo",
  van: "Valman",
  vao: "Vao",
  vap: "Vaiphei",
  var: "Huarijio",
  vas: "Vasavi",
  vau: "Vanuma",
  vav: "Varli",
  vay: "Wayu",
  vbb: "Southeast Babar",
  vbk: "Southwestern Bontok",
  vec: "Venetian",
  ved: "Veddah",
  vel: "Veluws",
  vem: "Vemgo-Mabas",
  ven: "Venda",
  veo: "Ventureo",
  vep: "Veps",
  ver: "Mom Jango",
  vgr: "Vaghri",
  vgt: "Vlaamse Gebarentaal",
  vic: "Virgin Islands Creole English",
  vid: "Vidunda",
  vie: "Vietnamese",
  vif: "Vili",
  vig: "Viemo",
  vil: "Vilela",
  vin: "Vinza",
  vis: "Vishavan",
  vit: "Viti",
  viv: "Iduna",
  vka: "Kariyarra",
  vki: "Ija-Zuba",
  vkj: "Kujarge",
  vkk: "Kaur",
  vkl: "Kulisusu",
  vkm: "Kamakan",
  vko: "Kodeoha",
  vkp: "Korlai Creole Portuguese",
  vkt: "Tenggarong Kutai Malay",
  vku: "Kurrama",
  vlp: "Valpei",
  vls: "Vlaams",
  vma: "Martuyhunira",
  vmb: "Barbaram",
  vmc: "Juxtlahuaca Mixtec",
  vmd: "Mudu Koraga",
  vme: "East Masela",
  vmf: "Mainfrnkisch",
  vmg: "Lungalunga",
  vmh: "Maraghei",
  vmi: "Miwa",
  vmj: "Ixtayutla Mixtec",
  vmk: "Makhuwa-Shirima",
  vml: "Malgana",
  vmm: "Mitlatongo Mixtec",
  vmp: "Soyaltepec Mazatec",
  vmq: "Soyaltepec Mixtec",
  vmr: "Marenje",
  vms: "Moksela",
  vmu: "Muluridyi",
  vmv: "Valley Maidu",
  vmw: "Makhuwa",
  vmx: "Tamazola Mixtec",
  vmy: "Ayautla Mazatec",
  vmz: "Mazatln Mazatec",
  vnk: "Vano",
  vnm: "Vinmavis",
  vnp: "Vunapu",
  vol: "Volapk",
  vor: "Voro",
  vot: "Votic",
  vra: "Vera'a",
  vro: "Vro",
  vrs: "Varisi",
  vrt: "Burmbar",
  vsi: "Moldova Sign Language",
  vsl: "Venezuelan Sign Language",
  vsv: "Valencian Sign Language",
  vto: "Vitou",
  vum: "Vumbu",
  vun: "Vunjo",
  vut: "Vute",
  vwa: "Awa (China)",
  waa: "Walla Walla",
  wab: "Wab",
  wac: "Wasco-Wishram",
  wad: "Wandamen",
  wae: "Walser",
  waf: "Wakon",
  wag: "Wa'ema",
  wah: "Watubela",
  wai: "Wares",
  waj: "Waffa",
  wal: "Wolaytta",
  wam: "Wampanoag",
  wan: "Wan",
  wao: "Wappo",
  wap: "Wapishana",
  waq: "Wageman",
  war: "Waray (Philippines)",
  was: "Washo",
  wat: "Kaninuwa",
  wau: "Waur",
  wav: "Waka",
  waw: "Waiwai",
  wax: "Watam",
  way: "Wayana",
  waz: "Wampur",
  wba: "Warao",
  wbb: "Wabo",
  wbe: "Waritai",
  wbf: "Wara",
  wbh: "Wanda",
  wbi: "Vwanji",
  wbj: "Alagwa",
  wbk: "Waigali",
  wbl: "Wakhi",
  wbm: "Wa",
  wbp: "Warlpiri",
  wbq: "Waddar",
  wbr: "Wagdi",
  wbs: "West Bengal Sign Language",
  wbt: "Wanman",
  wbv: "Wajarri",
  wbw: "Woi",
  wca: "Yanommi",
  wci: "Waci Gbe",
  wdd: "Wandji",
  wdg: "Wadaginam",
  wdj: "Wadjiginy",
  wdk: "Wadikali",
  wdu: "Wadjigu",
  wdy: "Wadjabangayi",
  wea: "Wewaw",
  wec: "W Western",
  wed: "Wedau",
  weg: "Wergaia",
  weh: "Weh",
  wei: "Kiunum",
  wem: "Weme Gbe",
  weo: "Wemale",
  wep: "Westphalien",
  wer: "Weri",
  wes: "Cameroon Pidgin",
  wet: "Perai",
  weu: "Rawngtu Chin",
  wew: "Wejewa",
  wfg: "Yafi",
  wga: "Wagaya",
  wgb: "Wagawaga",
  wgg: "Wangganguru",
  wgi: "Wahgi",
  wgo: "Waigeo",
  wgu: "Wirangu",
  wgy: "Warrgamay",
  wha: "Sou Upaa",
  whg: "North Wahgi",
  whk: "Wahau Kenyah",
  whu: "Wahau Kayan",
  wib: "Southern Toussian",
  wic: "Wichita",
  wie: "Wik-Epa",
  wif: "Wik-Keyangan",
  wig: "Wik-Ngathana",
  wih: "Wik-Me'anha",
  wii: "Minidien",
  wij: "Wik-Iiyanh",
  wik: "Wikalkan",
  wil: "Wilawila",
  wim: "Wik-Mungkan",
  win: "Ho-Chunk",
  wir: "Wirafd",
  wiu: "Wiru",
  wiv: "Vitu",
  wiy: "Wiyot",
  wja: "Waja",
  wji: "Warji",
  wka: "Kw'adza",
  wkb: "Kumbaran",
  wkd: "Wakde",
  wkl: "Kalanadi",
  wku: "Kunduvadi",
  wkw: "Wakawaka",
  wky: "Wangkayutyuru",
  wla: "Walio",
  wlc: "Mwali Comorian",
  wle: "Wolane",
  wlg: "Kunbarlang",
  wli: "Waioli",
  wlk: "Wailaki",
  wll: "Wali (Sudan)",
  wlm: "Middle Welsh",
  wln: "Walloon",
  wlo: "Wolio",
  wlr: "Wailapa",
  wls: "Wallisian",
  wlu: "Wuliwuli",
  wlv: "Wich Lhamts Vejoz",
  wlw: "Walak",
  wlx: "Wali (Ghana)",
  wly: "Waling",
  wma: "Mawa (Nigeria)",
  wmb: "Wambaya",
  wmc: "Wamas",
  wmd: "Mamaind",
  wme: "Wambule",
  wmh: "Waima'a",
  wmi: "Wamin",
  wmm: "Maiwa (Indonesia)",
  wmn: "Waamwang",
  wmo: "Wom (Papua New Guinea)",
  wms: "Wambon",
  wmt: "Walmajarri",
  wmw: "Mwani",
  wmx: "Womo",
  wnb: "Wanambre",
  wnc: "Wantoat",
  wnd: "Wandarang",
  wne: "Waneci",
  wng: "Wanggom",
  wni: "Ndzwani Comorian",
  wnk: "Wanukaka",
  wnm: "Wanggamala",
  wnn: "Wunumara",
  wno: "Wano",
  wnp: "Wanap",
  wnu: "Usan",
  wnw: "Wintu",
  wny: "Wanyi",
  woa: "Tyaraity",
  wob: "W Northern",
  woc: "Wogeo",
  wod: "Wolani",
  woe: "Woleaian",
  wof: "Gambian Wolof",
  wog: "Wogamusin",
  woi: "Kamang",
  wok: "Longto",
  wol: "Wolof",
  wom: "Wom (Nigeria)",
  won: "Wongo",
  woo: "Manombai",
  wor: "Woria",
  wos: "Hanga Hundi",
  wow: "Wawonii",
  woy: "Weyto",
  wpc: "Maco",
  wra: "Warapu",
  wrb: "Warluwara",
  wrd: "Warduji",
  wrg: "Warungu",
  wrh: "Wiradhuri",
  wri: "Wariyangga",
  wrk: "Garrwa",
  wrl: "Warlmanpa",
  wrm: "Warumungu",
  wrn: "Warnang",
  wro: "Worrorra",
  wrp: "Waropen",
  wrr: "Wardaman",
  wrs: "Waris",
  wru: "Waru",
  wrv: "Waruna",
  wrw: "Gugu Warra",
  wrx: "Wae Rana",
  wry: "Merwari",
  wrz: "Waray (Australia)",
  wsa: "Warembori",
  wsg: "Adilabad Gondi",
  wsi: "Wusi",
  wsk: "Waskia",
  wsr: "Owenia",
  wss: "Wasa",
  wsu: "Wasu",
  wsv: "Wotapuri-Katarqalai",
  wtf: "Watiwa",
  wth: "Wathawurrung",
  wti: "Berta",
  wtk: "Watakataui",
  wtm: "Mewati",
  wtw: "Wotu",
  wua: "Wikngenchera",
  wub: "Wunambal",
  wud: "Wudu",
  wuh: "Wutunhua",
  wul: "Silimo",
  wum: "Wumbvu",
  wun: "Bungu",
  wur: "Wurrugu",
  wut: "Wutung",
  wuu: "Wu Chinese",
  wuv: "Wuvulu-Aua",
  wux: "Wulna",
  wuy: "Wauyai",
  wwa: "Waama",
  wwb: "Wakabunga",
  wwo: "Wetamut",
  wwr: "Warrwa",
  www: "Wawa",
  wxa: "Waxianghua",
  wxw: "Wardandi",
  wya: "Wyandot",
  wyb: "Wangaaybuwan-Ngiyambaa",
  wyi: "Woiwurrung",
  wym: "Wymysorys",
  wyr: "Wayor",
  wyy: "Western Fijian",
  xaa: "Andalusian Arabic",
  xab: "Sambe",
  xac: "Kachari",
  xad: "Adai",
  xae: "Aequian",
  xag: "Aghwan",
  xai: "Kaimb",
  xaj: "Ararandewra",
  xak: "Mku",
  xal: "Kalmyk",
  xam: "/Xam",
  xan: "Xamtanga",
  xao: "Khao",
  xap: "Apalachee",
  xaq: "Aquitanian",
  xar: "Karami",
  xas: "Kamas",
  xat: "Katawixi",
  xau: "Kauwera",
  xav: "Xavnte",
  xaw: "Kawaiisu",
  xay: "Kayan Mahakam",
  xbb: "Lower Burdekin",
  xbc: "Bactrian",
  xbd: "Bindal",
  xbe: "Bigambal",
  xbg: "Bunganditj",
  xbi: "Kombio",
  xbj: "Birrpayi",
  xbm: "Middle Breton",
  xbn: "Kenaboi",
  xbo: "Bolgarian",
  xbp: "Bibbulman",
  xbr: "Kambera",
  xbw: "Kambiw",
  xby: "Batyala",
  xcb: "Cumbric",
  xcc: "Camunic",
  xce: "Celtiberian",
  xcg: "Cisalpine Gaulish",
  xch: "Chemakum",
  xcl: "Classical Armenian",
  xcm: "Comecrudo",
  xcn: "Cotoname",
  xco: "Chorasmian",
  xcr: "Carian",
  xct: "Classical Tibetan",
  xcu: "Curonian",
  xcv: "Chuvantsy",
  xcw: "Coahuilteco",
  xcy: "Cayuse",
  xda: "Darkinyung",
  xdc: "Dacian",
  xdk: "Dharuk",
  xdm: "Edomite",
  xdo: "Kwandu",
  xdy: "Malayic Dayak",
  xeb: "Eblan",
  xed: "Hdi",
  xeg: "//Xegwi",
  xel: "Kelo",
  xem: "Kembayan",
  xep: "Epi-Olmec",
  xer: "Xernte",
  xes: "Kesawai",
  xet: "Xet",
  xeu: "Keoru-Ahia",
  xfa: "Faliscan",
  xga: "Galatian",
  xgb: "Gbin",
  xgd: "Gudang",
  xgf: "Gabrielino-Fernandeo",
  xgg: "Goreng",
  xgi: "Garingbal",
  xgl: "Galindan",
  xgm: "Dharumbal",
  xgr: "Garza",
  xgu: "Unggumi",
  xgw: "Guwa",
  xha: "Harami",
  xhc: "Hunnic",
  xhd: "Hadrami",
  xhe: "Khetrani",
  xho: "Xhosa",
  xhr: "Hernican",
  xht: "Hattic",
  xhu: "Hurrian",
  xhv: "Khua",
  xib: "Iberian",
  xii: "Xiri",
  xil: "Illyrian",
  xin: "Xinca",
  xir: "Xirina",
  xis: "Kisan",
  xiv: "Indus Valley Language",
  xiy: "Xipaya",
  xjb: "Minjungbal",
  xjt: "Jaitmatang",
  xka: "Kalkoti",
  xkb: "Northern Nago",
  xkc: "Kho'ini",
  xkd: "Mendalam Kayan",
  xke: "Kereho",
  xkf: "Khengkha",
  xkg: "Kagoro",
  xki: "Kenyan Sign Language",
  xkj: "Kajali",
  xkk: "Kaco'",
  xkl: "Mainstream Kenyah",
  xkn: "Kayan River Kayan",
  xko: "Kiorr",
  xkp: "Kabatei",
  xkq: "Koroni",
  xkr: "Xakriab",
  xks: "Kumbewaha",
  xkt: "Kantosi",
  xku: "Kaamba",
  xkv: "Kgalagadi",
  xkw: "Kembra",
  xkx: "Karore",
  xky: "Uma' Lasan",
  xkz: "Kurtokha",
  xla: "Kamula",
  xlb: "Loup B",
  xlc: "Lycian",
  xld: "Lydian",
  xle: "Lemnian",
  xlg: "Ligurian (Ancient)",
  xli: "Liburnian",
  xln: "Alanic",
  xlo: "Loup A",
  xlp: "Lepontic",
  xls: "Lusitanian",
  xlu: "Cuneiform Luwian",
  xly: "Elymian",
  xma: "Mushungulu",
  xmb: "Mbonga",
  xmc: "Makhuwa-Marrevone",
  xmd: "Mbudum",
  xme: "Median",
  xmf: "Mingrelian",
  xmg: "Mengaka",
  xmh: "Kuku-Muminh",
  xmj: "Majera",
  xmk: "Ancient Macedonian",
  xml: "Malaysian Sign Language",
  xmm: "Manado Malay",
  xmn: "Manichaean Middle Persian",
  xmo: "Morerebi",
  xmp: "Kuku-Mu'inh",
  xmq: "Kuku-Mangk",
  xmr: "Meroitic",
  xms: "Moroccan Sign Language",
  xmt: "Matbat",
  xmu: "Kamu",
  xmv: "Antankarana Malagasy",
  xmw: "Tsimihety Malagasy",
  xmx: "Maden",
  xmy: "Mayaguduna",
  xmz: "Mori Bawah",
  xna: "Ancient North Arabian",
  xnb: "Kanakanabu",
  xng: "Middle Mongolian",
  xnh: "Kuanhua",
  xni: "Ngarigu",
  xnk: "Nganakarti",
  xnn: "Northern Kankanay",
  xno: "Anglo-Norman",
  xnr: "Kangri",
  xns: "Kanashi",
  xnt: "Narragansett",
  xnu: "Nukunul",
  xny: "Nyiyaparli",
  xnz: "Kenzi",
  xoc: "O'chi'chi'",
  xod: "Kokoda",
  xog: "Soga",
  xoi: "Kominimung",
  xok: "Xokleng",
  xom: "Komo (Sudan)",
  xon: "Konkomba",
  xoo: "Xukur",
  xop: "Kopar",
  xor: "Korubo",
  xow: "Kowaki",
  xpa: "Pirriya",
  xpc: "Pecheneg",
  xpe: "Liberia Kpelle",
  xpg: "Phrygian",
  xpi: "Pictish",
  xpj: "Mpalitjanh",
  xpk: "Kulina Pano",
  xpm: "Pumpokol",
  xpn: "Kapinaw",
  xpo: "Pochutec",
  xpp: "Puyo-Paekche",
  xpq: "Mohegan-Pequot",
  xpr: "Parthian",
  xps: "Pisidian",
  xpt: "Punthamara",
  xpu: "Punic",
  xpy: "Puyo",
  xqa: "Karakhanid",
  xqt: "Qatabanian",
  xra: "Krah",
  xrb: "Eastern Karaboro",
  xrd: "Gundungurra",
  xre: "Kreye",
  xrg: "Minang",
  xri: "Krikati-Timbira",
  xrm: "Armazic",
  xrn: "Arin",
  xrq: "Karranga",
  xrr: "Raetic",
  xrt: "Aranama-Tamique",
  xru: "Marriammu",
  xrw: "Karawa",
  xsa: "Sabaean",
  xsb: "Sambal",
  xsc: "Scythian",
  xsd: "Sidetic",
  xse: "Sempan",
  xsh: "Shamang",
  xsi: "Sio",
  xsl: "South Slavey",
  xsm: "Kasem",
  xsn: "Sanga (Nigeria)",
  xso: "Solano",
  xsp: "Silopi",
  xsq: "Makhuwa-Saka",
  xsr: "Sherpa",
  xss: "Assan",
  xsu: "Sanum",
  xsv: "Sudovian",
  xsy: "Saisiyat",
  xta: "Alcozauca Mixtec",
  xtb: "Chazumba Mixtec",
  xtc: "Katcha-Kadugli-Miri",
  xtd: "Diuxi-Tilantongo Mixtec",
  xte: "Ketengban",
  xtg: "Transalpine Gaulish",
  xth: "Yitha Yitha",
  xti: "Sinicahua Mixtec",
  xtj: "San Juan Teita Mixtec",
  xtl: "Tijaltepec Mixtec",
  xtm: "Magdalena Peasco Mixtec",
  xtn: "Northern Tlaxiaco Mixtec",
  xto: "Tokharian A",
  xtp: "San Miguel Piedras Mixtec",
  xtq: "Tumshuqese",
  xtr: "Early Tripuri",
  xts: "Sindihui Mixtec",
  xtt: "Tacahua Mixtec",
  xtu: "Cuyamecalco Mixtec",
  xtv: "Thawa",
  xtw: "Tawand",
  xty: "Yoloxochitl Mixtec",
  xtz: "Tasmanian",
  xua: "Alu Kurumba",
  xub: "Betta Kurumba",
  xud: "Umiida",
  xug: "Kunigami",
  xuj: "Jennu Kurumba",
  xul: "Ngunawal",
  xum: "Umbrian",
  xun: "Unggaranggu",
  xuo: "Kuo",
  xup: "Upper Umpqua",
  xur: "Urartian",
  xut: "Kuthant",
  xuu: "Kxoe",
  xve: "Venetic",
  xvi: "Kamviri",
  xvn: "Vandalic",
  xvo: "Volscian",
  xvs: "Vestinian",
  xwa: "Kwaza",
  xwc: "Woccon",
  xwd: "Wadi Wadi",
  xwe: "Xwela Gbe",
  xwg: "Kwegu",
  xwj: "Wajuk",
  xwk: "Wangkumara",
  xwl: "Western Xwla Gbe",
  xwo: "Written Oirat",
  xwr: "Kwerba Mamberamo",
  xwt: "Wotjobaluk",
  xww: "Wemba Wemba",
  xxb: "Boro (Ghana)",
  xxk: "Ke'o",
  xxm: "Minkin",
  xxr: "Korop",
  xxt: "Tambora",
  xya: "Yaygir",
  xyb: "Yandjibara",
  xyj: "Mayi-Yapi",
  xyk: "Mayi-Kulan",
  xyl: "Yalakalore",
  xyt: "Mayi-Thakurti",
  xyy: "Yorta Yorta",
  xzh: "Zhang-Zhung",
  xzm: "Zemgalian",
  xzp: "Ancient Zapotec",
  yaa: "Yaminahua",
  yab: "Yuhup",
  yac: "Pass Valley Yali",
  yad: "Yagua",
  yae: "Pum",
  yaf: "Yaka (Democratic Republic of Congo)",
  yag: "Ymana",
  yah: "Yazgulyam",
  yai: "Yagnobi",
  yaj: "Banda-Yangere",
  yak: "Yakama",
  yal: "Yalunka",
  yam: "Yamba",
  yan: "Mayangna",
  yao: "Yao",
  yap: "Yapese",
  yaq: "Yaqui",
  yar: "Yabarana",
  yas: "Nugunu (Cameroon)",
  yat: "Yambeta",
  yau: "Yuwana",
  yav: "Yangben",
  yaw: "Yawalapit",
  yax: "Yauma",
  yay: "Agwagwune",
  yaz: "Lokaa",
  yba: "Yala",
  ybb: "Yemba",
  ybe: "West Yugur",
  ybh: "Yakha",
  ybi: "Yamphu",
  ybj: "Hasha",
  ybk: "Bokha",
  ybl: "Yukuben",
  ybm: "Yaben",
  ybn: "Yabana",
  ybo: "Yabong",
  ybx: "Yawiyo",
  yby: "Yaweyuha",
  ych: "Chesu",
  ycl: "Lolopo",
  ycn: "Yucuna",
  ycp: "Chepya",
  yda: "Yanda",
  ydd: "Eastern Yiddish",
  yde: "Yangum Dey",
  ydg: "Yidgha",
  ydk: "Yoidik",
  yea: "Ravula",
  yec: "Yeniche",
  yee: "Yimas",
  yei: "Yeni",
  yej: "Yevanic",
  yel: "Yela",
  yer: "Tarok",
  yes: "Nyankpa",
  yet: "Yetfa",
  yeu: "Yerukula",
  yev: "Yapunda",
  yey: "Yeyi",
  yga: "Malyangapa",
  ygi: "Yiningayi",
  ygl: "Yangum Gel",
  ygm: "Yagomi",
  ygp: "Gepo",
  ygr: "Yagaria",
  ygs: "Yolu Sign Language",
  ygu: "Yugul",
  ygw: "Yagwoia",
  yha: "Baha Buyang",
  yhd: "Judeo-Iraqi Arabic",
  yhl: "Hlepho Phowa",
  yhs: "Yan-nhau Sign Language",
  yia: "Yinggarda",
  yid: "Yiddish",
  yif: "Ache",
  yig: "Wusa Nasu",
  yih: "Western Yiddish",
  yii: "Yidiny",
  yij: "Yindjibarndi",
  yik: "Dongshanba Lalo",
  yil: "Yindjilandji",
  yim: "Yimchungru Naga",
  yin: "Yinchia",
  yip: "Pholo",
  yiq: "Miqie",
  yir: "North Awyu",
  yis: "Yis",
  yit: "Eastern Lalu",
  yiu: "Awu",
  yiv: "Northern Nisu",
  yix: "Axi Yi",
  yiz: "Azhe",
  yka: "Yakan",
  ykg: "Northern Yukaghir",
  yki: "Yoke",
  ykk: "Yakaikeke",
  ykl: "Khlula",
  ykm: "Kap",
  ykn: "Kua-nsi",
  yko: "Yasa",
  ykr: "Yekora",
  ykt: "Kathu",
  yku: "Kuamasi",
  yky: "Yakoma",
  yla: "Yaul",
  ylb: "Yaleba",
  yle: "Yele",
  ylg: "Yelogu",
  yli: "Angguruk Yali",
  yll: "Yil",
  ylm: "Limi",
  yln: "Langnian Buyang",
  ylo: "Naluo Yi",
  ylr: "Yalarnnga",
  ylu: "Aribwaung",
  yly: "Nylayu",
  ymb: "Yambes",
  ymc: "Southern Muji",
  ymd: "Muda",
  yme: "Yameo",
  ymg: "Yamongeri",
  ymh: "Mili",
  ymi: "Moji",
  ymk: "Makwe",
  yml: "Iamalele",
  ymm: "Maay",
  ymn: "Yamna",
  ymo: "Yangum Mon",
  ymp: "Yamap",
  ymq: "Qila Muji",
  ymr: "Malasar",
  yms: "Mysian",
  ymx: "Northern Muji",
  ymz: "Muzi",
  yna: "Aluo",
  ynd: "Yandruwandha",
  yne: "Lang'e",
  yng: "Yango",
  ynk: "Naukan Yupik",
  ynl: "Yangulam",
  ynn: "Yana",
  yno: "Yong",
  ynq: "Yendang",
  yns: "Yansi",
  ynu: "Yahuna",
  yob: "Yoba",
  yog: "Yogad",
  yoi: "Yonaguni",
  yok: "Yokuts",
  yol: "Yola",
  yom: "Yombe",
  yon: "Yongkom",
  yor: "Yoruba",
  yot: "Yotti",
  yox: "Yoron",
  yoy: "Yoy",
  ypa: "Phala",
  ypb: "Labo Phowa",
  ypg: "Phola",
  yph: "Phupha",
  ypm: "Phuma",
  ypn: "Ani Phowa",
  ypo: "Alo Phola",
  ypp: "Phupa",
  ypz: "Phuza",
  yra: "Yerakai",
  yrb: "Yareba",
  yre: "Yaour",
  yrk: "Nenets",
  yrl: "Nhengatu",
  yrm: "Yirrk-Mel",
  yrn: "Yerong",
  yro: "Yaroam",
  yrs: "Yarsun",
  yrw: "Yarawata",
  yry: "Yarluyandi",
  ysc: "Yassic",
  ysd: "Samatao",
  ysg: "Sonaga",
  ysl: "Yugoslavian Sign Language",
  ysn: "Sani",
  yso: "Nisi (China)",
  ysp: "Southern Lolopo",
  ysr: "Sirenik Yupik",
  yss: "Yessan-Mayo",
  ysy: "Sanie",
  yta: "Talu",
  ytl: "Tanglang",
  ytp: "Thopho",
  ytw: "Yout Wam",
  yty: "Yatay",
  yua: "Yucateco",
  yub: "Yugambal",
  yuc: "Yuchi",
  yud: "Judeo-Tripolitanian Arabic",
  yue: "Yue Chinese",
  yuf: "Havasupai-Walapai-Yavapai",
  yug: "Yug",
  yui: "Yurut",
  yuj: "Karkar-Yuri",
  yuk: "Yuki",
  yul: "Yulu",
  yum: "Quechan",
  yun: "Bena (Nigeria)",
  yup: "Yukpa",
  yuq: "Yuqui",
  yur: "Yurok",
  yut: "Yopno",
  yuw: "Yau (Morobe Province)",
  yux: "Southern Yukaghir",
  yuy: "East Yugur",
  yuz: "Yuracare",
  yva: "Yawa",
  yvt: "Yavitero",
  ywa: "Kalou",
  ywg: "Yinhawangka",
  ywl: "Western Lalu",
  ywn: "Yawanawa",
  ywq: "Wuding-Luquan Yi",
  ywr: "Yawuru",
  ywt: "Xishanba Lalo",
  ywu: "Wumeng Nasu",
  yww: "Yawarawarga",
  yxa: "Mayawali",
  yxg: "Yagara",
  yxl: "Yardliyawarra",
  yxm: "Yinwum",
  yxu: "Yuyu",
  yxy: "Yabula Yabula",
  yyr: "Yir Yoront",
  yyu: "Yau (Sandaun Province)",
  yyz: "Ayizi",
  yzg: "E'ma Buyang",
  yzk: "Zokhuo",
  zaa: "Sierra de Jurez Zapotec",
  zab: "Western Tlacolula Valley Zapotec",
  zac: "Ocotln Zapotec",
  zad: "Cajonos Zapotec",
  zae: "Yareni Zapotec",
  zaf: "Ayoquesco Zapotec",
  zag: "Zaghawa",
  zah: "Zangwal",
  zai: "Isthmus Zapotec",
  zaj: "Zaramo",
  zak: "Zanaki",
  zal: "Zauzou",
  zam: "Miahuatln Zapotec",
  zao: "Ozolotepec Zapotec",
  zap: "Zapotec",
  zaq: "Alopam Zapotec",
  zar: "Rincn Zapotec",
  zas: "Santo Domingo Albarradas Zapotec",
  zat: "Tabaa Zapotec",
  zau: "Zangskari",
  zav: "Yatzachi Zapotec",
  zaw: "Mitla Zapotec",
  zax: "Xadani Zapotec",
  zay: "Zayse-Zergulla",
  zaz: "Zari",
  zbc: "Central Berawan",
  zbe: "East Berawan",
  zbl: "Blissymbols",
  zbt: "Batui",
  zbw: "West Berawan",
  zca: "Coatecas Altas Zapotec",
  zch: "Central Hongshuihe Zhuang",
  zdj: "Ngazidja Comorian",
  zea: "Zeeuws",
  zeg: "Zenag",
  zeh: "Eastern Hongshuihe Zhuang",
  zen: "Zenaga",
  zga: "Kinga",
  zgb: "Guibei Zhuang",
  zgh: "Standard Moroccan Tamazight",
  zgm: "Minz Zhuang",
  zgn: "Guibian Zhuang",
  zgr: "Magori",
  zha: "Zhuang",
  zhb: "Zhaba",
  zhd: "Dai Zhuang",
  zhi: "Zhire",
  zhn: "Nong Zhuang",
  zho: "Chinese",
  zhw: "Zhoa",
  zia: "Zia",
  zib: "Zimbabwe Sign Language",
  zik: "Zimakani",
  zil: "Zialo",
  zim: "Mesme",
  zin: "Zinza",
  zir: "Ziriya",
  ziw: "Zigula",
  ziz: "Zizilivakan",
  zka: "Kaimbulawa",
  zkb: "Koibal",
  zkd: "Kadu",
  zkg: "Koguryo",
  zkh: "Khorezmian",
  zkk: "Karankawa",
  zkn: "Kanan",
  zko: "Kott",
  zkp: "So Paulo Kaingng",
  zkr: "Zakhring",
  zkt: "Kitan",
  zku: "Kaurna",
  zkv: "Krevinian",
  zkz: "Khazar",
  zlj: "Liujiang Zhuang",
  zlm: "Malay (individual language)",
  zln: "Lianshan Zhuang",
  zlq: "Liuqian Zhuang",
  zma: "Manda (Australia)",
  zmb: "Zimba",
  zmc: "Margany",
  zmd: "Maridan",
  zme: "Mangerr",
  zmf: "Mfinu",
  zmg: "Marti Ke",
  zmh: "Makolkol",
  zmi: "Negeri Sembilan Malay",
  zmj: "Maridjabin",
  zmk: "Mandandanyi",
  zml: "Madngele",
  zmm: "Marimanindji",
  zmn: "Mbangwe",
  zmo: "Molo",
  zmp: "Mpuono",
  zmq: "Mituku",
  zmr: "Maranunggu",
  zms: "Mbesa",
  zmt: "Maringarr",
  zmu: "Muruwari",
  zmv: "Mbariman-Gudhinma",
  zmw: "Mbo (Democratic Republic of Congo)",
  zmx: "Bomitaba",
  zmy: "Mariyedi",
  zmz: "Mbandja",
  zna: "Zan Gula",
  zne: "Zande (individual language)",
  zng: "Mang",
  znk: "Manangkari",
  zns: "Mangas",
  zoc: "Copainal Zoque",
  zoh: "Chimalapa Zoque",
  zom: "Zou",
  zoo: "Asuncin Mixtepec Zapotec",
  zoq: "Tabasco Zoque",
  zor: "Rayn Zoque",
  zos: "Francisco Len Zoque",
  zpa: "Lachiguiri Zapotec",
  zpb: "Yautepec Zapotec",
  zpc: "Choapan Zapotec",
  zpd: "Southeastern Ixtln Zapotec",
  zpe: "Petapa Zapotec",
  zpf: "San Pedro Quiatoni Zapotec",
  zpg: "Guevea De Humboldt Zapotec",
  zph: "Totomachapan Zapotec",
  zpi: "Santa Mara Quiegolani Zapotec",
  zpj: "Quiavicuzas Zapotec",
  zpk: "Tlacolulita Zapotec",
  zpl: "Lachixo Zapotec",
  zpm: "Mixtepec Zapotec",
  zpn: "Santa Ins Yatzechi Zapotec",
  zpo: "Amatln Zapotec",
  zpp: "El Alto Zapotec",
  zpq: "Zoogocho Zapotec",
  zpr: "Santiago Xanica Zapotec",
  zps: "Coatln Zapotec",
  zpt: "San Vicente Coatln Zapotec",
  zpu: "Yallag Zapotec",
  zpv: "Chichicapan Zapotec",
  zpw: "Zaniza Zapotec",
  zpx: "San Baltazar Loxicha Zapotec",
  zpy: "Mazaltepec Zapotec",
  zpz: "Texmelucan Zapotec",
  zqe: "Qiubei Zhuang",
  zra: "Kara (Korea)",
  zrg: "Mirgan",
  zrn: "Zerenkel",
  zro: "Zparo",
  zrp: "Zarphatic",
  zrs: "Mairasi",
  zsa: "Sarasira",
  zsk: "Kaskean",
  zsl: "Zambian Sign Language",
  zsm: "Standard Malay",
  zsr: "Southern Rincon Zapotec",
  zsu: "Sukurum",
  zte: "Elotepec Zapotec",
  ztg: "Xanagua Zapotec",
  ztl: "Lapagua-Guivini Zapotec",
  ztm: "San Agustn Mixtepec Zapotec",
  ztn: "Santa Catarina Albarradas Zapotec",
  ztp: "Loxicha Zapotec",
  ztq: "Quioquitani-Quier Zapotec",
  zts: "Tilquiapan Zapotec",
  ztt: "Tejalapan Zapotec",
  ztu: "Gil Zapotec",
  ztx: "Zaachila Zapotec",
  zty: "Yatee Zapotec",
  zua: "Zeem",
  zuh: "Tokano",
  zul: "Zulu",
  zum: "Kumzari",
  zun: "Zuni",
  zuy: "Zumaya",
  zwa: "Zay",
  zxx: "No linguistic content",
  zyb: "Yongbei Zhuang",
  zyg: "Yang Zhuang",
  zyj: "Youjiang Zhuang",
  zyn: "Yongnan Zhuang",
  zyp: "Zyphe Chin",
  zza: "Zaza",
  zzj: "Zuojiang Zhuang"
});

/***/ }),
/* 376 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



/**
 * React Component which Displays an Image tip centered and on top of the
 * position wanted.
 *
 * Takes 3 props:
 *   - {Blob|string} Image - The image blob to display
 *   - {string} [className=""] - An optional className for the image
 *   - {Number} xPosition - The position on the horizontal axis where you
 *     want the image to be centered to.
 *
 * @class ImageTip
 */

var ImageTip = function (_React$Component) {
  _inherits(ImageTip, _React$Component);

  function ImageTip() {
    _classCallCheck(this, ImageTip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    var image = _this.props.image;

    _this.attachBIFImage(image);

    _this.positionIsCorrected = false;
    _this.state = {
      style: {}
    };
    return _this;
  }

  ImageTip.prototype.attachBIFImage = function attachBIFImage(image) {
    if (this.imageUrl) {
      URL.revokeObjectURL(this.imageUrl);
      this.imageUrl = "";
    }

    var blob = new Blob([image], { type: "image/jpeg" });
    var url = URL.createObjectURL(blob);
    this.imageUrl = url;
  };

  ImageTip.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.positionIsCorrected = false;
    var image = nextProps.image;

    if (this.props.image !== image) {
      this.attachBIFImage(image);
    }
  };

  ImageTip.prototype.componentWillUnmount = function componentWillUnmount() {
    URL.revokeObjectURL(this.imageUrl);
  };

  ImageTip.prototype.correctImagePosition = function correctImagePosition() {
    if (this.positionIsCorrected) {
      return;
    }
    var xPosition = this.props.xPosition;


    if (isNaN(+xPosition) || !this.element) {
      return null;
    }

    var style = {
      transform: "translate(" + xPosition + "px, -120px)"
    };

    this.positionIsCorrected = true;
    this.setState({ style: style });
  };

  ImageTip.prototype.componentDidMount = function componentDidMount() {
    this.correctImagePosition();
  };

  ImageTip.prototype.componentDidUpdate = function componentDidUpdate() {
    this.correctImagePosition();
  };

  ImageTip.prototype.render = function render() {
    var _this2 = this;

    var _props$className = this.props.className,
        className = _props$className === undefined ? "" : _props$className;
    var imageUrl = this.imageUrl;
    var style = this.state.style;


    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "image-tip-wrapper",
        style: style,
        ref: function ref(el) {
          return _this2.element = el;
        }
      },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("img", {
        className: "image-tip " + className,
        src: imageUrl
      })
    );
  };

  return ImageTip;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (ImageTip);

/***/ }),
/* 377 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/**
 * Simple select list. Call the onChange call back on choice with the index of
 * the option chosen in argument.
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      onChange = _ref.onChange,
      _ref$value = _ref.value,
      value = _ref$value === undefined ? "" : _ref$value,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === undefined ? "" : _ref$placeholder;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("input", {
    className: "input " + className,
    type: "text",
    placeholder: placeholder,
    onChange: onChange,
    value: value
  });
});

/***/ }),
/* 378 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/**
 * For now, only written "Live" (we will see for timeshifting and such)
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: "position-infos live " + className },
    "Live"
  );
});

/***/ }),
/* 379 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_time_js__ = __webpack_require__(402);



/**
 * Text with the following structure:
 *   CURRENT_POSITION / DURATION
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      _ref$position = _ref.position,
      position = _ref$position === undefined ? 0 : _ref$position,
      _ref$duration = _ref.duration,
      duration = _ref$duration === undefined ? 0 : _ref$duration;

  var convertTime = duration >= 60 * 60 ? __WEBPACK_IMPORTED_MODULE_1__lib_time_js__["a" /* toHours */] : __WEBPACK_IMPORTED_MODULE_1__lib_time_js__["b" /* toMinutes */];
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: "position-infos " + className },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      { className: "current-position" },
      convertTime(position)
    ),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      { className: "separator" },
      " / "
    ),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      { className: "duration" },
      convertTime(duration)
    )
  );
});

/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/**
 * Horizontal (left-to-right) progress bar component which:
 *
 *   - represents the current position and the buffer relatively to the
 *     minimum / maximum position.
 *
 *   - triggers a seek function with the clicked position on click
 *
 *   - call a onMouseMove function with the hovered position and the event when
 *     the mouse hover the component
 *
 *   - call a onMouseOut when it stops hovering it
 *
 * @param {Object} props
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var seek = _ref.seek,
      position = _ref.position,
      bufferGap = _ref.bufferGap,
      minimumPosition = _ref.minimumPosition,
      maximumPosition = _ref.maximumPosition,
      onMouseOut = _ref.onMouseOut,
      _onMouseMove = _ref.onMouseMove;

  var element = void 0;

  var duration = Math.max(maximumPosition - minimumPosition, 0);

  var getMousePosition = function getMousePosition(event) {
    var rect = element.getBoundingClientRect();
    var point0 = rect.left;
    var clickPosPx = Math.max(event.clientX - point0, 0);
    var endPointPx = Math.max(rect.right - point0, 0);
    if (!endPointPx) {
      return 0;
    }
    return clickPosPx / endPointPx * duration + minimumPosition;
  };

  // weird rx-player design decision. Should be fixed (or done in the
  // module)
  var bufferGapHotFix = isFinite(bufferGap) ? bufferGap : 0;
  var relativePosition = Math.max(position - minimumPosition, 0);
  var percentBuffered = Math.min((bufferGapHotFix + relativePosition) / duration, 1) * 100;

  var percentPosition = Math.min(relativePosition / duration, 1) * 100;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    {
      className: "progress-bar-wrapper",
      ref: function ref(el) {
        return element = el;
      },
      onClick: function onClick(event) {
        return seek(getMousePosition(event));
      },
      onMouseOut: onMouseOut,
      onMouseMove: function onMouseMove(evt) {
        return _onMouseMove(getMousePosition(evt), evt);
      }
    },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
      className: "progress-bar-current",
      style: {
        "width": percentPosition + "%"
      }
    }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
      className: "progress-bar-buffered",
      style: {
        "width": percentBuffered + "%"
      }
    })
  );
});

/***/ }),
/* 381 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


/* harmony default export */ __webpack_exports__["a"] = (function (_ref) {
  var title = _ref.title;
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "section",
    { className: "title-wrapper" },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "h1",
      { className: "title" },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "span",
        { className: "light" },
        title
      )
    )
  );
});

/***/ }),
/* 382 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ([{
  "name": "BIF Thumbnail Track example",
  "url": "http://hss-vod-aka-test.canal-bis.com/ondemand/test/bif/index.ism/Manifest",
  "transport": "smooth",
  "supplementaryImageTracks": {
    "mimeType": "application/bif",
    "url": "http://dash-vod-aka-test.canal-bis.com/test/bif/index.bif"
  }
}, {
  "name": "DASH-IF SegmentTimeline",
  "url": "http://vm2.dashif.org/livesim-dev/segtimeline_1/testpic_6s/Manifest.mpd",
  "transport": "dash",
  "live": true
}, {
  "name": "DASH-IF SegmentTemplate",
  "url": "http://vm2.dashif.org/livesim-dev/periods_1/testpic_2s/Manifest.mpd",
  "transport": "dash",
  "live": true
}, {
  "name": "Big Buck Bunny Wowza",
  "url": "https://wowzaec2demo.streamlock.net/live/_definst_/bigbuckbunny/manifest_mpm4sav_mvtime_w925796611.mpd",
  "transport": "dash",
  "live": true
}, {
  "name": "Unified Streaming - Timeline - A-Team",
  "url": "http://demo.unified-streaming.com/video/ateam/ateam.ism/ateam.mpd",
  "transport": "dash"
}, {
  "name": "Smooth Ingest",
  "url": "http://b028.wpc.azureedge.net/80B028/Samples/a38e6323-95e9-4f1f-9b38-75eba91704e4/5f2ce531-d508-49fb-8152-647eba422aec.ism/manifest",
  "transport": "smooth",
  "live": true
}]);

/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Input_jsx__ = __webpack_require__(377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Select_jsx__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__contents_js__ = __webpack_require__(382);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var STREAMING_TECHNOS = ["DASH", "Smooth"];
var CONTENTS_PER_TECHNO = STREAMING_TECHNOS.reduce(function (acc, tech) {
  acc[tech] = __WEBPACK_IMPORTED_MODULE_4__contents_js__["a" /* default */].filter(function (_ref) {
    var transport = _ref.transport;
    return transport === tech.toLowerCase();
  });
  return acc;
}, {});

var ContentList = function (_React$Component) {
  _inherits(ContentList, _React$Component);

  function ContentList() {
    _classCallCheck(this, ContentList);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      techno: STREAMING_TECHNOS[0],
      choiceIndex: 0,
      hasTextInput: !CONTENTS_PER_TECHNO[STREAMING_TECHNOS[0]].length,
      textValue: ""
    };
    return _this;
  }

  ContentList.prototype.loadContent = function loadContent(content) {
    var _props = this.props,
        loadVideo = _props.loadVideo,
        stopVideo = _props.stopVideo;

    if (content == null) {
      stopVideo();
      return;
    }

    var url = content.url,
        transport = content.transport,
        autoPlay = content.autoPlay,
        supplementaryImageTracks = content.supplementaryImageTracks,
        supplementaryTextTracks = content.supplementaryTextTracks,
        textTrackMode = content.textTrackMode;

    loadVideo({
      url: url,
      transport: transport,
      autoPlay: !(autoPlay === false),
      supplementaryImageTracks: supplementaryImageTracks,
      supplementaryTextTracks: supplementaryTextTracks,
      textTrackMode: textTrackMode
    });
  };

  ContentList.prototype.loadUrl = function loadUrl(url) {
    var loadVideo = this.props.loadVideo;

    loadVideo({
      url: url,
      transport: this.state.techno.toLowerCase(),
      autoPlay: true // TODO add checkBox
    });
  };

  ContentList.prototype.changeTechno = function changeTechno(techno) {
    this.setState({
      techno: techno,
      choiceIndex: 0,
      hasTextInput: !CONTENTS_PER_TECHNO[techno].length
    });
  };

  ContentList.prototype.changeContentIndex = function changeContentIndex(index) {
    var techno = this.state.techno;

    var hasTextInput = CONTENTS_PER_TECHNO[techno].length === index;
    this.setState({
      choiceIndex: index,
      hasTextInput: hasTextInput
    });
  };

  // TODO Better event?


  ContentList.prototype.onTextInput = function onTextInput(evt) {
    this.setState({
      textValue: evt.target.value
    });
  };

  ContentList.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        techno = _state.techno,
        choiceIndex = _state.choiceIndex,
        hasTextInput = _state.hasTextInput,
        textValue = _state.textValue;

    var contents = CONTENTS_PER_TECHNO[techno];

    var contentsName = contents.map(function (content) {
      return "" + content.name + (content.live ? " (live)" : "");
    });
    contentsName.push("Custom link");

    var onTechChange = function onTechChange(evt) {
      var index = +evt.target.value;
      if (index >= 0) {
        _this2.changeTechno(STREAMING_TECHNOS[index]);
      }
    };

    var onContentChange = function onContentChange(evt) {
      var index = +evt.target.value;
      _this2.changeContentIndex(index);
    };

    var onClickLoad = function onClickLoad() {
      if (choiceIndex === contents.length) {
        _this2.loadUrl(textValue);
      } else {
        _this2.loadContent(contents[choiceIndex]);
      }
    };

    var onTextInput = function onTextInput(t) {
      return _this2.onTextInput(t);
    };

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "choice-inputs-wrapper"
      },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          className: "content-inputs"
        },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__components_Select_jsx__["a" /* default */], {
          className: "choice-input techno-choice",
          onChange: onTechChange,
          options: STREAMING_TECHNOS
        }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__components_Select_jsx__["a" /* default */], {
          className: "choice-input content-choice",
          onChange: onContentChange,
          options: contentsName,
          selected: choiceIndex
        }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__["a" /* default */], {
          className: "choice-input load-button",
          onClick: onClickLoad,
          value: String.fromCharCode(0xf144)
        })
      ),
      hasTextInput ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_Input_jsx__["a" /* default */], {
        className: "choice-input text-input",
        onChange: onTextInput,
        value: textValue,
        placeholder: "URL for the " + techno + " manifest"
      }) : null
    );
  };

  return ContentList;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (ContentList);

/***/ }),
/* 384 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_PositionInfos_jsx__ = __webpack_require__(379);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_LivePosition_jsx__ = __webpack_require__(378);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PlayPauseButton_jsx__ = __webpack_require__(388);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__FullScreenButton_jsx__ = __webpack_require__(386);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ProgressBar_jsx__ = __webpack_require__(391);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__VolumeButton_jsx__ = __webpack_require__(393);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__VolumeBar_jsx__ = __webpack_require__(392);




// import SettingsButton from "./SettingsButton.jsx";






var ControlBar = function ControlBar(_ref) {
  var currentTime = _ref.currentTime,
      duration = _ref.duration,
      hasLoadedContent = _ref.hasLoadedContent,
      hasEnded = _ref.hasEnded,
      isLive = _ref.isLive,
      player = _ref.player;

  var displayControls = hasLoadedContent && !hasEnded;

  var positionElement = void 0;
  if (!displayControls) {
    positionElement = null;
  } else if (isLive) {
    positionElement = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__components_LivePosition_jsx__["a" /* default */], null);
  } else {
    positionElement = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_PositionInfos_jsx__["a" /* default */], {
      position: currentTime,
      duration: duration
    });
  }

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: "controls-bar-container" },
    !displayControls ? null : __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__ProgressBar_jsx__["a" /* default */], { player: player }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "controls-bar" },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__PlayPauseButton_jsx__["a" /* default */], {
        className: "control-button",
        player: player
      }),
      positionElement,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "controls-right-side" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "volume" },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_7__VolumeButton_jsx__["a" /* default */], {
            className: "control-button",
            player: player
          }),
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__VolumeBar_jsx__["a" /* default */], {
            className: "control-button",
            player: player
          })
        ),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__FullScreenButton_jsx__["a" /* default */], {
          className: "control-button",
          player: player
        })
      )
    )
  );
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    currentTime: "currentTime",
    duration: "duration",
    hasLoadedContent: "hasLoadedContent",
    hasEnded: "hasEnded",
    isLive: "isLive"
  }
})(ControlBar));

/***/ }),
/* 385 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);



var PlayerError = function PlayerError(_ref) {
  var error = _ref.error;

  var message = error && error.message ? error.message : error;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "span",
    {
      className: "fatal-error"
    },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      {
        className: "error-icon icon"
      },
      String.fromCharCode(0xf071)
    ),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      {
        className: "error-intro"
      },
      "The Player encountered a fatal Error:"
    ),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "span",
      {
        className: "error-message"
      },
      message
    )
  );
};

var ErrorDisplayer = function ErrorDisplayer(_ref2) {
  var error = _ref2.error;

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    {
      className: "player-error"
    },
    error ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(PlayerError, { error: error }) : null
  );
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    error: "error"
  }
})(ErrorDisplayer));

/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__ = __webpack_require__(27);




/**
 * Simple fullscreen button.
 * Triggers the right callback on click.
 *
 * Needs 2 props:
 *   - {Object} player: the player module.
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */
var FullscreenButton = function FullscreenButton(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      player = _ref.player,
      isFullscreen = _ref.isFullscreen,
      hasLoadedContent = _ref.hasLoadedContent,
      hasEnded = _ref.hasEnded;
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__["a" /* default */], {
    className: "fullscreen-button " + className,
    onClick: isFullscreen ? function () {
      return player.dispatch("EXIT_FULL_SCREEN");
    } : function () {
      return player.dispatch("SET_FULL_SCREEN");
    },
    disabled: !hasLoadedContent || hasEnded,
    value: String.fromCharCode(isFullscreen ? 0xf066 : 0xf065)
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    isFullscreen: "isFullscreen",
    hasLoadedContent: "hasLoadedContent",
    hasEnded: "hasEnded"
  }
})(FullscreenButton));

/***/ }),
/* 387 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var LogElement = function LogElement(_ref) {
  var text = _ref.text,
      date = _ref.date;
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    {
      className: "player-log-item"
    },
    date.toISOString() + " - " + text
  );
};

var LogDisplayer = function (_React$Component) {
  _inherits(LogDisplayer, _React$Component);

  function LogDisplayer() {
    _classCallCheck(this, LogDisplayer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      logs: []
    };

    // Only scroll to bottom if already scrolled to bottom
    _this.hasScrolledToBottom = true;
    return _this;
  }

  LogDisplayer.prototype.addLog = function addLog(text) {
    // A weird React behavior obligates me to mutate this.state directly
    // to allow multiple setState in a row before rendering.
    // The case seen was that this.state.logs would not change right after
    // setState, so the last addLog call would be the only one really considered

    // TODO What would be cleaner would be to give it to a module or copy the
    // pending state in a context variable.

    // previous version, do not work
    // this.setState({
    //   logs: this.state.logs.concat({
    //     text,
    //     date: new Date(),
    //   }),
    // });

    this.state.logs = [].concat(this.state.logs, [{
      text: text,
      date: new Date()
    }]);

    this.setState({ logs: this.state.logs });
  };

  LogDisplayer.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.destructionSubject = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();
    var player = this.props.player;


    player.$get("videoBitrateAuto").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).subscribe(function (vbAuto) {
      var text = "Video Bitrate selection changed to " + (vbAuto ? "automatic" : "manual");
      _this2.addLog(text);
    });

    player.$get("audioBitrateAuto").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).subscribe(function (abAuto) {
      var text = "Audio Bitrate selection changed to " + (abAuto ? "automatic" : "manual");
      _this2.addLog(text);
    });

    player.$get("videoBitrate").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).subscribe(function (vb) {
      var text = "Video Bitrate changed to " + vb;
      _this2.addLog(text);
    });

    player.$get("audioBitrate").takeUntil(this.destructionSubject).skip(1) // skip initial value
    .subscribe(function (ab) {
      var text = "Audio Bitrate changed to " + ab;
      _this2.addLog(text);
    });

    player.$get("error").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).filter(function (x) {
      return x;
    }).subscribe(function (error) {
      var message = error.message ? error.message : error;
      var text = "The player encountered a fatal Error: " + message;
      _this2.addLog(text);
    });

    player.$get("isLoading").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).filter(function (x) {
      return x;
    }).subscribe(function () {
      var text = "A new content is Loading.";
      _this2.addLog(text);
    });

    player.$get("hasLoadedContent").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).filter(function (x) {
      return x;
    }).subscribe(function () {
      var text = "The new content has been loaded.";
      _this2.addLog(text);
    });

    player.$get("isStopped").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).filter(function (x) {
      return x;
    }).subscribe(function () {
      var text = "The current content is stopped";
      _this2.addLog(text);
    });

    player.$get("hasEnded").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).filter(function (x) {
      return x;
    }).subscribe(function () {
      var text = "The current content has ended";
      _this2.addLog(text);
    });

    player.$get("isBuffering").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).subscribe(function (ib) {
      var text = ib ? "The current content is buffering" : "The current content is not buffering anymore";
      _this2.addLog(text);
    });

    player.$get("isSeeking").skip(1) // skip initial value
    .takeUntil(this.destructionSubject).subscribe(function (ib) {
      var text = ib ? "The current content is seeking" : "The current content is not seeking anymore";
      _this2.addLog(text);
    });
    this.scrollToBottom();

    var onScroll = function onScroll() {
      if (_this2.element.scrollHeight - _this2.element.offsetHeight === _this2.element.scrollTop) {
        _this2.hasScrolledToBottom = true;
      } else {
        _this2.hasScrolledToBottom = false;
      }
    };

    this.element.addEventListener("scroll", onScroll, { passive: true });
    this.destructionSubject.subscribe(function () {
      return _this2.element.removeEventListener("scroll", onScroll);
    });
  };

  LogDisplayer.prototype.scrollToBottom = function scrollToBottom() {
    if (this.hasScrolledToBottom) {
      this.element.scrollTop = this.element.scrollHeight;
    }
  };

  LogDisplayer.prototype.componentDidUpdate = function componentDidUpdate() {
    this.scrollToBottom();
  };

  LogDisplayer.prototype.componentWillUnmount = function componentWillUnmount() {
    this.destructionSubject.next();
    this.destructionSubject.complete();
  };

  LogDisplayer.prototype.render = function render() {
    var _this3 = this;

    var logs = this.state.logs;


    var logTexts = logs.map(function (_ref2) {
      var text = _ref2.text,
          date = _ref2.date;
      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(LogElement, {
        text: text,
        date: date
      });
    });
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "player-logs-wrapper"
      },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          className: "player-logs-wrapper-title"
        },
        "Logs"
      ),
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        {
          className: "player-logs",
          ref: function ref(el) {
            return _this3.element = el;
          }
        },
        logTexts
      )
    );
  };

  return LogDisplayer;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (LogDisplayer);

/***/ }),
/* 388 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__ = __webpack_require__(27);




/**
 * Play/Pause button.
 * Triggers the right callback on click.
 *
 * Needs 2 props:
 *   - {Object} player: the player module.
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */
var PlayPauseButton = function PlayPauseButton(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      player = _ref.player,
      isPaused = _ref.isPaused,
      hasLoadedContent = _ref.hasLoadedContent,
      hasEnded = _ref.hasEnded;

  var disabled = !hasLoadedContent || hasEnded;
  var displayPause = !isPaused && hasLoadedContent && !hasEnded;

  var completeClassName = "play-pause-button " + className + (disabled ? " disabled" : "");

  var play = function play() {
    return player.dispatch("PLAY");
  };
  var pause = function pause() {
    return player.dispatch("PAUSE");
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__["a" /* default */], {
    className: completeClassName,
    disabled: disabled,
    onClick: displayPause ? pause : play,
    value: String.fromCharCode(displayPause ? 0xf04c : 0xf04b)
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    isPaused: "isPaused",
    hasLoadedContent: "hasLoadedContent",
    hasEnded: "hasEnded"
  }
})(PlayPauseButton));

/***/ }),
/* 389 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_vespertine_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_player__ = __webpack_require__(405);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ControlBar_jsx__ = __webpack_require__(384);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ContentList_jsx__ = __webpack_require__(383);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ErrorDisplayer_jsx__ = __webpack_require__(385);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__PlayerKnobs_jsx__ = __webpack_require__(390);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__LogDisplayer_jsx__ = __webpack_require__(387);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__charts_index_jsx__ = __webpack_require__(396);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }












// time in ms while seeking/loading/buffering after which the spinner is shown
var SPINNER_TIMEOUT = 300;

var Player = function (_React$Component) {
  _inherits(Player, _React$Component);

  function Player() {
    _classCallCheck(this, Player);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      player: null,
      displaySpinner: false
    };

    return _this;
  }

  Player.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var player = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_vespertine_js__["a" /* createModule */])(__WEBPACK_IMPORTED_MODULE_3__modules_player__["a" /* default */], {
      videoElement: this.videoElement,
      textTrackElement: this.textTrackElement
    });

    this._$destroySubject = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();
    this._$destroySubject.subscribe(function () {
      return player.destroy();
    });

    player.$get("isSeeking", "isBuffering", "isLoading").takeUntil(this._$destroySubject).subscribe(function (_ref) {
      var isSeeking = _ref[0],
          isBuffering = _ref[1],
          isLoading = _ref[2];

      if (isSeeking || isBuffering || isLoading) {
        _this2._displaySpinnerTimeout = setTimeout(function () {
          _this2.setState({
            displaySpinner: true
          });
        }, SPINNER_TIMEOUT);
      } else {
        if (_this2._displaySpinnerTimeout) {
          clearTimeout(_this2._displaySpinnerTimeout);
          _this2._displaySpinnerTimeout = 0;
        }

        if (_this2.state.displaySpinner) {
          _this2.setState({
            displaySpinner: false
          });
        }
      }
    });

    this.setState({ player: player });
    // for DEV mode
    window.playerModule = player;
  };

  // will never happen, but still


  Player.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this._$destroySubject) {
      this._$destroySubject.next();
      this._$destroySubject.complete();
    }
    if (this._displaySpinnerTimeout) {
      clearTimeout(this._displaySpinnerTimeout);
    }
  };

  Player.prototype.onVideoClick = function onVideoClick() {
    var _state$player$get = this.state.player.get(),
        isPaused = _state$player$get.isPaused,
        hasLoadedContent = _state$player$get.hasLoadedContent,
        hasEnded = _state$player$get.hasEnded;

    if (!hasLoadedContent || hasEnded) {
      return;
    }

    this.state.player.dispatch(isPaused ? "PLAY" : "PAUSE");
  };

  Player.prototype.render = function render() {
    var _this3 = this;

    var _state = this.state,
        player = _state.player,
        displaySpinner = _state.displaySpinner;

    var loadVideo = function loadVideo(video) {
      return _this3.state.player.dispatch("LOAD", video);
    };
    var stopVideo = function stopVideo() {
      return _this3.state.player.dispatch("STOP");
    };

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "section",
      { className: "video-player-section" },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "video-player-content" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__ContentList_jsx__["a" /* default */], {
          loadVideo: loadVideo,
          stopVideo: stopVideo
        }),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "video-player-wrapper" },
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            "div",
            {
              className: "video-wrapper",
              onClick: function onClick() {
                return _this3.onVideoClick();
              }
            },
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__ErrorDisplayer_jsx__["a" /* default */], { player: player }),
            displaySpinner ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("img", {
              src: "./assets/spinner.gif", r: true,
              className: "video-player-spinner"
            }) : null,
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
              className: "text-track",
              ref: function ref(element) {
                return _this3.textTrackElement = element;
              }
            }),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("video", {
              ref: function ref(element) {
                return _this3.videoElement = element;
              }
            })
          ),
          player ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__ControlBar_jsx__["a" /* default */], { player: player }) : null
        ),
        player ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_7__PlayerKnobs_jsx__["a" /* default */], { player: player }) : null,
        player ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_9__charts_index_jsx__["a" /* default */], { player: player }) : null,
        player ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__LogDisplayer_jsx__["a" /* default */], { player: player }) : null
      )
    );
  };

  return Player;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (Player);

/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__knobs_VideoBitrate_jsx__ = __webpack_require__(400);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__knobs_AudioBitrate_jsx__ = __webpack_require__(397);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__knobs_AudioTrack_jsx__ = __webpack_require__(398);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__knobs_Subtitles_jsx__ = __webpack_require__(399);







var PlayerKnobs = function PlayerKnobs(_ref) {
  var player = _ref.player,
      hasLoadedContent = _ref.hasLoadedContent,
      hasEnded = _ref.hasEnded;


  if (!hasLoadedContent || hasEnded) {
    return null;
  }

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    { className: "player-knobs" },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__knobs_AudioBitrate_jsx__["a" /* default */], { player: player }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__knobs_VideoBitrate_jsx__["a" /* default */], { player: player }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__knobs_AudioTrack_jsx__["a" /* default */], { player: player }),
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__knobs_Subtitles_jsx__["a" /* default */], { player: player })
  );
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    isStopped: "isStopped",
    hasLoadedContent: "hasLoadedContent",
    hasEnded: "hasEnded"
  }
})(PlayerKnobs));

/***/ }),
/* 391 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_ProgressBar_jsx__ = __webpack_require__(380);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_ImageTip_jsx__ = __webpack_require__(376);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_withModulesState_jsx__ = __webpack_require__(27);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Progressbar = function (_React$Component) {
  _inherits(Progressbar, _React$Component);

  function Progressbar() {
    _classCallCheck(this, Progressbar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      imageTipVisible: false,
      imageTipPosition: 0,
      image: null
    };
    return _this;
  }

  Progressbar.prototype.showImageTip = function showImageTip(ts, clientX) {
    var images = this.props.images;

    if (!images || !images.length) {
      return;
    }
    var timestampToMs = ts * 1000;
    var imageIndex = images.findIndex(function (image) {
      return image && image.ts > timestampToMs;
    });
    var image = imageIndex === -1 ? images[images.length - 1] : images[imageIndex - 1];
    if (!image) {
      return;
    }
    this.setState({
      imageTipVisible: true,
      imageTipPosition: clientX,
      image: image.data
    });
  };

  Progressbar.prototype.hideImageTip = function hideImageTip() {
    this.setState({
      imageTipVisible: false,
      imageTipPosition: 0,
      image: null
    });
  };

  Progressbar.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        imageTipVisible = _state.imageTipVisible,
        imageTipPosition = _state.imageTipPosition,
        image = _state.image;
    var _props = this.props,
        currentTime = _props.currentTime,
        minimumPosition = _props.minimumPosition,
        maximumPosition = _props.maximumPosition,
        bufferGap = _props.bufferGap,
        player = _props.player;

    var seek = function seek(position) {
      return player.dispatch("SEEK", position);
    };
    var onMouseOut = function onMouseOut() {
      return _this2.hideImageTip();
    };
    var onMouseMove = function onMouseMove(position, event) {
      _this2.showImageTip(position, event.clientX);
    };

    var imageTipOffset = this.wrapperElement ? this.wrapperElement.getBoundingClientRect().left : 0;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      {
        className: "progress-bar-parent",
        ref: function ref(el) {
          return _this2.wrapperElement = el;
        }
      },
      imageTipVisible ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_ImageTip_jsx__["a" /* default */], {
        className: "progress-tip",
        image: image,
        xPosition: imageTipPosition - imageTipOffset
      }) : null,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_ProgressBar_jsx__["a" /* default */], {
        seek: seek,
        onMouseOut: onMouseOut,
        onMouseMove: onMouseMove,
        position: currentTime,
        minimumPosition: minimumPosition,
        maximumPosition: maximumPosition,
        bufferGap: bufferGap
      })
    );
  };

  return Progressbar;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    bufferGap: "bufferGap",
    currentTime: "currentTime",
    images: "images",
    minimumPosition: "minimumPosition",
    maximumPosition: "maximumPosition"
  }
})(Progressbar));

/***/ }),
/* 392 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);



/**
 * Horizontal (left-to-right) volume indication component which:
 *
 *   - represents the current volume relatively to the max and min.
 *
 *   - triggers a setVolume function with the clicked volume percentage on click
 * @param {Object} props
 * @returns {Object}
 */
var VolumeBar = function VolumeBar(_ref) {
  var player = _ref.player,
      volume = _ref.volume;

  var element = void 0;

  var getMouseVolume = function getMouseVolume(event) {
    var rect = element.getBoundingClientRect();
    var point0 = rect.left;
    var clickPosPx = Math.max(event.clientX - point0, 0);
    var endPointPx = Math.max(rect.right - point0, 0);
    if (!endPointPx) {
      return 0;
    }
    return Math.min(clickPosPx / endPointPx, 1);
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    "div",
    {
      className: "volume-bar-wrapper",
      ref: function ref(el) {
        return element = el;
      },
      onClick: function onClick(evt) {
        return player.dispatch("SET_VOLUME", getMouseVolume(evt));
      }
    },
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
      className: "volume-bar-current",
      style: { "width": volume * 100 + "%" }
    })
  );
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    volume: "volume"
  }
})(VolumeBar));

/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__ = __webpack_require__(27);




/**
 * Simple volume button.
 * Triggers the right callback on click.
 *
 * Needs 2 props:
 *   - {Object} player: the player module.
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */
var VolumeButton = function VolumeButton(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === undefined ? "" : _ref$className,
      player = _ref.player,
      volume = _ref.volume;

  var volumeLevelClass = void 0;
  var charCode = void 0;
  if (volume === 0) {
    volumeLevelClass = "muted";
    charCode = 0xf026;
  } else if (volume <= 0.5) {
    volumeLevelClass = "low";
    charCode = 0xf027;
  } else {
    volumeLevelClass = "high";
    charCode = 0xf028;
  }
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Button_jsx__["a" /* default */], {
    className: "volume-button " + className + " " + volumeLevelClass,
    onClick: volume === 0 ? function () {
      return player.dispatch("UNMUTE");
    } : function () {
      return player.dispatch("MUTE");
    },
    value: String.fromCharCode(charCode)
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    volume: "volume"
  }
})(VolumeButton));

/***/ }),
/* 394 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_chart_js__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_chart_js__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var repeat = function repeat(str, time) {
  var ret = [];
  for (var i = time; i > 0; i--) {
    ret.push(str);
  }
  return ret;
};

var filterData = function filterData(data, size) {
  return size < data.length ? data.slice(data.length - size - 1, data.length) : data;
};

var Bandwidth = function (_React$Component) {
  _inherits(Bandwidth, _React$Component);

  function Bandwidth() {
    _classCallCheck(this, Bandwidth);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      size: 30
    };
    return _this;
  }

  Bandwidth.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var element = this.element;

    if (!element) {
      return;
    }

    var module = this.props.module;
    var size = this.state.size;


    var initialData = filterData(module.get("data"), size);

    var canvas = element;
    var ctx = canvas.getContext("2d");

    var startingData = {
      labels: repeat("", initialData.length),
      datasets: [{
        label: "Last calculated Bandwidth, in kBps" + " (might be false when cache is involved)",
        backgroundColor: "rgba(100, 200, 200, 0.2)",
        fill: true,
        data: initialData.map(function (_ref) {
          var value = _ref.value;
          return value;
        }),
        steppedLine: true
      }]
    };

    this.chart = new __WEBPACK_IMPORTED_MODULE_1_chart_js___default.a(ctx, {
      type: "line",
      data: startingData,
      options: {
        // deactive animation as it f**cks all up when updating
        // TODO change chart lib or do it manually
        animation: false,
        elements: {
          point: {
            radius: 0
          }
        }
      }
    });

    this.subscription = module.$get("data").subscribe(function (data) {
      return _this2.onNewData(data);
    });
  };

  Bandwidth.prototype.onNewData = function onNewData(data) {
    var size = this.state.size;
    var _chart$data$datasets = this.chart.data.datasets,
        oldDataset = _chart$data$datasets[0];

    var newData = filterData(data, size).map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });

    this.chart.data.datasets[0] = Object.assign({}, oldDataset, {
      data: newData
    });
    this.chart.data.labels = repeat("", newData.length);
    this.chart.update();
  };

  Bandwidth.prototype.componentWillUnmount = function componentWillUnmount() {
    // debugger;
    if (this.subscription) {
      this.subscription.unsubscribe;
    }
    // this.chart.destroy();
  };

  Bandwidth.prototype.render = function render() {
    var _this3 = this;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      null,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("canvas", {
        className: "bitrate-charts",
        height: "80",
        ref: function ref(el) {
          return _this3.element = el;
        }
      })
    );
  };

  return Bandwidth;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (Bandwidth);

/***/ }),
/* 395 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_chart_js__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_chart_js__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var repeat = function repeat(str, time) {
  var ret = [];
  for (var i = time; i > 0; i--) {
    ret.push(str);
  }
  return ret;
};

var filterData = function filterData(data, duration) {
  var length = data.length;

  var until = Date.now() - duration;
  for (var i = length; i > 0; i--) {
    if (data[i - 1].date < until) {
      return data.slice(i, length);
    }
  }
  return data;
};

var BufferSizeChart = function (_React$Component) {
  _inherits(BufferSizeChart, _React$Component);

  function BufferSizeChart() {
    _classCallCheck(this, BufferSizeChart);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      duration: 60000
    };
    return _this;
  }

  BufferSizeChart.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var element = this.element;

    if (!element) {
      return;
    }

    var module = this.props.module;
    var duration = this.state.duration;


    var initialData = filterData(module.get().data || [], duration);

    var canvas = element;
    var ctx = canvas.getContext("2d");

    var startingData = {
      labels: repeat("", initialData.length),
      datasets: [{
        label: "Buffer Size, in s",
        backgroundColor: "rgba(200, 100, 200, 0.2)",
        fill: true,
        data: initialData.map(function (_ref) {
          var value = _ref.value;
          return value;
        })
      }]
    };

    this.chart = new __WEBPACK_IMPORTED_MODULE_1_chart_js___default.a(ctx, {
      type: "line",
      data: startingData,
      options: {
        // deactive animation as it f**cks all up when updating
        // TODO change chart lib or do it manually
        animation: false,
        elements: {
          point: {
            radius: 0
          }
        },
        scales: {
          xAxes: [{
            gridLines: {
              display: false
            }
          }]
        }
      }
    });

    this.subscription = module.$get("data").subscribe(function (data) {
      return _this2.onNewData(data);
    });
  };

  BufferSizeChart.prototype.onNewData = function onNewData(data) {
    var duration = this.state.duration;
    var _chart$data$datasets = this.chart.data.datasets,
        oldDataset = _chart$data$datasets[0];

    var newData = filterData(data, duration).map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });

    this.chart.data.datasets[0] = Object.assign({}, oldDataset, {
      data: newData
    });
    this.chart.data.labels = repeat("", newData.length);
    this.chart.update();
  };

  BufferSizeChart.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.subscription) {
      this.subscription.unsubscribe;
    }
  };

  BufferSizeChart.prototype.render = function render() {
    var _this3 = this;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      null,
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("canvas", {
        className: "bitrate-charts",
        height: "80",
        ref: function ref(el) {
          return _this3.element = el;
        }
      })
    );
  };

  return BufferSizeChart;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (BufferSizeChart);

/***/ }),
/* 396 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_vespertine_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_ChartData_js__ = __webpack_require__(403);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__BufferSize_jsx__ = __webpack_require__(395);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Bandwidth_jsx__ = __webpack_require__(394);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var BUFFER_GAP_REFRESH_TIME = 500;
var MAX_BUFFER_SIZE_LENGTH = 2000;
var MAX_BANDWIDTH_LENGTH = 200;

var ChartsManager = function (_React$Component) {
  _inherits(ChartsManager, _React$Component);

  function ChartsManager() {
    _classCallCheck(this, ChartsManager);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args)));

    _this.state = {
      displayBufferSizeChart: false,
      displayBandwidthChart: false
    };
    var player = _this.props.player;


    _this.bufferSizeChart = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_vespertine_js__["a" /* createModule */])(__WEBPACK_IMPORTED_MODULE_2__modules_ChartData_js__["a" /* default */], {
      maxSize: MAX_BUFFER_SIZE_LENGTH
    });

    _this.bandwidthChart = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_vespertine_js__["a" /* createModule */])(__WEBPACK_IMPORTED_MODULE_2__modules_ChartData_js__["a" /* default */], {
      maxSize: MAX_BANDWIDTH_LENGTH
    });

    _this.bandwidthSubscription = player.$get("bandwidth").subscribe(function (bandwidth) {
      _this.bandwidthChart.dispatch("ADD_DATA", bandwidth / 0.008);
    });

    _this.bufferGapInterval = setInterval(function () {
      _this.bufferSizeChart.dispatch("ADD_DATA", player.get("bufferGap"));
    }, BUFFER_GAP_REFRESH_TIME);
    return _this;
  }

  ChartsManager.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.bufferGapInterval) {
      clearInterval(this.bufferGapInterval);
    }
    this.bufferSizeChart.destroy();
    this.bandwidthSubscription.unsubscribe();
  };

  ChartsManager.prototype.render = function render() {
    var _this2 = this;

    var _state = this.state,
        displayBandwidthChart = _state.displayBandwidthChart,
        displayBufferSizeChart = _state.displayBufferSizeChart;

    // const onBandwidthCheckBoxChange = (e) => {
    //   const target = e.target;
    //   const value = target.type === "checkbox" ?
    //     target.checked : target.value;

    //   this.setState({
    //     displayBandwidthChart: value,
    //   });
    // };

    var onBufferSizeCheckBoxChange = function onBufferSizeCheckBoxChange(e) {
      var target = e.target;
      var value = target.type === "checkbox" ? target.checked : target.value;

      _this2.setState({
        displayBufferSizeChart: value
      });
    };
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      "div",
      { className: "player-charts" },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        "div",
        { className: "chart-checkboxes" },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
          "div",
          { className: "chart-checkbox" },
          "Buffer size chart",
          __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("input", {
            name: "displayBufferSizeChart",
            type: "checkbox",
            checked: this.state.displayBufferSizeChart,
            onChange: onBufferSizeCheckBoxChange })
        )
      ),
      displayBufferSizeChart ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__BufferSize_jsx__["a" /* default */], {
        module: this.bufferSizeChart
      }) : null,
      displayBandwidthChart ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Bandwidth_jsx__["a" /* default */], {
        module: this.bandwidthChart
      }) : null
    );
  };

  return ChartsManager;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

/* harmony default export */ __webpack_exports__["a"] = (ChartsManager);

/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Knob_jsx__ = __webpack_require__(86);




var AudioBitrateKnobBase = function AudioBitrateKnobBase(_ref) {
  var player = _ref.player,
      audioBitrateAuto = _ref.audioBitrateAuto,
      audioBitrate = _ref.audioBitrate,
      _ref$availableAudioBi = _ref.availableAudioBitrates,
      availableAudioBitrates = _ref$availableAudioBi === undefined ? [] : _ref$availableAudioBi;

  var options = [];
  var currentAudioBitrateIndex = void 0;

  if (availableAudioBitrates.length > 1) {
    var autoValue = audioBitrateAuto ? "auto (" + audioBitrate + ")" : "auto";
    options = [autoValue].concat(availableAudioBitrates);

    currentAudioBitrateIndex = audioBitrateAuto ? 0 : availableAudioBitrates.indexOf(audioBitrate) + 1 || 0;
  } else {
    options = availableAudioBitrates;
    currentAudioBitrateIndex = 0;
  }

  var onAudioBitrateChange = function onAudioBitrateChange(evt) {
    var index = +evt.target.value;
    if (index > 0) {
      var bitrate = availableAudioBitrates[index - 1];
      player.dispatch("SET_AUDIO_BITRATE", bitrate);
    } else {
      player.dispatch("SET_AUDIO_BITRATE");
    }
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_Knob_jsx__["a" /* default */], {
    name: "Audio Bitrate",
    disabled: availableAudioBitrates.length < 2,
    onChange: onAudioBitrateChange,
    options: options,
    selected: currentAudioBitrateIndex
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    audioBitrateAuto: "audioBitrateAuto",
    audioBitrate: "audioBitrate",
    availableAudioBitrates: "availableAudioBitrates"
  }
})(AudioBitrateKnobBase));

/***/ }),
/* 398 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_language_js__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Knob_jsx__ = __webpack_require__(86);





var AUDIO_DESCRIPTION_ICON = "(AD)"; // String.fromCharCode(0xf29e);

var findLanguageIndex = function findLanguageIndex(language, languages) {
  return languages.findIndex(function (ln) {
    return ln.id === language.id;
  });
};

var AudioTrackKnobBase = function AudioTrackKnobBase(_ref) {
  var player = _ref.player,
      currentLanguage = _ref.currentLanguage,
      _ref$availableLanguag = _ref.availableLanguages,
      availableLanguages = _ref$availableLanguag === undefined ? [] : _ref$availableLanguag;


  var options = availableLanguages.map(function (language) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_language_js__["a" /* default */])(language.normalized) + (language.audioDescription ? " " + AUDIO_DESCRIPTION_ICON : "");
  });

  var currentLanguageIndex = currentLanguage ? Math.max(findLanguageIndex(currentLanguage, availableLanguages), 0) : 0;

  var onLanguageChange = function onLanguageChange(evt) {
    var index = +evt.target.value;
    var track = availableLanguages[index];
    player.dispatch("SET_AUDIO_TRACK", track);
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__components_Knob_jsx__["a" /* default */], {
    name: "Audio Language",
    disabled: availableLanguages.length < 2,
    onChange: onLanguageChange,
    options: options,
    selected: currentLanguageIndex
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    language: "currentLanguage",
    availableLanguages: "availableLanguages"
  }
})(AudioTrackKnobBase));

/***/ }),
/* 399 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_language_js__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Knob_jsx__ = __webpack_require__(86);





var CLOSED_CAPTION_ICON = "(CC)"; // String.fromCharCode(0xf2a4);

var findLanguageIndex = function findLanguageIndex(currentSubtitle, languages) {
  return languages.findIndex(function (ln) {
    return ln.id === currentSubtitle.id;
  });
};

var SubtitlesKnobBase = function SubtitlesKnobBase(_ref) {
  var player = _ref.player,
      currentSubtitle = _ref.currentSubtitle,
      _ref$availableSubtitl = _ref.availableSubtitles,
      availableSubtitles = _ref$availableSubtitl === undefined ? [] : _ref$availableSubtitl;

  var options = ["no subtitles"].concat(availableSubtitles.map(function (subtitle) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_language_js__["a" /* default */])(subtitle.normalized) + (subtitle.closedCaption ? " " + CLOSED_CAPTION_ICON : "");
  }));

  var currentLanguageIndex = currentSubtitle ? findLanguageIndex(currentSubtitle, availableSubtitles) + 1 : 0;

  var onLanguageChange = function onLanguageChange(evt) {
    var index = +evt.target.value;
    if (index > 0) {
      var sub = availableSubtitles[index - 1];
      player.dispatch("SET_SUBTITLES_TRACK", sub);
    } else {
      player.dispatch("DISABLE_SUBTITLES_TRACK");
    }
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__components_Knob_jsx__["a" /* default */], {
    name: "Subtitles",
    disabled: !availableSubtitles.length,
    onChange: onLanguageChange,
    options: options,
    selected: currentLanguageIndex
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    subtitle: "currentSubtitle",
    availableSubtitles: "availableSubtitles"
  }
})(SubtitlesKnobBase));

/***/ }),
/* 400 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Knob_jsx__ = __webpack_require__(86);




var VideoBitrateKnobBase = function VideoBitrateKnobBase(_ref) {
  var player = _ref.player,
      videoBitrateAuto = _ref.videoBitrateAuto,
      videoBitrate = _ref.videoBitrate,
      _ref$availableVideoBi = _ref.availableVideoBitrates,
      availableVideoBitrates = _ref$availableVideoBi === undefined ? [] : _ref$availableVideoBi;

  var options = [];
  var currentVideoBitrateIndex = void 0;

  if (availableVideoBitrates.length > 1) {
    var autoValue = videoBitrateAuto ? "auto (" + videoBitrate + ")" : "auto";
    options = [autoValue].concat(availableVideoBitrates);

    currentVideoBitrateIndex = videoBitrateAuto ? 0 : availableVideoBitrates.indexOf(videoBitrate) + 1 || 0;
  } else {
    options = availableVideoBitrates;
    currentVideoBitrateIndex = 0;
  }

  var onVideoBitrateChange = function onVideoBitrateChange(evt) {
    var index = +evt.target.value;
    if (index > 0) {
      var bitrate = availableVideoBitrates[index - 1];
      player.dispatch("SET_VIDEO_BITRATE", bitrate);
    } else {
      player.dispatch("SET_VIDEO_BITRATE");
    }
  };

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_Knob_jsx__["a" /* default */], {
    name: "Video Bitrate",
    disabled: availableVideoBitrates.length < 2,
    onChange: onVideoBitrateChange,
    options: options,
    selected: currentVideoBitrateIndex
  });
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_withModulesState_jsx__["a" /* default */])({
  player: {
    videoBitrateAuto: "videoBitrateAuto",
    videoBitrate: "videoBitrate",
    availableVideoBitrates: "availableVideoBitrates"
  }
})(VideoBitrateKnobBase));

/***/ }),
/* 401 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_polyfill__ = __webpack_require__(373);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_polyfill___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_polyfill__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_dom__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react_dom__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__controllers_Main_jsx__ = __webpack_require__(372);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_combineLatest__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_combineLatest___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_combineLatest__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_interval__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_interval___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_interval__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_catch__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_add_operator_concat__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_operator_distinctUntilChanged__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_operator_distinctUntilChanged___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_add_operator_distinctUntilChanged__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_operator_do__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_operator_do___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_add_operator_do__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_filter__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_add_operator_filter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_map__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_mergeMap__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_mergeMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_skip__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_skip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_skip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_startWith__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_startWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_startWith__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_switchMap__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_switchMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_switchMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_take__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_take___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_take__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_takeUntil__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_takeUntil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_takeUntil__);




















__WEBPACK_IMPORTED_MODULE_2_react_dom___default.a.render(__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__controllers_Main_jsx__["a" /* default */], null), document.getElementById("player-container"));

/***/ }),
/* 402 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export toSeconds */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return toMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toHours; });
var toSeconds = function toSeconds(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);
  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00";
  }

  return String(toInt).padStart(2, "0");
};

var toMinutes = function toMinutes(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);
  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00:00";
  }

  if (toInt < 60) {
    var str = String(toInt);
    return "00:" + str.padStart(2, "0");
  }

  var numberOfMinutes = parseInt(toInt / 60);
  var numberOfSecondsRemaining = toInt % 60;
  return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
};

var toHours = function toHours(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);
  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00:00";
  }

  if (toInt < 60) {
    var str = String(toInt);
    return "00:" + str.padStart(2, "0");
  }

  var numberOfMinutes = parseInt(toInt / 60);
  var numberOfSecondsRemaining = toInt % 60;
  if (numberOfMinutes < 60) {
    return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
  }

  var numberOfHours = parseInt(numberOfMinutes / 60);
  var numberOfMinutesRemaining = numberOfHours % 60;
  return String(numberOfHours).padStart(2, "0") + ":" + String(numberOfMinutesRemaining).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
};



/***/ }),
/* 403 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (_ref, _ref2) {
  var state = _ref.state;
  var maxSize = _ref2.maxSize;

  var data = [];

  state.set({ data: data.slice() });
  return {
    ADD_DATA: function ADD_DATA(val) {
      if (data.length >= maxSize) {
        data.splice(0, data.length + 1 - maxSize);
      }
      data.push({
        date: Date.now(),
        value: val
      });

      state.set({ data: data.slice() });
    },

    REMOVE_DATA: function REMOVE_DATA() {
      var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      data.splice(0, number);
      state.set({ data: data.slice() });
    }
  };
});

/***/ }),
/* 404 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linkPlayerEventsToState; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);


var POSITION_UPDATES_INTERVAL = 100;

/**
 * Add event listeners to the RxPlayer to update the module's state at the right
 * time.
 * Unsubscribe when $destroy emit.
 * @param {RxPlayer} player
 * @param {Subject} state
 * @param {Subject} $destroy
 */
var linkPlayerEventsToState = function linkPlayerEventsToState(player, state, $destroy) {
  var fromPlayerEvent = function fromPlayerEvent(event) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
      var func = function func(payload) {
        return obs.next(payload);
      };
      player.addEventListener(event, func);

      return function () {
        player.removeEventListener(event, func);
      };
    });
  };

  var linkPlayerEventToState = function linkPlayerEventToState(event, stateItem) {
    return fromPlayerEvent(event).takeUntil($destroy).subscribe(function (arg) {
      var _state$set;

      return state.set((_state$set = {}, _state$set[stateItem] = arg, _state$set));
    });
  };

  linkPlayerEventToState("textTrackChange", "subtitle");
  linkPlayerEventToState("audioTrackChange", "language");
  linkPlayerEventToState("videoBitrateChange", "videoBitrate");
  linkPlayerEventToState("audioBitrateChange", "audioBitrate");
  linkPlayerEventToState("error", "error");
  linkPlayerEventToState("fullscreenChange", "isFullscreen");
  linkPlayerEventToState("volumeChange", "volume");

  fromPlayerEvent("imageTrackUpdate").distinctUntilChanged().takeUntil($destroy).map(function (_ref) {
    var data = _ref.data;
    return data;
  }).subscribe(function (images) {
    return state.set({ images: images });
  });

  // use an interval for current position
  // TODO Only active for content playback
  __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].interval(POSITION_UPDATES_INTERVAL).map(function () {
    return {
      currentTime: player.getPosition(),
      bufferGap: player.getVideoLoadedTime() - player.getVideoPlayedTime(),
      duration: player.getVideoDuration(),
      minimumPosition: player.getMinimumPosition(),
      maximumPosition: player.getMaximumPosition()
    };
  }).takeUntil($destroy).subscribe(function (arg) {
    state.set(arg);
  });

  fromPlayerEvent("playerStateChange").distinctUntilChanged().takeUntil($destroy).subscribe(function (arg) {
    var stateUpdates = {
      hasEnded: arg === "ENDED",
      hasLoadedContent: !["STOPPED", "LOADING"].includes(arg),
      isBuffering: arg === "BUFFERING",
      isLoading: arg === "LOADING",
      isSeeking: arg === "SEEKING",
      isStopped: arg === "STOPPED",
      speed: arg === "PLAYING" ? player.getPlaybackRate() : 0
    };

    if (arg === "PAUSED") {
      stateUpdates.isPaused = true;
    } else if (arg === "PLAYING") {
      stateUpdates.isPaused = false;
    } else if (arg === "LOADED") {
      stateUpdates.availableAudioBitrates = player.getAvailableAudioBitrates();
      stateUpdates.availableVideoBitrates = player.getAvailableVideoBitrates();
      stateUpdates.availableLanguages = player.getAvailableAudioTracks();
      stateUpdates.availableSubtitles = player.getAvailableTextTracks();
    } else if (arg === "STOPPED" || arg === "ENDED") {
      stateUpdates.audioBitrate = undefined;
      stateUpdates.videoBitrate = undefined;
      stateUpdates.availableAudioBitrates = [];
      stateUpdates.availableVideoBitrates = [];
      stateUpdates.availableLanguages = [];
      stateUpdates.availableSubtitles = [];
      stateUpdates.images = [];
      stateUpdates.currentTime = undefined;
      stateUpdates.bufferGap = undefined;
      stateUpdates.duration = undefined;
      stateUpdates.minimumPosition = undefined;
      stateUpdates.maximumPosition = undefined;
    }

    if (arg !== "STOPPED") {
      // error is never cleaned up
      stateUpdates.error = null;
    }

    state.set(stateUpdates);
  });

  fromPlayerEvent("manifestChange").map(function () {
    return player.isLive();
  }).distinctUntilChanged().takeUntil($destroy).subscribe(function (isLive) {
    state.set({ isLive: isLive });
  });
};



/***/ }),
/* 405 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src__ = __webpack_require__(798);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events_js__ = __webpack_require__(404);
/**
 * # Player Module
 *
 * Instanciate a new RxPlayer, link its state and this module's state, provide
 * actions to allow easy interactions with the player to the rest of the
 * application.
 */




var PLAYER = function PLAYER(_ref, _ref2) {
  var $destroy = _ref.$destroy,
      state = _ref.state;
  var videoElement = _ref2.videoElement,
      textTrackElement = _ref2.textTrackElement;

  var player = new __WEBPACK_IMPORTED_MODULE_0__src__["a" /* default */]({
    limitVideoWidth: false,
    throttleWhenHidden: true,
    videoElement: videoElement
  });

  // facilitate DEV mode
  window.player = window.rxPlayer = player;

  // initial state. Written here to easily showcase it exhaustively
  state.set({
    audioBitrateAuto: true,
    audioBitrate: undefined,
    availableAudioBitrates: [],
    availableLanguages: [],
    availableVideoBitrates: [],
    availableSubtitles: [],
    bufferGap: undefined,
    currentTime: undefined,
    duration: undefined,
    error: null,
    hasEnded: false,
    hasLoadedContent: false,
    images: [],
    isBuffering: false,
    isFullscreen: player.isFullscreen(),
    isLive: false,
    isLoading: false,
    isPaused: false,
    isSeeking: false,
    isStopped: true,
    language: undefined,
    loadedVideo: null,
    minimumPosition: undefined,
    maximumPosition: undefined,
    speed: 0,
    subtitle: undefined,
    videoBitrateAuto: true,
    videoBitrate: undefined,
    volume: player.getVolume()
  });

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* linkPlayerEventsToState */])(player, state, $destroy);

  // dispose of the RxPlayer when destroyed
  $destroy.subscribe(function () {
    return player.dispose();
  });

  return {
    SET_VOLUME: function SET_VOLUME(volume) {
      player.setVolume(volume);
    },

    SET_POSITION: function SET_POSITION(position) {
      player.setPosition(position);
    },

    LOAD: function LOAD(arg) {
      if (arg.textTrackMode === "html") {
        player.loadVideo(Object.assign({ textTrackElement: textTrackElement }, arg));
      } else {
        player.loadVideo(arg);
      }
      state.set({ loadedVideo: arg });
    },

    PLAY: function PLAY() {
      player.play();

      var _state$get = state.get(),
          isStopped = _state$get.isStopped,
          hasEnded = _state$get.hasEnded;

      if (!isStopped && !hasEnded) {
        state.set({ isPaused: false });
      }
    },

    PAUSE: function PAUSE() {
      player.pause();

      var _state$get2 = state.get(),
          isStopped = _state$get2.isStopped,
          hasEnded = _state$get2.hasEnded;

      if (!isStopped && !hasEnded) {
        state.set({ isPaused: true });
      }
    },

    STOP: function STOP() {
      player.stop();
    },

    SEEK: function SEEK(position) {
      player.seekTo({ position: position });
    },

    MUTE: function MUTE() {
      player.mute();
    },

    UNMUTE: function UNMUTE() {
      player.unMute();
    },

    SET_FULL_SCREEN: function SET_FULL_SCREEN() {
      player.setFullscreen(true);
    },

    EXIT_FULL_SCREEN: function EXIT_FULL_SCREEN() {
      player.setFullscreen(false);
    },

    SET_AUDIO_BITRATE: function SET_AUDIO_BITRATE(bitrate) {
      player.setAudioBitrate(bitrate || -1);
      state.set({
        audioBitrateAuto: !bitrate
      });
    },

    SET_VIDEO_BITRATE: function SET_VIDEO_BITRATE(bitrate) {
      player.setVideoBitrate(bitrate || -1);
      state.set({
        videoBitrateAuto: !bitrate
      });
    },

    SET_AUDIO_TRACK: function SET_AUDIO_TRACK(track) {
      player.setAudioTrack(track.id);
    },

    SET_SUBTITLES_TRACK: function SET_SUBTITLES_TRACK(track) {
      player.setTextTrack(track.id);
    },

    DISABLE_SUBTITLES_TRACK: function DISABLE_SUBTITLES_TRACK() {
      player.disableTextTrack();
    }
  };
};

/* harmony default export */ __webpack_exports__["a"] = (PLAYER);

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = ( false ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (_typeof(global.process) === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
(typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(146), __webpack_require__(353)(module)))

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.Bar = function (context, config) {
		config.type = 'bar';

		return new Chart(context, config);
	};
};

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.Bubble = function (context, config) {
		config.type = 'bubble';
		return new Chart(context, config);
	};
};

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.Doughnut = function (context, config) {
		config.type = 'doughnut';

		return new Chart(context, config);
	};
};

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.Line = function (context, config) {
		config.type = 'line';

		return new Chart(context, config);
	};
};

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.PolarArea = function (context, config) {
		config.type = 'polarArea';

		return new Chart(context, config);
	};
};

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	Chart.Radar = function (context, config) {
		config.type = 'radar';

		return new Chart(context, config);
	};
};

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {
	Chart.Scatter = function (context, config) {
		config.type = 'scatter';
		return new Chart(context, config);
	};
};

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('bar', {
	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',

			// Specific to Bar Controller
			categoryPercentage: 0.8,
			barPercentage: 0.9,

			// offset settings
			offset: true,

			// grid line settings
			gridLines: {
				offsetGridLines: true
			}
		}],

		yAxes: [{
			type: 'linear'
		}]
	}
});

defaults._set('horizontalBar', {
	hover: {
		mode: 'index',
		axis: 'y'
	},

	scales: {
		xAxes: [{
			type: 'linear',
			position: 'bottom'
		}],

		yAxes: [{
			position: 'left',
			type: 'category',

			// Specific to Horizontal Bar Controller
			categoryPercentage: 0.8,
			barPercentage: 0.9,

			// offset settings
			offset: true,

			// grid line settings
			gridLines: {
				offsetGridLines: true
			}
		}]
	},

	elements: {
		rectangle: {
			borderSkipped: 'left'
		}
	},

	tooltips: {
		callbacks: {
			title: function title(item, data) {
				// Pick first xLabel for now
				var title = '';

				if (item.length > 0) {
					if (item[0].yLabel) {
						title = item[0].yLabel;
					} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
						title = data.labels[item[0].index];
					}
				}

				return title;
			},

			label: function label(item, data) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				return datasetLabel + ': ' + item.xLabel;
			}
		},
		mode: 'index',
		axis: 'y'
	}
});

module.exports = function (Chart) {

	Chart.controllers.bar = Chart.DatasetController.extend({

		dataElementType: elements.Rectangle,

		initialize: function initialize() {
			var me = this;
			var meta;

			Chart.DatasetController.prototype.initialize.apply(me, arguments);

			meta = me.getMeta();
			meta.stack = me.getDataset().stack;
			meta.bar = true;
		},

		update: function update(reset) {
			var me = this;
			var rects = me.getMeta().data;
			var i, ilen;

			me._ruler = me.getRuler();

			for (i = 0, ilen = rects.length; i < ilen; ++i) {
				me.updateElement(rects[i], i, reset);
			}
		},

		updateElement: function updateElement(rectangle, index, reset) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var dataset = me.getDataset();
			var custom = rectangle.custom || {};
			var rectangleOptions = chart.options.elements.rectangle;

			rectangle._xScale = me.getScaleForId(meta.xAxisID);
			rectangle._yScale = me.getScaleForId(meta.yAxisID);
			rectangle._datasetIndex = me.index;
			rectangle._index = index;

			rectangle._model = {
				datasetLabel: dataset.label,
				label: chart.data.labels[index],
				borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
				backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
				borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
				borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
			};

			me.updateElementGeometry(rectangle, index, reset);

			rectangle.pivot();
		},

		/**
   * @private
   */
		updateElementGeometry: function updateElementGeometry(rectangle, index, reset) {
			var me = this;
			var model = rectangle._model;
			var vscale = me.getValueScale();
			var base = vscale.getBasePixel();
			var horizontal = vscale.isHorizontal();
			var ruler = me._ruler || me.getRuler();
			var vpixels = me.calculateBarValuePixels(me.index, index);
			var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

			model.horizontal = horizontal;
			model.base = reset ? base : vpixels.base;
			model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
			model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
			model.height = horizontal ? ipixels.size : undefined;
			model.width = horizontal ? undefined : ipixels.size;
		},

		/**
   * @private
   */
		getValueScaleId: function getValueScaleId() {
			return this.getMeta().yAxisID;
		},

		/**
   * @private
   */
		getIndexScaleId: function getIndexScaleId() {
			return this.getMeta().xAxisID;
		},

		/**
   * @private
   */
		getValueScale: function getValueScale() {
			return this.getScaleForId(this.getValueScaleId());
		},

		/**
   * @private
   */
		getIndexScale: function getIndexScale() {
			return this.getScaleForId(this.getIndexScaleId());
		},

		/**
   * Returns the effective number of stacks based on groups and bar visibility.
   * @private
   */
		getStackCount: function getStackCount(last) {
			var me = this;
			var chart = me.chart;
			var scale = me.getIndexScale();
			var stacked = scale.options.stacked;
			var ilen = last === undefined ? chart.data.datasets.length : last + 1;
			var stacks = [];
			var i, meta;

			for (i = 0; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
					stacks.push(meta.stack);
				}
			}

			return stacks.length;
		},

		/**
   * Returns the stack index for the given dataset based on groups and bar visibility.
   * @private
   */
		getStackIndex: function getStackIndex(datasetIndex) {
			return this.getStackCount(datasetIndex) - 1;
		},

		/**
   * @private
   */
		getRuler: function getRuler() {
			var me = this;
			var scale = me.getIndexScale();
			var stackCount = me.getStackCount();
			var datasetIndex = me.index;
			var pixels = [];
			var isHorizontal = scale.isHorizontal();
			var start = isHorizontal ? scale.left : scale.top;
			var end = start + (isHorizontal ? scale.width : scale.height);
			var i, ilen;

			for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
				pixels.push(scale.getPixelForValue(null, i, datasetIndex));
			}

			return {
				pixels: pixels,
				start: start,
				end: end,
				stackCount: stackCount,
				scale: scale
			};
		},

		/**
   * Note: pixel values are not clamped to the scale area.
   * @private
   */
		calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var scale = me.getValueScale();
			var datasets = chart.data.datasets;
			var value = scale.getRightValue(datasets[datasetIndex].data[index]);
			var stacked = scale.options.stacked;
			var stack = meta.stack;
			var start = 0;
			var i, imeta, ivalue, base, head, size;

			if (stacked || stacked === undefined && stack !== undefined) {
				for (i = 0; i < datasetIndex; ++i) {
					imeta = chart.getDatasetMeta(i);

					if (imeta.bar && imeta.stack === stack && imeta.controller.getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {

						ivalue = scale.getRightValue(datasets[i].data[index]);
						if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
							start += ivalue;
						}
					}
				}
			}

			base = scale.getPixelForValue(start);
			head = scale.getPixelForValue(start + value);
			size = (head - base) / 2;

			return {
				size: size,
				base: base,
				head: head,
				center: head + size / 2
			};
		},

		/**
   * @private
   */
		calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler) {
			var me = this;
			var options = ruler.scale.options;
			var stackIndex = me.getStackIndex(datasetIndex);
			var pixels = ruler.pixels;
			var base = pixels[index];
			var length = pixels.length;
			var start = ruler.start;
			var end = ruler.end;
			var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;

			if (length === 1) {
				leftSampleSize = base > start ? base - start : end - base;
				rightSampleSize = base < end ? end - base : base - start;
			} else {
				if (index > 0) {
					leftSampleSize = (base - pixels[index - 1]) / 2;
					if (index === length - 1) {
						rightSampleSize = leftSampleSize;
					}
				}
				if (index < length - 1) {
					rightSampleSize = (pixels[index + 1] - base) / 2;
					if (index === 0) {
						leftSampleSize = rightSampleSize;
					}
				}
			}

			leftCategorySize = leftSampleSize * options.categoryPercentage;
			rightCategorySize = rightSampleSize * options.categoryPercentage;
			fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
			size = fullBarSize * options.barPercentage;

			size = Math.min(helpers.valueOrDefault(options.barThickness, size), helpers.valueOrDefault(options.maxBarThickness, Infinity));

			base -= leftCategorySize;
			base += fullBarSize * stackIndex;
			base += (fullBarSize - size) / 2;

			return {
				size: size,
				base: base,
				head: base + size,
				center: base + size / 2
			};
		},

		draw: function draw() {
			var me = this;
			var chart = me.chart;
			var scale = me.getValueScale();
			var rects = me.getMeta().data;
			var dataset = me.getDataset();
			var ilen = rects.length;
			var i = 0;

			helpers.canvas.clipArea(chart.ctx, chart.chartArea);

			for (; i < ilen; ++i) {
				if (!isNaN(scale.getRightValue(dataset.data[i]))) {
					rects[i].draw();
				}
			}

			helpers.canvas.unclipArea(chart.ctx);
		},

		setHoverStyle: function setHoverStyle(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
			var custom = rectangle.custom || {};
			var model = rectangle._model;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function removeHoverStyle(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
			var custom = rectangle.custom || {};
			var model = rectangle._model;
			var rectangleElementOptions = this.chart.options.elements.rectangle;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
		}
	});

	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
		/**
   * @private
   */
		getValueScaleId: function getValueScaleId() {
			return this.getMeta().xAxisID;
		},

		/**
   * @private
   */
		getIndexScaleId: function getIndexScaleId() {
			return this.getMeta().yAxisID;
		}
	});
};

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('bubble', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			type: 'linear', // bubble should probably use a linear scale by default
			position: 'bottom',
			id: 'x-axis-0' // need an ID so datasets can reference the scale
		}],
		yAxes: [{
			type: 'linear',
			position: 'left',
			id: 'y-axis-0'
		}]
	},

	tooltips: {
		callbacks: {
			title: function title() {
				// Title doesn't make sense for scatter since we format the data as a point
				return '';
			},
			label: function label(item, data) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				var dataPoint = data.datasets[item.datasetIndex].data[item.index];
				return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
			}
		}
	}
});

module.exports = function (Chart) {

	Chart.controllers.bubble = Chart.DatasetController.extend({
		/**
   * @protected
   */
		dataElementType: elements.Point,

		/**
   * @protected
   */
		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data;

			// Update Points
			helpers.each(points, function (point, index) {
				me.updateElement(point, index, reset);
			});
		},

		/**
   * @protected
   */
		updateElement: function updateElement(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
			var options = me._resolveElementOptions(point, index);
			var data = me.getDataset().data[index];
			var dsIndex = me.index;

			var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? data : NaN, index, dsIndex);
			var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

			point._xScale = xScale;
			point._yScale = yScale;
			point._options = options;
			point._datasetIndex = dsIndex;
			point._index = index;
			point._model = {
				backgroundColor: options.backgroundColor,
				borderColor: options.borderColor,
				borderWidth: options.borderWidth,
				hitRadius: options.hitRadius,
				pointStyle: options.pointStyle,
				radius: reset ? 0 : options.radius,
				skip: custom.skip || isNaN(x) || isNaN(y),
				x: x,
				y: y
			};

			point.pivot();
		},

		/**
   * @protected
   */
		setHoverStyle: function setHoverStyle(point) {
			var model = point._model;
			var options = point._options;

			model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
			model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
			model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
			model.radius = options.radius + options.hoverRadius;
		},

		/**
   * @protected
   */
		removeHoverStyle: function removeHoverStyle(point) {
			var model = point._model;
			var options = point._options;

			model.backgroundColor = options.backgroundColor;
			model.borderColor = options.borderColor;
			model.borderWidth = options.borderWidth;
			model.radius = options.radius;
		},

		/**
   * @private
   */
		_resolveElementOptions: function _resolveElementOptions(point, index) {
			var me = this;
			var chart = me.chart;
			var datasets = chart.data.datasets;
			var dataset = datasets[me.index];
			var custom = point.custom || {};
			var options = chart.options.elements.point;
			var resolve = helpers.options.resolve;
			var data = dataset.data[index];
			var values = {};
			var i, ilen, key;

			// Scriptable options
			var context = {
				chart: chart,
				dataIndex: index,
				dataset: dataset,
				datasetIndex: me.index
			};

			var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle'];

			for (i = 0, ilen = keys.length; i < ilen; ++i) {
				key = keys[i];
				values[key] = resolve([custom[key], dataset[key], options[key]], context, index);
			}

			// Custom radius resolution
			values.radius = resolve([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);

			return values;
		}
	});
};

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('doughnut', {
	animation: {
		// Boolean - Whether we animate the rotation of the Doughnut
		animateRotate: true,
		// Boolean - Whether we animate scaling the Doughnut from the centre
		animateScale: false
	},
	hover: {
		mode: 'single'
	},
	legendCallback: function legendCallback(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function generateLabels(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function (label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc && arc.custom || {};
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function onClick(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				// toggle visibility of index if exists
				if (meta.data[index]) {
					meta.data[index].hidden = !meta.data[index].hidden;
				}
			}

			chart.update();
		}
	},

	// The percentage of the chart that we cut out of the middle.
	cutoutPercentage: 50,

	// The rotation of the chart, where the first data arc begins.
	rotation: Math.PI * -0.5,

	// The total circumference of the chart.
	circumference: Math.PI * 2.0,

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function title() {
				return '';
			},
			label: function label(tooltipItem, data) {
				var dataLabel = data.labels[tooltipItem.index];
				var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

				if (helpers.isArray(dataLabel)) {
					// show value on first line of multiline label
					// need to clone because we are changing the value
					dataLabel = dataLabel.slice();
					dataLabel[0] += value;
				} else {
					dataLabel += value;
				}

				return dataLabel;
			}
		}
	}
});

defaults._set('pie', helpers.clone(defaults.doughnut));
defaults._set('pie', {
	cutoutPercentage: 0
});

module.exports = function (Chart) {

	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

		dataElementType: elements.Arc,

		linkScales: helpers.noop,

		// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
		getRingIndex: function getRingIndex(datasetIndex) {
			var ringIndex = 0;

			for (var j = 0; j < datasetIndex; ++j) {
				if (this.chart.isDatasetVisible(j)) {
					++ringIndex;
				}
			}

			return ringIndex;
		},

		update: function update(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
			var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
			var minSize = Math.min(availableWidth, availableHeight);
			var offset = { x: 0, y: 0 };
			var meta = me.getMeta();
			var cutoutPercentage = opts.cutoutPercentage;
			var circumference = opts.circumference;

			// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
			if (circumference < Math.PI * 2.0) {
				var startAngle = opts.rotation % (Math.PI * 2.0);
				startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
				var endAngle = startAngle + circumference;
				var start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };
				var end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };
				var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
				var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
				var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
				var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
				var cutout = cutoutPercentage / 100.0;
				var min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };
				var max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };
				var size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };
				minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
				offset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };
			}

			chart.borderWidth = me.getMaxBorderWidth(meta.data);
			chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
			chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
			chart.offsetX = offset.x * chart.outerRadius;
			chart.offsetY = offset.y * chart.outerRadius;

			meta.total = me.calculateTotal();

			me.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);
			me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

			helpers.each(meta.data, function (arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function updateElement(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var opts = chart.options;
			var animationOpts = opts.animation;
			var centerX = (chartArea.left + chartArea.right) / 2;
			var centerY = (chartArea.top + chartArea.bottom) / 2;
			var startAngle = opts.rotation; // non reset case handled later
			var endAngle = opts.rotation; // non reset case handled later
			var dataset = me.getDataset();
			var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
			var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
			var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
			var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,

				// Desired view properties
				_model: {
					x: centerX + chart.offsetX,
					y: centerY + chart.offsetY,
					startAngle: startAngle,
					endAngle: endAngle,
					circumference: circumference,
					outerRadius: outerRadius,
					innerRadius: innerRadius,
					label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
				}
			});

			var model = arc._model;
			// Resets the visual styles
			this.removeHoverStyle(arc);

			// Set correct angles if not resetting
			if (!reset || !animationOpts.animateRotate) {
				if (index === 0) {
					model.startAngle = opts.rotation;
				} else {
					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
				}

				model.endAngle = model.startAngle + model.circumference;
			}

			arc.pivot();
		},

		removeHoverStyle: function removeHoverStyle(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		calculateTotal: function calculateTotal() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var total = 0;
			var value;

			helpers.each(meta.data, function (element, index) {
				value = dataset.data[index];
				if (!isNaN(value) && !element.hidden) {
					total += Math.abs(value);
				}
			});

			/* if (total === 0) {
   	total = NaN;
   }*/

			return total;
		},

		calculateCircumference: function calculateCircumference(value) {
			var total = this.getMeta().total;
			if (total > 0 && !isNaN(value)) {
				return Math.PI * 2.0 * (value / total);
			}
			return 0;
		},

		// gets the max border or hover width to properly scale pie charts
		getMaxBorderWidth: function getMaxBorderWidth(arcs) {
			var max = 0;
			var index = this.index;
			var length = arcs.length;
			var borderWidth;
			var hoverWidth;

			for (var i = 0; i < length; i++) {
				borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
				hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

				max = borderWidth > max ? borderWidth : max;
				max = hoverWidth > max ? hoverWidth : max;
			}
			return max;
		}
	});
};

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('line', {
	showLines: true,
	spanGaps: false,

	hover: {
		mode: 'label'
	},

	scales: {
		xAxes: [{
			type: 'category',
			id: 'x-axis-0'
		}],
		yAxes: [{
			type: 'linear',
			id: 'y-axis-0'
		}]
	}
});

module.exports = function (Chart) {

	function lineEnabled(dataset, options) {
		return helpers.valueOrDefault(dataset.showLine, options.showLines);
	}

	Chart.controllers.line = Chart.DatasetController.extend({

		datasetElementType: elements.Line,

		dataElementType: elements.Point,

		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data || [];
			var options = me.chart.options;
			var lineElementOptions = options.elements.line;
			var scale = me.getScaleForId(meta.yAxisID);
			var i, ilen, custom;
			var dataset = me.getDataset();
			var showLine = lineEnabled(dataset, options);

			// Update Line
			if (showLine) {
				custom = line.custom || {};

				// Compatibility: If the properties are defined with only the old name, use those values
				if (dataset.tension !== undefined && dataset.lineTension === undefined) {
					dataset.lineTension = dataset.tension;
				}

				// Utility
				line._scale = scale;
				line._datasetIndex = me.index;
				// Data
				line._children = points;
				// Model
				line._model = {
					// Appearance
					// The default behavior of lines is to break at null values, according
					// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
					// This option gives lines the ability to span gaps
					spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
					borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
					borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
					borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,
					fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
					steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
					cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)
				};

				line.pivot();
			}

			// Update Points
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				me.updateElement(points[i], i, reset);
			}

			if (showLine && line._model.tension !== 0) {
				me.updateBezierControlPoints();
			}

			// Now pivot the point for animation
			for (i = 0, ilen = points.length; i < ilen; ++i) {
				points[i].pivot();
			}
		},

		getPointBackgroundColor: function getPointBackgroundColor(point, index) {
			var backgroundColor = this.chart.options.elements.point.backgroundColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.backgroundColor) {
				backgroundColor = custom.backgroundColor;
			} else if (dataset.pointBackgroundColor) {
				backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
			} else if (dataset.backgroundColor) {
				backgroundColor = dataset.backgroundColor;
			}

			return backgroundColor;
		},

		getPointBorderColor: function getPointBorderColor(point, index) {
			var borderColor = this.chart.options.elements.point.borderColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (custom.borderColor) {
				borderColor = custom.borderColor;
			} else if (dataset.pointBorderColor) {
				borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
			} else if (dataset.borderColor) {
				borderColor = dataset.borderColor;
			}

			return borderColor;
		},

		getPointBorderWidth: function getPointBorderWidth(point, index) {
			var borderWidth = this.chart.options.elements.point.borderWidth;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			if (!isNaN(custom.borderWidth)) {
				borderWidth = custom.borderWidth;
			} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
				borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
			} else if (!isNaN(dataset.borderWidth)) {
				borderWidth = dataset.borderWidth;
			}

			return borderWidth;
		},

		updateElement: function updateElement(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var datasetIndex = me.index;
			var value = dataset.data[index];
			var yScale = me.getScaleForId(meta.yAxisID);
			var xScale = me.getScaleForId(meta.xAxisID);
			var pointOptions = me.chart.options.elements.point;
			var x, y;

			// Compatibility: If the properties are defined with only the old name, use those values
			if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
				dataset.pointRadius = dataset.radius;
			}
			if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			x = xScale.getPixelForValue((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : NaN, index, datasetIndex);
			y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

			// Utility
			point._xScale = xScale;
			point._yScale = yScale;
			point._datasetIndex = datasetIndex;
			point._index = index;

			// Desired view properties
			point._model = {
				x: x,
				y: y,
				skip: custom.skip || isNaN(x) || isNaN(y),
				// Appearance
				radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
				pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
				backgroundColor: me.getPointBackgroundColor(point, index),
				borderColor: me.getPointBorderColor(point, index),
				borderWidth: me.getPointBorderWidth(point, index),
				tension: meta.dataset._model ? meta.dataset._model.tension : 0,
				steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
				// Tooltip
				hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
			};
		},

		calculatePointY: function calculatePointY(value, index, datasetIndex) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var sumPos = 0;
			var sumNeg = 0;
			var i, ds, dsMeta;

			if (yScale.options.stacked) {
				for (i = 0; i < datasetIndex; i++) {
					ds = chart.data.datasets[i];
					dsMeta = chart.getDatasetMeta(i);
					if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
						var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
						if (stackedRightValue < 0) {
							sumNeg += stackedRightValue || 0;
						} else {
							sumPos += stackedRightValue || 0;
						}
					}
				}

				var rightValue = Number(yScale.getRightValue(value));
				if (rightValue < 0) {
					return yScale.getPixelForValue(sumNeg + rightValue);
				}
				return yScale.getPixelForValue(sumPos + rightValue);
			}

			return yScale.getPixelForValue(value);
		},

		updateBezierControlPoints: function updateBezierControlPoints() {
			var me = this;
			var meta = me.getMeta();
			var area = me.chart.chartArea;
			var points = meta.data || [];
			var i, ilen, point, model, controlPoints;

			// Only consider points that are drawn in case the spanGaps option is used
			if (meta.dataset._model.spanGaps) {
				points = points.filter(function (pt) {
					return !pt._model.skip;
				});
			}

			function capControlPoint(pt, min, max) {
				return Math.max(Math.min(pt, max), min);
			}

			if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
				helpers.splineCurveMonotone(points);
			} else {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					point = points[i];
					model = point._model;
					controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);
					model.controlPointPreviousX = controlPoints.previous.x;
					model.controlPointPreviousY = controlPoints.previous.y;
					model.controlPointNextX = controlPoints.next.x;
					model.controlPointNextY = controlPoints.next.y;
				}
			}

			if (me.chart.options.elements.line.capBezierPoints) {
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					model = points[i]._model;
					model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
					model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
					model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
					model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
				}
			}
		},

		draw: function draw() {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var points = meta.data || [];
			var area = chart.chartArea;
			var ilen = points.length;
			var i = 0;

			helpers.canvas.clipArea(chart.ctx, area);

			if (lineEnabled(me.getDataset(), chart.options)) {
				meta.dataset.draw();
			}

			helpers.canvas.unclipArea(chart.ctx);

			// Draw the points
			for (; i < ilen; ++i) {
				points[i].draw(area);
			}
		},

		setHoverStyle: function setHoverStyle(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;

			model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function removeHoverStyle(point) {
			var me = this;
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;

			// Compatibility: If the properties are defined with only the old name, use those values
			if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
				dataset.pointRadius = dataset.radius;
			}

			model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
			model.backgroundColor = me.getPointBackgroundColor(point, index);
			model.borderColor = me.getPointBorderColor(point, index);
			model.borderWidth = me.getPointBorderWidth(point, index);
		}
	});
};

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('polarArea', {
	scale: {
		type: 'radialLinear',
		angleLines: {
			display: false
		},
		gridLines: {
			circular: true
		},
		pointLabels: {
			display: false
		},
		ticks: {
			beginAtZero: true
		}
	},

	// Boolean - Whether to animate the rotation of the chart
	animation: {
		animateRotate: true,
		animateScale: true
	},

	startAngle: -0.5 * Math.PI,
	legendCallback: function legendCallback(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = data.datasets;
		var labels = data.labels;

		if (datasets.length) {
			for (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				if (labels[i]) {
					text.push(labels[i]);
				}
				text.push('</li>');
			}
		}

		text.push('</ul>');
		return text.join('');
	},
	legend: {
		labels: {
			generateLabels: function generateLabels(chart) {
				var data = chart.data;
				if (data.labels.length && data.datasets.length) {
					return data.labels.map(function (label, i) {
						var meta = chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc.custom || {};
						var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						return {
							text: label,
							fillStyle: fill,
							strokeStyle: stroke,
							lineWidth: bw,
							hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Extra data used for toggling the correct item
							index: i
						};
					});
				}
				return [];
			}
		},

		onClick: function onClick(e, legendItem) {
			var index = legendItem.index;
			var chart = this.chart;
			var i, ilen, meta;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				meta = chart.getDatasetMeta(i);
				meta.data[index].hidden = !meta.data[index].hidden;
			}

			chart.update();
		}
	},

	// Need to override these to give a nice default
	tooltips: {
		callbacks: {
			title: function title() {
				return '';
			},
			label: function label(item, data) {
				return data.labels[item.index] + ': ' + item.yLabel;
			}
		}
	}
});

module.exports = function (Chart) {

	Chart.controllers.polarArea = Chart.DatasetController.extend({

		dataElementType: elements.Arc,

		linkScales: helpers.noop,

		update: function update(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var meta = me.getMeta();
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

			me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
			me.innerRadius = me.outerRadius - chart.radiusLength;

			meta.count = me.countVisibleElements();

			helpers.each(meta.data, function (arc, index) {
				me.updateElement(arc, index, reset);
			});
		},

		updateElement: function updateElement(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var dataset = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var scale = chart.scale;
			var labels = chart.data.labels;

			var circumference = me.calculateCircumference(dataset.data[index]);
			var centerX = scale.xCenter;
			var centerY = scale.yCenter;

			// If there is NaN data before us, we need to calculate the starting angle correctly.
			// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
			var visibleCount = 0;
			var meta = me.getMeta();
			for (var i = 0; i < index; ++i) {
				if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
					++visibleCount;
				}
			}

			// var negHalfPI = -0.5 * Math.PI;
			var datasetStartAngle = opts.startAngle;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			var startAngle = datasetStartAngle + circumference * visibleCount;
			var endAngle = startAngle + (arc.hidden ? 0 : circumference);

			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: centerX,
					y: centerY,
					innerRadius: 0,
					outerRadius: reset ? resetRadius : distance,
					startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
					endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
					label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
				}
			});

			// Apply border and fill style
			me.removeHoverStyle(arc);

			arc.pivot();
		},

		removeHoverStyle: function removeHoverStyle(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		countVisibleElements: function countVisibleElements() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var count = 0;

			helpers.each(meta.data, function (element, index) {
				if (!isNaN(dataset.data[index]) && !element.hidden) {
					count++;
				}
			});

			return count;
		},

		calculateCircumference: function calculateCircumference(value) {
			var count = this.getMeta().count;
			if (count > 0 && !isNaN(value)) {
				return 2 * Math.PI / count;
			}
			return 0;
		}
	});
};

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('radar', {
	scale: {
		type: 'radialLinear'
	},
	elements: {
		line: {
			tension: 0 // no bezier in radar
		}
	}
});

module.exports = function (Chart) {

	Chart.controllers.radar = Chart.DatasetController.extend({

		datasetElementType: elements.Line,

		dataElementType: elements.Point,

		linkScales: helpers.noop,

		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data;
			var custom = line.custom || {};
			var dataset = me.getDataset();
			var lineElementOptions = me.chart.options.elements.line;
			var scale = me.chart.scale;

			// Compatibility: If the properties are defined with only the old name, use those values
			if (dataset.tension !== undefined && dataset.lineTension === undefined) {
				dataset.lineTension = dataset.tension;
			}

			helpers.extend(meta.dataset, {
				// Utility
				_datasetIndex: me.index,
				_scale: scale,
				// Data
				_children: points,
				_loop: true,
				// Model
				_model: {
					// Appearance
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,
					borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,
					borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,
					fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,
					borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle
				}
			});

			meta.dataset.pivot();

			// Update Points
			helpers.each(points, function (point, index) {
				me.updateElement(point, index, reset);
			}, me);

			// Update bezier control points
			me.updateBezierControlPoints();
		},
		updateElement: function updateElement(point, index, reset) {
			var me = this;
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var scale = me.chart.scale;
			var pointElementOptions = me.chart.options.elements.point;
			var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

			// Compatibility: If the properties are defined with only the old name, use those values
			if (dataset.radius !== undefined && dataset.pointRadius === undefined) {
				dataset.pointRadius = dataset.radius;
			}
			if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			helpers.extend(point, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,

				// Desired view properties
				_model: {
					x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
					y: reset ? scale.yCenter : pointPosition.y,

					// Appearance
					tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
					radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
				}
			});

			point._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);
		},
		updateBezierControlPoints: function updateBezierControlPoints() {
			var chartArea = this.chart.chartArea;
			var meta = this.getMeta();

			helpers.each(meta.data, function (point, index) {
				var model = point._model;
				var controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);

				// Prevent the bezier going outside of the bounds of the graph
				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

				// Now pivot the point for animation
				point.pivot();
			});
		},

		setHoverStyle: function setHoverStyle(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;

			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: function removeHoverStyle(point) {
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;
			var pointElementOptions = this.chart.options.elements.point;

			model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
		}
	});
};

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);

defaults._set('scatter', {
	hover: {
		mode: 'single'
	},

	scales: {
		xAxes: [{
			id: 'x-axis-1', // need an ID so datasets can reference the scale
			type: 'linear', // scatter should not use a category axis
			position: 'bottom'
		}],
		yAxes: [{
			id: 'y-axis-1',
			type: 'linear',
			position: 'left'
		}]
	},

	showLines: false,

	tooltips: {
		callbacks: {
			title: function title() {
				return ''; // doesn't make sense for scatter since data are formatted as a point
			},
			label: function label(item) {
				return '(' + item.xLabel + ', ' + item.yLabel + ')';
			}
		}
	}
});

module.exports = function (Chart) {

	// Scatter charts use line controllers
	Chart.controllers.scatter = Chart.controllers.line;
};

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	animation: {
		duration: 1000,
		easing: 'easeOutQuart',
		onProgress: helpers.noop,
		onComplete: helpers.noop
	}
});

module.exports = function (Chart) {

	Chart.Animation = Element.extend({
		chart: null, // the animation associated chart instance
		currentStep: 0, // the current animation step
		numSteps: 60, // default number of steps
		easing: '', // the easing to use for this animation
		render: null, // render function used by the animation service

		onAnimationProgress: null, // user specified callback to fire on each step of the animation
		onAnimationComplete: null // user specified callback to fire when the animation finishes
	});

	Chart.animationService = {
		frameDuration: 17,
		animations: [],
		dropFrames: 0,
		request: null,

		/**
   * @param {Chart} chart - The chart to animate.
   * @param {Chart.Animation} animation - The animation that we will animate.
   * @param {Number} duration - The animation duration in ms.
   * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
   */
		addAnimation: function addAnimation(chart, animation, duration, lazy) {
			var animations = this.animations;
			var i, ilen;

			animation.chart = chart;

			if (!lazy) {
				chart.animating = true;
			}

			for (i = 0, ilen = animations.length; i < ilen; ++i) {
				if (animations[i].chart === chart) {
					animations[i] = animation;
					return;
				}
			}

			animations.push(animation);

			// If there are no animations queued, manually kickstart a digest, for lack of a better word
			if (animations.length === 1) {
				this.requestAnimationFrame();
			}
		},

		cancelAnimation: function cancelAnimation(chart) {
			var index = helpers.findIndex(this.animations, function (animation) {
				return animation.chart === chart;
			});

			if (index !== -1) {
				this.animations.splice(index, 1);
				chart.animating = false;
			}
		},

		requestAnimationFrame: function requestAnimationFrame() {
			var me = this;
			if (me.request === null) {
				// Skip animation frame requests until the active one is executed.
				// This can happen when processing mouse events, e.g. 'mousemove'
				// and 'mouseout' events will trigger multiple renders.
				me.request = helpers.requestAnimFrame.call(window, function () {
					me.request = null;
					me.startDigest();
				});
			}
		},

		/**
   * @private
   */
		startDigest: function startDigest() {
			var me = this;
			var startTime = Date.now();
			var framesToDrop = 0;

			if (me.dropFrames > 1) {
				framesToDrop = Math.floor(me.dropFrames);
				me.dropFrames = me.dropFrames % 1;
			}

			me.advance(1 + framesToDrop);

			var endTime = Date.now();

			me.dropFrames += (endTime - startTime) / me.frameDuration;

			// Do we have more stuff to animate?
			if (me.animations.length > 0) {
				me.requestAnimationFrame();
			}
		},

		/**
   * @private
   */
		advance: function advance(count) {
			var animations = this.animations;
			var animation, chart;
			var i = 0;

			while (i < animations.length) {
				animation = animations[i];
				chart = animation.chart;

				animation.currentStep = (animation.currentStep || 0) + count;
				animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

				helpers.callback(animation.render, [chart, animation], chart);
				helpers.callback(animation.onAnimationProgress, [animation], chart);

				if (animation.currentStep >= animation.numSteps) {
					helpers.callback(animation.onAnimationComplete, [animation], chart);
					chart.animating = false;
					animations.splice(i, 1);
				} else {
					++i;
				}
			}
		}
	};

	/**
  * Provided for backward compatibility, use Chart.Animation instead
  * @prop Chart.Animation#animationObject
  * @deprecated since version 2.6.0
  * @todo remove at version 3
  */
	Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
		get: function get() {
			return this;
		}
	});

	/**
  * Provided for backward compatibility, use Chart.Animation#chart instead
  * @prop Chart.Animation#chartInstance
  * @deprecated since version 2.6.0
  * @todo remove at version 3
  */
	Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
		get: function get() {
			return this.chart;
		},
		set: function set(value) {
			this.chart = value;
		}
	});
};

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);
var Interaction = __webpack_require__(182);
var platform = __webpack_require__(183);

module.exports = function (Chart) {
	var plugins = Chart.plugins;

	// Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};

	// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	// Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};

	// Controllers available for dataset visualization eg. bar, line, slice, etc.
	Chart.controllers = {};

	/**
  * Initializes the given config with global and chart default values.
  */
	function initConfig(config) {
		config = config || {};

		// Do NOT use configMerge() for the data object because this method merges arrays
		// and so would change references to labels and datasets, preventing data updates.
		var data = config.data = config.data || {};
		data.datasets = data.datasets || [];
		data.labels = data.labels || [];

		config.options = helpers.configMerge(defaults.global, defaults[config.type], config.options || {});

		return config;
	}

	/**
  * Updates the config of the chart
  * @param chart {Chart} chart to update the options for
  */
	function updateConfig(chart) {
		var newOptions = chart.options;

		// Update Scale(s) with options
		if (newOptions.scale) {
			chart.scale.options = newOptions.scale;
		} else if (newOptions.scales) {
			newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {
				chart.scales[scaleOptions.id].options = scaleOptions;
			});
		}

		// Tooltip
		chart.tooltip._options = newOptions.tooltips;
	}

	function positionIsHorizontal(position) {
		return position === 'top' || position === 'bottom';
	}

	helpers.extend(Chart.prototype, /** @lends Chart */{
		/**
   * @private
   */
		construct: function construct(item, config) {
			var me = this;

			config = initConfig(config);

			var context = platform.acquireContext(item, config);
			var canvas = context && context.canvas;
			var height = canvas && canvas.height;
			var width = canvas && canvas.width;

			me.id = helpers.uid();
			me.ctx = context;
			me.canvas = canvas;
			me.config = config;
			me.width = width;
			me.height = height;
			me.aspectRatio = height ? width / height : null;
			me.options = config.options;
			me._bufferedRender = false;

			/**
    * Provided for backward compatibility, Chart and Chart.Controller have been merged,
    * the "instance" still need to be defined since it might be called from plugins.
    * @prop Chart#chart
    * @deprecated since version 2.6.0
    * @todo remove at version 3
    * @private
    */
			me.chart = me;
			me.controller = me; // chart.chart.controller #inception

			// Add the chart instance to the global namespace
			Chart.instances[me.id] = me;

			// Define alias to the config data: `chart.data === chart.config.data`
			Object.defineProperty(me, 'data', {
				get: function get() {
					return me.config.data;
				},
				set: function set(value) {
					me.config.data = value;
				}
			});

			if (!context || !canvas) {
				// The given item is not a compatible context2d element, let's return before finalizing
				// the chart initialization but after setting basic chart / controller properties that
				// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
				// https://github.com/chartjs/Chart.js/issues/2807
				console.error("Failed to create chart: can't acquire context from the given item");
				return;
			}

			me.initialize();
			me.update();
		},

		/**
   * @private
   */
		initialize: function initialize() {
			var me = this;

			// Before init plugin notification
			plugins.notify(me, 'beforeInit');

			helpers.retinaScale(me, me.options.devicePixelRatio);

			me.bindEvents();

			if (me.options.responsive) {
				// Initial resize before chart draws (must be silent to preserve initial animations).
				me.resize(true);
			}

			// Make sure scales have IDs and are built before we build any controllers.
			me.ensureScalesHaveIDs();
			me.buildScales();
			me.initToolTip();

			// After init plugin notification
			plugins.notify(me, 'afterInit');

			return me;
		},

		clear: function clear() {
			helpers.canvas.clear(this);
			return this;
		},

		stop: function stop() {
			// Stops any current animation loop occurring
			Chart.animationService.cancelAnimation(this);
			return this;
		},

		resize: function resize(silent) {
			var me = this;
			var options = me.options;
			var canvas = me.canvas;
			var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;

			// the canvas render width and height will be casted to integers so make sure that
			// the canvas display style uses the same integer values to avoid blurring effect.

			// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
			var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
			var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

			if (me.width === newWidth && me.height === newHeight) {
				return;
			}

			canvas.width = me.width = newWidth;
			canvas.height = me.height = newHeight;
			canvas.style.width = newWidth + 'px';
			canvas.style.height = newHeight + 'px';

			helpers.retinaScale(me, options.devicePixelRatio);

			if (!silent) {
				// Notify any plugins about the resize
				var newSize = { width: newWidth, height: newHeight };
				plugins.notify(me, 'resize', [newSize]);

				// Notify of resize
				if (me.options.onResize) {
					me.options.onResize(me, newSize);
				}

				me.stop();
				me.update(me.options.responsiveAnimationDuration);
			}
		},

		ensureScalesHaveIDs: function ensureScalesHaveIDs() {
			var options = this.options;
			var scalesOptions = options.scales || {};
			var scaleOptions = options.scale;

			helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {
				xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
			});

			helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {
				yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
			});

			if (scaleOptions) {
				scaleOptions.id = scaleOptions.id || 'scale';
			}
		},

		/**
   * Builds a map of scale ID to scale object for future lookup.
   */
		buildScales: function buildScales() {
			var me = this;
			var options = me.options;
			var scales = me.scales = {};
			var items = [];

			if (options.scales) {
				items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
					return { options: xAxisOptions, dtype: 'category', dposition: 'bottom' };
				}), (options.scales.yAxes || []).map(function (yAxisOptions) {
					return { options: yAxisOptions, dtype: 'linear', dposition: 'left' };
				}));
			}

			if (options.scale) {
				items.push({
					options: options.scale,
					dtype: 'radialLinear',
					isDefault: true,
					dposition: 'chartArea'
				});
			}

			helpers.each(items, function (item) {
				var scaleOptions = item.options;
				var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
				var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
				if (!scaleClass) {
					return;
				}

				if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
					scaleOptions.position = item.dposition;
				}

				var scale = new scaleClass({
					id: scaleOptions.id,
					options: scaleOptions,
					ctx: me.ctx,
					chart: me
				});

				scales[scale.id] = scale;
				scale.mergeTicksOptions();

				// TODO(SB): I think we should be able to remove this custom case (options.scale)
				// and consider it as a regular scale part of the "scales"" map only! This would
				// make the logic easier and remove some useless? custom code.
				if (item.isDefault) {
					me.scale = scale;
				}
			});

			Chart.scaleService.addScalesToLayout(this);
		},

		buildOrUpdateControllers: function buildOrUpdateControllers() {
			var me = this;
			var types = [];
			var newControllers = [];

			helpers.each(me.data.datasets, function (dataset, datasetIndex) {
				var meta = me.getDatasetMeta(datasetIndex);
				var type = dataset.type || me.config.type;

				if (meta.type && meta.type !== type) {
					me.destroyDatasetMeta(datasetIndex);
					meta = me.getDatasetMeta(datasetIndex);
				}
				meta.type = type;

				types.push(meta.type);

				if (meta.controller) {
					meta.controller.updateIndex(datasetIndex);
				} else {
					var ControllerClass = Chart.controllers[meta.type];
					if (ControllerClass === undefined) {
						throw new Error('"' + meta.type + '" is not a chart type.');
					}

					meta.controller = new ControllerClass(me, datasetIndex);
					newControllers.push(meta.controller);
				}
			}, me);

			return newControllers;
		},

		/**
   * Reset the elements of all datasets
   * @private
   */
		resetElements: function resetElements() {
			var me = this;
			helpers.each(me.data.datasets, function (dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.reset();
			}, me);
		},

		/**
  * Resets the chart back to it's state before the initial animation
  */
		reset: function reset() {
			this.resetElements();
			this.tooltip.initialize();
		},

		update: function update(config) {
			var me = this;

			if (!config || (typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
				// backwards compatibility
				config = {
					duration: config,
					lazy: arguments[1]
				};
			}

			updateConfig(me);

			if (plugins.notify(me, 'beforeUpdate') === false) {
				return;
			}

			// In case the entire data object changed
			me.tooltip._data = me.data;

			// Make sure dataset controllers are updated and new controllers are reset
			var newControllers = me.buildOrUpdateControllers();

			// Make sure all dataset controllers have correct meta data counts
			helpers.each(me.data.datasets, function (dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
			}, me);

			me.updateLayout();

			// Can only reset the new controllers after the scales have been updated
			helpers.each(newControllers, function (controller) {
				controller.reset();
			});

			me.updateDatasets();

			// Do this before render so that any plugins that need final scale updates can use it
			plugins.notify(me, 'afterUpdate');

			if (me._bufferedRender) {
				me._bufferedRequest = {
					duration: config.duration,
					easing: config.easing,
					lazy: config.lazy
				};
			} else {
				me.render(config);
			}
		},

		/**
   * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
   * hook, in which case, plugins will not be called on `afterLayout`.
   * @private
   */
		updateLayout: function updateLayout() {
			var me = this;

			if (plugins.notify(me, 'beforeLayout') === false) {
				return;
			}

			Chart.layoutService.update(this, this.width, this.height);

			/**
    * Provided for backward compatibility, use `afterLayout` instead.
    * @method IPlugin#afterScaleUpdate
    * @deprecated since version 2.5.0
    * @todo remove at version 3
    * @private
    */
			plugins.notify(me, 'afterScaleUpdate');
			plugins.notify(me, 'afterLayout');
		},

		/**
   * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
   * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
   * @private
   */
		updateDatasets: function updateDatasets() {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
				return;
			}

			for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				me.updateDataset(i);
			}

			plugins.notify(me, 'afterDatasetsUpdate');
		},

		/**
   * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
   * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
   * @private
   */
		updateDataset: function updateDataset(index) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index
			};

			if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
				return;
			}

			meta.controller.update();

			plugins.notify(me, 'afterDatasetUpdate', [args]);
		},

		render: function render(config) {
			var me = this;

			if (!config || (typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
				// backwards compatibility
				config = {
					duration: config,
					lazy: arguments[1]
				};
			}

			var duration = config.duration;
			var lazy = config.lazy;

			if (plugins.notify(me, 'beforeRender') === false) {
				return;
			}

			var animationOptions = me.options.animation;
			var onComplete = function onComplete(animation) {
				plugins.notify(me, 'afterRender');
				helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
			};

			if (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {
				var animation = new Chart.Animation({
					numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
					easing: config.easing || animationOptions.easing,

					render: function render(chart, animationObject) {
						var easingFunction = helpers.easing.effects[animationObject.easing];
						var currentStep = animationObject.currentStep;
						var stepDecimal = currentStep / animationObject.numSteps;

						chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
					},

					onAnimationProgress: animationOptions.onProgress,
					onAnimationComplete: onComplete
				});

				Chart.animationService.addAnimation(me, animation, duration, lazy);
			} else {
				me.draw();

				// See https://github.com/chartjs/Chart.js/issues/3781
				onComplete(new Chart.Animation({ numSteps: 0, chart: me }));
			}

			return me;
		},

		draw: function draw(easingValue) {
			var me = this;

			me.clear();

			if (helpers.isNullOrUndef(easingValue)) {
				easingValue = 1;
			}

			me.transition(easingValue);

			if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
				return;
			}

			// Draw all the scales
			helpers.each(me.boxes, function (box) {
				box.draw(me.chartArea);
			}, me);

			if (me.scale) {
				me.scale.draw();
			}

			me.drawDatasets(easingValue);

			// Finally draw the tooltip
			me.tooltip.draw();

			plugins.notify(me, 'afterDraw', [easingValue]);
		},

		/**
   * @private
   */
		transition: function transition(easingValue) {
			var me = this;

			for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
				if (me.isDatasetVisible(i)) {
					me.getDatasetMeta(i).controller.transition(easingValue);
				}
			}

			me.tooltip.transition(easingValue);
		},

		/**
   * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
   * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
   * @private
   */
		drawDatasets: function drawDatasets(easingValue) {
			var me = this;

			if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
				return;
			}

			// Draw datasets reversed to support proper line stacking
			for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
				if (me.isDatasetVisible(i)) {
					me.drawDataset(i, easingValue);
				}
			}

			plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
		},

		/**
   * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
   * hook, in which case, plugins will not be called on `afterDatasetDraw`.
   * @private
   */
		drawDataset: function drawDataset(index, easingValue) {
			var me = this;
			var meta = me.getDatasetMeta(index);
			var args = {
				meta: meta,
				index: index,
				easingValue: easingValue
			};

			if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
				return;
			}

			meta.controller.draw(easingValue);

			plugins.notify(me, 'afterDatasetDraw', [args]);
		},

		// Get the single element that was clicked on
		// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
		getElementAtEvent: function getElementAtEvent(e) {
			return Interaction.modes.single(this, e);
		},

		getElementsAtEvent: function getElementsAtEvent(e) {
			return Interaction.modes.label(this, e, { intersect: true });
		},

		getElementsAtXAxis: function getElementsAtXAxis(e) {
			return Interaction.modes['x-axis'](this, e, { intersect: true });
		},

		getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
			var method = Interaction.modes[mode];
			if (typeof method === 'function') {
				return method(this, e, options);
			}

			return [];
		},

		getDatasetAtEvent: function getDatasetAtEvent(e) {
			return Interaction.modes.dataset(this, e, { intersect: true });
		},

		getDatasetMeta: function getDatasetMeta(datasetIndex) {
			var me = this;
			var dataset = me.data.datasets[datasetIndex];
			if (!dataset._meta) {
				dataset._meta = {};
			}

			var meta = dataset._meta[me.id];
			if (!meta) {
				meta = dataset._meta[me.id] = {
					type: null,
					data: [],
					dataset: null,
					controller: null,
					hidden: null, // See isDatasetVisible() comment
					xAxisID: null,
					yAxisID: null
				};
			}

			return meta;
		},

		getVisibleDatasetCount: function getVisibleDatasetCount() {
			var count = 0;
			for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
				if (this.isDatasetVisible(i)) {
					count++;
				}
			}
			return count;
		},

		isDatasetVisible: function isDatasetVisible(datasetIndex) {
			var meta = this.getDatasetMeta(datasetIndex);

			// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
			// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
			return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
		},

		generateLegend: function generateLegend() {
			return this.options.legendCallback(this);
		},

		/**
   * @private
   */
		destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
			var id = this.id;
			var dataset = this.data.datasets[datasetIndex];
			var meta = dataset._meta && dataset._meta[id];

			if (meta) {
				meta.controller.destroy();
				delete dataset._meta[id];
			}
		},

		destroy: function destroy() {
			var me = this;
			var canvas = me.canvas;
			var i, ilen;

			me.stop();

			// dataset controllers need to cleanup associated data
			for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				me.destroyDatasetMeta(i);
			}

			if (canvas) {
				me.unbindEvents();
				helpers.canvas.clear(me);
				platform.releaseContext(me.ctx);
				me.canvas = null;
				me.ctx = null;
			}

			plugins.notify(me, 'destroy');

			delete Chart.instances[me.id];
		},

		toBase64Image: function toBase64Image() {
			return this.canvas.toDataURL.apply(this.canvas, arguments);
		},

		initToolTip: function initToolTip() {
			var me = this;
			me.tooltip = new Chart.Tooltip({
				_chart: me,
				_chartInstance: me, // deprecated, backward compatibility
				_data: me.data,
				_options: me.options.tooltips
			}, me);
		},

		/**
   * @private
   */
		bindEvents: function bindEvents() {
			var me = this;
			var listeners = me._listeners = {};
			var listener = function listener() {
				me.eventHandler.apply(me, arguments);
			};

			helpers.each(me.options.events, function (type) {
				platform.addEventListener(me, type, listener);
				listeners[type] = listener;
			});

			// Elements used to detect size change should not be injected for non responsive charts.
			// See https://github.com/chartjs/Chart.js/issues/2210
			if (me.options.responsive) {
				listener = function listener() {
					me.resize();
				};

				platform.addEventListener(me, 'resize', listener);
				listeners.resize = listener;
			}
		},

		/**
   * @private
   */
		unbindEvents: function unbindEvents() {
			var me = this;
			var listeners = me._listeners;
			if (!listeners) {
				return;
			}

			delete me._listeners;
			helpers.each(listeners, function (listener, type) {
				platform.removeEventListener(me, type, listener);
			});
		},

		updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
			var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
			var element, i, ilen;

			for (i = 0, ilen = elements.length; i < ilen; ++i) {
				element = elements[i];
				if (element) {
					this.getDatasetMeta(element._datasetIndex).controller[method](element);
				}
			}
		},

		/**
   * @private
   */
		eventHandler: function eventHandler(e) {
			var me = this;
			var tooltip = me.tooltip;

			if (plugins.notify(me, 'beforeEvent', [e]) === false) {
				return;
			}

			// Buffer any update calls so that renders do not occur
			me._bufferedRender = true;
			me._bufferedRequest = null;

			var changed = me.handleEvent(e);
			changed |= tooltip && tooltip.handleEvent(e);

			plugins.notify(me, 'afterEvent', [e]);

			var bufferedRequest = me._bufferedRequest;
			if (bufferedRequest) {
				// If we have an update that was triggered, we need to do a normal render
				me.render(bufferedRequest);
			} else if (changed && !me.animating) {
				// If entering, leaving, or changing elements, animate the change via pivot
				me.stop();

				// We only need to render at this point. Updating will cause scales to be
				// recomputed generating flicker & using more memory than necessary.
				me.render(me.options.hover.animationDuration, true);
			}

			me._bufferedRender = false;
			me._bufferedRequest = null;

			return me;
		},

		/**
   * Handle an event
   * @private
   * @param {IEvent} event the event to handle
   * @return {Boolean} true if the chart needs to re-render
   */
		handleEvent: function handleEvent(e) {
			var me = this;
			var options = me.options || {};
			var hoverOptions = options.hover;
			var changed = false;

			me.lastActive = me.lastActive || [];

			// Find Active Elements for hover and tooltips
			if (e.type === 'mouseout') {
				me.active = [];
			} else {
				me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
			}

			// Invoke onHover hook
			// Need to call with native event here to not break backwards compatibility
			helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

			if (e.type === 'mouseup' || e.type === 'click') {
				if (options.onClick) {
					// Use e.native here for backwards compatibility
					options.onClick.call(me, e.native, me.active);
				}
			}

			// Remove styling for last active (even if it may still be active)
			if (me.lastActive.length) {
				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
			}

			// Built in hover styling
			if (me.active.length && hoverOptions.mode) {
				me.updateHoverStyle(me.active, hoverOptions.mode, true);
			}

			changed = !helpers.arrayEquals(me.active, me.lastActive);

			// Remember Last Actives
			me.lastActive = me.active;

			return changed;
		}
	});

	/**
  * Provided for backward compatibility, use Chart instead.
  * @class Chart.Controller
  * @deprecated since version 2.6.0
  * @todo remove at version 3
  * @private
  */
	Chart.Controller = Chart;
};

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);

module.exports = function (Chart) {

	var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

	/**
  * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
  * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
  * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
  */
	function listenArrayEvents(array, listener) {
		if (array._chartjs) {
			array._chartjs.listeners.push(listener);
			return;
		}

		Object.defineProperty(array, '_chartjs', {
			configurable: true,
			enumerable: false,
			value: {
				listeners: [listener]
			}
		});

		arrayEvents.forEach(function (key) {
			var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
			var base = array[key];

			Object.defineProperty(array, key, {
				configurable: true,
				enumerable: false,
				value: function value() {
					var args = Array.prototype.slice.call(arguments);
					var res = base.apply(this, args);

					helpers.each(array._chartjs.listeners, function (object) {
						if (typeof object[method] === 'function') {
							object[method].apply(object, args);
						}
					});

					return res;
				}
			});
		});
	}

	/**
  * Removes the given array event listener and cleanup extra attached properties (such as
  * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
  */
	function unlistenArrayEvents(array, listener) {
		var stub = array._chartjs;
		if (!stub) {
			return;
		}

		var listeners = stub.listeners;
		var index = listeners.indexOf(listener);
		if (index !== -1) {
			listeners.splice(index, 1);
		}

		if (listeners.length > 0) {
			return;
		}

		arrayEvents.forEach(function (key) {
			delete array[key];
		});

		delete array._chartjs;
	}

	// Base class for all dataset controllers (line, bar, etc)
	Chart.DatasetController = function (chart, datasetIndex) {
		this.initialize(chart, datasetIndex);
	};

	helpers.extend(Chart.DatasetController.prototype, {

		/**
   * Element type used to generate a meta dataset (e.g. Chart.element.Line).
   * @type {Chart.core.element}
   */
		datasetElementType: null,

		/**
   * Element type used to generate a meta data (e.g. Chart.element.Point).
   * @type {Chart.core.element}
   */
		dataElementType: null,

		initialize: function initialize(chart, datasetIndex) {
			var me = this;
			me.chart = chart;
			me.index = datasetIndex;
			me.linkScales();
			me.addElements();
		},

		updateIndex: function updateIndex(datasetIndex) {
			this.index = datasetIndex;
		},

		linkScales: function linkScales() {
			var me = this;
			var meta = me.getMeta();
			var dataset = me.getDataset();

			if (meta.xAxisID === null) {
				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
			}
			if (meta.yAxisID === null) {
				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
			}
		},

		getDataset: function getDataset() {
			return this.chart.data.datasets[this.index];
		},

		getMeta: function getMeta() {
			return this.chart.getDatasetMeta(this.index);
		},

		getScaleForId: function getScaleForId(scaleID) {
			return this.chart.scales[scaleID];
		},

		reset: function reset() {
			this.update(true);
		},

		/**
   * @private
   */
		destroy: function destroy() {
			if (this._data) {
				unlistenArrayEvents(this._data, this);
			}
		},

		createMetaDataset: function createMetaDataset() {
			var me = this;
			var type = me.datasetElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index
			});
		},

		createMetaData: function createMetaData(index) {
			var me = this;
			var type = me.dataElementType;
			return type && new type({
				_chart: me.chart,
				_datasetIndex: me.index,
				_index: index
			});
		},

		addElements: function addElements() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data || [];
			var metaData = meta.data;
			var i, ilen;

			for (i = 0, ilen = data.length; i < ilen; ++i) {
				metaData[i] = metaData[i] || me.createMetaData(i);
			}

			meta.dataset = meta.dataset || me.createMetaDataset();
		},

		addElementAndReset: function addElementAndReset(index) {
			var element = this.createMetaData(index);
			this.getMeta().data.splice(index, 0, element);
			this.updateElement(element, index, true);
		},

		buildOrUpdateElements: function buildOrUpdateElements() {
			var me = this;
			var dataset = me.getDataset();
			var data = dataset.data || (dataset.data = []);

			// In order to correctly handle data addition/deletion animation (an thus simulate
			// real-time charts), we need to monitor these data modifications and synchronize
			// the internal meta data accordingly.
			if (me._data !== data) {
				if (me._data) {
					// This case happens when the user replaced the data array instance.
					unlistenArrayEvents(me._data, me);
				}

				listenArrayEvents(data, me);
				me._data = data;
			}

			// Re-sync meta data in case the user replaced the data array or if we missed
			// any updates and so make sure that we handle number of datapoints changing.
			me.resyncElements();
		},

		update: helpers.noop,

		transition: function transition(easingValue) {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			for (; i < ilen; ++i) {
				elements[i].transition(easingValue);
			}

			if (meta.dataset) {
				meta.dataset.transition(easingValue);
			}
		},

		draw: function draw() {
			var meta = this.getMeta();
			var elements = meta.data || [];
			var ilen = elements.length;
			var i = 0;

			if (meta.dataset) {
				meta.dataset.draw();
			}

			for (; i < ilen; ++i) {
				elements[i].draw();
			}
		},

		removeHoverStyle: function removeHoverStyle(element, elementOpts) {
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = element._index;
			var custom = element.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var model = element._model;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
		},

		setHoverStyle: function setHoverStyle(element) {
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = element._index;
			var custom = element.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var getHoverColor = helpers.getHoverColor;
			var model = element._model;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		/**
   * @private
   */
		resyncElements: function resyncElements() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data;
			var numMeta = meta.data.length;
			var numData = data.length;

			if (numData < numMeta) {
				meta.data.splice(numData, numMeta - numData);
			} else if (numData > numMeta) {
				me.insertElements(numMeta, numData - numMeta);
			}
		},

		/**
   * @private
   */
		insertElements: function insertElements(start, count) {
			for (var i = 0; i < count; ++i) {
				this.addElementAndReset(start + i);
			}
		},

		/**
   * @private
   */
		onDataPush: function onDataPush() {
			this.insertElements(this.getDataset().data.length - 1, arguments.length);
		},

		/**
   * @private
   */
		onDataPop: function onDataPop() {
			this.getMeta().data.pop();
		},

		/**
   * @private
   */
		onDataShift: function onDataShift() {
			this.getMeta().data.shift();
		},

		/**
   * @private
   */
		onDataSplice: function onDataSplice(start, count) {
			this.getMeta().data.splice(start, count);
			this.insertElements(start, arguments.length - 2);
		},

		/**
   * @private
   */
		onDataUnshift: function onDataUnshift() {
			this.insertElements(0, arguments.length);
		}
	});

	Chart.DatasetController.extend = helpers.inherits;
};

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */
/* global document: false */


var color = __webpack_require__(184);
var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);

module.exports = function (Chart) {

	// -- Basic js utility methods

	helpers.extend = function (base) {
		var setFn = function setFn(value, key) {
			base[key] = value;
		};
		for (var i = 1, ilen = arguments.length; i < ilen; i++) {
			helpers.each(arguments[i], setFn);
		}
		return base;
	};

	helpers.configMerge = function () /* objects ... */{
		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
			merger: function merger(key, target, source, options) {
				var tval = target[key] || {};
				var sval = source[key];

				if (key === 'scales') {
					// scale config merging is complex. Add our own function here for that
					target[key] = helpers.scaleMerge(tval, sval);
				} else if (key === 'scale') {
					// used in polar area & radar charts since there is only one scale
					target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
				} else {
					helpers._merger(key, target, source, options);
				}
			}
		});
	};

	helpers.scaleMerge = function () /* objects ... */{
		return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
			merger: function merger(key, target, source, options) {
				if (key === 'xAxes' || key === 'yAxes') {
					var slen = source[key].length;
					var i, type, scale;

					if (!target[key]) {
						target[key] = [];
					}

					for (i = 0; i < slen; ++i) {
						scale = source[key][i];
						type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

						if (i >= target[key].length) {
							target[key].push({});
						}

						if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
							// new/untyped scale or type changed: let's apply the new defaults
							// then merge source scale to correctly overwrite the defaults.
							helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
						} else {
							// scales type are the same
							helpers.merge(target[key][i], scale);
						}
					}
				} else {
					helpers._merger(key, target, source, options);
				}
			}
		});
	};

	helpers.where = function (collection, filterCallback) {
		if (helpers.isArray(collection) && Array.prototype.filter) {
			return collection.filter(filterCallback);
		}
		var filtered = [];

		helpers.each(collection, function (item) {
			if (filterCallback(item)) {
				filtered.push(item);
			}
		});

		return filtered;
	};
	helpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
		return array.findIndex(callback, scope);
	} : function (array, callback, scope) {
		scope = scope === undefined ? array : scope;
		for (var i = 0, ilen = array.length; i < ilen; ++i) {
			if (callback.call(scope, array[i], i, array)) {
				return i;
			}
		}
		return -1;
	};
	helpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
		// Default to start of the array
		if (helpers.isNullOrUndef(startIndex)) {
			startIndex = -1;
		}
		for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
		// Default to end of the array
		if (helpers.isNullOrUndef(startIndex)) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; i >= 0; i--) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.inherits = function (extensions) {
		// Basic javascript inheritance based on the model created in Backbone.js
		var me = this;
		var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
			return me.apply(this, arguments);
		};

		var Surrogate = function Surrogate() {
			this.constructor = ChartElement;
		};
		Surrogate.prototype = me.prototype;
		ChartElement.prototype = new Surrogate();

		ChartElement.extend = helpers.inherits;

		if (extensions) {
			helpers.extend(ChartElement.prototype, extensions);
		}

		ChartElement.__super__ = me.prototype;

		return ChartElement;
	};
	// -- Math methods
	helpers.isNumber = function (n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};
	helpers.almostEquals = function (x, y, epsilon) {
		return Math.abs(x - y) < epsilon;
	};
	helpers.almostWhole = function (x, epsilon) {
		var rounded = Math.round(x);
		return rounded - epsilon < x && rounded + epsilon > x;
	};
	helpers.max = function (array) {
		return array.reduce(function (max, value) {
			if (!isNaN(value)) {
				return Math.max(max, value);
			}
			return max;
		}, Number.NEGATIVE_INFINITY);
	};
	helpers.min = function (array) {
		return array.reduce(function (min, value) {
			if (!isNaN(value)) {
				return Math.min(min, value);
			}
			return min;
		}, Number.POSITIVE_INFINITY);
	};
	helpers.sign = Math.sign ? function (x) {
		return Math.sign(x);
	} : function (x) {
		x = +x; // convert to a number
		if (x === 0 || isNaN(x)) {
			return x;
		}
		return x > 0 ? 1 : -1;
	};
	helpers.log10 = Math.log10 ? function (x) {
		return Math.log10(x);
	} : function (x) {
		return Math.log(x) / Math.LN10;
	};
	helpers.toRadians = function (degrees) {
		return degrees * (Math.PI / 180);
	};
	helpers.toDegrees = function (radians) {
		return radians * (180 / Math.PI);
	};
	// Gets the angle from vertical upright to the point about a centre.
	helpers.getAngleFromPoint = function (centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x;
		var distanceFromYCenter = anglePoint.y - centrePoint.y;
		var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

		if (angle < -0.5 * Math.PI) {
			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
		}

		return {
			angle: angle,
			distance: radialDistanceFromCenter
		};
	};
	helpers.distanceBetweenPoints = function (pt1, pt2) {
		return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	};
	helpers.aliasPixel = function (pixelWidth) {
		return pixelWidth % 2 === 0 ? 0 : 0.5;
	};
	helpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
		// Props to Rob Spencer at scaled innovation for his post on splining between points
		// http://scaledinnovation.com/analytics/splines/aboutSplines.html

		// This function must also respect "skipped" points

		var previous = firstPoint.skip ? middlePoint : firstPoint;
		var current = middlePoint;
		var next = afterPoint.skip ? middlePoint : afterPoint;

		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

		var s01 = d01 / (d01 + d12);
		var s12 = d12 / (d01 + d12);

		// If all points are the same, s01 & s02 will be inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;

		var fa = t * s01; // scaling factor for triangle Ta
		var fb = t * s12;

		return {
			previous: {
				x: current.x - fa * (next.x - previous.x),
				y: current.y - fa * (next.y - previous.y)
			},
			next: {
				x: current.x + fb * (next.x - previous.x),
				y: current.y + fb * (next.y - previous.y)
			}
		};
	};
	helpers.EPSILON = Number.EPSILON || 1e-14;
	helpers.splineCurveMonotone = function (points) {
		// This function calculates Bzier control points in a similar way than |splineCurve|,
		// but preserves monotonicity of the provided data and ensures no local extremums are added
		// between the dataset discrete points due to the interpolation.
		// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

		var pointsWithTangents = (points || []).map(function (point) {
			return {
				model: point._model,
				deltaK: 0,
				mK: 0
			};
		});

		// Calculate slopes (deltaK) and initialize tangents (mK)
		var pointsLen = pointsWithTangents.length;
		var i, pointBefore, pointCurrent, pointAfter;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointAfter && !pointAfter.model.skip) {
				var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;

				// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
				pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
			}

			if (!pointBefore || pointBefore.model.skip) {
				pointCurrent.mK = pointCurrent.deltaK;
			} else if (!pointAfter || pointAfter.model.skip) {
				pointCurrent.mK = pointBefore.deltaK;
			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
				pointCurrent.mK = 0;
			} else {
				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
			}
		}

		// Adjust tangents to ensure monotonic properties
		var alphaK, betaK, tauK, squaredMagnitude;
		for (i = 0; i < pointsLen - 1; ++i) {
			pointCurrent = pointsWithTangents[i];
			pointAfter = pointsWithTangents[i + 1];
			if (pointCurrent.model.skip || pointAfter.model.skip) {
				continue;
			}

			if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
				pointCurrent.mK = pointAfter.mK = 0;
				continue;
			}

			alphaK = pointCurrent.mK / pointCurrent.deltaK;
			betaK = pointAfter.mK / pointCurrent.deltaK;
			squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
			if (squaredMagnitude <= 9) {
				continue;
			}

			tauK = 3 / Math.sqrt(squaredMagnitude);
			pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
		}

		// Compute control points
		var deltaX;
		for (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			if (pointCurrent.model.skip) {
				continue;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointBefore && !pointBefore.model.skip) {
				deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
			}
			if (pointAfter && !pointAfter.model.skip) {
				deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
			}
		}
	};
	helpers.nextItem = function (collection, index, loop) {
		if (loop) {
			return index >= collection.length - 1 ? collection[0] : collection[index + 1];
		}
		return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
	};
	helpers.previousItem = function (collection, index, loop) {
		if (loop) {
			return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
		}
		return index <= 0 ? collection[0] : collection[index - 1];
	};
	// Implementation of the nice number algorithm used in determining where axis labels will go
	helpers.niceNum = function (range, round) {
		var exponent = Math.floor(helpers.log10(range));
		var fraction = range / Math.pow(10, exponent);
		var niceFraction;

		if (round) {
			if (fraction < 1.5) {
				niceFraction = 1;
			} else if (fraction < 3) {
				niceFraction = 2;
			} else if (fraction < 7) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		} else if (fraction <= 1.0) {
			niceFraction = 1;
		} else if (fraction <= 2) {
			niceFraction = 2;
		} else if (fraction <= 5) {
			niceFraction = 5;
		} else {
			niceFraction = 10;
		}

		return niceFraction * Math.pow(10, exponent);
	};
	// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	helpers.requestAnimFrame = function () {
		if (typeof window === 'undefined') {
			return function (callback) {
				callback();
			};
		}
		return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
			return window.setTimeout(callback, 1000 / 60);
		};
	}();
	// -- DOM methods
	helpers.getRelativePosition = function (evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || evt;
		var canvas = evt.currentTarget || evt.srcElement;
		var boundingRect = canvas.getBoundingClientRect();

		var touches = e.touches;
		if (touches && touches.length > 0) {
			mouseX = touches[0].clientX;
			mouseY = touches[0].clientY;
		} else {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}

		// Scale mouse coordinates into canvas coordinates
		// by following the pattern laid out by 'jerryj' in the comments of
		// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);

		return {
			x: mouseX,
			y: mouseY
		};
	};

	// Private helper function to convert max-width/max-height values that may be percentages into a number
	function parseMaxStyle(styleValue, node, parentProperty) {
		var valueInPixels;
		if (typeof styleValue === 'string') {
			valueInPixels = parseInt(styleValue, 10);

			if (styleValue.indexOf('%') !== -1) {
				// percentage * size in dimension
				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
			}
		} else {
			valueInPixels = styleValue;
		}

		return valueInPixels;
	}

	/**
  * Returns if the given value contains an effective constraint.
  * @private
  */
	function isConstrainedValue(value) {
		return value !== undefined && value !== null && value !== 'none';
	}

	// Private helper to get a constraint dimension
	// @param domNode : the node to check the constraint on
	// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
	// @param percentageProperty : property of parent to use when calculating width as a percentage
	// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		var parentNode = domNode.parentNode;
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		var hasCNode = isConstrainedValue(constrainedNode);
		var hasCContainer = isConstrainedValue(constrainedContainer);
		var infinity = Number.POSITIVE_INFINITY;

		if (hasCNode || hasCContainer) {
			return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
		}

		return 'none';
	}
	// returns Number or undefined if no constraint
	helpers.getConstraintWidth = function (domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// returns Number or undefined if no constraint
	helpers.getConstraintHeight = function (domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	helpers.getMaximumWidth = function (domNode) {
		var container = domNode.parentNode;
		if (!container) {
			return domNode.clientWidth;
		}

		var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
		var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
		var w = container.clientWidth - paddingLeft - paddingRight;
		var cw = helpers.getConstraintWidth(domNode);
		return isNaN(cw) ? w : Math.min(w, cw);
	};
	helpers.getMaximumHeight = function (domNode) {
		var container = domNode.parentNode;
		if (!container) {
			return domNode.clientHeight;
		}

		var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
		var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
		var h = container.clientHeight - paddingTop - paddingBottom;
		var ch = helpers.getConstraintHeight(domNode);
		return isNaN(ch) ? h : Math.min(h, ch);
	};
	helpers.getStyle = function (el, property) {
		return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
	};
	helpers.retinaScale = function (chart, forceRatio) {
		var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
		if (pixelRatio === 1) {
			return;
		}

		var canvas = chart.canvas;
		var height = chart.height;
		var width = chart.width;

		canvas.height = height * pixelRatio;
		canvas.width = width * pixelRatio;
		chart.ctx.scale(pixelRatio, pixelRatio);

		// If no style has been set on the canvas, the render size is used as display size,
		// making the chart visually bigger, so let's enforce it to the "correct" values.
		// See https://github.com/chartjs/Chart.js/issues/3575
		canvas.style.height = height + 'px';
		canvas.style.width = width + 'px';
	};
	// -- Canvas methods
	helpers.fontString = function (pixelSize, fontStyle, fontFamily) {
		return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
	};
	helpers.longestText = function (ctx, font, arrayOfThings, cache) {
		cache = cache || {};
		var data = cache.data = cache.data || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];

		if (cache.font !== font) {
			data = cache.data = {};
			gc = cache.garbageCollect = [];
			cache.font = font;
		}

		ctx.font = font;
		var longest = 0;
		helpers.each(arrayOfThings, function (thing) {
			// Undefined strings and arrays should not be measured
			if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
				longest = helpers.measureText(ctx, data, gc, longest, thing);
			} else if (helpers.isArray(thing)) {
				// if it is an array lets measure each element
				// to do maybe simplify this function a bit so we can do this more recursively?
				helpers.each(thing, function (nestedThing) {
					// Undefined strings and arrays should not be measured
					if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
						longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
					}
				});
			}
		});

		var gcLen = gc.length / 2;
		if (gcLen > arrayOfThings.length) {
			for (var i = 0; i < gcLen; i++) {
				delete data[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		return longest;
	};
	helpers.measureText = function (ctx, data, gc, longest, string) {
		var textWidth = data[string];
		if (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(string);
		}
		if (textWidth > longest) {
			longest = textWidth;
		}
		return longest;
	};
	helpers.numberOfLabelLines = function (arrayOfThings) {
		var numberOfLines = 1;
		helpers.each(arrayOfThings, function (thing) {
			if (helpers.isArray(thing)) {
				if (thing.length > numberOfLines) {
					numberOfLines = thing.length;
				}
			}
		});
		return numberOfLines;
	};

	helpers.color = !color ? function (value) {
		console.error('Color.js not found!');
		return value;
	} : function (value) {
		/* global CanvasGradient */
		if (value instanceof CanvasGradient) {
			value = defaults.global.defaultColor;
		}

		return color(value);
	};

	helpers.getHoverColor = function (colorValue) {
		/* global CanvasPattern */
		return colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
	};
};

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);

defaults._set('global', {
	responsive: true,
	responsiveAnimationDuration: 0,
	maintainAspectRatio: true,
	events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
	hover: {
		onHover: null,
		mode: 'nearest',
		intersect: true,
		animationDuration: 400
	},
	onClick: null,
	defaultColor: 'rgba(0,0,0,0.1)',
	defaultFontColor: '#666',
	defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
	defaultFontSize: 12,
	defaultFontStyle: 'normal',
	showLines: true,

	// Element defaults defined in element extensions
	elements: {},

	// Layout options such as padding
	layout: {
		padding: {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		}
	}
});

module.exports = function () {

	// Occupy the global variable of Chart, and create a simple base class
	var Chart = function Chart(item, config) {
		this.construct(item, config);
		return this;
	};

	Chart.Chart = Chart;

	return Chart;
};

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);

module.exports = function (Chart) {

	function filterByPosition(array, position) {
		return helpers.where(array, function (v) {
			return v.position === position;
		});
	}

	function sortByWeight(array, reverse) {
		array.forEach(function (v, i) {
			v._tmpIndex_ = i;
			return v;
		});
		array.sort(function (a, b) {
			var v0 = reverse ? b : a;
			var v1 = reverse ? a : b;
			return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
		});
		array.forEach(function (v) {
			delete v._tmpIndex_;
		});
	}

	/**
  * @interface ILayoutItem
  * @prop {String} position - The position of the item in the chart layout. Possible values are
  * 'left', 'top', 'right', 'bottom', and 'chartArea'
  * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
  * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
  * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
  * @prop {Function} update - Takes two parameters: width and height. Returns size of item
  * @prop {Function} getPadding -  Returns an object with padding on the edges
  * @prop {Number} width - Width of item. Must be valid after update()
  * @prop {Number} height - Height of item. Must be valid after update()
  * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
  * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
  */

	// The layout service is very self explanatory.  It's responsible for the layout within a chart.
	// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
	// It is this service's responsibility of carrying out that layout.
	Chart.layoutService = {
		defaults: {},

		/**
   * Register a box to a chart.
   * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
   * @param {Chart} chart - the chart to use
   * @param {ILayoutItem} item - the item to add to be layed out
   */
		addBox: function addBox(chart, item) {
			if (!chart.boxes) {
				chart.boxes = [];
			}

			// initialize item with default values
			item.fullWidth = item.fullWidth || false;
			item.position = item.position || 'top';
			item.weight = item.weight || 0;

			chart.boxes.push(item);
		},

		/**
   * Remove a layoutItem from a chart
   * @param {Chart} chart - the chart to remove the box from
   * @param {Object} layoutItem - the item to remove from the layout
   */
		removeBox: function removeBox(chart, layoutItem) {
			var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
			if (index !== -1) {
				chart.boxes.splice(index, 1);
			}
		},

		/**
   * Sets (or updates) options on the given `item`.
   * @param {Chart} chart - the chart in which the item lives (or will be added to)
   * @param {Object} item - the item to configure with the given options
   * @param {Object} options - the new item options.
   */
		configure: function configure(chart, item, options) {
			var props = ['fullWidth', 'position', 'weight'];
			var ilen = props.length;
			var i = 0;
			var prop;

			for (; i < ilen; ++i) {
				prop = props[i];
				if (options.hasOwnProperty(prop)) {
					item[prop] = options[prop];
				}
			}
		},

		/**
   * Fits boxes of the given chart into the given size by having each box measure itself
   * then running a fitting algorithm
   * @param {Chart} chart - the chart
   * @param {Number} width - the width to fit into
   * @param {Number} height - the height to fit into
   */
		update: function update(chart, width, height) {
			if (!chart) {
				return;
			}

			var layoutOptions = chart.options.layout || {};
			var padding = helpers.options.toPadding(layoutOptions.padding);
			var leftPadding = padding.left;
			var rightPadding = padding.right;
			var topPadding = padding.top;
			var bottomPadding = padding.bottom;

			var leftBoxes = filterByPosition(chart.boxes, 'left');
			var rightBoxes = filterByPosition(chart.boxes, 'right');
			var topBoxes = filterByPosition(chart.boxes, 'top');
			var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
			var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

			// Sort boxes by weight. A higher weight is further away from the chart area
			sortByWeight(leftBoxes, true);
			sortByWeight(rightBoxes, false);
			sortByWeight(topBoxes, true);
			sortByWeight(bottomBoxes, false);

			// Essentially we now have any number of boxes on each of the 4 sides.
			// Our canvas looks like the following.
			// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
			// B1 is the bottom axis
			// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
			// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
			// an error will be thrown.
			//
			// |----------------------------------------------------|
			// |                  T1 (Full Width)                   |
			// |----------------------------------------------------|
			// |    |    |                 T2                  |    |
			// |    |----|-------------------------------------|----|
			// |    |    | C1 |                           | C2 |    |
			// |    |    |----|                           |----|    |
			// |    |    |                                     |    |
			// | L1 | L2 |           ChartArea (C0)            | R1 |
			// |    |    |                                     |    |
			// |    |    |----|                           |----|    |
			// |    |    | C3 |                           | C4 |    |
			// |    |----|-------------------------------------|----|
			// |    |    |                 B1                  |    |
			// |----------------------------------------------------|
			// |                  B2 (Full Width)                   |
			// |----------------------------------------------------|
			//
			// What we do to find the best sizing, we do the following
			// 1. Determine the minimum size of the chart area.
			// 2. Split the remaining width equally between each vertical axis
			// 3. Split the remaining height equally between each horizontal axis
			// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
			// 5. Adjust the sizes of each axis based on it's minimum reported size.
			// 6. Refit each axis
			// 7. Position each axis in the final location
			// 8. Tell the chart the final location of the chart area
			// 9. Tell any axes that overlay the chart area the positions of the chart area

			// Step 1
			var chartWidth = width - leftPadding - rightPadding;
			var chartHeight = height - topPadding - bottomPadding;
			var chartAreaWidth = chartWidth / 2; // min 50%
			var chartAreaHeight = chartHeight / 2; // min 50%

			// Step 2
			var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

			// Step 3
			var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

			// Step 4
			var maxChartAreaWidth = chartWidth;
			var maxChartAreaHeight = chartHeight;
			var minBoxSizes = [];

			function getMinimumBoxSize(box) {
				var minSize;
				var isHorizontal = box.isHorizontal();

				if (isHorizontal) {
					minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
					maxChartAreaHeight -= minSize.height;
				} else {
					minSize = box.update(verticalBoxWidth, chartAreaHeight);
					maxChartAreaWidth -= minSize.width;
				}

				minBoxSizes.push({
					horizontal: isHorizontal,
					minSize: minSize,
					box: box
				});
			}

			helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

			// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
			var maxHorizontalLeftPadding = 0;
			var maxHorizontalRightPadding = 0;
			var maxVerticalTopPadding = 0;
			var maxVerticalBottomPadding = 0;

			helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {
				if (horizontalBox.getPadding) {
					var boxPadding = horizontalBox.getPadding();
					maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
					maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
				}
			});

			helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {
				if (verticalBox.getPadding) {
					var boxPadding = verticalBox.getPadding();
					maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
					maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
				}
			});

			// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
			// be if the axes are drawn at their minimum sizes.
			// Steps 5 & 6
			var totalLeftBoxesWidth = leftPadding;
			var totalRightBoxesWidth = rightPadding;
			var totalTopBoxesHeight = topPadding;
			var totalBottomBoxesHeight = bottomPadding;

			// Function to fit a box
			function fitBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {
					return minBox.box === box;
				});

				if (minBoxSize) {
					if (box.isHorizontal()) {
						var scaleMargin = {
							left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
							right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
							top: 0,
							bottom: 0
						};

						// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
						// on the margin. Sometimes they need to increase in size slightly
						box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
					} else {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight);
					}
				}
			}

			// Update, and calculate the left and right margins for the horizontal boxes
			helpers.each(leftBoxes.concat(rightBoxes), fitBox);

			helpers.each(leftBoxes, function (box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function (box) {
				totalRightBoxesWidth += box.width;
			});

			// Set the Left and Right margins for the horizontal boxes
			helpers.each(topBoxes.concat(bottomBoxes), fitBox);

			// Figure out how much margin is on the top and bottom of the vertical boxes
			helpers.each(topBoxes, function (box) {
				totalTopBoxesHeight += box.height;
			});

			helpers.each(bottomBoxes, function (box) {
				totalBottomBoxesHeight += box.height;
			});

			function finalFitVerticalBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {
					return minSize.box === box;
				});

				var scaleMargin = {
					left: 0,
					right: 0,
					top: totalTopBoxesHeight,
					bottom: totalBottomBoxesHeight
				};

				if (minBoxSize) {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
				}
			}

			// Let the left layout know the final margin
			helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

			// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
			totalLeftBoxesWidth = leftPadding;
			totalRightBoxesWidth = rightPadding;
			totalTopBoxesHeight = topPadding;
			totalBottomBoxesHeight = bottomPadding;

			helpers.each(leftBoxes, function (box) {
				totalLeftBoxesWidth += box.width;
			});

			helpers.each(rightBoxes, function (box) {
				totalRightBoxesWidth += box.width;
			});

			helpers.each(topBoxes, function (box) {
				totalTopBoxesHeight += box.height;
			});
			helpers.each(bottomBoxes, function (box) {
				totalBottomBoxesHeight += box.height;
			});

			// We may be adding some padding to account for rotated x axis labels
			var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
			totalLeftBoxesWidth += leftPaddingAddition;
			totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

			var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
			totalTopBoxesHeight += topPaddingAddition;
			totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

			// Figure out if our chart area changed. This would occur if the dataset layout label rotation
			// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
			// without calling `fit` again
			var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
			var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

			if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
				helpers.each(leftBoxes, function (box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(rightBoxes, function (box) {
					box.height = newMaxChartAreaHeight;
				});

				helpers.each(topBoxes, function (box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				helpers.each(bottomBoxes, function (box) {
					if (!box.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});

				maxChartAreaHeight = newMaxChartAreaHeight;
				maxChartAreaWidth = newMaxChartAreaWidth;
			}

			// Step 7 - Position the boxes
			var left = leftPadding + leftPaddingAddition;
			var top = topPadding + topPaddingAddition;

			function placeBox(box) {
				if (box.isHorizontal()) {
					box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
					box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
					box.top = top;
					box.bottom = top + box.height;

					// Move to next point
					top = box.bottom;
				} else {

					box.left = left;
					box.right = left + box.width;
					box.top = totalTopBoxesHeight;
					box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

					// Move to next point
					left = box.right;
				}
			}

			helpers.each(leftBoxes.concat(topBoxes), placeBox);

			// Account for chart width and height
			left += maxChartAreaWidth;
			top += maxChartAreaHeight;

			helpers.each(rightBoxes, placeBox);
			helpers.each(bottomBoxes, placeBox);

			// Step 8
			chart.chartArea = {
				left: totalLeftBoxesWidth,
				top: totalTopBoxesHeight,
				right: totalLeftBoxesWidth + maxChartAreaWidth,
				bottom: totalTopBoxesHeight + maxChartAreaHeight
			};

			// Step 9
			helpers.each(chartAreaBoxes, function (box) {
				box.left = chart.chartArea.left;
				box.top = chart.chartArea.top;
				box.right = chart.chartArea.right;
				box.bottom = chart.chartArea.bottom;

				box.update(maxChartAreaWidth, maxChartAreaHeight);
			});
		}
	};
};

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	plugins: {}
});

module.exports = function (Chart) {

	/**
  * The plugin service singleton
  * @namespace Chart.plugins
  * @since 2.1.0
  */
	Chart.plugins = {
		/**
   * Globally registered plugins.
   * @private
   */
		_plugins: [],

		/**
   * This identifier is used to invalidate the descriptors cache attached to each chart
   * when a global plugin is registered or unregistered. In this case, the cache ID is
   * incremented and descriptors are regenerated during following API calls.
   * @private
   */
		_cacheId: 0,

		/**
   * Registers the given plugin(s) if not already registered.
   * @param {Array|Object} plugins plugin instance(s).
   */
		register: function register(plugins) {
			var p = this._plugins;
			[].concat(plugins).forEach(function (plugin) {
				if (p.indexOf(plugin) === -1) {
					p.push(plugin);
				}
			});

			this._cacheId++;
		},

		/**
   * Unregisters the given plugin(s) only if registered.
   * @param {Array|Object} plugins plugin instance(s).
   */
		unregister: function unregister(plugins) {
			var p = this._plugins;
			[].concat(plugins).forEach(function (plugin) {
				var idx = p.indexOf(plugin);
				if (idx !== -1) {
					p.splice(idx, 1);
				}
			});

			this._cacheId++;
		},

		/**
   * Remove all registered plugins.
   * @since 2.1.5
   */
		clear: function clear() {
			this._plugins = [];
			this._cacheId++;
		},

		/**
   * Returns the number of registered plugins?
   * @returns {Number}
   * @since 2.1.5
   */
		count: function count() {
			return this._plugins.length;
		},

		/**
   * Returns all registered plugin instances.
   * @returns {Array} array of plugin objects.
   * @since 2.1.5
   */
		getAll: function getAll() {
			return this._plugins;
		},

		/**
   * Calls enabled plugins for `chart` on the specified hook and with the given args.
   * This method immediately returns as soon as a plugin explicitly returns false. The
   * returned value can be used, for instance, to interrupt the current action.
   * @param {Object} chart - The chart instance for which plugins should be called.
   * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
   * @param {Array} [args] - Extra arguments to apply to the hook call.
   * @returns {Boolean} false if any of the plugins return false, else returns true.
   */
		notify: function notify(chart, hook, args) {
			var descriptors = this.descriptors(chart);
			var ilen = descriptors.length;
			var i, descriptor, plugin, params, method;

			for (i = 0; i < ilen; ++i) {
				descriptor = descriptors[i];
				plugin = descriptor.plugin;
				method = plugin[hook];
				if (typeof method === 'function') {
					params = [chart].concat(args || []);
					params.push(descriptor.options);
					if (method.apply(plugin, params) === false) {
						return false;
					}
				}
			}

			return true;
		},

		/**
   * Returns descriptors of enabled plugins for the given chart.
   * @returns {Array} [{ plugin, options }]
   * @private
   */
		descriptors: function descriptors(chart) {
			var cache = chart._plugins || (chart._plugins = {});
			if (cache.id === this._cacheId) {
				return cache.descriptors;
			}

			var plugins = [];
			var descriptors = [];
			var config = chart && chart.config || {};
			var options = config.options && config.options.plugins || {};

			this._plugins.concat(config.plugins || []).forEach(function (plugin) {
				var idx = plugins.indexOf(plugin);
				if (idx !== -1) {
					return;
				}

				var id = plugin.id;
				var opts = options[id];
				if (opts === false) {
					return;
				}

				if (opts === true) {
					opts = helpers.clone(defaults.global.plugins[id]);
				}

				plugins.push(plugin);
				descriptors.push({
					plugin: plugin,
					options: opts || {}
				});
			});

			cache.descriptors = descriptors;
			cache.id = this._cacheId;
			return descriptors;
		}
	};

	/**
  * Plugin extension hooks.
  * @interface IPlugin
  * @since 2.1.0
  */
	/**
  * @method IPlugin#beforeInit
  * @desc Called before initializing `chart`.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#afterInit
  * @desc Called after `chart` has been initialized and before the first update.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeUpdate
  * @desc Called before updating `chart`. If any plugin returns `false`, the update
  * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart update.
  */
	/**
  * @method IPlugin#afterUpdate
  * @desc Called after `chart` has been updated and before rendering. Note that this
  * hook will not be called if the chart update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeDatasetsUpdate
 	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
  * the datasets update is cancelled until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} false to cancel the datasets update.
  * @since version 2.1.5
  */
	/**
  * @method IPlugin#afterDatasetsUpdate
  * @desc Called after the `chart` datasets have been updated. Note that this hook
  * will not be called if the datasets update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @since version 2.1.5
  */
	/**
  * @method IPlugin#beforeDatasetUpdate
 	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
  * returns `false`, the datasets update is cancelled until another `update` is triggered.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
	/**
  * @method IPlugin#afterDatasetUpdate
 	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
  * that this hook will not be called if the datasets update has been previously cancelled.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeLayout
  * @desc Called before laying out `chart`. If any plugin returns `false`,
  * the layout update is cancelled until another `update` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart layout.
  */
	/**
  * @method IPlugin#afterLayout
  * @desc Called after the `chart` has been layed out. Note that this hook will not
  * be called if the layout update has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeRender
  * @desc Called before rendering `chart`. If any plugin returns `false`,
  * the rendering is cancelled until another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart rendering.
  */
	/**
  * @method IPlugin#afterRender
  * @desc Called after the `chart` has been fully rendered (and animation completed). Note
  * that this hook will not be called if the rendering has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeDraw
  * @desc Called before drawing `chart` at every animation frame specified by the given
  * easing value. If any plugin returns `false`, the frame drawing is cancelled until
  * another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart drawing.
  */
	/**
  * @method IPlugin#afterDraw
  * @desc Called after the `chart` has been drawn for the specific easing value. Note
  * that this hook will not be called if the drawing has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeDatasetsDraw
 	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
  * the datasets drawing is cancelled until another `render` is triggered.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
	/**
  * @method IPlugin#afterDatasetsDraw
  * @desc Called after the `chart` datasets have been drawn. Note that this hook
  * will not be called if the datasets drawing has been previously cancelled.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeDatasetDraw
 	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
  * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
  * is cancelled until another `render` is triggered.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  * @returns {Boolean} `false` to cancel the chart datasets drawing.
  */
	/**
  * @method IPlugin#afterDatasetDraw
 	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
  * (datasets are drawn in the reverse order). Note that this hook will not be called
  * if the datasets drawing has been previously cancelled.
  * @param {Chart} chart - The chart instance.
  * @param {Object} args - The call arguments.
  * @param {Number} args.index - The dataset index.
  * @param {Object} args.meta - The dataset metadata.
  * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#beforeEvent
 	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
  * the event will be discarded.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {IEvent} event - The event object.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#afterEvent
  * @desc Called after the `event` has been consumed. Note that this hook
  * will not be called if the `event` has been previously discarded.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {IEvent} event - The event object.
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#resize
  * @desc Called after the chart as been resized.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
  * @param {Object} options - The plugin options.
  */
	/**
  * @method IPlugin#destroy
  * @desc Called after the chart as been destroyed.
  * @param {Chart.Controller} chart - The chart instance.
  * @param {Object} options - The plugin options.
  */

	/**
  * Provided for backward compatibility, use Chart.plugins instead
  * @namespace Chart.pluginService
  * @deprecated since version 2.1.5
  * @todo remove at version 3
  * @private
  */
	Chart.pluginService = Chart.plugins;

	/**
  * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
  * effect, instead simply create/register plugins via plain JavaScript objects.
  * @interface Chart.PluginBase
  * @deprecated since version 2.5.0
  * @todo remove at version 3
  * @private
  */
	Chart.PluginBase = Element.extend({});
};

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);
var Ticks = __webpack_require__(75);

defaults._set('scale', {
	display: true,
	position: 'left',
	offset: false,

	// grid line settings
	gridLines: {
		display: true,
		color: 'rgba(0, 0, 0, 0.1)',
		lineWidth: 1,
		drawBorder: true,
		drawOnChartArea: true,
		drawTicks: true,
		tickMarkLength: 10,
		zeroLineWidth: 1,
		zeroLineColor: 'rgba(0,0,0,0.25)',
		zeroLineBorderDash: [],
		zeroLineBorderDashOffset: 0.0,
		offsetGridLines: false,
		borderDash: [],
		borderDashOffset: 0.0
	},

	// scale label
	scaleLabel: {
		// display property
		display: false,

		// actual label
		labelString: '',

		// line height
		lineHeight: 1.2,

		// top/bottom padding
		padding: {
			top: 4,
			bottom: 4
		}
	},

	// label settings
	ticks: {
		beginAtZero: false,
		minRotation: 0,
		maxRotation: 50,
		mirror: false,
		padding: 0,
		reverse: false,
		display: true,
		autoSkip: true,
		autoSkipPadding: 0,
		labelOffset: 0,
		// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
		callback: Ticks.formatters.values,
		minor: {},
		major: {}
	}
});

function labelsFromTicks(ticks) {
	var labels = [];
	var i, ilen;

	for (i = 0, ilen = ticks.length; i < ilen; ++i) {
		labels.push(ticks[i].label);
	}

	return labels;
}

function getLineValue(scale, index, offsetGridLines) {
	var lineValue = scale.getPixelForTick(index);

	if (offsetGridLines) {
		if (index === 0) {
			lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
		} else {
			lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
		}
	}
	return lineValue;
}

module.exports = function (Chart) {

	function computeTextSize(context, tick, font) {
		return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;
	}

	function parseFontOptions(options) {
		var valueOrDefault = helpers.valueOrDefault;
		var globalDefaults = defaults.global;
		var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
		var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
		var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

		return {
			size: size,
			style: style,
			family: family,
			font: helpers.fontString(size, style, family)
		};
	}

	function parseLineHeight(options) {
		return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
	}

	Chart.Scale = Element.extend({
		/**
   * Get the padding needed for the scale
   * @method getPadding
   * @private
   * @returns {Padding} the necessary padding
   */
		getPadding: function getPadding() {
			var me = this;
			return {
				left: me.paddingLeft || 0,
				top: me.paddingTop || 0,
				right: me.paddingRight || 0,
				bottom: me.paddingBottom || 0
			};
		},

		/**
   * Returns the scale tick objects ({label, major})
   * @since 2.7
   */
		getTicks: function getTicks() {
			return this._ticks;
		},

		// These methods are ordered by lifecyle. Utilities then follow.
		// Any function defined here is inherited by all scale types.
		// Any function can be extended by the scale type

		mergeTicksOptions: function mergeTicksOptions() {
			var ticks = this.options.ticks;
			if (ticks.minor === false) {
				ticks.minor = {
					display: false
				};
			}
			if (ticks.major === false) {
				ticks.major = {
					display: false
				};
			}
			for (var key in ticks) {
				if (key !== 'major' && key !== 'minor') {
					if (typeof ticks.minor[key] === 'undefined') {
						ticks.minor[key] = ticks[key];
					}
					if (typeof ticks.major[key] === 'undefined') {
						ticks.major[key] = ticks[key];
					}
				}
			}
		},
		beforeUpdate: function beforeUpdate() {
			helpers.callback(this.options.beforeUpdate, [this]);
		},
		update: function update(maxWidth, maxHeight, margins) {
			var me = this;
			var i, ilen, labels, label, ticks, tick;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = helpers.extend({
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, margins);
			me.longestTextCache = me.longestTextCache || {};

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();

			// Data min/max
			me.beforeDataLimits();
			me.determineDataLimits();
			me.afterDataLimits();

			// Ticks - `this.ticks` is now DEPRECATED!
			// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
			// and must not be accessed directly from outside this class. `this.ticks` being
			// around for long time and not marked as private, we can't change its structure
			// without unexpected breaking changes. If you need to access the scale ticks,
			// use scale.getTicks() instead.

			me.beforeBuildTicks();

			// New implementations should return an array of objects but for BACKWARD COMPAT,
			// we still support no return (`this.ticks` internally set by calling this method).
			ticks = me.buildTicks() || [];

			me.afterBuildTicks();

			me.beforeTickToLabelConversion();

			// New implementations should return the formatted tick labels but for BACKWARD
			// COMPAT, we still support no return (`this.ticks` internally changed by calling
			// this method and supposed to contain only string values).
			labels = me.convertTicksToLabels(ticks) || me.ticks;

			me.afterTickToLabelConversion();

			me.ticks = labels; // BACKWARD COMPATIBILITY

			// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

			// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
			for (i = 0, ilen = labels.length; i < ilen; ++i) {
				label = labels[i];
				tick = ticks[i];
				if (!tick) {
					ticks.push(tick = {
						label: label,
						major: false
					});
				} else {
					tick.label = label;
				}
			}

			me._ticks = ticks;

			// Tick Rotation
			me.beforeCalculateTickRotation();
			me.calculateTickRotation();
			me.afterCalculateTickRotation();
			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: function afterUpdate() {
			helpers.callback(this.options.afterUpdate, [this]);
		},

		//

		beforeSetDimensions: function beforeSetDimensions() {
			helpers.callback(this.options.beforeSetDimensions, [this]);
		},
		setDimensions: function setDimensions() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;
		},
		afterSetDimensions: function afterSetDimensions() {
			helpers.callback(this.options.afterSetDimensions, [this]);
		},

		// Data limits
		beforeDataLimits: function beforeDataLimits() {
			helpers.callback(this.options.beforeDataLimits, [this]);
		},
		determineDataLimits: helpers.noop,
		afterDataLimits: function afterDataLimits() {
			helpers.callback(this.options.afterDataLimits, [this]);
		},

		//
		beforeBuildTicks: function beforeBuildTicks() {
			helpers.callback(this.options.beforeBuildTicks, [this]);
		},
		buildTicks: helpers.noop,
		afterBuildTicks: function afterBuildTicks() {
			helpers.callback(this.options.afterBuildTicks, [this]);
		},

		beforeTickToLabelConversion: function beforeTickToLabelConversion() {
			helpers.callback(this.options.beforeTickToLabelConversion, [this]);
		},
		convertTicksToLabels: function convertTicksToLabels() {
			var me = this;
			// Convert ticks to strings
			var tickOpts = me.options.ticks;
			me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
		},
		afterTickToLabelConversion: function afterTickToLabelConversion() {
			helpers.callback(this.options.afterTickToLabelConversion, [this]);
		},

		//

		beforeCalculateTickRotation: function beforeCalculateTickRotation() {
			helpers.callback(this.options.beforeCalculateTickRotation, [this]);
		},
		calculateTickRotation: function calculateTickRotation() {
			var me = this;
			var context = me.ctx;
			var tickOpts = me.options.ticks;
			var labels = labelsFromTicks(me._ticks);

			// Get the width of each grid by calculating the difference
			// between x offsets between 0 and 1.
			var tickFont = parseFontOptions(tickOpts);
			context.font = tickFont.font;

			var labelRotation = tickOpts.minRotation || 0;

			if (labels.length && me.options.display && me.isHorizontal()) {
				var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
				var labelWidth = originalLabelWidth;
				var cosRotation, sinRotation;

				// Allow 3 pixels x2 padding either side for label readability
				var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

				// Max label rotation can be set or default to 90 - also act as a loop counter
				while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
					var angleRadians = helpers.toRadians(labelRotation);
					cosRotation = Math.cos(angleRadians);
					sinRotation = Math.sin(angleRadians);

					if (sinRotation * originalLabelWidth > me.maxHeight) {
						// go back one step
						labelRotation--;
						break;
					}

					labelRotation++;
					labelWidth = cosRotation * originalLabelWidth;
				}
			}

			me.labelRotation = labelRotation;
		},
		afterCalculateTickRotation: function afterCalculateTickRotation() {
			helpers.callback(this.options.afterCalculateTickRotation, [this]);
		},

		//

		beforeFit: function beforeFit() {
			helpers.callback(this.options.beforeFit, [this]);
		},
		fit: function fit() {
			var me = this;
			// Reset
			var minSize = me.minSize = {
				width: 0,
				height: 0
			};

			var labels = labelsFromTicks(me._ticks);

			var opts = me.options;
			var tickOpts = opts.ticks;
			var scaleLabelOpts = opts.scaleLabel;
			var gridLineOpts = opts.gridLines;
			var display = opts.display;
			var isHorizontal = me.isHorizontal();

			var tickFont = parseFontOptions(tickOpts);
			var tickMarkLength = opts.gridLines.tickMarkLength;

			// Width
			if (isHorizontal) {
				// subtract the margins to line up with the chartArea if we are a full width scale
				minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
			} else {
				minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			}

			// height
			if (isHorizontal) {
				minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			} else {
				minSize.height = me.maxHeight; // fill all the height
			}

			// Are we showing a title for the scale?
			if (scaleLabelOpts.display && display) {
				var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
				var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
				var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

				if (isHorizontal) {
					minSize.height += deltaHeight;
				} else {
					minSize.width += deltaHeight;
				}
			}

			// Don't bother fitting the ticks if we are not showing them
			if (tickOpts.display && display) {
				var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
				var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
				var lineSpace = tickFont.size * 0.5;
				var tickPadding = me.options.ticks.padding;

				if (isHorizontal) {
					// A horizontal axis is more constrained by the height.
					me.longestLabelWidth = largestTextWidth;

					var angleRadians = helpers.toRadians(me.labelRotation);
					var cosRotation = Math.cos(angleRadians);
					var sinRotation = Math.sin(angleRadians);

					// TODO - improve this calculation
					var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding

					minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

					me.ctx.font = tickFont.font;
					var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
					var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

					// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
					// which means that the right padding is dominated by the font height
					if (me.labelRotation !== 0) {
						me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges
						me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;
					} else {
						me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
						me.paddingRight = lastLabelWidth / 2 + 3;
					}
				} else {
					// A vertical axis is more constrained by the width. Labels are the
					// dominant factor here, so get that length first and account for padding
					if (tickOpts.mirror) {
						largestTextWidth = 0;
					} else {
						// use lineSpace for consistency with horizontal axis
						// tickPadding is not implemented for horizontal
						largestTextWidth += tickPadding + lineSpace;
					}

					minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

					me.paddingTop = tickFont.size / 2;
					me.paddingBottom = tickFont.size / 2;
				}
			}

			me.handleMargins();

			me.width = minSize.width;
			me.height = minSize.height;
		},

		/**
   * Handle margins and padding interactions
   * @private
   */
		handleMargins: function handleMargins() {
			var me = this;
			if (me.margins) {
				me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
				me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
				me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
				me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
			}
		},

		afterFit: function afterFit() {
			helpers.callback(this.options.afterFit, [this]);
		},

		// Shared Methods
		isHorizontal: function isHorizontal() {
			return this.options.position === 'top' || this.options.position === 'bottom';
		},
		isFullWidth: function isFullWidth() {
			return this.options.fullWidth;
		},

		// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
		getRightValue: function getRightValue(rawValue) {
			// Null and undefined values first
			if (helpers.isNullOrUndef(rawValue)) {
				return NaN;
			}
			// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
			if (typeof rawValue === 'number' && !isFinite(rawValue)) {
				return NaN;
			}
			// If it is in fact an object, dive in one more level
			if (rawValue) {
				if (this.isHorizontal()) {
					if (rawValue.x !== undefined) {
						return this.getRightValue(rawValue.x);
					}
				} else if (rawValue.y !== undefined) {
					return this.getRightValue(rawValue.y);
				}
			}

			// Value is good, return it
			return rawValue;
		},

		// Used to get the value to display in the tooltip for the data at the given index
		// function getLabelForIndex(index, datasetIndex)
		getLabelForIndex: helpers.noop,

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: helpers.noop,

		// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
		getValueForPixel: helpers.noop,

		// Used for tick location, should
		getPixelForTick: function getPixelForTick(index) {
			var me = this;
			var offset = me.options.offset;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
				var pixel = tickWidth * index + me.paddingLeft;

				if (offset) {
					pixel += tickWidth / 2;
				}

				var finalVal = me.left + Math.round(pixel);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			}
			var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
			return me.top + index * (innerHeight / (me._ticks.length - 1));
		},

		// Utility for getting the pixel location of a percentage of scale
		getPixelForDecimal: function getPixelForDecimal(decimal) {
			var me = this;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueOffset = innerWidth * decimal + me.paddingLeft;

				var finalVal = me.left + Math.round(valueOffset);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			}
			return me.top + decimal * me.height;
		},

		getBasePixel: function getBasePixel() {
			return this.getPixelForValue(this.getBaseValue());
		},

		getBaseValue: function getBaseValue() {
			var me = this;
			var min = me.min;
			var max = me.max;

			return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
		},

		/**
   * Returns a subset of ticks to be plotted to avoid overlapping labels.
   * @private
   */
		_autoSkip: function _autoSkip(ticks) {
			var skipRatio;
			var me = this;
			var isHorizontal = me.isHorizontal();
			var optionTicks = me.options.ticks.minor;
			var tickCount = ticks.length;
			var labelRotationRadians = helpers.toRadians(me.labelRotation);
			var cosRotation = Math.cos(labelRotationRadians);
			var longestRotatedLabel = me.longestLabelWidth * cosRotation;
			var result = [];
			var i, tick, shouldSkip;

			// figure out the maximum number of gridlines to show
			var maxTicks;
			if (optionTicks.maxTicksLimit) {
				maxTicks = optionTicks.maxTicksLimit;
			}

			if (isHorizontal) {
				skipRatio = false;

				if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {
					skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));
				}

				// if they defined a max number of optionTicks,
				// increase skipRatio until that number is met
				if (maxTicks && tickCount > maxTicks) {
					skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
				}
			}

			for (i = 0; i < tickCount; i++) {
				tick = ticks[i];

				// Since we always show the last tick,we need may need to hide the last shown one before
				shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;
				if (shouldSkip && i !== tickCount - 1 || helpers.isNullOrUndef(tick.label)) {
					// leave tick in place but make sure it's not displayed (#4635)
					delete tick.label;
				}
				result.push(tick);
			}
			return result;
		},

		// Actually draw the scale on the canvas
		// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
		draw: function draw(chartArea) {
			var me = this;
			var options = me.options;
			if (!options.display) {
				return;
			}

			var context = me.ctx;
			var globalDefaults = defaults.global;
			var optionTicks = options.ticks.minor;
			var optionMajorTicks = options.ticks.major || optionTicks;
			var gridLines = options.gridLines;
			var scaleLabel = options.scaleLabel;

			var isRotated = me.labelRotation !== 0;
			var isHorizontal = me.isHorizontal();

			var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
			var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
			var tickFont = parseFontOptions(optionTicks);
			var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
			var majorTickFont = parseFontOptions(optionMajorTicks);

			var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

			var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
			var scaleLabelFont = parseFontOptions(scaleLabel);
			var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
			var labelRotationRadians = helpers.toRadians(me.labelRotation);

			var itemsToDraw = [];

			var xTickStart = options.position === 'right' ? me.left : me.right - tl;
			var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
			var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
			var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;

			helpers.each(ticks, function (tick, index) {
				// autoskipper skipped this tick (#4635)
				if (tick.label === undefined) {
					return;
				}

				var label = tick.label;
				var lineWidth, lineColor, borderDash, borderDashOffset;
				if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
					// Draw the first index specially
					lineWidth = gridLines.zeroLineWidth;
					lineColor = gridLines.zeroLineColor;
					borderDash = gridLines.zeroLineBorderDash;
					borderDashOffset = gridLines.zeroLineBorderDashOffset;
				} else {
					lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
					lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
					borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
					borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
				}

				// Common properties
				var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
				var textAlign = 'middle';
				var textBaseline = 'middle';
				var tickPadding = optionTicks.padding;

				if (isHorizontal) {
					var labelYOffset = tl + tickPadding;

					if (options.position === 'bottom') {
						// bottom
						textBaseline = !isRotated ? 'top' : 'middle';
						textAlign = !isRotated ? 'center' : 'right';
						labelY = me.top + labelYOffset;
					} else {
						// top
						textBaseline = !isRotated ? 'bottom' : 'middle';
						textAlign = !isRotated ? 'center' : 'left';
						labelY = me.bottom - labelYOffset;
					}

					var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
					if (xLineValue < me.left) {
						lineColor = 'rgba(0,0,0,0)';
					}
					xLineValue += helpers.aliasPixel(lineWidth);

					labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

					tx1 = tx2 = x1 = x2 = xLineValue;
					ty1 = yTickStart;
					ty2 = yTickEnd;
					y1 = chartArea.top;
					y2 = chartArea.bottom;
				} else {
					var isLeft = options.position === 'left';
					var labelXOffset;

					if (optionTicks.mirror) {
						textAlign = isLeft ? 'left' : 'right';
						labelXOffset = tickPadding;
					} else {
						textAlign = isLeft ? 'right' : 'left';
						labelXOffset = tl + tickPadding;
					}

					labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

					var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
					if (yLineValue < me.top) {
						lineColor = 'rgba(0,0,0,0)';
					}
					yLineValue += helpers.aliasPixel(lineWidth);

					labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

					tx1 = xTickStart;
					tx2 = xTickEnd;
					x1 = chartArea.left;
					x2 = chartArea.right;
					ty1 = ty2 = y1 = y2 = yLineValue;
				}

				itemsToDraw.push({
					tx1: tx1,
					ty1: ty1,
					tx2: tx2,
					ty2: ty2,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
					labelX: labelX,
					labelY: labelY,
					glWidth: lineWidth,
					glColor: lineColor,
					glBorderDash: borderDash,
					glBorderDashOffset: borderDashOffset,
					rotation: -1 * labelRotationRadians,
					label: label,
					major: tick.major,
					textBaseline: textBaseline,
					textAlign: textAlign
				});
			});

			// Draw all of the tick labels, tick marks, and grid lines at the correct places
			helpers.each(itemsToDraw, function (itemToDraw) {
				if (gridLines.display) {
					context.save();
					context.lineWidth = itemToDraw.glWidth;
					context.strokeStyle = itemToDraw.glColor;
					if (context.setLineDash) {
						context.setLineDash(itemToDraw.glBorderDash);
						context.lineDashOffset = itemToDraw.glBorderDashOffset;
					}

					context.beginPath();

					if (gridLines.drawTicks) {
						context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
						context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
					}

					if (gridLines.drawOnChartArea) {
						context.moveTo(itemToDraw.x1, itemToDraw.y1);
						context.lineTo(itemToDraw.x2, itemToDraw.y2);
					}

					context.stroke();
					context.restore();
				}

				if (optionTicks.display) {
					// Make sure we draw text in the correct color and font
					context.save();
					context.translate(itemToDraw.labelX, itemToDraw.labelY);
					context.rotate(itemToDraw.rotation);
					context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
					context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
					context.textBaseline = itemToDraw.textBaseline;
					context.textAlign = itemToDraw.textAlign;

					var label = itemToDraw.label;
					if (helpers.isArray(label)) {
						for (var i = 0, y = 0; i < label.length; ++i) {
							// We just make sure the multiline element is a string here..
							context.fillText('' + label[i], 0, y);
							// apply same lineSpacing as calculated @ L#320
							y += tickFont.size * 1.5;
						}
					} else {
						context.fillText(label, 0, 0);
					}
					context.restore();
				}
			});

			if (scaleLabel.display) {
				// Draw the scale label
				var scaleLabelX;
				var scaleLabelY;
				var rotation = 0;
				var halfLineHeight = parseLineHeight(scaleLabel) / 2;

				if (isHorizontal) {
					scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width
					scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
				} else {
					var isLeft = options.position === 'left';
					scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
					scaleLabelY = me.top + (me.bottom - me.top) / 2;
					rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
				}

				context.save();
				context.translate(scaleLabelX, scaleLabelY);
				context.rotate(rotation);
				context.textAlign = 'center';
				context.textBaseline = 'middle';
				context.fillStyle = scaleLabelFontColor; // render in correct colour
				context.font = scaleLabelFont.font;
				context.fillText(scaleLabel.labelString, 0, 0);
				context.restore();
			}

			if (gridLines.drawBorder) {
				// Draw the line at the edge of the axis
				context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
				context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
				var x1 = me.left;
				var x2 = me.right;
				var y1 = me.top;
				var y2 = me.bottom;

				var aliasPixel = helpers.aliasPixel(context.lineWidth);
				if (isHorizontal) {
					y1 = y2 = options.position === 'top' ? me.bottom : me.top;
					y1 += aliasPixel;
					y2 += aliasPixel;
				} else {
					x1 = x2 = options.position === 'left' ? me.right : me.left;
					x1 += aliasPixel;
					x2 += aliasPixel;
				}

				context.beginPath();
				context.moveTo(x1, y1);
				context.lineTo(x2, y2);
				context.stroke();
			}
		}
	});
};

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);

module.exports = function (Chart) {

	Chart.scaleService = {
		// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
		// use the new chart options to grab the correct scale
		constructors: {},
		// Use a registration function so that we can move to an ES6 map when we no longer need to support
		// old browsers

		// Scale config defaults
		defaults: {},
		registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
			this.constructors[type] = scaleConstructor;
			this.defaults[type] = helpers.clone(scaleDefaults);
		},
		getScaleConstructor: function getScaleConstructor(type) {
			return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
		},
		getScaleDefaults: function getScaleDefaults(type) {
			// Return the scale defaults merged with the global settings so that we always use the latest ones
			return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
		},
		updateScaleDefaults: function updateScaleDefaults(type, additions) {
			var me = this;
			if (me.defaults.hasOwnProperty(type)) {
				me.defaults[type] = helpers.extend(me.defaults[type], additions);
			}
		},
		addScalesToLayout: function addScalesToLayout(chart) {
			// Adds each scale to the chart.boxes array to be sized accordingly
			helpers.each(chart.scales, function (scale) {
				// Set ILayoutItem parameters for backwards compatibility
				scale.fullWidth = scale.options.fullWidth;
				scale.position = scale.options.position;
				scale.weight = scale.options.weight;
				Chart.layoutService.addBox(chart, scale);
			});
		}
	};
};

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	tooltips: {
		enabled: true,
		custom: null,
		mode: 'nearest',
		position: 'average',
		intersect: true,
		backgroundColor: 'rgba(0,0,0,0.8)',
		titleFontStyle: 'bold',
		titleSpacing: 2,
		titleMarginBottom: 6,
		titleFontColor: '#fff',
		titleAlign: 'left',
		bodySpacing: 2,
		bodyFontColor: '#fff',
		bodyAlign: 'left',
		footerFontStyle: 'bold',
		footerSpacing: 2,
		footerMarginTop: 6,
		footerFontColor: '#fff',
		footerAlign: 'left',
		yPadding: 6,
		xPadding: 6,
		caretPadding: 2,
		caretSize: 5,
		cornerRadius: 6,
		multiKeyBackground: '#fff',
		displayColors: true,
		borderColor: 'rgba(0,0,0,0)',
		borderWidth: 0,
		callbacks: {
			// Args are: (tooltipItems, data)
			beforeTitle: helpers.noop,
			title: function title(tooltipItems, data) {
				// Pick first xLabel for now
				var title = '';
				var labels = data.labels;
				var labelCount = labels ? labels.length : 0;

				if (tooltipItems.length > 0) {
					var item = tooltipItems[0];

					if (item.xLabel) {
						title = item.xLabel;
					} else if (labelCount > 0 && item.index < labelCount) {
						title = labels[item.index];
					}
				}

				return title;
			},
			afterTitle: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeBody: helpers.noop,

			// Args are: (tooltipItem, data)
			beforeLabel: helpers.noop,
			label: function label(tooltipItem, data) {
				var label = data.datasets[tooltipItem.datasetIndex].label || '';

				if (label) {
					label += ': ';
				}
				label += tooltipItem.yLabel;
				return label;
			},
			labelColor: function labelColor(tooltipItem, chart) {
				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				return {
					borderColor: view.borderColor,
					backgroundColor: view.backgroundColor
				};
			},
			labelTextColor: function labelTextColor() {
				return this._options.bodyFontColor;
			},
			afterLabel: helpers.noop,

			// Args are: (tooltipItems, data)
			afterBody: helpers.noop,

			// Args are: (tooltipItems, data)
			beforeFooter: helpers.noop,
			footer: helpers.noop,
			afterFooter: helpers.noop
		}
	}
});

module.exports = function (Chart) {

	/**
 	 * Helper method to merge the opacity into a color
 	 */
	function mergeOpacity(colorString, opacity) {
		var color = helpers.color(colorString);
		return color.alpha(opacity * color.alpha()).rgbaString();
	}

	// Helper to push or concat based on if the 2nd parameter is an array or not
	function pushOrConcat(base, toPush) {
		if (toPush) {
			if (helpers.isArray(toPush)) {
				// base = base.concat(toPush);
				Array.prototype.push.apply(base, toPush);
			} else {
				base.push(toPush);
			}
		}

		return base;
	}

	// Private helper to create a tooltip item model
	// @param element : the chart element (point, arc, bar) to create the tooltip item for
	// @return : new tooltip item
	function createTooltipItem(element) {
		var xScale = element._xScale;
		var yScale = element._yScale || element._scale; // handle radar || polarArea charts
		var index = element._index;
		var datasetIndex = element._datasetIndex;

		return {
			xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
			yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
			index: index,
			datasetIndex: datasetIndex,
			x: element._model.x,
			y: element._model.y
		};
	}

	/**
  * Helper to get the reset model for the tooltip
  * @param tooltipOpts {Object} the tooltip options
  */
	function getBaseModel(tooltipOpts) {
		var globalDefaults = defaults.global;
		var valueOrDefault = helpers.valueOrDefault;

		return {
			// Positioning
			xPadding: tooltipOpts.xPadding,
			yPadding: tooltipOpts.yPadding,
			xAlign: tooltipOpts.xAlign,
			yAlign: tooltipOpts.yAlign,

			// Body
			bodyFontColor: tooltipOpts.bodyFontColor,
			_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
			_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
			_bodyAlign: tooltipOpts.bodyAlign,
			bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
			bodySpacing: tooltipOpts.bodySpacing,

			// Title
			titleFontColor: tooltipOpts.titleFontColor,
			_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
			_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
			titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
			_titleAlign: tooltipOpts.titleAlign,
			titleSpacing: tooltipOpts.titleSpacing,
			titleMarginBottom: tooltipOpts.titleMarginBottom,

			// Footer
			footerFontColor: tooltipOpts.footerFontColor,
			_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
			_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
			footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
			_footerAlign: tooltipOpts.footerAlign,
			footerSpacing: tooltipOpts.footerSpacing,
			footerMarginTop: tooltipOpts.footerMarginTop,

			// Appearance
			caretSize: tooltipOpts.caretSize,
			cornerRadius: tooltipOpts.cornerRadius,
			backgroundColor: tooltipOpts.backgroundColor,
			opacity: 0,
			legendColorBackground: tooltipOpts.multiKeyBackground,
			displayColors: tooltipOpts.displayColors,
			borderColor: tooltipOpts.borderColor,
			borderWidth: tooltipOpts.borderWidth
		};
	}

	/**
  * Get the size of the tooltip
  */
	function getTooltipSize(tooltip, model) {
		var ctx = tooltip._chart.ctx;

		var height = model.yPadding * 2; // Tooltip Padding
		var width = 0;

		// Count of all lines in the body
		var body = model.body;
		var combinedBodyLength = body.reduce(function (count, bodyItem) {
			return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
		}, 0);
		combinedBodyLength += model.beforeBody.length + model.afterBody.length;

		var titleLineCount = model.title.length;
		var footerLineCount = model.footer.length;
		var titleFontSize = model.titleFontSize;
		var bodyFontSize = model.bodyFontSize;
		var footerFontSize = model.footerFontSize;

		height += titleLineCount * titleFontSize; // Title Lines
		height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
		height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
		height += combinedBodyLength * bodyFontSize; // Body Lines
		height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
		height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
		height += footerLineCount * footerFontSize; // Footer Lines
		height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

		// Title width
		var widthPadding = 0;
		var maxLineWidth = function maxLineWidth(line) {
			width = Math.max(width, ctx.measureText(line).width + widthPadding);
		};

		ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
		helpers.each(model.title, maxLineWidth);

		// Body width
		ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
		helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

		// Body lines may include some extra width due to the color box
		widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
		helpers.each(body, function (bodyItem) {
			helpers.each(bodyItem.before, maxLineWidth);
			helpers.each(bodyItem.lines, maxLineWidth);
			helpers.each(bodyItem.after, maxLineWidth);
		});

		// Reset back to 0
		widthPadding = 0;

		// Footer width
		ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
		helpers.each(model.footer, maxLineWidth);

		// Add padding
		width += 2 * model.xPadding;

		return {
			width: width,
			height: height
		};
	}

	/**
  * Helper to get the alignment of a tooltip given the size
  */
	function determineAlignment(tooltip, size) {
		var model = tooltip._model;
		var chart = tooltip._chart;
		var chartArea = tooltip._chart.chartArea;
		var xAlign = 'center';
		var yAlign = 'center';

		if (model.y < size.height) {
			yAlign = 'top';
		} else if (model.y > chart.height - size.height) {
			yAlign = 'bottom';
		}

		var lf, rf; // functions to determine left, right alignment
		var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
		var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
		var midX = (chartArea.left + chartArea.right) / 2;
		var midY = (chartArea.top + chartArea.bottom) / 2;

		if (yAlign === 'center') {
			lf = function lf(x) {
				return x <= midX;
			};
			rf = function rf(x) {
				return x > midX;
			};
		} else {
			lf = function lf(x) {
				return x <= size.width / 2;
			};
			rf = function rf(x) {
				return x >= chart.width - size.width / 2;
			};
		}

		olf = function olf(x) {
			return x + size.width > chart.width;
		};
		orf = function orf(x) {
			return x - size.width < 0;
		};
		yf = function yf(y) {
			return y <= midY ? 'top' : 'bottom';
		};

		if (lf(model.x)) {
			xAlign = 'left';

			// Is tooltip too wide and goes over the right side of the chart.?
			if (olf(model.x)) {
				xAlign = 'center';
				yAlign = yf(model.y);
			}
		} else if (rf(model.x)) {
			xAlign = 'right';

			// Is tooltip too wide and goes outside left edge of canvas?
			if (orf(model.x)) {
				xAlign = 'center';
				yAlign = yf(model.y);
			}
		}

		var opts = tooltip._options;
		return {
			xAlign: opts.xAlign ? opts.xAlign : xAlign,
			yAlign: opts.yAlign ? opts.yAlign : yAlign
		};
	}

	/**
  * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
  */
	function getBackgroundPoint(vm, size, alignment) {
		// Background Position
		var x = vm.x;
		var y = vm.y;

		var caretSize = vm.caretSize;
		var caretPadding = vm.caretPadding;
		var cornerRadius = vm.cornerRadius;
		var xAlign = alignment.xAlign;
		var yAlign = alignment.yAlign;
		var paddingAndSize = caretSize + caretPadding;
		var radiusAndPadding = cornerRadius + caretPadding;

		if (xAlign === 'right') {
			x -= size.width;
		} else if (xAlign === 'center') {
			x -= size.width / 2;
		}

		if (yAlign === 'top') {
			y += paddingAndSize;
		} else if (yAlign === 'bottom') {
			y -= size.height + paddingAndSize;
		} else {
			y -= size.height / 2;
		}

		if (yAlign === 'center') {
			if (xAlign === 'left') {
				x += paddingAndSize;
			} else if (xAlign === 'right') {
				x -= paddingAndSize;
			}
		} else if (xAlign === 'left') {
			x -= radiusAndPadding;
		} else if (xAlign === 'right') {
			x += radiusAndPadding;
		}

		return {
			x: x,
			y: y
		};
	}

	Chart.Tooltip = Element.extend({
		initialize: function initialize() {
			this._model = getBaseModel(this._options);
		},

		// Get the title
		// Args are: (tooltipItem, data)
		getTitle: function getTitle() {
			var me = this;
			var opts = me._options;
			var callbacks = opts.callbacks;

			var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
			var title = callbacks.title.apply(me, arguments);
			var afterTitle = callbacks.afterTitle.apply(me, arguments);

			var lines = [];
			lines = pushOrConcat(lines, beforeTitle);
			lines = pushOrConcat(lines, title);
			lines = pushOrConcat(lines, afterTitle);

			return lines;
		},

		// Args are: (tooltipItem, data)
		getBeforeBody: function getBeforeBody() {
			var lines = this._options.callbacks.beforeBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Args are: (tooltipItem, data)
		getBody: function getBody(tooltipItems, data) {
			var me = this;
			var callbacks = me._options.callbacks;
			var bodyItems = [];

			helpers.each(tooltipItems, function (tooltipItem) {
				var bodyItem = {
					before: [],
					lines: [],
					after: []
				};
				pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

				bodyItems.push(bodyItem);
			});

			return bodyItems;
		},

		// Args are: (tooltipItem, data)
		getAfterBody: function getAfterBody() {
			var lines = this._options.callbacks.afterBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Get the footer and beforeFooter and afterFooter lines
		// Args are: (tooltipItem, data)
		getFooter: function getFooter() {
			var me = this;
			var callbacks = me._options.callbacks;

			var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
			var footer = callbacks.footer.apply(me, arguments);
			var afterFooter = callbacks.afterFooter.apply(me, arguments);

			var lines = [];
			lines = pushOrConcat(lines, beforeFooter);
			lines = pushOrConcat(lines, footer);
			lines = pushOrConcat(lines, afterFooter);

			return lines;
		},

		update: function update(changed) {
			var me = this;
			var opts = me._options;

			// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
			// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
			// which breaks any animations.
			var existingModel = me._model;
			var model = me._model = getBaseModel(opts);
			var active = me._active;

			var data = me._data;

			// In the case where active.length === 0 we need to keep these at existing values for good animations
			var alignment = {
				xAlign: existingModel.xAlign,
				yAlign: existingModel.yAlign
			};
			var backgroundPoint = {
				x: existingModel.x,
				y: existingModel.y
			};
			var tooltipSize = {
				width: existingModel.width,
				height: existingModel.height
			};
			var tooltipPosition = {
				x: existingModel.caretX,
				y: existingModel.caretY
			};

			var i, len;

			if (active.length) {
				model.opacity = 1;

				var labelColors = [];
				var labelTextColors = [];
				tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);

				var tooltipItems = [];
				for (i = 0, len = active.length; i < len; ++i) {
					tooltipItems.push(createTooltipItem(active[i]));
				}

				// If the user provided a filter function, use it to modify the tooltip items
				if (opts.filter) {
					tooltipItems = tooltipItems.filter(function (a) {
						return opts.filter(a, data);
					});
				}

				// If the user provided a sorting function, use it to modify the tooltip items
				if (opts.itemSort) {
					tooltipItems = tooltipItems.sort(function (a, b) {
						return opts.itemSort(a, b, data);
					});
				}

				// Determine colors for boxes
				helpers.each(tooltipItems, function (tooltipItem) {
					labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
					labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
				});

				// Build the Text Lines
				model.title = me.getTitle(tooltipItems, data);
				model.beforeBody = me.getBeforeBody(tooltipItems, data);
				model.body = me.getBody(tooltipItems, data);
				model.afterBody = me.getAfterBody(tooltipItems, data);
				model.footer = me.getFooter(tooltipItems, data);

				// Initial positioning and colors
				model.x = Math.round(tooltipPosition.x);
				model.y = Math.round(tooltipPosition.y);
				model.caretPadding = opts.caretPadding;
				model.labelColors = labelColors;
				model.labelTextColors = labelTextColors;

				// data points
				model.dataPoints = tooltipItems;

				// We need to determine alignment of the tooltip
				tooltipSize = getTooltipSize(this, model);
				alignment = determineAlignment(this, tooltipSize);
				// Final Size and Position
				backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
			} else {
				model.opacity = 0;
			}

			model.xAlign = alignment.xAlign;
			model.yAlign = alignment.yAlign;
			model.x = backgroundPoint.x;
			model.y = backgroundPoint.y;
			model.width = tooltipSize.width;
			model.height = tooltipSize.height;

			// Point where the caret on the tooltip points to
			model.caretX = tooltipPosition.x;
			model.caretY = tooltipPosition.y;

			me._model = model;

			if (changed && opts.custom) {
				opts.custom.call(me, model);
			}

			return me;
		},
		drawCaret: function drawCaret(tooltipPoint, size) {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

			ctx.lineTo(caretPosition.x1, caretPosition.y1);
			ctx.lineTo(caretPosition.x2, caretPosition.y2);
			ctx.lineTo(caretPosition.x3, caretPosition.y3);
		},
		getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
			var x1, x2, x3, y1, y2, y3;
			var caretSize = vm.caretSize;
			var cornerRadius = vm.cornerRadius;
			var xAlign = vm.xAlign;
			var yAlign = vm.yAlign;
			var ptX = tooltipPoint.x;
			var ptY = tooltipPoint.y;
			var width = size.width;
			var height = size.height;

			if (yAlign === 'center') {
				y2 = ptY + height / 2;

				if (xAlign === 'left') {
					x1 = ptX;
					x2 = x1 - caretSize;
					x3 = x1;

					y1 = y2 + caretSize;
					y3 = y2 - caretSize;
				} else {
					x1 = ptX + width;
					x2 = x1 + caretSize;
					x3 = x1;

					y1 = y2 - caretSize;
					y3 = y2 + caretSize;
				}
			} else {
				if (xAlign === 'left') {
					x2 = ptX + cornerRadius + caretSize;
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				} else if (xAlign === 'right') {
					x2 = ptX + width - cornerRadius - caretSize;
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				} else {
					x2 = ptX + width / 2;
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				}
				if (yAlign === 'top') {
					y1 = ptY;
					y2 = y1 - caretSize;
					y3 = y1;
				} else {
					y1 = ptY + height;
					y2 = y1 + caretSize;
					y3 = y1;
					// invert drawing order
					var tmp = x3;
					x3 = x1;
					x1 = tmp;
				}
			}
			return { x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3 };
		},
		drawTitle: function drawTitle(pt, vm, ctx, opacity) {
			var title = vm.title;

			if (title.length) {
				ctx.textAlign = vm._titleAlign;
				ctx.textBaseline = 'top';

				var titleFontSize = vm.titleFontSize;
				var titleSpacing = vm.titleSpacing;

				ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
				ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

				var i, len;
				for (i = 0, len = title.length; i < len; ++i) {
					ctx.fillText(title[i], pt.x, pt.y);
					pt.y += titleFontSize + titleSpacing; // Line Height and spacing

					if (i + 1 === title.length) {
						pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
					}
				}
			}
		},
		drawBody: function drawBody(pt, vm, ctx, opacity) {
			var bodyFontSize = vm.bodyFontSize;
			var bodySpacing = vm.bodySpacing;
			var body = vm.body;

			ctx.textAlign = vm._bodyAlign;
			ctx.textBaseline = 'top';
			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

			// Before Body
			var xLinePadding = 0;
			var fillLineOfText = function fillLineOfText(line) {
				ctx.fillText(line, pt.x + xLinePadding, pt.y);
				pt.y += bodyFontSize + bodySpacing;
			};

			// Before body lines
			helpers.each(vm.beforeBody, fillLineOfText);

			var drawColorBoxes = vm.displayColors;
			xLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;

			// Draw body lines now
			helpers.each(body, function (bodyItem, i) {
				helpers.each(bodyItem.before, fillLineOfText);

				helpers.each(bodyItem.lines, function (line) {
					// Draw Legend-like boxes if needed
					if (drawColorBoxes) {
						// Fill a white rect so that colours merge nicely if the opacity is < 1
						ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
						ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Border
						ctx.lineWidth = 1;
						ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
						ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Inner square
						ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
						ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
						var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
						ctx.fillStyle = textColor;
					}

					fillLineOfText(line);
				});

				helpers.each(bodyItem.after, fillLineOfText);
			});

			// Reset back to 0 for after body
			xLinePadding = 0;

			// After body lines
			helpers.each(vm.afterBody, fillLineOfText);
			pt.y -= bodySpacing; // Remove last body spacing
		},
		drawFooter: function drawFooter(pt, vm, ctx, opacity) {
			var footer = vm.footer;

			if (footer.length) {
				pt.y += vm.footerMarginTop;

				ctx.textAlign = vm._footerAlign;
				ctx.textBaseline = 'top';

				ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
				ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

				helpers.each(footer, function (line) {
					ctx.fillText(line, pt.x, pt.y);
					pt.y += vm.footerFontSize + vm.footerSpacing;
				});
			}
		},
		drawBackground: function drawBackground(pt, vm, ctx, tooltipSize, opacity) {
			ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
			ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
			ctx.lineWidth = vm.borderWidth;
			var xAlign = vm.xAlign;
			var yAlign = vm.yAlign;
			var x = pt.x;
			var y = pt.y;
			var width = tooltipSize.width;
			var height = tooltipSize.height;
			var radius = vm.cornerRadius;

			ctx.beginPath();
			ctx.moveTo(x + radius, y);
			if (yAlign === 'top') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + width - radius, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
			if (yAlign === 'center' && xAlign === 'right') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + width, y + height - radius);
			ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
			if (yAlign === 'bottom') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + radius, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
			if (yAlign === 'center' && xAlign === 'left') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x, y + radius);
			ctx.quadraticCurveTo(x, y, x + radius, y);
			ctx.closePath();

			ctx.fill();

			if (vm.borderWidth > 0) {
				ctx.stroke();
			}
		},
		draw: function draw() {
			var ctx = this._chart.ctx;
			var vm = this._view;

			if (vm.opacity === 0) {
				return;
			}

			var tooltipSize = {
				width: vm.width,
				height: vm.height
			};
			var pt = {
				x: vm.x,
				y: vm.y
			};

			// IE11/Edge does not like very small opacities, so snap to 0
			var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

			// Truthy/falsey value for empty tooltip
			var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

			if (this._options.enabled && hasTooltipContent) {
				// Draw Background
				this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

				// Draw Title, Body, and Footer
				pt.x += vm.xPadding;
				pt.y += vm.yPadding;

				// Titles
				this.drawTitle(pt, vm, ctx, opacity);

				// Body
				this.drawBody(pt, vm, ctx, opacity);

				// Footer
				this.drawFooter(pt, vm, ctx, opacity);
			}
		},

		/**
   * Handle an event
   * @private
   * @param {IEvent} event - The event to handle
   * @returns {Boolean} true if the tooltip changed
   */
		handleEvent: function handleEvent(e) {
			var me = this;
			var options = me._options;
			var changed = false;

			me._lastActive = me._lastActive || [];

			// Find Active Elements for tooltips
			if (e.type === 'mouseout') {
				me._active = [];
			} else {
				me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
			}

			// Remember Last Actives
			changed = !helpers.arrayEquals(me._active, me._lastActive);

			// If tooltip didn't change, do not handle the target event
			if (!changed) {
				return false;
			}

			me._lastActive = me._active;

			if (options.enabled || options.custom) {
				me._eventPosition = {
					x: e.x,
					y: e.y
				};

				var model = me._model;
				me.update(true);
				me.pivot();

				// See if our tooltip position changed
				changed |= model.x !== me._model.x || model.y !== me._model.y;
			}

			return changed;
		}
	});

	/**
  * @namespace Chart.Tooltip.positioners
  */
	Chart.Tooltip.positioners = {
		/**
   * Average mode places the tooltip at the average position of the elements shown
   * @function Chart.Tooltip.positioners.average
   * @param elements {ChartElement[]} the elements being displayed in the tooltip
   * @returns {Point} tooltip position
   */
		average: function average(elements) {
			if (!elements.length) {
				return false;
			}

			var i, len;
			var x = 0;
			var y = 0;
			var count = 0;

			for (i = 0, len = elements.length; i < len; ++i) {
				var el = elements[i];
				if (el && el.hasValue()) {
					var pos = el.tooltipPosition();
					x += pos.x;
					y += pos.y;
					++count;
				}
			}

			return {
				x: Math.round(x / count),
				y: Math.round(y / count)
			};
		},

		/**
   * Gets the tooltip position nearest of the item nearest to the event position
   * @function Chart.Tooltip.positioners.nearest
   * @param elements {Chart.Element[]} the tooltip elements
   * @param eventPosition {Point} the position of the event in canvas coordinates
   * @returns {Point} the tooltip position
   */
		nearest: function nearest(elements, eventPosition) {
			var x = eventPosition.x;
			var y = eventPosition.y;
			var minDistance = Number.POSITIVE_INFINITY;
			var i, len, nearestElement;

			for (i = 0, len = elements.length; i < len; ++i) {
				var el = elements[i];
				if (el && el.hasValue()) {
					var center = el.getCenterPoint();
					var d = helpers.distanceBetweenPoints(eventPosition, center);

					if (d < minDistance) {
						minDistance = d;
						nearestElement = el;
					}
				}
			}

			if (nearestElement) {
				var tp = nearestElement.tooltipPosition();
				x = tp.x;
				y = tp.y;
			}

			return {
				x: x,
				y: y
			};
		}
	};
};

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	elements: {
		arc: {
			backgroundColor: defaults.global.defaultColor,
			borderColor: '#fff',
			borderWidth: 2
		}
	}
});

module.exports = Element.extend({
	inLabelRange: function inLabelRange(mouseX) {
		var vm = this._view;

		if (vm) {
			return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
		}
		return false;
	},

	inRange: function inRange(chartX, chartY) {
		var vm = this._view;

		if (vm) {
			var pointRelativePosition = helpers.getAngleFromPoint(vm, { x: chartX, y: chartY });
			var angle = pointRelativePosition.angle;
			var distance = pointRelativePosition.distance;

			// Sanitise angle range
			var startAngle = vm.startAngle;
			var endAngle = vm.endAngle;
			while (endAngle < startAngle) {
				endAngle += 2.0 * Math.PI;
			}
			while (angle > endAngle) {
				angle -= 2.0 * Math.PI;
			}
			while (angle < startAngle) {
				angle += 2.0 * Math.PI;
			}

			// Check if within the range of the open/close angle
			var betweenAngles = angle >= startAngle && angle <= endAngle;
			var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;

			return betweenAngles && withinRadius;
		}
		return false;
	},

	getCenterPoint: function getCenterPoint() {
		var vm = this._view;
		var halfAngle = (vm.startAngle + vm.endAngle) / 2;
		var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
		return {
			x: vm.x + Math.cos(halfAngle) * halfRadius,
			y: vm.y + Math.sin(halfAngle) * halfRadius
		};
	},

	getArea: function getArea() {
		var vm = this._view;
		return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
	},

	tooltipPosition: function tooltipPosition() {
		var vm = this._view;
		var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
		var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

		return {
			x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
			y: vm.y + Math.sin(centreAngle) * rangeFromCentre
		};
	},

	draw: function draw() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var sA = vm.startAngle;
		var eA = vm.endAngle;

		ctx.beginPath();

		ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
		ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

		ctx.closePath();
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = vm.borderWidth;

		ctx.fillStyle = vm.backgroundColor;

		ctx.fill();
		ctx.lineJoin = 'bevel';

		if (vm.borderWidth) {
			ctx.stroke();
		}
	}
});

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

var globalDefaults = defaults.global;

defaults._set('global', {
	elements: {
		line: {
			tension: 0.4,
			backgroundColor: globalDefaults.defaultColor,
			borderWidth: 3,
			borderColor: globalDefaults.defaultColor,
			borderCapStyle: 'butt',
			borderDash: [],
			borderDashOffset: 0.0,
			borderJoinStyle: 'miter',
			capBezierPoints: true,
			fill: true // do we fill in the area between the line and its base axis
		}
	}
});

module.exports = Element.extend({
	draw: function draw() {
		var me = this;
		var vm = me._view;
		var ctx = me._chart.ctx;
		var spanGaps = vm.spanGaps;
		var points = me._children.slice(); // clone array
		var globalOptionLineElements = globalDefaults.elements.line;
		var lastDrawnIndex = -1;
		var index, current, previous, currentVM;

		// If we are looping, adding the first point again
		if (me._loop && points.length) {
			points.push(points[0]);
		}

		ctx.save();

		// Stroke Line Options
		ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

		// IE 9 and 10 do not support line dash
		if (ctx.setLineDash) {
			ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
		}

		ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
		ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
		ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
		ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

		// Stroke Line
		ctx.beginPath();
		lastDrawnIndex = -1;

		for (index = 0; index < points.length; ++index) {
			current = points[index];
			previous = helpers.previousItem(points, index);
			currentVM = current._view;

			// First point moves to it's starting position no matter what
			if (index === 0) {
				if (!currentVM.skip) {
					ctx.moveTo(currentVM.x, currentVM.y);
					lastDrawnIndex = index;
				}
			} else {
				previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

				if (!currentVM.skip) {
					if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
						// There was a gap and this is the first point after the gap
						ctx.moveTo(currentVM.x, currentVM.y);
					} else {
						// Line to next point
						helpers.canvas.lineTo(ctx, previous._view, current._view);
					}
					lastDrawnIndex = index;
				}
			}
		}

		ctx.stroke();
		ctx.restore();
	}
});

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

var defaultColor = defaults.global.defaultColor;

defaults._set('global', {
	elements: {
		point: {
			radius: 3,
			pointStyle: 'circle',
			backgroundColor: defaultColor,
			borderColor: defaultColor,
			borderWidth: 1,
			// Hover
			hitRadius: 1,
			hoverRadius: 4,
			hoverBorderWidth: 1
		}
	}
});

function xRange(mouseX) {
	var vm = this._view;
	return vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
}

function yRange(mouseY) {
	var vm = this._view;
	return vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;
}

module.exports = Element.extend({
	inRange: function inRange(mouseX, mouseY) {
		var vm = this._view;
		return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
	},

	inLabelRange: xRange,
	inXRange: xRange,
	inYRange: yRange,

	getCenterPoint: function getCenterPoint() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	},

	getArea: function getArea() {
		return Math.PI * Math.pow(this._view.radius, 2);
	},

	tooltipPosition: function tooltipPosition() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y,
			padding: vm.radius + vm.borderWidth
		};
	},

	draw: function draw(chartArea) {
		var vm = this._view;
		var model = this._model;
		var ctx = this._chart.ctx;
		var pointStyle = vm.pointStyle;
		var radius = vm.radius;
		var x = vm.x;
		var y = vm.y;
		var color = helpers.color;
		var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
		var ratio = 0;

		if (vm.skip) {
			return;
		}

		ctx.strokeStyle = vm.borderColor || defaultColor;
		ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
		ctx.fillStyle = vm.backgroundColor || defaultColor;

		// Cliping for Points.
		// going out from inner charArea?
		if (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {
			// Point fade out
			if (model.x < chartArea.left) {
				ratio = (x - model.x) / (chartArea.left - model.x);
			} else if (chartArea.right * errMargin < model.x) {
				ratio = (model.x - x) / (model.x - chartArea.right);
			} else if (model.y < chartArea.top) {
				ratio = (y - model.y) / (chartArea.top - model.y);
			} else if (chartArea.bottom * errMargin < model.y) {
				ratio = (model.y - y) / (model.y - chartArea.bottom);
			}
			ratio = Math.round(ratio * 100) / 100;
			ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
			ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
		}

		helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
	}
});

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);

defaults._set('global', {
	elements: {
		rectangle: {
			backgroundColor: defaults.global.defaultColor,
			borderColor: defaults.global.defaultColor,
			borderSkipped: 'bottom',
			borderWidth: 0
		}
	}
});

function isVertical(bar) {
	return bar._view.width !== undefined;
}

/**
 * Helper function to get the bounds of the bar regardless of the orientation
 * @param bar {Chart.Element.Rectangle} the bar
 * @return {Bounds} bounds of the bar
 * @private
 */
function getBarBounds(bar) {
	var vm = bar._view;
	var x1, x2, y1, y2;

	if (isVertical(bar)) {
		// vertical
		var halfWidth = vm.width / 2;
		x1 = vm.x - halfWidth;
		x2 = vm.x + halfWidth;
		y1 = Math.min(vm.y, vm.base);
		y2 = Math.max(vm.y, vm.base);
	} else {
		// horizontal bar
		var halfHeight = vm.height / 2;
		x1 = Math.min(vm.x, vm.base);
		x2 = Math.max(vm.x, vm.base);
		y1 = vm.y - halfHeight;
		y2 = vm.y + halfHeight;
	}

	return {
		left: x1,
		top: y1,
		right: x2,
		bottom: y2
	};
}

module.exports = Element.extend({
	draw: function draw() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var left, right, top, bottom, signX, signY, borderSkipped;
		var borderWidth = vm.borderWidth;

		if (!vm.horizontal) {
			// bar
			left = vm.x - vm.width / 2;
			right = vm.x + vm.width / 2;
			top = vm.y;
			bottom = vm.base;
			signX = 1;
			signY = bottom > top ? 1 : -1;
			borderSkipped = vm.borderSkipped || 'bottom';
		} else {
			// horizontal bar
			left = vm.base;
			right = vm.x;
			top = vm.y - vm.height / 2;
			bottom = vm.y + vm.height / 2;
			signX = right > left ? 1 : -1;
			signY = 1;
			borderSkipped = vm.borderSkipped || 'left';
		}

		// Canvas doesn't allow us to stroke inside the width so we can
		// adjust the sizes to fit if we're setting a stroke on the line
		if (borderWidth) {
			// borderWidth shold be less than bar width and bar height.
			var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
			borderWidth = borderWidth > barSize ? barSize : borderWidth;
			var halfStroke = borderWidth / 2;
			// Adjust borderWidth when bar top position is near vm.base(zero).
			var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
			var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
			var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
			var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
			// not become a vertical line?
			if (borderLeft !== borderRight) {
				top = borderTop;
				bottom = borderBottom;
			}
			// not become a horizontal line?
			if (borderTop !== borderBottom) {
				left = borderLeft;
				right = borderRight;
			}
		}

		ctx.beginPath();
		ctx.fillStyle = vm.backgroundColor;
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = borderWidth;

		// Corner points, from bottom-left to bottom-right clockwise
		// | 1 2 |
		// | 0 3 |
		var corners = [[left, bottom], [left, top], [right, top], [right, bottom]];

		// Find first (starting) corner with fallback to 'bottom'
		var borders = ['bottom', 'left', 'top', 'right'];
		var startCorner = borders.indexOf(borderSkipped, 0);
		if (startCorner === -1) {
			startCorner = 0;
		}

		function cornerAt(index) {
			return corners[(startCorner + index) % 4];
		}

		// Draw rectangle from 'startCorner'
		var corner = cornerAt(0);
		ctx.moveTo(corner[0], corner[1]);

		for (var i = 1; i < 4; i++) {
			corner = cornerAt(i);
			ctx.lineTo(corner[0], corner[1]);
		}

		ctx.fill();
		if (borderWidth) {
			ctx.stroke();
		}
	},

	height: function height() {
		var vm = this._view;
		return vm.base - vm.y;
	},

	inRange: function inRange(mouseX, mouseY) {
		var inRange = false;

		if (this._view) {
			var bounds = getBarBounds(this);
			inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
		}

		return inRange;
	},

	inLabelRange: function inLabelRange(mouseX, mouseY) {
		var me = this;
		if (!me._view) {
			return false;
		}

		var inRange = false;
		var bounds = getBarBounds(me);

		if (isVertical(me)) {
			inRange = mouseX >= bounds.left && mouseX <= bounds.right;
		} else {
			inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
		}

		return inRange;
	},

	inXRange: function inXRange(mouseX) {
		var bounds = getBarBounds(this);
		return mouseX >= bounds.left && mouseX <= bounds.right;
	},

	inYRange: function inYRange(mouseY) {
		var bounds = getBarBounds(this);
		return mouseY >= bounds.top && mouseY <= bounds.bottom;
	},

	getCenterPoint: function getCenterPoint() {
		var vm = this._view;
		var x, y;
		if (isVertical(this)) {
			x = vm.x;
			y = (vm.y + vm.base) / 2;
		} else {
			x = (vm.x + vm.base) / 2;
			y = vm.y;
		}

		return { x: x, y: y };
	},

	getArea: function getArea() {
		var vm = this._view;
		return vm.width * Math.abs(vm.y - vm.base);
	},

	tooltipPosition: function tooltipPosition() {
		var vm = this._view;
		return {
			x: vm.x,
			y: vm.y
		};
	}
});

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var helpers = __webpack_require__(87);

/**
 * @namespace Chart.helpers.canvas
 */
var exports = module.exports = {
	/**
  * Clears the entire canvas associated to the given `chart`.
  * @param {Chart} chart - The chart for which to clear the canvas.
  */
	clear: function clear(chart) {
		chart.ctx.clearRect(0, 0, chart.width, chart.height);
	},

	/**
  * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
  * given size (width, height) and the same `radius` for all corners.
  * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
  * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
  * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
  * @param {Number} width - The rectangle's width.
  * @param {Number} height - The rectangle's height.
  * @param {Number} radius - The rounded amount (in pixels) for the four corners.
  * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
  */
	roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
		if (radius) {
			var rx = Math.min(radius, width / 2);
			var ry = Math.min(radius, height / 2);

			ctx.moveTo(x + rx, y);
			ctx.lineTo(x + width - rx, y);
			ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
			ctx.lineTo(x + width, y + height - ry);
			ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
			ctx.lineTo(x + rx, y + height);
			ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
			ctx.lineTo(x, y + ry);
			ctx.quadraticCurveTo(x, y, x + rx, y);
		} else {
			ctx.rect(x, y, width, height);
		}
	},

	drawPoint: function drawPoint(ctx, style, radius, x, y) {
		var type, edgeLength, xOffset, yOffset, height, size;

		if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) === 'object') {
			type = style.toString();
			if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
				ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
				return;
			}
		}

		if (isNaN(radius) || radius <= 0) {
			return;
		}

		switch (style) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'triangle':
				ctx.beginPath();
				edgeLength = 3 * radius / Math.sqrt(3);
				height = edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rect':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case 'rectRounded':
				var offset = radius / Math.SQRT2;
				var leftX = x - offset;
				var topY = y - offset;
				var sideSize = Math.SQRT2 * radius;
				ctx.beginPath();
				this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rectRot':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case 'cross':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'crossRot':
				ctx.beginPath();
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'star':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'line':
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'dash':
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
		}

		ctx.stroke();
	},

	clipArea: function clipArea(ctx, area) {
		ctx.save();
		ctx.beginPath();
		ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
		ctx.clip();
	},

	unclipArea: function unclipArea(ctx) {
		ctx.restore();
	},

	lineTo: function lineTo(ctx, previous, target, flip) {
		if (target.steppedLine) {
			if (target.steppedLine === 'after' && !flip || target.steppedLine !== 'after' && flip) {
				ctx.lineTo(previous.x, target.y);
			} else {
				ctx.lineTo(target.x, previous.y);
			}
			ctx.lineTo(target.x, target.y);
			return;
		}

		if (!target.tension) {
			ctx.lineTo(target.x, target.y);
			return;
		}

		ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
	}
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
 * @namespace Chart.helpers.clear
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.clear = exports.clear;

/**
 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
 * @namespace Chart.helpers.drawRoundedRectangle
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.drawRoundedRectangle = function (ctx) {
	ctx.beginPath();
	exports.roundedRect.apply(exports, arguments);
	ctx.closePath();
};

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(87);

/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easingEffects
 * @see http://www.robertpenner.com/easing/
 */
var effects = {
	linear: function linear(t) {
		return t;
	},

	easeInQuad: function easeInQuad(t) {
		return t * t;
	},

	easeOutQuad: function easeOutQuad(t) {
		return -t * (t - 2);
	},

	easeInOutQuad: function easeInOutQuad(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t;
		}
		return -0.5 * (--t * (t - 2) - 1);
	},

	easeInCubic: function easeInCubic(t) {
		return t * t * t;
	},

	easeOutCubic: function easeOutCubic(t) {
		return (t = t - 1) * t * t + 1;
	},

	easeInOutCubic: function easeInOutCubic(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t + 2);
	},

	easeInQuart: function easeInQuart(t) {
		return t * t * t * t;
	},

	easeOutQuart: function easeOutQuart(t) {
		return -((t = t - 1) * t * t * t - 1);
	},

	easeInOutQuart: function easeInOutQuart(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t;
		}
		return -0.5 * ((t -= 2) * t * t * t - 2);
	},

	easeInQuint: function easeInQuint(t) {
		return t * t * t * t * t;
	},

	easeOutQuint: function easeOutQuint(t) {
		return (t = t - 1) * t * t * t * t + 1;
	},

	easeInOutQuint: function easeInOutQuint(t) {
		if ((t /= 0.5) < 1) {
			return 0.5 * t * t * t * t * t;
		}
		return 0.5 * ((t -= 2) * t * t * t * t + 2);
	},

	easeInSine: function easeInSine(t) {
		return -Math.cos(t * (Math.PI / 2)) + 1;
	},

	easeOutSine: function easeOutSine(t) {
		return Math.sin(t * (Math.PI / 2));
	},

	easeInOutSine: function easeInOutSine(t) {
		return -0.5 * (Math.cos(Math.PI * t) - 1);
	},

	easeInExpo: function easeInExpo(t) {
		return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
	},

	easeOutExpo: function easeOutExpo(t) {
		return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
	},

	easeInOutExpo: function easeInOutExpo(t) {
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if ((t /= 0.5) < 1) {
			return 0.5 * Math.pow(2, 10 * (t - 1));
		}
		return 0.5 * (-Math.pow(2, -10 * --t) + 2);
	},

	easeInCirc: function easeInCirc(t) {
		if (t >= 1) {
			return t;
		}
		return -(Math.sqrt(1 - t * t) - 1);
	},

	easeOutCirc: function easeOutCirc(t) {
		return Math.sqrt(1 - (t = t - 1) * t);
	},

	easeInOutCirc: function easeInOutCirc(t) {
		if ((t /= 0.5) < 1) {
			return -0.5 * (Math.sqrt(1 - t * t) - 1);
		}
		return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	},

	easeInElastic: function easeInElastic(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
	},

	easeOutElastic: function easeOutElastic(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if (t === 1) {
			return 1;
		}
		if (!p) {
			p = 0.3;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
	},

	easeInOutElastic: function easeInOutElastic(t) {
		var s = 1.70158;
		var p = 0;
		var a = 1;
		if (t === 0) {
			return 0;
		}
		if ((t /= 0.5) === 2) {
			return 1;
		}
		if (!p) {
			p = 0.45;
		}
		if (a < 1) {
			a = 1;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(1 / a);
		}
		if (t < 1) {
			return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		}
		return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
	},
	easeInBack: function easeInBack(t) {
		var s = 1.70158;
		return t * t * ((s + 1) * t - s);
	},

	easeOutBack: function easeOutBack(t) {
		var s = 1.70158;
		return (t = t - 1) * t * ((s + 1) * t + s) + 1;
	},

	easeInOutBack: function easeInOutBack(t) {
		var s = 1.70158;
		if ((t /= 0.5) < 1) {
			return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
		}
		return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
	},

	easeInBounce: function easeInBounce(t) {
		return 1 - effects.easeOutBounce(1 - t);
	},

	easeOutBounce: function easeOutBounce(t) {
		if (t < 1 / 2.75) {
			return 7.5625 * t * t;
		}
		if (t < 2 / 2.75) {
			return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
		}
		if (t < 2.5 / 2.75) {
			return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
		}
		return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
	},

	easeInOutBounce: function easeInOutBounce(t) {
		if (t < 0.5) {
			return effects.easeInBounce(t * 2) * 0.5;
		}
		return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
	}
};

module.exports = {
	effects: effects
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
 * @function Chart.helpers.easingEffects
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.easingEffects = effects;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(87);

/**
 * @alias Chart.helpers.options
 * @namespace
 */
module.exports = {
	/**
  * Converts the given line height `value` in pixels for a specific font `size`.
  * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
  * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
  * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
  * @since 2.7.0
  */
	toLineHeight: function toLineHeight(value, size) {
		var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
		if (!matches || matches[1] === 'normal') {
			return size * 1.2;
		}

		value = +matches[2];

		switch (matches[3]) {
			case 'px':
				return value;
			case '%':
				value /= 100;
				break;
			default:
				break;
		}

		return size * value;
	},

	/**
  * Converts the given value into a padding object with pre-computed width/height.
  * @param {Number|Object} value - If a number, set the value to all TRBL component,
  *  else, if and object, use defined properties and sets undefined ones to 0.
  * @returns {Object} The padding values (top, right, bottom, left, width, height)
  * @since 2.7.0
  */
	toPadding: function toPadding(value) {
		var t, r, b, l;

		if (helpers.isObject(value)) {
			t = +value.top || 0;
			r = +value.right || 0;
			b = +value.bottom || 0;
			l = +value.left || 0;
		} else {
			t = r = b = l = +value || 0;
		}

		return {
			top: t,
			right: r,
			bottom: b,
			left: l,
			height: t + b,
			width: l + r
		};
	},

	/**
  * Evaluates the given `inputs` sequentially and returns the first defined value.
  * @param {Array[]} inputs - An array of values, falling back to the last value.
  * @param {Object} [context] - If defined and the current value is a function, the value
  * is called with `context` as first argument and the result becomes the new input.
  * @param {Number} [index] - If defined and the current value is an array, the value
  * at `index` become the new input.
  * @since 2.7.0
  */
	resolve: function resolve(inputs, context, index) {
		var i, ilen, value;

		for (i = 0, ilen = inputs.length; i < ilen; ++i) {
			value = inputs[i];
			if (value === undefined) {
				continue;
			}
			if (context !== undefined && typeof value === 'function') {
				value = value(context);
			}
			if (index !== undefined && helpers.isArray(value)) {
				value = value[index];
			}
			if (value !== undefined) {
				return value;
			}
		}
	}
};

/***/ }),
/* 438 */
/***/ (function(module, exports) {

/**
 * Platform fallback implementation (minimal).
 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
 */

module.exports = {
	acquireContext: function acquireContext(item) {
		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		return item && item.getContext('2d') || null;
	}
};

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Chart.Platform implementation for targeting a web browser
 */



var helpers = __webpack_require__(4);

var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

/**
 * DOM event types -> Chart.js event types.
 * Note: only events with different types are mapped.
 * @see https://developer.mozilla.org/en-US/docs/Web/Events
 */
var EVENT_TYPES = {
	touchstart: 'mousedown',
	touchmove: 'mousemove',
	touchend: 'mouseup',
	pointerenter: 'mouseenter',
	pointerdown: 'mousedown',
	pointermove: 'mousemove',
	pointerup: 'mouseup',
	pointerleave: 'mouseout',
	pointerout: 'mouseout'
};

/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns {Number} Size in pixels or undefined if unknown.
 */
function readUsedSize(element, property) {
	var value = helpers.getStyle(element, property);
	var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
	return matches ? Number(matches[1]) : undefined;
}

/**
 * Initializes the canvas style and render size without modifying the canvas display size,
 * since responsiveness is handled by the controller.resize() method. The config is used
 * to determine the aspect ratio to apply in case no explicit height has been specified.
 */
function initCanvas(canvas, config) {
	var style = canvas.style;

	// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
	// returns null or '' if no explicit value has been set to the canvas attribute.
	var renderHeight = canvas.getAttribute('height');
	var renderWidth = canvas.getAttribute('width');

	// Chart.js modifies some canvas values that we want to restore on destroy
	canvas[EXPANDO_KEY] = {
		initial: {
			height: renderHeight,
			width: renderWidth,
			style: {
				display: style.display,
				height: style.height,
				width: style.width
			}
		}
	};

	// Force canvas to display as block to avoid extra space caused by inline
	// elements, which would interfere with the responsive resize process.
	// https://github.com/chartjs/Chart.js/issues/2538
	style.display = style.display || 'block';

	if (renderWidth === null || renderWidth === '') {
		var displayWidth = readUsedSize(canvas, 'width');
		if (displayWidth !== undefined) {
			canvas.width = displayWidth;
		}
	}

	if (renderHeight === null || renderHeight === '') {
		if (canvas.style.height === '') {
			// If no explicit render height and style height, let's apply the aspect ratio,
			// which one can be specified by the user but also by charts as default option
			// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
			canvas.height = canvas.width / (config.options.aspectRatio || 2);
		} else {
			var displayHeight = readUsedSize(canvas, 'height');
			if (displayWidth !== undefined) {
				canvas.height = displayHeight;
			}
		}
	}

	return canvas;
}

/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */
var supportsEventListenerOptions = function () {
	var supports = false;
	try {
		var options = Object.defineProperty({}, 'passive', {
			get: function get() {
				supports = true;
			}
		});
		window.addEventListener('e', null, options);
	} catch (e) {
		// continue regardless of error
	}
	return supports;
}();

// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;

function _addEventListener(node, type, listener) {
	node.addEventListener(type, listener, eventListenerOptions);
}

function _removeEventListener(node, type, listener) {
	node.removeEventListener(type, listener, eventListenerOptions);
}

function createEvent(type, chart, x, y, nativeEvent) {
	return {
		type: type,
		chart: chart,
		native: nativeEvent || null,
		x: x !== undefined ? x : null,
		y: y !== undefined ? y : null
	};
}

function fromNativeEvent(event, chart) {
	var type = EVENT_TYPES[event.type] || event.type;
	var pos = helpers.getRelativePosition(event, chart);
	return createEvent(type, chart, pos.x, pos.y, event);
}

function throttled(fn, thisArg) {
	var ticking = false;
	var args = [];

	return function () {
		args = Array.prototype.slice.call(arguments);
		thisArg = thisArg || this;

		if (!ticking) {
			ticking = true;
			helpers.requestAnimFrame.call(window, function () {
				ticking = false;
				fn.apply(thisArg, args);
			});
		}
	};
}

// Implementation based on https://github.com/marcj/css-element-queries
function createResizer(handler) {
	var resizer = document.createElement('div');
	var cls = CSS_PREFIX + 'size-monitor';
	var maxSize = 1000000;
	var style = 'position:absolute;' + 'left:0;' + 'top:0;' + 'right:0;' + 'bottom:0;' + 'overflow:hidden;' + 'pointer-events:none;' + 'visibility:hidden;' + 'z-index:-1;';

	resizer.style.cssText = style;
	resizer.className = cls;
	resizer.innerHTML = '<div class="' + cls + '-expand" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:' + maxSize + 'px;' + 'height:' + maxSize + 'px;' + 'left:0;' + 'top:0">' + '</div>' + '</div>' + '<div class="' + cls + '-shrink" style="' + style + '">' + '<div style="' + 'position:absolute;' + 'width:200%;' + 'height:200%;' + 'left:0; ' + 'top:0">' + '</div>' + '</div>';

	var expand = resizer.childNodes[0];
	var shrink = resizer.childNodes[1];

	resizer._reset = function () {
		expand.scrollLeft = maxSize;
		expand.scrollTop = maxSize;
		shrink.scrollLeft = maxSize;
		shrink.scrollTop = maxSize;
	};
	var onScroll = function onScroll() {
		resizer._reset();
		handler();
	};

	_addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
	_addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

	return resizer;
}

// https://davidwalsh.name/detect-node-insertion
function watchForRender(node, handler) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
	var proxy = expando.renderProxy = function (e) {
		if (e.animationName === CSS_RENDER_ANIMATION) {
			handler();
		}
	};

	helpers.each(ANIMATION_START_EVENTS, function (type) {
		_addEventListener(node, type, proxy);
	});

	node.classList.add(CSS_RENDER_MONITOR);
}

function unwatchForRender(node) {
	var expando = node[EXPANDO_KEY] || {};
	var proxy = expando.renderProxy;

	if (proxy) {
		helpers.each(ANIMATION_START_EVENTS, function (type) {
			_removeEventListener(node, type, proxy);
		});

		delete expando.renderProxy;
	}

	node.classList.remove(CSS_RENDER_MONITOR);
}

function addResizeListener(node, listener, chart) {
	var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

	// Let's keep track of this added resizer and thus avoid DOM query when removing it.
	var resizer = expando.resizer = createResizer(throttled(function () {
		if (expando.resizer) {
			return listener(createEvent('resize', chart));
		}
	}));

	// The resizer needs to be attached to the node parent, so we first need to be
	// sure that `node` is attached to the DOM before injecting the resizer element.
	watchForRender(node, function () {
		if (expando.resizer) {
			var container = node.parentNode;
			if (container && container !== resizer.parentNode) {
				container.insertBefore(resizer, container.firstChild);
			}

			// The container size might have changed, let's reset the resizer state.
			resizer._reset();
		}
	});
}

function removeResizeListener(node) {
	var expando = node[EXPANDO_KEY] || {};
	var resizer = expando.resizer;

	delete expando.resizer;
	unwatchForRender(node);

	if (resizer && resizer.parentNode) {
		resizer.parentNode.removeChild(resizer);
	}
}

function injectCSS(platform, css) {
	// http://stackoverflow.com/q/3922139
	var style = platform._style || document.createElement('style');
	if (!platform._style) {
		platform._style = style;
		css = '/* Chart.js */\n' + css;
		style.setAttribute('type', 'text/css');
		document.getElementsByTagName('head')[0].appendChild(style);
	}

	style.appendChild(document.createTextNode(css));
}

module.exports = {
	/**
  * This property holds whether this platform is enabled for the current environment.
  * Currently used by platform.js to select the proper implementation.
  * @private
  */
	_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

	initialize: function initialize() {
		var keyframes = 'from{opacity:0.99}to{opacity:1}';

		injectCSS(this,
		// DOM rendering detection
		// https://davidwalsh.name/detect-node-insertion
		'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' + '.' + CSS_RENDER_MONITOR + '{' + '-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + 'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' + '}');
	},

	acquireContext: function acquireContext(item, config) {
		if (typeof item === 'string') {
			item = document.getElementById(item);
		} else if (item.length) {
			// Support for array based queries (such as jQuery)
			item = item[0];
		}

		if (item && item.canvas) {
			// Support for any object associated to a canvas (including a context2d)
			item = item.canvas;
		}

		// To prevent canvas fingerprinting, some add-ons undefine the getContext
		// method, for example: https://github.com/kkapsner/CanvasBlocker
		// https://github.com/chartjs/Chart.js/issues/2807
		var context = item && item.getContext && item.getContext('2d');

		// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
		// inside an iframe or when running in a protected environment. We could guess the
		// types from their toString() value but let's keep things flexible and assume it's
		// a sufficient condition if the item has a context2D which has item as `canvas`.
		// https://github.com/chartjs/Chart.js/issues/3887
		// https://github.com/chartjs/Chart.js/issues/4102
		// https://github.com/chartjs/Chart.js/issues/4152
		if (context && context.canvas === item) {
			initCanvas(item, config);
			return context;
		}

		return null;
	},

	releaseContext: function releaseContext(context) {
		var canvas = context.canvas;
		if (!canvas[EXPANDO_KEY]) {
			return;
		}

		var initial = canvas[EXPANDO_KEY].initial;
		['height', 'width'].forEach(function (prop) {
			var value = initial[prop];
			if (helpers.isNullOrUndef(value)) {
				canvas.removeAttribute(prop);
			} else {
				canvas.setAttribute(prop, value);
			}
		});

		helpers.each(initial.style || {}, function (value, key) {
			canvas.style[key] = value;
		});

		// The canvas render size might have been changed (and thus the state stack discarded),
		// we can't use save() and restore() to restore the initial state. So make sure that at
		// least the canvas context is reset to the default state by setting the canvas width.
		// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
		canvas.width = canvas.width;

		delete canvas[EXPANDO_KEY];
	},

	addEventListener: function addEventListener(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			addResizeListener(canvas, listener, chart);
			return;
		}

		var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
		var proxies = expando.proxies || (expando.proxies = {});
		var proxy = proxies[chart.id + '_' + type] = function (event) {
			listener(fromNativeEvent(event, chart));
		};

		_addEventListener(canvas, type, proxy);
	},

	removeEventListener: function removeEventListener(chart, type, listener) {
		var canvas = chart.canvas;
		if (type === 'resize') {
			// Note: the resize event is not supported on all browsers.
			removeResizeListener(canvas, listener);
			return;
		}

		var expando = listener[EXPANDO_KEY] || {};
		var proxies = expando.proxies || {};
		var proxy = proxies[chart.id + '_' + type];
		if (!proxy) {
			return;
		}

		_removeEventListener(canvas, type, proxy);
	}
};

// DEPRECATIONS

/**
 * Provided for backward compatibility, use EventTarget.addEventListener instead.
 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * @function Chart.helpers.addEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.addEvent = _addEventListener;

/**
 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
 * @function Chart.helpers.removeEvent
 * @deprecated since version 2.7.0
 * @todo remove at version 3
 * @private
 */
helpers.removeEvent = _removeEventListener;

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Plugin based on discussion from the following Chart.js issues:
 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
 */



var defaults = __webpack_require__(9);
var elements = __webpack_require__(46);
var helpers = __webpack_require__(4);

defaults._set('global', {
	plugins: {
		filler: {
			propagate: true
		}
	}
});

module.exports = function () {

	var mappers = {
		dataset: function dataset(source) {
			var index = source.fill;
			var chart = source.chart;
			var meta = chart.getDatasetMeta(index);
			var visible = meta && chart.isDatasetVisible(index);
			var points = visible && meta.dataset._children || [];
			var length = points.length || 0;

			return !length ? null : function (point, i) {
				return i < length && points[i]._view || null;
			};
		},

		boundary: function boundary(source) {
			var boundary = source.boundary;
			var x = boundary ? boundary.x : null;
			var y = boundary ? boundary.y : null;

			return function (point) {
				return {
					x: x === null ? point.x : x,
					y: y === null ? point.y : y
				};
			};
		}
	};

	// @todo if (fill[0] === '#')
	function decodeFill(el, index, count) {
		var model = el._model || {};
		var fill = model.fill;
		var target;

		if (fill === undefined) {
			fill = !!model.backgroundColor;
		}

		if (fill === false || fill === null) {
			return false;
		}

		if (fill === true) {
			return 'origin';
		}

		target = parseFloat(fill, 10);
		if (isFinite(target) && Math.floor(target) === target) {
			if (fill[0] === '-' || fill[0] === '+') {
				target = index + target;
			}

			if (target === index || target < 0 || target >= count) {
				return false;
			}

			return target;
		}

		switch (fill) {
			// compatibility
			case 'bottom':
				return 'start';
			case 'top':
				return 'end';
			case 'zero':
				return 'origin';
			// supported boundaries
			case 'origin':
			case 'start':
			case 'end':
				return fill;
			// invalid fill values
			default:
				return false;
		}
	}

	function computeBoundary(source) {
		var model = source.el._model || {};
		var scale = source.el._scale || {};
		var fill = source.fill;
		var target = null;
		var horizontal;

		if (isFinite(fill)) {
			return null;
		}

		// Backward compatibility: until v3, we still need to support boundary values set on
		// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
		// controllers might still use it (e.g. the Smith chart).

		if (fill === 'start') {
			target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
		} else if (fill === 'end') {
			target = model.scaleTop === undefined ? scale.top : model.scaleTop;
		} else if (model.scaleZero !== undefined) {
			target = model.scaleZero;
		} else if (scale.getBasePosition) {
			target = scale.getBasePosition();
		} else if (scale.getBasePixel) {
			target = scale.getBasePixel();
		}

		if (target !== undefined && target !== null) {
			if (target.x !== undefined && target.y !== undefined) {
				return target;
			}

			if (typeof target === 'number' && isFinite(target)) {
				horizontal = scale.isHorizontal();
				return {
					x: horizontal ? target : null,
					y: horizontal ? null : target
				};
			}
		}

		return null;
	}

	function resolveTarget(sources, index, propagate) {
		var source = sources[index];
		var fill = source.fill;
		var visited = [index];
		var target;

		if (!propagate) {
			return fill;
		}

		while (fill !== false && visited.indexOf(fill) === -1) {
			if (!isFinite(fill)) {
				return fill;
			}

			target = sources[fill];
			if (!target) {
				return false;
			}

			if (target.visible) {
				return fill;
			}

			visited.push(fill);
			fill = target.fill;
		}

		return false;
	}

	function createMapper(source) {
		var fill = source.fill;
		var type = 'dataset';

		if (fill === false) {
			return null;
		}

		if (!isFinite(fill)) {
			type = 'boundary';
		}

		return mappers[type](source);
	}

	function isDrawable(point) {
		return point && !point.skip;
	}

	function drawArea(ctx, curve0, curve1, len0, len1) {
		var i;

		if (!len0 || !len1) {
			return;
		}

		// building first area curve (normal)
		ctx.moveTo(curve0[0].x, curve0[0].y);
		for (i = 1; i < len0; ++i) {
			helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
		}

		// joining the two area curves
		ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

		// building opposite area curve (reverse)
		for (i = len1 - 1; i > 0; --i) {
			helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
		}
	}

	function doFill(ctx, points, mapper, view, color, loop) {
		var count = points.length;
		var span = view.spanGaps;
		var curve0 = [];
		var curve1 = [];
		var len0 = 0;
		var len1 = 0;
		var i, ilen, index, p0, p1, d0, d1;

		ctx.beginPath();

		for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
			index = i % count;
			p0 = points[index]._view;
			p1 = mapper(p0, index, view);
			d0 = isDrawable(p0);
			d1 = isDrawable(p1);

			if (d0 && d1) {
				len0 = curve0.push(p0);
				len1 = curve1.push(p1);
			} else if (len0 && len1) {
				if (!span) {
					drawArea(ctx, curve0, curve1, len0, len1);
					len0 = len1 = 0;
					curve0 = [];
					curve1 = [];
				} else {
					if (d0) {
						curve0.push(p0);
					}
					if (d1) {
						curve1.push(p1);
					}
				}
			}
		}

		drawArea(ctx, curve0, curve1, len0, len1);

		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}

	return {
		id: 'filler',

		afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
			var count = (chart.data.datasets || []).length;
			var propagate = options.propagate;
			var sources = [];
			var meta, i, el, source;

			for (i = 0; i < count; ++i) {
				meta = chart.getDatasetMeta(i);
				el = meta.dataset;
				source = null;

				if (el && el._model && el instanceof elements.Line) {
					source = {
						visible: chart.isDatasetVisible(i),
						fill: decodeFill(el, i, count),
						chart: chart,
						el: el
					};
				}

				meta.$filler = source;
				sources.push(source);
			}

			for (i = 0; i < count; ++i) {
				source = sources[i];
				if (!source) {
					continue;
				}

				source.fill = resolveTarget(sources, i, propagate);
				source.boundary = computeBoundary(source);
				source.mapper = createMapper(source);
			}
		},

		beforeDatasetDraw: function beforeDatasetDraw(chart, args) {
			var meta = args.meta.$filler;
			if (!meta) {
				return;
			}

			var ctx = chart.ctx;
			var el = meta.el;
			var view = el._view;
			var points = el._children || [];
			var mapper = meta.mapper;
			var color = view.backgroundColor || defaults.global.defaultColor;

			if (mapper && color && points.length) {
				helpers.canvas.clipArea(ctx, chart.chartArea);
				doFill(ctx, points, mapper, view, color, el._loop);
				helpers.canvas.unclipArea(ctx);
			}
		}
	};
};

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	legend: {
		display: true,
		position: 'top',
		fullWidth: true,
		reverse: false,
		weight: 1000,

		// a callback that will handle
		onClick: function onClick(e, legendItem) {
			var index = legendItem.datasetIndex;
			var ci = this.chart;
			var meta = ci.getDatasetMeta(index);

			// See controller.isDatasetVisible comment
			meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

			// We hid a dataset ... rerender the chart
			ci.update();
		},

		onHover: null,

		labels: {
			boxWidth: 40,
			padding: 10,
			// Generates labels shown in the legend
			// Valid properties to return:
			// text : text to display
			// fillStyle : fill of coloured box
			// strokeStyle: stroke of coloured box
			// hidden : if this legend item refers to a hidden item
			// lineCap : cap style for line
			// lineDash
			// lineDashOffset :
			// lineJoin :
			// lineWidth :
			generateLabels: function generateLabels(chart) {
				var data = chart.data;
				return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
					return {
						text: dataset.label,
						fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
						hidden: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: dataset.borderDash,
						lineDashOffset: dataset.borderDashOffset,
						lineJoin: dataset.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
						pointStyle: dataset.pointStyle,

						// Below is extra data used for toggling the datasets
						datasetIndex: i
					};
				}, this) : [];
			}
		}
	},

	legendCallback: function legendCallback(chart) {
		var text = [];
		text.push('<ul class="' + chart.id + '-legend">');
		for (var i = 0; i < chart.data.datasets.length; i++) {
			text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
			if (chart.data.datasets[i].label) {
				text.push(chart.data.datasets[i].label);
			}
			text.push('</li>');
		}
		text.push('</ul>');
		return text.join('');
	}
});

module.exports = function (Chart) {

	var layout = Chart.layoutService;
	var noop = helpers.noop;

	/**
  * Helper function to get the box width based on the usePointStyle option
  * @param labelopts {Object} the label options on the legend
  * @param fontSize {Number} the label font size
  * @return {Number} width of the color box area
  */
	function getBoxWidth(labelOpts, fontSize) {
		return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;
	}

	Chart.Legend = Element.extend({

		initialize: function initialize(config) {
			helpers.extend(this, config);

			// Contains hit boxes for each dataset (in dataset order)
			this.legendHitBoxes = [];

			// Are we in doughnut mode which has a different data type
			this.doughnutMode = false;
		},

		// These methods are ordered by lifecycle. Utilities then follow.
		// Any function defined here is inherited by all legend types.
		// Any function can be extended by the legend type

		beforeUpdate: noop,
		update: function update(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function setDimensions() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: function buildLabels() {
			var me = this;
			var labelOpts = me.options.labels || {};
			var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

			if (labelOpts.filter) {
				legendItems = legendItems.filter(function (item) {
					return labelOpts.filter(item, me.chart.data);
				});
			}

			if (me.options.reverse) {
				legendItems.reverse();
			}

			me.legendItems = legendItems;
		},
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function fit() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var display = opts.display;

			var ctx = me.ctx;

			var globalDefault = defaults.global;
			var valueOrDefault = helpers.valueOrDefault;
			var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
			var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
			var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
			var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

			// Reset hit boxes
			var hitboxes = me.legendHitBoxes = [];

			var minSize = me.minSize;
			var isHorizontal = me.isHorizontal();

			if (isHorizontal) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? 10 : 0;
			} else {
				minSize.width = display ? 10 : 0;
				minSize.height = me.maxHeight; // fill all the height
			}

			// Increase sizes here
			if (display) {
				ctx.font = labelFont;

				if (isHorizontal) {
					// Labels

					// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
					var lineWidths = me.lineWidths = [0];
					var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;

					ctx.textAlign = 'left';
					ctx.textBaseline = 'top';

					helpers.each(me.legendItems, function (legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

						if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
							totalHeight += fontSize + labelOpts.padding;
							lineWidths[lineWidths.length] = me.left;
						}

						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: width,
							height: fontSize
						};

						lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
					});

					minSize.height += totalHeight;
				} else {
					var vPadding = labelOpts.padding;
					var columnWidths = me.columnWidths = [];
					var totalWidth = labelOpts.padding;
					var currentColWidth = 0;
					var currentColHeight = 0;
					var itemHeight = fontSize + vPadding;

					helpers.each(me.legendItems, function (legendItem, i) {
						var boxWidth = getBoxWidth(labelOpts, fontSize);
						var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

						// If too tall, go to new column
						if (currentColHeight + itemHeight > minSize.height) {
							totalWidth += currentColWidth + labelOpts.padding;
							columnWidths.push(currentColWidth); // previous column width

							currentColWidth = 0;
							currentColHeight = 0;
						}

						// Get max width
						currentColWidth = Math.max(currentColWidth, itemWidth);
						currentColHeight += itemHeight;

						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: itemWidth,
							height: fontSize
						};
					});

					totalWidth += currentColWidth;
					columnWidths.push(currentColWidth);
					minSize.width += totalWidth;
				}
			}

			me.width = minSize.width;
			me.height = minSize.height;
		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function isHorizontal() {
			return this.options.position === 'top' || this.options.position === 'bottom';
		},

		// Actually draw the legend on the canvas
		draw: function draw() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var globalDefault = defaults.global;
			var lineDefault = globalDefault.elements.line;
			var legendWidth = me.width;
			var lineWidths = me.lineWidths;

			if (opts.display) {
				var ctx = me.ctx;
				var valueOrDefault = helpers.valueOrDefault;
				var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
				var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
				var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
				var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
				var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
				var cursor;

				// Canvas setup
				ctx.textAlign = 'left';
				ctx.textBaseline = 'middle';
				ctx.lineWidth = 0.5;
				ctx.strokeStyle = fontColor; // for strikethrough effect
				ctx.fillStyle = fontColor; // render in correct colour
				ctx.font = labelFont;

				var boxWidth = getBoxWidth(labelOpts, fontSize);
				var hitboxes = me.legendHitBoxes;

				// current position
				var drawLegendBox = function drawLegendBox(x, y, legendItem) {
					if (isNaN(boxWidth) || boxWidth <= 0) {
						return;
					}

					// Set the ctx for the box
					ctx.save();

					ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
					ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
					ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
					ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
					ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
					ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
					var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;

					if (ctx.setLineDash) {
						// IE 9 and 10 do not support line dash
						ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
					}

					if (opts.labels && opts.labels.usePointStyle) {
						// Recalculate x and y for drawPoint() because its expecting
						// x and y to be center of figure (instead of top left)
						var radius = fontSize * Math.SQRT2 / 2;
						var offSet = radius / Math.SQRT2;
						var centerX = x + offSet;
						var centerY = y + offSet;

						// Draw pointStyle as legend symbol
						helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
					} else {
						// Draw box as legend symbol
						if (!isLineWidthZero) {
							ctx.strokeRect(x, y, boxWidth, fontSize);
						}
						ctx.fillRect(x, y, boxWidth, fontSize);
					}

					ctx.restore();
				};
				var fillText = function fillText(x, y, legendItem, textWidth) {
					var halfFontSize = fontSize / 2;
					var xLeft = boxWidth + halfFontSize + x;
					var yMiddle = y + halfFontSize;

					ctx.fillText(legendItem.text, xLeft, yMiddle);

					if (legendItem.hidden) {
						// Strikethrough the text if hidden
						ctx.beginPath();
						ctx.lineWidth = 2;
						ctx.moveTo(xLeft, yMiddle);
						ctx.lineTo(xLeft + textWidth, yMiddle);
						ctx.stroke();
					}
				};

				// Horizontal
				var isHorizontal = me.isHorizontal();
				if (isHorizontal) {
					cursor = {
						x: me.left + (legendWidth - lineWidths[0]) / 2,
						y: me.top + labelOpts.padding,
						line: 0
					};
				} else {
					cursor = {
						x: me.left + labelOpts.padding,
						y: me.top + labelOpts.padding,
						line: 0
					};
				}

				var itemHeight = fontSize + labelOpts.padding;
				helpers.each(me.legendItems, function (legendItem, i) {
					var textWidth = ctx.measureText(legendItem.text).width;
					var width = boxWidth + fontSize / 2 + textWidth;
					var x = cursor.x;
					var y = cursor.y;

					if (isHorizontal) {
						if (x + width >= legendWidth) {
							y = cursor.y += itemHeight;
							cursor.line++;
							x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;
						}
					} else if (y + itemHeight > me.bottom) {
						x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
						y = cursor.y = me.top + labelOpts.padding;
						cursor.line++;
					}

					drawLegendBox(x, y, legendItem);

					hitboxes[i].left = x;
					hitboxes[i].top = y;

					// Fill the actual label
					fillText(x, y, legendItem, textWidth);

					if (isHorizontal) {
						cursor.x += width + labelOpts.padding;
					} else {
						cursor.y += itemHeight;
					}
				});
			}
		},

		/**
   * Handle an event
   * @private
   * @param {IEvent} event - The event to handle
   * @return {Boolean} true if a change occured
   */
		handleEvent: function handleEvent(e) {
			var me = this;
			var opts = me.options;
			var type = e.type === 'mouseup' ? 'click' : e.type;
			var changed = false;

			if (type === 'mousemove') {
				if (!opts.onHover) {
					return;
				}
			} else if (type === 'click') {
				if (!opts.onClick) {
					return;
				}
			} else {
				return;
			}

			// Chart event already has relative position in it
			var x = e.x;
			var y = e.y;

			if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
				// See if we are touching one of the dataset boxes
				var lh = me.legendHitBoxes;
				for (var i = 0; i < lh.length; ++i) {
					var hitBox = lh[i];

					if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
						// Touching an element
						if (type === 'click') {
							// use e.native for backwards compatibility
							opts.onClick.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						} else if (type === 'mousemove') {
							// use e.native for backwards compatibility
							opts.onHover.call(me, e.native, me.legendItems[i]);
							changed = true;
							break;
						}
					}
				}
			}

			return changed;
		}
	});

	function createNewLegendAndAttach(chart, legendOpts) {
		var legend = new Chart.Legend({
			ctx: chart.ctx,
			options: legendOpts,
			chart: chart
		});

		layout.configure(chart, legend, legendOpts);
		layout.addBox(chart, legend);
		chart.legend = legend;
	}

	return {
		id: 'legend',

		beforeInit: function beforeInit(chart) {
			var legendOpts = chart.options.legend;

			if (legendOpts) {
				createNewLegendAndAttach(chart, legendOpts);
			}
		},

		beforeUpdate: function beforeUpdate(chart) {
			var legendOpts = chart.options.legend;
			var legend = chart.legend;

			if (legendOpts) {
				helpers.mergeIf(legendOpts, defaults.global.legend);

				if (legend) {
					layout.configure(chart, legend, legendOpts);
					legend.options = legendOpts;
				} else {
					createNewLegendAndAttach(chart, legendOpts);
				}
			} else if (legend) {
				layout.removeBox(chart, legend);
				delete chart.legend;
			}
		},

		afterEvent: function afterEvent(chart, e) {
			var legend = chart.legend;
			if (legend) {
				legend.handleEvent(e);
			}
		}
	};
};

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var Element = __webpack_require__(31);
var helpers = __webpack_require__(4);

defaults._set('global', {
	title: {
		display: false,
		fontStyle: 'bold',
		fullWidth: true,
		lineHeight: 1.2,
		padding: 10,
		position: 'top',
		text: '',
		weight: 2000 // by default greater than legend (1000) to be above
	}
});

module.exports = function (Chart) {

	var layout = Chart.layoutService;
	var noop = helpers.noop;

	Chart.Title = Element.extend({
		initialize: function initialize(config) {
			var me = this;
			helpers.extend(me, config);

			// Contains hit boxes for each dataset (in dataset order)
			me.legendHitBoxes = [];
		},

		// These methods are ordered by lifecycle. Utilities then follow.

		beforeUpdate: noop,
		update: function update(maxWidth, maxHeight, margins) {
			var me = this;

			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();

			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;

			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();

			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();

			return me.minSize;
		},
		afterUpdate: noop,

		//

		beforeSetDimensions: noop,
		setDimensions: function setDimensions() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;

				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}

			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;

			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,

		//

		beforeBuildLabels: noop,
		buildLabels: noop,
		afterBuildLabels: noop,

		//

		beforeFit: noop,
		fit: function fit() {
			var me = this;
			var valueOrDefault = helpers.valueOrDefault;
			var opts = me.options;
			var display = opts.display;
			var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
			var minSize = me.minSize;
			var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
			var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
			var textSize = display ? lineCount * lineHeight + opts.padding * 2 : 0;

			if (me.isHorizontal()) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = textSize;
			} else {
				minSize.width = textSize;
				minSize.height = me.maxHeight; // fill all the height
			}

			me.width = minSize.width;
			me.height = minSize.height;
		},
		afterFit: noop,

		// Shared Methods
		isHorizontal: function isHorizontal() {
			var pos = this.options.position;
			return pos === 'top' || pos === 'bottom';
		},

		// Actually draw the title block on the canvas
		draw: function draw() {
			var me = this;
			var ctx = me.ctx;
			var valueOrDefault = helpers.valueOrDefault;
			var opts = me.options;
			var globalDefaults = defaults.global;

			if (opts.display) {
				var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
				var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
				var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
				var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
				var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
				var offset = lineHeight / 2 + opts.padding;
				var rotation = 0;
				var top = me.top;
				var left = me.left;
				var bottom = me.bottom;
				var right = me.right;
				var maxWidth, titleX, titleY;

				ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
				ctx.font = titleFont;

				// Horizontal
				if (me.isHorizontal()) {
					titleX = left + (right - left) / 2; // midpoint of the width
					titleY = top + offset;
					maxWidth = right - left;
				} else {
					titleX = opts.position === 'left' ? left + offset : right - offset;
					titleY = top + (bottom - top) / 2;
					maxWidth = bottom - top;
					rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
				}

				ctx.save();
				ctx.translate(titleX, titleY);
				ctx.rotate(rotation);
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';

				var text = opts.text;
				if (helpers.isArray(text)) {
					var y = 0;
					for (var i = 0; i < text.length; ++i) {
						ctx.fillText(text[i], 0, y, maxWidth);
						y += lineHeight;
					}
				} else {
					ctx.fillText(text, 0, 0, maxWidth);
				}

				ctx.restore();
			}
		}
	});

	function createNewTitleBlockAndAttach(chart, titleOpts) {
		var title = new Chart.Title({
			ctx: chart.ctx,
			options: titleOpts,
			chart: chart
		});

		layout.configure(chart, title, titleOpts);
		layout.addBox(chart, title);
		chart.titleBlock = title;
	}

	return {
		id: 'title',

		beforeInit: function beforeInit(chart) {
			var titleOpts = chart.options.title;

			if (titleOpts) {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		},

		beforeUpdate: function beforeUpdate(chart) {
			var titleOpts = chart.options.title;
			var titleBlock = chart.titleBlock;

			if (titleOpts) {
				helpers.mergeIf(titleOpts, defaults.global.title);

				if (titleBlock) {
					layout.configure(chart, titleBlock, titleOpts);
					titleBlock.options = titleOpts;
				} else {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			} else if (titleBlock) {
				Chart.layoutService.removeBox(chart, titleBlock);
				delete chart.titleBlock;
			}
		}
	};
};

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Chart) {

	// Default config for a category scale
	var defaultConfig = {
		position: 'bottom'
	};

	var DatasetScale = Chart.Scale.extend({
		/**
  * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
  * else fall back to data.labels
  * @private
  */
		getLabels: function getLabels() {
			var data = this.chart.data;
			return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
		},

		determineDataLimits: function determineDataLimits() {
			var me = this;
			var labels = me.getLabels();
			me.minIndex = 0;
			me.maxIndex = labels.length - 1;
			var findIndex;

			if (me.options.ticks.min !== undefined) {
				// user specified min value
				findIndex = labels.indexOf(me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}

			if (me.options.ticks.max !== undefined) {
				// user specified max value
				findIndex = labels.indexOf(me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}

			me.min = labels[me.minIndex];
			me.max = labels[me.maxIndex];
		},

		buildTicks: function buildTicks() {
			var me = this;
			var labels = me.getLabels();
			// If we are viewing some subset of labels, slice the original array
			me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
		},

		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var isHorizontal = me.isHorizontal();

			if (data.yLabels && !isHorizontal) {
				return me.getRightValue(data.datasets[datasetIndex].data[index]);
			}
			return me.ticks[index - me.minIndex];
		},

		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: function getPixelForValue(value, index) {
			var me = this;
			var offset = me.options.offset;
			// 1 is added because we need the length but we have the indexes
			var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);

			// If value is a data object, then index is the index in the data array,
			// not the index of the scale. We need to change that.
			var valueCategory;
			if (value !== undefined && value !== null) {
				valueCategory = me.isHorizontal() ? value.x : value.y;
			}
			if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
				var labels = me.getLabels();
				value = valueCategory || value;
				var idx = labels.indexOf(value);
				index = idx !== -1 ? idx : index;
			}

			if (me.isHorizontal()) {
				var valueWidth = me.width / offsetAmt;
				var widthOffset = valueWidth * (index - me.minIndex);

				if (offset) {
					widthOffset += valueWidth / 2;
				}

				return me.left + Math.round(widthOffset);
			}
			var valueHeight = me.height / offsetAmt;
			var heightOffset = valueHeight * (index - me.minIndex);

			if (offset) {
				heightOffset += valueHeight / 2;
			}

			return me.top + Math.round(heightOffset);
		},
		getPixelForTick: function getPixelForTick(index) {
			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
		},
		getValueForPixel: function getValueForPixel(pixel) {
			var me = this;
			var offset = me.options.offset;
			var value;
			var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
			var horz = me.isHorizontal();
			var valueDimension = (horz ? me.width : me.height) / offsetAmt;

			pixel -= horz ? me.left : me.top;

			if (offset) {
				pixel -= valueDimension / 2;
			}

			if (pixel <= 0) {
				value = 0;
			} else {
				value = Math.round(pixel / valueDimension);
			}

			return value + me.minIndex;
		},
		getBasePixel: function getBasePixel() {
			return this.bottom;
		}
	});

	Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);
var Ticks = __webpack_require__(75);

module.exports = function (Chart) {

	var defaultConfig = {
		position: 'left',
		ticks: {
			callback: Ticks.formatters.linear
		}
	};

	var LinearScale = Chart.LinearScaleBase.extend({

		determineDataLimits: function determineDataLimits() {
			var me = this;
			var opts = me.options;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var isHorizontal = me.isHorizontal();
			var DEFAULT_MIN = 0;
			var DEFAULT_MAX = 1;

			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// First Calculate the range
			me.min = null;
			me.max = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function (dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function (dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [meta.type,
					// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
					opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

					if (valuesPerStack[key] === undefined) {
						valuesPerStack[key] = {
							positiveValues: [],
							negativeValues: []
						};
					}

					// Store these per type
					var positiveValues = valuesPerStack[key].positiveValues;
					var negativeValues = valuesPerStack[key].negativeValues;

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function (rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							positiveValues[index] = positiveValues[index] || 0;
							negativeValues[index] = negativeValues[index] || 0;

							if (opts.relativePoints) {
								positiveValues[index] = 100;
							} else if (value < 0) {
								negativeValues[index] += value;
							} else {
								positiveValues[index] += value;
							}
						});
					}
				});

				helpers.each(valuesPerStack, function (valuesForType) {
					var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
					var minVal = helpers.min(values);
					var maxVal = helpers.max(values);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});
			} else {
				helpers.each(datasets, function (dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function (rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}
						});
					}
				});
			}

			me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
			me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			this.handleTickRangeOptions();
		},
		getTickLimit: function getTickLimit() {
			var maxTicks;
			var me = this;
			var tickOpts = me.options.ticks;

			if (me.isHorizontal()) {
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
			} else {
				// The factor of 2 used to scale the font size has been experimentally determined.
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
			}

			return maxTicks;
		},
		// Called after the ticks are built. We need
		handleDirectionalChanges: function handleDirectionalChanges() {
			if (!this.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				this.ticks.reverse();
			}
		},
		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		// Utils
		getPixelForValue: function getPixelForValue(value) {
			// This must be called after fit has been run so that
			// this.left, this.top, this.right, and this.bottom have been defined
			var me = this;
			var start = me.start;

			var rightValue = +me.getRightValue(value);
			var pixel;
			var range = me.end - start;

			if (me.isHorizontal()) {
				pixel = me.left + me.width / range * (rightValue - start);
				return Math.round(pixel);
			}

			pixel = me.bottom - me.height / range * (rightValue - start);
			return Math.round(pixel);
		},
		getValueForPixel: function getValueForPixel(pixel) {
			var me = this;
			var isHorizontal = me.isHorizontal();
			var innerDimension = isHorizontal ? me.width : me.height;
			var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
			return me.start + (me.end - me.start) * offset;
		},
		getPixelForTick: function getPixelForTick(index) {
			return this.getPixelForValue(this.ticksAsNumbers[index]);
		}
	});
	Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
};

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);
var Ticks = __webpack_require__(75);

module.exports = function (Chart) {

	var noop = helpers.noop;

	Chart.LinearScaleBase = Chart.Scale.extend({
		getRightValue: function getRightValue(value) {
			if (typeof value === 'string') {
				return +value;
			}
			return Chart.Scale.prototype.getRightValue.call(this, value);
		},

		handleTickRangeOptions: function handleTickRangeOptions() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
			// do nothing since that would make the chart weird. If the user really wants a weird chart
			// axis, they can manually override it
			if (tickOpts.beginAtZero) {
				var minSign = helpers.sign(me.min);
				var maxSign = helpers.sign(me.max);

				if (minSign < 0 && maxSign < 0) {
					// move the top up to 0
					me.max = 0;
				} else if (minSign > 0 && maxSign > 0) {
					// move the bottom down to 0
					me.min = 0;
				}
			}

			var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
			var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

			if (tickOpts.min !== undefined) {
				me.min = tickOpts.min;
			} else if (tickOpts.suggestedMin !== undefined) {
				if (me.min === null) {
					me.min = tickOpts.suggestedMin;
				} else {
					me.min = Math.min(me.min, tickOpts.suggestedMin);
				}
			}

			if (tickOpts.max !== undefined) {
				me.max = tickOpts.max;
			} else if (tickOpts.suggestedMax !== undefined) {
				if (me.max === null) {
					me.max = tickOpts.suggestedMax;
				} else {
					me.max = Math.max(me.max, tickOpts.suggestedMax);
				}
			}

			if (setMin !== setMax) {
				// We set the min or the max but not both.
				// So ensure that our range is good
				// Inverted or 0 length range can happen when
				// ticks.min is set, and no datasets are visible
				if (me.min >= me.max) {
					if (setMin) {
						me.max = me.min + 1;
					} else {
						me.min = me.max - 1;
					}
				}
			}

			if (me.min === me.max) {
				me.max++;

				if (!tickOpts.beginAtZero) {
					me.min--;
				}
			}
		},
		getTickLimit: noop,
		handleDirectionalChanges: noop,

		buildTicks: function buildTicks() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph. Make sure we always have at least 2 ticks
			var maxTicks = me.getTickLimit();
			maxTicks = Math.max(2, maxTicks);

			var numericGeneratorOptions = {
				maxTicks: maxTicks,
				min: tickOpts.min,
				max: tickOpts.max,
				stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
			};
			var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);

			me.handleDirectionalChanges();

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				ticks.reverse();

				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function convertTicksToLabels() {
			var me = this;
			me.ticksAsNumbers = me.ticks.slice();
			me.zeroLineIndex = me.ticks.indexOf(0);

			Chart.Scale.prototype.convertTicksToLabels.call(me);
		}
	});
};

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var helpers = __webpack_require__(4);
var Ticks = __webpack_require__(75);

module.exports = function (Chart) {

	var defaultConfig = {
		position: 'left',

		// label settings
		ticks: {
			callback: Ticks.formatters.logarithmic
		}
	};

	var LogarithmicScale = Chart.Scale.extend({
		determineDataLimits: function determineDataLimits() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var valueOrDefault = helpers.valueOrDefault;
			var isHorizontal = me.isHorizontal();
			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// Calculate Range
			me.min = null;
			me.max = null;
			me.minNotZero = null;

			var hasStacks = opts.stacked;
			if (hasStacks === undefined) {
				helpers.each(datasets, function (dataset, datasetIndex) {
					if (hasStacks) {
						return;
					}

					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
						hasStacks = true;
					}
				});
			}

			if (opts.stacked || hasStacks) {
				var valuesPerStack = {};

				helpers.each(datasets, function (dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var key = [meta.type,
					// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
					opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = [];
						}

						helpers.each(dataset.data, function (rawValue, index) {
							var values = valuesPerStack[key];
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							values[index] = values[index] || 0;

							if (opts.relativePoints) {
								values[index] = 100;
							} else {
								// Don't need to split positive and negative since the log scale can't handle a 0 crossing
								values[index] += value;
							}
						});
					}
				});

				helpers.each(valuesPerStack, function (valuesForType) {
					var minVal = helpers.min(valuesForType);
					var maxVal = helpers.max(valuesForType);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});
			} else {
				helpers.each(datasets, function (dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						helpers.each(dataset.data, function (rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							if (me.min === null) {
								me.min = value;
							} else if (value < me.min) {
								me.min = value;
							}

							if (me.max === null) {
								me.max = value;
							} else if (value > me.max) {
								me.max = value;
							}

							if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
								me.minNotZero = value;
							}
						});
					}
				});
			}

			me.min = valueOrDefault(tickOpts.min, me.min);
			me.max = valueOrDefault(tickOpts.max, me.max);

			if (me.min === me.max) {
				if (me.min !== 0 && me.min !== null) {
					me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
					me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
				} else {
					me.min = 1;
					me.max = 10;
				}
			}
		},
		buildTicks: function buildTicks() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;

			var generationOptions = {
				min: tickOpts.min,
				max: tickOpts.max
			};
			var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);

			if (!me.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				ticks.reverse();
			}

			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);

			if (tickOpts.reverse) {
				ticks.reverse();

				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function convertTicksToLabels() {
			this.tickValues = this.ticks.slice();

			Chart.Scale.prototype.convertTicksToLabels.call(this);
		},
		// Get the correct tooltip label
		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		getPixelForTick: function getPixelForTick(index) {
			return this.getPixelForValue(this.tickValues[index]);
		},
		getPixelForValue: function getPixelForValue(value) {
			var me = this;
			var start = me.start;
			var newVal = +me.getRightValue(value);
			var opts = me.options;
			var tickOpts = opts.ticks;
			var innerDimension, pixel, range;

			if (me.isHorizontal()) {
				range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
				if (newVal === 0) {
					pixel = me.left;
				} else {
					innerDimension = me.width;
					pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
				}
			} else {
				// Bottom - top since pixels increase downward on a screen
				innerDimension = me.height;
				if (start === 0 && !tickOpts.reverse) {
					range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
					if (newVal === start) {
						pixel = me.bottom;
					} else if (newVal === me.minNotZero) {
						pixel = me.bottom - innerDimension * 0.02;
					} else {
						pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
					}
				} else if (me.end === 0 && tickOpts.reverse) {
					range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
					if (newVal === me.end) {
						pixel = me.top;
					} else if (newVal === me.minNotZero) {
						pixel = me.top + innerDimension * 0.02;
					} else {
						pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));
					}
				} else if (newVal === 0) {
					pixel = tickOpts.reverse ? me.top : me.bottom;
				} else {
					range = helpers.log10(me.end) - helpers.log10(start);
					innerDimension = me.height;
					pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));
				}
			}
			return pixel;
		},
		getValueForPixel: function getValueForPixel(pixel) {
			var me = this;
			var range = helpers.log10(me.end) - helpers.log10(me.start);
			var value, innerDimension;

			if (me.isHorizontal()) {
				innerDimension = me.width;
				value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
			} else {
				// todo: if start === 0
				innerDimension = me.height;
				value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
			}
			return value;
		}
	});
	Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
};

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);
var Ticks = __webpack_require__(75);

module.exports = function (Chart) {

	var globalDefaults = defaults.global;

	var defaultConfig = {
		display: true,

		// Boolean - Whether to animate scaling the chart from the centre
		animate: true,
		position: 'chartArea',

		angleLines: {
			display: true,
			color: 'rgba(0, 0, 0, 0.1)',
			lineWidth: 1
		},

		gridLines: {
			circular: false
		},

		// label settings
		ticks: {
			// Boolean - Show a backdrop to the scale label
			showLabelBackdrop: true,

			// String - The colour of the label backdrop
			backdropColor: 'rgba(255,255,255,0.75)',

			// Number - The backdrop padding above & below the label in pixels
			backdropPaddingY: 2,

			// Number - The backdrop padding to the side of the label in pixels
			backdropPaddingX: 2,

			callback: Ticks.formatters.linear
		},

		pointLabels: {
			// Boolean - if true, show point labels
			display: true,

			// Number - Point label font size in pixels
			fontSize: 10,

			// Function - Used to convert point labels
			callback: function callback(label) {
				return label;
			}
		}
	};

	function getValueCount(scale) {
		var opts = scale.options;
		return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
	}

	function getPointLabelFontOptions(scale) {
		var pointLabelOptions = scale.options.pointLabels;
		var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
		var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
		var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
		var font = helpers.fontString(fontSize, fontStyle, fontFamily);

		return {
			size: fontSize,
			style: fontStyle,
			family: fontFamily,
			font: font
		};
	}

	function measureLabelSize(ctx, fontSize, label) {
		if (helpers.isArray(label)) {
			return {
				w: helpers.longestText(ctx, ctx.font, label),
				h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize
			};
		}

		return {
			w: ctx.measureText(label).width,
			h: fontSize
		};
	}

	function determineLimits(angle, pos, size, min, max) {
		if (angle === min || angle === max) {
			return {
				start: pos - size / 2,
				end: pos + size / 2
			};
		} else if (angle < min || angle > max) {
			return {
				start: pos - size - 5,
				end: pos
			};
		}

		return {
			start: pos,
			end: pos + size + 5
		};
	}

	/**
  * Helper function to fit a radial linear scale with point labels
  */
	function fitWithPointLabels(scale) {
		/*
   * Right, this is really confusing and there is a lot of maths going on here
   * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
   *
   * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
   *
   * Solution:
   *
   * We assume the radius of the polygon is half the size of the canvas at first
   * at each index we check if the text overlaps.
   *
   * Where it does, we store that angle and that index.
   *
   * After finding the largest index and angle we calculate how much we need to remove
   * from the shape radius to move the point inwards by that x.
   *
   * We average the left and right distances to get the maximum shape radius that can fit in the box
   * along with labels.
   *
   * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
   * on each side, removing that from the size, halving it and adding the left x protrusion width.
   *
   * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
   * and position it in the most space efficient manner
   *
   * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
   */

		var plFont = getPointLabelFontOptions(scale);

		// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
		// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		var furthestLimits = {
			r: scale.width,
			l: 0,
			t: scale.height,
			b: 0
		};
		var furthestAngles = {};
		var i, textSize, pointPosition;

		scale.ctx.font = plFont.font;
		scale._pointLabelSizes = [];

		var valueCount = getValueCount(scale);
		for (i = 0; i < valueCount; i++) {
			pointPosition = scale.getPointPosition(i, largestPossibleRadius);
			textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
			scale._pointLabelSizes[i] = textSize;

			// Add quarter circle to make degree 0 mean top of circle
			var angleRadians = scale.getIndexAngle(i);
			var angle = helpers.toDegrees(angleRadians) % 360;
			var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
			var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

			if (hLimits.start < furthestLimits.l) {
				furthestLimits.l = hLimits.start;
				furthestAngles.l = angleRadians;
			}

			if (hLimits.end > furthestLimits.r) {
				furthestLimits.r = hLimits.end;
				furthestAngles.r = angleRadians;
			}

			if (vLimits.start < furthestLimits.t) {
				furthestLimits.t = vLimits.start;
				furthestAngles.t = angleRadians;
			}

			if (vLimits.end > furthestLimits.b) {
				furthestLimits.b = vLimits.end;
				furthestAngles.b = angleRadians;
			}
		}

		scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
	}

	/**
  * Helper function to fit a radial linear scale with no point labels
  */
	function _fit(scale) {
		var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
		scale.drawingArea = Math.round(largestPossibleRadius);
		scale.setCenterPoint(0, 0, 0, 0);
	}

	function getTextAlignForAngle(angle) {
		if (angle === 0 || angle === 180) {
			return 'center';
		} else if (angle < 180) {
			return 'left';
		}

		return 'right';
	}

	function fillText(ctx, text, position, fontSize) {
		if (helpers.isArray(text)) {
			var y = position.y;
			var spacing = 1.5 * fontSize;

			for (var i = 0; i < text.length; ++i) {
				ctx.fillText(text[i], position.x, y);
				y += spacing;
			}
		} else {
			ctx.fillText(text, position.x, position.y);
		}
	}

	function adjustPointPositionForLabelHeight(angle, textSize, position) {
		if (angle === 90 || angle === 270) {
			position.y -= textSize.h / 2;
		} else if (angle > 270 || angle < 90) {
			position.y -= textSize.h;
		}
	}

	function drawPointLabels(scale) {
		var ctx = scale.ctx;
		var valueOrDefault = helpers.valueOrDefault;
		var opts = scale.options;
		var angleLineOpts = opts.angleLines;
		var pointLabelOpts = opts.pointLabels;

		ctx.lineWidth = angleLineOpts.lineWidth;
		ctx.strokeStyle = angleLineOpts.color;

		var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

		// Point Label Font
		var plFont = getPointLabelFontOptions(scale);

		ctx.textBaseline = 'top';

		for (var i = getValueCount(scale) - 1; i >= 0; i--) {
			if (angleLineOpts.display) {
				var outerPosition = scale.getPointPosition(i, outerDistance);
				ctx.beginPath();
				ctx.moveTo(scale.xCenter, scale.yCenter);
				ctx.lineTo(outerPosition.x, outerPosition.y);
				ctx.stroke();
				ctx.closePath();
			}

			if (pointLabelOpts.display) {
				// Extra 3px out for some label spacing
				var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

				// Keep this in loop since we may support array properties here
				var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
				ctx.font = plFont.font;
				ctx.fillStyle = pointLabelFontColor;

				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians);
				ctx.textAlign = getTextAlignForAngle(angle);
				adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
			}
		}
	}

	function drawRadiusLine(scale, gridLineOpts, radius, index) {
		var ctx = scale.ctx;
		ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
		ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

		if (scale.options.gridLines.circular) {
			// Draw circular arcs between the points
			ctx.beginPath();
			ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
			ctx.closePath();
			ctx.stroke();
		} else {
			// Draw straight lines connecting each index
			var valueCount = getValueCount(scale);

			if (valueCount === 0) {
				return;
			}

			ctx.beginPath();
			var pointPosition = scale.getPointPosition(0, radius);
			ctx.moveTo(pointPosition.x, pointPosition.y);

			for (var i = 1; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, radius);
				ctx.lineTo(pointPosition.x, pointPosition.y);
			}

			ctx.closePath();
			ctx.stroke();
		}
	}

	function numberOrZero(param) {
		return helpers.isNumber(param) ? param : 0;
	}

	var LinearRadialScale = Chart.LinearScaleBase.extend({
		setDimensions: function setDimensions() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			// Set the unconstrained dimension before label rotation
			me.width = me.maxWidth;
			me.height = me.maxHeight;
			me.xCenter = Math.round(me.width / 2);
			me.yCenter = Math.round(me.height / 2);

			var minSize = helpers.min([me.height, me.width]);
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;
		},
		determineDataLimits: function determineDataLimits() {
			var me = this;
			var chart = me.chart;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;

			helpers.each(chart.data.datasets, function (dataset, datasetIndex) {
				if (chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex);

					helpers.each(dataset.data, function (rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}

						min = Math.min(value, min);
						max = Math.max(value, max);
					});
				}
			});

			me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
			me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;

			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			me.handleTickRangeOptions();
		},
		getTickLimit: function getTickLimit() {
			var tickOpts = this.options.ticks;
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
		},
		convertTicksToLabels: function convertTicksToLabels() {
			var me = this;

			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

			// Point labels
			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
		},
		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		fit: function fit() {
			if (this.options.pointLabels.display) {
				fitWithPointLabels(this);
			} else {
				_fit(this);
			}
		},
		/**
   * Set radius reductions and determine new radius and center point
   * @private
   */
		setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
			var me = this;
			var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
			var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
			var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
			var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

			radiusReductionLeft = numberOrZero(radiusReductionLeft);
			radiusReductionRight = numberOrZero(radiusReductionRight);
			radiusReductionTop = numberOrZero(radiusReductionTop);
			radiusReductionBottom = numberOrZero(radiusReductionBottom);

			me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
			me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
		},
		setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
			var me = this;
			var maxRight = me.width - rightMovement - me.drawingArea;
			var maxLeft = leftMovement + me.drawingArea;
			var maxTop = topMovement + me.drawingArea;
			var maxBottom = me.height - bottomMovement - me.drawingArea;

			me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);
			me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);
		},

		getIndexAngle: function getIndexAngle(index) {
			var angleMultiplier = Math.PI * 2 / getValueCount(this);
			var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;

			var startAngleRadians = startAngle * Math.PI * 2 / 360;

			// Start from the top instead of right, so remove a quarter of the circle
			return index * angleMultiplier + startAngleRadians;
		},
		getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
			var me = this;

			if (value === null) {
				return 0; // null always in center
			}

			// Take into account half font size + the yPadding of the top value
			var scalingFactor = me.drawingArea / (me.max - me.min);
			if (me.options.ticks.reverse) {
				return (me.max - value) * scalingFactor;
			}
			return (value - me.min) * scalingFactor;
		},
		getPointPosition: function getPointPosition(index, distanceFromCenter) {
			var me = this;
			var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
			return {
				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
			};
		},
		getPointPositionForValue: function getPointPositionForValue(index, value) {
			return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
		},

		getBasePosition: function getBasePosition() {
			var me = this;
			var min = me.min;
			var max = me.max;

			return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
		},

		draw: function draw() {
			var me = this;
			var opts = me.options;
			var gridLineOpts = opts.gridLines;
			var tickOpts = opts.ticks;
			var valueOrDefault = helpers.valueOrDefault;

			if (opts.display) {
				var ctx = me.ctx;
				var startAngle = this.getIndexAngle(0);

				// Tick Font
				var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
				var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

				helpers.each(me.ticks, function (label, index) {
					// Don't draw a centre value (if it is minimum)
					if (index > 0 || tickOpts.reverse) {
						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

						// Draw circular lines around the scale
						if (gridLineOpts.display && index !== 0) {
							drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
						}

						if (tickOpts.display) {
							var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = tickLabelFont;

							ctx.save();
							ctx.translate(me.xCenter, me.yCenter);
							ctx.rotate(startAngle);

							if (tickOpts.showLabelBackdrop) {
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = tickOpts.backdropColor;
								ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);
							}

							ctx.textAlign = 'center';
							ctx.textBaseline = 'middle';
							ctx.fillStyle = tickFontColor;
							ctx.fillText(label, 0, -yCenterOffset);
							ctx.restore();
						}
					}
				});

				if (opts.angleLines.display || opts.pointLabels.display) {
					drawPointLabels(me);
				}
			}
		}
	});
	Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
};

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */


var moment = __webpack_require__(0);
moment = typeof moment === 'function' ? moment : window.moment;

var defaults = __webpack_require__(9);
var helpers = __webpack_require__(4);

// Integer constants are from the ES6 spec.
var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

var INTERVALS = {
	millisecond: {
		major: true,
		size: 1,
		steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
	},
	second: {
		major: true,
		size: 1000,
		steps: [1, 2, 5, 10, 30]
	},
	minute: {
		major: true,
		size: 60000,
		steps: [1, 2, 5, 10, 30]
	},
	hour: {
		major: true,
		size: 3600000,
		steps: [1, 2, 3, 6, 12]
	},
	day: {
		major: true,
		size: 86400000,
		steps: [1, 2, 5]
	},
	week: {
		major: false,
		size: 604800000,
		steps: [1, 2, 3, 4]
	},
	month: {
		major: true,
		size: 2.628e9,
		steps: [1, 2, 3]
	},
	quarter: {
		major: false,
		size: 7.884e9,
		steps: [1, 2, 3, 4]
	},
	year: {
		major: true,
		size: 3.154e10
	}
};

var UNITS = Object.keys(INTERVALS);

function sorter(a, b) {
	return a - b;
}

function arrayUnique(items) {
	var hash = {};
	var out = [];
	var i, ilen, item;

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		item = items[i];
		if (!hash[item]) {
			hash[item] = true;
			out.push(item);
		}
	}

	return out;
}

/**
 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
 * extremity (left + width or top + height). Note that it would be more optimized to directly
 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
 *
 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
 * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
 * If 'series', timestamps will be positioned at the same distance from each other. In this
 * case, only timestamps that break the time linearity are registered, meaning that in the
 * best case, all timestamps are linear, the table contains only min and max.
 */
function buildLookupTable(timestamps, min, max, distribution) {
	if (distribution === 'linear' || !timestamps.length) {
		return [{ time: min, pos: 0 }, { time: max, pos: 1 }];
	}

	var table = [];
	var items = [min];
	var i, ilen, prev, curr, next;

	for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
		curr = timestamps[i];
		if (curr > min && curr < max) {
			items.push(curr);
		}
	}

	items.push(max);

	for (i = 0, ilen = items.length; i < ilen; ++i) {
		next = items[i + 1];
		prev = items[i - 1];
		curr = items[i];

		// only add points that breaks the scale linearity
		if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
			table.push({ time: curr, pos: i / (ilen - 1) });
		}
	}

	return table;
}

// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
function lookup(table, key, value) {
	var lo = 0;
	var hi = table.length - 1;
	var mid, i0, i1;

	while (lo >= 0 && lo <= hi) {
		mid = lo + hi >> 1;
		i0 = table[mid - 1] || null;
		i1 = table[mid];

		if (!i0) {
			// given value is outside table (before first item)
			return { lo: null, hi: i1 };
		} else if (i1[key] < value) {
			lo = mid + 1;
		} else if (i0[key] > value) {
			hi = mid - 1;
		} else {
			return { lo: i0, hi: i1 };
		}
	}

	// given value is outside table (after last item)
	return { lo: i1, hi: null };
}

/**
 * Linearly interpolates the given source `value` using the table items `skey` values and
 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
 * index [0, 1] or [n - 1, n] are used for the interpolation.
 */
function interpolate(table, skey, sval, tkey) {
	var range = lookup(table, skey, sval);

	// Note: the lookup table ALWAYS contains at least 2 items (min and max)
	var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
	var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

	var span = next[skey] - prev[skey];
	var ratio = span ? (sval - prev[skey]) / span : 0;
	var offset = (next[tkey] - prev[tkey]) * ratio;

	return prev[tkey] + offset;
}

/**
 * Convert the given value to a moment object using the given time options.
 * @see http://momentjs.com/docs/#/parsing/
 */
function momentify(value, options) {
	var parser = options.parser;
	var format = options.parser || options.format;

	if (typeof parser === 'function') {
		return parser(value);
	}

	if (typeof value === 'string' && typeof format === 'string') {
		return moment(value, format);
	}

	if (!(value instanceof moment)) {
		value = moment(value);
	}

	if (value.isValid()) {
		return value;
	}

	// Labels are in an incompatible moment format and no `parser` has been provided.
	// The user might still use the deprecated `format` option to convert his inputs.
	if (typeof format === 'function') {
		return format(value);
	}

	return value;
}

function parse(input, scale) {
	if (helpers.isNullOrUndef(input)) {
		return null;
	}

	var options = scale.options.time;
	var value = momentify(scale.getRightValue(input), options);
	if (!value.isValid()) {
		return null;
	}

	if (options.round) {
		value.startOf(options.round);
	}

	return value.valueOf();
}

/**
 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
 */
function determineStepSize(min, max, unit, capacity) {
	var range = max - min;
	var interval = INTERVALS[unit];
	var milliseconds = interval.size;
	var steps = interval.steps;
	var i, ilen, factor;

	if (!steps) {
		return Math.ceil(range / ((capacity || 1) * milliseconds));
	}

	for (i = 0, ilen = steps.length; i < ilen; ++i) {
		factor = steps[i];
		if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
			break;
		}
	}

	return factor;
}

function determineUnit(minUnit, min, max, capacity) {
	var ilen = UNITS.length;
	var i, interval, factor;

	for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
		interval = INTERVALS[UNITS[i]];
		factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

		if (Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
			return UNITS[i];
		}
	}

	return UNITS[ilen - 1];
}

function determineMajorUnit(unit) {
	for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
		if (INTERVALS[UNITS[i]].major) {
			return UNITS[i];
		}
	}
}

/**
 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
 * Important: this method can return ticks outside the min and max range, it's the
 * responsibility of the calling code to clamp values if needed.
 */
function generate(min, max, minor, major, capacity, options) {
	var timeOpts = options.time;
	var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
	var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
	var majorTicksEnabled = options.ticks.major.enabled;
	var interval = INTERVALS[minor];
	var first = moment(min);
	var last = moment(max);
	var ticks = [];
	var time;

	if (!stepSize) {
		stepSize = determineStepSize(min, max, minor, capacity);
	}

	// For 'week' unit, handle the first day of week option
	if (weekday) {
		first = first.isoWeekday(weekday);
		last = last.isoWeekday(weekday);
	}

	// Align first/last ticks on unit
	first = first.startOf(weekday ? 'day' : minor);
	last = last.startOf(weekday ? 'day' : minor);

	// Make sure that the last tick include max
	if (last < max) {
		last.add(1, minor);
	}

	time = moment(first);

	if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
		// Align the first tick on the previous `minor` unit aligned on the `major` unit:
		// we first aligned time on the previous `major` unit then add the number of full
		// stepSize there is between first and the previous major time.
		time.startOf(major);
		time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
	}

	for (; time < last; time.add(stepSize, minor)) {
		ticks.push(+time);
	}

	ticks.push(+time);

	return ticks;
}

/**
 * Returns the right and left offsets from edges in the form of {left, right}.
 * Offsets are added when the `offset` option is true.
 */
function computeOffsets(table, ticks, min, max, options) {
	var left = 0;
	var right = 0;
	var upper, lower;

	if (options.offset && ticks.length) {
		if (!options.time.min) {
			upper = ticks.length > 1 ? ticks[1] : max;
			lower = ticks[0];
			left = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
		}
		if (!options.time.max) {
			upper = ticks[ticks.length - 1];
			lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
			right = (interpolate(table, 'time', upper, 'pos') - interpolate(table, 'time', lower, 'pos')) / 2;
		}
	}

	return { left: left, right: right };
}

function ticksFromTimestamps(values, majorUnit) {
	var ticks = [];
	var i, ilen, value, major;

	for (i = 0, ilen = values.length; i < ilen; ++i) {
		value = values[i];
		major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

		ticks.push({
			value: value,
			major: major
		});
	}

	return ticks;
}

module.exports = function (Chart) {

	var defaultConfig = {
		position: 'bottom',

		/**
   * Data distribution along the scale:
   * - 'linear': data are spread according to their time (distances can vary),
   * - 'series': data are spread at the same distance from each other.
   * @see https://github.com/chartjs/Chart.js/pull/4507
   * @since 2.7.0
   */
		distribution: 'linear',

		/**
   * Scale boundary strategy (bypassed by min/max time options)
   * - `data`: make sure data are fully visible, ticks outside are removed
   * - `ticks`: make sure ticks are fully visible, data outside are truncated
   * @see https://github.com/chartjs/Chart.js/pull/4556
   * @since 2.7.0
   */
		bounds: 'data',

		time: {
			parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
			format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
			unit: false, // false == automatic or override with week, month, year, etc.
			round: false, // none, or override with week, month, year, etc.
			displayFormat: false, // DEPRECATED
			isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
			minUnit: 'millisecond',

			// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
			displayFormats: {
				millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
				second: 'h:mm:ss a', // 11:20:01 AM
				minute: 'h:mm a', // 11:20 AM
				hour: 'hA', // 5PM
				day: 'MMM D', // Sep 4
				week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
				month: 'MMM YYYY', // Sept 2015
				quarter: '[Q]Q - YYYY', // Q3
				year: 'YYYY' // 2015
			}
		},
		ticks: {
			autoSkip: false,

			/**
    * Ticks generation input values:
    * - 'auto': generates "optimal" ticks based on scale size and time options.
    * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
    * - 'labels': generates ticks from user given `data.labels` values ONLY.
    * @see https://github.com/chartjs/Chart.js/pull/4507
    * @since 2.7.0
    */
			source: 'auto',

			major: {
				enabled: false
			}
		}
	};

	var TimeScale = Chart.Scale.extend({
		initialize: function initialize() {
			if (!moment) {
				throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
			}

			this.mergeTicksOptions();

			Chart.Scale.prototype.initialize.call(this);
		},

		update: function update() {
			var me = this;
			var options = me.options;

			// DEPRECATIONS: output a message only one time per update
			if (options.time && options.time.format) {
				console.warn('options.time.format is deprecated and replaced by options.time.parser.');
			}

			return Chart.Scale.prototype.update.apply(me, arguments);
		},

		/**
   * Allows data to be referenced via 't' attribute
   */
		getRightValue: function getRightValue(rawValue) {
			if (rawValue && rawValue.t !== undefined) {
				rawValue = rawValue.t;
			}
			return Chart.Scale.prototype.getRightValue.call(this, rawValue);
		},

		determineDataLimits: function determineDataLimits() {
			var me = this;
			var chart = me.chart;
			var timeOpts = me.options.time;
			var min = parse(timeOpts.min, me) || MAX_INTEGER;
			var max = parse(timeOpts.max, me) || MIN_INTEGER;
			var timestamps = [];
			var datasets = [];
			var labels = [];
			var i, j, ilen, jlen, data, timestamp;

			// Convert labels to timestamps
			for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
				labels.push(parse(chart.data.labels[i], me));
			}

			// Convert data to timestamps
			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				if (chart.isDatasetVisible(i)) {
					data = chart.data.datasets[i].data;

					// Let's consider that all data have the same format.
					if (helpers.isObject(data[0])) {
						datasets[i] = [];

						for (j = 0, jlen = data.length; j < jlen; ++j) {
							timestamp = parse(data[j], me);
							timestamps.push(timestamp);
							datasets[i][j] = timestamp;
						}
					} else {
						timestamps.push.apply(timestamps, labels);
						datasets[i] = labels.slice(0);
					}
				} else {
					datasets[i] = [];
				}
			}

			if (labels.length) {
				// Sort labels **after** data have been converted
				labels = arrayUnique(labels).sort(sorter);
				min = Math.min(min, labels[0]);
				max = Math.max(max, labels[labels.length - 1]);
			}

			if (timestamps.length) {
				timestamps = arrayUnique(timestamps).sort(sorter);
				min = Math.min(min, timestamps[0]);
				max = Math.max(max, timestamps[timestamps.length - 1]);
			}

			// In case there is no valid min/max, let's use today limits
			min = min === MAX_INTEGER ? +moment().startOf('day') : min;
			max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;

			// Make sure that max is strictly higher than min (required by the lookup table)
			me.min = Math.min(min, max);
			me.max = Math.max(min + 1, max);

			// PRIVATE
			me._horizontal = me.isHorizontal();
			me._table = [];
			me._timestamps = {
				data: timestamps,
				datasets: datasets,
				labels: labels
			};
		},

		buildTicks: function buildTicks() {
			var me = this;
			var min = me.min;
			var max = me.max;
			var options = me.options;
			var timeOpts = options.time;
			var formats = timeOpts.displayFormats;
			var capacity = me.getLabelCapacity(min);
			var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, min, max, capacity);
			var majorUnit = determineMajorUnit(unit);
			var timestamps = [];
			var ticks = [];
			var i, ilen, timestamp;

			switch (options.ticks.source) {
				case 'data':
					timestamps = me._timestamps.data;
					break;
				case 'labels':
					timestamps = me._timestamps.labels;
					break;
				case 'auto':
				default:
					timestamps = generate(min, max, unit, majorUnit, capacity, options);
			}

			if (options.bounds === 'ticks' && timestamps.length) {
				min = timestamps[0];
				max = timestamps[timestamps.length - 1];
			}

			// Enforce limits with user min/max options
			min = parse(timeOpts.min, me) || min;
			max = parse(timeOpts.max, me) || max;

			// Remove ticks outside the min/max range
			for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
				timestamp = timestamps[i];
				if (timestamp >= min && timestamp <= max) {
					ticks.push(timestamp);
				}
			}

			me.min = min;
			me.max = max;

			// PRIVATE
			me._unit = unit;
			me._majorUnit = majorUnit;
			me._minorFormat = formats[unit];
			me._majorFormat = formats[majorUnit];
			me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
			me._offsets = computeOffsets(me._table, ticks, min, max, options);

			return ticksFromTimestamps(ticks, majorUnit);
		},

		getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
			var me = this;
			var data = me.chart.data;
			var timeOpts = me.options.time;
			var label = data.labels && index < data.labels.length ? data.labels[index] : '';
			var value = data.datasets[datasetIndex].data[index];

			if (helpers.isObject(value)) {
				label = me.getRightValue(value);
			}
			if (timeOpts.tooltipFormat) {
				label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
			}

			return label;
		},

		/**
   * Function to format an individual tick mark
   * @private
   */
		tickFormatFunction: function tickFormatFunction(tick, index, ticks) {
			var me = this;
			var options = me.options;
			var time = tick.valueOf();
			var majorUnit = me._majorUnit;
			var majorFormat = me._majorFormat;
			var majorTime = tick.clone().startOf(me._majorUnit).valueOf();
			var majorTickOpts = options.ticks.major;
			var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
			var label = tick.format(major ? majorFormat : me._minorFormat);
			var tickOpts = major ? majorTickOpts : options.ticks.minor;
			var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

			return formatter ? formatter(label, index, ticks) : label;
		},

		convertTicksToLabels: function convertTicksToLabels(ticks) {
			var labels = [];
			var i, ilen;

			for (i = 0, ilen = ticks.length; i < ilen; ++i) {
				labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
			}

			return labels;
		},

		/**
   * @private
   */
		getPixelForOffset: function getPixelForOffset(time) {
			var me = this;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = interpolate(me._table, 'time', time, 'pos');

			return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
		},

		getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
			var me = this;
			var time = null;

			if (index !== undefined && datasetIndex !== undefined) {
				time = me._timestamps.datasets[datasetIndex][index];
			}

			if (time === null) {
				time = parse(value, me);
			}

			if (time !== null) {
				return me.getPixelForOffset(time);
			}
		},

		getPixelForTick: function getPixelForTick(index) {
			var ticks = this.getTicks();
			return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
		},

		getValueForPixel: function getValueForPixel(pixel) {
			var me = this;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
			var time = interpolate(me._table, 'pos', pos, 'time');

			return moment(time);
		},

		/**
   * Crude approximation of what the label width might be
   * @private
   */
		getLabelWidth: function getLabelWidth(label) {
			var me = this;
			var ticksOpts = me.options.ticks;
			var tickLabelWidth = me.ctx.measureText(label).width;
			var angle = helpers.toRadians(ticksOpts.maxRotation);
			var cosRotation = Math.cos(angle);
			var sinRotation = Math.sin(angle);
			var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

			return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
		},

		/**
   * @private
   */
		getLabelCapacity: function getLabelCapacity(exampleTime) {
			var me = this;

			me._minorFormat = me.options.time.displayFormats.millisecond; // Pick the longest format for guestimation

			var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);
			var tickLabelWidth = me.getLabelWidth(exampleLabel);
			var innerWidth = me.isHorizontal() ? me.width : me.height;

			return Math.floor(innerWidth / tickLabelWidth);
		}
	});

	Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
};

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var colorNames = __webpack_require__(452);

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
};

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr = /^#([a-fA-F0-9]{3})$/i,
       hex = /^#([a-fA-F0-9]{6})$/i,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       keyword = /(\w+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   } else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   } else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   } else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   } else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   } else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
   var hsla = getHsla(string);
   return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   } else if (vals = getHsla(string)) {
      return vals[3];
   } else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = rgba[3] !== undefined ? rgba[3] : 1;
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0] / 255 * 100),
       g = Math.round(rgba[1] / 255 * 100),
       b = Math.round(rgba[2] / 255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0] / 255 * 100),
       g = Math.round(rgba[1] / 255 * 100),
       b = Math.round(rgba[2] / 255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || hsla[3] && hsla[3] < 1) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = hsla[3] !== undefined ? hsla[3] : 1;
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = hwb[3] !== undefined ? hwb[3] : 1;
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
   return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
   var str = num.toString(16).toUpperCase();
   return str.length < 2 ? "0" + str : str;
}

//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}

/***/ }),
/* 450 */
/***/ (function(module, exports) {

/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
};

function rgb2hsl(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      l;

  if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0) h += 360;

  l = (min + max) / 2;

  if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      v;

  if (max == 0) s = 0;else s = delta / max * 1000 / 10;

  if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0) h += 360;

  v = max / 255 * 1000 / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1 / 255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c,
      m,
      y,
      k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;

  return [x * 100, y * 100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
      x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1,
      t2,
      t3,
      rgb,
      val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv,
      v;

  if (l === 0) {
    // no need to do calc on black
    // also avoids divide by 0 error
    return [0, 0, 0];
  }

  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  v = (l + s) / 2;
  sv = 2 * s / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}

function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - s * f),
      t = 255 * v * (1 - s * (1 - f)),
      v = 255 * v;

  switch (hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl,
      l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= l <= 1 ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args));
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i,
      v,
      f,
      n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh); // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0:
      r = v;g = n;b = wh;break;
    case 1:
      r = n;g = v;b = wh;break;
    case 2:
      r = wh;g = v;b = n;break;
    case 3:
      r = wh;g = n;b = v;break;
    case 4:
      r = n;g = wh;b = v;break;
    case 5:
      r = v;g = wh;b = n;break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r,
      g,
      b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}

function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r,
      g,
      b;

  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570;

  // assume sRGB
  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;

  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;

  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x,
      y,
      z,
      y2;

  if (l <= 8) {
    y = l * 100 / 903.3;
    y2 = 7.787 * (y / 100) + 16 / 116;
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1 / 3);
  }

  x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr,
      h,
      c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a,
      b,
      hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(450);

var convert = function convert() {
  return new Converter();
};

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] = function (func) {
    // accept array or plain args
    return function (arg) {
      if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    };
  }(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = function (func) {
    return function (arg) {
      if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);

      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined) return val; // keyword

      for (var i = 0; i < val.length; i++) {
        val[i] = Math.round(val[i]);
      }return val;
    };
  }(func);
}

/* Converter does lazy conversion and caching */
var Converter = function Converter() {
  this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function (space, args) {
  var values = args[0];
  if (values === undefined) {
    // color.rgb()
    return this.getValues(space);
  }
  // color.rgb(10, 10, 10)
  if (typeof values == "number") {
    values = Array.prototype.slice.call(args);
  }

  return this.setValues(space, values);
};

/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function (space, values) {
  this.space = space;
  this.convs = {};
  this.convs[space] = values;
  return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function (space) {
  var vals = this.convs[space];
  if (!vals) {
    var fspace = this.space,
        from = this.convs[fspace];
    vals = convert[fspace][space](from);

    this.convs[space] = vals;
  }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
  Converter.prototype[space] = function (vals) {
    return this.routeSpace(space, arguments);
  };
});

module.exports = convert;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(460);
module.exports = __webpack_require__(36).RegExp.escape;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(8);
var isArray = __webpack_require__(92);
var SPECIES = __webpack_require__(11)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }return C === undefined ? Array : C;
};

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(7);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(3);
var toPrimitive = __webpack_require__(40);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(60);
var gOPS = __webpack_require__(96);
var pIE = __webpack_require__(78);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }return result;
};

/***/ }),
/* 458 */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),
/* 459 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(1);
var $re = __webpack_require__(458)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) {
    return $re(it);
  } });

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', { copyWithin: __webpack_require__(186) });

__webpack_require__(47)('copyWithin');

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $every = __webpack_require__(35)(4);

$export($export.P + $export.F * !__webpack_require__(34)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', { fill: __webpack_require__(109) });

__webpack_require__(47)('fill');

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $filter = __webpack_require__(35)(2);

$export($export.P + $export.F * !__webpack_require__(34)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(1);
var $find = __webpack_require__(35)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(47)(KEY);

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(1);
var $find = __webpack_require__(35)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(47)(KEY);

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $forEach = __webpack_require__(35)(0);
var STRICT = __webpack_require__(34)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(33);
var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var call = __webpack_require__(197);
var isArrayIter = __webpack_require__(117);
var toLength = __webpack_require__(15);
var createProperty = __webpack_require__(111);
var getIterFn = __webpack_require__(133);

$export($export.S + $export.F * !__webpack_require__(94)(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $indexOf = __webpack_require__(88)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(34)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
    // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(1);

$export($export.S, 'Array', { isArray: __webpack_require__(92) });

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(1);
var toIObject = __webpack_require__(30);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(77) != Object || !__webpack_require__(34)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toIObject = __webpack_require__(30);
var toInteger = __webpack_require__(39);
var toLength = __webpack_require__(15);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(34)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (; index >= 0; index--) {
      if (index in O) if (O[index] === searchElement) return index || 0;
    }return -1;
  }
});

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $map = __webpack_require__(35)(1);

$export($export.P + $export.F * !__webpack_require__(34)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var createProperty = __webpack_require__(111);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(7)(function () {
  function F() {/* empty */}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of() /* ...args */{
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) {
      createProperty(result, index, arguments[index++]);
    }result.length = aLen;
    return result;
  }
});

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(188);

$export($export.P + $export.F * !__webpack_require__(34)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(188);

$export($export.P + $export.F * !__webpack_require__(34)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var html = __webpack_require__(115);
var cof = __webpack_require__(32);
var toAbsoluteIndex = __webpack_require__(64);
var toLength = __webpack_require__(15);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(7)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) {
      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
    }return cloned;
  }
});

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $some = __webpack_require__(35)(3);

$export($export.P + $export.F * !__webpack_require__(34)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var aFunction = __webpack_require__(21);
var toObject = __webpack_require__(17);
var fails = __webpack_require__(7);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(34)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(63)('Array');

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(1);

$export($export.S, 'Date', { now: function now() {
    return new Date().getTime();
  } });

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(1);
var toISOString = __webpack_require__(455);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(40);

$export($export.P + $export.F * __webpack_require__(7)(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
      return 1;
    } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(11)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(24)(proto, TO_PRIMITIVE, __webpack_require__(456));

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(25)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(1);

$export($export.P, 'Function', { bind: __webpack_require__(189) });

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(8);
var getPrototypeOf = __webpack_require__(29);
var HAS_INSTANCE = __webpack_require__(11)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(14).f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) {
      if (this.prototype === O) return true;
    }return false;
  } });

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(14).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(1);
var log1p = __webpack_require__(200);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710
// Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(1);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(1);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(1);
var sign = __webpack_require__(121);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(1);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(1);
var $expm1 = __webpack_require__(120);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { fround: __webpack_require__(199) });

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(1);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(1);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(7)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { log1p: __webpack_require__(200) });

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { sign: __webpack_require__(121) });

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(120);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(7)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(120);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(5);
var has = __webpack_require__(23);
var cof = __webpack_require__(32);
var inheritIfRequired = __webpack_require__(116);
var toPrimitive = __webpack_require__(40);
var fails = __webpack_require__(7);
var gOPN = __webpack_require__(59).f;
var gOPD = __webpack_require__(28).f;
var dP = __webpack_require__(14).f;
var $trim = __webpack_require__(70).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(58)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:case 98:
          radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
        case 79:case 111:
          radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
        default:
          return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      }return parseInt(digits, radix);
    }
  }return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
    // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(13) ? gOPN(Base) : (
  // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
  // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(25)(global, NUMBER, $Number);
}

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(1);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(1);
var _isFinite = __webpack_require__(5).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', { isInteger: __webpack_require__(196) });

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(1);
var isInteger = __webpack_require__(196);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(208);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(209);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toInteger = __webpack_require__(39);
var aNumberValue = __webpack_require__(185);
var repeat = __webpack_require__(128);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function divide(n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};
var numToString = function numToString() {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }return s;
};
var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function log(x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(7)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }return m;
  }
});

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $fails = __webpack_require__(7);
var aNumberValue = __webpack_require__(185);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(202) });

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(58) });

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(203) });

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(14).f });

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(48).onFreeze;

__webpack_require__(38)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(30);
var $getOwnPropertyDescriptor = __webpack_require__(28).f;

__webpack_require__(38)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(38)('getOwnPropertyNames', function () {
  return __webpack_require__(204).f;
});

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(17);
var $getPrototypeOf = __webpack_require__(29);

__webpack_require__(38)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(8);

__webpack_require__(38)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(8);

__webpack_require__(38)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(8);

__webpack_require__(38)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(1);
$export($export.S, 'Object', { is: __webpack_require__(459) });

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(17);
var $keys = __webpack_require__(60);

__webpack_require__(38)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(48).onFreeze;

__webpack_require__(38)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(8);
var meta = __webpack_require__(48).onFreeze;

__webpack_require__(38)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(1);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(124).set });

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(76);
var test = {};
test[__webpack_require__(11)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(25)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(208);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(209);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(57);
var global = __webpack_require__(5);
var ctx = __webpack_require__(33);
var classof = __webpack_require__(76);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(8);
var aFunction = __webpack_require__(21);
var anInstance = __webpack_require__(55);
var forOf = __webpack_require__(56);
var speciesConstructor = __webpack_require__(100);
var task = __webpack_require__(130).set;
var microtask = __webpack_require__(122)();
var newPromiseCapabilityModule = __webpack_require__(123);
var perform = __webpack_require__(210);
var promiseResolve = __webpack_require__(211);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function empty() {/* empty */};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(11)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) {/* empty */}
}();

// helpers
var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function isUnhandled(promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  }return true;
};
var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions
    this._a = undefined; // <- checked in isUnhandled reactions
    this._s = 0; // <- state
    this._d = false; // <- done
    this._v = undefined; // <- value
    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false; // <- notify
  };
  Internal.prototype = __webpack_require__(62)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(69)($Promise, PROMISE);
__webpack_require__(63)(PROMISE);
Wrapper = __webpack_require__(36)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(94)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(21);
var anObject = __webpack_require__(3);
var rApply = (__webpack_require__(5).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(7)(function () {
  rApply(function () {/* empty */});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(1);
var create = __webpack_require__(58);
var aFunction = __webpack_require__(21);
var anObject = __webpack_require__(3);
var isObject = __webpack_require__(8);
var fails = __webpack_require__(7);
var bind = __webpack_require__(189);
var rConstruct = (__webpack_require__(5).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() {/* empty */}
  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {/* empty */});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(14);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(3);
var toPrimitive = __webpack_require__(40);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(7)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(1);
var gOPD = __webpack_require__(28).f;
var anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(1);
var anObject = __webpack_require__(3);
var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target
  this._i = 0; // next index
  var keys = this._k = []; // keys
  var key;
  for (key in iterated) {
    keys.push(key);
  }
};
__webpack_require__(118)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(28);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(1);
var getProto = __webpack_require__(29);
var anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(28);
var getPrototypeOf = __webpack_require__(29);
var has = __webpack_require__(23);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(8);
var anObject = __webpack_require__(3);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(1);
var anObject = __webpack_require__(3);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(207) });

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(1);
var anObject = __webpack_require__(3);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(1);
var setProto = __webpack_require__(124);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(14);
var gOPD = __webpack_require__(28);
var getPrototypeOf = __webpack_require__(29);
var has = __webpack_require__(23);
var $export = __webpack_require__(1);
var createDesc = __webpack_require__(61);
var anObject = __webpack_require__(3);
var isObject = __webpack_require__(8);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5);
var inheritIfRequired = __webpack_require__(116);
var dP = __webpack_require__(14).f;
var gOPN = __webpack_require__(59).f;
var isRegExp = __webpack_require__(93);
var $flags = __webpack_require__(91);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(7)(function () {
  re2[__webpack_require__(11)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };
  var proxy = function proxy(key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
    proxy(keys[i++]);
  }proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(25)(global, 'RegExp', $RegExp);
}

__webpack_require__(63)('RegExp');

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(90)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(90)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';

    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(90)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';

    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(90)('split', 2, function (defined, SPLIT, $split) {
  'use strict';

  var isRegExp = __webpack_require__(93);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function $split(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
    // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function $split(separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(216);
var anObject = __webpack_require__(3);
var $flags = __webpack_require__(91);
var DESCRIPTORS = __webpack_require__(13);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(7)(function () {
  return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
  // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)

__webpack_require__(26)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()

__webpack_require__(26)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()

__webpack_require__(26)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()

__webpack_require__(26)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $at = __webpack_require__(126)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(1);
var toLength = __webpack_require__(15);
var context = __webpack_require__(127);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(114)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()

__webpack_require__(26)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(26)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(26)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(64);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }return res.join('');
  }
});

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(1);
var context = __webpack_require__(127);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(114)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()

__webpack_require__(26)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(126)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(119)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)

__webpack_require__(26)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var toIObject = __webpack_require__(30);
var toLength = __webpack_require__(15);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }return res.join('');
  }
});

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(128)
});

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()

__webpack_require__(26)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(1);
var toLength = __webpack_require__(15);
var context = __webpack_require__(127);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(114)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()

__webpack_require__(26)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()

__webpack_require__(26)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()

__webpack_require__(26)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()

__webpack_require__(70)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var global = __webpack_require__(5);
var has = __webpack_require__(23);
var DESCRIPTORS = __webpack_require__(13);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(25);
var META = __webpack_require__(48).KEY;
var $fails = __webpack_require__(7);
var shared = __webpack_require__(99);
var setToStringTag = __webpack_require__(69);
var uid = __webpack_require__(65);
var wks = __webpack_require__(11);
var wksExt = __webpack_require__(214);
var wksDefine = __webpack_require__(132);
var enumKeys = __webpack_require__(457);
var isArray = __webpack_require__(92);
var anObject = __webpack_require__(3);
var toIObject = __webpack_require__(30);
var toPrimitive = __webpack_require__(40);
var createDesc = __webpack_require__(61);
var _create = __webpack_require__(58);
var gOPNExt = __webpack_require__(204);
var $GOPD = __webpack_require__(28);
var $DP = __webpack_require__(14);
var $keys = __webpack_require__(60);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    }return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(59).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(78).f = $propertyIsEnumerable;
  __webpack_require__(96).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(57)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(24)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $typed = __webpack_require__(101);
var buffer = __webpack_require__(131);
var anObject = __webpack_require__(3);
var toAbsoluteIndex = __webpack_require__(64);
var toLength = __webpack_require__(15);
var isObject = __webpack_require__(8);
var ArrayBuffer = __webpack_require__(5).ArrayBuffer;
var speciesConstructor = __webpack_require__(100);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(7)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }return result;
  }
});

__webpack_require__(63)(ARRAY_BUFFER);

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
$export($export.G + $export.W + $export.F * !__webpack_require__(101).ABV, {
  DataView: __webpack_require__(131).DataView
});

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(192);
var validate = __webpack_require__(71);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(89)(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(1);
var flattenIntoArray = __webpack_require__(193);
var toObject = __webpack_require__(17);
var toLength = __webpack_require__(15);
var aFunction = __webpack_require__(21);
var arraySpeciesCreate = __webpack_require__(110);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(47)('flatMap');

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(1);
var flattenIntoArray = __webpack_require__(193);
var toObject = __webpack_require__(17);
var toLength = __webpack_require__(15);
var toInteger = __webpack_require__(39);
var arraySpeciesCreate = __webpack_require__(110);

$export($export.P, 'Array', {
  flatten: function flatten() /* depthArg = 1 */{
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(47)('flatten');

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(1);
var $includes = __webpack_require__(88)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(47)('includes');

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(1);
var microtask = __webpack_require__(122)();
var process = __webpack_require__(5).process;
var isNode = __webpack_require__(32)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(1);
var cof = __webpack_require__(32);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(1);

$export($export.G, { global: __webpack_require__(5) });

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(97)('Map');

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(98)('Map');

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(191)('Map') });

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);
var scale = __webpack_require__(201);
var fround = __webpack_require__(199);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(1);

$export($export.S, 'Math', { scale: __webpack_require__(201) });

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(1);

$export($export.S, 'Math', { signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  } });

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var aFunction = __webpack_require__(21);
var $defineProperty = __webpack_require__(14);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(13) && $export($export.P + __webpack_require__(95), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var aFunction = __webpack_require__(21);
var $defineProperty = __webpack_require__(14);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(13) && $export($export.P + __webpack_require__(95), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);
var $entries = __webpack_require__(206)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(1);
var ownKeys = __webpack_require__(207);
var toIObject = __webpack_require__(30);
var gOPD = __webpack_require__(28);
var createProperty = __webpack_require__(111);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(40);
var getPrototypeOf = __webpack_require__(29);
var getOwnPropertyDescriptor = __webpack_require__(28).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(13) && $export($export.P + __webpack_require__(95), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(17);
var toPrimitive = __webpack_require__(40);
var getPrototypeOf = __webpack_require__(29);
var getOwnPropertyDescriptor = __webpack_require__(28).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(13) && $export($export.P + __webpack_require__(95), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);
var $values = __webpack_require__(206)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable

var $export = __webpack_require__(1);
var global = __webpack_require__(5);
var core = __webpack_require__(36);
var microtask = __webpack_require__(122)();
var OBSERVABLE = __webpack_require__(11)('observable');
var aFunction = __webpack_require__(21);
var anObject = __webpack_require__(3);
var anInstance = __webpack_require__(55);
var redefineAll = __webpack_require__(62);
var hide = __webpack_require__(24);
var forOf = __webpack_require__(56);
var RETURN = forOf.RETURN;

var getMethod = function getMethod(fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function cleanupSubscription(subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function subscriptionClosed(subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function closeSubscription(subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function Subscription(observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function SubscriptionObserver(subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function next(value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) {
      items[i] = arguments[i++];
    }return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});

$export($export.G, { Observable: $Observable });

__webpack_require__(63)('Observable');

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(1);
var core = __webpack_require__(36);
var global = __webpack_require__(5);
var speciesConstructor = __webpack_require__(100);
var promiseResolve = __webpack_require__(211);

$export($export.P + $export.R, 'Promise', { 'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  } });

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(1);
var newPromiseCapability = __webpack_require__(123);
var perform = __webpack_require__(210);

$export($export.S, 'Promise', { 'try': function _try(callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  } });

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  } });

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(217);
var from = __webpack_require__(187);
var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(29);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  } });

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(29);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  } });

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(29);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  } });

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(41);
var anObject = __webpack_require__(3);
var aFunction = __webpack_require__(21);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  } });

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(97)('Set');

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(98)('Set');

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(191)('Set') });

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(1);
var $at = __webpack_require__(126)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(1);
var defined = __webpack_require__(37);
var toLength = __webpack_require__(15);
var isRegExp = __webpack_require__(93);
var getFlags = __webpack_require__(91);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(118)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(1);
var $pad = __webpack_require__(212);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(1);
var $pad = __webpack_require__(212);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(70)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(70)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(132)('asyncIterator');

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(132)('observable');

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(1);

$export($export.S, 'System', { global: __webpack_require__(5) });

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(97)('WeakMap');

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(98)('WeakMap');

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(97)('WeakSet');

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(98)('WeakSet');

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(134);
var getKeys = __webpack_require__(60);
var redefine = __webpack_require__(25);
var global = __webpack_require__(5);
var hide = __webpack_require__(24);
var Iterators = __webpack_require__(68);
var wks = __webpack_require__(11);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) {
      if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $task = __webpack_require__(130);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(5);
var $export = __webpack_require__(1);
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function wrap(set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(580);
__webpack_require__(519);
__webpack_require__(521);
__webpack_require__(520);
__webpack_require__(523);
__webpack_require__(525);
__webpack_require__(530);
__webpack_require__(524);
__webpack_require__(522);
__webpack_require__(532);
__webpack_require__(531);
__webpack_require__(527);
__webpack_require__(528);
__webpack_require__(526);
__webpack_require__(518);
__webpack_require__(529);
__webpack_require__(533);
__webpack_require__(534);
__webpack_require__(486);
__webpack_require__(488);
__webpack_require__(487);
__webpack_require__(536);
__webpack_require__(535);
__webpack_require__(506);
__webpack_require__(516);
__webpack_require__(517);
__webpack_require__(507);
__webpack_require__(508);
__webpack_require__(509);
__webpack_require__(510);
__webpack_require__(511);
__webpack_require__(512);
__webpack_require__(513);
__webpack_require__(514);
__webpack_require__(515);
__webpack_require__(489);
__webpack_require__(490);
__webpack_require__(491);
__webpack_require__(492);
__webpack_require__(493);
__webpack_require__(494);
__webpack_require__(495);
__webpack_require__(496);
__webpack_require__(497);
__webpack_require__(498);
__webpack_require__(499);
__webpack_require__(500);
__webpack_require__(501);
__webpack_require__(502);
__webpack_require__(503);
__webpack_require__(504);
__webpack_require__(505);
__webpack_require__(567);
__webpack_require__(572);
__webpack_require__(579);
__webpack_require__(570);
__webpack_require__(562);
__webpack_require__(563);
__webpack_require__(568);
__webpack_require__(573);
__webpack_require__(575);
__webpack_require__(558);
__webpack_require__(559);
__webpack_require__(560);
__webpack_require__(561);
__webpack_require__(564);
__webpack_require__(565);
__webpack_require__(566);
__webpack_require__(569);
__webpack_require__(571);
__webpack_require__(574);
__webpack_require__(576);
__webpack_require__(577);
__webpack_require__(578);
__webpack_require__(481);
__webpack_require__(483);
__webpack_require__(482);
__webpack_require__(485);
__webpack_require__(484);
__webpack_require__(470);
__webpack_require__(468);
__webpack_require__(474);
__webpack_require__(471);
__webpack_require__(477);
__webpack_require__(479);
__webpack_require__(467);
__webpack_require__(473);
__webpack_require__(464);
__webpack_require__(478);
__webpack_require__(462);
__webpack_require__(476);
__webpack_require__(475);
__webpack_require__(469);
__webpack_require__(472);
__webpack_require__(461);
__webpack_require__(463);
__webpack_require__(466);
__webpack_require__(465);
__webpack_require__(480);
__webpack_require__(134);
__webpack_require__(552);
__webpack_require__(557);
__webpack_require__(216);
__webpack_require__(553);
__webpack_require__(554);
__webpack_require__(555);
__webpack_require__(556);
__webpack_require__(537);
__webpack_require__(215);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(592);
__webpack_require__(581);
__webpack_require__(582);
__webpack_require__(587);
__webpack_require__(590);
__webpack_require__(591);
__webpack_require__(585);
__webpack_require__(588);
__webpack_require__(586);
__webpack_require__(589);
__webpack_require__(583);
__webpack_require__(584);
__webpack_require__(538);
__webpack_require__(539);
__webpack_require__(540);
__webpack_require__(541);
__webpack_require__(542);
__webpack_require__(545);
__webpack_require__(543);
__webpack_require__(544);
__webpack_require__(546);
__webpack_require__(547);
__webpack_require__(548);
__webpack_require__(549);
__webpack_require__(551);
__webpack_require__(550);
__webpack_require__(595);
__webpack_require__(593);
__webpack_require__(594);
__webpack_require__(636);
__webpack_require__(639);
__webpack_require__(638);
__webpack_require__(640);
__webpack_require__(641);
__webpack_require__(637);
__webpack_require__(642);
__webpack_require__(643);
__webpack_require__(617);
__webpack_require__(620);
__webpack_require__(616);
__webpack_require__(614);
__webpack_require__(615);
__webpack_require__(618);
__webpack_require__(619);
__webpack_require__(601);
__webpack_require__(635);
__webpack_require__(600);
__webpack_require__(634);
__webpack_require__(646);
__webpack_require__(648);
__webpack_require__(599);
__webpack_require__(633);
__webpack_require__(645);
__webpack_require__(647);
__webpack_require__(598);
__webpack_require__(644);
__webpack_require__(597);
__webpack_require__(602);
__webpack_require__(603);
__webpack_require__(604);
__webpack_require__(605);
__webpack_require__(606);
__webpack_require__(608);
__webpack_require__(607);
__webpack_require__(609);
__webpack_require__(610);
__webpack_require__(611);
__webpack_require__(613);
__webpack_require__(612);
__webpack_require__(622);
__webpack_require__(623);
__webpack_require__(624);
__webpack_require__(625);
__webpack_require__(627);
__webpack_require__(626);
__webpack_require__(629);
__webpack_require__(628);
__webpack_require__(630);
__webpack_require__(631);
__webpack_require__(632);
__webpack_require__(596);
__webpack_require__(621);
__webpack_require__(651);
__webpack_require__(650);
__webpack_require__(649);
module.exports = __webpack_require__(36);

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(655);
var isArguments = __webpack_require__(654);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

    // 7.3. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
    return opts.strict ? actual === expected : actual == expected;

    // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer(x) {
  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {
    //happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
}

/***/ }),
/* 654 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var supportsArgumentsClass = function () {
  return Object.prototype.toString.call(arguments);
}() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object) {
  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
};

/***/ }),
/* 655 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;

exports.shim = shim;
function shim(obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
}

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(135);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (false) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(662);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(661);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 React v16.0.0
 react-dom.production.min.js

 Copyright (c) 2013-present, Facebook, Inc.

 This source code is licensed under the MIT license found in the
 LICENSE file in the root directory of this source tree.
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(6);__webpack_require__(220);var l = __webpack_require__(657),
    n = __webpack_require__(20),
    ba = __webpack_require__(656),
    ca = __webpack_require__(135),
    da = __webpack_require__(219),
    ea = __webpack_require__(663),
    fa = __webpack_require__(658),
    ha = __webpack_require__(659),
    ia = __webpack_require__(660);
function w(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : w("227");
function ja(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}
var ka = { Namespaces: { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" }, getIntrinsicNamespace: ja, getChildNamespace: function getChildNamespace(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? ja(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  } },
    la = null,
    oa = {};
function pa() {
  if (la) for (var a in oa) {
    var b = oa[a],
        c = la.indexOf(a);-1 < c ? void 0 : w("96", a);if (!qa.plugins[c]) {
      b.extractEvents ? void 0 : w("97", a);qa.plugins[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            h = d;qa.eventNameDispatchConfigs.hasOwnProperty(h) ? w("99", h) : void 0;qa.eventNameDispatchConfigs[h] = f;var k = f.phasedRegistrationNames;if (k) {
          for (e in k) {
            k.hasOwnProperty(e) && ra(k[e], g, h);
          }e = !0;
        } else f.registrationName ? (ra(f.registrationName, g, h), e = !0) : e = !1;e ? void 0 : w("98", d, a);
      }
    }
  }
}
function ra(a, b, c) {
  qa.registrationNameModules[a] ? w("100", a) : void 0;qa.registrationNameModules[a] = b;qa.registrationNameDependencies[a] = b.eventTypes[c].dependencies;
}
var qa = { plugins: [], eventNameDispatchConfigs: {}, registrationNameModules: {}, registrationNameDependencies: {}, possibleRegistrationNames: null, injectEventPluginOrder: function injectEventPluginOrder(a) {
    la ? w("101") : void 0;la = Array.prototype.slice.call(a);pa();
  }, injectEventPluginsByName: function injectEventPluginsByName(a) {
    var b = !1,
        c;for (c in a) {
      if (a.hasOwnProperty(c)) {
        var d = a[c];oa.hasOwnProperty(c) && oa[c] === d || (oa[c] ? w("102", c) : void 0, oa[c] = d, b = !0);
      }
    }b && pa();
  } },
    sa = qa,
    ta = { children: !0, dangerouslySetInnerHTML: !0, autoFocus: !0, defaultValue: !0, defaultChecked: !0,
  innerHTML: !0, suppressContentEditableWarning: !0, style: !0 };function ua(a, b) {
  return (a & b) === b;
}
var wa = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = wa,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      xa.properties.hasOwnProperty(f) ? w("48", f) : void 0;var g = f.toLowerCase(),
          h = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: ua(h, b.MUST_USE_PROPERTY),
        hasBooleanValue: ua(h, b.HAS_BOOLEAN_VALUE), hasNumericValue: ua(h, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: ua(h, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: ua(h, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: ua(h, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : w("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);xa.properties[f] = g;
    }
  } },
    xa = { ID_ATTRIBUTE_NAME: "data-reactid", ROOT_ATTRIBUTE_NAME: "data-reactroot", ATTRIBUTE_NAME_START_CHAR: ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR: ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
  properties: {}, shouldSetAttribute: function shouldSetAttribute(a, b) {
    if (xa.isReservedProp(a) || !("o" !== a[0] && "O" !== a[0] || "n" !== a[1] && "N" !== a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
        return xa.shouldAttributeAcceptBooleanValue(a);case "undefined":case "number":case "string":case "object":
        return !0;default:
        return !1;}
  }, getPropertyInfo: function getPropertyInfo(a) {
    return xa.properties.hasOwnProperty(a) ? xa.properties[a] : null;
  }, shouldAttributeAcceptBooleanValue: function shouldAttributeAcceptBooleanValue(a) {
    if (xa.isReservedProp(a)) return !0;var b = xa.getPropertyInfo(a);
    if (b) return b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue;a = a.toLowerCase().slice(0, 5);return "data-" === a || "aria-" === a;
  }, isReservedProp: function isReservedProp(a) {
    return ta.hasOwnProperty(a);
  }, injection: wa },
    A = xa,
    E = { IndeterminateComponent: 0, FunctionalComponent: 1, ClassComponent: 2, HostRoot: 3, HostPortal: 4, HostComponent: 5, HostText: 6, CoroutineComponent: 7, CoroutineHandlerPhase: 8, YieldComponent: 9, Fragment: 10 },
    F = { ELEMENT_NODE: 1, TEXT_NODE: 3, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_FRAGMENT_NODE: 11 },
    ya = E.HostComponent,
    za = E.HostText,
    Aa = F.ELEMENT_NODE,
    Ba = F.COMMENT_NODE,
    Ea = A.ID_ATTRIBUTE_NAME,
    Fa = { hasCachedChildNodes: 1 },
    Ga = Math.random().toString(36).slice(2),
    Ha = "__reactInternalInstance$" + Ga,
    Ia = "__reactEventHandlers$" + Ga;function La(a) {
  for (var b; b = a._renderedComponent;) {
    a = b;
  }return a;
}function Ma(a, b) {
  a = La(a);a._hostNode = b;b[Ha] = a;
}
function Na(a, b) {
  if (!(a._flags & Fa.hasCachedChildNodes)) {
    var c = a._renderedChildren;b = b.firstChild;var d;a: for (d in c) {
      if (c.hasOwnProperty(d)) {
        var e = c[d],
            f = La(e)._domID;if (0 !== f) {
          for (; null !== b; b = b.nextSibling) {
            var g = b,
                h = f;if (g.nodeType === Aa && g.getAttribute(Ea) === "" + h || g.nodeType === Ba && g.nodeValue === " react-text: " + h + " " || g.nodeType === Ba && g.nodeValue === " react-empty: " + h + " ") {
              Ma(e, b);continue a;
            }
          }w("32", f);
        }
      }
    }a._flags |= Fa.hasCachedChildNodes;
  }
}
function Oa(a) {
  if (a[Ha]) return a[Ha];for (var b = []; !a[Ha];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = a[Ha];if (c.tag === ya || c.tag === za) return c;for (; a && (c = a[Ha]); a = b.pop()) {
    var d = c;b.length && Na(c, a);
  }return d;
}
var G = { getClosestInstanceFromNode: Oa, getInstanceFromNode: function getInstanceFromNode(a) {
    var b = a[Ha];if (b) return b.tag === ya || b.tag === za ? b : b._hostNode === a ? b : null;b = Oa(a);return null != b && b._hostNode === a ? b : null;
  }, getNodeFromInstance: function getNodeFromInstance(a) {
    if (a.tag === ya || a.tag === za) return a.stateNode;void 0 === a._hostNode ? w("33") : void 0;if (a._hostNode) return a._hostNode;for (var b = []; !a._hostNode;) {
      b.push(a), a._hostParent ? void 0 : w("34"), a = a._hostParent;
    }for (; b.length; a = b.pop()) {
      Na(a, a._hostNode);
    }return a._hostNode;
  }, precacheChildNodes: Na,
  precacheNode: Ma, uncacheNode: function uncacheNode(a) {
    var b = a._hostNode;b && (delete b[Ha], a._hostNode = null);
  }, precacheFiberNode: function precacheFiberNode(a, b) {
    b[Ha] = a;
  }, getFiberCurrentPropsFromNode: function getFiberCurrentPropsFromNode(a) {
    return a[Ia] || null;
  }, updateFiberProps: function updateFiberProps(a, b) {
    a[Ia] = b;
  } },
    Pa = { remove: function remove(a) {
    a._reactInternalFiber = void 0;
  }, get: function get(a) {
    return a._reactInternalFiber;
  }, has: function has(a) {
    return void 0 !== a._reactInternalFiber;
  }, set: function set(a, b) {
    a._reactInternalFiber = b;
  } },
    Qa = { ReactCurrentOwner: aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner };
function Ra(a) {
  if ("function" === typeof a.getName) return a.getName();if ("number" === typeof a.tag) {
    a = a.type;if ("string" === typeof a) return a;if ("function" === typeof a) return a.displayName || a.name;
  }return null;
}var J = { NoEffect: 0, PerformedWork: 1, Placement: 2, Update: 4, PlacementAndUpdate: 6, Deletion: 8, ContentReset: 16, Callback: 32, Err: 64, Ref: 128 },
    Sa = E.HostComponent,
    Ta = E.HostRoot,
    Ua = E.HostPortal,
    Va = E.HostText,
    Wa = J.NoEffect,
    Xa = J.Placement;
function Za(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if ((b.effectTag & Xa) !== Wa) return 1;for (; b["return"];) {
      if (b = b["return"], (b.effectTag & Xa) !== Wa) return 1;
    }
  }return b.tag === Ta ? 2 : 3;
}function $a(a) {
  2 !== Za(a) ? w("188") : void 0;
}
function ab(a) {
  var b = a.alternate;if (!b) return b = Za(a), 3 === b ? w("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return $a(e), a;if (g === d) return $a(e), b;g = g.sibling;
      }w("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }g ? void 0 : w("189");
      }
    }c.alternate !== d ? w("190") : void 0;
  }c.tag !== Ta ? w("188") : void 0;return c.stateNode.current === c ? a : b;
}
var bb = { isFiberMounted: function isFiberMounted(a) {
    return 2 === Za(a);
  }, isMounted: function isMounted(a) {
    return (a = Pa.get(a)) ? 2 === Za(a) : !1;
  }, findCurrentFiberUsingSlowPath: ab, findCurrentHostFiber: function findCurrentHostFiber(a) {
    a = ab(a);if (!a) return null;for (var b = a;;) {
      if (b.tag === Sa || b.tag === Va) return b;if (b.child) b.child["return"] = b, b = b.child;else {
        if (b === a) break;for (; !b.sibling;) {
          if (!b["return"] || b["return"] === a) return null;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      }
    }return null;
  }, findCurrentHostFiberWithNoPortals: function findCurrentHostFiberWithNoPortals(a) {
    a = ab(a);
    if (!a) return null;for (var b = a;;) {
      if (b.tag === Sa || b.tag === Va) return b;if (b.child && b.tag !== Ua) b.child["return"] = b, b = b.child;else {
        if (b === a) break;for (; !b.sibling;) {
          if (!b["return"] || b["return"] === a) return null;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      }
    }return null;
  } },
    K = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? w("197") : void 0;cb = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, h, k) {
    cb.apply(K, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, h, k) {
    K.invokeGuardedCallback.apply(this, arguments);if (K.hasCaughtError()) {
      var p = K.clearCaughtError();K._hasRethrowError || (K._hasRethrowError = !0, K._rethrowError = p);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return db.apply(K, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return K._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (K._hasCaughtError) {
      var a = K._caughtError;K._caughtError = null;K._hasCaughtError = !1;return a;
    }w("198");
  } };
function cb(a, b, c, d, e, f, g, h, k) {
  K._hasCaughtError = !1;K._caughtError = null;var p = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, p);
  } catch (x) {
    K._caughtError = x, K._hasCaughtError = !0;
  }
}function db() {
  if (K._hasRethrowError) {
    var a = K._rethrowError;K._rethrowError = null;K._hasRethrowError = !1;throw a;
  }
}var eb = K,
    fb;function gb(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = hb.getNodeFromInstance(d);eb.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
var hb = { isEndish: function isEndish(a) {
    return "topMouseUp" === a || "topTouchEnd" === a || "topTouchCancel" === a;
  }, isMoveish: function isMoveish(a) {
    return "topMouseMove" === a || "topTouchMove" === a;
  }, isStartish: function isStartish(a) {
    return "topMouseDown" === a || "topTouchStart" === a;
  }, executeDirectDispatch: function executeDirectDispatch(a) {
    var b = a._dispatchListeners,
        c = a._dispatchInstances;Array.isArray(b) ? w("103") : void 0;a.currentTarget = b ? hb.getNodeFromInstance(c) : null;b = b ? b(a) : null;a.currentTarget = null;a._dispatchListeners = null;a._dispatchInstances = null;return b;
  }, executeDispatchesInOrder: function executeDispatchesInOrder(a, b) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      gb(a, b, c[e], d[e]);
    } else c && gb(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;
  }, executeDispatchesInOrderStopAtTrue: function executeDispatchesInOrderStopAtTrue(a) {
    a: {
      var b = a._dispatchListeners;var c = a._dispatchInstances;if (Array.isArray(b)) for (var d = 0; d < b.length && !a.isPropagationStopped(); d++) {
        if (b[d](a, c[d])) {
          b = c[d];break a;
        }
      } else if (b && b(a, c)) {
        b = c;break a;
      }b = null;
    }a._dispatchInstances = null;a._dispatchListeners = null;return b;
  }, hasDispatches: function hasDispatches(a) {
    return !!a._dispatchListeners;
  }, getFiberCurrentPropsFromNode: function getFiberCurrentPropsFromNode(a) {
    return fb.getFiberCurrentPropsFromNode(a);
  }, getInstanceFromNode: function getInstanceFromNode(a) {
    return fb.getInstanceFromNode(a);
  }, getNodeFromInstance: function getNodeFromInstance(a) {
    return fb.getNodeFromInstance(a);
  }, injection: { injectComponentTree: function injectComponentTree(a) {
      fb = a;
    } } },
    ib = hb,
    jb = null,
    kb = null,
    lb = null;
function mb(a) {
  if (a = ib.getInstanceFromNode(a)) if ("number" === typeof a.tag) {
    jb && "function" === typeof jb.restoreControlledState ? void 0 : w("194");var b = ib.getFiberCurrentPropsFromNode(a.stateNode);jb.restoreControlledState(a.stateNode, a.type, b);
  } else "function" !== typeof a.restoreControlledState ? w("195") : void 0, a.restoreControlledState();
}
var nb = { injection: { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
      jb = a;
    } }, enqueueStateRestore: function enqueueStateRestore(a) {
    kb ? lb ? lb.push(a) : lb = [a] : kb = a;
  }, restoreStateIfNeeded: function restoreStateIfNeeded() {
    if (kb) {
      var a = kb,
          b = lb;lb = kb = null;mb(a);if (b) for (a = 0; a < b.length; a++) {
        mb(b[a]);
      }
    }
  } };function ob(a, b, c, d, e, f) {
  return a(b, c, d, e, f);
}function pb(a, b) {
  return a(b);
}function qb(a, b) {
  return pb(a, b);
}
var rb = !1,
    sb = { batchedUpdates: function batchedUpdates(a, b) {
    if (rb) return ob(qb, a, b);rb = !0;try {
      return ob(qb, a, b);
    } finally {
      rb = !1, nb.restoreStateIfNeeded();
    }
  }, injection: { injectStackBatchedUpdates: function injectStackBatchedUpdates(a) {
      ob = a;
    }, injectFiberBatchedUpdates: function injectFiberBatchedUpdates(a) {
      pb = a;
    } } },
    tb = F.TEXT_NODE;function ub(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return a.nodeType === tb ? a.parentNode : a;
}var vb = E.HostRoot,
    wb = [];
function xb(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c = b;if ("number" === typeof c.tag) {
      for (; c["return"];) {
        c = c["return"];
      }c = c.tag !== vb ? null : c.stateNode.containerInfo;
    } else {
      for (; c._hostParent;) {
        c = c._hostParent;
      }c = G.getNodeFromInstance(c).parentNode;
    }if (!c) break;a.ancestors.push(b);b = G.getClosestInstanceFromNode(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], yb._handleTopLevel(a.topLevelType, b, a.nativeEvent, ub(a.nativeEvent));
  }
}
var yb = { _enabled: !0, _handleTopLevel: null, setHandleTopLevel: function setHandleTopLevel(a) {
    yb._handleTopLevel = a;
  }, setEnabled: function setEnabled(a) {
    yb._enabled = !!a;
  }, isEnabled: function isEnabled() {
    return yb._enabled;
  }, trapBubbledEvent: function trapBubbledEvent(a, b, c) {
    return c ? ba.listen(c, b, yb.dispatchEvent.bind(null, a)) : null;
  }, trapCapturedEvent: function trapCapturedEvent(a, b, c) {
    return c ? ba.capture(c, b, yb.dispatchEvent.bind(null, a)) : null;
  }, dispatchEvent: function dispatchEvent(a, b) {
    if (yb._enabled) {
      var c = ub(b);c = G.getClosestInstanceFromNode(c);null === c || "number" !== typeof c.tag || bb.isFiberMounted(c) || (c = null);if (wb.length) {
        var d = wb.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
      } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
        sb.batchedUpdates(xb, a);
      } finally {
        a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > wb.length && wb.push(a);
      }
    }
  } },
    L = yb;function Cb(a, b) {
  null == b ? w("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}
function Db(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var Eb = null;function Fb(a, b) {
  a && (ib.executeDispatchesInOrder(a, b), a.isPersistent() || a.constructor.release(a));
}function Gb(a) {
  return Fb(a, !0);
}function Hb(a) {
  return Fb(a, !1);
}
function Ib(a, b, c) {
  switch (a) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      return !(!c.disabled || "button" !== b && "input" !== b && "select" !== b && "textarea" !== b);default:
      return !1;}
}
var Jb = { injection: { injectEventPluginOrder: sa.injectEventPluginOrder, injectEventPluginsByName: sa.injectEventPluginsByName }, getListener: function getListener(a, b) {
    if ("number" === typeof a.tag) {
      var c = a.stateNode;if (!c) return null;var d = ib.getFiberCurrentPropsFromNode(c);if (!d) return null;c = d[b];if (Ib(b, a.type, d)) return null;
    } else {
      d = a._currentElement;if ("string" === typeof d || "number" === typeof d || !a._rootNodeID) return null;a = d.props;c = a[b];if (Ib(b, d.type, a)) return null;
    }c && "function" !== typeof c ? w("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
    return c;
  }, extractEvents: function extractEvents(a, b, c, d) {
    for (var e, f = sa.plugins, g = 0; g < f.length; g++) {
      var h = f[g];h && (h = h.extractEvents(a, b, c, d)) && (e = Cb(e, h));
    }return e;
  }, enqueueEvents: function enqueueEvents(a) {
    a && (Eb = Cb(Eb, a));
  }, processEventQueue: function processEventQueue(a) {
    var b = Eb;Eb = null;a ? Db(b, Gb) : Db(b, Hb);Eb ? w("95") : void 0;eb.rethrowCaughtError();
  } },
    Kb;l.canUseDOM && (Kb = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function Lb(a, b) {
  if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && Kb && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function Mb(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var Nb = { animationend: Mb("Animation", "AnimationEnd"), animationiteration: Mb("Animation", "AnimationIteration"), animationstart: Mb("Animation", "AnimationStart"), transitionend: Mb("Transition", "TransitionEnd") },
    Ob = {},
    Pb = {};l.canUseDOM && (Pb = document.createElement("div").style, "AnimationEvent" in window || (delete Nb.animationend.animation, delete Nb.animationiteration.animation, delete Nb.animationstart.animation), "TransitionEvent" in window || delete Nb.transitionend.transition);
function Qb(a) {
  if (Ob[a]) return Ob[a];if (!Nb[a]) return a;var b = Nb[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in Pb) return Ob[a] = b[c];
  }return "";
}
var Rb = { topAbort: "abort", topAnimationEnd: Qb("animationend") || "animationend", topAnimationIteration: Qb("animationiteration") || "animationiteration", topAnimationStart: Qb("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: Qb("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    Sb = {},
    Tb = 0,
    Ub = "_reactListenersID" + ("" + Math.random()).slice(2);function Vb(a) {
  Object.prototype.hasOwnProperty.call(a, Ub) || (a[Ub] = Tb++, Sb[a[Ub]] = {});return Sb[a[Ub]];
}
var M = n({}, { handleTopLevel: function handleTopLevel(a, b, c, d) {
    a = Jb.extractEvents(a, b, c, d);Jb.enqueueEvents(a);Jb.processEventQueue(!1);
  } }, { setEnabled: function setEnabled(a) {
    L && L.setEnabled(a);
  }, isEnabled: function isEnabled() {
    return !(!L || !L.isEnabled());
  }, listenTo: function listenTo(a, b) {
    var c = Vb(b);a = sa.registrationNameDependencies[a];for (var d = 0; d < a.length; d++) {
      var e = a[d];c.hasOwnProperty(e) && c[e] || ("topWheel" === e ? Lb("wheel") ? L.trapBubbledEvent("topWheel", "wheel", b) : Lb("mousewheel") ? L.trapBubbledEvent("topWheel", "mousewheel", b) : L.trapBubbledEvent("topWheel", "DOMMouseScroll", b) : "topScroll" === e ? L.trapCapturedEvent("topScroll", "scroll", b) : "topFocus" === e || "topBlur" === e ? (L.trapCapturedEvent("topFocus", "focus", b), L.trapCapturedEvent("topBlur", "blur", b), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (Lb("cancel", !0) && L.trapCapturedEvent("topCancel", "cancel", b), c.topCancel = !0) : "topClose" === e ? (Lb("close", !0) && L.trapCapturedEvent("topClose", "close", b), c.topClose = !0) : Rb.hasOwnProperty(e) && L.trapBubbledEvent(e, Rb[e], b), c[e] = !0);
    }
  }, isListeningToAllDependencies: function isListeningToAllDependencies(a, b) {
    b = Vb(b);a = sa.registrationNameDependencies[a];for (var c = 0; c < a.length; c++) {
      var d = a[c];if (!b.hasOwnProperty(d) || !b[d]) return !1;
    }return !0;
  }, trapBubbledEvent: function trapBubbledEvent(a, b, c) {
    return L.trapBubbledEvent(a, b, c);
  }, trapCapturedEvent: function trapCapturedEvent(a, b, c) {
    return L.trapCapturedEvent(a, b, c);
  } }),
    Wb = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0,
  flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    Xb = ["Webkit", "ms", "Moz", "O"];
Object.keys(Wb).forEach(function (a) {
  Xb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);Wb[b] = Wb[a];
  });
});
var Yb = { isUnitlessNumber: Wb, shorthandPropertyExpansions: { background: { backgroundAttachment: !0, backgroundColor: !0, backgroundImage: !0, backgroundPositionX: !0, backgroundPositionY: !0, backgroundRepeat: !0 }, backgroundPosition: { backgroundPositionX: !0, backgroundPositionY: !0 }, border: { borderWidth: !0, borderStyle: !0, borderColor: !0 }, borderBottom: { borderBottomWidth: !0, borderBottomStyle: !0, borderBottomColor: !0 }, borderLeft: { borderLeftWidth: !0, borderLeftStyle: !0, borderLeftColor: !0 }, borderRight: { borderRightWidth: !0, borderRightStyle: !0,
      borderRightColor: !0 }, borderTop: { borderTopWidth: !0, borderTopStyle: !0, borderTopColor: !0 }, font: { fontStyle: !0, fontVariant: !0, fontWeight: !0, fontSize: !0, lineHeight: !0, fontFamily: !0 }, outline: { outlineWidth: !0, outlineStyle: !0, outlineColor: !0 } } },
    Zb = Yb.isUnitlessNumber,
    $b = !1;if (l.canUseDOM) {
  var ac = document.createElement("div").style;try {
    ac.font = "";
  } catch (a) {
    $b = !0;
  }
}
var bc = { createDangerousStringForStyles: function createDangerousStringForStyles() {}, setValueForStyles: function setValueForStyles(a, b) {
    a = a.style;for (var c in b) {
      if (b.hasOwnProperty(c)) {
        var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || Zb.hasOwnProperty(e) && Zb[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");if (d) a.setProperty(c, e);else if (e) a[c] = e;else if (d = $b && Yb.shorthandPropertyExpansions[c]) for (var g in d) {
          a[g] = "";
        } else a[c] = "";
      }
    }
  } },
    cc = new RegExp("^[" + A.ATTRIBUTE_NAME_START_CHAR + "][" + A.ATTRIBUTE_NAME_CHAR + "]*$"),
    dc = {},
    ec = {};function fc(a) {
  if (ec.hasOwnProperty(a)) return !0;if (dc.hasOwnProperty(a)) return !1;if (cc.test(a)) return ec[a] = !0;dc[a] = !0;return !1;
}
var gc = { setAttributeForID: function setAttributeForID(a, b) {
    a.setAttribute(A.ID_ATTRIBUTE_NAME, b);
  }, setAttributeForRoot: function setAttributeForRoot(a) {
    a.setAttribute(A.ROOT_ATTRIBUTE_NAME, "");
  }, getValueForProperty: function getValueForProperty() {}, getValueForAttribute: function getValueForAttribute() {}, setValueForProperty: function setValueForProperty(a, b, c) {
    var d = A.getPropertyInfo(b);if (d && A.shouldSetAttribute(b, c)) {
      var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? gc.deleteValueForProperty(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
    } else gc.setValueForAttribute(a, b, A.shouldSetAttribute(b, c) ? c : null);
  }, setValueForAttribute: function setValueForAttribute(a, b, c) {
    fc(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
  }, deleteValueForAttribute: function deleteValueForAttribute(a, b) {
    a.removeAttribute(b);
  }, deleteValueForProperty: function deleteValueForProperty(a, b) {
    var c = A.getPropertyInfo(b);
    c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
  } },
    hc = gc,
    ic = Qa.ReactDebugCurrentFrame;function jc() {
  return null;
}
var kc = { current: null, phase: null, resetCurrentFiber: function resetCurrentFiber() {
    ic.getCurrentStack = null;kc.current = null;kc.phase = null;
  }, setCurrentFiber: function setCurrentFiber(a, b) {
    ic.getCurrentStack = jc;kc.current = a;kc.phase = b;
  }, getCurrentFiberOwnerName: function getCurrentFiberOwnerName() {
    return null;
  }, getCurrentFiberStackAddendum: jc },
    lc = kc,
    mc = { getHostProps: function getHostProps(a, b) {
    var c = b.value,
        d = b.checked;return n({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
  }, initWrapperState: function initWrapperState(a, b) {
    var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }, updateWrapper: function updateWrapper(a, b) {
    var c = b.checked;null != c && hc.setValueForProperty(a, "checked", c || !1);c = b.value;if (null != c) {
      if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
        if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
    } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }, postMountWrapper: function postMountWrapper(a, b) {
    switch (b.type) {case "submit":case "reset":
        break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
        a.value = "";a.value = a.defaultValue;break;default:
        a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
  }, restoreControlledState: function restoreControlledState(a, b) {
    mc.updateWrapper(a, b);var c = b.name;if ("radio" === b.type && null != c) {
      for (b = a; b.parentNode;) {
        b = b.parentNode;
      }c = b.querySelectorAll("input[name\x3d" + JSON.stringify("" + c) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
        var d = c[b];if (d !== a && d.form === a.form) {
          var e = G.getFiberCurrentPropsFromNode(d);e ? void 0 : w("90");mc.updateWrapper(d, e);
        }
      }
    }
  } },
    qc = mc;
function rc(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}var sc = { validateProps: function validateProps() {}, postMountWrapper: function postMountWrapper(a, b) {
    null != b.value && a.setAttribute("value", b.value);
  }, getHostProps: function getHostProps(a, b) {
    a = n({ children: void 0 }, b);if (b = rc(b.children)) a.children = b;return a;
  } };
function tc(a, b, c) {
  a = a.options;if (b) {
    b = {};for (var d = 0; d < c.length; d++) {
      b["$" + c[d]] = !0;
    }for (c = 0; c < a.length; c++) {
      d = b.hasOwnProperty("$" + a[c].value), a[c].selected !== d && (a[c].selected = d);
    }
  } else {
    c = "" + c;b = null;for (d = 0; d < a.length; d++) {
      if (a[d].value === c) {
        a[d].selected = !0;return;
      }null !== b || a[d].disabled || (b = a[d]);
    }null !== b && (b.selected = !0);
  }
}
var uc = { getHostProps: function getHostProps(a, b) {
    return n({}, b, { value: void 0 });
  }, initWrapperState: function initWrapperState(a, b) {
    var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
  }, postMountWrapper: function postMountWrapper(a, b) {
    a.multiple = !!b.multiple;var c = b.value;null != c ? tc(a, !!b.multiple, c) : null != b.defaultValue && tc(a, !!b.multiple, b.defaultValue);
  }, postUpdateWrapper: function postUpdateWrapper(a, b) {
    a._wrapperState.initialValue = void 0;var c = a._wrapperState.wasMultiple;a._wrapperState.wasMultiple = !!b.multiple;var d = b.value;
    null != d ? tc(a, !!b.multiple, d) : c !== !!b.multiple && (null != b.defaultValue ? tc(a, !!b.multiple, b.defaultValue) : tc(a, !!b.multiple, b.multiple ? [] : ""));
  }, restoreControlledState: function restoreControlledState(a, b) {
    var c = b.value;null != c && tc(a, !!b.multiple, c);
  } },
    vc = { getHostProps: function getHostProps(a, b) {
    null != b.dangerouslySetInnerHTML ? w("91") : void 0;return n({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }, initWrapperState: function initWrapperState(a, b) {
    var c = b.value,
        d = c;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? w("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : w("93"), b = b[0]), c = "" + b), null == c && (c = ""), d = c);a._wrapperState = { initialValue: "" + d };
  }, updateWrapper: function updateWrapper(a, b) {
    var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
  }, postMountWrapper: function postMountWrapper(a) {
    var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
  }, restoreControlledState: function restoreControlledState(a, b) {
    vc.updateWrapper(a, b);
  } },
    wc = vc,
    xc = n({ menuitem: !0 }, { area: !0,
  base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });function yc(a, b) {
  b && (xc[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? w("137", a, "") : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? w("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : w("61")), null != b.style && "object" !== _typeof(b.style) ? w("62", "") : void 0);
}
function zc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ac(a) {
  var b = zc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
var Bc = { _getTrackerFromNode: function _getTrackerFromNode(a) {
    return a._valueTracker;
  }, track: function track(a) {
    a._valueTracker || (a._valueTracker = Ac(a));
  }, updateValueIfChanged: function updateValueIfChanged(a) {
    if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
  }, stopTracking: function stopTracking(a) {
    (a = a._valueTracker) && a.stopTracking();
  } };
function Cc(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}
var Dc = ka.Namespaces,
    Ec,
    Fc = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Dc.svg || "innerHTML" in a) a.innerHTML = b;else for (Ec = Ec || document.createElement("div"), Ec.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e", b = Ec.firstChild; b.firstChild;) {
    a.appendChild(b.firstChild);
  }
}),
    Gc = /["'&<>]/,
    Hc = F.TEXT_NODE;
function Ic(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && c.nodeType === Hc) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
l.canUseDOM && ("textContent" in document.documentElement || (Ic = function Ic(a, b) {
  if (a.nodeType === Hc) a.nodeValue = b;else {
    if ("boolean" === typeof b || "number" === typeof b) b = "" + b;else {
      b = "" + b;var c = Gc.exec(b);if (c) {
        var d = "",
            e,
            f = 0;for (e = c.index; e < b.length; e++) {
          switch (b.charCodeAt(e)) {case 34:
              c = "\x26quot;";break;case 38:
              c = "\x26amp;";break;case 39:
              c = "\x26#x27;";break;case 60:
              c = "\x26lt;";break;case 62:
              c = "\x26gt;";break;default:
              continue;}f !== e && (d += b.substring(f, e));f = e + 1;d += c;
        }b = f !== e ? d + b.substring(f, e) : d;
      }
    }Fc(a, b);
  }
}));
var Jc = Ic,
    Kc = lc.getCurrentFiberOwnerName,
    Lc = F.DOCUMENT_NODE,
    Mc = F.DOCUMENT_FRAGMENT_NODE,
    Nc = M.listenTo,
    Oc = sa.registrationNameModules,
    Pc = ka.Namespaces.html,
    Qc = ka.getIntrinsicNamespace;function Rc(a, b) {
  Nc(b, a.nodeType === Lc || a.nodeType === Mc ? a : a.ownerDocument);
}
var Sc = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" },
    N = { createElement: function createElement(a, b, c, d) {
    c = c.nodeType === Lc ? c : c.ownerDocument;d === Pc && (d = Qc(a));d === Pc ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
  }, createTextNode: function createTextNode(a, b) {
    return (b.nodeType === Lc ? b : b.ownerDocument).createTextNode(a);
  }, setInitialProperties: function setInitialProperties(a, b, c, d) {
    var e = Cc(b, c);switch (b) {case "iframe":case "object":
        M.trapBubbledEvent("topLoad", "load", a);var f = c;break;case "video":case "audio":
        for (f in Sc) {
          Sc.hasOwnProperty(f) && M.trapBubbledEvent(f, Sc[f], a);
        }f = c;break;case "source":
        M.trapBubbledEvent("topError", "error", a);f = c;break;case "img":case "image":
        M.trapBubbledEvent("topError", "error", a);M.trapBubbledEvent("topLoad", "load", a);f = c;break;case "form":
        M.trapBubbledEvent("topReset", "reset", a);M.trapBubbledEvent("topSubmit", "submit", a);f = c;break;case "details":
        M.trapBubbledEvent("topToggle", "toggle", a);f = c;break;case "input":
        qc.initWrapperState(a, c);f = qc.getHostProps(a, c);M.trapBubbledEvent("topInvalid", "invalid", a);Rc(d, "onChange");break;case "option":
        sc.validateProps(a, c);f = sc.getHostProps(a, c);break;case "select":
        uc.initWrapperState(a, c);f = uc.getHostProps(a, c);M.trapBubbledEvent("topInvalid", "invalid", a);Rc(d, "onChange");break;case "textarea":
        wc.initWrapperState(a, c);f = wc.getHostProps(a, c);M.trapBubbledEvent("topInvalid", "invalid", a);Rc(d, "onChange");break;default:
        f = c;}yc(b, f, Kc);var g = f,
        h;for (h in g) {
      if (g.hasOwnProperty(h)) {
        var k = g[h];"style" === h ? bc.setValueForStyles(a, k) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, null != k && Fc(a, k)) : "children" === h ? "string" === typeof k ? Jc(a, k) : "number" === typeof k && Jc(a, "" + k) : "suppressContentEditableWarning" !== h && (Oc.hasOwnProperty(h) ? null != k && Rc(d, h) : e ? hc.setValueForAttribute(a, h, k) : null != k && hc.setValueForProperty(a, h, k));
      }
    }switch (b) {case "input":
        Bc.track(a);qc.postMountWrapper(a, c);break;case "textarea":
        Bc.track(a);wc.postMountWrapper(a, c);break;case "option":
        sc.postMountWrapper(a, c);break;case "select":
        uc.postMountWrapper(a, c);break;default:
        "function" === typeof f.onClick && (a.onclick = ca);}
  }, diffProperties: function diffProperties(a, b, c, d, e) {
    var f = null;switch (b) {case "input":
        c = qc.getHostProps(a, c);d = qc.getHostProps(a, d);f = [];break;case "option":
        c = sc.getHostProps(a, c);d = sc.getHostProps(a, d);f = [];break;case "select":
        c = uc.getHostProps(a, c);d = uc.getHostProps(a, d);f = [];break;case "textarea":
        c = wc.getHostProps(a, c);d = wc.getHostProps(a, d);f = [];break;default:
        "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = ca);}yc(b, d, Kc);
    var g, h;a = null;for (g in c) {
      if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], b) {
        b.hasOwnProperty(h) && (a || (a = {}), a[h] = "");
      } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && (Oc.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
    }for (g in d) {
      var k = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) {
        if (b) {
          for (h in b) {
            !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), a[h] = "");
          }for (h in k) {
            k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
          }
        } else a || (f || (f = []), f.push(g, a)), a = k;
      } else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && (Oc.hasOwnProperty(g) ? (null != k && Rc(e, g), f || b === k || (f = [])) : (f = f || []).push(g, k));
    }a && (f = f || []).push("style", a);return f;
  }, updateProperties: function updateProperties(a, b, c, d, e) {
    Cc(c, d);d = Cc(c, e);for (var f = 0; f < b.length; f += 2) {
      var g = b[f],
          h = b[f + 1];"style" === g ? bc.setValueForStyles(a, h) : "dangerouslySetInnerHTML" === g ? Fc(a, h) : "children" === g ? Jc(a, h) : d ? null != h ? hc.setValueForAttribute(a, g, h) : hc.deleteValueForAttribute(a, g) : null != h ? hc.setValueForProperty(a, g, h) : hc.deleteValueForProperty(a, g);
    }switch (c) {case "input":
        qc.updateWrapper(a, e);Bc.updateValueIfChanged(a);break;case "textarea":
        wc.updateWrapper(a, e);break;case "select":
        uc.postUpdateWrapper(a, e);}
  }, diffHydratedProperties: function diffHydratedProperties(a, b, c, d, e) {
    switch (b) {case "iframe":case "object":
        M.trapBubbledEvent("topLoad", "load", a);break;case "video":case "audio":
        for (var f in Sc) {
          Sc.hasOwnProperty(f) && M.trapBubbledEvent(f, Sc[f], a);
        }break;case "source":
        M.trapBubbledEvent("topError", "error", a);break;case "img":case "image":
        M.trapBubbledEvent("topError", "error", a);M.trapBubbledEvent("topLoad", "load", a);break;case "form":
        M.trapBubbledEvent("topReset", "reset", a);M.trapBubbledEvent("topSubmit", "submit", a);break;case "details":
        M.trapBubbledEvent("topToggle", "toggle", a);break;case "input":
        qc.initWrapperState(a, c);M.trapBubbledEvent("topInvalid", "invalid", a);Rc(e, "onChange");break;case "option":
        sc.validateProps(a, c);break;case "select":
        uc.initWrapperState(a, c);M.trapBubbledEvent("topInvalid", "invalid", a);Rc(e, "onChange");break;case "textarea":
        wc.initWrapperState(a, c), M.trapBubbledEvent("topInvalid", "invalid", a), Rc(e, "onChange");}yc(b, c, Kc);d = null;for (var g in c) {
      c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Oc.hasOwnProperty(g) && null != f && Rc(e, g));
    }switch (b) {case "input":
        Bc.track(a);qc.postMountWrapper(a, c);break;case "textarea":
        Bc.track(a);wc.postMountWrapper(a, c);break;case "select":case "option":
        break;default:
        "function" === typeof c.onClick && (a.onclick = ca);}return d;
  }, diffHydratedText: function diffHydratedText(a, b) {
    return a.nodeValue !== b;
  }, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        qc.restoreControlledState(a, c);break;case "textarea":
        wc.restoreControlledState(a, c);break;case "select":
        uc.restoreControlledState(a, c);}
  } },
    Tc = void 0;
if (l.canUseDOM) {
  if ("function" !== typeof requestIdleCallback) {
    var Uc = null,
        Vc = null,
        Wc = !1,
        Xc = !1,
        Yc = 0,
        Zc = 33,
        $c = 33,
        ad = { timeRemaining: "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now ? function () {
        return Yc - performance.now();
      } : function () {
        return Yc - Date.now();
      } },
        bd = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      a.source === window && a.data === bd && (Wc = !1, a = Vc, Vc = null, null !== a && a(ad));
    }, !1);var cd = function cd(a) {
      Xc = !1;var b = a - Yc + $c;b < $c && Zc < $c ? (8 > b && (b = 8), $c = b < Zc ? Zc : b) : Zc = b;Yc = a + $c;Wc || (Wc = !0, window.postMessage(bd, "*"));b = Uc;Uc = null;null !== b && b(a);
    };Tc = function Tc(a) {
      Vc = a;Xc || (Xc = !0, requestAnimationFrame(cd));return 0;
    };
  } else Tc = requestIdleCallback;
} else Tc = function Tc(a) {
  setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });return 0;
};
var dd = { rIC: Tc },
    ed = { enableAsyncSubtreeAPI: !0 },
    Q = { NoWork: 0, SynchronousPriority: 1, TaskPriority: 2, HighPriority: 3, LowPriority: 4, OffscreenPriority: 5 },
    fd = J.Callback,
    gd = Q.NoWork,
    hd = Q.SynchronousPriority,
    id = Q.TaskPriority,
    jd = E.ClassComponent,
    kd = E.HostRoot,
    md = void 0,
    nd = void 0;function od(a, b) {
  return a !== id && a !== hd || b !== id && b !== hd ? a === gd && b !== gd ? -255 : a !== gd && b === gd ? 255 : a - b : 0;
}function pd() {
  return { first: null, last: null, hasForceUpdate: !1, callbackList: null };
}
function qd(a, b, c, d) {
  null !== c ? c.next = b : (b.next = a.first, a.first = b);null !== d ? b.next = d : a.last = b;
}function rd(a, b) {
  b = b.priorityLevel;var c = null;if (null !== a.last && 0 >= od(a.last.priorityLevel, b)) c = a.last;else for (a = a.first; null !== a && 0 >= od(a.priorityLevel, b);) {
    c = a, a = a.next;
  }return c;
}
function sd(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = pd());null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = pd())) : a = null;md = d;nd = a !== d ? a : null;var e = md;c = nd;var f = rd(e, b),
      g = null !== f ? f.next : e.first;if (null === c) return qd(e, b, f, g), null;d = rd(c, b);a = null !== d ? d.next : c.first;qd(e, b, f, g);if (g === a && null !== g || f === d && null !== f) return null === d && (c.first = b), null === a && (c.last = null), null;b = { priorityLevel: b.priorityLevel, partialState: b.partialState, callback: b.callback, isReplace: b.isReplace,
    isForced: b.isForced, isTopLevelUnmount: b.isTopLevelUnmount, next: null };qd(c, b, d, a);return b;
}function td(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
var ud = { addUpdate: function addUpdate(a, b, c, d) {
    sd(a, { priorityLevel: d, partialState: b, callback: c, isReplace: !1, isForced: !1, isTopLevelUnmount: !1, next: null });
  }, addReplaceUpdate: function addReplaceUpdate(a, b, c, d) {
    sd(a, { priorityLevel: d, partialState: b, callback: c, isReplace: !0, isForced: !1, isTopLevelUnmount: !1, next: null });
  }, addForceUpdate: function addForceUpdate(a, b, c) {
    sd(a, { priorityLevel: c, partialState: null, callback: b, isReplace: !1, isForced: !0, isTopLevelUnmount: !1, next: null });
  }, getUpdatePriority: function getUpdatePriority(a) {
    var b = a.updateQueue;return null === b || a.tag !== jd && a.tag !== kd ? gd : null !== b.first ? b.first.priorityLevel : gd;
  }, addTopLevelUpdate: function addTopLevelUpdate(a, b, c, d) {
    var e = null === b.element;b = { priorityLevel: d, partialState: b, callback: c, isReplace: !1, isForced: !1, isTopLevelUnmount: e, next: null };a = sd(a, b);e && (e = md, c = nd, null !== e && null !== b.next && (b.next = null, e.last = b), null !== c && null !== a && null !== a.next && (a.next = null, c.last = b));
  }, beginUpdateQueue: function beginUpdateQueue(a, b, c, d, e, f, g) {
    null !== a && a.updateQueue === c && (c = b.updateQueue = { first: c.first, last: c.last, callbackList: null, hasForceUpdate: !1 });
    a = c.callbackList;for (var h = c.hasForceUpdate, k = !0, p = c.first; null !== p && 0 >= od(p.priorityLevel, g);) {
      c.first = p.next;null === c.first && (c.last = null);var x;if (p.isReplace) e = td(p, d, e, f), k = !0;else if (x = td(p, d, e, f)) e = k ? n({}, e, x) : n(e, x), k = !1;p.isForced && (h = !0);null === p.callback || p.isTopLevelUnmount && null !== p.next || (a = null !== a ? a : [], a.push(p.callback), b.effectTag |= fd);p = p.next;
    }c.callbackList = a;c.hasForceUpdate = h;null !== c.first || null !== a || h || (b.updateQueue = null);return e;
  }, commitCallbacks: function commitCallbacks(a, b, c) {
    a = b.callbackList;
    if (null !== a) for (b.callbackList = null, b = 0; b < a.length; b++) {
      var d = a[b];"function" !== typeof d ? w("191", d) : void 0;d.call(c);
    }
  } },
    vd = [],
    wd = -1,
    xd = { createCursor: function createCursor(a) {
    return { current: a };
  }, isEmpty: function isEmpty() {
    return -1 === wd;
  }, pop: function pop(a) {
    0 > wd || (a.current = vd[wd], vd[wd] = null, wd--);
  }, push: function push(a, b) {
    wd++;vd[wd] = a.current;a.current = b;
  }, reset: function reset() {
    for (; -1 < wd;) {
      vd[wd] = null, wd--;
    }
  } },
    yd = bb.isFiberMounted,
    zd = E.ClassComponent,
    Ad = E.HostRoot,
    Bd = xd.createCursor,
    Cd = xd.pop,
    Dd = xd.push,
    Ed = Bd(da),
    Fd = Bd(!1),
    Ld = da;
function Md(a, b, c) {
  a = a.stateNode;a.__reactInternalMemoizedUnmaskedChildContext = b;a.__reactInternalMemoizedMaskedChildContext = c;
}function Nd(a) {
  return a.tag === zd && null != a.type.childContextTypes;
}function Od(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : w("108", Ra(a) || "Unknown", e);
  }return n({}, b, c);
}
var R = { getUnmaskedContext: function getUnmaskedContext(a) {
    return Nd(a) ? Ld : Ed.current;
  }, cacheContext: Md, getMaskedContext: function getMaskedContext(a, b) {
    var c = a.type.contextTypes;if (!c) return da;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
        f;for (f in c) {
      e[f] = b[f];
    }d && Md(a, b, e);return e;
  }, hasContextChanged: function hasContextChanged() {
    return Fd.current;
  }, isContextConsumer: function isContextConsumer(a) {
    return a.tag === zd && null != a.type.contextTypes;
  }, isContextProvider: Nd, popContextProvider: function popContextProvider(a) {
    Nd(a) && (Cd(Fd, a), Cd(Ed, a));
  }, popTopLevelContextObject: function popTopLevelContextObject(a) {
    Cd(Fd, a);Cd(Ed, a);
  }, pushTopLevelContextObject: function pushTopLevelContextObject(a, b, c) {
    null != Ed.cursor ? w("168") : void 0;Dd(Ed, b, a);Dd(Fd, c, a);
  }, processChildContext: Od, pushContextProvider: function pushContextProvider(a) {
    if (!Nd(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || da;Ld = Ed.current;Dd(Ed, b, a);Dd(Fd, Fd.current, a);return !0;
  }, invalidateContextProvider: function invalidateContextProvider(a, b) {
    var c = a.stateNode;c ? void 0 : w("169");if (b) {
      var d = Od(a, Ld, !0);c.__reactInternalMemoizedMergedChildContext = d;Cd(Fd, a);Cd(Ed, a);Dd(Ed, d, a);
    } else Cd(Fd, a);Dd(Fd, b, a);
  }, resetContext: function resetContext() {
    Ld = da;Ed.current = da;Fd.current = !1;
  }, findCurrentUnmaskedContext: function findCurrentUnmaskedContext(a) {
    for (yd(a) && a.tag === zd ? void 0 : w("170"); a.tag !== Ad;) {
      if (Nd(a)) return a.stateNode.__reactInternalMemoizedMergedChildContext;(a = a["return"]) ? void 0 : w("171");
    }return a.stateNode.context;
  } },
    Pd = { NoContext: 0, AsyncUpdates: 1 },
    Qd = E.IndeterminateComponent,
    Rd = E.ClassComponent,
    Sd = E.HostRoot,
    Td = E.HostComponent,
    Ud = E.HostText,
    Vd = E.HostPortal,
    Wd = E.CoroutineComponent,
    Xd = E.YieldComponent,
    Yd = E.Fragment,
    Zd = Q.NoWork,
    $d = Pd.NoContext,
    ae = J.NoEffect;function be(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = ae;this.lastEffect = this.firstEffect = this.nextEffect = null;this.pendingWorkPriority = Zd;this.alternate = null;
}
function ce(a, b, c) {
  var d = void 0;"function" === typeof a ? (d = a.prototype && a.prototype.isReactComponent ? new be(Rd, b, c) : new be(Qd, b, c), d.type = a) : "string" === typeof a ? (d = new be(Td, b, c), d.type = a) : "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && "number" === typeof a.tag ? d = a : w("130", null == a ? a : typeof a === "undefined" ? "undefined" : _typeof(a), "");return d;
}
var de = { createWorkInProgress: function createWorkInProgress(a, b) {
    var c = a.alternate;null === c ? (c = new be(a.tag, a.key, a.internalContextTag), c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.effectTag = ae, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);c.pendingWorkPriority = b;c.child = a.child;c.memoizedProps = a.memoizedProps;c.memoizedState = a.memoizedState;c.updateQueue = a.updateQueue;c.sibling = a.sibling;c.index = a.index;c.ref = a.ref;return c;
  }, createHostRootFiber: function createHostRootFiber() {
    return new be(Sd, null, $d);
  },
  createFiberFromElement: function createFiberFromElement(a, b, c) {
    b = ce(a.type, a.key, b, null);b.pendingProps = a.props;b.pendingWorkPriority = c;return b;
  }, createFiberFromFragment: function createFiberFromFragment(a, b, c) {
    b = new be(Yd, null, b);b.pendingProps = a;b.pendingWorkPriority = c;return b;
  }, createFiberFromText: function createFiberFromText(a, b, c) {
    b = new be(Ud, null, b);b.pendingProps = a;b.pendingWorkPriority = c;return b;
  }, createFiberFromElementType: ce, createFiberFromHostInstanceForDeletion: function createFiberFromHostInstanceForDeletion() {
    var a = new be(Td, null, $d);a.type = "DELETED";return a;
  }, createFiberFromCoroutine: function createFiberFromCoroutine(a, b, c) {
    b = new be(Wd, a.key, b);b.type = a.handler;b.pendingProps = a;b.pendingWorkPriority = c;return b;
  }, createFiberFromYield: function createFiberFromYield(a, b) {
    return new be(Xd, null, b);
  }, createFiberFromPortal: function createFiberFromPortal(a, b, c) {
    b = new be(Vd, a.key, b);b.pendingProps = a.children || [];b.pendingWorkPriority = c;b.stateNode = { containerInfo: a.containerInfo, implementation: a.implementation };return b;
  }, largerPriority: function largerPriority(a, b) {
    return a !== Zd && (b === Zd || b > a) ? a : b;
  } },
    ee = de.createHostRootFiber,
    fe = E.IndeterminateComponent,
    ge = E.FunctionalComponent,
    he = E.ClassComponent,
    ie = E.HostComponent,
    je,
    ke;"function" === typeof Symbol && Symbol["for"] ? (je = Symbol["for"]("react.coroutine"), ke = Symbol["for"]("react.yield")) : (je = 60104, ke = 60105);
var le = { createCoroutine: function createCoroutine(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: je, key: null == d ? null : "" + d, children: a, handler: b, props: c };
  }, createYield: function createYield(a) {
    return { $$typeof: ke, value: a };
  }, isCoroutine: function isCoroutine(a) {
    return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === je;
  }, isYield: function isYield(a) {
    return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === ke;
  }, REACT_YIELD_TYPE: ke, REACT_COROUTINE_TYPE: je },
    me = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.portal") || 60106,
    ne = { createPortal: function createPortal(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: me, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }, isPortal: function isPortal(a) {
    return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === me;
  }, REACT_PORTAL_TYPE: me },
    oe = le.REACT_COROUTINE_TYPE,
    pe = le.REACT_YIELD_TYPE,
    qe = ne.REACT_PORTAL_TYPE,
    re = de.createWorkInProgress,
    se = de.createFiberFromElement,
    te = de.createFiberFromFragment,
    ue = de.createFiberFromText,
    ve = de.createFiberFromCoroutine,
    we = de.createFiberFromYield,
    xe = de.createFiberFromPortal,
    ye = Array.isArray,
    ze = E.FunctionalComponent,
    Ae = E.ClassComponent,
    Be = E.HostText,
    Ce = E.HostPortal,
    De = E.CoroutineComponent,
    Ee = E.YieldComponent,
    Fe = E.Fragment,
    Ge = J.NoEffect,
    He = J.Placement,
    Ie = J.Deletion,
    Je = "function" === typeof Symbol && Symbol.iterator,
    Ke = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;
function Le(a) {
  if (null === a || "undefined" === typeof a) return null;a = Je && a[Je] || a["@@iterator"];return "function" === typeof a ? a : null;
}
function Me(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && ("number" === typeof b.tag ? (b.tag !== Ae ? w("110") : void 0, d = b.stateNode) : d = b.getPublicInstance());d ? void 0 : w("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === da ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? w("148") : void 0;b._owner ? void 0 : w("149", c);
  }return c;
}
function Ne(a, b) {
  "textarea" !== a.type && w("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function Oe(a, b) {
  function c(c, d) {
    if (b) {
      if (!a) {
        if (null === d.alternate) return;d = d.alternate;
      }var m = c.lastEffect;null !== m ? (m.nextEffect = d, c.lastEffect = d) : c.firstEffect = c.lastEffect = d;d.nextEffect = null;d.effectTag = Ie;
    }
  }function d(a, d) {
    if (!b) return null;for (; null !== d;) {
      c(a, d), d = d.sibling;
    }return null;
  }function e(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function f(b, c) {
    if (a) return b = re(b, c), b.index = 0, b.sibling = null, b;b.pendingWorkPriority = c;b.effectTag = Ge;
    b.index = 0;b.sibling = null;return b;
  }function g(a, c, d) {
    a.index = d;if (!b) return c;d = a.alternate;if (null !== d) return d = d.index, d < c ? (a.effectTag = He, c) : d;a.effectTag = He;return c;
  }function h(a) {
    b && null === a.alternate && (a.effectTag = He);return a;
  }function k(a, b, c, d) {
    if (null === b || b.tag !== Be) return c = ue(c, a.internalContextTag, d), c["return"] = a, c;b = f(b, d);b.pendingProps = c;b["return"] = a;return b;
  }function p(a, b, c, d) {
    if (null === b || b.type !== c.type) return d = se(c, a.internalContextTag, d), d.ref = Me(b, c), d["return"] = a, d;d = f(b, d);d.ref = Me(b, c);d.pendingProps = c.props;d["return"] = a;return d;
  }function x(a, b, c, d) {
    if (null === b || b.tag !== De) return c = ve(c, a.internalContextTag, d), c["return"] = a, c;b = f(b, d);b.pendingProps = c;b["return"] = a;return b;
  }function S(a, b, c, d) {
    if (null === b || b.tag !== Ee) return b = we(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = f(b, d);b.type = c.value;b["return"] = a;return b;
  }function D(a, b, c, d) {
    if (null === b || b.tag !== Ce || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return c = xe(c, a.internalContextTag, d), c["return"] = a, c;b = f(b, d);b.pendingProps = c.children || [];b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || b.tag !== Fe) return c = te(c, a.internalContextTag, d), c["return"] = a, c;b = f(b, d);b.pendingProps = c;b["return"] = a;return b;
  }function B(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = ue("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Ke:
          return c = se(b, a.internalContextTag, c), c.ref = Me(null, b), c["return"] = a, c;case oe:
          return b = ve(b, a.internalContextTag, c), b["return"] = a, b;case pe:
          return c = we(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case qe:
          return b = xe(b, a.internalContextTag, c), b["return"] = a, b;}if (ye(b) || Le(b)) return b = te(b, a.internalContextTag, c), b["return"] = a, b;Ne(a, b);
    }return null;
  }function H(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : k(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Ke:
          return c.key === e ? p(a, b, c, d) : null;case oe:
          return c.key === e ? x(a, b, c, d) : null;case pe:
          return null === e ? S(a, b, c, d) : null;case qe:
          return c.key === e ? D(a, b, c, d) : null;}if (ye(c) || Le(c)) return null !== e ? null : y(a, b, c, d);Ne(a, c);
    }return null;
  }function C(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, k(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Ke:
          return a = a.get(null === d.key ? c : d.key) || null, p(b, a, d, e);case oe:
          return a = a.get(null === d.key ? c : d.key) || null, x(b, a, d, e);case pe:
          return a = a.get(c) || null, S(b, a, d, e);case qe:
          return a = a.get(null === d.key ? c : d.key) || null, D(b, a, d, e);}if (ye(d) || Le(d)) return a = a.get(c) || null, y(b, a, d, e);Ne(b, d);
    }return null;
  }function Ca(a, f, h, k) {
    for (var m = null, t = null, q = f, r = f = 0, p = null; null !== q && r < h.length; r++) {
      q.index > r ? (p = q, q = null) : p = q.sibling;var v = H(a, q, h[r], k);if (null === v) {
        null === q && (q = p);break;
      }b && q && null === v.alternate && c(a, q);f = g(v, f, r);null === t ? m = v : t.sibling = v;t = v;q = p;
    }if (r === h.length) return d(a, q), m;if (null === q) {
      for (; r < h.length; r++) {
        if (q = B(a, h[r], k)) f = g(q, f, r), null === t ? m = q : t.sibling = q, t = q;
      }return m;
    }for (q = e(a, q); r < h.length; r++) {
      if (p = C(q, a, r, h[r], k)) {
        if (b && null !== p.alternate) q["delete"](null === p.key ? r : p.key);f = g(p, f, r);null === t ? m = p : t.sibling = p;t = p;
      }
    }b && q.forEach(function (b) {
      return c(a, b);
    });return m;
  }function r(a, f, h, r) {
    var m = Le(h);"function" !== typeof m ? w("150") : void 0;h = m.call(h);null == h ? w("151") : void 0;for (var t = m = null, q = f, k = f = 0, p = null, v = h.next(); null !== q && !v.done; k++, v = h.next()) {
      q.index > k ? (p = q, q = null) : p = q.sibling;var V = H(a, q, v.value, r);if (null === V) {
        q || (q = p);break;
      }b && q && null === V.alternate && c(a, q);f = g(V, f, k);null === t ? m = V : t.sibling = V;t = V;q = p;
    }if (v.done) return d(a, q), m;if (null === q) {
      for (; !v.done; k++, v = h.next()) {
        v = B(a, v.value, r), null !== v && (f = g(v, f, k), null === t ? m = v : t.sibling = v, t = v);
      }return m;
    }for (q = e(a, q); !v.done; k++, v = h.next()) {
      if (v = C(q, a, k, v.value, r), null !== v) {
        if (b && null !== v.alternate) q["delete"](null === v.key ? k : v.key);f = g(v, f, k);null === t ? m = v : t.sibling = v;t = v;
      }
    }b && q.forEach(function (b) {
      return c(a, b);
    });return m;
  }return function (a, b, e, g) {
    var m = "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;if (m) switch (e.$$typeof) {case Ke:
        a: {
          var C = e.key;for (m = b; null !== m;) {
            if (m.key === C) {
              if (m.type === e.type) {
                d(a, m.sibling);b = f(m, g);b.ref = Me(m, e);b.pendingProps = e.props;b["return"] = a;a = b;break a;
              } else {
                d(a, m);break;
              }
            } else c(a, m);m = m.sibling;
          }g = se(e, a.internalContextTag, g);g.ref = Me(b, e);g["return"] = a;a = g;
        }return h(a);case oe:
        a: {
          for (m = e.key; null !== b;) {
            if (b.key === m) {
              if (b.tag === De) {
                d(a, b.sibling);b = f(b, g);b.pendingProps = e;b["return"] = a;a = b;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = ve(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return h(a);case pe:
        a: {
          if (null !== b) if (b.tag === Ee) {
            d(a, b.sibling);b = f(b, g);b.type = e.value;b["return"] = a;a = b;break a;
          } else d(a, b);b = we(e, a.internalContextTag, g);b.type = e.value;b["return"] = a;a = b;
        }return h(a);case qe:
        a: {
          for (m = e.key; null !== b;) {
            if (b.key === m) {
              if (b.tag === Ce && b.stateNode.containerInfo === e.containerInfo && b.stateNode.implementation === e.implementation) {
                d(a, b.sibling);b = f(b, g);b.pendingProps = e.children || [];b["return"] = a;a = b;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = xe(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return h(a);}if ("string" === typeof e || "number" === typeof e) return e = "" + e, null !== b && b.tag === Be ? (d(a, b.sibling), b = f(b, g), b.pendingProps = e, b["return"] = a, a = b) : (d(a, b), e = ue(e, a.internalContextTag, g), e["return"] = a, a = e), h(a);if (ye(e)) return Ca(a, b, e, g);if (Le(e)) return r(a, b, e, g);m && Ne(a, e);if ("undefined" === typeof e) switch (a.tag) {case Ae:case ze:
        e = a.type, w("152", e.displayName || e.name || "Component");}return d(a, b);
  };
}
var Pe = Oe(!0, !0),
    Qe = Oe(!1, !0),
    Re = Oe(!1, !1),
    Se = { reconcileChildFibers: Pe, reconcileChildFibersInPlace: Qe, mountChildFibersInPlace: Re, cloneChildFibers: function cloneChildFibers(a, b) {
    null !== a && b.child !== a.child ? w("153") : void 0;if (null !== b.child) {
      a = b.child;var c = re(a, a.pendingWorkPriority);c.pendingProps = a.pendingProps;b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = re(a, a.pendingWorkPriority), c.pendingProps = a.pendingProps, c["return"] = b;
      }c.sibling = null;
    }
  } },
    Te = J.Update,
    Ue = Pd.AsyncUpdates,
    Ve = R.cacheContext,
    We = R.getMaskedContext,
    Xe = R.getUnmaskedContext,
    Ye = R.isContextConsumer,
    Ze = ud.addUpdate,
    $e = ud.addReplaceUpdate,
    af = ud.addForceUpdate,
    bf = ud.beginUpdateQueue,
    cf = R.hasContextChanged,
    df = bb.isMounted;
function ef(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;Pa.set(b, a);
  }var f = { isMounted: df, enqueueSetState: function enqueueSetState(c, d, e) {
      c = Pa.get(c);var f = b(c, !1);Ze(c, d, void 0 === e ? null : e, f);a(c, f);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = Pa.get(c);var f = b(c, !1);$e(c, d, void 0 === e ? null : e, f);a(c, f);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = Pa.get(c);var e = b(c, !1);af(c, void 0 === d ? null : d, e);a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = Xe(a),
          f = Ye(a),
          g = f ? We(a, d) : da;b = new c(b, g);
      e(a, b);f && Ve(a, d, g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : w("158");var h = Xe(a);d.props = g;d.state = e;d.refs = da;d.context = We(a, h);ed.enableAsyncSubtreeAPI && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= Ue);"function" === typeof d.componentWillMount && (h = d.state, d.componentWillMount(), h !== d.state && f.enqueueReplaceState(d, d.state, null), h = a.updateQueue, null !== h && (d.state = bf(c, a, h, d, e, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= Te);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var h = b.memoizedProps,
          k = b.pendingProps;k || (k = h, null == k ? w("159") : void 0);var D = g.context,
          y = Xe(b);y = We(b, y);"function" !== typeof g.componentWillReceiveProps || h === k && D === y || (D = g.state, g.componentWillReceiveProps(k, y), g.state !== D && f.enqueueReplaceState(g, g.state, null));D = b.memoizedState;e = null !== b.updateQueue ? bf(a, b, b.updateQueue, g, D, k, e) : D;if (!(h !== k || D !== e || cf() || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && D === a.memoizedState || (b.effectTag |= Te), !1;var B = k;if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) B = !0;else {
        var H = b.stateNode,
            C = b.type;B = "function" === typeof H.shouldComponentUpdate ? H.shouldComponentUpdate(B, e, y) : C.prototype && C.prototype.isPureReactComponent ? !ea(h, B) || !ea(D, e) : !0;
      }B ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, y), "function" === typeof g.componentDidUpdate && (b.effectTag |= Te)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && D === a.memoizedState || (b.effectTag |= Te), c(b, k), d(b, e));g.props = k;g.state = e;g.context = y;return B;
    } };
}
var ff = Se.mountChildFibersInPlace,
    gf = Se.reconcileChildFibers,
    hf = Se.reconcileChildFibersInPlace,
    jf = Se.cloneChildFibers,
    kf = ud.beginUpdateQueue,
    lf = R.getMaskedContext,
    mf = R.getUnmaskedContext,
    nf = R.hasContextChanged,
    of = R.pushContextProvider,
    pf = R.pushTopLevelContextObject,
    qf = R.invalidateContextProvider,
    rf = E.IndeterminateComponent,
    sf = E.FunctionalComponent,
    tf = E.ClassComponent,
    uf = E.HostRoot,
    wf = E.HostComponent,
    xf = E.HostText,
    yf = E.HostPortal,
    zf = E.CoroutineComponent,
    Af = E.CoroutineHandlerPhase,
    Bf = E.YieldComponent,
    Cf = E.Fragment,
    Df = Q.NoWork,
    Ef = Q.OffscreenPriority,
    Ff = J.PerformedWork,
    Gf = J.Placement,
    Hf = J.ContentReset,
    If = J.Err,
    Jf = J.Ref,
    Kf = Qa.ReactCurrentOwner;
function Lf(a, b, c, d, e) {
  function f(a, b, c) {
    g(a, b, c, b.pendingWorkPriority);
  }function g(a, b, c, d) {
    b.child = null === a ? ff(b, b.child, c, d) : a.child === b.child ? gf(b, b.child, c, d) : hf(b, b.child, c, d);
  }function h(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= Jf);
  }function k(a, b, c, d) {
    h(a, b);if (!c) return d && qf(b, !1), x(a, b);c = b.stateNode;Kf.current = b;var e = c.render();b.effectTag |= Ff;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && qf(b, !0);return b.child;
  }function p(a) {
    var b = a.stateNode;b.pendingContext ? pf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && pf(a, b.context, !1);C(a, b.containerInfo);
  }function x(a, b) {
    jf(a, b);return b.child;
  }function S(a, b) {
    switch (b.tag) {case uf:
        p(b);break;case tf:
        of(b);break;case yf:
        C(b, b.stateNode.containerInfo);}return null;
  }var D = a.shouldSetTextContent,
      y = a.useSyncScheduling,
      B = a.shouldDeprioritizeSubtree,
      H = b.pushHostContext,
      C = b.pushHostContainer,
      Ca = c.enterHydrationState,
      r = c.resetHydrationState,
      m = c.tryToClaimNextHydratableInstance;a = ef(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var t = a.adoptClassInstance,
      v = a.constructClassInstance,
      V = a.mountClassInstance,
      ld = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (b.pendingWorkPriority === Df || b.pendingWorkPriority > c) return S(a, b);switch (b.tag) {case rf:
          null !== a ? w("155") : void 0;var d = b.type,
              e = b.pendingProps,
              g = mf(b);g = lf(b, g);d = d(e, g);b.effectTag |= Ff;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = tf, e = of(b), t(b, d), V(b, c), b = k(a, b, !0, e)) : (b.tag = sf, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case sf:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (nf()) null === c && (c = d);else if (null === c || d === c) {
              b = x(a, b);break a;
            }d = mf(b);d = lf(b, d);e = e(c, d);b.effectTag |= Ff;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case tf:
          return e = of(b), d = void 0, null === a ? b.stateNode ? w("153") : (v(b, b.pendingProps), V(b, c), d = !0) : d = ld(a, b, c), k(a, b, d, e);case uf:
          return p(b), d = b.updateQueue, null !== d ? (e = b.memoizedState, d = kf(a, b, d, null, e, null, c), e === d ? (r(), b = x(a, b)) : (e = d.element, null !== a && null !== a.child || !Ca(b) ? (r(), f(a, b, e)) : (b.effectTag |= Gf, b.child = ff(b, b.child, e, c)), b.memoizedState = d, b = b.child)) : (r(), b = x(a, b)), b;case wf:
          H(b);null === a && m(b);e = b.type;var q = b.memoizedProps;d = b.pendingProps;null === d && (d = q, null === d ? w("154") : void 0);g = null !== a ? a.memoizedProps : null;nf() || null !== d && q !== d ? (q = d.children, D(e, d) ? q = null : g && D(e, g) && (b.effectTag |= Hf), h(a, b), c !== Ef && !y && B(e, d) ? (b.pendingWorkPriority = Ef, b = null) : (f(a, b, q), b.memoizedProps = d, b = b.child)) : b = x(a, b);return b;case xf:
          return null === a && m(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case Af:
          b.tag = zf;case zf:
          c = b.pendingProps;if (nf()) null === c && (c = a && a.memoizedProps, null === c ? w("154") : void 0);else if (null === c || b.memoizedProps === c) c = b.memoizedProps;e = c.children;d = b.pendingWorkPriority;b.stateNode = null === a ? ff(b, b.stateNode, e, d) : a.child === b.child ? gf(b, b.stateNode, e, d) : hf(b, b.stateNode, e, d);b.memoizedProps = c;return b.stateNode;case Bf:
          return null;case yf:
          a: {
            C(b, b.stateNode.containerInfo);c = b.pendingWorkPriority;e = b.pendingProps;if (nf()) null === e && (e = a && a.memoizedProps, null == e ? w("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = x(a, b);break a;
            }null === a ? b.child = hf(b, b.child, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case Cf:
          a: {
            c = b.pendingProps;if (nf()) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = x(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          w("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case tf:
          of(b);break;case uf:
          p(b);break;default:
          w("157");}b.effectTag |= If;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (b.pendingWorkPriority === Df || b.pendingWorkPriority > c) return S(a, b);b.firstEffect = null;b.lastEffect = null;g(a, b, null, c);b.tag === tf && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
var Mf = Se.reconcileChildFibers,
    Nf = R.popContextProvider,
    Of = R.popTopLevelContextObject,
    Pf = E.IndeterminateComponent,
    Qf = E.FunctionalComponent,
    Rf = E.ClassComponent,
    Sf = E.HostRoot,
    Tf = E.HostComponent,
    Uf = E.HostText,
    Vf = E.HostPortal,
    Wf = E.CoroutineComponent,
    Xf = E.CoroutineHandlerPhase,
    Yf = E.YieldComponent,
    Zf = E.Fragment,
    ag = J.Placement,
    bg = J.Ref,
    cg = J.Update,
    dg = Q.OffscreenPriority;
function eg(a, b, c) {
  var d = a.createInstance,
      e = a.createTextInstance,
      f = a.appendInitialChild,
      g = a.finalizeInitialChildren,
      h = a.prepareUpdate,
      k = b.getRootHostContainer,
      p = b.popHostContext,
      x = b.getHostContext,
      S = b.popHostContainer,
      D = c.prepareToHydrateHostInstance,
      y = c.prepareToHydrateHostTextInstance,
      B = c.popHydrationState;return { completeWork: function completeWork(a, b, c) {
      var r = b.pendingProps;if (null === r) r = b.memoizedProps;else if (b.pendingWorkPriority !== dg || c === dg) b.pendingProps = null;switch (b.tag) {case Qf:
          return null;case Rf:
          return Nf(b), null;case Sf:
          S(b);Of(b);r = b.stateNode;r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null);if (null === a || null === a.child) B(b), b.effectTag &= ~ag;return null;case Tf:
          p(b);c = k();var m = b.type;if (null !== a && null != b.stateNode) {
            var t = a.memoizedProps,
                C = b.stateNode,
                V = x();r = h(C, m, t, r, c, V);if (b.updateQueue = r) b.effectTag |= cg;a.ref !== b.ref && (b.effectTag |= bg);
          } else {
            if (!r) return null === b.stateNode ? w("166") : void 0, null;a = x();if (B(b)) D(b, c, a) && (b.effectTag |= cg);else {
              a = d(m, r, c, a, b);a: for (t = b.child; null !== t;) {
                if (t.tag === Tf || t.tag === Uf) f(a, t.stateNode);else if (t.tag !== Vf && null !== t.child) {
                  t = t.child;continue;
                }if (t === b) break a;for (; null === t.sibling;) {
                  if (null === t["return"] || t["return"] === b) break a;t = t["return"];
                }t = t.sibling;
              }g(a, m, r, c) && (b.effectTag |= cg);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= bg);
          }return null;case Uf:
          if (a && null != b.stateNode) a.memoizedProps !== r && (b.effectTag |= cg);else {
            if ("string" !== typeof r) return null === b.stateNode ? w("166") : void 0, null;a = k();c = x();B(b) ? y(b) && (b.effectTag |= cg) : b.stateNode = e(r, a, c, b);
          }return null;case Wf:
          (r = b.memoizedProps) ? void 0 : w("165");b.tag = Xf;c = [];a: for ((m = b.stateNode) && (m["return"] = b); null !== m;) {
            if (m.tag === Tf || m.tag === Uf || m.tag === Vf) w("164");else if (m.tag === Yf) c.push(m.type);else if (null !== m.child) {
              m.child["return"] = m;m = m.child;continue;
            }for (; null === m.sibling;) {
              if (null === m["return"] || m["return"] === b) break a;m = m["return"];
            }m.sibling["return"] = m["return"];m = m.sibling;
          }m = r.handler;r = m(r.props, c);b.child = Mf(b, null !== a ? a.child : null, r, b.pendingWorkPriority);return b.child;
        case Xf:
          return b.tag = Wf, null;case Yf:
          return null;case Zf:
          return null;case Vf:
          return b.effectTag |= cg, S(b), null;case Pf:
          w("167");default:
          w("156");}
    } };
}var fg = null,
    gg = null;function hg(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}
var ig = { injectInternals: function injectInternals(a) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (!b.supportsFiber) return !0;try {
      var c = b.inject(a);fg = hg(function (a) {
        return b.onCommitFiberRoot(c, a);
      });gg = hg(function (a) {
        return b.onCommitFiberUnmount(c, a);
      });
    } catch (d) {}return !0;
  }, onCommitRoot: function onCommitRoot(a) {
    "function" === typeof fg && fg(a);
  }, onCommitUnmount: function onCommitUnmount(a) {
    "function" === typeof gg && gg(a);
  } },
    jg = E.ClassComponent,
    kg = E.HostRoot,
    lg = E.HostComponent,
    mg = E.HostText,
    ng = E.HostPortal,
    og = E.CoroutineComponent,
    pg = ud.commitCallbacks,
    qg = ig.onCommitUnmount,
    rg = J.Placement,
    sg = J.Update,
    tg = J.Callback,
    ug = J.ContentReset;
function vg(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (t) {
      b(a, t);
    }
  }function d(a) {
    return a.tag === lg || a.tag === kg || a.tag === ng;
  }function e(a) {
    for (var b = a;;) {
      if (g(b), null !== b.child && b.tag !== ng) b.child["return"] = b, b = b.child;else {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      }
    }
  }function f(a) {
    for (var b = a, c = !1, d = void 0, f = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? w("160") : void 0;switch (c.tag) {case lg:
              d = c.stateNode;f = !1;break a;case kg:
              d = c.stateNode.containerInfo;f = !0;break a;case ng:
              d = c.stateNode.containerInfo;f = !0;break a;}c = c["return"];
        }c = !0;
      }if (b.tag === lg || b.tag === mg) e(b), f ? C(d, b.stateNode) : H(d, b.stateNode);else if (b.tag === ng ? d = b.stateNode.containerInfo : g(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];b.tag === ng && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }function g(a) {
    "function" === typeof qg && qg(a);switch (a.tag) {case jg:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (t) {
          b(a, t);
        }break;case lg:
        c(a);break;case og:
        e(a.stateNode);break;case ng:
        f(a);}
  }var h = a.commitMount,
      k = a.commitUpdate,
      p = a.resetTextContent,
      x = a.commitTextUpdate,
      S = a.appendChild,
      D = a.appendChildToContainer,
      y = a.insertBefore,
      B = a.insertInContainerBefore,
      H = a.removeChild,
      C = a.removeChildFromContainer,
      Ca = a.getPublicInstance;
  return { commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (d(b)) {
            var c = b;break a;
          }b = b["return"];
        }w("160");c = void 0;
      }var e = b = void 0;switch (c.tag) {case lg:
          b = c.stateNode;e = !1;break;case kg:
          b = c.stateNode.containerInfo;e = !0;break;case ng:
          b = c.stateNode.containerInfo;e = !0;break;default:
          w("161");}c.effectTag & ug && (p(b), c.effectTag &= ~ug);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || d(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; c.tag !== lg && c.tag !== mg;) {
          if (c.effectTag & rg) continue b;if (null === c.child || c.tag === ng) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & rg)) {
          c = c.stateNode;break a;
        }
      }for (var f = a;;) {
        if (f.tag === lg || f.tag === mg) c ? e ? B(b, f.stateNode, c) : y(b, f.stateNode, c) : e ? D(b, f.stateNode) : S(b, f.stateNode);else if (f.tag !== ng && null !== f.child) {
          f.child["return"] = f;f = f.child;continue;
        }if (f === a) break;for (; null === f.sibling;) {
          if (null === f["return"] || f["return"] === a) return;f = f["return"];
        }f.sibling["return"] = f["return"];f = f.sibling;
      }
    },
    commitDeletion: function commitDeletion(a) {
      f(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case jg:
          break;case lg:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && k(c, f, e, a, d, b);
          }break;case mg:
          null === b.stateNode ? w("162") : void 0;c = b.memoizedProps;x(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case kg:
          break;case ng:
          break;default:
          w("163");}
    },
    commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case jg:
          var c = b.stateNode;if (b.effectTag & sg) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b.effectTag & tg && null !== b.updateQueue && pg(b, b.updateQueue, c);break;case kg:
          a = b.updateQueue;null !== a && pg(b, a, b.child && b.child.stateNode);break;case lg:
          c = b.stateNode;null === a && b.effectTag & sg && h(c, b.type, b.memoizedProps, b);break;case mg:
          break;case ng:
          break;default:
          w("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case lg:
            b(Ca(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var wg = xd.createCursor,
    xg = xd.pop,
    yg = xd.push,
    zg = {};
function Ag(a) {
  function b(a) {
    a === zg ? w("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = wg(zg),
      f = wg(zg),
      g = wg(zg);return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      xg(e, a);xg(f, a);xg(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (xg(e, a), xg(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      yg(g, b, a);b = d(b);yg(f, a, a);yg(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          h = b(e.current);d = c(h, a.type, d);h !== d && (yg(f, a, a), yg(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = zg;g.current = zg;
    } };
}var Bg = E.HostComponent,
    Cg = E.HostText,
    Dg = E.HostRoot,
    Eg = J.Deletion,
    Fg = J.Placement,
    Gg = de.createFiberFromHostInstanceForDeletion;
function Hg(a) {
  function b(a, b) {
    var c = Gg();c.stateNode = b;c["return"] = a;c.effectTag = Eg;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case Bg:
        return f(b, a.type, a.pendingProps);case Cg:
        return g(b, a.pendingProps);default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && a.tag !== Bg && a.tag !== Dg;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent,
      f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      h = a.getNextHydratableSibling,
      k = a.getFirstHydratableChild,
      p = a.hydrateInstance,
      x = a.hydrateTextInstance,
      S = a.didNotHydrateInstance,
      D = a.didNotFindHydratableInstance;a = a.didNotFindHydratableTextInstance;if (!(f && g && h && k && p && x && S && D && a)) return { enterHydrationState: function enterHydrationState() {
      return !1;
    }, resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      w("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      w("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var y = null,
      B = null,
      H = !1;return { enterHydrationState: function enterHydrationState(a) {
      B = k(a.stateNode.containerInfo);y = a;return H = !0;
    }, resetHydrationState: function resetHydrationState() {
      B = y = null;H = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (H) {
        var d = B;if (d) {
          if (!c(a, d)) {
            d = h(d);if (!d || !c(a, d)) {
              a.effectTag |= Fg;H = !1;y = a;return;
            }b(y, B);
          }a.stateNode = d;y = a;B = k(d);
        } else a.effectTag |= Fg, H = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = p(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return x(a.stateNode, a.memoizedProps, a);
    },
    popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!H) return d(a), H = !0, !1;var c = a.type;if (a.tag !== Bg || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = B; c;) {
        b(a, c), c = h(c);
      }d(a);B = y ? h(a.stateNode) : null;return !0;
    } };
}
var Ig = R.popContextProvider,
    Jg = xd.reset,
    Kg = Qa.ReactCurrentOwner,
    Lg = de.createWorkInProgress,
    Mg = de.largerPriority,
    Ng = ig.onCommitRoot,
    T = Q.NoWork,
    Og = Q.SynchronousPriority,
    U = Q.TaskPriority,
    Pg = Q.HighPriority,
    Qg = Q.LowPriority,
    Rg = Q.OffscreenPriority,
    Sg = Pd.AsyncUpdates,
    Tg = J.PerformedWork,
    Ug = J.Placement,
    Vg = J.Update,
    Wg = J.PlacementAndUpdate,
    Xg = J.Deletion,
    Yg = J.ContentReset,
    Zg = J.Callback,
    $g = J.Err,
    ah = J.Ref,
    bh = E.HostRoot,
    ch = E.HostComponent,
    dh = E.HostPortal,
    eh = E.ClassComponent,
    fh = ud.getUpdatePriority,
    gh = R.resetContext;
function hh(a) {
  function b() {
    for (; null !== ma && ma.current.pendingWorkPriority === T;) {
      ma.isScheduled = !1;var a = ma.nextScheduledRoot;ma.nextScheduledRoot = null;if (ma === zb) return zb = ma = null, z = T, null;ma = a;
    }a = ma;for (var b = null, c = T; null !== a;) {
      a.current.pendingWorkPriority !== T && (c === T || c > a.current.pendingWorkPriority) && (c = a.current.pendingWorkPriority, b = a), a = a.nextScheduledRoot;
    }null !== b ? (z = c, Jg(), gh(), t(), I = Lg(b.current, c), b !== nc && (oc = 0, nc = b)) : (z = T, nc = I = null);
  }function c(c) {
    Hd = !0;na = null;var d = c.stateNode;d.current === c ? w("177") : void 0;z !== Og && z !== U || oc++;Kg.current = null;if (c.effectTag > Tg) {
      if (null !== c.lastEffect) {
        c.lastEffect.nextEffect = c;var e = c.firstEffect;
      } else e = c;
    } else e = c.firstEffect;Ui();for (u = e; null !== u;) {
      var f = !1,
          g = void 0;try {
        for (; null !== u;) {
          var h = u.effectTag;h & Yg && a.resetTextContent(u.stateNode);if (h & ah) {
            var k = u.alternate;null !== k && Ph(k);
          }switch (h & ~(Zg | $g | Yg | ah | Tg)) {case Ug:
              q(u);u.effectTag &= ~Ug;break;case Wg:
              q(u);u.effectTag &= ~Ug;vf(u.alternate, u);break;case Vg:
              vf(u.alternate, u);break;case Xg:
              Id = !0, Mh(u), Id = !1;}u = u.nextEffect;
        }
      } catch (Jd) {
        f = !0, g = Jd;
      }f && (null === u ? w("178") : void 0, x(u, g), null !== u && (u = u.nextEffect));
    }Vi();d.current = c;for (u = e; null !== u;) {
      d = !1;e = void 0;try {
        for (; null !== u;) {
          var Gd = u.effectTag;Gd & (Vg | Zg) && Nh(u.alternate, u);Gd & ah && Oh(u);if (Gd & $g) switch (f = u, g = void 0, null !== P && (g = P.get(f), P["delete"](f), null == g && null !== f.alternate && (f = f.alternate, g = P.get(f), P["delete"](f))), null == g ? w("184") : void 0, f.tag) {case eh:
              f.stateNode.componentDidCatch(g.error, { componentStack: g.componentStack });break;case bh:
              null === Ja && (Ja = g.error);break;default:
              w("157");}var m = u.nextEffect;u.nextEffect = null;u = m;
        }
      } catch (Jd) {
        d = !0, e = Jd;
      }d && (null === u ? w("178") : void 0, x(u, e), null !== u && (u = u.nextEffect));
    }Hd = !1;"function" === typeof Ng && Ng(c.stateNode);va && (va.forEach(H), va = null);b();
  }function d(a) {
    for (;;) {
      var b = Lh(a.alternate, a, z),
          c = a["return"],
          d = a.sibling;var e = a;if (!(e.pendingWorkPriority !== T && e.pendingWorkPriority > z)) {
        for (var f = fh(e), g = e.child; null !== g;) {
          f = Mg(f, g.pendingWorkPriority), g = g.sibling;
        }e.pendingWorkPriority = f;
      }if (null !== b) return b;
      null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), a.effectTag > Tg && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;if (null !== c) a = c;else {
        na = a;break;
      }
    }return null;
  }function e(a) {
    var b = V(a.alternate, a, z);null === b && (b = d(a));Kg.current = null;return b;
  }function f(a) {
    var b = ld(a.alternate, a, z);null === b && (b = d(a));Kg.current = null;return b;
  }
  function g(a) {
    p(Rg, a);
  }function h() {
    if (null !== P && 0 < P.size && z === U) for (; null !== I;) {
      var a = I;I = null !== P && (P.has(a) || null !== a.alternate && P.has(a.alternate)) ? f(I) : e(I);if (null === I && (null === na ? w("179") : void 0, O = U, c(na), O = z, null === P || 0 === P.size || z !== U)) break;
    }
  }function k(a, d) {
    null !== na ? (O = U, c(na), h()) : null === I && b();if (!(z === T || z > a)) {
      O = z;a: do {
        if (z <= U) for (; null !== I && !(I = e(I), null === I && (null === na ? w("179") : void 0, O = U, c(na), O = z, h(), z === T || z > a || z > U));) {} else if (null !== d) for (; null !== I && !Ab;) {
          if (1 < d.timeRemaining()) {
            if (I = e(I), null === I) if (null === na ? w("179") : void 0, 1 < d.timeRemaining()) {
              if (O = U, c(na), O = z, h(), z === T || z > a || z < Pg) break;
            } else Ab = !0;
          } else Ab = !0;
        }switch (z) {case Og:case U:
            if (z <= a) continue a;break a;case Pg:case Qg:case Rg:
            if (null === d) break a;if (!Ab && z <= a) continue a;break a;case T:
            break a;default:
            w("181");}
      } while (1);
    }
  }function p(a, b) {
    Da ? w("182") : void 0;Da = !0;var c = O,
        d = !1,
        e = null;try {
      k(a, b);
    } catch (Kd) {
      d = !0, e = Kd;
    }for (; d;) {
      if (Ya) {
        Ja = e;break;
      }var h = I;if (null === h) Ya = !0;else {
        var p = x(h, e);null === p ? w("183") : void 0;if (!Ya) {
          try {
            d = p;e = a;p = b;for (var q = d; null !== h;) {
              switch (h.tag) {case eh:
                  Ig(h);break;case ch:
                  m(h);break;case bh:
                  r(h);break;case dh:
                  r(h);}if (h === q || h.alternate === q) break;h = h["return"];
            }I = f(d);k(e, p);
          } catch (Kd) {
            d = !0;e = Kd;continue;
          }break;
        }
      }
    }O = c;null !== b && (Bb = !1);z > U && !Bb && ($f(g), Bb = !0);a = Ja;Ya = Ab = Da = !1;nc = Ka = P = Ja = null;oc = 0;if (null !== a) throw a;
  }function x(a, b) {
    var c = Kg.current = null,
        d = !1,
        e = !1,
        f = null;if (a.tag === bh) c = a, S(a) && (Ya = !0);else for (var g = a["return"]; null !== g && null === c;) {
      g.tag === eh ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = Ra(g), c = g, e = !0) : g.tag === bh && (c = g);if (S(g)) {
        if (Id || null !== va && (va.has(g) || null !== g.alternate && va.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === Ka && (Ka = new Set());Ka.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case fe:case ge:case he:case ie:
            var k = g._debugOwner,
                m = g._debugSource;var p = Ra(g);var q = null;k && (q = Ra(k));k = m;p = "\n    in " + (p || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : q ? " (created by " + q + ")" : "");break a;default:
            p = "";}h += p;g = g["return"];
      } while (g);
      g = h;a = Ra(a);null === P && (P = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };P.set(c, b);try {
        console.error(b.error);
      } catch (Wi) {
        console.error(Wi);
      }Hd ? (null === va && (va = new Set()), va.add(c)) : H(c);return c;
    }null === Ja && (Ja = b);return null;
  }function S(a) {
    return null !== Ka && (Ka.has(a) || null !== a.alternate && Ka.has(a.alternate));
  }function D(a, b) {
    return y(a, b, !1);
  }function y(a, b) {
    oc > Xi && (Ya = !0, w("185"));!Da && b <= z && (I = null);for (var c = !0; null !== a && c;) {
      c = !1;if (a.pendingWorkPriority === T || a.pendingWorkPriority > b) c = !0, a.pendingWorkPriority = b;null !== a.alternate && (a.alternate.pendingWorkPriority === T || a.alternate.pendingWorkPriority > b) && (c = !0, a.alternate.pendingWorkPriority = b);if (null === a["return"]) if (a.tag === bh) {
        var d = a.stateNode;b === T || d.isScheduled || (d.isScheduled = !0, zb ? zb.nextScheduledRoot = d : ma = d, zb = d);if (!Da) switch (b) {case Og:
            pc ? p(Og, null) : p(U, null);break;case U:
            W ? void 0 : w("186");break;default:
            Bb || ($f(g), Bb = !0);}
      } else break;a = a["return"];
    }
  }
  function B(a, b) {
    var c = O;c === T && (c = !Yi || a.internalContextTag & Sg || b ? Qg : Og);return c === Og && (Da || W) ? U : c;
  }function H(a) {
    y(a, U, !0);
  }var C = Ag(a),
      Ca = Hg(a),
      r = C.popHostContainer,
      m = C.popHostContext,
      t = C.resetHostContainer,
      v = Lf(a, C, Ca, D, B),
      V = v.beginWork,
      ld = v.beginFailedWork,
      Lh = eg(a, C, Ca).completeWork;C = vg(a, x);var q = C.commitPlacement,
      Mh = C.commitDeletion,
      vf = C.commitWork,
      Nh = C.commitLifeCycles,
      Oh = C.commitAttachRef,
      Ph = C.commitDetachRef,
      $f = a.scheduleDeferredCallback,
      Yi = a.useSyncScheduling,
      Ui = a.prepareForCommit,
      Vi = a.resetAfterCommit,
      O = T,
      Da = !1,
      Ab = !1,
      W = !1,
      pc = !1,
      I = null,
      z = T,
      u = null,
      na = null,
      ma = null,
      zb = null,
      Bb = !1,
      P = null,
      Ka = null,
      va = null,
      Ja = null,
      Ya = !1,
      Hd = !1,
      Id = !1,
      Xi = 1E3,
      oc = 0,
      nc = null;return { scheduleUpdate: D, getPriorityContext: B, batchedUpdates: function batchedUpdates(a, b) {
      var c = W;W = !0;try {
        return a(b);
      } finally {
        W = c, Da || W || p(U, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      var b = pc,
          c = W;pc = W;W = !1;try {
        return a();
      } finally {
        W = c, pc = b;
      }
    }, flushSync: function flushSync(a) {
      var b = W,
          c = O;W = !0;O = Og;try {
        return a();
      } finally {
        W = b, O = c, Da ? w("187") : void 0, p(U, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = O;O = Qg;try {
        return a();
      } finally {
        O = b;
      }
    } };
}function ih() {
  w("196");
}function jh(a) {
  if (!a) return da;a = Pa.get(a);return "number" === typeof a.tag ? ih(a) : a._processChildContext(a._context);
}jh._injectFiber = function (a) {
  ih = a;
};var kh = ud.addTopLevelUpdate,
    lh = R.findCurrentUnmaskedContext,
    mh = R.isContextProvider,
    nh = R.processChildContext,
    oh = E.HostComponent,
    ph = bb.findCurrentHostFiber,
    qh = bb.findCurrentHostFiberWithNoPortals;jh._injectFiber(function (a) {
  var b = lh(a);return mh(a) ? nh(a, b, !1) : b;
});var rh = F.TEXT_NODE;
function sh(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}function th(a, b) {
  var c = sh(a);a = 0;for (var d; c;) {
    if (c.nodeType === rh) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = sh(c);
  }
}var uh = null;function vh() {
  !uh && l.canUseDOM && (uh = "textContent" in document.documentElement ? "textContent" : "innerText");return uh;
}
var wh = { getOffsets: function getOffsets(a) {
    var b = window.getSelection && window.getSelection();if (!b || 0 === b.rangeCount) return null;var c = b.anchorNode,
        d = b.anchorOffset,
        e = b.focusNode,
        f = b.focusOffset,
        g = b.getRangeAt(0);try {
      g.startContainer.nodeType, g.endContainer.nodeType;
    } catch (k) {
      return null;
    }b = b.anchorNode === b.focusNode && b.anchorOffset === b.focusOffset ? 0 : g.toString().length;var h = g.cloneRange();h.selectNodeContents(a);h.setEnd(g.startContainer, g.startOffset);a = h.startContainer === h.endContainer && h.startOffset === h.endOffset ? 0 : h.toString().length;g = a + b;b = document.createRange();b.setStart(c, d);b.setEnd(e, f);c = b.collapsed;return { start: c ? g : a, end: c ? a : g };
  }, setOffsets: function setOffsets(a, b) {
    if (window.getSelection) {
      var c = window.getSelection(),
          d = a[vh()].length,
          e = Math.min(b.start, d);b = void 0 === b.end ? e : Math.min(b.end, d);!c.extend && e > b && (d = b, b = e, e = d);d = th(a, e);a = th(a, b);if (d && a) {
        var f = document.createRange();f.setStart(d.node, d.offset);c.removeAllRanges();e > b ? (c.addRange(f), c.extend(a.node, a.offset)) : (f.setEnd(a.node, a.offset), c.addRange(f));
      }
    }
  } },
    xh = F.ELEMENT_NODE,
    yh = { hasSelectionCapabilities: function hasSelectionCapabilities(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
  }, getSelectionInformation: function getSelectionInformation() {
    var a = ia();return { focusedElem: a, selectionRange: yh.hasSelectionCapabilities(a) ? yh.getSelection(a) : null };
  }, restoreSelection: function restoreSelection(a) {
    var b = ia(),
        c = a.focusedElem;a = a.selectionRange;if (b !== c && fa(document.documentElement, c)) {
      yh.hasSelectionCapabilities(c) && yh.setSelection(c, a);b = [];for (a = c; a = a.parentNode;) {
        a.nodeType === xh && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ha(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
  }, getSelection: function getSelection(a) {
    return ("selectionStart" in a ? { start: a.selectionStart, end: a.selectionEnd } : wh.getOffsets(a)) || { start: 0, end: 0 };
  }, setSelection: function setSelection(a, b) {
    var c = b.start,
        d = b.end;void 0 === d && (d = c);"selectionStart" in a ? (a.selectionStart = c, a.selectionEnd = Math.min(d, a.value.length)) : wh.setOffsets(a, b);
  } },
    zh = yh,
    Ah = F.ELEMENT_NODE;function Bh() {
  w("211");
}function Ch() {
  w("212");
}function Dh(a) {
  if (null == a) return null;if (a.nodeType === Ah) return a;var b = Pa.get(a);if (b) return "number" === typeof b.tag ? Bh(b) : Ch(b);"function" === typeof a.render ? w("188") : w("213", Object.keys(a));
}Dh._injectFiber = function (a) {
  Bh = a;
};Dh._injectStack = function (a) {
  Ch = a;
};var Eh = E.HostComponent;function Fh(a) {
  if (void 0 !== a._hostParent) return a._hostParent;if ("number" === typeof a.tag) {
    do {
      a = a["return"];
    } while (a && a.tag !== Eh);if (a) return a;
  }return null;
}
function Gh(a, b) {
  for (var c = 0, d = a; d; d = Fh(d)) {
    c++;
  }d = 0;for (var e = b; e; e = Fh(e)) {
    d++;
  }for (; 0 < c - d;) {
    a = Fh(a), c--;
  }for (; 0 < d - c;) {
    b = Fh(b), d--;
  }for (; c--;) {
    if (a === b || a === b.alternate) return a;a = Fh(a);b = Fh(b);
  }return null;
}
var Hh = { isAncestor: function isAncestor(a, b) {
    for (; b;) {
      if (a === b || a === b.alternate) return !0;b = Fh(b);
    }return !1;
  }, getLowestCommonAncestor: Gh, getParentInstance: function getParentInstance(a) {
    return Fh(a);
  }, traverseTwoPhase: function traverseTwoPhase(a, b, c) {
    for (var d = []; a;) {
      d.push(a), a = Fh(a);
    }for (a = d.length; 0 < a--;) {
      b(d[a], "captured", c);
    }for (a = 0; a < d.length; a++) {
      b(d[a], "bubbled", c);
    }
  }, traverseEnterLeave: function traverseEnterLeave(a, b, c, d, e) {
    for (var f = a && b ? Gh(a, b) : null, g = []; a && a !== f;) {
      g.push(a), a = Fh(a);
    }for (a = []; b && b !== f;) {
      a.push(b), b = Fh(b);
    }for (b = 0; b < g.length; b++) {
      c(g[b], "bubbled", d);
    }for (b = a.length; 0 < b--;) {
      c(a[b], "captured", e);
    }
  } },
    Ih = Jb.getListener;function Jh(a, b, c) {
  if (b = Ih(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = Cb(c._dispatchListeners, b), c._dispatchInstances = Cb(c._dispatchInstances, a);
}function Kh(a) {
  a && a.dispatchConfig.phasedRegistrationNames && Hh.traverseTwoPhase(a._targetInst, Jh, a);
}function Qh(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? Hh.getParentInstance(b) : null;Hh.traverseTwoPhase(b, Jh, a);
  }
}
function Rh(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = Ih(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = Cb(c._dispatchListeners, b), c._dispatchInstances = Cb(c._dispatchInstances, a));
}function Sh(a) {
  a && a.dispatchConfig.registrationName && Rh(a._targetInst, null, a);
}
var Th = { accumulateTwoPhaseDispatches: function accumulateTwoPhaseDispatches(a) {
    Db(a, Kh);
  }, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    Db(a, Qh);
  }, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    Db(a, Sh);
  }, accumulateEnterLeaveDispatches: function accumulateEnterLeaveDispatches(a, b, c, d) {
    Hh.traverseEnterLeave(c, d, Rh, a, b);
  } },
    X = { _root: null, _startText: null, _fallbackText: null },
    Uh = { initialize: function initialize(a) {
    X._root = a;X._startText = Uh.getText();return !0;
  }, reset: function reset() {
    X._root = null;X._startText = null;X._fallbackText = null;
  }, getData: function getData() {
    if (X._fallbackText) return X._fallbackText;
    var a,
        b = X._startText,
        c = b.length,
        d,
        e = Uh.getText(),
        f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}X._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return X._fallbackText;
  }, getText: function getText() {
    return "value" in X._root ? X._root.value : X._root[vh()];
  } },
    Vh = Uh,
    Wh = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Xh = { type: null, target: null, currentTarget: ca.thatReturnsNull, eventPhase: null, bubbles: null,
  cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function Y(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? ca.thatReturnsTrue : ca.thatReturnsFalse;this.isPropagationStopped = ca.thatReturnsFalse;return this;
}
n(Y.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = ca.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = ca.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = ca.thatReturnsTrue;
  }, isPersistent: ca.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Wh.length; a++) {
      this[Wh[a]] = null;
    }
  } });Y.Interface = Xh;Y.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();n(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = n({}, this.Interface, b);a.augmentClass = this.augmentClass;Yh(a);
};Yh(Y);function Zh(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function $h(a) {
  a instanceof this ? void 0 : w("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Yh(a) {
  a.eventPool = [];a.getPooled = Zh;a.release = $h;
}function ai(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(ai, { data: null });function bi(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(bi, { data: null });var ci = [9, 13, 27, 32],
    di = l.canUseDOM && "CompositionEvent" in window,
    ei = null;l.canUseDOM && "documentMode" in document && (ei = document.documentMode);var fi;
if (fi = l.canUseDOM && "TextEvent" in window && !ei) {
  var gi = window.opera;fi = !("object" === (typeof gi === "undefined" ? "undefined" : _typeof(gi)) && "function" === typeof gi.version && 12 >= parseInt(gi.version(), 10));
}
var hi = fi,
    ii = l.canUseDOM && (!di || ei && 8 < ei && 11 >= ei),
    ji = String.fromCharCode(32),
    ki = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    li = !1;
function mi(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== ci.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function ni(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var oi = !1;function pi(a, b) {
  switch (a) {case "topCompositionEnd":
      return ni(b);case "topKeyPress":
      if (32 !== b.which) return null;li = !0;return ji;case "topTextInput":
      return a = b.data, a === ji && li ? null : a;default:
      return null;}
}
function qi(a, b) {
  if (oi) return "topCompositionEnd" === a || !di && mi(a, b) ? (a = Vh.getData(), Vh.reset(), oi = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return ii ? null : b.data;default:
      return null;}
}
var ri = { eventTypes: ki, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (di) b: {
      switch (a) {case "topCompositionStart":
          var f = ki.compositionStart;break b;case "topCompositionEnd":
          f = ki.compositionEnd;break b;case "topCompositionUpdate":
          f = ki.compositionUpdate;break b;}f = void 0;
    } else oi ? mi(a, c) && (f = ki.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = ki.compositionStart);f ? (ii && (oi || f !== ki.compositionStart ? f === ki.compositionEnd && oi && (e = Vh.getData()) : oi = Vh.initialize(d)), f = ai.getPooled(f, b, c, d), e ? f.data = e : (e = ni(c), null !== e && (f.data = e)), Th.accumulateTwoPhaseDispatches(f), e = f) : e = null;(a = hi ? pi(a, c) : qi(a, c)) ? (b = bi.getPooled(ki.beforeInput, b, c, d), b.data = a, Th.accumulateTwoPhaseDispatches(b)) : b = null;return [e, b];
  } },
    si = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };function ti(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!si[a.type] : "textarea" === b ? !0 : !1;
}
var ui = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };function vi(a, b, c) {
  a = Y.getPooled(ui.change, a, b, c);a.type = "change";nb.enqueueStateRestore(c);Th.accumulateTwoPhaseDispatches(a);return a;
}var wi = null,
    xi = null;function yi(a) {
  Jb.enqueueEvents(a);Jb.processEventQueue(!1);
}
function zi(a) {
  var b = G.getNodeFromInstance(a);if (Bc.updateValueIfChanged(b)) return a;
}function Ai(a, b) {
  if ("topChange" === a) return b;
}var Bi = !1;l.canUseDOM && (Bi = Lb("input") && (!document.documentMode || 9 < document.documentMode));function Ci() {
  wi && (wi.detachEvent("onpropertychange", Di), xi = wi = null);
}function Di(a) {
  "value" === a.propertyName && zi(xi) && (a = vi(xi, a, ub(a)), sb.batchedUpdates(yi, a));
}function Ei(a, b, c) {
  "topFocus" === a ? (Ci(), wi = b, xi = c, wi.attachEvent("onpropertychange", Di)) : "topBlur" === a && Ci();
}
function Fi(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return zi(xi);
}function Gi(a, b) {
  if ("topClick" === a) return zi(b);
}function Hi(a, b) {
  if ("topInput" === a || "topChange" === a) return zi(b);
}
var Ii = { eventTypes: ui, _isInputEventSupported: Bi, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? G.getNodeFromInstance(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Ai;else if (ti(e)) {
      if (Bi) g = Hi;else {
        g = Fi;var h = Ei;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Gi);if (g && (g = g(a, b))) return vi(g, c, d);h && h(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function Ji(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(Ji, { view: function view(a) {
    if (a.view) return a.view;a = ub(a);return a.window === a ? a : (a = a.ownerDocument) ? a.defaultView || a.parentWindow : window;
  }, detail: function detail(a) {
    return a.detail || 0;
  } });var Ki = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function Li(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = Ki[a]) ? !!b[a] : !1;
}function Mi() {
  return Li;
}
function Ni(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Ji.augmentClass(Ni, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Mi, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var Oi = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    Pi = { eventTypes: Oi, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? G.getClosestInstanceFromNode(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : G.getNodeFromInstance(a);e = null == b ? e : G.getNodeFromInstance(b);var g = Ni.getPooled(Oi.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = Ni.getPooled(Oi.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Th.accumulateEnterLeaveDispatches(g, c, a, b);return [g, c];
  } },
    Qi = F.DOCUMENT_NODE,
    Ri = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Si = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" },
    dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Ti = null,
    Zi = null,
    $i = null,
    aj = !1,
    bj = M.isListeningToAllDependencies;
function cj(a, b) {
  if (aj || null == Ti || Ti !== ia()) return null;var c = Ti;"selectionStart" in c && zh.hasSelectionCapabilities(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return $i && ea($i, c) ? null : ($i = c, a = Y.getPooled(Si.select, Zi, a, b), a.type = "select", a.target = Ti, Th.accumulateTwoPhaseDispatches(a), a);
}
var dj = { eventTypes: Si, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : d.nodeType === Qi ? d : d.ownerDocument;if (!e || !bj("onSelect", e)) return null;e = b ? G.getNodeFromInstance(b) : window;switch (a) {case "topFocus":
        if (ti(e) || "true" === e.contentEditable) Ti = e, Zi = b, $i = null;break;case "topBlur":
        $i = Zi = Ti = null;break;case "topMouseDown":
        aj = !0;break;case "topContextMenu":case "topMouseUp":
        return aj = !1, cj(c, d);case "topSelectionChange":
        if (Ri) break;case "topKeyDown":case "topKeyUp":
        return cj(c, d);}return null;
  } };
function ej(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(ej, { animationName: null, elapsedTime: null, pseudoElement: null });function fj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(fj, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function gj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Ji.augmentClass(gj, { relatedTarget: null });function hj(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var ij = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    jj = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function kj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}
Ji.augmentClass(kj, { key: function key(a) {
    if (a.key) {
      var b = ij[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = hj(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? jj[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Mi, charCode: function charCode(a) {
    return "keypress" === a.type ? hj(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? hj(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function lj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Ni.augmentClass(lj, { dataTransfer: null });function mj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Ji.augmentClass(mj, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Mi });function nj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Y.augmentClass(nj, { propertyName: null, elapsedTime: null, pseudoElement: null });
function oj(a, b, c, d) {
  return Y.call(this, a, b, c, d);
}Ni.augmentClass(oj, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var pj = {},
    qj = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };pj[a] = c;qj[b] = c;
});
var rj = { eventTypes: pj, extractEvents: function extractEvents(a, b, c, d) {
    var e = qj[a];if (!e) return null;switch (a) {case "topAbort":case "topCancel":case "topCanPlay":case "topCanPlayThrough":case "topClose":case "topDurationChange":case "topEmptied":case "topEncrypted":case "topEnded":case "topError":case "topInput":case "topInvalid":case "topLoad":case "topLoadedData":case "topLoadedMetadata":case "topLoadStart":case "topPause":case "topPlay":case "topPlaying":case "topProgress":case "topRateChange":case "topReset":case "topSeeked":case "topSeeking":case "topStalled":case "topSubmit":case "topSuspend":case "topTimeUpdate":case "topToggle":case "topVolumeChange":case "topWaiting":
        var f = Y;
        break;case "topKeyPress":
        if (0 === hj(c)) return null;case "topKeyDown":case "topKeyUp":
        f = kj;break;case "topBlur":case "topFocus":
        f = gj;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        f = Ni;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        f = lj;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        f = mj;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        f = ej;break;case "topTransitionEnd":
        f = nj;break;case "topScroll":
        f = Ji;break;case "topWheel":
        f = oj;break;case "topCopy":case "topCut":case "topPaste":
        f = fj;}f ? void 0 : w("86", a);a = f.getPooled(e, b, c, d);Th.accumulateTwoPhaseDispatches(a);return a;
  } };L.setHandleTopLevel(M.handleTopLevel);Jb.injection.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
ib.injection.injectComponentTree(G);Jb.injection.injectEventPluginsByName({ SimpleEventPlugin: rj, EnterLeaveEventPlugin: Pi, ChangeEventPlugin: Ii, SelectEventPlugin: dj, BeforeInputEventPlugin: ri });
var sj = A.injection.MUST_USE_PROPERTY,
    Z = A.injection.HAS_BOOLEAN_VALUE,
    tj = A.injection.HAS_NUMERIC_VALUE,
    uj = A.injection.HAS_POSITIVE_NUMERIC_VALUE,
    vj = A.injection.HAS_STRING_BOOLEAN_VALUE,
    wj = { Properties: { allowFullScreen: Z, allowTransparency: vj, async: Z, autoPlay: Z, capture: Z, checked: sj | Z, cols: uj, contentEditable: vj, controls: Z, "default": Z, defer: Z, disabled: Z, download: A.injection.HAS_OVERLOADED_BOOLEAN_VALUE, draggable: vj, formNoValidate: Z, hidden: Z, loop: Z, multiple: sj | Z, muted: sj | Z, noValidate: Z, open: Z, playsInline: Z,
    readOnly: Z, required: Z, reversed: Z, rows: uj, rowSpan: tj, scoped: Z, seamless: Z, selected: sj | Z, size: uj, start: tj, span: uj, spellCheck: vj, style: 0, itemScope: Z, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: vj }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    xj = A.injection.HAS_STRING_BOOLEAN_VALUE,
    yj = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    zj = { Properties: { autoReverse: xj, externalResourcesRequired: xj, preserveAlpha: xj }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: yj.xlink, xlinkArcrole: yj.xlink, xlinkHref: yj.xlink, xlinkRole: yj.xlink,
    xlinkShow: yj.xlink, xlinkTitle: yj.xlink, xlinkType: yj.xlink, xmlBase: yj.xml, xmlLang: yj.xml, xmlSpace: yj.xml } },
    Aj = /[\-\:]([a-z])/g;function Bj(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Aj, Bj);zj.Properties[b] = 0;zj.DOMAttributeNames[b] = a;
});A.injection.injectDOMPropertyConfig(wj);A.injection.injectDOMPropertyConfig(zj);
var Cj = ig.injectInternals,
    Dj = F.ELEMENT_NODE,
    Ej = F.TEXT_NODE,
    Fj = F.COMMENT_NODE,
    Gj = F.DOCUMENT_NODE,
    Hj = F.DOCUMENT_FRAGMENT_NODE,
    Ij = A.ROOT_ATTRIBUTE_NAME,
    Jj = ka.getChildNamespace,
    Kj = N.createElement,
    Lj = N.createTextNode,
    Mj = N.setInitialProperties,
    Nj = N.diffProperties,
    Oj = N.updateProperties,
    Pj = N.diffHydratedProperties,
    Qj = N.diffHydratedText,
    Rj = N.warnForDeletedHydratableElement,
    Sj = N.warnForDeletedHydratableText,
    Tj = N.warnForInsertedHydratedElement,
    Uj = N.warnForInsertedHydratedText,
    Vj = G.precacheFiberNode,
    Wj = G.updateFiberProps;
nb.injection.injectFiberControlledHostComponent(N);Dh._injectFiber(function (a) {
  return Xj.findHostInstance(a);
});var Yj = null,
    Zj = null;function ak(a) {
  return !(!a || a.nodeType !== Dj && a.nodeType !== Gj && a.nodeType !== Hj && (a.nodeType !== Fj || " react-mount-point-unstable " !== a.nodeValue));
}function bk(a) {
  a = a ? a.nodeType === Gj ? a.documentElement : a.firstChild : null;return !(!a || a.nodeType !== Dj || !a.hasAttribute(Ij));
}
var Xj = function (a) {
  var b = a.getPublicInstance;a = hh(a);var c = a.scheduleUpdate,
      d = a.getPriorityContext;return { createContainer: function createContainer(a) {
      var b = ee();a = { current: b, containerInfo: a, isScheduled: !1, nextScheduledRoot: null, context: null, pendingContext: null };return b.stateNode = a;
    }, updateContainer: function updateContainer(a, b, g, h) {
      var e = b.current;g = jh(g);null === b.context ? b.context = g : b.pendingContext = g;b = h;h = d(e, ed.enableAsyncSubtreeAPI && null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent);
      a = { element: a };kh(e, a, void 0 === b ? null : b, h);c(e, h);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case oh:
          return b(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: function findHostInstance(a) {
      a = ph(a);return null === a ? null : a.stateNode;
    }, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = qh(a);return null === a ? null : a.stateNode;
    } };
}({ getRootHostContext: function getRootHostContext(a) {
    if (a.nodeType === Gj) a = (a = a.documentElement) ? a.namespaceURI : Jj(null, "");else {
      var b = a.nodeType === Fj ? a.parentNode : a;a = b.namespaceURI || null;b = b.tagName;a = Jj(a, b);
    }return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return Jj(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    Yj = M.isEnabled();Zj = zh.getSelectionInformation();M.setEnabled(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    zh.restoreSelection(Zj);Zj = null;M.setEnabled(Yj);Yj = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = Kj(a, b, c, d);Vj(e, a);Wj(a, b);return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    Mj(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return Nj(a, b, c, d, e);
  }, commitMount: function commitMount(a) {
    a.focus();
  }, commitUpdate: function commitUpdate(a, b, c, d, e) {
    Wj(a, e);Oj(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, resetTextContent: function resetTextContent(a) {
    a.textContent = "";
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = Lj(a, b);Vj(d, a);return a;
  }, commitTextUpdate: function commitTextUpdate(a, b, c) {
    a.nodeValue = c;
  }, appendChild: function appendChild(a, b) {
    a.appendChild(b);
  }, appendChildToContainer: function appendChildToContainer(a, b) {
    a.nodeType === Fj ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
  }, insertBefore: function insertBefore(a, b, c) {
    a.insertBefore(b, c);
  }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
    a.nodeType === Fj ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
  }, removeChild: function removeChild(a, b) {
    a.removeChild(b);
  }, removeChildFromContainer: function removeChildFromContainer(a, b) {
    a.nodeType === Fj ? a.parentNode.removeChild(b) : a.removeChild(b);
  }, canHydrateInstance: function canHydrateInstance(a, b) {
    return a.nodeType === Dj && b === a.nodeName.toLowerCase();
  }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
    return "" === b ? !1 : a.nodeType === Ej;
  }, getNextHydratableSibling: function getNextHydratableSibling(a) {
    for (a = a.nextSibling; a && a.nodeType !== Dj && a.nodeType !== Ej;) {
      a = a.nextSibling;
    }return a;
  }, getFirstHydratableChild: function getFirstHydratableChild(a) {
    for (a = a.firstChild; a && a.nodeType !== Dj && a.nodeType !== Ej;) {
      a = a.nextSibling;
    }return a;
  }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
    Vj(f, a);Wj(a, c);return Pj(a, b, c, e, d);
  }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
    Vj(c, a);return Qj(a, b);
  }, didNotHydrateInstance: function didNotHydrateInstance(a, b) {
    1 === b.nodeType ? Rj(a, b) : Sj(a, b);
  }, didNotFindHydratableInstance: function didNotFindHydratableInstance(a, b, c) {
    Tj(a, b, c);
  }, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance(a, b) {
    Uj(a, b);
  }, scheduleDeferredCallback: dd.rIC, useSyncScheduling: !0 });sb.injection.injectFiberBatchedUpdates(Xj.batchedUpdates);
function ck(a, b, c, d, e) {
  ak(c) ? void 0 : w("200");var f = c._reactRootContainer;if (f) Xj.updateContainer(b, f, a, e);else {
    if (!d && !bk(c)) for (d = void 0; d = c.lastChild;) {
      c.removeChild(d);
    }var g = Xj.createContainer(c);f = c._reactRootContainer = g;Xj.unbatchedUpdates(function () {
      Xj.updateContainer(b, g, a, e);
    });
  }return Xj.getPublicRootInstance(f);
}function dk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;ak(b) ? void 0 : w("200");return ne.createPortal(a, b, null, c);
}
var ek = { createPortal: dk, hydrate: function hydrate(a, b, c) {
    return ck(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return ck(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null != a && Pa.has(a) ? void 0 : w("38");return ck(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    ak(a) ? void 0 : w("40");return a._reactRootContainer ? (Xj.unbatchedUpdates(function () {
      ck(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, findDOMNode: Dh, unstable_createPortal: dk, unstable_batchedUpdates: sb.batchedUpdates,
  unstable_deferredUpdates: Xj.deferredUpdates, flushSync: Xj.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: Jb, EventPluginRegistry: sa, EventPropagators: Th, ReactControlledComponent: nb, ReactDOMComponentTree: G, ReactDOMEventListener: L } };Cj({ findFiberByHostInstance: G.getClosestInstanceFromNode, findHostInstanceByFiber: Xj.findHostInstance, bundleType: 0, version: "16.0.0", rendererPackageName: "react-dom" });module.exports = ek;

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 React v16.0.0
 react.production.min.js

 Copyright (c) 2013-present, Facebook, Inc.

 This source code is licensed under the MIT license found in the
 LICENSE file in the root directory of this source tree.
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var f = __webpack_require__(20),
    p = __webpack_require__(219);__webpack_require__(220);var r = __webpack_require__(135);
function t(a) {
  for (var b = arguments.length - 1, d = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, e = 0; e < b; e++) {
    d += "\x26args[]\x3d" + encodeURIComponent(arguments[e + 1]);
  }b = Error(d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var u = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function v(a, b, d) {
  this.props = a;this.context = b;this.refs = p;this.updater = d || u;
}v.prototype.isReactComponent = {};v.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? t("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};v.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function w(a, b, d) {
  this.props = a;this.context = b;this.refs = p;this.updater = d || u;
}function x() {}x.prototype = v.prototype;var y = w.prototype = new x();y.constructor = w;f(y, v.prototype);y.isPureReactComponent = !0;function z(a, b, d) {
  this.props = a;this.context = b;this.refs = p;this.updater = d || u;
}var A = z.prototype = new x();A.constructor = z;f(A, v.prototype);A.unstable_isAsyncReactComponent = !0;A.render = function () {
  return this.props.children;
};
var B = { Component: v, PureComponent: w, AsyncComponent: z },
    C = { current: null },
    D = Object.prototype.hasOwnProperty,
    E = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    F = { key: !0, ref: !0, __self: !0, __source: !0 };function G(a, b, d, e, c, g, k) {
  return { $$typeof: E, type: a, key: b, ref: d, props: k, _owner: g };
}
G.createElement = function (a, b, d) {
  var e,
      c = {},
      g = null,
      k = null,
      m = null,
      q = null;if (null != b) for (e in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), m = void 0 === b.__self ? null : b.__self, q = void 0 === b.__source ? null : b.__source, b) {
    D.call(b, e) && !F.hasOwnProperty(e) && (c[e] = b[e]);
  }var l = arguments.length - 2;if (1 === l) c.children = d;else if (1 < l) {
    for (var h = Array(l), n = 0; n < l; n++) {
      h[n] = arguments[n + 2];
    }c.children = h;
  }if (a && a.defaultProps) for (e in l = a.defaultProps, l) {
    void 0 === c[e] && (c[e] = l[e]);
  }return G(a, g, k, m, q, C.current, c);
};
G.createFactory = function (a) {
  var b = G.createElement.bind(null, a);b.type = a;return b;
};G.cloneAndReplaceKey = function (a, b) {
  return G(a.type, b, a.ref, a._self, a._source, a._owner, a.props);
};
G.cloneElement = function (a, b, d) {
  var e = f({}, a.props),
      c = a.key,
      g = a.ref,
      k = a._self,
      m = a._source,
      q = a._owner;if (null != b) {
    void 0 !== b.ref && (g = b.ref, q = C.current);void 0 !== b.key && (c = "" + b.key);if (a.type && a.type.defaultProps) var l = a.type.defaultProps;for (h in b) {
      D.call(b, h) && !F.hasOwnProperty(h) && (e[h] = void 0 === b[h] && void 0 !== l ? l[h] : b[h]);
    }
  }var h = arguments.length - 2;if (1 === h) e.children = d;else if (1 < h) {
    l = Array(h);for (var n = 0; n < h; n++) {
      l[n] = arguments[n + 2];
    }e.children = l;
  }return G(a.type, c, g, k, m, q, e);
};
G.isValidElement = function (a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === E;
};var H = "function" === typeof Symbol && Symbol.iterator,
    I = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var J = /\/+/g,
    K = [];
function L(a, b, d, e) {
  if (K.length) {
    var c = K.pop();c.result = a;c.keyPrefix = b;c.func = d;c.context = e;c.count = 0;return c;
  }return { result: a, keyPrefix: b, func: d, context: e, count: 0 };
}function M(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > K.length && K.push(a);
}
function N(a, b, d, e) {
  var c = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === c || "boolean" === c) a = null;if (null === a || "string" === c || "number" === c || "object" === c && a.$$typeof === I) return d(e, a, "" === b ? "." + O(a, 0) : b), 1;var g = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    c = a[k];var m = b + O(c, k);g += N(c, m, d, e);
  } else if (m = H && a[H] || a["@@iterator"], "function" === typeof m) for (a = m.call(a), k = 0; !(c = a.next()).done;) {
    c = c.value, m = b + O(c, k++), g += N(c, m, d, e);
  } else "object" === c && (d = "" + a, t("31", "[object Object]" === d ? "object with keys {" + Object.keys(a).join(", ") + "}" : d, ""));return g;
}function O(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function P(a, b) {
  a.func.call(a.context, b, a.count++);
}function Q(a, b, d) {
  var e = a.result,
      c = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? R(a, e, d, r.thatReturnsArgument) : null != a && (G.isValidElement(a) && (a = G.cloneAndReplaceKey(a, c + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(J, "$\x26/") + "/") + d)), e.push(a));
}
function R(a, b, d, e, c) {
  var g = "";null != d && (g = ("" + d).replace(J, "$\x26/") + "/");b = L(b, g, e, c);null == a || N(a, "", Q, b);M(b);
}var S = { forEach: function forEach(a, b, d) {
    if (null == a) return a;b = L(null, null, b, d);null == a || N(a, "", P, b);M(b);
  }, map: function map(a, b, d) {
    if (null == a) return a;var e = [];R(a, e, null, b, d);return e;
  }, count: function count(a) {
    return null == a ? 0 : N(a, "", r.thatReturnsNull, null);
  }, toArray: function toArray(a) {
    var b = [];R(a, b, null, r.thatReturnsArgument);return b;
  } };
module.exports = { Children: { map: S.map, forEach: S.forEach, count: S.count, toArray: S.toArray, only: function only(a) {
      G.isValidElement(a) ? void 0 : t("143");return a;
    } }, Component: B.Component, PureComponent: B.PureComponent, unstable_AsyncComponent: B.AsyncComponent, createElement: G.createElement, cloneElement: G.cloneElement, isValidElement: G.isValidElement, createFactory: G.createFactory, version: "16.0.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: C, assign: f } };

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;
//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;
//# sourceMappingURL=Notification.js.map

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler = function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
    };
    return Scheduler;
}();
exports.Scheduler = Scheduler;
//# sourceMappingURL=Scheduler.js.map

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var defer_1 = __webpack_require__(704);
Observable_1.Observable.defer = defer_1.defer;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var empty_1 = __webpack_require__(705);
Observable_1.Observable.empty = empty_1.empty;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var from_1 = __webpack_require__(706);
Observable_1.Observable.from = from_1.from;
//# sourceMappingURL=from.js.map

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var fromEvent_1 = __webpack_require__(707);
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var fromPromise_1 = __webpack_require__(708);
Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var merge_1 = __webpack_require__(710);
Observable_1.Observable.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var never_1 = __webpack_require__(711);
Observable_1.Observable.never = never_1.never;
//# sourceMappingURL=never.js.map

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var of_1 = __webpack_require__(712);
Observable_1.Observable.of = of_1.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var throw_1 = __webpack_require__(713);
Observable_1.Observable.throw = throw_1._throw;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var timer_1 = __webpack_require__(714);
Observable_1.Observable.timer = timer_1.timer;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var concatAll_1 = __webpack_require__(717);
Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var concatMap_1 = __webpack_require__(718);
Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var debounceTime_1 = __webpack_require__(719);
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var finally_1 = __webpack_require__(723);
Observable_1.Observable.prototype.finally = finally_1._finally;
Observable_1.Observable.prototype._finally = finally_1._finally;
//# sourceMappingURL=finally.js.map

/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var ignoreElements_1 = __webpack_require__(724);
Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var mapTo_1 = __webpack_require__(726);
Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var merge_1 = __webpack_require__(341);
Observable_1.Observable.prototype.merge = merge_1.merge;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 686 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var multicast_1 = __webpack_require__(139);
Observable_1.Observable.prototype.multicast = multicast_1.multicast;
//# sourceMappingURL=multicast.js.map

/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var pairwise_1 = __webpack_require__(727);
Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var publish_1 = __webpack_require__(728);
Observable_1.Observable.prototype.publish = publish_1.publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var scan_1 = __webpack_require__(729);
Observable_1.Observable.prototype.scan = scan_1.scan;
//# sourceMappingURL=scan.js.map

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var share_1 = __webpack_require__(730);
Observable_1.Observable.prototype.share = share_1.share;
//# sourceMappingURL=share.js.map

/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var switchMapTo_1 = __webpack_require__(734);
Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Observable_1 = __webpack_require__(2);
var timeout_1 = __webpack_require__(737);
Observable_1.Observable.prototype.timeout = timeout_1.timeout;
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var ScalarObservable_1 = __webpack_require__(137);
var EmptyObservable_1 = __webpack_require__(79);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = function (_super) {
    __extends(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1.EmptyObservable();
        } else if (length === 1) {
            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        } else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike,
            index = state.index,
            length = state.length,
            subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            arrayLike = _a.arrayLike,
            scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1.Observable);
exports.ArrayLikeObservable = ArrayLikeObservable;
//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = __webpack_require__(18);
var Observable_1 = __webpack_require__(2);
var Subscriber_1 = __webpack_require__(16);
var Subscription_1 = __webpack_require__(50);
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=ConnectableObservable.js.map

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var subscribeToResult_1 = __webpack_require__(52);
var OuterSubscriber_1 = __webpack_require__(49);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable);
exports.DeferObservable = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
//# sourceMappingURL=DeferObservable.js.map

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable);
exports.ErrorObservable = ErrorObservable;
//# sourceMappingURL=ErrorObservable.js.map

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var tryCatch_1 = __webpack_require__(145);
var isFunction_1 = __webpack_require__(144);
var errorObject_1 = __webpack_require__(103);
var Subscription_1 = __webpack_require__(50);
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function unsubscribe() {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;
//# sourceMappingURL=FromEventObservable.js.map

/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = __webpack_require__(80);
var isArrayLike_1 = __webpack_require__(347);
var isPromise_1 = __webpack_require__(351);
var PromiseObservable_1 = __webpack_require__(339);
var IteratorObservable_1 = __webpack_require__(700);
var ArrayObservable_1 = __webpack_require__(66);
var ArrayLikeObservable_1 = __webpack_require__(693);
var iterator_1 = __webpack_require__(140);
var Observable_1 = __webpack_require__(2);
var observeOn_1 = __webpack_require__(343);
var observable_1 = __webpack_require__(141);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = function (_super) {
    __extends(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1.observable] === 'function') {
                if (ish instanceof Observable_1.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            } else if (isArray_1.isArray(ish)) {
                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
            } else if (isPromise_1.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            } else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            } else if (isArrayLike_1.isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && (typeof ish === 'undefined' ? 'undefined' : _typeof(ish)) || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1.observable]().subscribe(subscriber);
        } else {
            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1.Observable);
exports.FromObservable = FromObservable;
//# sourceMappingURL=FromObservable.js.map

/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(349);
var Observable_1 = __webpack_require__(2);
var async_1 = __webpack_require__(102);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IntervalObservable = function (_super) {
    __extends(IntervalObservable, _super);
    function IntervalObservable(period, scheduler) {
        if (period === void 0) {
            period = 0;
        }
        if (scheduler === void 0) {
            scheduler = async_1.async;
        }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = async_1.async;
        }
    }
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified IScheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` IScheduler to provide a notion of time, but you may pass any
     * IScheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    IntervalObservable.create = function (period, scheduler) {
        if (period === void 0) {
            period = 0;
        }
        if (scheduler === void 0) {
            scheduler = async_1.async;
        }
        return new IntervalObservable(period, scheduler);
    };
    IntervalObservable.dispatch = function (state) {
        var index = state.index,
            subscriber = state.subscriber,
            period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };
    IntervalObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };
    return IntervalObservable;
}(Observable_1.Observable);
exports.IntervalObservable = IntervalObservable;
//# sourceMappingURL=IntervalObservable.js.map

/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = __webpack_require__(51);
var Observable_1 = __webpack_require__(2);
var iterator_1 = __webpack_require__(140);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = function (_super) {
    __extends(IteratorObservable, _super);
    function IteratorObservable(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator);
    }
    IteratorObservable.create = function (iterator, scheduler) {
        return new IteratorObservable(iterator, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index,
            hasError = state.hasError,
            iterator = state.iterator,
            subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator.return === 'function') {
                iterator.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            iterator = _a.iterator,
            scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator, subscriber: subscriber
            });
        } else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                } else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator.return === 'function') {
                        iterator.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1.Observable);
exports.IteratorObservable = IteratorObservable;
var StringIterator = function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = str.length;
        }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}();
var ArrayIterator = function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = toLength(arr);
        }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}();
function getIterator(obj) {
    var i = obj[iterator_1.iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1.iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
//# sourceMappingURL=IteratorObservable.js.map

/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = __webpack_require__(2);
var noop_1 = __webpack_require__(352);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var NeverObservable = function (_super) {
    __extends(NeverObservable, _super);
    function NeverObservable() {
        _super.call(this);
    }
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please note
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.noop();
    };
    return NeverObservable;
}(Observable_1.Observable);
exports.NeverObservable = NeverObservable;
//# sourceMappingURL=NeverObservable.js.map

/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = __webpack_require__(349);
var Observable_1 = __webpack_require__(2);
var async_1 = __webpack_require__(102);
var isScheduler_1 = __webpack_require__(72);
var isDate_1 = __webpack_require__(348);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;
//# sourceMappingURL=TimerObservable.js.map

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isScheduler_1 = __webpack_require__(72);
var isArray_1 = __webpack_require__(80);
var ArrayObservable_1 = __webpack_require__(66);
var combineLatest_1 = __webpack_require__(716);
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DeferObservable_1 = __webpack_require__(695);
exports.defer = DeferObservable_1.DeferObservable.create;
//# sourceMappingURL=defer.js.map

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EmptyObservable_1 = __webpack_require__(79);
exports.empty = EmptyObservable_1.EmptyObservable.create;
//# sourceMappingURL=empty.js.map

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FromObservable_1 = __webpack_require__(698);
exports.from = FromObservable_1.FromObservable.create;
//# sourceMappingURL=from.js.map

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FromEventObservable_1 = __webpack_require__(697);
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
//# sourceMappingURL=fromEvent.js.map

/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var PromiseObservable_1 = __webpack_require__(339);
exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
//# sourceMappingURL=fromPromise.js.map

/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IntervalObservable_1 = __webpack_require__(699);
exports.interval = IntervalObservable_1.IntervalObservable.create;
//# sourceMappingURL=interval.js.map

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var merge_1 = __webpack_require__(341);
exports.merge = merge_1.mergeStatic;
//# sourceMappingURL=merge.js.map

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var NeverObservable_1 = __webpack_require__(701);
exports.never = NeverObservable_1.NeverObservable.create;
//# sourceMappingURL=never.js.map

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayObservable_1 = __webpack_require__(66);
exports.of = ArrayObservable_1.ArrayObservable.of;
//# sourceMappingURL=of.js.map

/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ErrorObservable_1 = __webpack_require__(696);
exports._throw = ErrorObservable_1.ErrorObservable.create;
//# sourceMappingURL=throw.js.map

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TimerObservable_1 = __webpack_require__(702);
exports.timer = TimerObservable_1.TimerObservable.create;
//# sourceMappingURL=timer.js.map

/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
//# sourceMappingURL=catch.js.map

/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = __webpack_require__(66);
var isArray_1 = __webpack_require__(80);
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
var none = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    observables.unshift(this);
    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}();
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        } else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            } else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.CombineLatestSubscriber = CombineLatestSubscriber;
//# sourceMappingURL=combineLatest.js.map

/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mergeAll_1 = __webpack_require__(138);
/* tslint:enable:max-line-length */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
  return this.lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mergeMap_1 = __webpack_require__(342);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
  return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map

/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var async_1 = __webpack_require__(102);
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var tryCatch_1 = __webpack_require__(145);
var errorObject_1 = __webpack_require__(103);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=distinctUntilChanged.js.map

/***/ }),
/* 721 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=do.js.map

/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=filter.js.map

/***/ }),
/* 723 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var Subscription_1 = __webpack_require__(50);
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}
exports._finally = _finally;
var FinallyOperator = function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=finally.js.map

/***/ }),
/* 724 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var noop_1 = __webpack_require__(352);
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements() {
    return this.lift(new IgnoreElementsOperator());
}
exports.ignoreElements = ignoreElements;
;
var IgnoreElementsOperator = function () {
    function IgnoreElementsOperator() {}
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=ignoreElements.js.map

/***/ }),
/* 725 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=map.js.map

/***/ }),
/* 726 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo(value) {
    return this.lift(new MapToOperator(value));
}
exports.mapTo = mapTo;
var MapToOperator = function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=mapTo.js.map

/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return this.lift(new PairwiseOperator());
}
exports.pairwise = pairwise;
var PairwiseOperator = function () {
    function PairwiseOperator() {}
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        } else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=pairwise.js.map

/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Subject_1 = __webpack_require__(18);
var multicast_1 = __webpack_require__(139);
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish(selector) {
  return selector ? multicast_1.multicast.call(this, function () {
    return new Subject_1.Subject();
  }, selector) : multicast_1.multicast.call(this, new Subject_1.Subject());
}
exports.publish = publish;
//# sourceMappingURL=publish.js.map

/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
}
exports.scan = scan;
var ScanOperator = function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function get() {
            return this._seed;
        },
        set: function set(value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        } else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        } catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=scan.js.map

/***/ }),
/* 730 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var multicast_1 = __webpack_require__(139);
var Subject_1 = __webpack_require__(18);
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;
//# sourceMappingURL=share.js.map

/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip(count) {
    return this.lift(new SkipOperator(count));
}
exports.skip = skip;
var SkipOperator = function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=skip.js.map

/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayObservable_1 = __webpack_require__(66);
var ScalarObservable_1 = __webpack_require__(137);
var EmptyObservable_1 = __webpack_require__(79);
var concat_1 = __webpack_require__(340);
var isScheduler_1 = __webpack_require__(72);
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;
//# sourceMappingURL=startWith.js.map

/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo(innerObservable, resultSelector) {
    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
}
exports.switchMapTo = switchMapTo;
var SwitchMapToOperator = function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = function (_super) {
    __extends(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
//# sourceMappingURL=switchMapTo.js.map

/***/ }),
/* 735 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = __webpack_require__(16);
var ArgumentOutOfRangeError_1 = __webpack_require__(742);
var EmptyObservable_1 = __webpack_require__(79);
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=take.js.map

/***/ }),
/* 736 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = __webpack_require__(49);
var subscribeToResult_1 = __webpack_require__(52);
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
//# sourceMappingURL=takeUntil.js.map

/***/ }),
/* 737 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = __webpack_require__(102);
var isDate_1 = __webpack_require__(348);
var Subscriber_1 = __webpack_require__(16);
var TimeoutError_1 = __webpack_require__(346);
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
}
exports.timeout = timeout;
var TimeoutOperator = function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = function (_super) {
    __extends(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.action = null;
        this.scheduleTimeout();
    }
    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
        subscriber.error(subscriber.errorInstance);
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        } else {
            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.errorInstance = null;
    };
    return TimeoutSubscriber;
}(Subscriber_1.Subscriber);
//# sourceMappingURL=timeout.js.map

/***/ }),
/* 738 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = __webpack_require__(50);
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;
//# sourceMappingURL=Action.js.map

/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = __webpack_require__(344);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction);
exports.QueueAction = QueueAction;
//# sourceMappingURL=QueueAction.js.map

/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = __webpack_require__(345);
var QueueScheduler = function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler);
exports.QueueScheduler = QueueScheduler;
//# sourceMappingURL=QueueScheduler.js.map

/***/ }),
/* 741 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var QueueAction_1 = __webpack_require__(739);
var QueueScheduler_1 = __webpack_require__(740);
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map

/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ }),
/* 743 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Subscriber_1 = __webpack_require__(16);
var rxSubscriber_1 = __webpack_require__(142);
var Observer_1 = __webpack_require__(336);
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;
//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 745 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MediaKeys_js__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__setMediaKeys_js__ = __webpack_require__(746);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keySystemAccess_js__ = __webpack_require__(355);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__MediaKeys_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__setMediaKeys_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_2__keySystemAccess_js__["a"]; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/***/ }),
/* 746 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__MediaKeys_js__ = __webpack_require__(354);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Promise}
 */
function _setMediaKeys(elt, mediaKeys) {
  if (mediaKeys instanceof __WEBPACK_IMPORTED_MODULE_2__MediaKeys_js__["b" /* MockMediaKeys */]) {
    return mediaKeys._setVideo(elt);
  }

  if (elt.setMediaKeys) {
    return elt.setMediaKeys(mediaKeys);
  }

  if (mediaKeys === null) {
    return;
  }

  if (elt.WebkitSetMediaKeys) {
    return elt.WebkitSetMediaKeys(mediaKeys);
  }

  if (elt.mozSetMediaKeys) {
    return elt.mozSetMediaKeys(mediaKeys);
  }

  if (elt.msSetMediaKeys) {
    return elt.msSetMediaKeys(mediaKeys);
  }
}

/**
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */
/* harmony default export */ __webpack_exports__["a"] = (function (elt, mediaKeys) {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].defer(function () {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_castToObservable_js__["a" /* default */])(_setMediaKeys(elt, mediaKeys));
  });
});

/***/ }),
/* 747 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return requestFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exitFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isFullscreen; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 */
function requestFullscreen(elt) {
  if (!isFullscreen()) {
    if (elt.requestFullscreen) {
      elt.requestFullscreen();
    } else if (elt.msRequestFullscreen) {
      elt.msRequestFullscreen();
    } else if (elt.mozRequestFullScreen) {
      elt.mozRequestFullScreen();
    } else if (elt.webkitRequestFullscreen) {
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}

/**
 * Exit fullscreen if an element is currently in fullscreen.
 * TODO this exit fullscreen mode even if any element in the document is in
 * fullscreen, is it really what we want?
 */
function exitFullscreen() {
  if (isFullscreen()) {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
}

/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */
function isFullscreen() {
  return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
}



/***/ }),
/* 748 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ewma_js__ = __webpack_require__(356);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(19);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var FAST_EMA = 2;
var SLOW_EMA = 10;

var ABR_MINIMUM_TOTAL_BYTES = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].ABR_MINIMUM_TOTAL_BYTES,
    ABR_MINIMUM_CHUNK_SIZE = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].ABR_MINIMUM_CHUNK_SIZE;

/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */

var BandwidthEstimator = function () {
  function BandwidthEstimator() {
    _classCallCheck(this, BandwidthEstimator);

    /**
     * A fast-moving average.
     * @private
     */
    this._fast = new __WEBPACK_IMPORTED_MODULE_0__ewma_js__["a" /* default */](FAST_EMA);

    /**
     * A slow-moving average.
     * @private
     */
    this._slow = new __WEBPACK_IMPORTED_MODULE_0__ewma_js__["a" /* default */](SLOW_EMA);

    /**
     * Number of bytes sampled.
     * @private
     */
    this._bytesSampled = 0;
  }

  /**
   * Takes a bandwidth sample.
   * @param {number} durationMs The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes The total number of bytes transferred in that
   *   request.
   */


  BandwidthEstimator.prototype.addSample = function addSample(durationInMs, numberOfBytes) {
    if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
      return;
    }

    var bandwidth = 8000 * numberOfBytes / durationInMs;
    var weight = durationInMs / 1000;
    this._bytesSampled += numberOfBytes;

    this._fast.addSample(weight, bandwidth);
    this._slow.addSample(weight, bandwidth);
  };

  /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number}
   */


  BandwidthEstimator.prototype.getEstimate = function getEstimate() {
    if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
      return;
    }

    // Take the minimum of these two estimates.  This should have the effect of
    // adapting down quickly, but up more slowly.
    return Math.min(this._fast.getEstimate(), this._slow.getEstimate());
  };

  /**
   * Reset the bandwidth estimation.
   */


  BandwidthEstimator.prototype.reset = function reset() {
    this._fast = new __WEBPACK_IMPORTED_MODULE_0__ewma_js__["a" /* default */](FAST_EMA);
    this._slow = new __WEBPACK_IMPORTED_MODULE_0__ewma_js__["a" /* default */](SLOW_EMA);
    this._bytesSampled = 0;
  };

  return BandwidthEstimator;
}();

/* harmony default export */ __webpack_exports__["a"] = (BandwidthEstimator);

/***/ }),
/* 749 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = filterByBitrate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find_index__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find_index___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find_index__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
function filterByBitrate(representations, bitrate) {
  var firstSuperiorBitrate = __WEBPACK_IMPORTED_MODULE_0_array_find_index___default()(representations, function (r) {
    return r.bitrate > bitrate;
  });

  if (firstSuperiorBitrate === -1) {
    return representations;
  }
  return representations.slice(0, firstSuperiorBitrate);
}

/***/ }),
/* 750 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = filterByWidth;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
function filterByWidth(representations, width) {
  var sortedRepsByWidth = representations.sort(function (a, b) {
    return a.width - b.width;
  });
  var RepWithMaxWidth = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(sortedRepsByWidth, function (r) {
    return r.width >= width;
  });

  if (RepWithMaxWidth) {
    var maxWidth = RepWithMaxWidth.width;
    return representations.filter(function (r) {
      return r.width <= maxWidth;
    });
  }
  return representations;
}

/***/ }),
/* 751 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = fromBitrateCeil;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find_index__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find_index___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find_index__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Representation>}
 */
function fromBitrateCeil(representations, bitrate) {
  var tooHighIndex = __WEBPACK_IMPORTED_MODULE_0_array_find_index___default()(representations, function (representation) {
    return representation.bitrate > bitrate;
  });
  if (tooHighIndex === -1) {
    return representations[representations.length - 1];
  }
  return representations[tooHighIndex - 1];
}

/***/ }),
/* 752 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__representation_chooser_js__ = __webpack_require__(753);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Types of chunks accepted by the ABR logic.
 */
var KNOWN_TYPES = ["audio", "video", "text", "image"];

/**
 * @param {string} type
 * @throws {AssertError} - Throws if the type given is not known.
 */
var assertType = function assertType(type) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert_js__["a" /* default */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__["a" /* default */])(KNOWN_TYPES, type), "\"" + type + "\" is an unknown type");
};

/**
 * Create the right RepresentationChooser instance, from the given data.
 * @param {string} type
 * @param {Object} options
 * @returns {Observable} - The RepresentationChooser instance
 */
var createChooser = function createChooser(type, options) {
  return new __WEBPACK_IMPORTED_MODULE_3__representation_chooser_js__["a" /* default */]({
    limitWidth$: options.limitWidth[type],
    throttle$: options.throttle[type],
    initialBitrate: options.initialBitrates[type],
    manualBitrate: options.manualBitrates[type],
    maxAutoBitrate: options.maxAutoBitrates[type]
  });
};

/**
 * If it doesn't exist, create a RepresentationChooser instance and add
 * it to the given "instce" context, under the _choosers.<bufferType> property.
 * @param {ABRManager} intce
 * @param {string} bufferType
 */
var lazilyAttachChooser = function lazilyAttachChooser(instce, bufferType) {
  if (!instce._choosers[bufferType]) {
    instce._choosers[bufferType] = createChooser(bufferType, instce._chooserInstanceOptions);
  }
};

/**
 * Adaptive BitRate Manager.
 *
 * Select the right representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */

var ABRManager = function () {
  /**
   * @param {Observable} requests$ - Emit requests infos as they begin, progress
   * and end.
   * Allows to know if a request take too much time to be finished in
   * emergency times (e.g. when the user's bandwidth falls very quickly).
   *
   * The items emitted are Observables which each emit infos about a SINGLE
   * request. These infos are under the form of objects with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *
   *   - event {string}: Wether the request started, is progressing or has
   *     ended. Should be either one of these three strings:
   *       1. "requestBegin": The request has just begun.
   *
   *       2. "progress": Informations about the request progress were received
   *          (basically the amount of bytes currently received).
   *
   *       2. "requestEnd": The request just ended (successfully/on error/was
   *          canceled)
   *
   *     Note that it should ALWAYS happen in the following order:
   *     1 requestBegin -> 0+ progress -> 1 requestEnd
   *
   *     Also note that EVERY requestBegin should eventually be followed by a
   *     requestEnd at some point. If that's not the case, a memory leak
   *     can happen.
   *
   *   - value {Object|undefined}: The value depends on the type of event
   *     received:
   *       - for "requestBegin" events, it should be an object with the
   *         following keys:
   *           - id {Number|String}: The id of this particular request.
   *           - duration {Number}: duration, in seconds of the asked segment.
   *           - time {Number}: The start time, in seconds of the asked segment.
   *           - requestTimestamp {Number}: the timestamp at which the request
   *             was sent, in ms.
   *
   *       - for "progress" events, it should be an object with the following
   *         keys:
   *           - id {Number|String}: The id of this particular request.
   *           - size {Number}: amount currently downloaded, in bytes
   *           - timestamp {Number}: timestamp at which the progress event was
   *             received, in ms
   *         Those events SHOULD be received in order (that is, in increasing
   *         order for both size and timestamp).
   *
   *       - for "requestEnd" events:
   *           - id {Number|String}: The id of this particular request.
   *
   * @param {Observable} metrics$ - Emit each times the network downloaded
   * a new segment for a given buffer type. Allows to obtain informations about
   * the user's bitrate.
   *
   * The items emitted are object with the following keys:
   *   - type {string}: the buffer type (example: "video")
   *   - value {Object}:
   *     - duration {Number}: duration of the request, in seconds.
   *     - size {Number}: size of the downloaded chunks, in bytes.
   *
   * @param {Object} [options={}]
   * @param {Object} [options.initialBitrates={}]
   * @param {Object} [options.manualBitrates={}]
   * @param {Object} [options.maxAutoBitrates={}]
   * @param {Object} [options.throttle={}]
   * @param {Object} [options.limitWidth={}]
   */
  function ABRManager(requests$, metrics$) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ABRManager);

    // Subject emitting and completing on dispose.
    // Used to clean up every created observables.
    this._dispose$ = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]();

    // Will contain every RepresentationChooser attached to the ABRManager,
    // by type ("audio"/"video" etc.)
    this._choosers = {};

    // -- OPTIONS --

    // Will contain options used when (lazily) instantiating a
    // RepresentationChooser
    this._chooserInstanceOptions = {
      initialBitrates: options.initialBitrates || {},
      manualBitrates: options.manualBitrates || {},
      maxAutoBitrates: options.maxAutoBitrates || {},
      throttle: options.throttle || {},
      limitWidth: options.limitWidth || {}
    };

    metrics$.takeUntil(this._dispose$).subscribe(function (_ref) {
      var type = _ref.type,
          value = _ref.value;

      if (true) {
        assertType(type);
      }

      lazilyAttachChooser(_this, type);
      var duration = value.duration,
          size = value.size;

      // TODO Should we do a single estimate instead of a per-type one?
      // Test it thoroughly

      _this._choosers[type].addEstimate(duration, size);
    });

    requests$
    // requests$ emits observables which are subscribed to
    .mergeMap(function (request$) {
      return request$;
    }).takeUntil(this._dispose$).subscribe(function (_ref2) {
      var type = _ref2.type,
          event = _ref2.event,
          value = _ref2.value;

      if (true) {
        assertType(type);
      }

      lazilyAttachChooser(_this, type);
      switch (event) {
        case "requestBegin":
          // use the id of the segment as in any case, we should only have at
          // most one active download for the same segment.
          // This might be not optimal if this changes however. The best I think
          // for now is to just throw/warn in DEV mode when two pending ids
          // are identical
          _this._choosers[type].addPendingRequest(value.id, value);
          break;
        case "requestEnd":
          _this._choosers[type].removePendingRequest(value.id);
          break;
        case "progress":
          _this._choosers[type].addRequestProgress(value.id, value);
          break;
      }
    });
  }

  /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Array.<Representation>} [representations=[]]
   * @returns {Observable}
   */


  ABRManager.prototype.get$ = function get$(type, clock$) {
    var representations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (true) {
      assertType(type);
    }
    lazilyAttachChooser(this, type);
    return this._choosers[type].get$(clock$, representations);
  };

  /**
   * Set manually the bitrate for a given type.
   *
   * The given number will act as a ceil.
   * If no representation is found with the given bitrate, we will consider:
   *   1. The representation just lower than it
   *   2. If no representation is found in the previous step, the representation
   *   with the lowest bitrate.
   *
   * @param {string} type
   * @param {Number} bitrate
   */


  ABRManager.prototype.setManualBitrate = function setManualBitrate(type, bitrate) {
    if (true) {
      assertType(type);
    }

    var chooser = this._choosers[type];
    if (!chooser) {
      // if no chooser yet, store as a chooser option for when it will be
      // effectively instantiated
      this._chooserInstanceOptions.initialBitrates[type] = bitrate;
    } else {
      chooser.manualBitrate$.next(bitrate);
    }
  };

  ABRManager.prototype.setMaxAutoBitrate = function setMaxAutoBitrate(type, bitrate) {
    if (true) {
      assertType(type);
    }

    var chooser = this._choosers[type];
    if (!chooser) {
      // if no chooser yet, store as a chooser option for when it will be
      // effectively instantiated
      this._chooserInstanceOptions.maxAutoBitrates[type] = bitrate;
    } else {
      chooser.maxAutoBitrate$.next(bitrate);
    }
  };

  ABRManager.prototype.getManualBitrate = function getManualBitrate(type) {
    if (true) {
      assertType(type);
    }
    var chooser = this._choosers[type];
    return chooser ? chooser.manualBitrate$.getValue() : this._chooserInstanceOptions.manualBitrates[type];
  };

  ABRManager.prototype.getMaxAutoBitrate = function getMaxAutoBitrate(type) {
    if (true) {
      assertType(type);
    }
    var chooser = this._choosers[type];
    return chooser ? chooser.maxAutoBitrate$.getValue() : this._chooserInstanceOptions.maxAutoBitrates[type];
  };

  ABRManager.prototype.dispose = function dispose() {
    var _this2 = this;

    Object.keys(this._choosers).forEach(function (type) {
      _this2._choosers[type].dispose();
    });
    this._chooserInstanceOptions = null;
    this._choosers = null;
    this._dispose$.next();
    this._dispose$.complete();
  };

  return ABRManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (ABRManager);

/***/ }),
/* 753 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bandwidth_estimator_js__ = __webpack_require__(748);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__filterByWidth_js__ = __webpack_require__(750);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__filterByBitrate_js__ = __webpack_require__(749);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__fromBitrateCeil_js__ = __webpack_require__(751);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ewma_js__ = __webpack_require__(356);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








// import takeFirstSet from "../../utils/takeFirstSet.js";







var ABR_STARVATION_GAP = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].ABR_STARVATION_GAP,
    OUT_OF_STARVATION_GAP = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].OUT_OF_STARVATION_GAP,
    ABR_STARVATION_FACTOR = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].ABR_STARVATION_FACTOR,
    ABR_REGULAR_FACTOR = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].ABR_REGULAR_FACTOR;

/**
 * Returns an observable emitting only the representation concerned by the
 * bitrate ceil given.
 * @param {Array.<Representation>} representations
 * @param {Number} bitrate
 * @returns {Observable}
 */

var setManualRepresentation = function setManualRepresentation(representations, bitrate) {
  var chosenRepresentation = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__fromBitrateCeil_js__["a" /* default */])(representations, bitrate) || representations[0];

  return __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].of({
    bitrate: undefined, // Bitrate estimation is deactivated here
    representation: chosenRepresentation
  }).concat(__WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].never());
};

/**
 * Get the pending request containing the asked segment position.
 * @param {Object} requests
 * @param {Number} segmentPosition
 * @returns {Object|undefined}
 */
var getConcernedRequest = function getConcernedRequest(requests, segmentPosition) {
  var currentRequestIds = Object.keys(requests);
  var len = currentRequestIds.length;

  for (var i = 0; i < len - 1; i++) {
    var request = requests[currentRequestIds[i]];
    var chunkTime = request.time,
        chunkDuration = request.duration;

    // TODO review this

    if (Math.abs(segmentPosition - chunkTime) < chunkDuration) {
      return request;
    }
  }
};

/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * Use progress events if available, set a much more random lower bitrate
 * if no progress events are available.
 *
 * @param {Object} request
 * @param {Number} requestTime - Amount of time the request has taken for now,
 * in seconds.
 * @param {Number} bitrate - Current bitrate at the time of download
 */
var estimateRequestBandwidth = function estimateRequestBandwidth(request, requestTime, bitrate) {
  var estimate = void 0;
  var chunkDuration = request.duration;

  // try to infer quickly the current bitrate based on the
  // progress events
  if (request.progress.length >= 2) {
    var ewma1 = new __WEBPACK_IMPORTED_MODULE_10__ewma_js__["a" /* default */](2);

    var progress = request.progress;

    for (var i = 1; i < progress.length; i++) {
      var bytesDownloaded = progress[i].size - progress[i - 1].size;

      var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;

      var _bitrate = bytesDownloaded * 8 / (timeElapsed / 1000);

      ewma1.addSample(timeElapsed / 1000, _bitrate);
    }
    estimate = ewma1.getEstimate();
  }

  // if that fails / no progress event, take a guess
  if (!estimate) {
    var chunkSize = chunkDuration * bitrate;

    // take current duration of request as a base
    estimate = chunkSize / (requestTime * 5 / 4);
  }
  return estimate;
};

/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters
 * @param {Number} [filters.bitrate] - max bitrate authorized (included).
 * @param {Number} [filters.width] - max width authorized (included).
 * @returns {Array.<Representation>}
 */
var getFilteredRepresentations = function getFilteredRepresentations(representations, filters) {
  var _representations = representations;

  if (filters.hasOwnProperty("bitrate")) {
    _representations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__filterByBitrate_js__["a" /* default */])(_representations, filters.bitrate);
  }

  if (filters.hasOwnProperty("width")) {
    _representations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__filterByWidth_js__["a" /* default */])(_representations, filters.width);
  }

  return _representations;
};

/**
 * Returns true if the request takes too much time relatively to how much we
 * should actually wait.
 * Depends on the chunk duration.
 * @param {Number} durationOfRequest - time, in s, since the request has been
 * performed.
 * @param {Number} chunkDuration - duration, in s, of a single chunk
 * @returns {Boolean}
 */
var requestTakesTime = function requestTakesTime(durationOfRequest, chunkDuration) {
  return durationOfRequest > 1 + chunkDuration * 1.2;
};

/**
 * Choose the right representation based on multiple parameters given, such as:
 *   - the current user's bandwidth
 *   - the max bitrate authorized
 *   - the size of the video element
 *   - etc.
 *
 * Those parameters can be set through different subjects and methods.
 * The subjects (undocumented here are):
 *
 *   - manualBitrate$ {Subject}: Set the bitrate manually, if no representation
 *     is found with the given bitrate. An immediately inferior one will be
 *     taken instead. If still, none are found, the representation with the
 *     minimum bitrate will be taken.
 *     Set it to a negative value to go into automatic bitrate mode.
 *
 *   - maxBitrate$ {Subject}: Set the maximum automatic bitrate. If the manual
 *     bitrate is not set / set to a negative value, this will be the maximum
 *     switch-able bitrate. If no representation is found inferior or equal to
 *     this bitrate, the representation with the minimum bitrate will be taken.
 *
 */

var RepresentationChooser = function () {
  /**
   * @param {Object} options
   * @param {Number} [options.manualBitrate=-1]
   * @param {Number} [options.maxAutoBitrate=Infinity]
   * @param {Number} [options.initialBitrate=0]
   * @param {Observable} [options.limitWidth$]
   * @param {Observable} [options.throttle$]
   */
  function RepresentationChooser() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RepresentationChooser);

    this._dispose$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__["Subject"]();

    this.manualBitrate$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__["BehaviorSubject"](options.manualBitrate != null ? options.manualBitrate : -1).takeUntil(this._dispose$);

    this.maxAutoBitrate$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__["BehaviorSubject"](options.maxAutoBitrate != null ? options.maxAutoBitrate : Infinity).takeUntil(this._dispose$);

    this.estimator = new __WEBPACK_IMPORTED_MODULE_6__bandwidth_estimator_js__["a" /* default */]();
    this._currentRequests = {};

    this.initialBitrate = options.initialBitrate || 0;

    this._limitWidth$ = options.limitWidth$;
    this._throttle$ = options.throttle$;
  }

  RepresentationChooser.prototype.get$ = function get$(clock$, representations) {
    var _this = this;

    if (representations.length < 2) {
      return __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].of({
        bitrate: undefined, // Bitrate estimation is deactivated here
        representation: representations.length ? representations[0] : null
      }).concat(__WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].never()).takeUntil(this._dispose$);
    }

    var manualBitrate$ = this.manualBitrate$,
        maxAutoBitrate$ = this.maxAutoBitrate$,
        initialBitrate = this.initialBitrate;


    var _deviceEventsArray = [];

    if (this._limitWidth$) {
      _deviceEventsArray.push(this._limitWidth$.map(function (width) {
        return { width: width };
      }));
    }

    if (this._throttle$) {
      _deviceEventsArray.push(this._throttle$.map(function (bitrate) {
        return { bitrate: bitrate };
      }));
    }

    var deviceEvents$ = _deviceEventsArray.length ? __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].combineLatest.apply(__WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"], _deviceEventsArray).map(function (args) {
      return __WEBPACK_IMPORTED_MODULE_0_object_assign___default.a.apply(undefined, [{}].concat(args));
    }) : __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].of({});

    var lastEstimatedBitrate = void 0;
    return manualBitrate$.switchMap(function (manualBitrate) {
      if (manualBitrate >= 0) {
        // MANUAL mode
        return setManualRepresentation(representations, manualBitrate);
      }

      // AUTO mode
      var inStarvationMode = false;
      return __WEBPACK_IMPORTED_MODULE_3_rxjs_Observable__["Observable"].combineLatest(clock$, maxAutoBitrate$, deviceEvents$).map(function (_ref) {
        var clock = _ref[0],
            maxAutoBitrate = _ref[1],
            deviceEvents = _ref[2];


        var nextBitrate = void 0;
        var bandwidthEstimate = void 0;
        var bufferGap = clock.bufferGap;

        // Check for starvation == not much left to play

        if (bufferGap <= ABR_STARVATION_GAP) {
          inStarvationMode = true;
        } else if (inStarvationMode && bufferGap >= OUT_OF_STARVATION_GAP) {
          inStarvationMode = false;
        }

        // If in starvation mode, check if the request for the next segment
        // takes too much time relatively to the chunk's duration.
        // If that's the case, re-calculate the bandwidth urgently based on
        // this single request.
        if (inStarvationMode) {
          var position = clock.position,
              bitrate = clock.bitrate;


          var nextSegmentPosition = bufferGap + position;
          var request = getConcernedRequest(_this._currentRequests, nextSegmentPosition);

          if (request) {
            var chunkDuration = request.duration,
                requestTimestamp = request.requestTimestamp;


            var now = Date.now();
            var requestTimeInSeconds = (now - requestTimestamp) / 1000;
            if (chunkDuration && requestTakesTime(requestTimeInSeconds, chunkDuration)) {
              bandwidthEstimate = estimateRequestBandwidth(request, requestTimeInSeconds, bitrate);

              if (bandwidthEstimate != null) {
                // Reset all estimations to zero
                // Note: this is weird to do this type of "global" side effect
                // (for this class) in an observable, not too comfortable with
                // that.
                _this.resetEstimate();
                nextBitrate = Math.min(bandwidthEstimate, bitrate, maxAutoBitrate);
              }
            }
          }
        }

        // if nextBitrate is not yet defined, do the normal estimation
        if (nextBitrate == null) {
          bandwidthEstimate = _this.estimator.getEstimate();

          var nextEstimate = void 0;
          if (bandwidthEstimate != null) {
            nextEstimate = clock.bufferGap <= inStarvationMode ? bandwidthEstimate * ABR_STARVATION_FACTOR : bandwidthEstimate * ABR_REGULAR_FACTOR;
          } else if (lastEstimatedBitrate != null) {
            nextEstimate = clock.bufferGap <= inStarvationMode ? lastEstimatedBitrate * ABR_STARVATION_FACTOR : lastEstimatedBitrate * ABR_REGULAR_FACTOR;
          } else {
            nextEstimate = initialBitrate;
          }
          nextBitrate = Math.min(nextEstimate, maxAutoBitrate);
        }

        if (clock.speed > 1) {
          nextBitrate /= clock.speed;
        }

        var _representations = getFilteredRepresentations(representations, deviceEvents);

        return {
          bitrate: bandwidthEstimate,
          representation: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__fromBitrateCeil_js__["a" /* default */])(_representations, nextBitrate) || representations[0]
        };
      }).do(function (_ref2) {
        var bitrate = _ref2.bitrate;

        if (bitrate != null) {
          lastEstimatedBitrate = bitrate;
        }
      }).share();
    });
  };

  /**
   * Add a bandwidth estimate by giving:
   *   - the duration of the request, in s
   *   - the size of the request in bytes
   * @param {Number} duration
   * @param {Number} size
   */


  RepresentationChooser.prototype.addEstimate = function addEstimate(duration, size) {
    if (duration != null && size != null) {
      this.estimator.addSample(duration, size);
    }
  };

  /**
   * Reset all the estimates done until now.
   * Useful when the network situation changed completely.
   */


  RepresentationChooser.prototype.resetEstimate = function resetEstimate() {
    this.estimator.reset();
  };

  /**
   * Add informations about a new pending request.
   * This can be useful if the network bandwidth drastically changes to infer
   * a new bandwidth through this single request.
   * @param {string|Number} id
   * @param {Segment} segment
   */


  RepresentationChooser.prototype.addPendingRequest = function addPendingRequest(id, segment) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_assert_js__["a" /* default */])(!this._currentRequests[id], "request already added");
    }
    this._currentRequests[id] = segment;
    this._currentRequests[id].progress = [];
  };

  /**
   * Add progress informations to a pending request.
   * Progress objects are a key part to calculate the bandwidth from a single
   * request, in the case the user's bandwidth changes drastically while doing
   * it.
   * @param {string|Number} id
   * @param {Object} progress
   */


  RepresentationChooser.prototype.addRequestProgress = function addRequestProgress(id, progress) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_assert_js__["a" /* default */])(this._currentRequests[id] && this._currentRequests[id].progress, "not a valid request");
    }
    this._currentRequests[id].progress.push(progress);
  };

  /**
   * Remove a request previously set as pending through the addPendingRequest
   * method.
   * @param {string|Number} id
   */


  RepresentationChooser.prototype.removePendingRequest = function removePendingRequest(id) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_assert_js__["a" /* default */])(this._currentRequests[id], "can't remove request: id not found");
    }
    delete this._currentRequests[id];
  };

  /**
   * Remove informations about all pending requests.
   */


  RepresentationChooser.prototype.resetRequests = function resetRequests() {
    this._currentRequests = {};
  };

  /**
   * TODO Not really needed for now
   */


  RepresentationChooser.prototype.dispose = function dispose() {
    this._dispose$.next();
  };

  return RepresentationChooser;
}();

/* harmony default export */ __webpack_exports__["a"] = (RepresentationChooser);

/***/ }),
/* 754 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__ = __webpack_require__(54);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var SAMPLING_INTERVAL_MEDIASOURCE = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].SAMPLING_INTERVAL_MEDIASOURCE,
    SAMPLING_INTERVAL_NO_MEDIASOURCE = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].SAMPLING_INTERVAL_NO_MEDIASOURCE,
    RESUME_AFTER_SEEKING_GAP = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].RESUME_AFTER_SEEKING_GAP,
    RESUME_AFTER_BUFFERING_GAP = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].RESUME_AFTER_BUFFERING_GAP,
    STALL_GAP = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].STALL_GAP;

/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */

var SCANNED_VIDEO_EVENTS = ["canplay", "play", "progress", "seeking", "seeked", "loadedmetadata"];

/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @returns {Boolean}
 */
var getResumeGap = function getResumeGap(stalled) {
  return stalled.state == "seeking" ? RESUME_AFTER_SEEKING_GAP : RESUME_AFTER_BUFFERING_GAP;
};

/**
 * TODO I just don't get it for this one.
 * gap + range.end ??? HELP
 * @param {Number} gap
 * @param {Object} range
 * @param {Number} duration
 * @returns {Boolean}
 */
var isEnding = function isEnding(bufferGap, currentRange, duration) {
  return currentRange && duration - (bufferGap + currentRange.end) <= STALL_GAP;
};

/**
 * Generate a basic timings object from the video element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} video
 * @param {string} name
 * @returns {Object}
 */
function getTimings(video, name) {
  var currentTime = video.currentTime,
      paused = video.paused,
      playbackRate = video.playbackRate,
      readyState = video.readyState,
      buffered = video.buffered,
      duration = video.duration;


  return {
    currentTime: currentTime,
    buffered: buffered,
    duration: duration,
    bufferGap: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__["a" /* getLeftSizeOfRange */])(buffered, currentTime),
    state: name,
    playbackRate: playbackRate,
    currentRange: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__["i" /* getRange */])(buffered, currentTime),
    readyState: readyState,
    paused: paused
  };
}

/**
 * Infer stalled status of the video based on:
 *   - the return of the function getTimings
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Boolean} withMediaSource - False if the directfile API is used.
 * @returns {Object|null}
 */
var getStalledStatus = function getStalledStatus(prevTimings, currentTimings, withMediaSource) {
  var currentState = currentTimings.state,
      currentTime = currentTimings.currentTime,
      bufferGap = currentTimings.bufferGap,
      currentRange = currentTimings.currentRange,
      duration = currentTimings.duration,
      paused = currentTimings.paused,
      readyState = currentTimings.readyState;
  var prevStalled = prevTimings.stalled,
      prevState = prevTimings.state,
      prevTime = prevTimings.currentTime;


  var ending = isEnding(bufferGap, currentRange, duration);

  var canStall = readyState >= 1 && currentState != "loadedmetadata" && !prevStalled && !ending;

  var shouldStall = void 0,
      shouldUnstall = void 0;

  if (withMediaSource) {
    if (canStall && (bufferGap <= STALL_GAP || bufferGap === Infinity || readyState === 1)) {
      shouldStall = true;
    } else if (prevStalled && readyState > 1 && bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending)) {
      shouldUnstall = true;
    }
  }

  // when using a direct file, the video will stall and unstall on its
  // own, so we only try to detect when the video timestamp has not changed
  // between two consecutive timeupdates
  else {
      if (canStall && (!paused && currentState == "timeupdate" && prevState == "timeupdate" && currentTime === prevTime || currentState == "seeking" && bufferGap === Infinity)) {
        shouldStall = true;
      } else if (prevStalled && (currentState != "seeking" && currentTime !== prevTime || currentState == "canplay" || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled) || ending))) {
        shouldUnstall = true;
      }
    }

  if (shouldStall) {
    return { state: currentState, timestamp: Date.now() };
  } else if (shouldUnstall) {
    return null;
  } else {
    return prevStalled;
  }
};

/**
 * Timings observable.
 *
 * This streams samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * video duration
 *
 * In addition to sampling, this stream also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to <video>
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} video
 * @param {Object} options
 * @returns {Observable}
 */
function createTimingsSampler(video, _ref) {
  var withMediaSource = _ref.withMediaSource;

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
    var lastTimings = getTimings(video, "init");
    lastTimings.stalled = null;

    /**
     * Emit timings sample.
     * Meant to be used as a callback on various async events.
     * @param {Event} [evt] - The Event which triggered the callback, if one.
     */
    function emitSample(evt) {
      var timingEventType = evt && evt.type || "timeupdate";
      var currentTimings = getTimings(video, timingEventType);
      currentTimings.stalled = getStalledStatus(lastTimings, currentTimings, withMediaSource);
      lastTimings = currentTimings;
      obs.next(lastTimings);
    }

    var interval = withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE;

    var intervalID = setInterval(emitSample, interval);
    SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
      return video.addEventListener(eventName, emitSample);
    });

    obs.next(lastTimings);

    return function () {
      clearInterval(intervalID);
      SCANNED_VIDEO_EVENTS.forEach(function (eventName) {
        return video.removeEventListener(eventName, emitSample);
      });
    };
  }).multicast(function () {
    return new __WEBPACK_IMPORTED_MODULE_1_rxjs_BehaviorSubject__["BehaviorSubject"]({});
  }).refCount();
}

/* harmony default export */ __webpack_exports__["a"] = (createTimingsSampler);

/***/ }),
/* 755 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_eventemitter__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_ranges_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__net__ = __webpack_require__(816);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__manifest_timings_js__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__stream_index_js__ = __webpack_require__(778);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__eme__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__constants_js__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__clock_js__ = __webpack_require__(754);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__private_js__ = __webpack_require__(759);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__infer_player_state_js__ = __webpack_require__(756);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__option_parsers_js__ = __webpack_require__(758);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines the public player API
 */




























var DEFAULT_UNMUTED_VOLUME = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].DEFAULT_UNMUTED_VOLUME;

/**
 * @param {Observable} stream
 * @param {string} type
 * @returns {Observable}
 */

function filterStreamByType(stream, type) {
  return stream.filter(function (o) {
    return o.type == type;
  }).map(function (o) {
    return o.value;
  });
}

/**
 * @class Player
 * @extends EventEmitter
 */

var Player = function (_EventEmitter) {
  _inherits(Player, _EventEmitter);

  _createClass(Player, null, [{
    key: "ErrorTypes",

    /**
     * @returns {Object}
     */
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_13__errors__["a" /* ErrorTypes */];
    }

    /**
     * @returns {Object}
     */

  }, {
    key: "ErrorCodes",
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_13__errors__["b" /* ErrorCodes */];
    }

    /**
     * @returns {string} - current log level
     */

  }, {
    key: "LogLevel",
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_5__utils_log__["a" /* default */].getLevel();
    }

    /**
     * @param {string} logLevel - should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */
    ,
    set: function set(logLevel) {
      __WEBPACK_IMPORTED_MODULE_5__utils_log__["a" /* default */].setLevel(logLevel);
    }

    /**
     * Note: as the private state from this class can be pretty heavy, every
     * private properties should be initialized here for better visibility.
     * @param {Object} options
     * @param {HTMLVideoElement_} options.videoElement
     */

  }]);

  function Player(options) {
    _classCallCheck(this, Player);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    var _parseConstructorOpti = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__option_parsers_js__["a" /* parseConstructorOptions */])(options),
        initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate,
        initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate,
        limitVideoWidth = _parseConstructorOpti.limitVideoWidth,
        maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate,
        maxBufferAhead = _parseConstructorOpti.maxBufferAhead,
        maxBufferBehind = _parseConstructorOpti.maxBufferBehind,
        maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate,
        throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden,
        videoElement = _parseConstructorOpti.videoElement,
        wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead;

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(videoElement instanceof __WEBPACK_IMPORTED_MODULE_9__compat__["a" /* HTMLVideoElement_ */], "videoElement needs to be an HTMLVideoElement");

    // Workaround to support Firefox autoplay on FF 42.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
    videoElement.preload = "auto";

    _this.version = /*PLAYER_VERSION*/"3.0.0-rc6";
    _this.log = __WEBPACK_IMPORTED_MODULE_5__utils_log__["a" /* default */];
    _this.state = undefined;
    _this.videoElement = videoElement;

    _this._priv = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18__private_js__["a" /* default */])(_this);

    _this._priv.destroy$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__compat_events_js__["a" /* onFullscreenChange$ */])(videoElement).takeUntil(_this._priv.destroy$).subscribe(function () {
      return _this.trigger("fullscreenChange", _this.isFullscreen());
    });

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__compat_events_js__["b" /* onTextTrackChanges$ */])(videoElement.textTracks).takeUntil(_this._priv.destroy$).map(function (_ref) {
      var target = _ref.target;
      // prepare TextTrack array
      var arr = [];
      for (var _iterator = target, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref2 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref2 = _i.value;
        }

        var textTrack = _ref2;

        arr.push(textTrack);
      }
      return arr;
    })

    // We can have two consecutive textTrackChanges with the exact same
    // payload when we perform multiple texttrack operations before the event
    // loop is freed.
    // In that case we only want to fire one time the observable.
    .distinctUntilChanged(function (textTracksA, textTracksB) {
      if (textTracksA.length !== textTracksB.length) {
        return false;
      }
      for (var i = 0; i < textTracksA.length; i++) {
        if (textTracksA[i] !== textTracksB[i]) {
          return false;
        }
      }
      return true;
    }).subscribe(function (x) {
      return _this._priv.onNativeTextTracksNext(x);
    });

    // TODO Use regular Stream observable for that
    _this._priv.errorStream$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]() // Emits warnings
    .takeUntil(_this._priv.destroy$);

    /**
     * Emit false when the player is in a "paused" state, false otherwise)
     * @type {Observable.<Boolean}
     */
    _this._priv.playing$ = new __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__["ReplaySubject"](1);

    // last speed set by the user
    _this._priv.speed$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__["BehaviorSubject"](videoElement.playbackRate);

    // clean ressources from loaded content
    _this._priv.unsubscribeLoadedVideo$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]().takeUntil(_this._priv.destroy$);

    _this._priv.wantedBufferAhead$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__["BehaviorSubject"](wantedBufferAhead);
    _this._priv.maxBufferAhead$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__["BehaviorSubject"](maxBufferAhead);
    _this._priv.maxBufferBehind$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_BehaviorSubject__["BehaviorSubject"](maxBufferBehind);

    // keep track of the last adaptive options
    _this._priv.lastBitrates = {
      audio: initialAudioBitrate,
      video: initialVideoBitrate
    };
    _this._priv.initialMaxAutoBitrates = {
      audio: maxAudioBitrate,
      video: maxVideoBitrate
    };
    _this._priv.manualBitrates = {
      audio: -1,
      video: -1
    };

    // adaptive initial private state
    _this._priv.throttleWhenHidden = throttleWhenHidden;
    _this._priv.limitVideoWidth = limitVideoWidth;

    _this._priv.mutedMemory = DEFAULT_UNMUTED_VOLUME;

    // private state set later
    ["abrManager", "currentAdaptations", "currentImagePlaylist", "currentRepresentations", "fatalError", "initialAudioTrack", "initialTextTrack", "languageManager", "manifest", "recordedEvents"].forEach(function (key) {
      _this._priv[key] = undefined;
    });

    // populate initial values for content-related state
    _this._priv.resetContentState();

    _this._priv.setPlayerState(__WEBPACK_IMPORTED_MODULE_16__constants_js__["a" /* PLAYER_STATES */].STOPPED);
    return _this;
  }

  /**
   * Stop the player.
   */


  Player.prototype.stop = function stop() {
    if (this.state !== __WEBPACK_IMPORTED_MODULE_16__constants_js__["a" /* PLAYER_STATES */].STOPPED) {
      this._priv.resetContentState();
      this._priv.unsubscribeLoadedVideo$.next();
      this._priv.setPlayerState(__WEBPACK_IMPORTED_MODULE_16__constants_js__["a" /* PLAYER_STATES */].STOPPED);
    }
  };

  /**
   * Free the resources used by the player.
   */


  Player.prototype.dispose = function dispose() {
    // free resources linked to the loaded content
    this.stop();

    // free resources used for EME management
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__eme__["a" /* dispose */])();

    var _priv = this._priv;

    // free resources linked to the Player instance

    _priv.destroy$.next();
    _priv.destroy$.complete();

    // clean up BehaviorSubjects
    _priv.playing$.complete();
    _priv.speed$.complete();
    _priv.wantedBufferAhead$.complete();
    _priv.maxBufferAhead$.complete();
    _priv.maxBufferBehind$.complete();

    // clean up potentially heavy objects
    _priv.playing$ = null;
    _priv.speed$ = null;
    _priv.wantedBufferAhead$ = null;
    _priv.maxBufferAhead$ = null;
    _priv.maxBufferBehind$ = null;
    _priv.unsubscribeLoadedVideo$ = null;
    _priv.errorStream$ = null;
    _priv.lastBitrates = null;
    _priv.manualBitrates = null;
    _priv.initialMaxAutoBitrates = null;
    this.videoElement = null;
  };

  /**
   * Load a new video.
   * @param {Object} options
   * @returns {Observable}
   * @throws Error - throws if no url is given.
   * @throws Error - throws if no transport is given and no default transport
   * has been set.
   * @throws Error - throws if the asked transport does not exist
   */


  Player.prototype.loadVideo = function loadVideo() {
    var _this2 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__option_parsers_js__["b" /* parseLoadVideoOptions */])(options, this);
    __WEBPACK_IMPORTED_MODULE_5__utils_log__["a" /* default */].info("loadvideo", options);

    var _options = options,
        autoPlay = _options.autoPlay,
        defaultAudioTrack = _options.defaultAudioTrack,
        defaultTextTrack = _options.defaultTextTrack,
        hideNativeSubtitle = _options.hideNativeSubtitle,
        keySystems = _options.keySystems,
        startAt = _options.startAt,
        supplementaryImageTracks = _options.supplementaryImageTracks,
        supplementaryTextTracks = _options.supplementaryTextTracks,
        textTrackElement = _options.textTrackElement,
        textTrackMode = _options.textTrackMode,
        transport = _options.transport,
        transportOptions = _options.transportOptions,
        url = _options.url;

    // Perform multiple checks on the given options

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(url, "you have to set at least an url");
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(transport, "you have to set the transport type (e.g. \"smooth\", \"dash\")");
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(textTrackMode !== "html" || textTrackElement instanceof Element, "textTrackElement needs to be specified as an Element in \"html\"" + " textTrackMode.");

    var Transport = __WEBPACK_IMPORTED_MODULE_11__net__["a" /* default */][transport];
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(Transport, "transport \"" + transport + "\" not supported");
    var transportObj = Transport(transportOptions);

    // now that every check has passed, stop previous content
    this.stop();

    // prepare initial tracks played
    this._priv.initialAudioTrack = defaultAudioTrack;
    this._priv.initialTextTrack = defaultTextTrack;

    this._priv.playing$.next(autoPlay);

    // get every properties used from context for clarity
    var videoElement = this.videoElement;
    var _priv2 = this._priv,
        errorStream$ = _priv2.errorStream$,
        initialMaxAutoBitrates = _priv2.initialMaxAutoBitrates,
        lastBitrates = _priv2.lastBitrates,
        limitVideoWidth = _priv2.limitVideoWidth,
        manualBitrates = _priv2.manualBitrates,
        maxBufferAhead$ = _priv2.maxBufferAhead$,
        maxBufferBehind$ = _priv2.maxBufferBehind$,
        playing$ = _priv2.playing$,
        speed$ = _priv2.speed$,
        throttleWhenHidden = _priv2.throttleWhenHidden,
        unsubscribeLoadedVideo$ = _priv2.unsubscribeLoadedVideo$,
        wantedBufferAhead$ = _priv2.wantedBufferAhead$;

    // TODO either ditch or repair directFile playback
    /** @type {Boolean} */

    var withMediaSource = !transport.directFile;

    /**
     * Global clock used for the whole application.
     * @type {Observable.<Object>}
     */
    var clock$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17__clock_js__["a" /* default */])(videoElement, { withMediaSource: withMediaSource });

    /**
     * Options used by the ABR Manager.
     * @type {Object}
     */
    var adaptiveOptions = {
      initialBitrates: lastBitrates,
      manualBitrates: manualBitrates,
      maxAutoBitrates: initialMaxAutoBitrates,
      throttle: throttleWhenHidden && {
        video: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__compat_events_js__["c" /* isInBackground$ */])().map(function (isBg) {
          return isBg ? 0 : Infinity;
        }).takeUntil(unsubscribeLoadedVideo$)
      },
      limitWidth: limitVideoWidth && {
        video: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__compat_events_js__["d" /* videoWidth$ */])(videoElement).takeUntil(unsubscribeLoadedVideo$)
      }
    };

    /**
     * Options used by the Buffer(s)
     * @type {Object}
     */
    var bufferOptions = {
      wantedBufferAhead$: wantedBufferAhead$,
      maxBufferAhead$: maxBufferAhead$,
      maxBufferBehind$: maxBufferBehind$
    };

    /**
     * Options used by the TextTrack SourceBuffer
     * @type {Object}
     */
    var textTrackOptions = {
      textTrackMode: textTrackMode,
      textTrackElement: textTrackElement,
      hideNativeSubtitle: hideNativeSubtitle
    };

    /**
     * Stream Observable, through which the content will be launched.
     * @type {Observable.<Object>}
     */
    var stream = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__stream_index_js__["a" /* default */])({
      adaptiveOptions: adaptiveOptions,
      autoPlay: autoPlay,
      bufferOptions: bufferOptions,
      errorStream: errorStream$, // TODO
      keySystems: keySystems,
      speed$: speed$,
      startAt: startAt,
      textTrackOptions: textTrackOptions,
      timings$: clock$,
      transport: transportObj,
      url: url,
      videoElement: videoElement,
      withMediaSource: withMediaSource,

      supplementaryImageTracks: supplementaryImageTracks,
      supplementaryTextTracks: supplementaryTextTracks
    }).takeUntil(unsubscribeLoadedVideo$).publish();

    /**
     * Emit a truthy value when the player stalls, a falsy value as it unstalls.
     * TODO Observable of boolean
     * @type {Observable}
     */
    var stalled$ = filterStreamByType(stream, "stalled").startWith(null);

    /**
     * Emit when the stream is considered "loaded".
     * @type {Observable}
     */
    var loaded = filterStreamByType(stream, "loaded").take(1).share();

    /**
     * Emit the player state as it changes.
     * TODO only way to call setPlayerState?
     * @type {Observable.<string>}
     */
    var stateChanges$ = loaded.mapTo(__WEBPACK_IMPORTED_MODULE_16__constants_js__["a" /* PLAYER_STATES */].LOADED).concat(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(playing$, stalled$, __WEBPACK_IMPORTED_MODULE_19__infer_player_state_js__["a" /* default */])).distinctUntilChanged().startWith(__WEBPACK_IMPORTED_MODULE_16__constants_js__["a" /* PLAYER_STATES */].LOADING);

    /**
     * Emit true each time the player goes into a "play" state.
     * @type {Observable.<Boolean>}
     */
    var videoPlays$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__compat_events_js__["e" /* onPlayPause$ */])(videoElement).map(function (evt) {
      return evt.type === "play";
    });

    var streamDisposable = void 0;
    unsubscribeLoadedVideo$.take(1).subscribe(function () {
      if (streamDisposable) {
        streamDisposable.unsubscribe();
      }
    });

    // This is needed to avoid a weird behavior when the second callback of RxJS
    // Observables (onError) is not specified
    // TODO investigate
    var noop = function noop() {};

    videoPlays$.takeUntil(unsubscribeLoadedVideo$).subscribe(function (x) {
      return _this2._priv.onPlayPauseNext(x);
    }, noop);

    clock$.takeUntil(unsubscribeLoadedVideo$).subscribe(function (x) {
      return _this2._priv.triggerTimeChange(x);
    }, noop);

    stateChanges$.takeUntil(unsubscribeLoadedVideo$).subscribe(function (x) {
      return _this2._priv.setPlayerState(x);
    }, noop);

    stream.subscribe(function (x) {
      return _this2._priv.onStreamNext(x);
    }, function (err) {
      return _this2._priv.onStreamError(err);
    }, function () {
      return _this2._priv.onStreamComplete();
    });

    errorStream$.takeUntil(unsubscribeLoadedVideo$).subscribe(function (x) {
      return _this2._priv.onErrorStreamNext(x);
    });

    streamDisposable = stream.connect();
  };

  /**
   * Returns fatal error if one for the current content. null otherwise.
   * @returns {Object|null}
   */


  Player.prototype.getError = function getError() {
    return this._priv.fatalError;
  };

  /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @returns {Manifest|null}
   */


  Player.prototype.getManifest = function getManifest() {
    return this._priv.manifest || null;
  };

  /**
   * Returns adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */


  Player.prototype.getCurrentAdaptations = function getCurrentAdaptations() {
    if (!this._priv.manifest) {
      return null;
    }
    return this._priv.currentAdaptations;
  };

  /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null}
   */


  Player.prototype.getCurrentRepresentations = function getCurrentRepresentations() {
    if (!this._priv.manifest) {
      return null;
    }
    return this._priv.currentRepresentations;
  };

  /**
   * Returns the video DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HMTLMediaElement}
   */


  Player.prototype.getVideoElement = function getVideoElement() {
    return this.videoElement;
  };

  /**
   * Returns the text-track element used by the player to inject subtitles.
   * @returns {TextTrack}
   */


  Player.prototype.getNativeTextTrack = function getNativeTextTrack() {
    var textTracks = this.videoElement.textTracks;
    if (textTracks.length > 0) {
      return this.videoElement.textTracks[0];
    } else {
      return null;
    }
  };

  /**
   * Returns the player's current state.
   * @returns {string}
   */


  Player.prototype.getPlayerState = function getPlayerState() {
    return this.state;
  };

  /**
   * Returns true if:
   *   - a content is loaded
   *   - the content is a live content
   * @returns {Boolean}
   */


  Player.prototype.isLive = function isLive() {
    if (!this._priv.manifest) {
      return false;
    }
    return this._priv.manifest.isLive;
  };

  /**
   * Returns the url of the content's manifest
   * @returns {string"undefined}
   */


  Player.prototype.getUrl = function getUrl() {
    if (!this._priv.manifest) {
      return;
    }
    return this._priv.manifest.getUrl();
  };

  /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */


  Player.prototype.getVideoDuration = function getVideoDuration() {
    return this.videoElement.duration;
  };

  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */


  Player.prototype.getVideoBufferGap = function getVideoBufferGap() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_ranges_js__["a" /* getLeftSizeOfRange */])(this.videoElement.buffered, this.videoElement.currentTime);
  };

  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */


  Player.prototype.getVideoLoadedTime = function getVideoLoadedTime() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_ranges_js__["b" /* getSizeOfRange */])(this.videoElement.buffered, this.videoElement.currentTime);
  };

  /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */


  Player.prototype.getVideoPlayedTime = function getVideoPlayedTime() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_ranges_js__["c" /* getPlayedSizeOfRange */])(this.videoElement.buffered, this.videoElement.currentTime);
  };

  /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */


  Player.prototype.getWallClockTime = function getWallClockTime() {
    if (!this._priv.manifest) {
      return 0;
    }
    var ct = this.videoElement.currentTime;
    return this.isLive() ? +__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__manifest_timings_js__["a" /* toWallClockTime */])(ct, this._priv.manifest) / 1000 : ct;
  };

  /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */


  Player.prototype.getPosition = function getPosition() {
    return this.videoElement.currentTime;
  };

  /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */


  Player.prototype.getPlaybackRate = function getPlaybackRate() {
    return this._priv.speed$.getValue();
  };

  /**
   * @returns {Number}
   */


  Player.prototype.getVolume = function getVolume() {
    return this.videoElement.volume;
  };

  /**
   * @returns {Boolean}
   */


  Player.prototype.isFullscreen = function isFullscreen() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__compat__["b" /* isFullscreen */])();
  };

  /**
   * @returns {Array.<Number>}
   */


  Player.prototype.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
    var videoAdaptation = this._priv.currentAdaptations.video;
    if (!videoAdaptation) {
      return [];
    }

    return videoAdaptation.representations.map(function (_ref3) {
      var bitrate = _ref3.bitrate;
      return bitrate;
    });
  };

  /**
   * @returns {Array.<Number>}
   */


  Player.prototype.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
    var audioAdaptation = this._priv.currentAdaptations.audio;
    if (!audioAdaptation) {
      return [];
    }

    return audioAdaptation.representations.map(function (_ref4) {
      var bitrate = _ref4.bitrate;
      return bitrate;
    });
  };

  /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */


  Player.prototype.getManualAudioBitrate = function getManualAudioBitrate() {
    return this._priv.manualBitrates.audio;
  };

  /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */


  Player.prototype.getManualVideoBitrate = function getManualVideoBitrate() {
    return this._priv.manualBitrates.video;
  };

  /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */


  Player.prototype.getVideoBitrate = function getVideoBitrate() {
    return this._priv.recordedEvents.videoBitrate;
  };

  /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */


  Player.prototype.getAudioBitrate = function getAudioBitrate() {
    return this._priv.recordedEvents.audioBitrate;
  };

  /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */


  Player.prototype.getMaxVideoBitrate = function getMaxVideoBitrate() {
    if (!this._priv.abrManager) {
      return this._priv.initialMaxAutoBitrates.video;
    }
    return this._priv.abrManager.getMaxAutoBitrate("video");
  };

  /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */


  Player.prototype.getMaxAudioBitrate = function getMaxAudioBitrate() {
    if (!this._priv.abrManager) {
      return this._priv.initialMaxAutoBitrates.audio;
    }
    return this._priv.abrManager.getMaxAutoBitrate("audio");
  };

  /**
   * Play/Resume the current video.
   */


  Player.prototype.play = function play() {
    this.videoElement.play();
  };

  /**
   * Pause playback of the video.
   */


  Player.prototype.pause = function pause() {
    this.videoElement.pause();
  };

  /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */


  Player.prototype.setPlaybackRate = function setPlaybackRate(rate) {
    this._priv.speed$.next(rate);
  };

  /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */


  Player.prototype.seekTo = function seekTo(time) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(this._priv.manifest, "player: no manifest loaded");

    var positionWanted = void 0;
    var type = typeof time === "undefined" ? "undefined" : _typeof(time);

    if (type === "number") {
      positionWanted = time;
    } else if (type === "object") {
      var currentTs = this.videoElement.currentTime;
      if (time.relative != null) {
        positionWanted = currentTs + time.relative;
      } else if (time.position != null) {
        positionWanted = time.position;
      } else if (time.wallClockTime) {
        positionWanted = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__manifest_timings_js__["b" /* fromWallClockTime */])(time.wallClockTime * 1000, this._priv.manifest);
      } else {
        throw new Error("invalid time object. You must set one of the " + "following properties: \"relative\", \"position\" or " + "\"wallClockTime\"");
      }
    }

    if (positionWanted === undefined) {
      throw new Error("invalid time given");
    }

    this.videoElement.currentTime = positionWanted;
    return positionWanted;
  };

  Player.prototype.exitFullscreen = function exitFullscreen() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__compat__["c" /* exitFullscreen */])();
  };

  /**
   * Set/exit fullScreen.
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */


  Player.prototype.setFullscreen = function setFullscreen() {
    var goFull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (goFull) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__compat__["d" /* requestFullscreen */])(this.videoElement);
    } else {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__compat__["c" /* exitFullscreen */])();
    }
  };

  /**
   * Set the player's volume. From 0 (muted volume) to 1 (maximum volume).
   * @param {Number}
   */


  Player.prototype.setVolume = function setVolume(volume) {
    if (volume !== this.videoElement.volume) {
      this.videoElement.volume = volume;
      this.trigger("volumeChange", volume);
    }
  };

  /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */


  Player.prototype.isMute = function isMute() {
    return !this.getVolume();
  };

  /**
   * Set the volume to 0 and save current one for when unmuted.
   */


  Player.prototype.mute = function mute() {
    this._priv.mutedMemory = this.getVolume();
    this.setVolume(0);
  };

  /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */


  Player.prototype.unMute = function unMute() {
    var vol = this.getVolume();
    if (vol === 0) {
      this.setVolume(this._priv.mutedMemory || DEFAULT_UNMUTED_VOLUME);
    }
  };

  /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */


  Player.prototype.setVideoBitrate = function setVideoBitrate(btr) {
    this._priv.manualBitrates.video = btr;
    if (this._priv.abrManager) {
      this._priv.abrManager.setManualBitrate("video", btr);
    }
  };

  /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */


  Player.prototype.setAudioBitrate = function setAudioBitrate(btr) {
    this._priv.manualBitrates.audio = btr;
    if (this._priv.abrManager) {
      this._priv.abrManager.setManualBitrate("audio", btr);
    }
  };

  /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */


  Player.prototype.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
    // set it for the next content loaded
    this._priv.initialMaxAutoBitrates.video = btr;

    // set it for the current if one is loaded
    if (this._priv.abrManager) {
      this._priv.abrManager.setMaxAutoBitrate("video", btr);
    }
  };

  /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */


  Player.prototype.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
    // set it for the next content loaded
    this._priv.initialMaxAutoBitrates.audio = btr;

    // set it for the current if one is loaded
    if (this._priv.abrManager) {
      this._priv.abrManager.setMaxAutoBitrate("audio", btr);
    }
  };

  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */


  Player.prototype.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
    this._priv.maxBufferBehind$.next(depthInSeconds);
  };

  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */


  Player.prototype.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
    this._priv.maxBufferAhead$.next(depthInSeconds);
  };

  /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */


  Player.prototype.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
    this._priv.wantedBufferAhead$.next(sizeInSeconds);
  };

  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */


  Player.prototype.getMaxBufferBehind = function getMaxBufferBehind() {
    return this._priv.maxBufferBehind$.getValue();
  };

  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */


  Player.prototype.getMaxBufferAhead = function getMaxBufferAhead() {
    return this._priv.maxBufferAhead$.getValue();
  };

  /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */


  Player.prototype.getWantedBufferAhead = function getWantedBufferAhead() {
    return this._priv.wantedBufferAhead$.getValue();
  };

  /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */


  Player.prototype.getCurrentKeySystem = function getCurrentKeySystem() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__eme__["b" /* getCurrentKeySystem */])();
  };

  /**
   * @returns {Array.<Object>|null}
   */


  Player.prototype.getAvailableAudioTracks = function getAvailableAudioTracks() {
    if (!this._priv.languageManager) {
      return null;
    }
    return this._priv.languageManager.getAvailableAudioTracks();
  };

  /**
   * @returns {Array.<Object>|null}
   */


  Player.prototype.getAvailableTextTracks = function getAvailableTextTracks() {
    if (!this._priv.languageManager) {
      return null;
    }
    return this._priv.languageManager.getAvailableTextTracks();
  };

  /**
   * Returns last chosen language.
   * @returns {string}
   */


  Player.prototype.getAudioTrack = function getAudioTrack() {
    if (!this._priv.languageManager) {
      return undefined;
    }
    return this._priv.languageManager.getCurrentAudioTrack();
  };

  /**
   * Returns last chosen subtitle.
   * @returns {string}
   */


  Player.prototype.getTextTrack = function getTextTrack() {
    if (!this._priv.languageManager) {
      return undefined;
    }
    return this._priv.languageManager.getCurrentTextTrack();
  };

  /**
   * Update the audio language.
   * @param {string} audioId
   */


  Player.prototype.setAudioTrack = function setAudioTrack(audioId) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(this._priv.languageManager, "No compatible content launched.");
    try {
      this._priv.languageManager.setAudioTrackByID(audioId);
    } catch (e) {
      throw new Error("player: unknown audio track");
    }
  };

  /**
   * Update the audio language.
   * @param {string} sub
   */


  Player.prototype.setTextTrack = function setTextTrack(textId) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(this._priv.languageManager, "No compatible content launched.");
    try {
      this._priv.languageManager.setTextTrackByID(textId);
    } catch (e) {
      throw new Error("player: unknown text track");
    }
  };

  Player.prototype.disableTextTrack = function disableTextTrack() {
    if (!this._priv.languageManager) {
      return undefined;
    }
    return this._priv.languageManager.disableTextTrack();
  };

  Player.prototype.getImageTrackData = function getImageTrackData() {
    if (!this._priv.manifest) {
      return null;
    }
    return this._priv.currentImagePlaylist;
  };

  Player.prototype.getMinimumPosition = function getMinimumPosition() {
    if (!this._priv.manifest) {
      return null;
    }
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__manifest_timings_js__["c" /* getMinimumBufferPosition */])(this._priv.manifest);
  };

  Player.prototype.getMaximumPosition = function getMaximumPosition() {
    if (!this._priv.manifest) {
      return null;
    }
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__manifest_timings_js__["d" /* getMaximumBufferPosition */])(this._priv.manifest);
  };

  return Player;
}(__WEBPACK_IMPORTED_MODULE_6__utils_eventemitter__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Player);

/***/ }),
/* 756 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = inferPlayerState;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(148);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns current playback state for the current content.
 * /!\ Only pertinent for a content that is currently loaded and playing
 * (i.e. not loading, ended or stopped).
 * @param {Boolean} isPlaying - Whether the player is currently playing
 * (not paused).
 * @param {Boolean} stalled - Whether the player is currently "stalled".
 *
 * @returns {string}
 */
function inferPlayerState(isPlaying, stalled) {
  if (stalled) {
    return stalled.state == "seeking" ? __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* PLAYER_STATES */].SEEKING : __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* PLAYER_STATES */].BUFFERING;
  }

  if (isPlaying) {
    return __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* PLAYER_STATES */].PLAYING;
  }

  return __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* PLAYER_STATES */].PAUSED;
}

/***/ }),
/* 757 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Try to find the given track config in the adaptations given:
 *
 * If no track config return null.
 * If no adaptation are found return undefined.
 *
 * @param {Array.<Object>} adaptations
 * @param {Object} trackConfig
 * @param {string} trackConfig.language
 * @param {string} trackConfig.normalized
 * @param {Boolean} trackConfig.closedCaption
 * @return {null|undefined|Object}
 */
var findTextAdaptation = function findTextAdaptation(adaptations, trackConfig) {
  if (!trackConfig) {
    return null;
  }

  if (!adaptations.length) {
    return void 0;
  }

  var foundTextTrack = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(adaptations, function (textAdaptation) {
    return trackConfig.normalized === textAdaptation.normalizedLanguage && trackConfig.closedCaption === textAdaptation.isClosedCaption;
  });

  return foundTextTrack;
};

/**
 * Try to find the given track config in the adaptations given:
 *
 * If no track config return null.
 * If no adaptation are found return undefined.
 *
 * @param {Array.<Object>} adaptations
 * @param {Object} trackConfig
 * @param {string} trackConfig.language
 * @param {string} trackConfig.normalized
 * @param {string} trackConfig.audioDescription
 * @return {null|undefined|Object}
 */
var findAudioAdaptation = function findAudioAdaptation(adaptations, trackConfig) {
  if (!adaptations.length || !trackConfig) {
    return undefined;
  }

  var foundAudioTrack = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(adaptations, function (audioAdaptation) {
    return trackConfig.normalized === audioAdaptation.normalizedLanguage && trackConfig.audioDescription === audioAdaptation.isAudioDescription;
  });
  return foundAudioTrack;
};

/**
 * # LanguageManager
 *
 * ## Overview
 *
 * Takes in the text and audio adaptations parsed from a manifest and provide
 * various methods and properties to set/get the right adaption based on a
 * language configuration.
 */

var LanguageManager = function () {
  /**
   * @constructor
   *
   * @param {Object} adaptations
   * @param {Array.<Adaptation>} adaptations.audio - The different audio
   * adaptations available right now.
   * Can be updated through the updateAdaptations method.
   * @param {Array.<Adaptation>} adaptations.text - The different text
   * adaptations available right now.
   * Can be updated through the updateAdaptations method.
   *
   * @param {Object} adaptations$
   * @param {Subject} adaptations$.audio$ - Subject through which the chosen
   * audio adaptation will be emitted.
   * @param {Subject} adaptations$.text$ - Subject through which the chosen
   * text adaptation will be emitted
   */
  function LanguageManager(_ref, _ref2) {
    var text = _ref.text,
        audio = _ref.audio;
    var text$ = _ref2.text$,
        audio$ = _ref2.audio$;

    _classCallCheck(this, LanguageManager);

    var textAdaptations = text || [];
    var audioAdaptations = audio || [];

    this._currentAudioAdaptation = undefined;
    this._currentTextAdaptation = undefined;
    this._textAdaptations = textAdaptations;
    this._audioAdaptations = audioAdaptations;
    this._text$ = text$;
    this._audio$ = audio$;
  }

  LanguageManager.prototype.updateAdaptations = function updateAdaptations(_ref3) {
    var audio = _ref3.audio,
        text = _ref3.text;

    this._audioAdaptations = audio || [];
    this._textAdaptations = text || [];

    var currentAudioAdaptation = this._currentAudioAdaptation;
    var currentAudioId = currentAudioAdaptation && currentAudioAdaptation.id;

    var audioAdaptationFound = void 0;
    if (currentAudioId != null) {
      audioAdaptationFound = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(audio, function (_ref4) {
        var id = _ref4.id;
        return id === currentAudioId;
      });
    }

    if (!audioAdaptationFound) {
      var foundTrack = findAudioAdaptation(audio, {
        language: currentAudioAdaptation.language,
        audioDescription: !!currentAudioAdaptation.isAudioDescription
      });

      var chosenTrack = foundTrack || audio[0] || null;
      if (this._currentAudioAdaptation !== chosenTrack) {
        this._currentAudioAdaptation = chosenTrack;
        this._audio$.next(this._currentAudioAdaptation);
      }
    }

    var currentTextAdaptation = this._currentTextAdaptation;
    var currentTextId = currentTextAdaptation && currentTextAdaptation.id;

    var textAdaptationFound = void 0;
    if (currentTextId != null) {
      textAdaptationFound = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(text, function (_ref5) {
        var id = _ref5.id;
        return id === currentTextId;
      });
    }

    if (currentTextId !== null && !textAdaptationFound) {
      var _foundTrack = findTextAdaptation(text, {
        language: currentTextAdaptation.language,
        closedCaption: !!currentTextAdaptation.isClosedCaption
      });

      var _chosenTrack = _foundTrack || text[0];
      if (this._currentTextAdaptation !== _chosenTrack) {
        this._currentTextAdaptation = _chosenTrack;
        this._text$.next(this._currentTextAdaptation);
      }
    }
  };

  /**
   * Set the audio track based on its configuration.
   * @param {Object} wantedTrack
   * @param {string} wantedTrack.language
   * @param {string} wantedTrack.normalized
   * @param {Boolean} wantedTrack.audioDescription
   */


  LanguageManager.prototype.setAudioTrackByConfiguration = function setAudioTrackByConfiguration(wantedTrack) {
    var chosenAdaptation = wantedTrack ? findAudioAdaptation(this._audioAdaptations, wantedTrack) || this._audioAdaptations[0] : this._audioAdaptations[0];

    if (chosenAdaptation === undefined) {
      throw new Error("Audio Track not found.");
    }
    if (chosenAdaptation !== this._currentAudioAdaptation) {
      this._currentAudioAdaptation = chosenAdaptation;
      this._audio$.next(this._currentAudioAdaptation);
    }
  };

  /**
   * Set the text track based on its configuration.
   * @param {Object} wantedTrack
   * @param {string} wantedTrack.language
   * @param {string} wantedTrack.normalized
   * @param {Boolean} wantedTrack.closedCaption
   */


  LanguageManager.prototype.setTextTrackByConfiguration = function setTextTrackByConfiguration(wantedTrack) {
    var chosenAdaptation = wantedTrack ? findTextAdaptation(this._textAdaptations, wantedTrack) || null : null;

    if (chosenAdaptation === undefined) {
      throw new Error("Text Track not found.");
    }
    if (chosenAdaptation !== this._currentTextAdaptation) {
      this._currentTextAdaptation = chosenAdaptation;
      this._text$.next(this._currentTextAdaptation);
    }
  };

  /**
   * @param {string|Number} wantedId - adaptation id of the wanted track
   * @throws Error - Throws if the given id is not found in any audio adaptation
   */


  LanguageManager.prototype.setAudioTrackByID = function setAudioTrackByID(wantedId) {
    var foundTrack = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(this._audioAdaptations, function (_ref6) {
      var id = _ref6.id;
      return id === wantedId;
    });

    if (foundTrack === undefined) {
      throw new Error("Audio Track not found.");
    }

    if (this._currentAudioAdaptation !== foundTrack) {
      this._currentAudioAdaptation = foundTrack;
      this._audio$.next(this._currentAudioAdaptation);
    }
  };

  /**
   * @param {string|Number} wantedId - adaptation id of the wanted track
   * @throws Error - Throws if the given id is not found in any text adaptation
   */


  LanguageManager.prototype.setTextTrackByID = function setTextTrackByID(wantedId) {
    var foundTrack = __WEBPACK_IMPORTED_MODULE_0_array_find___default()(this._textAdaptations, function (_ref7) {
      var id = _ref7.id;
      return id === wantedId;
    });

    if (foundTrack === undefined) {
      throw new Error("Text Track not found.");
    }

    if (this._currentTextAdaptation !== foundTrack) {
      this._currentTextAdaptation = foundTrack;
      this._text$.next(this._currentTextAdaptation);
    }
  };

  LanguageManager.prototype.disableTextTrack = function disableTextTrack() {
    if (this._currentTextAdaptation === null) {
      return;
    }
    this._currentTextAdaptation = null;
    this._text$.next(this._currentTextAdaptation);
  };

  LanguageManager.prototype.getCurrentAudioTrack = function getCurrentAudioTrack() {
    var adaptation = this._currentAudioAdaptation;
    if (!adaptation) {
      return null;
    }
    return {
      language: adaptation.language,
      normalized: adaptation.normalizedLanguage,
      audioDescription: adaptation.isAudioDescription,
      id: adaptation.id
    };
  };

  LanguageManager.prototype.getCurrentTextTrack = function getCurrentTextTrack() {
    var adaptation = this._currentTextAdaptation;
    if (!adaptation) {
      return null;
    }
    return {
      language: adaptation.language,
      normalized: adaptation.normalizedLanguage,
      closedCaption: adaptation.isClosedCaption,
      id: adaptation.id
    };
  };

  LanguageManager.prototype.getAvailableAudioTracks = function getAvailableAudioTracks() {
    var currentTrack = this._currentAudioAdaptation;
    var currentId = currentTrack && currentTrack.id;
    return this._audioAdaptations.map(function (adaptation) {
      return {
        language: adaptation.language,
        normalized: adaptation.normalizedLanguage,
        audioDescription: adaptation.isAudioDescription,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id
      };
    });
  };

  LanguageManager.prototype.getAvailableTextTracks = function getAvailableTextTracks() {
    var currentTrack = this._currentTextAdaptation;
    var currentId = currentTrack && currentTrack.id;
    return this._textAdaptations.map(function (adaptation) {
      return {
        language: adaptation.language,
        normalized: adaptation.normalizedLanguage,
        closedCaption: adaptation.isClosedCaption,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id
      };
    });
  };

  return LanguageManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (LanguageManager);

/***/ }),
/* 758 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parseConstructorOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return parseLoadVideoOptions; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_takeFirstDefined_js__ = __webpack_require__(840);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_languages__ = __webpack_require__(108);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var DEFAULT_AUTO_PLAY = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_AUTO_PLAY,
    DEFAULT_INITIAL_BITRATES = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_INITIAL_BITRATES,
    DEFAULT_LIMIT_VIDEO_WIDTH = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_LIMIT_VIDEO_WIDTH,
    DEFAULT_MAX_BITRATES = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_MAX_BITRATES,
    DEFAULT_MAX_BUFFER_AHEAD = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_MAX_BUFFER_AHEAD,
    DEFAULT_MAX_BUFFER_BEHIND = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_MAX_BUFFER_BEHIND,
    DEFAULT_SHOW_NATIVE_SUBTITLE = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_SHOW_NATIVE_SUBTITLE,
    DEFAULT_TEXT_TRACK_MODE = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_TEXT_TRACK_MODE,
    DEFAULT_THROTTLE_WHEN_HIDDEN = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_THROTTLE_WHEN_HIDDEN,
    DEFAULT_WANTED_BUFFER_AHEAD = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_WANTED_BUFFER_AHEAD;


var def = __WEBPACK_IMPORTED_MODULE_1__utils_takeFirstDefined_js__["a" /* default */];

/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object} [options={}]
 * @returns {Object}
 */
function parseConstructorOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var parsed = {
    maxBufferAhead: def(options.maxBufferAhead, DEFAULT_MAX_BUFFER_AHEAD),
    maxBufferBehind: def(options.maxBufferBehind, DEFAULT_MAX_BUFFER_BEHIND),
    limitVideoWidth: def(options.limitVideoWidth, DEFAULT_LIMIT_VIDEO_WIDTH),
    videoElement: options.videoElement || document.createElement("video"),
    wantedBufferAhead: def(options.wantedBufferAhead, DEFAULT_WANTED_BUFFER_AHEAD),

    throttleWhenHidden: def(options.throttleWhenHidden, DEFAULT_THROTTLE_WHEN_HIDDEN)
  };

  var defaultInitialBitrates = DEFAULT_INITIAL_BITRATES || {};
  var defaultMaxBitrates = DEFAULT_MAX_BITRATES || {};
  parsed.initialAudioBitrate = def(options.initialAudioBitrate, defaultInitialBitrates.audio, defaultInitialBitrates.other);
  parsed.initialVideoBitrate = def(options.initialVideoBitrate, defaultInitialBitrates.video, defaultInitialBitrates.other);

  parsed.maxAudioBitrate = def(options.maxAudioBitrate, defaultMaxBitrates.audio, defaultMaxBitrates.other);
  parsed.maxVideoBitrate = def(options.maxVideoBitrate, defaultMaxBitrates.video, defaultMaxBitrates.other);
  return parsed;
}

/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object} [options={}]
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */
function parseLoadVideoOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var parsed = {
    url: options.url,
    transport: options.transport,
    autoPlay: def(options.autoPlay, DEFAULT_AUTO_PLAY),
    keySystems: def(options.keySystems, []),
    transportOptions: options.transportOptions,
    supplementaryTextTracks: def(options.supplementaryTextTracks, []),
    supplementaryImageTracks: def(options.supplementaryImageTracks, []),
    textTrackMode: def(options.textTrackMode, DEFAULT_TEXT_TRACK_MODE),
    defaultAudioTrack: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_languages__["b" /* normalizeAudioTrack */])(options.defaultAudioTrack),
    defaultTextTrack: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_languages__["c" /* normalizeTextTrack */])(options.defaultTextTrack),

    hideNativeSubtitle: def(options.hideNativeSubtitle, !DEFAULT_SHOW_NATIVE_SUBTITLE)

  };

  if (options.textTrackMode === "html") {
    parsed.textTrackElement = options.textTrackElement;
  }

  if (options.startAt && options.startAt.wallClockTime instanceof Date) {
    parsed.startAt = __WEBPACK_IMPORTED_MODULE_2_object_assign___default()({}, options.startAt, {
      wallClockTime: options.startAt.wallClockTime / 1000
    });
  } else {
    parsed.startAt = options.startAt;
  }

  if (options.directFile) {
    parsed.transport = "directfile";
  }

  return parsed;
}



/***/ }),
/* 759 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_deep_equal__ = __webpack_require__(653);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_deep_equal___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_deep_equal__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__manifest_timings_js__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__language_manager_js__ = __webpack_require__(757);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use self file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines the private methods of the API.
 * This is isolated from the rest of the player class for different reasons:
 *
 *   - There is many private methods which "pollutes" the namespace, when a
 *     user wants to experiment the player (e.g. in a console).
 *
 *   - The player keeps a lot of state, which can be subject to change with
 *     future features. Keeping it isolated helps to know which one / convince
 *     users to not rely on them.
 */












/* harmony default export */ __webpack_exports__["a"] = (function (self) {
  return {
    /**
     * Reset all states relative to a playing content.
     */
    resetContentState: function resetContentState() {
      // language management
      self._priv.initialAudioTrack = undefined;
      self._priv.initialTextTrack = undefined;
      self._priv.languageManager = null;

      self._priv.abrManager = null;

      self._priv.manifest = null;
      self._priv.currentRepresentations = {};
      self._priv.currentAdaptations = {};

      self._priv.recordedEvents = {}; // event memory

      self._priv.fatalError = null;
      self._priv.currentImagePlaylist = null;
    },


    /**
     * Store and emit new player state (e.g. text track, videoBitrate...).
     * We check for deep equality to avoid emitting 2 consecutive times the same
     * state.
     * @param {string} type - the type of the updated state (videoBitrate...)
     * @param {*} value - its new value
     */
    recordState: function recordState(type, value) {
      var prev = self._priv.recordedEvents[type];
      if (!__WEBPACK_IMPORTED_MODULE_0_deep_equal___default()(prev, value)) {
        self._priv.recordedEvents[type] = value;
        self.trigger(type + "Change", value);
      }
    },


    /**
     * Called each time the Stream Observable emits.
     * @param {Object} streamInfos - payload emitted
     */
    onStreamNext: function onStreamNext(streamInfos) {
      var type = streamInfos.type,
          value = streamInfos.value;


      switch (type) {
        case "representationChange":
          self._priv.onRepresentationChange(value);
          break;
        case "manifestUpdate":
          self._priv.onManifestUpdate(value);
          break;
        case "adaptationChange":
          self._priv.onAdaptationChange(value);
          break;
        case "bitrateEstimationChange":
          self._priv.onBitrateEstimationChange(value);
          break;
        case "manifestChange":
          self._priv.onManifestChange(value);
          break;
        case "pipeline":
          var bufferType = value.bufferType,
              parsed = value.parsed;

          if (bufferType === "image") {
            var _value = parsed.segmentData;

            // TODO merge multiple data from the same track together
            self._priv.currentImagePlaylist = _value;
            self.trigger("imageTrackUpdate", {
              data: self._priv.currentImagePlaylist
            });
          }
      }
    },


    /**
     * Called each time the Stream emits through its errorStream (non-fatal
     * errors).
     * @param {Object} streamInfos
     */
    onErrorStreamNext: function onErrorStreamNext(error) {
      self.trigger("warning", error);
    },


    /**
     * Called when the Stream instance throws (fatal errors).
     * @param {Object} streamInfos
     */
    onStreamError: function onStreamError(error) {
      self._priv.resetContentState();
      self._priv.fatalError = error;
      self._priv.unsubscribeLoadedVideo$.next();
      self._priv.setPlayerState(__WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* PLAYER_STATES */].STOPPED);

      // TODO This condition is here because the eventual callback called when the
      // player state is updated can launch a new content, thus the error will not
      // be here anymore, in which case triggering the "error" event is unwanted.
      // This is not perfect however as technically, this condition could be true
      // even for a new content (I cannot see it happen with the current code but
      // that's not a reason). In that case, "error" would be triggered 2 times.
      // Find a better solution.
      if (self._priv.fatalError === error) {
        self.trigger("error", error);
      }
    },


    /**
     * Called when the Stream instance complete.
     * @param {Object} streamInfos
     */
    onStreamComplete: function onStreamComplete() {
      self._priv.resetContentState();
      self._priv.unsubscribeLoadedVideo$.next();
      self._priv.setPlayerState(__WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* PLAYER_STATES */].ENDED);
    },


    /**
     * Called when the manifest is first downloaded.
     * @param {Object} value
     * @param {Manifest} value.manifest - The Manifest instance
     * @param {Subject} value.adaptations$ - Subject to emit the chosen
     * adaptation for each type.
     */
    onManifestChange: function onManifestChange(value) {
      if (true) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(value && value.manifest, "no manifest received");
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(value && value.adaptations$, "no adaptations subject received");
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(value && value.abrManager, "no ABR Manager received");
      }

      var manifest = value.manifest,
          _value$adaptations$ = value.adaptations$,
          adaptations$ = _value$adaptations$ === undefined ? {} : _value$adaptations$;

      self._priv.manifest = manifest;

      // set language management for audio and text
      self._priv.languageManager = new __WEBPACK_IMPORTED_MODULE_5__language_manager_js__["a" /* default */](manifest.adaptations, {
        audio$: adaptations$.audio,
        text$: adaptations$.text
      });

      // Set first adaptation chosen
      Object.keys(adaptations$).forEach(function (type) {
        // audio and text are completely managed by the languageManager
        if (type === "audio") {
          self._priv.languageManager.setAudioTrackByConfiguration(self._priv.initialAudioTrack);
        } else if (type === "text") {
          self._priv.languageManager.setTextTrackByConfiguration(self._priv.initialTextTrack);
        } else {
          var adaptations = manifest.adaptations[type] || [];
          adaptations$[type].next(adaptations[0] || null);
        }
      });

      self._priv.abrManager = value.abrManager;

      self.trigger("manifestChange", manifest);
    },
    onManifestUpdate: function onManifestUpdate(value) {
      if (true) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(value && value.manifest, "no manifest received");
      }

      var manifest = value.manifest;

      self._priv.manifest = manifest;
      self._priv.languageManager.updateAdaptations(manifest.adaptations);

      self.trigger("manifestUpdate", manifest);
    },


    /**
     * @param {Object} obj
     * @param {string} obj.type
     * @param {Object} obj.adaptation
     */
    onAdaptationChange: function onAdaptationChange(_ref) {
      var type = _ref.type,
          adaptation = _ref.adaptation;

      self._priv.currentAdaptations[type] = adaptation;

      // TODO Emit adaptationChange?

      if (!self._priv.languageManager) {
        return;
      }
      if (type === "audio") {
        var audioTrack = self._priv.languageManager.getCurrentAudioTrack();
        self._priv.recordState("audioTrack", audioTrack);
      } else if (type === "text") {
        var textTrack = self._priv.languageManager.getCurrentTextTrack();
        self._priv.recordState("textTrack", textTrack);
      }
    },


    /**
     * Called each time a representation changes.
     * @param {Object} obj
     * @param {string} obj.type
     * @param {Object} obj.representation
     */
    onRepresentationChange: function onRepresentationChange(_ref2) {
      var type = _ref2.type,
          representation = _ref2.representation;

      self._priv.currentRepresentations[type] = representation;

      var bitrate = representation && representation.bitrate;
      if (bitrate != null) {
        self._priv.lastBitrates[type] = bitrate;
      }

      // TODO Emit representationChange?

      if (type == "video") {
        self._priv.recordState("videoBitrate", bitrate != null ? bitrate : -1);
      } else if (type == "audio") {
        self._priv.recordState("audioBitrate", bitrate != null ? bitrate : -1);
      }
    },
    onBitrateEstimationChange: function onBitrateEstimationChange(_ref3) {
      var type = _ref3.type,
          bitrate = _ref3.bitrate;

      if (true) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(type != null);
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_assert__["a" /* default */])(bitrate != null);
      }
      self._priv.recordState("bitrateEstimation", { type: type, bitrate: bitrate });
    },


    /**
     * Called each time the player alternates between play and pause.
     * @param {Boolean} isPlaying
     */
    onPlayPauseNext: function onPlayPauseNext(isPlaying) {
      if (self.videoElement.ended !== true) {
        self._priv.playing$.next(isPlaying);
      }
    },


    /**
     * Called each time a textTrack is added to the video DOM Element.
     * @param {Array.<TextTrackElement} tracks
     */
    onNativeTextTracksNext: function onNativeTextTracksNext(tracks) {
      self.trigger("nativeTextTracksChange", tracks);
    },


    /**
     * Called each time the player state updates.
     * @param {string} s
     */
    setPlayerState: function setPlayerState(s) {
      if (self.state !== s) {
        self.state = s;
        __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("playerStateChange", s);
        self.trigger("playerStateChange", s);
      }
    },


    /**
     * Called each time a new timing object is emitted.
     * @param {Object} timing
     */
    triggerTimeChange: function triggerTimeChange(timing) {
      if (!self._priv.manifest || !timing) {
        return;
      }

      var positionData = {
        position: timing.currentTime,
        duration: timing.duration,
        playbackRate: timing.playbackRate,

        // TODO fix higher up?
        bufferGap: isFinite(timing.bufferGap) ? timing.bufferGap : 0
      };

      if (self._priv.manifest.isLive && timing.currentTime > 0) {
        positionData.wallClockTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__manifest_timings_js__["a" /* toWallClockTime */])(timing.currentTime, self._priv.manifest).getTime() / 1000;
        positionData.liveGap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__manifest_timings_js__["d" /* getMaximumBufferPosition */])(self._priv.manifest) - timing.currentTime;
      }

      self.trigger("positionUpdate", positionData);
    }
  };
});

/***/ }),
/* 760 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cleanBuffer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_ranges_js__ = __webpack_require__(54);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */
function cleanBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
  if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
  }

  var cleanedupRanges = [];

  var _getInnerAndOuterTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_ranges_js__["g" /* getInnerAndOuterTimeRanges */])(qSourceBuffer.getBuffered(), position),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var collectBufferBehind = function collectBufferBehind() {
    if (!isFinite(maxBufferBehind)) {
      return;
    }

    // begin from the oldest
    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];
      if (position - maxBufferBehind >= outerRange.end) {
        cleanedupRanges.push(outerRange);
      } else if (position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end) {
        cleanedupRanges.push({
          start: outerRange.start,
          end: position - maxBufferBehind
        });
      }
    }
    if (innerRange) {
      if (position - maxBufferBehind > innerRange.start) {
        cleanedupRanges.push({
          start: innerRange.start,
          end: position - maxBufferBehind
        });
      }
    }
  };

  var collectBufferAhead = function collectBufferAhead() {
    if (!isFinite(maxBufferAhead)) {
      return;
    }

    // begin from the oldest
    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];
      if (position + maxBufferAhead <= outerRange.start) {
        cleanedupRanges.push(outerRange);
      } else if (position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: outerRange.end
        });
      }
    }
    if (innerRange) {
      if (position + maxBufferAhead < innerRange.end) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: innerRange.end
        });
      }
    }
  };

  collectBufferBehind();
  collectBufferAhead();
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].from(cleanedupRanges.map(function (range) {
    return qSourceBuffer.removeBuffer(range);
  })).concatAll().ignoreElements();
}

/***/ }),
/* 761 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = launchGarbageCollector;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__ = __webpack_require__(54);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var GC_GAP_CALM = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].BUFFER_GC_GAPS.CALM;
var GC_GAP_BEEFY = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].BUFFER_GC_GAPS.BEEFY;

/**
 * Buffer garbage collector algorithm. Tries to free up some part of
 * the ranges that are distant from the current playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Range>} - Ranges selected for clean up
 */
function selectGCedRanges(currentTime, buffered, gcGap) {
  var _getInnerAndOuterTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__["g" /* getInnerAndOuterTimeRanges */])(buffered, currentTime),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var cleanedupRanges = [];

  // start by trying to remove all ranges that do not contain the
  // current time and respect the gcGap
  // respect the gcGap? FIXME?
  for (var i = 0; i < outerRanges.length; i++) {
    var outerRange = outerRanges[i];
    if (currentTime - gcGap < outerRange.end) {
      cleanedupRanges.push(outerRange);
    } else if (currentTime + gcGap > outerRange.start) {
      cleanedupRanges.push(outerRange);
    }
  }

  // try to clean up some space in the current range
  if (innerRange) {
    __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].debug("buffer: gc removing part of inner range", cleanedupRanges);
    if (currentTime - gcGap > innerRange.start) {
      cleanedupRanges.push({
        start: innerRange.start,
        end: currentTime - gcGap
      });
    }

    if (currentTime + gcGap < innerRange.end) {
      cleanedupRanges.push({
        start: currentTime + gcGap,
        end: innerRange.end
      });
    }
  }

  return cleanedupRanges;
}

/**
 * Run the garbage collector.
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 * @param {Observable} timings$
 * @param {QueuedSourceBuffer} bufferingQueue
 * @returns {Observable}
 */
function launchGarbageCollector(timings$, bufferingQueue) {
  __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("buffer: running garbage collector");

  // wait for next timing event
  return timings$.take(1).mergeMap(function (timing) {
    var buffered = bufferingQueue.getBuffered();
    var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM);

    // more aggressive GC if we could not find any range to clean
    if (cleanedupRanges.length === 0) {
      cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);
    }

    __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].debug("buffer: gc cleaning", cleanedupRanges);
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].from(cleanedupRanges.map(function (range) {
      return bufferingQueue.removeBuffer(range);
    })).concatAll();
  });
}

/***/ }),
/* 762 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmptyBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_collections__ = __webpack_require__(834);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_ranges_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__segment_bookkeeper_js__ = __webpack_require__(764);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__queued_source_buffer_js__ = __webpack_require__(763);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__gc_js__ = __webpack_require__(761);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__cleanBuffer_js__ = __webpack_require__(760);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















var BITRATE_REBUFFERING_RATIO = __WEBPACK_IMPORTED_MODULE_3__config_js__["a" /* default */].BITRATE_REBUFFERING_RATIO;

/**
 * Calculate start and end timestamps of the wanted buffer.
 * @param {TimeRanges} buffered - TimeRanges coming from the concerned
 * SourceBuffer
 * @param {Object} clock
 * @param {Number} bufferGoal
 * @param {Object} paddings
 * @param {Number} paddings.low
 * @param {Number} paddings.high
 * @returns {Object} - Start and end timestamps, in seconds, under an object
 * form with two properties:
 *   - start {Number}
 *   - end {Number}
 */

function getWantedBufferRange(buffered, clock, bufferGoal, paddings) {
  var lowPadding = paddings.low,
      highPadding = paddings.high;

  var timestamp = clock.currentTime + clock.timeOffset;

  // wantedBufferSize calculates the size of the buffer we want to ensure,
  // taking into account the min between: the set max buffer size, the
  // duration and the live gap.
  var endDiff = (clock.duration || Infinity) - timestamp;
  var wantedBufferSize = Math.max(0, clock.liveGap == null ? Math.min(bufferGoal, endDiff) : Math.min(bufferGoal, clock.liveGap, endDiff));

  var bufferGap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_ranges_js__["a" /* getLeftSizeOfRange */])(buffered, timestamp);

  // the ts padding is the time offset that we want to apply to our current
  // timestamp in order to calculate the starting point of the list of
  // segments to inject.
  var timestampPadding = bufferGap > lowPadding && bufferGap < Infinity ? Math.min(bufferGap, highPadding) : 0;

  return {
    start: timestamp + timestampPadding,
    end: timestamp + wantedBufferSize
  };
}

/**
 * Manage a single buffer:
 *   - load the right segments through the downloader on normal playback /
 *     seeking / as the adaptation chosen changes
 *   - add those to the sourceBuffer
 *   - clean up if too much segments have been loaded
 *
 * TODO too many parameters?
 * @param {Object} opt
 * @param {SourceBuffer} opt.sourceBuffer
 * @param {Function} opt.downloader
 * @param {Observable} opt.switch$
 * @param {Observable} opt.clock
 * @param {Number} opt.wantedBufferAhead
 * @param {Number} opt.maxBufferBehind
 * @param {Number} opt.maxBufferAhead
 * @param {string} opt.bufferType
 * @param {Boolean} opt.isLive
 * @returns {Observable}
 */
function Buffer(_ref) {
  var sourceBuffer = _ref.sourceBuffer,
      downloader = _ref.downloader,
      switch$ = _ref.switch$,
      clock$ = _ref.clock$,
      wantedBufferAhead = _ref.wantedBufferAhead,
      maxBufferBehind = _ref.maxBufferBehind,
      maxBufferAhead = _ref.maxBufferAhead,
      bufferType = _ref.bufferType,
      isLive = _ref.isLive;


  /**
   * Saved state of an init segment to give to the downloader.
   * TODO Re-think that mess for a Buffer refacto.
   */
  var initSegmentInfos = null;

  // will be used to emit messages to the calling function
  var messageSubject = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();

  // safety level (low and high water mark) size of buffer that won't
  // be flushed when switching representation for smooth transitions
  // and avoiding buffer underflows
  var LOW_PADDING = bufferType == "video" ? 4 : 1;
  var HIGH_PADDING = bufferType == "video" ? 6 : 1;

  var bookkeeper = new __WEBPACK_IMPORTED_MODULE_8__segment_bookkeeper_js__["a" /* default */]();
  var bufferingQueue = new __WEBPACK_IMPORTED_MODULE_9__queued_source_buffer_js__["a" /* default */](sourceBuffer);

  /**
   * Returns every segments currently wanted.
   * @param {Object} adaptation - The adaptation concerned (audio/video...)
   * @param {Object} representation - The representation of the chosen
   * adaptation
   * @param {BufferedRanges} buffered - The BufferedRanges of the corresponding
   * sourceBuffer
   * @param {Object} timing - The last item emitted from clock$
   * @param {Number} bufferGoal - The last item emitted from wantedBufferAhead
   * @param {Number} bufferSize - The last item emitted from bufferSize$
   * @param {Boolean} withInitSegment - Whether we're dealing with an init
   * segment.
   * @returns {Array.<Segment>}
   * @throws IndexError - Throws if the current timestamp is considered out
   * of bounds.
   */
  function getSegmentsListToInject(representation, range, timing, withInitSegment) {
    var initSegment = null;

    if (withInitSegment) {
      __WEBPACK_IMPORTED_MODULE_4__utils_log__["a" /* default */].debug("add init segment", bufferType);
      initSegment = representation.index.getInitSegment();
    }

    if (timing.readyState === 0) {
      return initSegment ? [initSegment] : [];
    }

    var start = range.start,
        end = range.end;

    var duration = end - start;

    /**
     * TODO This is an ugly hack for now.
     * shouldRefresh returns true if, from the informations given and the type
     * of index used in the manifest, we infer that we have to refresh the
     * manifest (to get informations about subsequent needed segments).
     *
     * The problem with shouldRefresh is that depending on the type of techno,
     * we want different things:
     *
     *   - for smooth contents, index informations about a segment n is present
     *     in the container of the segment n-1. Thus, shouldRefresh should
     *     return true there if the segment n-1 has been parsed but we still
     *     miss informations about the segment n (this happens).
     *
     *   - for dash contents, we prefer to fetch the manifest as soon as we
     *     miss the informations about even one distant segment in the future.
     *     Thus, shouldRefresh should return true there if the end of the
     *     wanted range is not yet in the index.
     *
     * Doing the DASH usecase does not cause much problem (though the precision
     * of the range end could be improved).
     * The smooth usecase is however difficult to implement with the current
     * code (we have to know that we parsed the last segment from the index and
     * that we need the next segment, for which we have no information).
     * As a quick and dirty hack, we take the current time instead. If the
     * current time is well into the last segment and our range indicates
     * that we need another segment, we should refresh. However, this is not
     * efficient:
     *   - we have a high chance of rebuffering when this happens. It would
     *     be best to know that we have the last segment (one other problem is
     *     that this segment could be in another representation) before
     *     actually playing it.
     *   - the player stops usually some milliseconds before the end of the
     *     last segment, but this is not an exact thing. So we have to add
     *     rounding and infer the fact that we're well into the last segment.
     *   - for readability, it makes no sense that shouldRefresh might need
     *     the current time of playback.
     */
    var timestamp = timing.currentTime + timing.timeOffset;
    var shouldRefresh = representation.index.shouldRefresh(timestamp, start, end);
    if (shouldRefresh) {
      var error = new __WEBPACK_IMPORTED_MODULE_7__errors__["g" /* IndexError */]("OUT_OF_INDEX_ERROR", representation.index.getType(), false);
      messageSubject.next({ type: "out-of-index", value: error });
    }

    // given the current timestamp and the previously calculated time gap and
    // wanted buffer size, we can retrieve the list of segments to inject in
    // our pipelines.
    var mediaSegments = representation.index.getSegments(start, duration);

    if (initSegment) {
      mediaSegments.unshift(initSegment);
    }

    return mediaSegments;
  }

  function createRepresentationBuffer(representation) {
    __WEBPACK_IMPORTED_MODULE_4__utils_log__["a" /* default */].info("bitrate", bufferType, representation.bitrate);

    var queuedSegments = new __WEBPACK_IMPORTED_MODULE_5__utils_collections__["a" /* SimpleSet */]();

    /**
     * Returns true if it considers that the segment given should be loaded.
     * @param {Segment} segment
     * @param {Array.<number>} wantedRange
     * @returns {Boolean}
     */
    function segmentFilter(segment, wantedRange) {
      // if this segment is already in the pipeline
      var isInQueue = queuedSegments.test(segment.id);
      if (isInQueue) {
        return false;
      }

      // segment without time info are usually init segments or some
      // kind of metadata segment that we never filter out
      if (segment.isInit || segment.time < 0) {
        return true;
      }

      var time = segment.time,
          duration = segment.duration,
          timescale = segment.timescale;

      // TODO If the segment is too big, and is garbage collected immediately
      // when appended, it will be downloaded in loop, even if we have enough
      // of it to continue regular playback.
      // To avoid this behavior, we should probably indicate the wanted start
      // and end time here, and only re-download it if the segment is missing
      // part(s) of it.
      //
      // You can repeat this bug easily by setting the maxBufferBehind or
      // maxBufferAhead option for a supplementaryTextTrack

      var currentSegment = bookkeeper.hasPlayableSegment(wantedRange, time, duration, timescale);

      // only re-load comparatively-poor bitrates.
      return !currentSegment || currentSegment.bitrate * BITRATE_REBUFFERING_RATIO < representation.bitrate;
    }

    /**
     * Append buffer to the bufferingQueue.
     * If it leads to a QuotaExceededError, try to run our custom range
     * _garbage collector_.
     * @returns {Observable}
     */
    function appendDataInBuffer(pipelineData) {
      var segment = pipelineData.segment,
          parsed = pipelineData.parsed;
      var segmentData = parsed.segmentData,
          nextSegments = parsed.nextSegments,
          segmentInfos = parsed.segmentInfos;


      if (segment.isInit) {
        initSegmentInfos = segmentInfos;
      }

      // If we have informations about subsequent segments, add them to the
      // index.
      // TODO do that higher up?
      var addedSegments = nextSegments ? representation.index._addSegments(nextSegments, segmentInfos) : [];

      /**
       * Validate the segment downloaded:
       *   - remove from the queued segment to re-allow its download
       *   - insert it in the bufferedRanges object
       */
      var validateSegment = function validateSegment() {
        // Note: we should also clean when canceled/errored
        // (TODO do it when canceled?)
        queuedSegments.remove(segment.id);

        if (!segment.isInit) {
          var _ref2 = segmentInfos ? segmentInfos : segment,
              time = _ref2.time,
              duration = _ref2.duration,
              timescale = _ref2.timescale;

          // current segment timings informations are used to update
          // bufferedRanges informations


          bookkeeper.insert(segment, time / timescale, // start
          (time + duration) / timescale, // end
          representation.bitrate);
        }
      };

      var appendSegment = function appendSegment() {
        return bufferingQueue.appendBuffer(segmentData).do(validateSegment);
      };

      return appendSegment().catch(function (error) {
        if (error.name != "QuotaExceededError") {
          queuedSegments.remove(segment.id);
          throw new __WEBPACK_IMPORTED_MODULE_7__errors__["f" /* MediaError */]("BUFFER_APPEND_ERROR", error, true);
        }

        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__gc_js__["a" /* default */])(clock$, bufferingQueue).mergeMap(appendSegment).catch(function (error) {
          queuedSegments.remove(segment.id);
          throw new __WEBPACK_IMPORTED_MODULE_7__errors__["f" /* MediaError */]("BUFFER_FULL_ERROR", error, true);
        });
      }).map(function () {
        return {
          type: "pipeline",
          value: __WEBPACK_IMPORTED_MODULE_2_object_assign___default()({ bufferType: bufferType, addedSegments: addedSegments }, pipelineData)
        };
      });
    }

    /**
     * Get list of segment to injects.
     * @param {Array} combineLatestResult
     * @param {Number} injectCount
     * @returns {Observable|Array.<Segment>}
     */
    function getNeededSegments(timing, bufferGoal, injectCount) {
      var buffered = bufferingQueue.getBuffered();
      bookkeeper.addBufferedInfos(buffered);

      // send a message downstream when bumping on an explicit
      // discontinuity announced in the segment index.
      if (timing.stalled) {
        if (isLive) {
          var discontinuity = representation.index.checkDiscontinuity(timing.currentTime);
          if (discontinuity > 0) {
            messageSubject.next({
              type: "index-discontinuity",
              value: { ts: discontinuity + 1 }
            });
          }
        }
      }

      // filter out already loaded and already queued segments
      var withInitSegment = injectCount === 0;

      var wantedRange = getWantedBufferRange(buffered, timing, bufferGoal, {
        low: LOW_PADDING,
        high: HIGH_PADDING
      });

      var neededSegments = getSegmentsListToInject(representation, wantedRange, timing, withInitSegment).filter(function (segment) {
        return segmentFilter(segment, wantedRange);
      });

      // queue all segments injected in the observable
      for (var i = 0; i < neededSegments.length; i++) {
        queuedSegments.add(neededSegments[i].id);
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of.apply(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"], neededSegments);
    }

    var loadNeededSegments = function loadNeededSegments(segment) {
      return downloader({ segment: segment, representation: representation, init: initSegmentInfos }).map(function (args) {
        return __WEBPACK_IMPORTED_MODULE_2_object_assign___default()({ segment: segment }, args);
      });
    };

    var onClockTick = function onClockTick(_ref3, i) {
      var timing = _ref3[0],
          wantedBufferAhead = _ref3[1],
          maxBufferBehind = _ref3[2],
          maxBufferAhead = _ref3[3];

      var bufferGoal = Math.min(wantedBufferAhead, maxBufferAhead);
      var loadNeeded$ = getNeededSegments(timing, bufferGoal, i).concatMap(loadNeededSegments);
      var clean$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__cleanBuffer_js__["a" /* default */])(bufferingQueue, timing.currentTime, maxBufferBehind, maxBufferAhead);
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(loadNeeded$, clean$);
    };

    var segmentsPipeline = __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(clock$, wantedBufferAhead, maxBufferBehind, maxBufferAhead).mergeMap(onClockTick).concatMap(appendDataInBuffer);

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(segmentsPipeline, messageSubject).catch(function (error) {
      // For live adaptations, handle 412 errors as precondition-
      // failed errors, ie: we are requesting for segments before they
      // exist
      var isPreconditionFailedError = isLive && error.type == __WEBPACK_IMPORTED_MODULE_7__errors__["a" /* ErrorTypes */].NETWORK_ERROR && error.isHttpError(412);

      if (!isPreconditionFailedError) {
        throw error;
      }

      // 412 Precondition Failed request errors do not cause the
      // buffer to stop but are re-emitted in the stream as
      // "precondition-failed" type. They should be handled re-
      // adapting the live-gap that the player is holding
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ type: "precondition-failed", value: error }).concat(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].timer(2000)).concat(createRepresentationBuffer(representation));
    }).startWith({
      type: "representationChange",
      value: {
        type: bufferType,
        representation: representation
      }
    });
  }

  return switch$.switchMap(createRepresentationBuffer).finally(function () {
    return bufferingQueue.dispose();
  });
}

function EmptyBuffer(_ref4) {
  var bufferType = _ref4.bufferType;

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({
    type: "representationChange",
    value: {
      type: bufferType,
      representation: null
    }
  });
}



/***/ }),
/* 763 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var BUFFER_APPEND = "append";
var BUFFER_REMOVE = "remove";

/**
 * Append/Remove from sourceBuffer in a queue.
 * Wait for the previous buffer action to be finished (updateend event) to
 * perform the next in the queue.
 * @class QueuedSourceBuffer
 */

var QueuedSourceBuffer = function () {
  /**
   * @constructor
   * @param {SourceBuffer} sourceBuffer
   */
  function QueuedSourceBuffer(sourceBuffer) {
    _classCallCheck(this, QueuedSourceBuffer);

    this.buffer = sourceBuffer;
    this.queue = [];
    this.flushing = null;

    this.__onUpdate = this._onUpdate.bind(this);
    this.__onError = this._onError.bind(this);
    this.__flush = this._flush.bind(this);

    this.buffer.addEventListener("update", this.__onUpdate);
    this.buffer.addEventListener("error", this.__onError);
    this.buffer.addEventListener("updateend", this.__flush);
  }

  /**
   * Append media segment to the attached SourceBuffer, in a FIFO queue.
   * @param {ArrayBuffer} buffer
   * @returns {Observable}
   */


  QueuedSourceBuffer.prototype.appendBuffer = function appendBuffer(buffer) {
    return this._queueAction(BUFFER_APPEND, buffer);
  };

  /**
   * Remove data from the attached SourceBuffer, in a FIFO queue.
   * @param {Object} range
   * @param {Number} range.start - start position, in seconds
   * @param {Number} range.end - end position, in seconds
   * @returns {Observable}
   */


  QueuedSourceBuffer.prototype.removeBuffer = function removeBuffer(_ref) {
    var start = _ref.start,
        end = _ref.end;

    return this._queueAction(BUFFER_REMOVE, { start: start, end: end });
  };

  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */


  QueuedSourceBuffer.prototype.getBuffered = function getBuffered() {
    return this.buffer.buffered;
  };

  /**
   * Free up ressources used by this class.
   */


  QueuedSourceBuffer.prototype.dispose = function dispose() {
    this.buffer.removeEventListener("update", this.__onUpdate);
    this.buffer.removeEventListener("error", this.__onError);
    this.buffer.removeEventListener("updateend", this.__flush);
    this.buffer = null;
    this.queue.length = 0;
    this.flushing = null;
  };

  /**
   * @private
   * @param {Event} evt
   */


  QueuedSourceBuffer.prototype._onUpdate = function _onUpdate(evt) {
    if (this.flushing) {
      this.flushing.next(evt);
      this.flushing.complete();
      this.flushing = null;
    }
  };

  /**
   * @private
   * @param {Event} error
   */


  QueuedSourceBuffer.prototype._onError = function _onError(error) {
    if (this.flushing) {
      this.flushing.error(error);
      this.flushing = null;
    }
  };

  /**
   * Queue a new action.
   * Begin flushing if no action were previously in the queue.
   * @private
   * @param {string} type
   * @param {*} args
   * @returns {Subject} - Can be used to follow the buffer action advancement.
   */


  QueuedSourceBuffer.prototype._queueAction = function _queueAction(type, args) {
    var subj = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]();
    var length = this.queue.unshift({ type: type, args: args, subj: subj });
    if (length === 1) {
      this._flush();
    }
    return subj;
  };

  /**
   * Perform next queued action if one and none are pending.
   * @private
   */


  QueuedSourceBuffer.prototype._flush = function _flush() {
    if (this.flushing || this.queue.length === 0 || this.buffer.updating) {
      return;
    }

    var _queue$pop = this.queue.pop(),
        type = _queue$pop.type,
        args = _queue$pop.args,
        subj = _queue$pop.subj;

    this.flushing = subj;
    try {
      switch (type) {
        case BUFFER_APPEND:
          this.buffer.appendBuffer(args);break;
        case BUFFER_REMOVE:
          this.buffer.remove(args.start, args.end);break;
      }
    } catch (e) {
      this._onError(e);
    }
  };

  return QueuedSourceBuffer;
}();

/* harmony default export */ __webpack_exports__["a"] = (QueuedSourceBuffer);

/***/ }),
/* 764 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_takeFirstSet_js__ = __webpack_require__(841);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__ = __webpack_require__(54);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT,
    MAX_BUFFERED_DISTANCE = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].MAX_BUFFERED_DISTANCE,
    MINIMUM_SEGMENT_SIZE = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].MINIMUM_SEGMENT_SIZE;

/**
 * TODO Find what to do with that one empirically. Either delete or uncomment.
 *
 * Tolerated margin when comparing segments.
 * If the absolute difference between two segment's start time is inferior or
 * equal to this margin, we infer that they begin at the exact same time, same
 * logic for the end time (where we infer that they end at the exact same
 * time).
 * Used to know whether a newly downloaded segment replace/update an old one in
 * the bookkeeping we perform on currently downloaded segments.
 * @type {Number}
 */
// const SEGMENT_EPSILON = 0.3;

/**
 * Keep track of every segment downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN segments are already
 * downloaded, at which bitrate, and which have been garbage-collected since
 * by the browser (and thus should be re-downloaded).
 *
 * @class SegmentBookkeeper
 */

var SegmentBookkeeper = function () {
  function SegmentBookkeeper() {
    _classCallCheck(this, SegmentBookkeeper);

    /**
     * The inventory keep track of all the segments which should be currently
     * in the browser's memory.
     * This array contains objects, each being related to a single downloaded
     * segment which is at least partially added in a source buffer.
     * Those objects have the following keys:
     *
     *   - bitrate {Number}: bitrate of the representation corresponding to
     *     the segment.
     *
     *   - start {Number}: time, in seconds, at which the segment should begin
     *     (parsed from the container or from the Segment Object)
     *
     *   - end {Number}: time, in seconds, at which the segment should end
     *     (parsed from the container or from the Segment Object)
     *
     *   - bufferedStart {Number|undefined}: time, in seconds, at which we infer
     *     the segment currently begin in the sourcebuffer
     *
     *   - bufferedEnd {Number|undefined}: time, in seconds, at which we infer
     *     the segment currently end in the sourcebuffer
     *
     *   - segment {Segment}: the corresponding segment object, as downloaded
     *     from the CDN.
     *
     * @type {Array.<Object>}
     */
    this._inventory = [];
  }

  /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given (coming from the source buffer).
   * @param {TimeRanges}
   *
   * TODO implement management of segments whose end is not known
   */


  SegmentBookkeeper.prototype.addBufferedInfos = function addBufferedInfos(buffered) {
    var ranges = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_ranges_js__["h" /* convertToRanges */])(buffered);
    var maxI = ranges.length - 1;

    var _inventory = this._inventory;

    var inventoryIndex = 0;
    var thisSegment = _inventory[0];

    for (var i = 0; i <= maxI; i++) {
      if (!thisSegment) {
        // Those buffered do not link to any segment here.
        // It may be linked to another adaptation, for example
        return;
      }

      var _ranges$i = ranges[i],
          rangeStart = _ranges$i.start,
          rangeEnd = _ranges$i.end;


      if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
        continue;
      }

      var indexBefore = inventoryIndex;

      // skip until first segment with at least MINIMUM_SEGMENT_SIZE past the
      // start of that range.
      while (thisSegment && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_takeFirstSet_js__["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {
        thisSegment = _inventory[++inventoryIndex];
      }

      // might be useful to infer the bufferedStart of thisSegment
      var lastDeletedSegmentEnd = -1;

      // remove garbage-collected segments
      // (not in that range nor in the previous one)
      var numberOfSegmentToDelete = inventoryIndex - indexBefore;
      if (numberOfSegmentToDelete) {
        var lastDeletedSegment = _inventory[indexBefore + numberOfSegmentToDelete - 1];
        lastDeletedSegmentEnd = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_takeFirstSet_js__["a" /* default */])(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);
        _inventory.splice(indexBefore, numberOfSegmentToDelete);
        inventoryIndex = indexBefore;
      }

      // if no segment left for that range (or any other one), quit
      if (!thisSegment) {
        return;
      }

      // if the first segment past the start is actually outside that range,
      // skip the following part
      if (rangeEnd - __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_takeFirstSet_js__["a" /* default */])(thisSegment.bufferedStart, thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {

        // set the bufferedStart of the first segment in that range
        if (thisSegment.bufferedStart != null && thisSegment.bufferedStart < rangeStart) {
          // the segment appears to have been partially garbage collected.
          // Update bufferedStart
          thisSegment.bufferedStart = rangeStart;
        } else if (thisSegment.bufferedStart == null) {
          if (lastDeletedSegmentEnd !== -1 && lastDeletedSegmentEnd > rangeStart) {
            if (thisSegment.bufferedStart - lastDeletedSegmentEnd <= MAX_BUFFERED_DISTANCE) {
              thisSegment.bufferedStart = lastDeletedSegmentEnd;
            }
          } else if (thisSegment.start - rangeStart <= MAX_BUFFERED_DISTANCE) {
            thisSegment.bufferedStart = rangeStart;
          } else {
            thisSegment.bufferedStart = thisSegment.start;
          }
        }

        thisSegment = _inventory[++inventoryIndex];
      }

      // make contiguous until first segment outside that range
      // (i.e until the start of the next segment can not constitute a segment
      // in that range == less than MINIMUM_SEGMENT_SIZE into that range)
      while (thisSegment && rangeEnd - __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_takeFirstSet_js__["a" /* default */])(thisSegment.bufferedStart, thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
        var prevSegment = _inventory[inventoryIndex - 1];

        // those segments are contiguous, we have no way to infer their real end
        if (prevSegment.bufferedEnd == null) {
          prevSegment.bufferedEnd = prevSegment.end;
        }

        thisSegment.bufferedStart = prevSegment.bufferedEnd;
        thisSegment = _inventory[++inventoryIndex];
      }

      // update the bufferedEnd of the last segment in that range
      // Note: lastSegmentInRange can be undefined
      var lastSegmentInRange = _inventory[inventoryIndex - 1];
      if (lastSegmentInRange) {
        if (lastSegmentInRange.bufferedEnd != null && lastSegmentInRange.bufferedEnd > rangeEnd) {
          // the segment appears to have been partially garbage collected.
          // Update bufferedEnd
          lastSegmentInRange.bufferedEnd = rangeEnd;
        } else if (lastSegmentInRange.bufferedEnd == null) {
          if (rangeEnd - lastSegmentInRange.end <= MAX_BUFFERED_DISTANCE) {
            lastSegmentInRange.bufferedEnd = rangeEnd;
          } else {
            lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
          }
        }
      }
    }

    // if we still have segments left, they are not affiliated to any range.
    // They might have been garbage collected, delete them from here.
    if (thisSegment) {
      _inventory.splice(inventoryIndex, _inventory.length - inventoryIndex);
    }
  };

  /**
   * Add a new segment in the inventory.
   *
   * Note: As new segments can "replace" partially or completely old ones, we
   * have to perform a complex logic and might update previously added segments.
   *
   * @param {Segment} segment
   * @param {Number} start - start time of the segment, in seconds
   * @param {Number|undefined} end - end time of the segment, in seconds. Can
   * be undefined in some rare cases
   * @param {Number} bitrate - bitrate of the representation the segment is in
   */


  SegmentBookkeeper.prototype.insert = function insert(segment, start, end, bitrate) {
    // TODO (*very* low-priority) manage segments whose end is unknown (rare but
    // could eventually happen).
    // This should be properly managed in this method, but it is not in some
    // other methods of this class, so I decided to not one of those to the
    // inventory by security
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert_js__["a" /* default */])(end != null, "SegmentBookkeeper: ending time of the segment not defined");
    } else if (end == null) {
      // This leads to excessive re-downloads of segment without an ending time.
      return;
    }

    var _inventory = this._inventory;

    // infer start and end from the segment data
    // /!\ Can be a little different than their real start/end time in the
    // sourcebuffer.
    // const start = segment.time / segment.timescale;
    // const end = (segment.time + segment.duration) / segment.timescale;

    var newSegment = {
      bitrate: bitrate,
      start: start,
      end: end,
      bufferedStart: undefined,
      bufferedEnd: undefined,
      segment: segment
    };

    // begin by the end as in most use cases this will be faster
    for (var i = _inventory.length - 1; i >= 0; i--) {
      var segmentI = _inventory[i];

      if (segmentI.start /* - SEGMENT_EPSILON */ <= start) {
        if (segmentI.end /* - SEGMENT_EPSILON */ <= start) {
          // our segment is after, push it after this one
          //
          // Case 1:
          //   segmentI     : |======|
          //   newSegment   :        |======|
          //
          // Case 2:
          //   segmentI     : |======|
          //   newSegment   :          |======|
          this._inventory.splice(i + 1, 0, newSegment);
          return;
        } else {
          // /!\ also goes here if end is undefined
          if (segmentI.start >= start /* - SEGMENT_EPSILON */) {
            // In those cases, replace
            // Case 1:
            //  segmentI     : |=======|
            //  newSegment   : |=======|
            //
            // Case 2:
            //  segmentI     : |=======|
            //  newSegment   : |==========|
            //
            // Case 3:
            //  segmentI     : |=======|
            //  newSegment   : |???*
            //
            // Case 4:
            //  segmentI     : |???*
            //  newSegment   : |======|
            //
            // Case 5:
            //  segmentI     : |???*
            //  newSegment   : |???*
            //
            // *|??? = unknown end
            this._inventory.splice(i, 1, newSegment);
            return;
          } else {
            // our segment has a "complex" relation with this one,
            // update the old one end and add this one after it.
            //
            // Case 1:
            //  segmentI     : |=======|
            //  newSegment   :    |======|
            //
            // Case 2:
            //  segmentI     : |=======|
            //  newSegment   :    |====|
            //
            // Case 3:
            //  segmentI     : |=======|
            //  newSegment   :    |???*
            //
            // Case 4:
            //  segmentI     : |???*
            //  newSegment   :    |====|
            //
            // Case 5:
            //  segmentI     : |???*
            //  newSegment   :    |???*
            //
            // *|??? = unknown end

            // (if segment's end is not known yet, it could perfectly
            // end before the one we're adding now)
            if (segmentI.end != null) {
              segmentI.end = start;
            }
            this._inventory.splice(i + 1, 0, newSegment);
            return;
          }
        }
      }
    }

    // if we got here, we are the first segment
    // check bounds of the previous first segment
    var firstSegment = this._inventory[0];
    if (!firstSegment) {
      // we do not have any segment yet
      this._inventory.push(newSegment);
      return;
    }

    if (segment.end == null) {
      if (firstSegment.start === start) {
        // same beginning, unknown end, just replace
        // Case 1:
        //  firstSegment : |=======|
        //  newSegment   : |???*
        //
        // Case 2:
        //  firstSegment : |???*
        //  newSegment   : |???*
        //
        // *|??? = unknown end
        this._inventory.splice(0, 1, newSegment);
      } else {
        // our segment begins before this one, push at the beginning
        // Case 1:
        // firstSegment :   |=======|
        // newSegment   : |???*
        //
        // Case 2:
        // firstSegment :   |???*
        // newSegment   : |???*
        //
        // *|??? = unknown end
        this._inventory.splice(0, 0, newSegment);
      }
      return;
    }

    if (firstSegment.start >= segment.end) {
      // our segment is before, put it before
      // Case 1:
      //  firstSegment :      |====|
      //  newSegment   : |====|
      //
      // Case 2:
      //  firstSegment :        |====|
      //  newSegment   : |====|
      //
      // Case 3:
      //  firstSegment :        |???*
      //  newSegment   : |====|
      //
      // Case 4:
      //  firstSegment :      |???*
      //  newSegment   : |====|
      //
      // *|??? = unknown end
      this._inventory.splice(0, 0, newSegment);
    } else if (firstSegment.end /* - SEGMENT_EPSILON */ <= segment.end) {
      // Our segment is bigger, replace the first
      // Case 1:
      //  firstSegment :   |===|
      //  newSegment   : |=======|
      //
      // Case 2:
      //  firstSegment :   |=====|
      //  newSegment   : |=======|
      this._inventory.splice(0, 1, newSegment);
    } else {
      // our segment has a "complex" relation with the first one,
      // update the old one start and add this one before it.
      // Case 1:
      //  firstSegment :    |======|
      //  newSegment   : |======|
      //
      // Case 2:
      // firstSegment :   |???*
      // newSegment   : |=====|
      //
      // *|??? = unknown end
      firstSegment.start = segment.end;
      this._inventory.splice(0, 0, newSegment);
    }
  };

  /**
   * Returns segment infos for a segment corresponding to the given time,
   * duration and timescale.
   *
   * Returns null if either:
   *   - no segment can be linked exactly to the given time/duration
   *   - a segment is linked to this information, but is currently considered
   *     "incomplete" to be playable, in the sourceBuffer. We check if all
   *     needed data for playback (from wanted range) is loaded.
   *
   * The main purpose of this method is to know if the segment asked should be
   * downloaded (or re-downloaded).
   *
   * /!\ Make sure that this class is synchronized with the sourceBuffer
   * (see addBufferedInfos method of the same class) before calling this method,
   * as it depends on it to categorize "incomplete" from "complete" segments.
   *
   * @param {Object} wantedRange
   * @param {Number} time
   * @param {Number} duration
   * @param {Number} timescale
   * @returns {Object|null}
   */


  SegmentBookkeeper.prototype.hasPlayableSegment = function hasPlayableSegment(wantedRange, time, duration, timescale) {
    var _inventory = this._inventory;


    for (var i = _inventory.length - 1; i >= 0; i--) {
      var currentSegmentI = _inventory[i];
      var prevSegmentI = _inventory[i - 1];
      var nextSegmentI = _inventory[i + 1];

      var segment = currentSegmentI.segment;

      var _time = time;
      var _duration = duration;
      if (segment.timescale !== timescale) {
        // Note: we could get rounding errors here
        _time = time * segment.timescale / timescale;
        _duration = duration * segment.timescale / timescale;
      }

      if (segment.time === _time && segment.duration === _duration) {
        // false negatives are better than false positives here.
        // When impossible to know, say the segment is not complete
        if (hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI)) {
          if (hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI)) {
            return currentSegmentI;
          }
        }
      }
    }
    return null;

    // -- Helpers

    /*
    * Check if segment can be evaluated.
    * @param {Object} currentSegmentI
    * @param {Object} prevSegmentI
    * @param {Object} nextSegmentI
    * @returns {Boolean}
    */
    function hasEnoughInfos(currentSegmentI, prevSegmentI, nextSegmentI) {
      if (prevSegmentI && prevSegmentI.bufferedEnd == null || currentSegmentI.bufferedStart == null) {
        return false;
      }

      if (nextSegmentI && nextSegmentI.bufferedStart == null || currentSegmentI.bufferedEnd == null) {
        return false;
      }

      return true;
    }

    /* Returns true if the segment given can be played for the wanted range.
    * @param {Object} currentSegmentI
    * @param {Object} prevSegmentI
    * @param {Object} nextSegmentI
    * @returns {Boolean}
    */
    function hasWantedRange(wantedRange, currentSegmentI, prevSegmentI, nextSegmentI) {
      if (!prevSegmentI || prevSegmentI.bufferedEnd < currentSegmentI.bufferedStart) {
        var timeDiff = currentSegmentI.bufferedStart - currentSegmentI.start;
        if (wantedRange.start > currentSegmentI.start) {
          var wantedDiff = currentSegmentI.bufferedStart - wantedRange.start;
          if (wantedDiff > 0 && timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
            return false;
          }
        } else {
          if (timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
            return false;
          }
        }
      }

      if (currentSegmentI.end === null) {
        return false;
      } else if (!nextSegmentI || nextSegmentI.bufferedStart > currentSegmentI.bufferedEnd) {
        var _timeDiff = currentSegmentI.end - currentSegmentI.bufferedEnd;
        if (wantedRange.end < currentSegmentI.end) {
          var _wantedDiff = wantedRange.end - currentSegmentI.bufferedEnd;
          if (_wantedDiff > 0 && _timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
            return false;
          }
        } else {
          if (_timeDiff > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
            return false;
          }
        }
      }
      return true;
    }
  };

  return SegmentBookkeeper;
}();

/* harmony default export */ __webpack_exports__["a"] = (SegmentBookkeeper);

/***/ }),
/* 765 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KEY_STATUS_ERRORS; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var KEY_STATUS_ERRORS = {
  "expired": true,
  "internal-error": true
  // "released",
  // "output-restricted",
  // "output-downscaled",
  // "status-pending",
};

/***/ }),
/* 766 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export findCompatibleKeySystem */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getKeySystem; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__errors__ = __webpack_require__(43);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var EME_DEFAULT_WIDEVINE_ROBUSTNESSES = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
    EME_KEY_SYSTEMS = __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].EME_KEY_SYSTEMS;


function getCachedKeySystemAccess(keySystems) {
  var instanceInfos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var $keySystem = instanceInfos.$keySystem,
      $mediaKeys = instanceInfos.$mediaKeys,
      $mediaKeySystemConfiguration = instanceInfos.$mediaKeySystemConfiguration;

  // NOTE(pierre): alwaysRenew flag is used for IE11 which require the
  // creation of a new MediaKeys instance for each session creation

  if (!$keySystem || !$mediaKeys || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat__["e" /* shouldRenewMediaKeys */])()) {
    return null;
  }

  var configuration = $mediaKeySystemConfiguration;
  var foundKeySystem = keySystems.filter(function (ks) {
    if (ks.type !== $keySystem.type) {
      return false;
    }

    if (ks.persistentLicense && configuration.persistentState != "required") {
      return false;
    }

    if (ks.distinctiveIdentifierRequired && configuration.distinctiveIdentifier != "required") {
      return false;
    }

    return true;
  })[0];

  if (foundKeySystem) {
    return {
      keySystem: foundKeySystem,
      keySystemAccess: new __WEBPACK_IMPORTED_MODULE_3__compat__["f" /* KeySystemAccess */]($keySystem, $mediaKeys, $mediaKeySystemConfiguration)
    };
  } else {
    return null;
  }
}

/**
* Find key system canonical name from key system type.
* @param {string} ksType - Obtained via inversion
* @returns {string} - Either the canonical name, or undefined.
*/
function findKeySystemCanonicalName(ksType) {
  for (var _iterator = Object.keys(EME_KEY_SYSTEMS), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var ksName = _ref;

    if (EME_KEY_SYSTEMS[ksName].includes(ksType)) {
      return ksName;
    }
  }
  return;
}

/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @param {Boolean} [keySystem.persistentLicense]
 * @param {Boolean} [keySystem.persistentStateRequired]
 * @param {Boolean} [keySystem.distinctiveIdentifierRequired]
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */
function buildKeySystemConfigurations(ksName, keySystem) {
  var sessionTypes = ["temporary"];
  var persistentState = "optional";
  var distinctiveIdentifier = "optional";

  if (keySystem.persistentLicense) {
    persistentState = "required";
    sessionTypes.push("persistent-license");
  }

  if (keySystem.persistentStateRequired) {
    persistentState = "required";
  }

  if (keySystem.distinctiveIdentifierRequired) {
    distinctiveIdentifier = "required";
  }

  // Set robustness, in order of consideration:
  //   1. the user specified its own robustnesses
  //   2. a "widevine" key system is used, in that case set the default widevine
  //      robustnesses as defined in the config
  //   3. set an undefined robustness
  var videoRobustnesses = keySystem.videoRobustnesses || (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);
  var audioRobustnesses = keySystem.audioRobustnesses || (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : []);

  if (!videoRobustnesses.length) {
    videoRobustnesses.push(undefined);
  }

  if (!audioRobustnesses.length) {
    audioRobustnesses.push(undefined);
  }

  // From the W3 EME spec, we have to provide videoCapabilities and
  // audioCapabilities.
  // These capabilities must specify a codec (even though your stream can use
  // a completely different codec afterward).
  // It is also strongly recommended to specify the required security
  // robustness. As we do not want to forbide any security level, we specify
  // every existing security level from highest to lowest so that the best
  // security level is selected.
  // More details here:
  // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
  // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent
  var videoCapabilities = videoRobustnesses.map(function (robustness) {
    return {
      contentType: "video/mp4;codecs=\"avc1.4d401e\"", // standard mp4 codec
      robustness: robustness
    };
  });
  var audioCapabilities = audioRobustnesses.map(function (robustness) {
    return {
      contentType: "audio/mp4;codecs=\"mp4a.40.2\"", // standard mp4 codec
      robustness: robustness
    };
  });

  return [{
    initDataTypes: ["cenc"],
    videoCapabilities: videoCapabilities,
    audioCapabilities: audioCapabilities,
    distinctiveIdentifier: distinctiveIdentifier,
    persistentState: persistentState,
    sessionTypes: sessionTypes
  }, {
    // TODO Re-test with a set contentType but an undefined robustness on the
    // STBs on which this problem was found.
    //
    // add another with no {audio,video}Capabilities for some legacy browsers.
    // As of today's spec, this should return NotSupported but the first
    // candidate configuration should be good, so we should have no downside
    // doing that.
    // initDataTypes: ["cenc"],
    // videoCapabilities: undefined,
    // audioCapabilities: undefined,
    // distinctiveIdentifier,
    // persistentState,
    // sessionTypes,
  }];
}

/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */
function findCompatibleKeySystem(keySystems, instanceInfos) {
  // Fast way to find a compatible keySystem if the currently loaded
  // one as exactly the same compatibility options.
  var cachedKeySystemAccess = getCachedKeySystemAccess(keySystems, instanceInfos);
  if (cachedKeySystemAccess) {
    __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].debug("eme: found compatible keySystem quickly", cachedKeySystemAccess);
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(cachedKeySystemAccess);
  }

  /**
   * Array of set keySystems for this content.
   * Each item of this array is an object containing the following keys:
   *   - keyName {string}: keySystem canonical name (e.g. "widevine")
   *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
   *   - keySystem {Object}: the original keySystem object
   * @type {Array.<Object>}
   */
  var keySystemsType = keySystems.reduce(function (arr, keySystem) {

    var ksType = void 0;

    if (EME_KEY_SYSTEMS[keySystem.type]) {
      ksType = EME_KEY_SYSTEMS[keySystem.type].map(function (keyType) {
        var keyName = keySystem.type;
        return { keyName: keyName, keyType: keyType, keySystem: keySystem };
      });
    } else {
      var keyName = findKeySystemCanonicalName(keySystem.type);
      var keyType = keySystem.type;
      ksType = [{ keyName: keyName, keyType: keyType, keySystem: keySystem }];
    }

    return arr.concat(ksType);
  }, []);

  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
    var disposed = false;
    var sub = null;

    /**
     * Test the key system as defined in keySystemsType[index].
     * @param {Number} index
     */
    function testKeySystem(index) {
      // completely quit the loop if unsubscribed
      if (disposed) {
        return;
      }

      // if we iterated over the whole keySystemsType Array, quit on error
      if (index >= keySystemsType.length) {
        obs.error(new __WEBPACK_IMPORTED_MODULE_4__errors__["c" /* EncryptedMediaError */]("INCOMPATIBLE_KEYSYSTEMS", null, true));
        return;
      }

      var _keySystemsType$index = keySystemsType[index],
          keyName = _keySystemsType$index.keyName,
          keyType = _keySystemsType$index.keyType,
          keySystem = _keySystemsType$index.keySystem;

      var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystem);

      __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].debug("eme: request keysystem access " + keyType + "," + (index + 1 + " of " + keySystemsType.length), keySystemConfigurations);

      sub = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat__["g" /* requestMediaKeySystemAccess */])(keyType, keySystemConfigurations).subscribe(function (keySystemAccess) {
        __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].info("eme: found compatible keysystem", keyType, keySystemConfigurations);
        obs.next({ keySystem: keySystem, keySystemAccess: keySystemAccess });
        obs.complete();
      }, function () {
        __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].debug("eme: rejected access to keysystem", keyType, keySystemConfigurations);
        sub = null;
        testKeySystem(index + 1);
      });
    }

    testKeySystem(0);

    return function () {
      disposed = true;
      if (sub) {
        sub.unsubscribe();
      }
    };
  });
}

function getKeySystem() {
  var instanceInfos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return instanceInfos.$keySystem && instanceInfos.$keySystem.type;
}



/* harmony default export */ __webpack_exports__["a"] = (findCompatibleKeySystem);

/***/ }),
/* 767 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return trySettingServerCertificate; });
/* unused harmony export setServerCertificate */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__errors_EncryptedMediaError_js__ = __webpack_require__(151);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function setServerCertificate(mediaKeys, serverCertificate) {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].defer(function () {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_castToObservable_js__["a" /* default */])(mediaKeys.setServerCertificate(serverCertificate)).ignoreElements().catch(function (error) {
      throw new __WEBPACK_IMPORTED_MODULE_2__errors_EncryptedMediaError_js__["a" /* default */]("LICENSE_SERVER_CERTIFICATE_ERROR", error, true);
    });
  });
}

/**
 * Call the setCertificate API. If it fails just emit the error through the
 * errorStream and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function trySettingServerCertificate(mediaKeys, serverCertificate, errorStream) {
  return setServerCertificate(mediaKeys, serverCertificate).catch(function (error) {
    error.fatal = false;
    errorStream.next(error);
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
  });
}



/* unused harmony default export */ var _unused_webpack_default_export = (setServerCertificate);

/***/ }),
/* 768 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_util_TimeoutError__ = __webpack_require__(346);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_util_TimeoutError___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_util_TimeoutError__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_rx_tryCatch_js__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_retry__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__constants_js__ = __webpack_require__(765);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__globals_js__ = __webpack_require__(149);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















/**
 * Create the Object emitted by the EME Observable.
 * @param {string} name - name of the event
 * @param {MediaKeySession} session - MediaKeySession concerned
 * @param {Object} [options] - Supplementary data, will be merged with the
 * session information in the returned object.
 * @returns {Object}
 */
function createMessage(name, session, options) {
  return { type: "eme", value: __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({ name: name, session: session }, options) };
}

/*
 * listen to "message" events from session containing a challenge
 * blob and map them to licenses using the getLicense method from
 * selected keySystem.
 * @param {MediaKeySession} session
 * @param {Object} keySystem
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function sessionEventsHandler(session, keySystem, errorStream) {
  __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: handle message events", session);
  var sessionId = void 0;

  /**
   * @param {Error|Object} error
   * @param {Boolean} fatal
   * @returns {Error|Object}
   */
  function licenseErrorSelector(error, fatal) {
    if (error.type === __WEBPACK_IMPORTED_MODULE_8__errors__["a" /* ErrorTypes */].ENCRYPTED_MEDIA_ERROR) {
      error.fatal = fatal;
      return error;
    } else {
      return new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_LOAD_ERROR", error, fatal);
    }
  }

  var getLicenseRetryOptions = {
    totalRetry: 2,
    retryDelay: 200,
    errorSelector: function errorSelector(error) {
      return licenseErrorSelector(error, true);
    },
    onRetry: function onRetry(error) {
      return errorStream.next(licenseErrorSelector(error, false));
    }
  };

  var keyErrors = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__compat_events_js__["j" /* onKeyError$ */])(session).map(function (error) {
    throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_ERROR", error, true);
  });

  var keyStatusesChanges = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__compat_events_js__["l" /* onKeyStatusesChange$ */])(session).mergeMap(function (keyStatusesEvent) {
    sessionId = keyStatusesEvent.sessionId;
    __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: keystatuseschange event", sessionId, session, keyStatusesEvent);

    // find out possible errors associated with this event
    session.keyStatuses.forEach(function (keyStatus, keyId) {
      // Hack present because the order of the arguments has changed in spec
      // and is not the same between some versions of Edge and Chrome.
      if (__WEBPACK_IMPORTED_MODULE_9__constants_js__["a" /* KEY_STATUS_ERRORS */][keyId]) {
        throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_STATUS_CHANGE_ERROR", keyId, true);
      } else if (__WEBPACK_IMPORTED_MODULE_9__constants_js__["a" /* KEY_STATUS_ERRORS */][keyStatus]) {
        throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_STATUS_CHANGE_ERROR", keyStatus, true);
      }
    });

    // otherwise use the keysystem handler if disponible
    if (!keySystem.onKeyStatusesChange) {
      __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].info("eme: keystatuseschange event not handled");
      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].empty();
    }

    var license = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_rx_tryCatch_js__["a" /* default */])(function () {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(keySystem.onKeyStatusesChange(keyStatusesEvent, session));
    });

    return license.catch(function (error) {
      throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_STATUS_CHANGE_ERROR", error, true);
    });
  });

  var keyMessages = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__compat_events_js__["k" /* onKeyMessage$ */])(session).mergeMap(function (messageEvent) {
    sessionId = messageEvent.sessionId;

    var message = new Uint8Array(messageEvent.message);
    var messageType = messageEvent.messageType || "license-request";

    __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: event message type " + messageType, session, messageEvent);

    var getLicense = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].defer(function () {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(keySystem.getLicense(message, messageType)).timeout(10 * 1000).catch(function (error) {
        if (error instanceof __WEBPACK_IMPORTED_MODULE_2_rxjs_util_TimeoutError__["TimeoutError"]) {
          throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_LOAD_TIMEOUT", null, false);
        } else {
          throw error;
        }
      });
    });

    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_retry__["a" /* retryWithBackoff */])(getLicense, getLicenseRetryOptions);
  });

  var sessionUpdates = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(keyMessages, keyStatusesChanges).concatMap(function (res) {
    __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: update session", sessionId, res);

    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(session.update(res, sessionId)).catch(function (error) {
      throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_UPDATE_ERROR", error, true);
    }).mapTo(createMessage("session-update", session, { updatedWith: res }));
  });

  var sessionEvents = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(sessionUpdates, keyErrors);
  if (session.closed) {
    return sessionEvents.takeUntil(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(session.closed));
  } else {
    return sessionEvents;
  }
}

/**
 * Create Key Session and link MediaKeySession events to the right events
 * handlers.
 * @param {MediaKeys} mediaKeys
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {Object} keySystem
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSession(mediaKeys, sessionType, keySystem, initData, errorStream) {
  __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: create a new " + sessionType + " session");
  var session = mediaKeys.createSession(sessionType);
  var sessionEvents = sessionEventsHandler(session, keySystem, errorStream).finally(function () {
    __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].deleteAndClose(session);
    __WEBPACK_IMPORTED_MODULE_11__globals_js__["a" /* $storedSessions */].delete(initData);
  }).publish();

  return { session: session, sessionEvents: sessionEvents };
}

/**
 * Create a MediaKeySession and manage it (generate the request, manage
 * communications...).
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream) {
  var _createSession = createSession(mediaKeys, sessionType, keySystem, initData, errorStream),
      session = _createSession.session,
      sessionEvents = _createSession.sessionEvents;

  __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].add(initData, session, sessionEvents);
  __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: generate request", initDataType, initData);

  var generateRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(session.generateRequest(initDataType, initData)).catch(function (error) {
    throw new __WEBPACK_IMPORTED_MODULE_8__errors__["c" /* EncryptedMediaError */]("KEY_GENERATE_REQUEST_ERROR", error, false);
  }).do(function () {
    if (sessionType == "persistent-license") {
      __WEBPACK_IMPORTED_MODULE_11__globals_js__["a" /* $storedSessions */].add(initData, session);
    }
  }).mapTo(createMessage("generated-request", session, { initData: initData, initDataType: initDataType }));

  return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(sessionEvents, generateRequest);
}

/**
 * Create a session, if it fails due to a session.generateRequest error, retry
 * in certain cases.
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} sessionType - Either "persistent-license" or "temporary"
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream) {
  return createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream).catch(function (error) {
    if (error.code !== __WEBPACK_IMPORTED_MODULE_8__errors__["b" /* ErrorCodes */].KEY_GENERATE_REQUEST_ERROR) {
      throw error;
    }

    // TODO In that case, the first in $loadedSessions could be this session,
    // is this wanted?
    var firstLoadedSession = __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].getFirst();
    if (!firstLoadedSession) {
      throw error;
    }

    __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].warn("eme: could not create a new session, " + "retry after closing a currently loaded session", error);

    return __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].deleteAndClose(firstLoadedSession).mergeMap(function () {
      return createSessionAndKeyRequest(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream);
    });
  });
}

/**
 * Create persistent MediaKeySession and load data from a sessionId.
 * @param {MediaKeys} mediaKeys
 * @param {Object} keySystem
 * @param {string} storedSessionId
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createPersistentSessionAndLoad(mediaKeys, keySystem, storedSessionId, initDataType, initData, errorStream) {
  __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: load persisted session", storedSessionId);

  var sessionType = "persistent-license";

  var _createSession2 = createSession(mediaKeys, sessionType, keySystem, initData, errorStream),
      session = _createSession2.session,
      sessionEvents = _createSession2.sessionEvents;

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_castToObservable_js__["a" /* default */])(session.load(storedSessionId)).catch(function () {
    return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of(false);
  }).mergeMap(function (success) {
    if (success) {
      __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].add(initData, session, sessionEvents);
      __WEBPACK_IMPORTED_MODULE_11__globals_js__["a" /* $storedSessions */].add(initData, session);
      return sessionEvents.startWith(createMessage("loaded-session", session, { storedSessionId: storedSessionId }));
    } else {
      // Failed. Try to create a new persistent session from scratch
      __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].warn("eme: no data stored for the loaded session, do fallback", storedSessionId);

      __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].deleteById(storedSessionId);
      __WEBPACK_IMPORTED_MODULE_11__globals_js__["a" /* $storedSessions */].delete(initData);

      if (session.sessionId) {
        session.remove();
      }

      return createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream).startWith(createMessage("loaded-session-failed", session, { storedSessionId: storedSessionId }));
    }
  });
}

/**
 * Create MediaKeySession and react to its events.
 * @param {MediaKeys} mediaKeys
 * @param {MediaKeySystemConfiguration} mksConfig
 * @param {Object} keySystem
 * @param {string} initDataType
 * @param {UInt8Array} initData
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function manageSessionCreation(mediaKeys, mksConfig, keySystem, initDataType, initData, errorStream) {
  return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].defer(function () {
    // reuse currently loaded sessions without making a new key request
    var loadedSession = __WEBPACK_IMPORTED_MODULE_11__globals_js__["b" /* $loadedSessions */].get(initData);
    if (loadedSession && loadedSession.sessionId) {
      __WEBPACK_IMPORTED_MODULE_10__utils_log__["a" /* default */].debug("eme: reuse loaded session", loadedSession.sessionId);
      return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of(createMessage("reuse-session", loadedSession));
    }

    var sessionType = "temporary"; // (default value)
    var sessionTypes = mksConfig.sessionTypes;
    var hasPersistence = sessionTypes && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_array_includes_js__["a" /* default */])(sessionTypes, "persistent-license");

    if (hasPersistence && keySystem.persistentLicense) {
      sessionType = "persistent-license";

      // if a persisted session exists in the store associated to this initData,
      // we reuse it without a new license request through the `load` method.
      var storedEntry = __WEBPACK_IMPORTED_MODULE_11__globals_js__["a" /* $storedSessions */].get(initData);
      if (storedEntry) {
        return createPersistentSessionAndLoad(mediaKeys, keySystem, storedEntry.sessionId, initDataType, initData, errorStream);
      }
    }

    // we have a fresh session without persisted informations and need
    // to make a new key request that we will associate to this session
    return createSessionAndKeyRequestWithRetry(mediaKeys, keySystem, sessionType, initDataType, initData, errorStream);
  });
}

/* harmony default export */ __webpack_exports__["a"] = (manageSessionCreation);

/***/ }),
/* 769 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__abstract_js__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__hash_init_data_js__ = __webpack_require__(359);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Set maintaining a representation of all currently loaded
 * MediaKeySessions. This set allow to reuse sessions without re-
 * negotiating a license exchange if the key is already used in a
 * loaded session.
 * @class InMemorySessionsSet
 * @extends SessionSet
 */

var InMemorySessionsSet = function (_SessionSet) {
  _inherits(InMemorySessionsSet, _SessionSet);

  function InMemorySessionsSet() {
    _classCallCheck(this, InMemorySessionsSet);

    return _possibleConstructorReturn(this, _SessionSet.apply(this, arguments));
  }

  InMemorySessionsSet.prototype.getFirst = function getFirst() {
    if (this._entries.length > 0) {
      return this._entries[0].session;
    }
  };

  InMemorySessionsSet.prototype.find = function find(func) {
    for (var i = 0; i < this._entries.length; i++) {
      if (func(this._entries[i]) === true) {
        return this._entries[i];
      }
    }
    return null;
  };

  InMemorySessionsSet.prototype.get = function get(initData) {
    initData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__hash_init_data_js__["a" /* default */])(initData);
    var entry = this.find(function (e) {
      return e.initData === initData;
    });
    if (entry) {
      return entry.session;
    } else {
      return null;
    }
  };

  InMemorySessionsSet.prototype.add = function add(initData, session, sessionEvents) {
    initData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__hash_init_data_js__["a" /* default */])(initData);
    var currentSession = this.get(initData);
    if (currentSession) {
      this.deleteAndClose(currentSession);
    }

    var eventSubscription = sessionEvents.connect();
    var entry = { session: session, initData: initData, eventSubscription: eventSubscription };
    __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].debug("eme-mem-store: add session", entry);
    this._entries.push(entry);
  };

  InMemorySessionsSet.prototype.deleteById = function deleteById(sessionId) {
    var entry = this.find(function (e) {
      return e.session.sessionId === sessionId;
    });
    if (entry) {
      return this.delete(entry.session);
    } else {
      return null;
    }
  };

  InMemorySessionsSet.prototype.delete = function _delete(session_) {
    var entry = this.find(function (e) {
      return e.session === session_;
    });
    if (!entry) {
      return null;
    }

    var session = entry.session,
        eventSubscription = entry.eventSubscription;

    __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].debug("eme-mem-store: delete session", entry);
    var idx = this._entries.indexOf(entry);
    this._entries.splice(idx, 1);
    eventSubscription.unsubscribe();
    return session;
  };

  InMemorySessionsSet.prototype.deleteAndClose = function deleteAndClose(session_) {
    var session = this.delete(session_);
    if (session) {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].debug("eme-mem-store: close session", session);
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_castToObservable_js__["a" /* default */])(session.close()).catch(function () {
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);
      });
    } else {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);
    }
  };

  InMemorySessionsSet.prototype.dispose = function dispose() {
    var _this2 = this;

    var disposed = this._entries.map(function (e) {
      return _this2.deleteAndClose(e.session);
    });
    this._entries = [];
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge.apply(null, disposed);
  };

  return InMemorySessionsSet;
}(__WEBPACK_IMPORTED_MODULE_3__abstract_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (InMemorySessionsSet);

/***/ }),
/* 770 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__in_memory_js__ = __webpack_require__(769);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__persisted_js__ = __webpack_require__(771);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__in_memory_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__persisted_js__["a"]; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/***/ }),
/* 771 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__abstract_js__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hash_init_data_js__ = __webpack_require__(359);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist informations on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 */

var PersistedSessionsSet = function (_SessionSet) {
  _inherits(PersistedSessionsSet, _SessionSet);

  /*
   * @param {Object} storage
   * @param {Function} storage.load
   * @param {Function} storage.save
   */
  function PersistedSessionsSet(storage) {
    _classCallCheck(this, PersistedSessionsSet);

    var _this = _possibleConstructorReturn(this, _SessionSet.call(this));

    _this.setStorage(storage);
    return _this;
  }

  /**
   * Set a new storage System.
   * storages are user-provided objects which allow to save and load given
   * informations.
   * @param {Object} storage
   * @param {Function} storage.load
   * @param {Function} storage.save
   */


  PersistedSessionsSet.prototype.setStorage = function setStorage(storage) {
    if (this._storage === storage) {
      return;
    }

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(storage, "no licenseStorage given for keySystem with persistentLicense");

    __WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */].iface(storage, "licenseStorage", { save: "function", load: "function" });

    this._storage = storage;
    try {
      this._entries = this._storage.load();
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(Array.isArray(this._entries));
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].warn("eme-persitent-store: could not get entries from license storage", e);
      this.dispose();
    }
  };

  /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Array|TypedArray|Number}  initData
   * @returns {Object|null}
   */


  PersistedSessionsSet.prototype.get = function get(initData) {
    initData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__hash_init_data_js__["a" /* default */])(initData);
    var entry = this.find(function (e) {
      return e.initData === initData;
    });
    return entry || null;
  };

  /**
   * Add a new entry in the storage.
   * @param {Array|TypedArray|Number}  initData
   * @param {MediaKeySession} session
   */


  PersistedSessionsSet.prototype.add = function add(initData, session) {
    var sessionId = session && session.sessionId;
    if (!sessionId) {
      return;
    }

    initData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__hash_init_data_js__["a" /* default */])(initData);
    var currentEntry = this.get(initData);
    if (currentEntry && currentEntry.sessionId === sessionId) {
      return;
    } else if (currentEntry) {
      // currentEntry has a different sessionId
      this.delete(initData);
    }

    __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].info("eme-persitent-store: add new session", sessionId, session);
    this._entries.push({ sessionId: sessionId, initData: initData });
    this._save();
  };

  /**
   * Delete entry (sessionId + initData) based on its initData.
   * @param {Array|TypedArray|Number}  initData
   * @returns {Object|null}
   */


  PersistedSessionsSet.prototype.delete = function _delete(initData) {
    initData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__hash_init_data_js__["a" /* default */])(initData);

    var entry = this.find(function (e) {
      return e.initData === initData;
    });
    if (entry) {
      __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].warn("eme-persitent-store: delete session from store", entry);

      var idx = this._entries.indexOf(entry);
      this._entries.splice(idx, 1);
      this._save();
    }
  };

  /**
   * Delete all saved entries.
   */


  PersistedSessionsSet.prototype.dispose = function dispose() {
    this._entries = [];
    this._save();
  };

  /**
   * Use the given storage to store the current entries.
   */


  PersistedSessionsSet.prototype._save = function _save() {
    try {
      this._storage.save(this._entries);
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].warn("eme-persitent-store: could not save licenses in localStorage");
    }
  };

  return PersistedSessionsSet;
}(__WEBPACK_IMPORTED_MODULE_2__abstract_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (PersistedSessionsSet);

/***/ }),
/* 772 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export setMediaKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return disposeMediaKeys; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__globals_js__ = __webpack_require__(149);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Set the MediaKeys object on the videoElement.
 * @param {MediaKeys} mediaKeys
 * @param {Object} mksConfig - MediaKeySystemConfiguration used
 * @param {HTMLMediaElement} video
 * @param {Object} keySystem
 * @param {Object} instceInfos
 * @returns {Observable}
 */
function setMediaKeysObs(mediaKeys, mksConfig, video, keySystem, instceInfos) {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].defer(function () {
    var $videoElement = instceInfos.$videoElement,
        $mediaKeys = instceInfos.$mediaKeys;

    var oldVideoElement = $videoElement;
    var oldMediaKeys = $mediaKeys;

    instceInfos.$mediaKeys = mediaKeys;
    instceInfos.$mediaKeySystemConfiguration = mksConfig;
    instceInfos.$keySystem = keySystem;
    instceInfos.$videoElement = video;

    if (video.mediaKeys === mediaKeys) {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(mediaKeys);
    }

    if (oldMediaKeys && oldMediaKeys !== mediaKeys) {
      // if we change our mediaKeys singleton, we need to dispose all existing
      // sessions linked to the previous one.
      __WEBPACK_IMPORTED_MODULE_3__globals_js__["b" /* $loadedSessions */].dispose();
    }

    var mediaKeysSetter = void 0;
    if (oldVideoElement && oldVideoElement !== video) {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].debug("eme: unlink old video element and set mediakeys");
      mediaKeysSetter = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat__["h" /* setMediaKeys */])(oldVideoElement, null).concat(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat__["h" /* setMediaKeys */])(video, mediaKeys));
    } else {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].debug("eme: set mediakeys");
      mediaKeysSetter = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat__["h" /* setMediaKeys */])(video, mediaKeys);
    }

    return mediaKeysSetter.mapTo(mediaKeys);
  });
}

function disposeMediaKeys(videoElement) {
  if (videoElement) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat__["h" /* setMediaKeys */])(videoElement, null);
  }
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
}


/* harmony default export */ __webpack_exports__["a"] = (setMediaKeysObs);

/***/ }),
/* 773 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeManifest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getCodec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return updateManifest; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_languages__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__manifest__ = __webpack_require__(800);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO That file here should be progressively removed:
 *   - the net directory contains transport utils which include manifest
 *     parsers.
 *
 *   - the manifest directory defines a common class for manifest and sub-parts
 *     of a manifest.
 *
 * The best may be to have what is returned by net directly fed to the
 * instanciation of the manifest class.
 *
 * Due to that, some parts should be moved to net/, other to manifest/.
 *
 * Kept for now, as it just werks, but this might become a problem for
 * maintability and future evolutions.
 */











/**
 * Representation keys directly inherited from the adaptation.
 * If any of those keys are in an adaptation but not in one of its
 * representation, it will be inherited.
 */
var representationBaseType = ["audioSamplingRate", "codecs", "codingDependency", "frameRate", "height", "index", "maxPlayoutRate", "maximumSAPPeriod", "mimeType", "profiles", "segmentProfiles", "width"];

var uniqueId = 0;
var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];

function parseBaseURL(manifest) {
  var baseURL = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_url__["a" /* normalizeBaseURL */])(manifest.locations[0]);
  var period = manifest.periods[0];
  if (period && period.baseURL) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_url__["b" /* resolveURL */])(baseURL, period.baseURL);
  }
  return baseURL;
}

/**
 * @param {string} url - the manifest's url
 * @param {Object} manifest - the parsed manifest
 * @param {Array.<Object>|Object} externalTextTracks - Will be added to the
 * manifest as an adaptation.
 * @param {Array.<Object>|Object} externalImageTracks - Will be added to the
 * manifest as an adaptation.
 *
 * @throws MediaError - throw if the manifest has no transportType set
 * @throws MediaError - Throws if one of the periods has no id property defined
 *
 * @throws MediaError - Throws if one of the periods has no adaptation in the
 * types understood by the RxPlayer
 *
 * @throws MediaError - Throws if one of the periods has no representation in a
 * codec supported by the browser
 *
 * @throws MediaError - Throws if one of the adaptations has no id property
 * defined
 *
 * @throws MediaError - Throws if one of the adaptations does not have any type
 *
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object}
 */
function normalizeManifest(url, manifest, externalTextTracks, externalImageTracks) {
  // transportType == "smooth"|"dash"
  if (!manifest.transportType) {
    throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_PARSE_ERROR", null, true);
  }

  // TODO cleaner ID
  manifest.id = manifest.id || "gen-manifest-" + uniqueId++;

  // "static"|"dynamic"
  manifest.type = manifest.type || "static";
  manifest.isLive = manifest.type == "dynamic";

  var locations = manifest.locations;
  if (!locations || !locations.length) {
    manifest.locations = [url];
  }

  var rootURL = parseBaseURL(manifest);

  // TODO(pierre): support multi-locations/cdns
  var inherit = {
    rootURL: rootURL, // TODO needed for inheritance?
    baseURL: manifest.baseURL, // TODO so manifest.baseURL is more important
    // than manifest.periods[0].baseURL?
    // TODO needed for inheritance?
    isLive: manifest.isLive // TODO needed for inheritance?
  };

  var periods = manifest.periods.map(function (period) {
    return normalizePeriod(period, inherit, externalTextTracks, externalImageTracks);
  });

  // TODO(pierre): support multiple periods
  manifest = assignAndClone(manifest, periods[0]);
  manifest.periods = null;

  if (!manifest.duration) {
    manifest.duration = Infinity;
  }

  if (manifest.isLive) {
    manifest.suggestedPresentationDelay = manifest.suggestedPresentationDelay || 0;

    manifest.availabilityStartTime = manifest.availabilityStartTime || 0;
  }

  return new __WEBPACK_IMPORTED_MODULE_7__manifest__["a" /* default */](manifest);
}

// /**
//  * Put every IDs from the manifest in an array.
//  * It collects the ID from:
//  *   - the manifest
//  *   - the periods
//  *   - the adaptations
//  *   - the representations
//  *
//  * Can be used to ensure a newly created ID is not yet already defined.
//  *
//  * @param {Object} manifest
//  * @param {Array.<string|Number>}
//  */
// function collectEveryIDs(manifest) {
//   const currentIDs = [];

//   if (manifest.id != null) {
//     currentIDs.push(manifest.id);
//   }

//   manifest.periods.forEach(period => {
//     if (period.id != null) {
//       currentIDs.push(period.id);
//     }
//     period.adaptations.forEach(adaptation => {
//       if (adaptation.id != null) {
//         currentIDs.push(adaptation.id);
//       }
//       adaptation.representation.forEach(representation => {
//         if (representation.id != null) {
//           currentIDs.push(representation.id);
//         }
//       });
//     });
//   });

//   return currentIDs;
// }

// /**
//  * Set IDs if they are not found for:
//  */
// function setMissingIDs(manifest) {
//   const currentIDs = [];

//   if (manifest.id != null) {
//     currentIDs.push(manifest.id);
//   }

//   manifest.periods.forEach(period => {
//     if (period.id != null) {
//       currentIDs.push(period.id);
//     }
//     period.adaptations.forEach(adaptation => {
//       if (adaptation.id != null) {
//         currentIDs.push(adaptation.id);
//       }
//       adaptation.representation.forEach(representation => {
//         if (representation.id != null) {
//           currentIDs.push(representation.id);
//         }
//       });
//     });
//   });

//   if (manifest.id == null) {
//     let IDBase = 0;
//     const basename = "manifest-";
//     while (currentIDs.include(basename + ++IDBase)) {
//       if (IDBase === Number.MAX_VALUE) {
//         throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
//       }
//     }
//     manifest.id = basename + IDBase;
//     currentIDs.push(manifest.id);
//   }

//   manifest.periods.forEach(period => {
//     if (period.id == null) {
//       let IDBase = 0;
//       const basename = "period-";
//       while (currentIDs.include(basename + ++IDBase)) {
//         if (IDBase === Number.MAX_VALUE) {
//           throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
//         }
//       }
//       period.id = basename + IDBase;
//       currentIDs.push(period.id);
//     }
//     period.adaptations.forEach(adaptation => {
//       if (adaptation.id == null) {
//         let IDBase = 0;
//         const basename = "adaptation-";
//         while (currentIDs.include(basename + ++IDBase)) {
//           if (IDBase === Number.MAX_VALUE) {
//             throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
//           }
//         }
//         adaptation.id = basename + IDBase;
//         currentIDs.push(adaptation.id);
//       }
//       adaptation.representation.forEach(representation => {
//         if (representation.id == null) {
//           let IDBase = 0;
//           const basename = "representation-";
//           while (currentIDs.include(basename + ++IDBase)) {
//             if (IDBase === Number.MAX_VALUE) {
//               throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
//             }
//           }
//           representation.id = basename + IDBase;
//           currentIDs.push(representation.id);
//         }
//       });
//     });
//   });
// }

/**
 * @param {Object} period
 * @param {Object} inherit
 * @param {Array.<Object>|Object} [addedTextTracks]
 * @param {Array.<Object>|Object} [addedImageTracks]
 *
 * @throws MediaError - Throws if the period has no id property defined
 *
 * @throws MediaError - Throws if the period has no adaptation in the types
 * understood by the RxPlayer
 *
 * @throws MediaError - Throws if the period has no representation in a codec
 * supported by the browser
 *
 * @throws MediaError - Throws if one of the adaptations has no id property
 * defined
 *
 * @throws MediaError - Throws if one of the adaptations does not have any type
 *
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object} period
 */
function normalizePeriod(period, inherit, externalTextTracks, externalImageTracks) {
  if (typeof period.id == "undefined") {
    // TODO cleaner ID
    period.id = "gen-period-" + uniqueId++;

    // TODO Generate ID higher and throw here?
    // throw new MediaError("MANIFEST_PARSE_ERROR", null, true);
  }

  var adaptations = period.adaptations.map(function (adaptation) {
    return normalizeAdaptation(adaptation, inherit);
  });

  if (externalTextTracks) {
    adaptations.push.apply(adaptations, normalizeSupplementaryTextTracks(externalTextTracks).map(function (adaptation) {
      return normalizeAdaptation(adaptation, inherit);
    }));
  }

  if (externalImageTracks) {
    adaptations.push.apply(adaptations, normalizeSupplementaryImageTracks(externalImageTracks).map(function (adaptation) {
      return normalizeAdaptation(adaptation, inherit);
    }));
  }

  // filter out adaptations from unsupported types
  var filteredAdaptations = adaptations.filter(function (adaptation) {
    if (SUPPORTED_ADAPTATIONS_TYPE.indexOf(adaptation.type) < 0) {
      __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].info("not supported adaptation type", adaptation.type);
      return false;
    } else {
      return true;
    }
  });

  if (filteredAdaptations.length === 0) {
    throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_PARSE_ERROR", null, true);
  }

  var adaptationsByType = {};

  // construct adaptationsByType object
  for (var i = 0; i < filteredAdaptations.length; i++) {
    var adaptation = filteredAdaptations[i];
    var adaptationReps = adaptation.representations;
    var adaptationType = adaptation.type;

    if (!adaptationsByType[adaptationType]) {
      adaptationsByType[adaptationType] = [];
    }

    // only keep adaptations that have at least one representation
    if (adaptationReps.length > 0) {
      adaptationsByType[adaptationType].push(adaptation);
    }
  }

  // TODO Throwing this way is ugly and could not work with future improvements
  // Find better way to really detect if the codecs are incompatible
  for (var _adaptationType in adaptationsByType) {
    if (adaptationsByType[_adaptationType].length === 0) {
      throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_INCOMPATIBLE_CODECS_ERROR", null, true);
    }
  }

  period.adaptations = adaptationsByType;
  return period;
}

/**
 * TODO perform some cleanup like adaptations.index (indexes are
 * in the representations)
 *
 * @param {Object} initialAdaptation
 * @param {Object} inherit
 *
 * @throws MediaError - Throws if the adaptation has no id property defined
 * @throws MediaError - Throws if the adaptation does not have any type
 * @throws MediaError - Throws if one of the representations has no id property
 * defined
 *
 * @returns {Object} adaptation
 */
function normalizeAdaptation(initialAdaptation, inherit) {
  if (typeof initialAdaptation.id == "undefined") {
    throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_PARSE_ERROR", null, true);
  }

  var adaptation = assignAndClone(inherit, initialAdaptation);

  // representations in this adaptation will inherit the props of this object
  var toInheritFromAdaptation = {};
  representationBaseType.forEach(function (baseType) {
    if (baseType in adaptation) {
      toInheritFromAdaptation[baseType] = adaptation[baseType];
    }
  });

  var representations = adaptation.representations.map(function (representation) {
    return normalizeRepresentation(representation, toInheritFromAdaptation, adaptation.rootURL, adaptation.baseURL);
  }).sort(function (a, b) {
    return a.bitrate - b.bitrate;
  }); // bitrate ascending

  var type = adaptation.type,
      _adaptation$accessibi = adaptation.accessibility,
      accessibility = _adaptation$accessibi === undefined ? [] : _adaptation$accessibi;

  if (!type) {
    throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_PARSE_ERROR", null, true);
  }

  if (type == "video" || type == "audio") {
    representations = representations.filter(function (representation) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__compat__["p" /* isCodecSupported */])(getCodec(representation));
    });

    if (type === "audio") {
      var isAudioDescription = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__["a" /* default */])(accessibility, "visuallyImpaired");
      adaptation.audioDescription = isAudioDescription;
    }
  } else if (type === "text") {
    var isHardOfHearing = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_array_includes_js__["a" /* default */])(accessibility, "hardOfHearing");
    adaptation.closedCaption = isHardOfHearing;
  }

  adaptation.representations = representations;
  adaptation.bitrates = representations.map(function (rep) {
    return rep.bitrate;
  });
  return adaptation;
}

/**
 * @param {Object} initialRepresentation
 * @param {Object} inherit
 * @param {string} [rootURL]
 * @param {string} [baseURL]
 *
* @throws MediaError - Throws if the representation has no id property defined
*
 * @returns {Object}
 */
function normalizeRepresentation(initialRepresentation, inherit, rootURL, baseURL) {
  if (typeof initialRepresentation.id == "undefined") {
    throw new __WEBPACK_IMPORTED_MODULE_5__errors__["f" /* MediaError */]("MANIFEST_PARSE_ERROR", null, true);
  }

  var representation = assignAndClone(inherit, initialRepresentation);

  if (!representation.index) {
    // if we have no index, it must mean the whole file is directly accessible
    // as is. Simulate a "template" for now as it is the most straightforward.
    // TODO own indexType
    representation.index = {
      indexType: "template",
      duration: Number.MAX_VALUE,
      timescale: 1,
      startNumber: 0
    };
  } else if (!representation.index.timescale) {
    representation.index.timescale = 1;
  }

  if (!representation.bitrate) {
    representation.bitrate = 1;
  }

  // Fix issue in some packagers, like GPAC, generating a non
  // compliant mimetype with RFC 6381. Other closed-source packagers
  // may be impacted.
  if (representation.codecs == "mp4a.40.02") {
    representation.codecs = "mp4a.40.2";
  }

  representation.baseURL = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_url__["b" /* resolveURL */])(rootURL, baseURL, representation.baseURL);
  representation.codec = representation.codecs;
  return representation;
}

/**
 * Normalize text tracks Object/Array to a normalized manifest adaptation.
 * @param {Array.<Object>|Object} subtitles
 * @returns {Array.<Object>}
 */
function normalizeSupplementaryTextTracks(textTracks) {
  var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
  return _textTracks.reduce(function (allSubs, _ref) {
    var mimeType = _ref.mimeType,
        codecs = _ref.codecs,
        url = _ref.url,
        language = _ref.language,
        languages = _ref.languages,
        closedCaption = _ref.closedCaption;

    if (language) {
      languages = [language];
    }

    return allSubs.concat(languages.map(function (language) {
      return {
        // TODO cleaner ID
        id: "gen-text-ada-" + uniqueId++,
        type: "text",
        language: language,
        normalizedLanguage: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_languages__["a" /* normalize */])(language),
        accessibility: closedCaption ? ["hardOfHearing"] : [],
        baseURL: url,
        representations: [{
          // TODO cleaner ID
          id: "gen-text-rep-" + uniqueId++,
          mimeType: mimeType,
          codecs: codecs,
          index: {
            indexType: "template",
            duration: Number.MAX_VALUE,
            timescale: 1,
            startNumber: 0
          }
        }]
      };
    }));
  }, []);
}

/**
 * Normalize image tracks Object/Array to a normalized manifest adaptation.
 * @param {Array.<Object>|Object} images
 * @returns {Array.<Object>}
 */
function normalizeSupplementaryImageTracks(imageTracks) {
  var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
  return _imageTracks.map(function (_ref2) {
    var mimeType = _ref2.mimeType,
        url = _ref2.url;

    return {
      // TODO cleaner ID
      id: "gen-image-ada-" + uniqueId++,
      type: "image",
      baseURL: url,
      representations: [{
        // TODO cleaner ID
        id: "gen-image-rep-" + uniqueId++,
        mimeType: mimeType,
        index: {
          indexType: "template",
          duration: Number.MAX_VALUE,
          timescale: 1,
          startNumber: 0
        }
      }]
    };
  });
}

/**
 * Returns an object which is a merge of all arguments given
 * (Object.assign-like) but with all the corresponding merged attributes
 * cloned (they do not share the same references than the original attributes).
 *
 * This is useful to keep representations, for example, sharing inherited
 * Objects to also share their references. In that case, an update of a single
 * representation would update every other one.
 *
 * @param {...Object} args
 * @returns {Object}
 */
function assignAndClone() {
  var res = {};

  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var i = args.length - 1; i >= 0; i--) {
    var arg = args[i];
    for (var attr in arg) {
      if (res.hasOwnProperty(attr)) {
        continue;
      }

      var val = arg[attr];
      if (val && (typeof val === "undefined" ? "undefined" : _typeof(val)) === "object") {
        if (val instanceof Date) {
          res[attr] = new Date(val.getTime());
        } else if (Array.isArray(val)) {
          res[attr] = val.slice(0);
        } else {
          res[attr] = assignAndClone(val);
        }
      } else {
        res[attr] = val;
      }
    }
  }

  return res;
}

// TODO Check and re-check the id thing
function updateManifest(oldManifest, newManifest) {
  var findElementFromId = function findElementFromId(id, elements) {
    return __WEBPACK_IMPORTED_MODULE_0_array_find___default()(elements, function (obj) {
      return obj.id === id;
    });
  };

  var oldAdaptations = oldManifest.getAdaptations();
  var newAdaptations = newManifest.getAdaptations();

  for (var i = 0; i < oldAdaptations.length; i++) {
    var newAdaptation = findElementFromId(oldAdaptations[i].id, newAdaptations);

    if (!newAdaptation) {
      __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("manifest: adaptation \"" + oldAdaptations[i].id + "\" not found when merging.");
    } else {
      var oldRepresentations = oldAdaptations[i].representations;
      var newRepresentations = newAdaptation.representations;
      for (var j = 0; j < oldRepresentations.length; j++) {
        var newRepresentation = findElementFromId(oldRepresentations[j].id, newRepresentations);

        if (!newRepresentation) {
          __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("manifest: representation \"" + oldRepresentations[j].id + "\" not found when merging.");
        } else {
          oldRepresentations[j].index.update(newRepresentation.index);
        }
      }
    }
  }
  return oldManifest;
}

/**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */
function getCodec(representation) {
  var codec = representation.codec,
      mimeType = representation.mimeType;

  return mimeType + ";codecs=\"" + codec + "\"";
}



/***/ }),
/* 774 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_backoff_js__ = __webpack_require__(369);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Called on a pipeline's loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean}
 */
function shouldRetry(error) {
  if (!(error instanceof __WEBPACK_IMPORTED_MODULE_1__errors__["h" /* RequestError */])) {
    return false;
  }
  if (error.type === __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].ERROR_HTTP_CODE) {
    return error.status >= 500 || error.status == 404;
  }
  return error.type === __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].TIMEOUT || error.type === __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].ERROR_EVENT;
}

function isOfflineError(error) {
  return error.type === __WEBPACK_IMPORTED_MODULE_1__errors__["j" /* RequestErrorTypes */].ERROR_EVENT && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat__["q" /* isOffline */])();
}

/**
 * Specific exponential backoff algorithm used for segments/manifest
 * downloading.
 *
 * The specificty here in comparaison to a "regular" backoff algorithm is
 * the separation between type of errors:
 *   - "offline" errors
 *   - other xhr errors
 * Both have their own counters which are resetted if the error type changes.
 * @param {Observable}
 * @param {Object} options
 * @param {Number} options.baseDelay - First delay set when and if:
 *   - the first observable throws
 *   - any observable throws an error which has a type different than the last
 *     one.
 * @param {Number} options.maxDelay - Maximum delay considered for the backoff.
 * Note that this delay is not exact as it will be "fuzzed".
 * @param {Number} options.maxRetryRegular - Maximum number of retry for
 * "regular" errors. That is, errors that are most likely due to the CDN.
 * @param {Number} options.maxRetryOffline - Maximum number of retry for
 * "offline" errors. That is, errors that are most likely due to the user being
 * offline.
 * @param {Function} [options.onRetry] - callback to call as an observable
 * throws. Will be called with two arguments:
 *   - The error thrown by the observable.
 *   - The counter for the current error type.
 * @returns {Observable}
 */
function downloadingBackoff(obs$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      maxRetryRegular = options.maxRetryRegular,
      maxRetryOffline = options.maxRetryOffline,
      onRetry = options.onRetry;

  var retryCount = 0;

  var ERROR_TYPES = {
    NONE: 0,
    REGULAR: 1,
    OFFLINE: 2
  };

  var lastError = ERROR_TYPES.NONE;
  return obs$.catch(function (error, source) {
    if (!shouldRetry(error)) {
      throw error;
    }

    var currentError = isOfflineError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;

    var maxRetry = currentError === ERROR_TYPES.OFFLINE ? maxRetryOffline : maxRetryRegular;

    if (currentError !== lastError) {
      retryCount = 0;
      lastError = currentError;
    }

    if (++retryCount > maxRetry) {
      throw error;
    }

    if (onRetry) {
      onRetry(error, retryCount);
    }

    var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);

    var fuzzedDelay = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_backoff_js__["b" /* getFuzzedDelay */])(delay);
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].timer(fuzzedDelay).mergeMap(function () {
      return source;
    });
  });
}

/* harmony default export */ __webpack_exports__["a"] = (downloadingBackoff);

/***/ }),
/* 775 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createPipeline;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_rx_tryCatch_js__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_castToObservable_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__backoff_js__ = __webpack_require__(774);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














var DEFAULT_MAXIMUM_RETRY_ON_ERROR = __WEBPACK_IMPORTED_MODULE_3__config_js__["a" /* default */].DEFAULT_MAX_PIPELINES_RETRY_ON_ERROR;

var DEFAULT_MAXIMUM_RETRY_ON_OFFLINE = __WEBPACK_IMPORTED_MODULE_3__config_js__["a" /* default */].DEFAULT_MAX_PIPELINES_RETRY_ON_OFFLINE;

var MAX_BACKOFF_DELAY_BASE = __WEBPACK_IMPORTED_MODULE_3__config_js__["a" /* default */].MAX_BACKOFF_DELAY_BASE,
    INITIAL_BACKOFF_DELAY_BASE = __WEBPACK_IMPORTED_MODULE_3__config_js__["a" /* default */].INITIAL_BACKOFF_DELAY_BASE;

/**
 * Generate a new error from the infos given.
 * Also attach the pipeline type (audio/manifest...) to the _pipelineType_
 * property of the returned error.
 * @param {string} code
 * @param {string} pipelineType
 * @param {Error} error
 * @param {Boolean} [fatal=true] - Whether the error is fatal to the content's
 * playback.
 * @returns {Error}
 */

function errorSelector(code, error) {
  var fatal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__errors__["d" /* isKnownError */])(error)) {
    var ErrorType = error instanceof __WEBPACK_IMPORTED_MODULE_4__errors__["h" /* RequestError */] ? __WEBPACK_IMPORTED_MODULE_4__errors__["i" /* NetworkError */] : __WEBPACK_IMPORTED_MODULE_4__errors__["e" /* OtherError */];

    error = new ErrorType(code, error, fatal);
  }
  return error;
}

/**
 * Returns function allowing to download the wanted transport object through
 * the resolver -> loader -> parser pipeline.
 *
 * (A transport object can be for example: the manifest, audio and video
 * segments, text, images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *   - each time a request begins (type "request"). This is not emitted if the
 *     value is retrieved from a local js cache. This one emit the payload
 *     as a value.
 *   - each time a request ends (type "metrics"). This one contains
 *     informations about the metrics of the request.
 *   - each time a minor request error is encountered (type "error"). With the
 *     error as a value.
 *   - Lastly, with the obtained data (type "data").
 *
 * Each of these but "error" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 * @param {Object} transportObject
 * @param {Function} transportObject.resolver
 * @param {Function} transportObject.loader
 * @param {Function} transportObject.parser
 * @param {Object} [options={}]
 * @param {Number} [options.maxRetry=DEFAULT_MAXIMUM_RETRY_ON_ERROR]
 * @param {Object} [options.cache]
 * @returns {Function}
 */
function createPipeline(_ref) {
  var resolver = _ref.resolver,
      loader = _ref.loader,
      parser = _ref.parser;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var maxRetry = options.maxRetry,
      cache = options.cache;

  /**
   * Subject that will emit non-fatal errors.
   */

  var retryErrorSubject = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__["Subject"]();

  if (!resolver) {
    resolver = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of;
  }
  if (!loader) {
    loader = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of;
  }
  if (!parser) {
    parser = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of;
  }

  var totalRetry = typeof maxRetry === "number" ? maxRetry : DEFAULT_MAXIMUM_RETRY_ON_ERROR;

  /**
   * Backoff options given to the backoff retry done with the loader function.
   * @see retryWithBackoff
   */
  var backoffOptions = {
    baseDelay: INITIAL_BACKOFF_DELAY_BASE,
    maxDelay: MAX_BACKOFF_DELAY_BASE,
    maxRetryRegular: totalRetry,
    maxRetryOffline: DEFAULT_MAXIMUM_RETRY_ON_OFFLINE,
    onRetry: function onRetry(error) {
      retryErrorSubject.next(errorSelector("PIPELINE_LOAD_ERROR", error, false));
    }
  };

  var _resolver = function _resolver(pipelineInputData) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_rx_tryCatch_js__["a" /* default */])(resolver, pipelineInputData).catch(function (error) {
      throw errorSelector("PIPELINE_RESOLVE_ERROR", error);
    });
  };

  var _loader = function _loader(resolvedInfos, pipelineInputData) {
    var loaderWithRetry = function loaderWithRetry(resolvedInfos) {
      return (
        // TODO do something about bufferdepth to avoid infinite errors?
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__backoff_js__["a" /* default */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_rx_tryCatch_js__["a" /* default */])(loader, resolvedInfos), backoffOptions).catch(function (error) {
          throw errorSelector("PIPELINE_LOAD_ERROR", error);
        }).do(function (_ref2) {
          var type = _ref2.type,
              value = _ref2.value;

          if (type === "response" && cache) {
            cache.add(resolvedInfos, value);
          }
        }).startWith({
          type: "request",
          value: pipelineInputData
        })
      );
    };

    var fromCache = cache ? cache.get(resolvedInfos) : null;
    return fromCache === null ? loaderWithRetry(resolvedInfos) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_castToObservable_js__["a" /* default */])(fromCache).map(function (response) {
      return {
        type: "cache",
        value: response
      };
    }).catch(function () {
      return loaderWithRetry(resolvedInfos);
    });
  };

  var _parser = function _parser(loadedInfos) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__utils_rx_tryCatch_js__["a" /* default */])(parser, loadedInfos).catch(function (error) {
      throw errorSelector("PIPELINE_PARSING_ERROR", error);
    });
  };

  return function (pipelineInputData) {
    var pipeline$ = _resolver(pipelineInputData).mergeMap(function (resolvedInfos) {
      return _loader(resolvedInfos, pipelineInputData).mergeMap(function (_ref3) {
        var type = _ref3.type,
            value = _ref3.value;

        // "cache": taken from cache
        // "data": no request have been done
        // "response": a request has been done
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_array_includes_js__["a" /* default */])(["cache", "data", "response"], type)) {
          var loaderResponse = value;
          var loadedInfos = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({ response: loaderResponse }, resolvedInfos);

          // add metrics if a request was made
          var metrics = type === "response" ? __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of({
            type: "metrics",
            value: {
              size: value.size,
              duration: value.duration
            }
          }) : __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].empty();

          return metrics.concat(_parser(loadedInfos).map(function (parserResponse) {
            return {
              type: "data",
              value: __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({
                parsed: parserResponse
              }, loadedInfos)
            };
          }));
        } else {
          return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of({ type: type, value: value });
        }
      });
    }).do(null, null, function () {
      retryError$.complete();
    });

    var retryError$ = retryErrorSubject.map(function (error) {
      return { type: "error", value: error };
    });

    return __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(pipeline$, retryError$);
  };
}

/***/ }),
/* 776 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errors_EncryptedMediaError_js__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__eme__ = __webpack_require__(357);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Perform EME management if needed.
 * @param {HTMLMediaElement} videoElement
 * @param {Array.<Object>} [keySystems]
 * @param {Subject} errorStream
 * @returns {Observable}
 */
function createEMEIfKeySystems(videoElement, keySystems, errorStream) {
  if (keySystems && keySystems.length) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__eme__["c" /* createEME */])(videoElement, keySystems, errorStream);
  } else {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__compat_events_js__["f" /* onEncrypted$ */])(videoElement).map(function () {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].error("eme: ciphered media and no keySystem passed");
      throw new __WEBPACK_IMPORTED_MODULE_0__errors_EncryptedMediaError_js__["a" /* default */]("MEDIA_IS_ENCRYPTED_ERROR", null, true);
    });
  }
}

/* harmony default export */ __webpack_exports__["a"] = (createEMEIfKeySystems);

/***/ }),
/* 777 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createMediaErrorStream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_rx_onEvent_js__ = __webpack_require__(161);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the videoElement.
 * @see MediaError
 * @returns {Observable}
 */
function createMediaErrorStream(videoElement) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_rx_onEvent_js__["a" /* default */])(videoElement, "error").mergeMap(function () {
    var errorCode = videoElement.error.code;
    var errorDetail = void 0;
    switch (errorCode) {
      case 1:
        errorDetail = "MEDIA_ERR_ABORTED";
        break;
      case 2:
        errorDetail = "MEDIA_ERR_NETWORK";
        break;
      case 3:
        errorDetail = "MEDIA_ERR_DECODE";
        break;
      case 4:
        errorDetail = "MEDIA_ERR_SRC_NOT_SUPPORTED";
        break;
    }
    __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].error("stream: video element MEDIA_ERR(" + errorDetail + ")");
    throw new __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__["a" /* default */](errorDetail, null, true);
  });
}

/***/ }),
/* 778 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Stream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__ = __webpack_require__(337);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_retry__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_rx_throttle_js__ = __webpack_require__(839);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_initialization_segment_cache_js__ = __webpack_require__(835);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__errors__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__manifest__ = __webpack_require__(773);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__buffer__ = __webpack_require__(762);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pipelines_index_js__ = __webpack_require__(775);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__abr__ = __webpack_require__(752);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__initial_time_js__ = __webpack_require__(779);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__source_buffers__ = __webpack_require__(783);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__media_source_js__ = __webpack_require__(780);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__timings_js__ = __webpack_require__(793);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__error_stream_js__ = __webpack_require__(777);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__process_pipeline_js__ = __webpack_require__(781);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__speed_manager_js__ = __webpack_require__(791);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__stalling_obs_js__ = __webpack_require__(792);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__eme_js__ = __webpack_require__(776);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


































var END_OF_PLAY = __WEBPACK_IMPORTED_MODULE_4__config_js__["a" /* default */].END_OF_PLAY;

/**
 * Returns the pipeline options depending on the type of pipeline concerned.
 * @param {string} bufferType - e.g. "audio"|"text"...
 * @returns {Object} - Options to give to the Pipeline
 */

var getPipelineOptions = function getPipelineOptions(bufferType) {
  var downloaderOptions = {};
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_array_includes_js__["a" /* default */])(["audio", "video"], bufferType)) {
    downloaderOptions.cache = new __WEBPACK_IMPORTED_MODULE_10__utils_initialization_segment_cache_js__["a" /* default */]();
  } else if (bufferType === "image") {
    downloaderOptions.maxRetry = 0; // Deactivate BIF fetching if it fails
  }
  return downloaderOptions;
};

/**
 * Central part of the player. Play a given stream described by the given
 * manifest with given options.
 *
 * On subscription:
 *  - Creates the MediaSource and attached sourceBuffers instances.
 *  - download the content's manifest
 *  - Perform EME management if needed
 *  - create Buffer instances for each adaptation to manage buffers.
 *  - give adaptation control to the caller (e.g. to choose a language)
 *  - perform ABR Management
 *  - returns Observable emitting notifications about the stream lifecycle.
 *
 * TODO TOO MANY PARAMETERS something is wrong here.
 * @param {Object} args
 * @returns {Observable}
 */
function Stream(_ref) {
  var adaptiveOptions = _ref.adaptiveOptions,
      autoPlay = _ref.autoPlay,
      bufferOptions = _ref.bufferOptions,
      keySystems = _ref.keySystems,
      startAt = _ref.startAt,
      url = _ref.url,
      videoElement = _ref.videoElement,
      speed$ = _ref.speed$,
      supplementaryTextTracks = _ref.supplementaryTextTracks,
      supplementaryImageTracks = _ref.supplementaryImageTracks,
      textTrackOptions = _ref.textTrackOptions,
      timings$ = _ref.timings$,
      errorStream = _ref.errorStream,
      _ref$withMediaSource = _ref.withMediaSource,
      withMediaSource = _ref$withMediaSource === undefined ? true : _ref$withMediaSource,
      transport = _ref.transport;
  var wantedBufferAhead$ = bufferOptions.wantedBufferAhead$,
      maxBufferAhead$ = bufferOptions.maxBufferAhead$,
      maxBufferBehind$ = bufferOptions.maxBufferBehind$;
  /**
   * Subject through which network metrics will be sent to the ABR manager.
   */

  var network$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();

  /**
   * Subject through which each request progression will be reported to the ABR
   * manager.
   */
  var requestsInfos$ = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();

  /**
   * Pipeline used to download the manifest file.
   * @see ../pipelines
   * @type {Function} - take in argument the pipeline data, returns a pipeline
   * observable.
   */
  var manifestPipeline = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16__pipelines_index_js__["a" /* default */])(transport.manifest);

  /*
   * ...Fetch the manifest file given.
   * Throttled to avoid doing multiple simultaneous requests because multiple
   * source buffers are out-of-index
   * TODO check if that throttle works as expected
   * @param {string} url - the manifest url
   * @returns {Observable} - the parsed manifest
   */
  var fetchManifest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__utils_rx_throttle_js__["a" /* default */])(function (url) {
    var manifest$ = manifestPipeline({ url: url });
    var fakeSubject = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_23__process_pipeline_js__["a" /* default */])("manifest", manifest$, fakeSubject, // we don't care about metrics here
    fakeSubject, // and we don't care about the request progress
    errorStream).map(function (_ref2) {
      var parsed = _ref2.parsed;
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__manifest__["a" /* normalizeManifest */])(parsed.url, parsed.manifest, supplementaryTextTracks, supplementaryImageTracks);
    });
  });

  /**
   * Map the "type" of a sourceBuffer (example "audio" or "video") to a
   * SourceBuffer.
   *
   * Allow to avoid creating multiple sourceBuffers for the same type.
   * TODO Is this compatible with codec switching?
   *
   * There is 2 "native" SourceBuffers: "audio" and "video" as they are the
   * only one added to the MediaSource.
   *
   * All other SourceBuffers are "custom"
   * @type Object
   */
  var sourceBufferMemory = {
    native: {}, // SourceBuffers added to the MediaSource
    custom: {} // custom SourceBuffers managed entirely in the Rx-PLayer
  };

  /**
   * Backoff options used given to the backoff retry done with the manifest
   * pipeline.
   * @see retryWithBackoff
   */
  var retryOptions = {
    totalRetry: 3,
    retryDelay: 250,
    resetDelay: 60 * 1000,
    shouldRetry: function shouldRetry(error) {
      return error.fatal !== true;
    },
    errorSelector: function errorSelector(error) {
      if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11__errors__["d" /* isKnownError */])(error)) {
        error = new __WEBPACK_IMPORTED_MODULE_11__errors__["e" /* OtherError */]("NONE", error, true);
      }
      error.fatal = true;
      return error;
    },
    onRetry: function onRetry(error, tryCount) {
      __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].warn("stream retry", error, tryCount);
      errorStream.next(error);
    }
  };

  /**
   * End-Of-Play emit when the current timing is really close to the end.
   * @see END_OF_PLAY
   * @type {Observable}
   */
  var endOfPlay = timings$.filter(function (_ref3) {
    var currentTime = _ref3.currentTime,
        duration = _ref3.duration;
    return duration > 0 && duration - currentTime < END_OF_PLAY;
  });

  /**
   * On subscription:
   *   - load the manifest (through its pipeline)
   *   - wiat for the given mediasource to be open
   * Once those are done, initialize the source duration and creates every
   * SourceBuffers and Buffers instances.
   *
   * This Observable can be retried on the basis of the retryOptions defined
   * here.
   * @param {Object} params
   * @param {string} params.url
   * @param {MediaSource|null} params.mediaSource
   * @returns {Observable}
   */
  var startStream = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_retry__["b" /* retryableFuncWithBackoff */])(function (_ref4) {
    var url = _ref4.url,
        mediaSource = _ref4.mediaSource;

    var sourceOpening$ = mediaSource ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13__compat_events_js__["g" /* onSourceOpen$ */])(mediaSource) : __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(null);

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(fetchManifest(url), sourceOpening$).mergeMap(function (_ref5) {
      var manifest = _ref5[0];
      return createStream(mediaSource, manifest);
    });
  }, retryOptions);

  /**
   * Creates a stream of audio/video/text buffers given a set of
   * adaptations and a codec information.
   *
   * For each buffer stream, a unique "sourceBuffer" observable is
   * created that will be reused for each created buffer.
   *
   * An "adaptations choice" observable is also created and
   * responsible for changing the video or audio adaptation choice in
   * reaction to user choices (ie. changing the language).
   *
   * @param {MediaSource} mediaSource
   * @param {Object} bufferInfos - Per-type object containing the adaptions,
   * the codec and the type
   * @param {Observable} timings
   * @param {Observable} seekings
   * @returns {Observable}
   */
  function createBuffer(mediaSource, bufferType, codec, timings, seekings, manifest, adaptation$, abrManager) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_assert__["a" /* default */])(transport[bufferType], "stream: no management found for type " + bufferType);
    }
    var pipelineOptions = getPipelineOptions(bufferType);
    return adaptation$.switchMap(function (adaptation) {
      if (!adaptation) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19__source_buffers__["a" /* disposeSourceBuffer */])(videoElement, mediaSource, bufferType, sourceBufferMemory);
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__buffer__["a" /* EmptyBuffer */])({ bufferType: bufferType }).startWith({
          type: "adaptationChange",
          value: {
            type: bufferType,
            adaptation: adaptation
          }
        });
      }

      /**
       * Keep the current representation to add informations to the ABR clock.
       * TODO isn't that a little bit ugly?
       * @type {Object|null}
       */
      var currentRepresentation = null;

      var abrClock$ = timings$.map(function (timing) {
        var bitrate = void 0,
            lastIndexPosition = void 0;

        if (currentRepresentation) {
          bitrate = currentRepresentation.bitrate;

          if (currentRepresentation.index) {
            lastIndexPosition = currentRepresentation.index.getLastPosition();
          }
        }

        return {
          bitrate: bitrate,
          bufferGap: timing.bufferGap,
          duration: timing.duration,
          isLive: manifest.isLive,
          lastIndexPosition: lastIndexPosition,
          position: timing.currentTime,
          speed: speed$.getValue()
        };
      });

      var representations = adaptation.representations;


      var abr$ = abrManager.get$(bufferType, abrClock$, representations);
      var representation$ = abr$.map(function (_ref6) {
        var representation = _ref6.representation;
        return representation;
      }).distinctUntilChanged(function (a, b) {
        return (a && a.bitrate) === (b && b.bitrate) && (a && a.id) === (b && b.id);
      }).do(function (representation) {
        return currentRepresentation = representation;
      });

      var sourceBuffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19__source_buffers__["b" /* createSourceBuffer */])(videoElement, mediaSource, bufferType, codec, sourceBufferMemory, bufferType === "text" ? textTrackOptions : {});

      var downloader = function downloader(_ref7) {
        var segment = _ref7.segment,
            representation = _ref7.representation,
            init = _ref7.init;

        var pipeline$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16__pipelines_index_js__["a" /* default */])(transport[bufferType], pipelineOptions)({
          segment: segment,
          representation: representation,
          adaptation: adaptation,
          manifest: manifest,
          init: init
        });
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_23__process_pipeline_js__["a" /* default */])(bufferType, pipeline$, network$, requestsInfos$, errorStream);
      };

      var switchRepresentation$ = __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(representation$, seekings).map(function (_ref8) {
        var representation = _ref8[0];
        return representation;
      });

      var buffer$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__buffer__["b" /* Buffer */])({
        sourceBuffer: sourceBuffer,
        downloader: downloader,
        switch$: switchRepresentation$,
        clock$: timings,
        wantedBufferAhead: wantedBufferAhead$,
        maxBufferBehind: maxBufferBehind$,
        maxBufferAhead: maxBufferAhead$,
        bufferType: bufferType,
        isLive: manifest.isLive
      }).startWith({
        type: "adaptationChange",
        value: {
          type: bufferType,
          adaptation: adaptation
        }
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].error("buffer", bufferType, "has crashed", error);

        // non native buffer should not impact the stability of the
        // player. ie: if a text buffer sends an error, we want to
        // continue streaming without any subtitles
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19__source_buffers__["c" /* shouldHaveNativeSourceBuffer */])(bufferType)) {
          errorStream.next(error);
          return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
        }
        throw error; // else, throw
      });

      var bitrateEstimate$ = abr$.filter(function (_ref9) {
        var bitrate = _ref9.bitrate;
        return bitrate != null;
      }).map(function (_ref10) {
        var bitrate = _ref10.bitrate;

        return {
          type: "bitrateEstimationChange",
          value: {
            type: bufferType,
            bitrate: bitrate
          }
        };
      });

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(buffer$, bitrateEstimate$);
    });
  }

  /**
   * Creates an observable waiting for the "loadedmetadata" and "canplay"
   * events, and emitting a "loaded" event as both are received.
   *
   * /!\ This has also the side effect of setting the initial time as soon as
   * the loadedmetadata event pops up.
   * @param {Object} manifest
   * @returns {Observable}
   */
  function createVideoEventsObservables(manifest, timings) {
    var startTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18__initial_time_js__["a" /* default */])(manifest, startAt);

    /**
     * Time offset is an offset to add to the timing's current time to have
     * the "real" position.
     * For now, this is seen when the video has not yet seeked to its initial
     * position, the currentTime will most probably be 0 where the effective
     * starting position will be _startTime_.
     * Thus we initially set a timeOffset equal to startTime.
     * TODO That look ugly, find better solution?
     * @type {Number}
     */
    var timeOffset = startTime;

    var canSeek$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__compat__["i" /* canSeek */])(videoElement).do(function () {
      __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].info("set initial time", startTime);

      // reset playbackRate to 1 in case we were at 0 (from a stalled
      // retry for instance)
      videoElement.playbackRate = 1;
      videoElement.currentTime = startTime;
      timeOffset = 0;
    });

    var canPlay$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__compat__["j" /* canPlay */])(videoElement).do(function () {
      __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].info("canplay event");
      if (autoPlay) {
        videoElement.play();
      }
      autoPlay = true;
    });

    return {
      clock$: timings.map(function (timing) {
        return __WEBPACK_IMPORTED_MODULE_3_object_assign___default()({ timeOffset: timeOffset }, timing);
      }),

      loaded$: __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].combineLatest(canSeek$, canPlay$).take(1).mapTo({ type: "loaded", value: true })
    };
  }

  /**
   * Re-fetch the manifest and merge it with the previous version.
   * @param {Object} manifest
   * @returns {Observable}
   */
  function refreshManifest(manifest) {
    return fetchManifest(manifest.getUrl()).map(function (parsed) {
      var newManifest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__manifest__["b" /* updateManifest */])(manifest, parsed);
      return {
        type: "manifestUpdate",
        value: {
          manifest: newManifest
        }
      };
    });
  }

  /**
   * Handle events happening only in live contexts.
   * @param {Object} message
   * @param {Object} manifest
   * @returns {Observable}
   */
  function liveMessageHandler(message, manifest) {
    switch (message.type) {
      case "index-discontinuity":
        __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].warn("explicit discontinuity seek", message.value.ts);
        videoElement.currentTime = message.value.ts;
        break;

      // precondition-failed messages require a change of live-gap to
      // calibrate the live representation of the player
      // TODO(pierre): smarter converging algorithm
      case "precondition-failed":
        manifest.updateLiveGap(1); // go back 1s for now
        __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].warn("precondition failed", manifest.presentationLiveGap);
        break;

      case "out-of-index":
        // out-of-index messages require a complete reloading of the
        // manifest to refresh the current index
        __WEBPACK_IMPORTED_MODULE_6__utils_log__["a" /* default */].info("out of index");
        return refreshManifest(manifest);
    }

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(message);
  }

  /**
   * Creates a stream merging all observable that are required to make
   * the system cooperate.
   * @param {MediaSource} mediaSource
   * @param {Object} manifest
   * @returns {Observable}
   */
  function createStream(mediaSource, manifest) {
    if (mediaSource) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__media_source_js__["a" /* setDurationToMediaSource */])(mediaSource, manifest.getDuration());
    }

    var _createTimings = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_21__timings_js__["a" /* default */])(manifest, timings$),
        _timings = _createTimings.timings,
        seekings = _createTimings.seekings;

    var _createVideoEventsObs = createVideoEventsObservables(manifest, _timings),
        loaded$ = _createVideoEventsObs.loaded$,
        clock$ = _createVideoEventsObs.clock$;

    var abrManager = new __WEBPACK_IMPORTED_MODULE_17__abr__["a" /* default */](requestsInfos$, network$, // emit network metrics such as the observed bandwidth
    adaptiveOptions);

    var adaptations$ = {};
    var _buffersArray = Object.keys(manifest.adaptations).map(function (type) {
      adaptations$[type] = new __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__["ReplaySubject"](1);

      // TODO re-check that
      var codec = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__manifest__["c" /* getCodec */])(manifest.adaptations[type][0].representations[0]);

      // Initialize all native source buffer at the same time. We cannot
      // lazily create native sourcebuffers since the spec does not
      // allow adding them during playback.
      //
      // From https://w3c.github.io/media-source/#methods
      //    For example, a user agent may throw a QuotaExceededError
      //    exception if the media element has reached the HAVE_METADATA
      //    readyState. This can occur if the user agent's media engine
      //    does not support adding more tracks during playback.
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19__source_buffers__["c" /* shouldHaveNativeSourceBuffer */])(type)) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19__source_buffers__["d" /* addNativeSourceBuffer */])(mediaSource, type, codec, sourceBufferMemory);
      }

      return createBuffer(mediaSource, type, codec, clock$, seekings, manifest, adaptations$[type], abrManager);
    });

    var buffers$ = manifest.isLive ? __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge.apply(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"], _buffersArray).mergeMap(function (message) {
      return liveMessageHandler(message, manifest);
    }) : __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge.apply(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"], _buffersArray);

    var manifest$ = __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({
      type: "manifestChange",
      value: {
        manifest: manifest,
        adaptations$: adaptations$,
        abrManager: abrManager
      }
    });

    var emeManager$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_26__eme_js__["a" /* default */])(videoElement, keySystems, errorStream);

    var speedManager$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24__speed_manager_js__["a" /* default */])(videoElement, speed$, _timings, {
      changePlaybackRate: withMediaSource
    }).map(function (newSpeed) {
      return { type: "speed", value: newSpeed };
    });

    var stallingManager$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_25__stalling_obs_js__["a" /* default */])(videoElement, manifest, _timings).map(function (stalledStatus) {
      return { type: "stalled", value: stalledStatus };
    });

    var mediaErrorManager$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22__error_stream_js__["a" /* default */])(videoElement);

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(buffers$, emeManager$, loaded$, manifest$, mediaErrorManager$, speedManager$, stallingManager$).finally(function () {
      return abrManager.dispose();
    });
  }

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__media_source_js__["b" /* createAndPlugMediaSource */])(url, videoElement, withMediaSource, sourceBufferMemory).mergeMap(startStream).takeUntil(endOfPlay);
}

/***/ }),
/* 779 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getInitialTime;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__manifest_timings_js__ = __webpack_require__(105);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var DEFAULT_LIVE_GAP = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_LIVE_GAP;

/**
 * Returns the calculated initial time for the stream described by the given
 * manifest:
 *   1. if a start time is defined by user, calculate video starting time from
 *      the manifest informations
 *   2. else if the video is live, use the live edge and suggested delays from
 *      it
 *   3. else returns 0 (beginning)
 *
 * @param {Manifest} manifest
 * @param {Object} startAt
 * @returns {Number}
 */

function getInitialTime(manifest, startAt) {
  if (startAt) {
    var _getBufferLimits = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__manifest_timings_js__["e" /* getBufferLimits */])(manifest),
        min = _getBufferLimits[0],
        max = _getBufferLimits[1];

    if (startAt.position != null) {
      return Math.max(Math.min(startAt.position, max), min);
    } else if (startAt.wallClockTime != null) {
      var position = manifest.isLive ? startAt.wallClockTime - manifest.availabilityStartTime : startAt.wallClockTime;

      return Math.max(Math.min(position, max), min);
    } else if (startAt.fromFirstPosition != null) {
      var fromFirstPosition = startAt.fromFirstPosition;

      return fromFirstPosition <= 0 ? min : Math.min(min + fromFirstPosition, max);
    } else if (startAt.fromLastPosition != null) {
      var fromLastPosition = startAt.fromLastPosition;

      return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
    } else if (startAt.percentage != null) {
      var percentage = startAt.percentage;

      if (percentage > 100) {
        return max;
      } else if (percentage < 0) {
        return min;
      }
      var ratio = +percentage / 100;
      var extent = max - min;
      return min + extent * ratio;
    }
  }

  if (manifest.isLive) {
    var sgp = manifest.suggestedPresentationDelay;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__manifest_timings_js__["d" /* getMaximumBufferPosition */])(manifest) - (sgp == null ? DEFAULT_LIVE_GAP : sgp);
  }
  return 0;
}

/***/ }),
/* 780 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createAndPlugMediaSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setDurationToMediaSource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errors_MediaError_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compat__ = __webpack_require__(22);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Side effect that set the media duration in the mediaSource. This side
 * effect occurs when we receive the "sourceopen" from the
 * mediaSource.
 * @param {MediaSource} mediaSource
 * @param {Object} manifest
 */
var setDurationToMediaSource = function setDurationToMediaSource(mediaSource, duration) {
  var newDuration = void 0;
  if (duration === Infinity) {
    // TODO(pierre): hack for Chrome 42
    // is it "https://bugs.chromium.org/p/chromium/issues/detail?id=461733"?
    newDuration = Number.MAX_VALUE;
  } else {
    newDuration = duration;
  }

  if (mediaSource.duration !== newDuration) {
    mediaSource.duration = newDuration;
    __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].info("set duration", mediaSource.duration);
  }
};

/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * video element's src attribute.
 *
 * Returns an Observable which emits one time when done an object with the
 * following properties:
 *
 *   - src {string} - the src given
 *
 *   - mediaSource {MediaSource|null} - the MediaSource instance. Can be null
 *     in the case no MediaSource is needed.
 *
 * This Observable never completes. It can throw if MediaSource is needed but
 * is not available in the current environment.
 *
 * On unsubscription, the video.src is cleaned, MediaSource sourcenuffers and
 * customBuffers are aborted and some minor cleaning is done.
 *
 * @param {string} url
 * @param {HTMLMediaElement} video
 * @param {Boolean} withMediaSource
 * @param {Object} customBuffers
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.custom
 * @param {Object} sourceBufferMemory.native
 * @returns {Observable}
 */
var createAndPlugMediaSource = function createAndPlugMediaSource(url, video, withMediaSource, sourceBufferMemory) {
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (observer) {
    var mediaSource = void 0,
        objectURL = void 0;
    var nativeBuffers = sourceBufferMemory.native,
        customBuffers = sourceBufferMemory.custom;


    function resetMediaElement() {
      if (mediaSource && mediaSource.readyState != "closed") {
        var _mediaSource = mediaSource,
            readyState = _mediaSource.readyState,
            sourceBuffers = _mediaSource.sourceBuffers;

        for (var i = 0; i < sourceBuffers.length; i++) {
          var sourceBuffer = sourceBuffers[i];
          try {
            if (readyState == "open") {
              sourceBuffer.abort();
            }

            mediaSource.removeSourceBuffer(sourceBuffer);
          } catch (e) {
            __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("error while disposing souceBuffer", e);
          }
        }
      }

      Object.keys(nativeBuffers).forEach(function (type) {
        delete nativeBuffers[type];
      });

      Object.keys(customBuffers).forEach(function (sourceBufferType) {
        var sourceBuffer = customBuffers[sourceBufferType];
        try {
          sourceBuffer.abort();
        } catch (e) {
          __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("error while disposing souceBuffer", e);
        }
        delete customBuffers[sourceBufferType];
      });

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat__["k" /* clearVideoSrc */])(video);

      if (objectURL) {
        try {
          URL.revokeObjectURL(objectURL);
        } catch (e) {
          __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].warn("error while revoking ObjectURL", e);
        }
      }

      mediaSource = null;
      objectURL = null;
    }

    // make sure the media has been correctly reset
    resetMediaElement();

    if (withMediaSource) {
      if (!__WEBPACK_IMPORTED_MODULE_3__compat__["l" /* MediaSource_ */]) {
        throw new __WEBPACK_IMPORTED_MODULE_1__errors_MediaError_js__["a" /* default */]("MEDIA_SOURCE_NOT_SUPPORTED", null, true);
      }
      mediaSource = new __WEBPACK_IMPORTED_MODULE_3__compat__["l" /* MediaSource_ */]();
      objectURL = URL.createObjectURL(mediaSource);
    } else {
      mediaSource = null;
      objectURL = url;
    }

    video.src = objectURL;

    observer.next({ url: url, mediaSource: mediaSource });
    __WEBPACK_IMPORTED_MODULE_2__utils_log__["a" /* default */].info("create mediasource object", objectURL);

    return resetMediaElement;
  });
};



/***/ }),
/* 781 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = processPipeline;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Process a pipeline observable to adapt it to the Stream way:
 *   - use the network$ subject for network metrics (bandwitdh mesure)
 *   - use the requests subject for network requests and their progress
 *   - use the warning$ subject for retries' error messages
 *   - only emit the data
 *
 * @param {string} pipelineType
 * @param {Observable} pipeline$
 * @param {Subject} network$
 * @param {Subject} warning$
 * @returns {Observable}
 */
function processPipeline(pipelineType, pipeline$, network$, requests$, warning$) {
  var request$ = void 0;
  var segmentId = void 0;
  return pipeline$.filter(function (_ref) {
    var type = _ref.type,
        value = _ref.value;

    if (type === "data") {
      return true;
    }

    // ugly to do side effect in a filter, but heh
    if (type === "error") {
      // value is an Error. Add the pipeline type information to it.
      value.pipelineType = pipelineType;
      warning$.next(value);
    } else if (pipelineType === "manifest") {
      return;
    } else if (type === "metrics") {
      // format it for ABR Handling
      network$.next({ type: pipelineType, value: value });
    } else if (type === "request") {
      // format it for ABR Handling if the right format
      var segment = value && value.segment;
      if (segment != null) {
        var duration = segment.duration / segment.timescale;
        var time = segment.time / segment.timescale;
        segmentId = segment.id;

        var segmentInfos = {
          duration: isNaN(duration) ? undefined : duration,
          time: isNaN(time) ? undefined : time,
          requestTimestamp: Date.now(),
          id: segmentId
        };

        request$ = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]();
        requests$.next(request$);

        request$.next({
          type: pipelineType,
          event: "requestBegin",
          value: segmentInfos
        });
      }
    } else if (type === "progress") {
      if (value.size === value.totalSize) {
        return;
      }
      var progressInfos = {
        duration: value.duration,
        size: value.size,
        totalSize: value.totalSize,
        timestamp: Date.now(),
        id: segmentId
      };

      request$.next({
        type: pipelineType,
        event: "progress",
        value: progressInfos
      });
    }
  }).map(function (_ref2) {
    var value = _ref2.value;

    return value;
  }) // take only value from data/cache events
  .finally(function () {
    if (request$) {
      if (segmentId != null) {
        request$.next({
          type: pipelineType,
          event: "requestEnd",
          value: { id: segmentId }
        });
      }
      request$.complete();
    }
  }).share(); // avoid multiple side effects if multiple subs
}

/***/ }),
/* 782 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__abstract_js__ = __webpack_require__(150);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var ImageSourceBuffer = function (_AbstractSourceBuffer) {
  _inherits(ImageSourceBuffer, _AbstractSourceBuffer);

  function ImageSourceBuffer() {
    _classCallCheck(this, ImageSourceBuffer);

    return _possibleConstructorReturn(this, _AbstractSourceBuffer.apply(this, arguments));
  }

  ImageSourceBuffer.prototype._append = function _append() {
    // TODO: handle live case.
    // We suppose here that the first received bsi includes all images
    this.buffered.insert(0, Number.MAX_VALUE);
  };

  return ImageSourceBuffer;
}(__WEBPACK_IMPORTED_MODULE_0__abstract_js__["a" /* AbstractSourceBuffer */]);

/* harmony default export */ __webpack_exports__["a"] = (ImageSourceBuffer);

/***/ }),
/* 783 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return shouldHaveNativeSourceBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return addNativeSourceBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createSourceBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disposeSourceBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__text__ = __webpack_require__(787);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__image__ = __webpack_require__(782);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" source buffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */
var shouldHaveNativeSourceBuffer = function shouldHaveNativeSourceBuffer(bufferType) {
  return bufferType == "audio" || bufferType == "video";
};

/**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} type - The "type" of SourceBuffer (audio/video...)
 * @param {string} codec
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.native
 * @returns {SourceBuffer}
 */
function addNativeSourceBuffer(mediaSource, type, codec, _ref) {
  var native = _ref.native;

  if (!native[type]) {
    __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("add sourcebuffer", codec);
    native[type] = mediaSource.addSourceBuffer(codec);
  }
  return native[type];
}

/**
 * Creates a new SourceBuffer.
 * Can be a native one (audio/video) as well as a custom one (image/text).
 * @throws MediaError - The type of bugger given is unknown.
 * @param {HTMLMediaElement} video
 * @param {MediaSource} mediaSource
 * @param {string} type
 * @param {string} codex
 * @param {Object} custom
 * @param {Object} custom
 * @returns {SourceBuffer|AbstractSourceBuffer}
 */
function createSourceBuffer(video, mediaSource, type, codec, sourceBufferMemory) {
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

  var sourceBuffer = void 0;

  if (shouldHaveNativeSourceBuffer(type)) {
    sourceBuffer = addNativeSourceBuffer(mediaSource, type, codec, sourceBufferMemory);
  } else {
    var custom = sourceBufferMemory.custom;

    var oldSourceBuffer = custom[type];
    if (oldSourceBuffer) {
      try {
        oldSourceBuffer.abort();
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].warn(e);
      } finally {
        delete custom[type];
      }
    }

    if (type === "text") {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("add text sourcebuffer", codec);
      if (options.textTrackMode === "html") {
        sourceBuffer = new __WEBPACK_IMPORTED_MODULE_2__text__["a" /* HTMLTextSourceBuffer */](codec, video, options.textTrackElement);
      } else {
        sourceBuffer = new __WEBPACK_IMPORTED_MODULE_2__text__["b" /* NativeTextSourceBuffer */](codec, video, options.hideNativeSubtitle);
      }
    } else if (type === "image") {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("add image sourcebuffer", codec);
      sourceBuffer = new __WEBPACK_IMPORTED_MODULE_3__image__["a" /* default */](codec);
    } else {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].error("unknown buffer type " + type);
      throw new __WEBPACK_IMPORTED_MODULE_0__errors_MediaError_js__["a" /* default */]("BUFFER_TYPE_UNKNOWN", null, true);
    }

    custom[type] = sourceBuffer;
  }

  return sourceBuffer;
}

/**
 * Abort and remove the SourceBuffer given.
 * @param {HTMLMediaElement} video
 * @param {MediaSource} mediaSource
 * @param {string} type
 * @param {Object} sourceBufferMemory
 * @param {Object} sourceBufferMemory.native
 * @param {Object} sourceBufferMemory.custom
 */
function disposeSourceBuffer(video, mediaSource, type, sourceBufferMemory) {
  var native = sourceBufferMemory.native,
      custom = sourceBufferMemory.custom;


  var oldSourceBuffer = void 0;

  var isNative = shouldHaveNativeSourceBuffer(type);
  if (isNative) {
    oldSourceBuffer = native[type];
    delete native[type];
  } else {
    oldSourceBuffer = custom[type];
    delete custom[type];
  }

  if (oldSourceBuffer) {
    try {
      oldSourceBuffer.abort();

      if (isNative) {
        mediaSource.removeSourceBuffer(oldSourceBuffer);
      }
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].warn(e);
    }
  }
}



/***/ }),
/* 784 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert_js__ = __webpack_require__(12);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * source buffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the source buffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the source buffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;

/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function areNearlyEqual(a, b) {
  return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}

/**
 * Get cue corresponding to the given time in an array of cues.
 * @param {Number} currentTime
 * @param {Array.<Object>} cues
 * @returns {Object|undefined}
 */
function getCueInCues(currentTime, cues) {
  for (var i = cues.length - 1; i >= 0; i--) {
    var cue = cues[i];
    if (currentTime >= cue.start) {
      if (currentTime < cue.end) {
        return cue;
      } else {
        return;
      }
    }
  }
}

/**
 * Get all cues strictly before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesBefore(cues, time) {
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (time < cue.end) {
      return cues.slice(0, i);
    }
  }
  return cues.slice();
}

/**
 * Get all cues strictly after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesAfter(cues, time) {
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (time < cue.end) {
      return cues.slice(i + 1, cues.length);
    }
  }
  return [];
}

/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */
function removeCuesInfosBetween(cuesInfos, start, end) {
  var cuesInfos1 = {
    start: cuesInfos.start,
    end: start,
    cues: getCuesBefore(cuesInfos.cues, start)
  };

  var cuesInfos2 = {
    start: end,
    end: cuesInfos.end,
    cues: getCuesAfter(cuesInfos.cues, end)
  };
  return [cuesInfos1, cuesInfos2];
}

/**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextBufferManager
 */

var TextBufferManager = function () {
  function TextBufferManager() {
    _classCallCheck(this, TextBufferManager);

    /**
     * CuesBuffer structure: [
     *  {
     *     start: Number,
     *     end: Number,
     *     cues: [  // Cues Group
     *      {
     *        start: Number,
     *        end: Number,
     *        element: HTMLElement,
     *      }
     *     ]
     *   }
     * ]
     * @type {Array.<Object>}
     */
    this._cuesBuffer = [];
  }

  /**
   * Get corresponding cue for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */


  TextBufferManager.prototype.get = function get(time) {
    var cuesBuffer = this._cuesBuffer;

    // begins at the end as most of the time the player will ask for the last
    // CuesGroup
    for (var i = cuesBuffer.length - 1; i >= 0; i--) {
      var cuesInfos = cuesBuffer[i];
      if (time >= cuesInfos.start) {
        if (time < cuesInfos.end) {
          return getCueInCues(time, cuesInfos.cues);
        } else {
          return;
        }
      }
    }
    return;
  };

  /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */


  TextBufferManager.prototype.remove = function remove(from, _to) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(from >= 0);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(_to >= 0);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(_to > from);
    }

    var to = Math.max(from, _to);
    var cuesBuffer = this._cuesBuffer;
    var len = cuesBuffer.length;
    for (var i = 0; i < len; i++) {
      var startCuesInfos = cuesBuffer[i];

      if (startCuesInfos.end >= to) {
        var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to),
            cuesInfos1 = _removeCuesInfosBetwe[0],
            cuesInfos2 = _removeCuesInfosBetwe[1];

        this._cuesBuffer[i] = cuesInfos1;
        cuesBuffer.splice(i + 1, 0, cuesInfos2);
        return;
      } else {
        startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
        startCuesInfos.end = from;
      }

      for (var j = i + 1; j < len; j++) {
        var endCuesInfos = cuesBuffer[i];
        if (to < endCuesInfos.end) {
          cuesBuffer.splice(i + 1, j - (i + 1));
          endCuesInfos.cues = getCuesAfter(endCuesInfos.cues, to);
          endCuesInfos.start = to;
          return;
        }
      }
      cuesBuffer.splice(i + 1, cuesBuffer.length - (i + 1));
      return;
    }
  };

  /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */


  TextBufferManager.prototype.insert = function insert(cues, start, end) {
    var cuesBuffer = this._cuesBuffer;
    var cuesInfosToInsert = { start: start, end: end, cues: cues };
    for (var i = 0; i < cuesBuffer.length; i++) {
      var cuesInfos = cuesBuffer[i];
      if (start < cuesInfos.end) {
        if (areNearlyEqual(start, cuesInfos.start)) {
          if (areNearlyEqual(end, cuesInfos.end)) {
            // exact same segment
            //   ours:            |AAAAA|
            //   the current one: |BBBBB|
            //   Result:          |AAAAA|
            // Which means:
            //   1. replace the current cue with ours
            cuesBuffer[i] = cuesInfosToInsert;
            return;
          } else if (end < cuesInfos.end) {
            // our cue overlaps with the current one:
            //   ours:            |AAAAA|
            //   the current one: |BBBBBBBB|
            //   Result:          |AAAAABBB|
            // Which means:
            //   1. remove some cues at the start of the current one
            //   2. update start of current one
            //   3. add ours before the current one
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          }
          // our cue goes beyond the current one:
          //   ours:            |AAAAAAA|
          //   the current one: |BBBB|
          //   Result:          |AAAAAAA|
          // Here we have to delete any cuesInfos which end before ours end,
          // and see about the following one.
          do {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          } while (cuesInfos && end > cuesInfos.end);

          if (!cuesInfos) {
            // There was no more cue, add ours
            cuesBuffer[i] = cuesInfosToInsert;
            return;
          } else if (areNearlyEqual(end, cuesInfos.end)) {
            cuesBuffer[i] = cuesInfosToInsert; // replace
            return;
          }
          // else -> end < cuesInfos.end (overlapping case)
          //   ours:            |AAAAA|
          //   the current one: |BBBBBBBB|
          //   Result:          |AAAAABBB|
          cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
          cuesInfos.start = end;
          cuesBuffer.splice(i, 0, cuesInfosToInsert);
          return;
        } else if (start < cuesInfos.start) {
          if (end < cuesInfos.start) {
            // our cue goes strictly before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:           |BBBB|
            //   Result:          |AAAAAAA| |BBBB|
            // Which means:
            //   - add ours before the current one
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.start)) {
            // our cue goes just before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:         |BBBB|
            //   Result:          |AAAAAAA|BBBB|
            // Which means:
            //   - update start time of the current one to be sure
            //   - add ours before the current one
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          }
          // our cue overlaps the current one:
          //   ours:            |AAAAAAA|
          //   the current one:     |BBBBB|
          //   Result:          |AAAAAAABB|
          // Which means:
          //   1. remove some cues at the start of the current one
          //   2. update start of current one
          //   3. add ours before the current one
          cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
          cuesInfos.start = end;
          cuesBuffer.splice(i, 0, cuesInfosToInsert);
          return;
        }
        // else -> start > cuesInfos.start
        if (end > cuesInfos.end || areNearlyEqual(end, cuesInfos.end)) {
          // our cue overlaps the current one:
          //   ours:              |AAAAAA|
          //   the current one: |BBBBB|
          //   Result:          |BBAAAAAA|
          //   - or -
          //   ours:              |AAAA|
          //   the current one: |BBBBBB|
          //   Result:          |BBAAAA|
          // Which means:
          //   1. remove some cues at the end of the current one
          //   2. update end of current one
          //   3. add ours after current one
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
          return;
        }
        // else -> end < cuesInfos.end
        // our cue is in the current one:
        //   ours:              |AAA|
        //   the current one: |BBBBBBB|
        //   Result:          |BBAAABB|
        // Which means:
        //   1. split current one in two parts based on our cue.
        //   2. insert our cue into it.

        var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end),
            cuesInfos1 = _removeCuesInfosBetwe2[0],
            cuesInfos2 = _removeCuesInfosBetwe2[1];

        this._cuesBuffer[i] = cuesInfos1;
        cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
        cuesBuffer.splice(i + 2, 0, cuesInfos2);
        return;
      }
    }
    // no cues group has the end after our current start.
    // These cues should be the last one
    cuesBuffer.push(cuesInfosToInsert);
  };

  return TextBufferManager;
}();

/* harmony default export */ __webpack_exports__["a"] = (TextBufferManager);

/***/ }),
/* 785 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compat_events_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__abstract_js__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__buffer_manager_js__ = __webpack_require__(784);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parsers_js__ = __webpack_require__(786);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = __WEBPACK_IMPORTED_MODULE_2__config_js__["a" /* default */].MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL;

/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */

function generateClock(videoElement) {
  var seeking$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat_events_js__["m" /* onSeeking$ */])(videoElement);
  var seeked$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat_events_js__["n" /* onSeeked$ */])(videoElement);
  var ended$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat_events_js__["o" /* onEnded$ */])(videoElement);

  var manualRefresh$ = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].merge(seeked$, ended$);
  var autoRefresh$ = __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).startWith(null);

  // TODO Better way to express that
  return manualRefresh$.startWith(null).switchMapTo(autoRefresh$.mapTo(true).takeUntil(seeking$).concat(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"].of(false)));
}

/**
 * @param {Element} element
 * @param {Element|null} [child]
 */
function safelyRemoveChild(element, child) {
  if (child) {
    try {
      element.removeChild(child);
    } catch (e) {}
  }
}

/**
 * Source buffer to display TextTracks in the given HTML element.
 * @class HTMLTextTrackSourceBuffer
 */

var HTMLTextTrackSourceBuffer = function (_AbstractSourceBuffer) {
  _inherits(HTMLTextTrackSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLTrackElement} textTrackElement
   */
  function HTMLTextTrackSourceBuffer(codec, videoElement, textTrackElement) {
    _classCallCheck(this, HTMLTextTrackSourceBuffer);

    var _this = _possibleConstructorReturn(this, _AbstractSourceBuffer.call(this, codec));

    _this._videoElement = videoElement;
    _this._textTrackElement = textTrackElement;
    _this._destroy$ = new __WEBPACK_IMPORTED_MODULE_0_rxjs_Subject__["Subject"]();
    _this._buffer = new __WEBPACK_IMPORTED_MODULE_5__buffer_manager_js__["a" /* default */]();
    _this._currentElement = null;
    _this._track = null;

    generateClock(_this._videoElement).takeUntil(_this._destroy$).subscribe(function (shouldDisplay) {
      if (!shouldDisplay) {
        safelyRemoveChild(textTrackElement, _this._currentElement);
        _this._currentElement = null;
        return;
      }

      // to spread the time error, we divide the regular chosen interval.
      // As the clock is also based on real video events, we cannot just
      // divide by two the regular interval.
      var time = Math.max(_this._videoElement.currentTime - MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 3000, 0);
      var cue = _this._buffer.get(time);
      if (!cue) {
        safelyRemoveChild(textTrackElement, _this._currentElement);
        _this._currentElement = null;
        return;
      } else if (_this._currentElement === cue.element) {
        return;
      }
      safelyRemoveChild(textTrackElement, _this._currentElement);
      _this._currentElement = cue.element;
      textTrackElement.appendChild(_this._currentElement);
    });
    return _this;
  }

  /**
   * Append text tracks.
   * @param {Object} data
   * @param {string} data.data
   * @param {string} data.language
   * @param {Number} data.timescale
   * @param {Number} data.start
   * @param {Number|undefined} data.end
   */


  HTMLTextTrackSourceBuffer.prototype._append = function _append(data) {
    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;

    if (timescaledEnd - timescaledStart <= 0) {
      // this is accepted for error resilience, just skip that case.
      return;
    }

    var startTime = timescaledStart / timescale;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;

    var cues = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__parsers_js__["a" /* default */])(type, dataString, language);
    var start = startTime;
    var end = endTime != null ? endTime : cues[cues.length - 1].end;
    this._buffer.insert(cues, start, end);
    this.buffered.insert(start, end);
  };

  /**
   * @param {Number} from
   * @param {Number} to
   */


  HTMLTextTrackSourceBuffer.prototype._remove = function _remove(from, to) {
    this._buffer.remove(from, to);
  };

  /**
   * Free up ressources from this sourceBuffer
   */


  HTMLTextTrackSourceBuffer.prototype._abort = function _abort() {
    this._destroy$.next();
    this._destroy$.complete();
    safelyRemoveChild(this._textTrackElement, this._currentElement);
  };

  return HTMLTextTrackSourceBuffer;
}(__WEBPACK_IMPORTED_MODULE_4__abstract_js__["a" /* AbstractSourceBuffer */]);

/* harmony default export */ __webpack_exports__["default"] = (HTMLTextTrackSourceBuffer);

/***/ }),
/* 786 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTextTrackToElements;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var htmlParsers = {};

// TODO manage webvtt

if (true) {
  htmlParsers.sami = __webpack_require__(821).default;
}

if (true) {
  htmlParsers.ttml = __webpack_require__(827).default;
}

if (true) {
  htmlParsers.srt = __webpack_require__(823).default;
}

if (true) {
  htmlParsers.vtt = __webpack_require__(831).default;
}

/**
 * @param {string} type
 * @param {string} data
 * @param {string} [language]
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToElements(type, data, language) {
  var parser = htmlParsers[type];

  if (!parser) {
    throw new Error("no parser found for the given text track");
  }
  return parser(data, language);
}

/***/ }),
/* 787 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTMLTextSourceBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return NativeTextSourceBuffer; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Feature switching the HTML TextTrack implementation
var HAS_HTML_MODE = true || true || true || true;

var HAS_NATIVE_MODE = true || true || true || true;

var HTMLTextSourceBuffer = HAS_HTML_MODE ? __webpack_require__(785).default : function () {
  throw new Error("Cannot display HTML subtitles: feature not activated.");
};

var NativeTextSourceBuffer = HAS_NATIVE_MODE ? __webpack_require__(788).default : function () {
  throw new Error("Cannot display native subtitles: feature not activated.");
};



/***/ }),
/* 788 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_log_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__abstract_js__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parsers_js__ = __webpack_require__(789);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Source buffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextTrackSourceBuffer
 * @extends AbstractSourceBuffer
 */

var NativeTextTrackSourceBuffer = function (_AbstractSourceBuffer) {
  _inherits(NativeTextTrackSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {string} codec
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
  function NativeTextTrackSourceBuffer(codec, videoElement, hideNativeSubtitle) {
    _classCallCheck(this, NativeTextTrackSourceBuffer);

    var _this = _possibleConstructorReturn(this, _AbstractSourceBuffer.call(this, codec));

    var _addTextTrack = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__compat__["n" /* addTextTrack */])(videoElement, hideNativeSubtitle),
        track = _addTextTrack.track,
        trackElement = _addTextTrack.trackElement;

    _this._videoElement = videoElement;
    _this._track = track;
    _this._trackElement = trackElement;
    return _this;
  }

  /**
   * Append text tracks.
   * @param {Object} data
   * @param {string} data.data
   * @param {string} data.language
   * @param {Number} data.timescale
   * @param {Number} data.start
   * @param {Number|undefined} data.end
   */


  NativeTextTrackSourceBuffer.prototype._append = function _append(data) {
    var _this2 = this;

    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;


    if (timescaledEnd - timescaledStart <= 0) {
      // this is accepted for error resilience, just skip that case.
      __WEBPACK_IMPORTED_MODULE_0__utils_log_js__["a" /* default */].warn("Invalid subtitles appended");
      return;
    }

    var startTime = timescaledStart / timescale;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;

    var cues = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__parsers_js__["a" /* default */])(type, dataString, language);
    if (cues.length > 0) {
      var firstCue = cues[0];

      // NOTE(compat): cleanup all current cues if the newly added
      // ones are in the past. this is supposed to fix an issue on
      // IE/Edge.
      var currentCues = this._track.cues;
      if (currentCues.length > 0) {
        if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
          this._remove(firstCue.startTime, +Infinity);
        }
      }

      cues.forEach(function (cue) {
        return _this2._track.addCue(cue);
      });
      this.buffered.insert(startTime, endTime != null ? endTime : cues[cues.length - 1].endTime);
    } else if (endTime != null) {
      this.buffered.insert(startTime, endTime);
    }
  };

  /**
   * @param {Number} from
   * @param {Number} to
   */


  NativeTextTrackSourceBuffer.prototype._remove = function _remove(from, to) {
    var track = this._track;
    var cues = track.cues;
    for (var i = cues.length - 1; i >= 0; i--) {
      var cue = cues[i];
      var startTime = cue.startTime,
          endTime = cue.endTime;

      if (startTime >= from && startTime <= to && endTime <= to) {
        track.removeCue(cue);
      }
    }
    this.buffered.remove(from, to);
  };

  NativeTextTrackSourceBuffer.prototype._abort = function _abort() {
    var _trackElement = this._trackElement,
        _videoElement = this._videoElement;


    if (_trackElement && _videoElement && _videoElement.hasChildNodes()) {
      try {
        _videoElement.removeChild(_trackElement);
      } catch (e) {}
    }

    if (this._track) {
      this._track.mode = "disabled";
      this._track = null;
    }

    if (this._trackElement) {
      this._trackElement.innerHTML = "";
      this._trackElement = null;
    }
  };

  return NativeTextTrackSourceBuffer;
}(__WEBPACK_IMPORTED_MODULE_2__abstract_js__["a" /* AbstractSourceBuffer */]);

/* harmony default export */ __webpack_exports__["default"] = (NativeTextTrackSourceBuffer);

/***/ }),
/* 789 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTextTrackToCues;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var nativeParsers = {};

if (true) {
  nativeParsers.vtt = __webpack_require__(832).default;
}

if (true) {
  nativeParsers.ttml = __webpack_require__(829).default;
}

if (true) {
  nativeParsers.sami = __webpack_require__(822).default;
}

if (true) {
  nativeParsers.srt = __webpack_require__(824).default;
}

/**
 * @param {string} type
 * @param {string} data
 * @param {string} [language]
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToCues(type, data, language) {
  var parser = nativeParsers[type];

  if (!parser) {
    throw new Error("no parser found for the given text track");
  }

  return parser(data, language);
}

/***/ }),
/* 790 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_ranges_js__ = __webpack_require__(54);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */

var ManualTimeRanges = function () {
  function ManualTimeRanges() {
    _classCallCheck(this, ManualTimeRanges);

    this._ranges = [];
    this.length = 0;
  }

  ManualTimeRanges.prototype.insert = function insert(start, end) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(start >= 0, "invalid start time");
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(end - start > 0, "invalid end time");
    }
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_ranges_js__["e" /* insertInto */])(this._ranges, { start: start, end: end });
    this.length = this._ranges.length;
  };

  ManualTimeRanges.prototype.remove = function remove(start, end) {
    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(start >= 0, "invalid start time");
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert_js__["a" /* default */])(end - start > 0, "invalid end time");
    }
    var rangesToIntersect = [];
    if (start > 0) {
      rangesToIntersect.push({ start: 0, end: start });
    }
    if (end < Infinity) {
      rangesToIntersect.push({ start: end, end: Infinity });
    }
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_ranges_js__["f" /* keepRangeIntersection */])(this._ranges, rangesToIntersect);
    this.length = this._ranges.length;
  };

  ManualTimeRanges.prototype.start = function start(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }
    return this._ranges[index].start;
  };

  ManualTimeRanges.prototype.end = function end(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }
    return this._ranges[index].end;
  };

  return ManualTimeRanges;
}();

/* harmony default export */ __webpack_exports__["a"] = (ManualTimeRanges);

/***/ }),
/* 791 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} videoElement
 * @param {BehaviorSubject} speed$ - emit speed set by the user
 * @param {Observable} clock$
 * @param {Object} options
 * @param {Boolean} [options.pauseWhenStalled=true] - true if the player
 * stalling should lead to a pause until it un-stalls.
 * @returns {Observable}
 */
var SpeedManager = function SpeedManager(videoElement, speed$, clock$, _ref) {
  var _ref$pauseWhenStalled = _ref.pauseWhenStalled,
      pauseWhenStalled = _ref$pauseWhenStalled === undefined ? true : _ref$pauseWhenStalled;

  var forcePause$ = void 0;

  if (!pauseWhenStalled) {
    forcePause$ = __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(false).concat(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].never());
  } else {
    forcePause$ = clock$.pairwise().map(function (_ref2) {
      var prevTiming = _ref2[0],
          timing = _ref2[1];

      var isStalled = timing.stalled;
      var wasStalled = prevTiming.stalled;
      if (!wasStalled !== !isStalled || // xor
      wasStalled && isStalled && wasStalled.state !== isStalled.state) {
        return !wasStalled;
      }
    }).filter(function (val) {
      return val != null;
    }).startWith(false);
  }

  return forcePause$.switchMap(function (shouldForcePause) {
    if (shouldForcePause) {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].defer(function () {
        __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("pause playback to build buffer");
        videoElement.playbackRate = 0;
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(0);
      });
    }
    return speed$.do(function (speed) {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].info("resume playback speed", speed);
      videoElement.playbackRate = speed;
    });
  });
};

/* harmony default export */ __webpack_exports__["a"] = (SpeedManager);

/***/ }),
/* 792 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_ranges_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compat__ = __webpack_require__(22);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var DISCONTINUITY_THRESHOLD = __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DISCONTINUITY_THRESHOLD;

/**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {HTMLMediaElement} videoElement
 * @param {Manifest} manifest
 * @param {Observable} timings$
 * @returns {Observable}
 */

function StallingManager(videoElement, manifest, timings$) {
  return timings$.do(function (timing) {
    if (!timing.stalled) {
      return;
    }

    // Perform various checks to try to get out of the stalled state:
    //   1. is it a browser bug? -> force seek at the same current time
    //   2. is it a short discontinuity? -> Seek at the beginning of the
    //                                      next range
    //   3. are we before the buffer depth? -> Seek a little after it
    var buffered = timing.buffered,
        currentTime = timing.currentTime;

    var nextRangeGap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_ranges_js__["d" /* getNextRangeGap */])(buffered, currentTime);

    // Discontinuity check in case we are close a buffer but still
    // calculate a stalled state. This is useful for some
    // implementation that might drop an injected segment, or in
    // case of small discontinuity in the stream.
    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__compat__["m" /* isPlaybackStuck */])(timing)) {
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].warn("after freeze seek", currentTime, timing.range);
      videoElement.currentTime = currentTime;
    } else if (nextRangeGap < DISCONTINUITY_THRESHOLD) {
      var seekTo = currentTime + nextRangeGap + 1 / 60;
      __WEBPACK_IMPORTED_MODULE_1__utils_log__["a" /* default */].warn("discontinuity seek", currentTime, nextRangeGap, seekTo);
      videoElement.currentTime = seekTo;
    }
  }).share().map(function (timing) {
    return timing.stalled;
  }).distinctUntilChanged(function (wasStalled, isStalled) {
    return !wasStalled && !isStalled || wasStalled && isStalled && wasStalled.state === isStalled.state;
  });
}

/* harmony default export */ __webpack_exports__["a"] = (StallingManager);

/***/ }),
/* 793 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__manifest_timings_js__ = __webpack_require__(105);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * TODO I'm not sure that's useful here.
 * seek gap in seconds.
 */
var SEEK_GAP = 2;

/**
 * Observable emitting each time the player is in a true seeking state.
 * That is, the player is seeking and no buffer has been constructed for this
 * range yet.
 * @param {Observable} timingsSampling - the timings observable emitting every
 * seeking events.
 * @returns {Observable}
 */
function seekingsSampler(timingsSampling) {
  return timingsSampling.filter(function (timing) {
    return timing.state == "seeking" && (timing.bufferGap === Infinity ||

    // TODO I don't think that's possible here:
    // the gap is based on the current position and the difference
    // between it and the end of the range this position is in.
    // I don't see how it could be negative.
    // It is Infinity when no range is found for the current position
    timing.bufferGap < -SEEK_GAP);
  })
  // skip the first seeking event generated by the set of the
  // initial seeking time in the video
  // TODO Always the case? check that up
  .skip(1).startWith(true); // TODO What's with the true?
}

/**
 * Create timings and seekings Observables:
 *   - timings is the given timings observable with added informations.
 *   - seekings emits each time the player go in a seeking state.
 * @param {Object} manifest
 * @returns {Object}
 */
function createTimingsAndSeekingsObservables(manifest, timings) {
  var augmentedTimings = timings.map(function (timing) {
    var clonedTiming = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, timing);

    // TODO remove liveGap for non-live?
    clonedTiming.liveGap = manifest.isLive ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__manifest_timings_js__["d" /* getMaximumBufferPosition */])(manifest) - timing.currentTime : Infinity;
    return clonedTiming;
  });

  var seekings = seekingsSampler(augmentedTimings);

  return {
    timings: augmentedTimings,
    seekings: seekings
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createTimingsAndSeekingsObservables);

/***/ }),
/* 794 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errorMessage_js__ = __webpack_require__(82);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @class IndexError
 */
function IndexError(code, indexType, fatal) {
  this.name = "IndexError";
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].INDEX_ERROR;

  this.indexType = indexType;

  this.reason = null;
  this.code = __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* ErrorCodes */][code];
  this.fatal = fatal;
  this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, null);
}
IndexError.prototype = new Error();

/* harmony default export */ __webpack_exports__["a"] = (IndexError);

/***/ }),
/* 795 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errorMessage_js__ = __webpack_require__(82);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @class NetworkError
 */
function NetworkError(code, reason, fatal) {
  this.name = "NetworkError";
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].NETWORK_ERROR;

  this.xhr = reason.xhr;
  this.url = reason.url;
  this.status = reason.status;
  this.reqType = reason.type;

  this.reason = reason;
  this.code = __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* ErrorCodes */][code];
  this.fatal = fatal;
  if (this.reason) {
    this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, this.reason);
  } else {
    var reasonMessage = "" + this.reqType + (this.status > 0 ? "(" + this.status + ")" : "") + " on " + this.url;
    this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, {
      message: reasonMessage
    });
  }
}
NetworkError.prototype = new Error();

NetworkError.prototype.isHttpError = function (httpErrorCode) {
  return this.reqType == __WEBPACK_IMPORTED_MODULE_0__constants_js__["c" /* RequestErrorTypes */].ERROR_HTTP_CODE && this.status == httpErrorCode;
};

/* harmony default export */ __webpack_exports__["a"] = (NetworkError);

/***/ }),
/* 796 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errorMessage_js__ = __webpack_require__(82);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @class OtherError
 */
function OtherError(code, reason, fatal) {
  this.name = "OtherError";
  this.type = __WEBPACK_IMPORTED_MODULE_0__constants_js__["a" /* ErrorTypes */].OTHER_ERROR;

  this.reason = reason;
  this.code = __WEBPACK_IMPORTED_MODULE_0__constants_js__["b" /* ErrorCodes */][code];
  this.fatal = fatal;
  this.message = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__errorMessage_js__["a" /* default */])(this.name, this.code, this.reason);
}
OtherError.prototype = new Error();

/* harmony default export */ __webpack_exports__["a"] = (OtherError);

/***/ }),
/* 797 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @class RequestError
 */
function RequestError(xhr, url, type) {
  this.name = "RequestError";
  this.url = url;
  this.xhr = xhr;
  this.status = xhr.status;
  this.type = type;
  this.message = type;
}
RequestError.prototype = new Error();

/* harmony default export */ __webpack_exports__["a"] = (RequestError);

/***/ }),
/* 798 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_add_observable_combineLatest__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_add_observable_combineLatest___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_add_observable_combineLatest__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_observable_defer__ = __webpack_require__(669);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_observable_defer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_add_observable_defer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_empty__ = __webpack_require__(670);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_empty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_add_observable_empty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_from__ = __webpack_require__(671);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_from___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_add_observable_from__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent__ = __webpack_require__(672);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_fromEvent__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_fromPromise__ = __webpack_require__(673);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_observable_fromPromise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_observable_interval__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_observable_interval___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_add_observable_interval__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_observable_merge__ = __webpack_require__(674);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_add_observable_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_add_observable_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_never__ = __webpack_require__(675);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_never___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_add_observable_never__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_of__ = __webpack_require__(676);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_add_observable_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_observable_throw__ = __webpack_require__(677);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_rxjs_add_observable_throw___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_rxjs_add_observable_throw__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_observable_timer__ = __webpack_require__(678);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_rxjs_add_observable_timer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_rxjs_add_observable_timer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_catch__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_rxjs_add_operator_catch__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_concat__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_concat___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_rxjs_add_operator_concat__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_concatAll__ = __webpack_require__(679);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_concatAll___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_rxjs_add_operator_concatAll__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_concatMap__ = __webpack_require__(680);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_concatMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_rxjs_add_operator_concatMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_debounceTime__ = __webpack_require__(681);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_debounceTime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_rxjs_add_operator_debounceTime__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_distinctUntilChanged__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_distinctUntilChanged___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_rxjs_add_operator_distinctUntilChanged__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_add_operator_do__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_rxjs_add_operator_do___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_rxjs_add_operator_do__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_filter__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_rxjs_add_operator_filter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_finally__ = __webpack_require__(682);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_finally___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20_rxjs_add_operator_finally__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_ignoreElements__ = __webpack_require__(683);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_ignoreElements___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_rxjs_add_operator_ignoreElements__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_mapTo__ = __webpack_require__(684);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_mapTo___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23_rxjs_add_operator_mapTo__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_rxjs_add_operator_merge__ = __webpack_require__(685);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_rxjs_add_operator_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24_rxjs_add_operator_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_mergeMap__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25_rxjs_add_operator_mergeMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_rxjs_add_operator_multicast__ = __webpack_require__(686);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_rxjs_add_operator_multicast___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26_rxjs_add_operator_multicast__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_rxjs_add_operator_pairwise__ = __webpack_require__(687);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_rxjs_add_operator_pairwise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27_rxjs_add_operator_pairwise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_rxjs_add_operator_publish__ = __webpack_require__(688);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_rxjs_add_operator_publish___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_28_rxjs_add_operator_publish__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_rxjs_add_operator_scan__ = __webpack_require__(689);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_rxjs_add_operator_scan___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_29_rxjs_add_operator_scan__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_rxjs_add_operator_share__ = __webpack_require__(690);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_rxjs_add_operator_share___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_30_rxjs_add_operator_share__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_rxjs_add_operator_skip__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_rxjs_add_operator_skip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_31_rxjs_add_operator_skip__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32_rxjs_add_operator_startWith__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32_rxjs_add_operator_startWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_32_rxjs_add_operator_startWith__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33_rxjs_add_operator_switchMap__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33_rxjs_add_operator_switchMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_33_rxjs_add_operator_switchMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34_rxjs_add_operator_switchMapTo__ = __webpack_require__(691);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34_rxjs_add_operator_switchMapTo___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_34_rxjs_add_operator_switchMapTo__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35_rxjs_add_operator_take__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35_rxjs_add_operator_take___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_35_rxjs_add_operator_take__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36_rxjs_add_operator_takeUntil__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36_rxjs_add_operator_takeUntil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_36_rxjs_add_operator_takeUntil__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37_rxjs_add_operator_timeout__ = __webpack_require__(692);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37_rxjs_add_operator_timeout___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_37_rxjs_add_operator_timeout__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__utils_log_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__core_api__ = __webpack_require__(755);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













































if (true) {
  __WEBPACK_IMPORTED_MODULE_38__utils_log_js__["a" /* default */].setLevel("DEBUG");
}

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_39__core_api__["a" /* default */]);

/***/ }),
/* 799 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_array_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__representation_js__ = __webpack_require__(806);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_id_js__ = __webpack_require__(159);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Normalized Adaptation structure.
 *
 * API Public Properties:
 *   - id {string|Number}:
 *   - type {string}
 *   - language {string|undefined}
 *   - normalizedLanguage {string|undefined}
 *   - isAudioDescription {Boolean|undefined}
 *   - isClosedCaption {Boolean|undefined}
 *   - representations {[]Representation}
 *
 * API Public Methods:
 *   - getAvailableBitrates () => {[]Number}
 */

var Adaptation = function () {
  /**
   * @constructor
   * @param {Object} [args={}]
   * @param {string|Number} [args.id]
   * @param {string} args.type
   * @param {string} [args.language]
   * @param {string} [args.normalizedLanguage]
   * @param {Array.<Object>} args.representations
   * @param {Boolean} [args.closedCaption]
   * @param {Boolean} [args.audioDescription]
   * @param {Boolean} args.manual
   */
  function Adaptation() {
    var _this = this;

    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Adaptation);

    var nId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_id_js__["a" /* default */])();
    this.id = args.id == null ? nId : "" + args.id;
    this.type = args.type || "";
    this.representations = Array.isArray(args.representations) ? args.representations.map(function (r) {
      return new __WEBPACK_IMPORTED_MODULE_2__representation_js__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0_object_assign___default()({ rootId: _this.id }, r));
    }).sort(function (a, b) {
      return a.bitrate - b.bitrate;
    }) : [];

    if (args.language != null) {
      this.language = args.language;
    }

    if (args.normalizedLanguage != null) {
      this.normalizedLanguage = args.normalizedLanguage;
    }

    if (args.closedCaption != null) {
      this.isClosedCaption = args.closedCaption;
    }
    if (args.audioDescription != null) {
      this.isAudioDescription = args.audioDescription;
    }

    // TODO rename both protectionData?
    if (args.contentProtection != null) {
      this.contentProtection = args.contentProtection;
    }
    if (args.smoothProtection != null) {
      this._smoothProtection = args.smoothProtection;
    }

    // for manual adaptations (not in the manifest)
    this.manual = args.manual;

    // ---------
    // this._rootURL = args.rootURL;
    // this._baseURL = args.baseURL;
  }

  /**
   * @returns {Array.<Number>}
   */


  Adaptation.prototype.getAvailableBitrates = function getAvailableBitrates() {
    return this.representations.map(function (r) {
      return r.bitrate;
    });
  };

  Adaptation.prototype.getRepresentation = function getRepresentation(wantedId) {
    return __WEBPACK_IMPORTED_MODULE_1_array_find___default()(this.representations, function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  /**
   * @param {Number} bitrate
   * @returns {Representation|null}
   */


  Adaptation.prototype.getRepresentationsForBitrate = function getRepresentationsForBitrate(bitrate) {
    return this.representations.filter(function (r) {
      return r.bitrate === bitrate;
    }) || null;
  };

  return Adaptation;
}();

/* harmony default export */ __webpack_exports__["a"] = (Adaptation);

/***/ }),
/* 800 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_array_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_array_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__adaptation_js__ = __webpack_require__(799);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_id_js__ = __webpack_require__(159);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Normalized Manifest structure.
 *
 * API Public Properties:
 *   - id {string|Number}
 *   - adaptations {Object}:
 *       adaptations.video {[]Adaptation|undefined}
 *       adaptations.audio {[]Adaptation|undefined}
 *       adaptations.text {[]Adaptation|undefined}
 *       adaptations.image {[]Adaptation|undefined}
 *       adaptations.other {[]adaptation|undefined}
 *   - periods {[]Object} TODO
 *   - isLive {Boolean}
 *   - uris {[]string}
 *   - transport {string}
 *
 * API Public Methods:
 *   - getDuration () => {Number} - Returns duration of the entire content, in s
 */

var Manifest = function () {
  /**
   * @constructor
   * @param {Object} [args={}]
   * @param {string|Number} [args.id]
   * @param {string} args.transportType
   * @param {Array.<Object>} args.adaptations
   * @param {string} args.type
   * @param {Array.<string>} args.locations
   * @param {Number} args.duration
   */
  function Manifest() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Manifest);

    var nId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_id_js__["a" /* default */])();
    this.id = args.id == null ? nId : "" + args.id;
    this.transport = args.transportType || "";
    this.adaptations = args.adaptations ? Object.keys(args.adaptations).reduce(function (acc, val) {
      acc[val] = args.adaptations[val].map(function (a) {
        return new __WEBPACK_IMPORTED_MODULE_1__adaptation_js__["a" /* default */](a);
      });
      return acc;
    }, {}) : [];

    // TODO Real period management
    this.periods = [{
      adaptations: this.adaptations
    }];

    this.isLive = args.type === "dynamic";
    this.uris = args.locations || [];

    // --------- private data
    this._duration = args.duration;

    // Will be needed here
    this.suggestedPresentationDelay = args.suggestedPresentationDelay;
    this.availabilityStartTime = args.availabilityStartTime;
    this.presentationLiveGap = args.presentationLiveGap;
    this.timeShiftBufferDepth = args.timeShiftBufferDepth;
  }

  /**
   * @returns {Number}
   */


  Manifest.prototype.getDuration = function getDuration() {
    return this._duration;
  };

  Manifest.prototype.getUrl = function getUrl() {
    return this.uris[0];
  };

  /**
   * @returns {Array.<Object>}
   */


  Manifest.prototype.getAdaptations = function getAdaptations() {
    var adaptationsByType = this.adaptations;
    if (!adaptationsByType) {
      return [];
    }

    var adaptationsList = [];
    for (var type in adaptationsByType) {
      var adaptations = adaptationsByType[type];
      adaptationsList.push.apply(adaptationsList, adaptations);
    }
    return adaptationsList;
  };

  Manifest.prototype.getAdaptation = function getAdaptation(wantedId) {
    return __WEBPACK_IMPORTED_MODULE_0_array_find___default()(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  Manifest.prototype.updateLiveGap = function updateLiveGap(delta) {
    if (this.isLive) {
      this.presentationLiveGap += delta;
    }
  };

  return Manifest;
}();

/* harmony default export */ __webpack_exports__["a"] = (Manifest);

/***/ }),
/* 801 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__timeline_js__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_js__ = __webpack_require__(83);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Provide helpers for SegmentBase-based indexes.
 * @type {Object}
 * TODO weird that everything is inherited from Timeline...
 * Reimplement from scratch
 */
/* harmony default export */ __webpack_exports__["default"] = (__WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, __WEBPACK_IMPORTED_MODULE_1__timeline_js__["default"], {
  getInitSegment: __WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* getInitSegment */],
  setTimescale: __WEBPACK_IMPORTED_MODULE_2__helpers_js__["b" /* setTimescale */],
  scale: __WEBPACK_IMPORTED_MODULE_2__helpers_js__["c" /* scale */],

  /**
   * Add a new segment to the index.
   *
   * /!\ Mutate the given index
   * @param {Object} index
   * @param {Object} segmentInfos
   * @param {Number} segmentInfos.timescale
   * @param {Number} segmentInfos.duration
   * @param {Number} segmentInfos.count
   * @param {*} segmentInfos.range - TODO check type
   * @returns {Boolean} - true if the segment has been added
   */
  _addSegmentInfos: function _addSegmentInfos(index, segmentInfos) {
    if (segmentInfos.timescale !== index.timescale) {
      var timescale = index.timescale;

      index.timeline.push({
        ts: segmentInfos.time / segmentInfos.timescale * timescale,
        d: segmentInfos.duration / segmentInfos.timescale * timescale,
        r: segmentInfos.count,
        range: segmentInfos.range
      });
    } else {
      index.timeline.push({
        ts: segmentInfos.time,
        d: segmentInfos.duration,
        r: segmentInfos.count,
        range: segmentInfos.range
      });
    }
    return true;
  },


  /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */
  shouldRefresh: function shouldRefresh() {
    return false;
  }
}));

/***/ }),
/* 802 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var indexes = {};

if (true) {
  indexes.smooth = __webpack_require__(804).default;
}
if (true) {
  indexes.timeline = __webpack_require__(152).default;
  indexes.template = __webpack_require__(805).default;
  indexes.list = __webpack_require__(803).default;
  indexes.base = __webpack_require__(801).default;
}

/**
 * Indexes have multiple "flavors" depending on the manifest concerned.
 * Here we returns the helpers best adapted to the given index.
 * @param {Object} index
 * @returns {Object|undefined}
 */
var getRightIndexHelpers = function getRightIndexHelpers(index) {
  return indexes[index.indexType];
};

/* harmony default export */ __webpack_exports__["a"] = (getRightIndexHelpers);

/***/ }),
/* 803 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__segment_js__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers_js__ = __webpack_require__(83);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * NEEDED IN INDEX
 * duration
 * list []
 *   ?range
 * timescale
 */

/**
 * Provide helpers for SegmentList-based indexes.
 * @type {Object}
 */
var ListIndexHelpers = {
  getInitSegment: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["a" /* getInitSegment */],
  setTimescale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["b" /* setTimescale */],
  scale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["c" /* scale */],

  /**
   * @param {string|Number} repId
   * @param {Object} index
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Segment>}
   */
  getSegments: function getSegments(repId, index, _up, _to) {
    var _normalizeRange = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["d" /* normalizeRange */])(index, _up, _to),
        up = _normalizeRange.up,
        to = _normalizeRange.to;

    var duration = index.duration,
        list = index.list,
        timescale = index.timescale;

    var length = Math.min(list.length - 1, Math.floor(to / duration));
    var segments = [];
    var i = Math.floor(up / duration);
    while (i <= length) {
      var range = list[i].range;
      var media = list[i].media;
      var args = {
        id: "" + repId + "_" + i,
        time: i * duration,
        init: false,
        range: range,
        duration: duration,
        indexRange: null,
        timescale: timescale,
        media: media
      };
      segments.push(new __WEBPACK_IMPORTED_MODULE_0__segment_js__["a" /* default */](args));
      i++;
    }
    return segments;
  },


  /**
   * Returns first position in index.
   * @returns {Number}
   */
  getFirstPosition: function getFirstPosition() {
    return 0;
  },


  /**
   * Returns last position in index.
   * @param {Object} index
   * @returns {Number}
   */
  getLastPosition: function getLastPosition(index) {
    var duration = index.duration,
        list = index.list;

    return list.length * duration / index.timescale;
  },


  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Object} index
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */
  shouldRefresh: function shouldRefresh(index, time, up, to) {
    var timescale = index.timescale,
        duration = index.duration,
        list = index.list,
        _index$presentationTi = index.presentationTimeOffset,
        presentationTimeOffset = _index$presentationTi === undefined ? 0 : _index$presentationTi;


    var scaledTo = to * timescale - presentationTimeOffset;
    var i = Math.floor(scaledTo / duration);
    return !(i >= 0 && i < list.length);
  },


  /**
   * We do not have to add new segments to SegmentList-based indexes.
   * Return false in any case.
   * @returns {Boolean}
   */
  _addSegmentInfos: function _addSegmentInfos() {
    return false;
  },


  /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */
  checkDiscontinuity: function checkDiscontinuity() {
    return -1;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (ListIndexHelpers);

/***/ }),
/* 804 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timeline_js__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers_js__ = __webpack_require__(83);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/* harmony default export */ __webpack_exports__["default"] = ({
  getSegments: __WEBPACK_IMPORTED_MODULE_0__timeline_js__["default"].getSegments, // TODO Re-implement?
  getInitSegment: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["a" /* getInitSegment */],
  checkDiscontinuity: __WEBPACK_IMPORTED_MODULE_0__timeline_js__["default"].checkDiscontinuity, // TODO Re-implement?
  _addSegmentInfos: __WEBPACK_IMPORTED_MODULE_0__timeline_js__["default"]._addSegmentInfos,
  setTimescale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["b" /* setTimescale */],
  scale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["c" /* scale */],

  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Object} index
   * @param {Number} time
   * @param {Number} from
   * @param {Number} to
   * @returns {Boolean}
   */
  shouldRefresh: function shouldRefresh(index, time, from, to) {
    var timeline = index.timeline,
        timescale = index.timescale,
        _index$presentationTi = index.presentationTimeOffset,
        presentationTimeOffset = _index$presentationTi === undefined ? 0 : _index$presentationTi;


    var scaledTime = time * timescale - presentationTimeOffset;
    var last = timeline[timeline.length - 1];
    if (!last) {
      return false;
    }

    if (last.d < 0) {
      last = { ts: last.ts, d: 0, r: last.r };
    }

    var lastEnd = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(last);
    var scaledTo = to * timescale - presentationTimeOffset;

    // TODO This is an ugly hack, see buffer code.
    // What we do here is to check if we are currently close to the end
    // of the index and if we still have no informations about the next
    // segments.
    // If that's the case we have to refresh.
    return (lastEnd - scaledTime) / timescale <= 1 && scaledTo > lastEnd;
  },


  /**
   * Returns first position in index.
   * @param {Object} index
   * @returns {Number}
   */
  getFirstPosition: function getFirstPosition(index) {
    if (!index.timeline.length) {
      return undefined;
    }
    return index.timeline[0].ts / index.timescale;
  },


  /**
   * Returns last position in index.
   * @param {Object} index
   * @returns {Number}
   */
  getLastPosition: function getLastPosition(index) {
    if (!index.timeline.length) {
      return undefined;
    }
    var lastTimelineElement = index.timeline[index.timeline.length - 1];
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["e" /* getTimelineRangeEnd */])(lastTimelineElement) / index.timescale;
  }
});

/***/ }),
/* 805 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__segment_js__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__helpers_js__ = __webpack_require__(83);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/* harmony default export */ __webpack_exports__["default"] = ({
  getInitSegment: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["a" /* getInitSegment */],
  setTimescale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["b" /* setTimescale */],
  scale: __WEBPACK_IMPORTED_MODULE_1__helpers_js__["c" /* scale */],

  /**
   * @param {string|Number} repId
   * @param {Object} index
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Segment>}
   */
  getSegments: function getSegments(repId, index, _up, _to) {
    var _normalizeRange = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__helpers_js__["d" /* normalizeRange */])(index, _up, _to),
        up = _normalizeRange.up,
        to = _normalizeRange.to;

    var duration = index.duration,
        startNumber = index.startNumber,
        timescale = index.timescale,
        media = index.media;


    var segments = [];
    for (var time = up; time <= to; time += duration) {
      var number = Math.floor(time / duration) + (startNumber == null ? 1 : startNumber);

      var args = {
        id: "" + repId + "_" + number,
        number: number,
        time: number * duration,
        init: false,
        duration: duration,
        range: null,
        indexRange: null,
        timescale: timescale,
        media: media
      };
      segments.push(new __WEBPACK_IMPORTED_MODULE_0__segment_js__["a" /* default */](args));
    }

    return segments;
  },


  /**
   * Returns first position in index.
   * @returns {undefined}
   */
  getFirstPosition: function getFirstPosition() {
    return undefined;
  },


  /**
   * Returns last position in index.
   * @returns {undefined}
   */
  getLastPosition: function getLastPosition() {
    return undefined;
  },


  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */
  shouldRefresh: function shouldRefresh() {
    return false;
  },


  /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */
  checkDiscontinuity: function checkDiscontinuity() {
    return -1;
  },


  /**
   * We do not have to add new segments to SegmentList-based indexes.
   * Return false in any case.
   * @returns {Boolean}
   */
  _addSegmentInfos: function _addSegmentInfos() {
    return false;
  }
});

/***/ }),
/* 806 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_id_js__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__representation_index_js__ = __webpack_require__(807);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Normalized Representation structure.
 *
 * API Public Properties:
 *   - id {string|Number}
 *   - bitrate {Number}
 *   - codec {string}
 *   - height {Number|undefined}
 *   - width {Number|undefined}
 *   - mimeType {Number|undefined}
 *
 * API Public Methods:
 *   - getSegments () => {[]Segment}
 */

var Representation =
/**
 * @constructor
 * @param {Object} [args={}]
 * @param {string|Number} [args.rootId]
 * @param {string|Number} [args.id]
 * @param {Number} args.bitrate
 * @param {string} args.codecs
 * @param {Number} args.height
 * @param {Number} args.width
 * @param {string} args.mimeType
 * @param {Object} args.index
 */
function Representation() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Representation);

  var nId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_id_js__["a" /* default */])();
  this.id = args.id == null ? nId : args.id;
  this.bitrate = args.bitrate;
  this.codec = args.codecs;

  if (args.height != null) {
    this.height = args.height;
  }

  if (args.width != null) {
    this.width = args.width;
  }

  if (args.mimeType != null) {
    this.mimeType = args.mimeType;
  }

  this.index = new __WEBPACK_IMPORTED_MODULE_1__representation_index_js__["a" /* default */]({
    index: args.index,
    rootId: this.id
  });

  this.baseURL = args.baseURL;

  // Most of those are for the smooth init segment
  if (args.codecPrivateData != null) {
    this._codecPrivateData = args.codecPrivateData;
  }
  if (args.channels != null) {
    this._channels = args.channels;
  }
  if (args.bitsPerSample != null) {
    this._bitsPerSample = args.bitsPerSample;
  }
  if (args.packetSize != null) {
    this._packetSize = args.packetSize;
  }
  if (args.samplingRate != null) {
    this._samplingRate = args.samplingRate;
  }

  // this._audioSamplingRate = args.audioSamplingRate;
  // this._codingDependency = args.codingDependency;
  // this._frameRate = args.frameRate;
  // this._maxPlayoutRate = args.maxPlayoutRate;
  // this._maximumSAPPeriod = args.maximumSAPPeriod;
  // this._profiles = args.profiles;
  // this._segmentProfiles = args.segmentProfiles;
};

/* harmony default export */ __webpack_exports__["a"] = (Representation);

/***/ }),
/* 807 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__indexes_index_js__ = __webpack_require__(802);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var RepresentationIndex = function () {
  /**
   * @constructor
   * @param {Object} args
   * @param {Object} args.index
   * @param {string|Number} args.rootId
   */
  function RepresentationIndex(args) {
    _classCallCheck(this, RepresentationIndex);

    this._index = args.index;
    this._rootId = args.rootId;
    this._indexHelpers = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__indexes_index_js__["a" /* default */])(this._index);
  }

  RepresentationIndex.prototype.getInitSegment = function getInitSegment() {
    return this._indexHelpers.getInitSegment(this._rootId, this._index);
  };

  RepresentationIndex.prototype.getSegments = function getSegments(up, duration) {
    return this._indexHelpers.getSegments(this._rootId, this._index, up, duration);
  };

  RepresentationIndex.prototype.shouldRefresh = function shouldRefresh(time, up, to) {
    return this._indexHelpers.shouldRefresh(this._index, time, up, to);
  };

  RepresentationIndex.prototype.getFirstPosition = function getFirstPosition() {
    return this._indexHelpers.getFirstPosition(this._index);
  };

  RepresentationIndex.prototype.getLastPosition = function getLastPosition() {
    return this._indexHelpers.getLastPosition(this._index);
  };

  RepresentationIndex.prototype.checkDiscontinuity = function checkDiscontinuity(time) {
    return this._indexHelpers.checkDiscontinuity(this._index, time);
  };

  /**
   * Returns time given scaled into seconds.
   * @param {Number} time
   * @returns {Number}
   */


  RepresentationIndex.prototype.scale = function scale(time) {
    return this._indexHelpers.scale(this._index, time);
  };

  /**
   * Update the timescale used (for all segments).
   * @param {Number} timescale
   */


  RepresentationIndex.prototype.setTimescale = function setTimescale(timescale) {
    return this._indexHelpers.setTimescale(this._index, timescale);
  };

  RepresentationIndex.prototype._addSegments = function _addSegments(nextSegments, currentSegment) {
    var addedSegments = [];
    for (var i = 0; i < nextSegments.length; i++) {
      if (this._indexHelpers._addSegmentInfos(this._index, nextSegments[i], currentSegment)) {
        addedSegments.push(nextSegments[i]);
      }
    }
    return addedSegments;
  };

  RepresentationIndex.prototype.update = function update(newIndex) {
    this._index = newIndex._index;
  };

  RepresentationIndex.prototype.getType = function getType() {
    return this._index.indexType || "";
  };

  return RepresentationIndex;
}();

/* harmony default export */ __webpack_exports__["a"] = (RepresentationIndex);

/***/ }),
/* 808 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parsers_containers_isobmff_js__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__parsers_images_bif_js__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__manifest__ = __webpack_require__(811);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isobmff_timing_infos_js__ = __webpack_require__(360);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__request_js__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_js__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__segment_loader_js__ = __webpack_require__(813);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__texttracks_js__ = __webpack_require__(814);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @param {Function} [options.contentProtectionParser] - Optional parser for the
 * manifest's content Protection.
 * @returns {Object}
 */
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var segmentLoader = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__segment_loader_js__["a" /* default */])(options.segmentLoader);
  var contentProtectionParser = options.contentProtectionParser;


  if (!contentProtectionParser) {
    contentProtectionParser = function contentProtectionParser() {};
  }

  var manifestPipeline = {
    loader: function loader(_ref) {
      var url = _ref.url;

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__request_js__["a" /* default */])({
        url: url,
        responseType: "document"
      });
    },
    parser: function parser(_ref2) {
      var response = _ref2.response;

      var data = response.responseData;
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({
        manifest: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__manifest__["a" /* default */])(data, contentProtectionParser),
        url: response.url
      });
    }
  };

  var segmentPipeline = {
    loader: function loader(_ref3) {
      var segment = _ref3.segment,
          representation = _ref3.representation,
          adaptation = _ref3.adaptation,
          manifest = _ref3.manifest;

      return segmentLoader({
        segment: segment,
        representation: representation,
        adaptation: adaptation,
        manifest: manifest
      });
    },
    parser: function parser(_ref4) {
      var segment = _ref4.segment,
          adaptation = _ref4.adaptation,
          response = _ref4.response,
          init = _ref4.init;

      var responseData = new Uint8Array(response.responseData);
      var nextSegments = void 0,
          segmentInfos = void 0;
      var segmentData = responseData;

      var indexRange = segment.indexRange;
      var sidxSegments = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__parsers_containers_isobmff_js__["a" /* parseSidx */])(responseData, indexRange ? indexRange[0] : 0);
      if (sidxSegments) {
        nextSegments = sidxSegments;
      }

      if (segment.isInit) {
        segmentInfos = { time: -1, duration: 0 };
        var timescale = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__parsers_containers_isobmff_js__["b" /* getMDHDTimescale */])(responseData);
        if (timescale > 0) {
          segmentInfos.timescale = timescale;
        }
        if (adaptation.contentProtection) {
          segmentData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__parsers_containers_isobmff_js__["c" /* patchPssh */])(responseData, adaptation.contentProtection);
        }
      } else {
        segmentInfos = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__isobmff_timing_infos_js__["a" /* default */])(segment, responseData, sidxSegments, init);
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos, nextSegments: nextSegments });
    }
  };

  var textTrackPipeline = {
    loader: __WEBPACK_IMPORTED_MODULE_9__texttracks_js__["a" /* loader */],
    parser: __WEBPACK_IMPORTED_MODULE_9__texttracks_js__["b" /* parser */]
  };

  var imageTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          representation = _ref5.representation;
      var isInit = segment.isInit;


      if (isInit) {
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
      } else {
        var media = segment.media;


        var path = media ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["a" /* replaceTokens */])(media, segment, representation) : "";
        var mediaUrl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_url__["b" /* resolveURL */])(representation.baseURL, path);
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__request_js__["a" /* default */])({
          url: mediaUrl,
          responseType: "arraybuffer"
        });
      }
    },
    parser: function parser(_ref6) {
      var response = _ref6.response;

      var responseData = response.responseData;
      var blob = new Uint8Array(responseData);

      var segmentInfos = {
        time: 0,
        duration: Number.MAX_VALUE
      };

      var segmentData = void 0;
      if (blob) {
        var bif = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__parsers_images_bif_js__["a" /* default */])(blob);
        segmentData = bif.thumbs;
        segmentInfos.timescale = bif.timescale;

        // TODO
        // var firstThumb = blob[0];
        // var lastThumb  = blob[blob.length - 1];

        // segmentInfos = {
        //   time: firstThumb.ts,
        //   duration:  lastThumb.ts
        // };
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos });
    }
  };

  return {
    directFile: false,
    manifest: manifestPipeline,
    audio: segmentPipeline,
    video: segmentPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});

/***/ }),
/* 809 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_languages__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helpers_js__ = __webpack_require__(361);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */
function parseInitializationAttribute(attrValue) {
  return { media: attrValue, range: undefined };
}

// @see attributes
var RepresentationBaseType = [{ k: "profiles", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "width", fn: parseInt }, { k: "height", fn: parseInt }, { k: "frameRate", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["h" /* parseFrameRate */] }, { k: "audioSamplingRate", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "mimeType", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "segmentProfiles", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "codecs", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "maximumSAPPeriod", fn: parseFloat }, { k: "maxPlayoutRate", fn: parseFloat }, { k: "codingDependency", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["i" /* parseBoolean */] }];

// @see attributes
var SegmentBaseType = [{ k: "timescale", fn: parseInt, def: 1 }, { k: "timeShiftBufferDepth", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "presentationTimeOffset", fn: parseFloat, def: 0 }, { k: "indexRange", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["f" /* parseByteRange */] }, { k: "indexRangeExact", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["i" /* parseBoolean */], def: false }, { k: "availabilityTimeOffset", fn: parseFloat }, { k: "availabilityTimeComplete", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["i" /* parseBoolean */], def: true }];

// @see attributes
var MultipleSegmentBaseType = SegmentBaseType.concat([{ k: "duration", fn: parseInt }, { k: "startNumber", fn: parseInt }]);

/**
 * Object describing how a Dash MPD should be parsed automatically.
 *
 * Basically, immediate keys are the nodeName concerned.
 * They contain array of Objects, each concerning a unique node attributes.
 *
 * The keys these Objects have are as such:
 *
 *   - k {string}: the name of the node attribute
 *
 *   - fn {Function}: the function called to parse this attribute. It takes
 *     as argument the attribute value and should return the parsed value.
 *
 *   - n {string}: new name used for the attribute in the parsed object.
 *
 *   - def {*}: the default value used if the attribute is not found in the
 *     MPD.
 */
var attributes = {
  "ContentProtection": [{ k: "schemeIdUri", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "value", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }],

  "SegmentURL": [{ k: "media", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "mediaRange", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["f" /* parseByteRange */] }, { k: "index", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "indexRange", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["f" /* parseByteRange */] }],

  "S": [{ k: "t", fn: parseInt, n: "ts" }, { k: "d", fn: parseInt }, { k: "r", fn: parseInt }],

  "SegmentTimeline": [],
  "SegmentBase": SegmentBaseType,
  "SegmentTemplate": MultipleSegmentBaseType.concat([{ k: "initialization", fn: parseInitializationAttribute }, { k: "index", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "media", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "bitstreamSwitching", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }]),
  "SegmentList": MultipleSegmentBaseType,

  "ContentComponent": [{ k: "id", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "lang", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */], n: "language" }, { k: "lang", fn: __WEBPACK_IMPORTED_MODULE_2__utils_languages__["a" /* normalize */], n: "normalizedLanguage" }, { k: "contentType", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "par", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["k" /* parseRatio */] }],

  "Representation": RepresentationBaseType.concat([{ k: "id", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "bandwidth", fn: parseInt, n: "bitrate" }, { k: "qualityRanking", fn: parseInt }]),

  "AdaptationSet": RepresentationBaseType.concat([{ k: "id", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "group", fn: parseInt }, { k: "lang", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */], n: "language" }, { k: "lang", fn: __WEBPACK_IMPORTED_MODULE_2__utils_languages__["a" /* normalize */], n: "normalizedLanguage" }, { k: "contentType", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "par", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["k" /* parseRatio */] }, { k: "minBandwidth", fn: parseInt, n: "minBitrate" }, { k: "maxBandwidth", fn: parseInt, n: "maxBitrate" }, { k: "minWidth", fn: parseInt }, { k: "maxWidth", fn: parseInt }, { k: "minHeight", fn: parseInt }, { k: "maxHeight", fn: parseInt }, { k: "minFrameRate", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["h" /* parseFrameRate */] }, { k: "maxFrameRate", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["h" /* parseFrameRate */] }, { k: "segmentAlignment", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["l" /* parseIntOrBoolean */] }, { k: "subsegmentAlignment", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["l" /* parseIntOrBoolean */] }, { k: "bitstreamSwitching", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["i" /* parseBoolean */] }]),

  "Period": [{ k: "id", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "start", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "duration", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "bitstreamSwitching", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["i" /* parseBoolean */] }],

  "MPD": [{ k: "id", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "profiles", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "type", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */], def: "static" }, { k: "availabilityStartTime", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["m" /* parseDateTime */] }, { k: "availabilityEndTime", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["m" /* parseDateTime */] }, { k: "publishTime", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["m" /* parseDateTime */] }, { k: "mediaPresentationDuration", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */], n: "duration" }, { k: "minimumUpdatePeriod", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "minBufferTime", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "timeShiftBufferDepth", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, {
    k: "suggestedPresentationDelay",
    fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */],
    def: __WEBPACK_IMPORTED_MODULE_0__config_js__["a" /* default */].DEFAULT_SUGGESTED_PRESENTATION_DELAY.DASH
  }, { k: "maxSegmentDuration", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }, { k: "maxSubsegmentDuration", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["j" /* parseDuration */] }],

  "Role": [{ k: "schemeIdUri", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "value", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }],

  "Accessibility": [{ k: "schemeIdUri", fn: __WEBPACK_IMPORTED_MODULE_3__helpers_js__["g" /* parseString */] }, { k: "value", fn: parseInt }]
};

/**
 * @param {Document} node - The Node content
 * @param {Object} [base] - Base object that will be enriched
 * @returns {Object}
 */
function feedAttributes(node, base) {
  var attrs = attributes[node.nodeName];

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert_js__["a" /* default */])(attrs, "no attributes for " + node.nodeName);

  var obj = base || {};
  for (var i = 0; i < attrs.length; i++) {
    var _attrs$i = attrs[i],
        k = _attrs$i.k,
        fn = _attrs$i.fn,
        n = _attrs$i.n,
        def = _attrs$i.def;

    if (node.hasAttribute(k)) {
      obj[n || k] = fn(node.getAttribute(k));
    } else if (def != null) {
      obj[n || k] = def;
    }
  }
  return obj;
}

/* harmony default export */ __webpack_exports__["a"] = (feedAttributes);

/***/ }),
/* 810 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filterMPD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return filterPeriod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return filterAdaptation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return filterRepresentation; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Keys in a parsed manifest are, after parsing, filtered to only the keys
 * actually used to simplify manifest management and debugging in the core.
 *
 * This allows to clearly see what manifest property is exploited in this player
 * for now and allows a cleaner management down the line. It also allows to
 * greatly simplify the update / creation of other streaming technologies
 * (MSS, HLS...) for this player, as they should all give the same properties.
 *
 * The arrays of strings declared here are the keys used in each type of object
 * (periods, adaptations, etc.).
 *
 * NOTE: This object can be totally removed without losing any feature. It had
 * mainly been added to simplify debugging.
 */
var FILTERED_KEYS = {

  /**
   * Every keys in a returned manifest (@see parseMDP).
   * The commented ones are the ones available here but not yet exploited.
   */
  MPD: [
  // "availabilityEndTime",
  // "minimumUpdatePeriod",
  // "profiles",
  // "publishTime",
  // "maxSegmentDuration",
  // "maxSubsegmentDuration",
  // "minBufferTime",
  "availabilityStartTime", "baseURL", "duration", "id", "locations", "periods", "presentationLiveGap", "suggestedPresentationDelay", "timeShiftBufferDepth", "transportType", "type"],

  /**
   * Every keys in a returned period (@see parsePeriod).
   * The commented ones are the ones available here but not yet exploited.
   */
  PERIOD: [
  // "bitstreamSwitching",
  "adaptations", "baseURL", "duration", "id", "start"],

  /**
   * Every keys in a returned adaptation (@see parseAdaptationSet).
   * The commented ones are the ones available here but not yet exploited.
   */
  ADAPTATION: [
  // "audioSamplingRate",
  // "bitstreamSwitching",
  // "codingDependency",
  // "contentComponent",
  // "contentType",
  // "frameRate",
  // "group",
  // "maxBitrate",
  // "maxFrameRate",
  // "maxHeight",
  // "maxPlayoutRate",
  // "maxWidth",
  // "maximumSAPPeriod",
  // "minBitrate",
  // "minFrameRate",
  // "minHeight",
  // "minWidth",
  // "par",
  // "profiles",
  // "role",
  // "segmentAlignment",
  // "segmentProfiles",
  // "subsegmentAlignment",
  "contentProtection", "accessibility", "baseURL", "contentProtection", "id", "language", "normalizedLanguage", "representations", "type"],

  /**
   * Every keys in a returned representation (@see parseRepresentation).
   * The commented ones are the ones available here but not yet exploited.
   */
  REPRESENTATION: [
  // "audioSamplingRate",
  // "codingDependency",
  // "frameRate",
  // "maxPlayoutRate",
  // "maximumSAPPeriod",
  // "profiles",
  // "qualityRanking",
  // "segmentProfiles",
  "bitrate", "baseURL", "codecs", "height", "id", "index", "mimeType", "width"]
};

/**
 * Create filter function for a corresponding FILTERED_KEYS array
 * of string.
 * @param {Array.<string>} filter - Array containing only the keys to filter in.
 * @returns {Function} - Function taking in argument an object and applying the
 * filter on it (keeping only the declared keys).
 */
var createFilter = function createFilter(filter) {
  return function (obj) {
    return filter.reduce(function (acc, key) {
      if (obj.hasOwnProperty(key)) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  };
};

var filterMPD = createFilter(FILTERED_KEYS.MPD);
var filterPeriod = createFilter(FILTERED_KEYS.PERIOD);
var filterAdaptation = createFilter(FILTERED_KEYS.ADAPTATION);
var filterRepresentation = createFilter(FILTERED_KEYS.REPRESENTATION);

/***/ }),
/* 811 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export parseFromString */
/* unused harmony export parseFromDocument */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parsers_js__ = __webpack_require__(812);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parseFromDocument(document, contentProtectionParser) {
  var root = document.documentElement;
  __WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */].equal(root.nodeName, "MPD", "document root should be MPD");
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parsers_js__["a" /* parseMPD */])(root, contentProtectionParser);
}

/**
 * @param {string} manifest - manifest file in a string format
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parseFromString(manifest, contentProtectionParser) {
  return parser.parseFromDocument(new DOMParser().parseFromString(manifest, "application/xml"), contentProtectionParser);
}

/**
 * @param {string|Document} manifest - Original manifest as returned by the
 * server. Either in string format, or in a Document Object format.
 * @param {Function} [contentProtectionParser]
 * @returns {Object} - parsed manifest
 */
function parser(manifest, contentProtectionParser) {
  if (typeof manifest == "string") {
    return parser.parseFromString(manifest, contentProtectionParser);
  } else {
    return parser.parseFromDocument(manifest, contentProtectionParser);
  }
}

parser.parseFromString = parseFromString;
parser.parseFromDocument = parseFromDocument;



/* harmony default export */ __webpack_exports__["a"] = (parser);

/***/ }),
/* 812 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parseMPD; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_js__ = __webpack_require__(361);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__filters_js__ = __webpack_require__(810);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__attributes_js__ = __webpack_require__(809);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var representationKeysInheritedFromAdaptation = ["codecs", "height", "index", "mimeType", "width"];

function parseMPD(root, contentProtectionParser) {
  var parser = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    switch (name) {

      case "BaseURL":
        res.baseURL = node.textContent;
        break;

      case "Location":
        res.locations.push(node.textContent);
        break;

      case "Period":
        res.periods.push(parsePeriod(node, contentProtectionParser));
        break;
    }

    return res;
  }, {
    transportType: "dash",
    periods: [],
    locations: []
  });

  var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root, parser);

  if (/dynamic/.test(parsed.type)) {
    var adaptations = parsed.periods[0].adaptations;

    var videoAdaptation = adaptations.filter(function (a) {
      return a.type == "video";
    })[0];

    var lastRef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["b" /* getLastLiveTimeReference */])(videoAdaptation);

    if (true) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert_js__["a" /* default */])(lastRef);
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert_js__["a" /* default */])(parsed.availabilityStartTime);
    }

    // if last time not found / something was invalid in the indexes, set a
    // default live time.
    if (!lastRef) {
      __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].warn("Live edge not deduced from manifest, setting a default one");
      lastRef = Date.now() / 1000 - 60;
    }

    parsed.availabilityStartTime = parsed.availabilityStartTime.getTime() / 1000;
    parsed.presentationLiveGap = Date.now() / 1000 - (lastRef + parsed.availabilityStartTime);
  }

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__filters_js__["a" /* filterMPD */])(parsed);
}

/**
 * Parse a single manifest period.
 * @param {Document} root
 * @param {Function} contentProtectionParser
 * @returns {Object}
 */
function parsePeriod(root, contentProtectionParser) {
  var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    switch (name) {

      case "BaseURL":
        res.baseURL = node.textContent;
        break;

      case "AdaptationSet":
        var ada = parseAdaptationSet(node, contentProtectionParser);
        if (ada.id == null) {
          ada.id = res.adaptations.length;
        }
        res.adaptations.push(ada);
        break;

    }
    return res;
  }, { adaptations: [] }));

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__filters_js__["b" /* filterPeriod */])(parsed);
}

function parseAdaptationSet(root, contentProtectionParser) {
  var accessibility = void 0;
  var parser = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    switch (name) {
      // case "Rating": break;
      // case "Viewpoint": break;

      case "Accessibility":
        accessibility = parseAccessibility(node);
        break;

      case "BaseURL":
        res.baseURL = node.textContent;
        break;

      // TODO seems to be unused
      case "ContentComponent":
        res.contentComponent = parseContentComponent(node);
        break;

      // TODO seems to be unused
      case "ContentProtection":
        res.contentProtection = parseContentProtection(node, contentProtectionParser);
        break;

      case "Representation":
        var rep = parseRepresentation(node);
        if (rep.id == null) {
          rep.id = res.representations.length;
        }
        res.representations.push(rep);break;

      case "Role":
        res.role = parseRole(node);
        break;

      case "SegmentBase":
        res.index = parseSegmentBase(node);
        break;

      case "SegmentList":
        res.index = parseSegmentList(node);
        break;

      case "SegmentTemplate":
        res.index = parseSegmentTemplate(node);
        break;
    }

    return res;
  }, { representations: [] });

  var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root, parser);

  parsed.type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["c" /* inferAdaptationType */])(parsed);

  parsed.accessibility = [];

  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["d" /* isHardOfHearing */])(accessibility)) {
    parsed.accessibility.push("hardOfHearing");
  }

  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["e" /* isVisuallyImpaired */])(accessibility)) {
    parsed.accessibility.push("visuallyImpaired");
  }

  // representations inherit some adaptation keys
  parsed.representations = parsed.representations.map(function (representation) {
    representationKeysInheritedFromAdaptation.forEach(function (key) {
      if (!representation.hasOwnProperty(key) && parsed.hasOwnProperty(key)) {
        // TODO clone objects, they should not share the same ref
        representation[key] = parsed[key];
      }
    });

    return representation;
  });

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__filters_js__["c" /* filterAdaptation */])(parsed);
}

function parseRepresentation(root) {
  var parser = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    switch (name) {
      // case "FramePacking": break;
      // case "AudioChannelConfiguration": break;
      // case "ContentProtection":
      //   res.contentProtection = parseContentProtection(node);
      //   break;
      // case "EssentialProperty": break;
      // case "SupplementalProperty": break;
      // case "InbandEventStream": break;
      // case "SubRepresentation": break;

      case "BaseURL":
        res.baseURL = node.textContent;
        break;

      case "SegmentBase":
        res.index = parseSegmentBase(node);
        break;

      case "SegmentList":
        res.index = parseSegmentList(node);
        break;

      case "SegmentTemplate":
        res.index = parseSegmentTemplate(node);
        break;
    }
    return res;
  }, {});

  var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root, parser);
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__filters_js__["d" /* filterRepresentation */])(parsed);
}

function parseRole(root) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root);
}

function parseAccessibility(root) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root);
}

function parseContentComponent(root) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root);
}

function parseSegmentTemplate(root) {
  var base = parseMultipleSegmentBase(root);
  if (!base.indexType) {
    base.indexType = "template";
  }
  return base;
}

function parseSegmentList(root) {
  var base = parseMultipleSegmentBase(root);
  base.list = [];
  base.indexType = "list";
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    if (name == "SegmentURL") {
      res.list.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(node));
    }
    return res;
  }, base);
}

/**
 * Parse the contentProtection node of a MPD.
 * @param {Document} root
 * @param {Function} contentProtectionParser
 * @returns {Object}
 */
function parseContentProtection(root, contentProtectionParser) {
  return contentProtectionParser(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root), root);
}

function parseSegmentBase(root) {
  var index = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    if (name == "Initialization") {
      res.initialization = parseInitialization(node);
    }
    return res;
  }, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(root));

  if (root.nodeName == "SegmentBase") {
    index.indexType = "base";
    index.timeline = [];
  }
  return index;
}

function parseMultipleSegmentBase(root) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (res, name, node) {
    if (name == "SegmentTimeline") {
      res.indexType = "timeline";
      res.timeline = parseSegmentTimeline(node);
    }
    return res;
  }, parseSegmentBase(root));
}

function parseSegmentTimeline(root) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["a" /* reduceChildren */])(root, function (arr, name, node) {
    var len = arr.length;
    var seg = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__attributes_js__["a" /* default */])(node);
    if (seg.ts == null) {
      var prev = len > 0 && arr[len - 1];
      seg.ts = prev ? prev.ts + prev.d * (prev.r + 1) : 0;
    }
    if (seg.r == null) {
      seg.r = 0;
    }
    arr.push(seg);
    return arr;
  }, []);
}

function parseInitialization(root) {
  var range = void 0,
      media = void 0;

  if (root.hasAttribute("range")) {
    range = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__helpers_js__["f" /* parseByteRange */])(root.getAttribute("range"));
  }

  if (root.hasAttribute("sourceURL")) {
    media = root.getAttribute("sourceURL");
  }

  return { range: range, media: media };
}



/***/ }),
/* 813 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__request_js__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_js__ = __webpack_require__(154);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @param {string} opt.url
 * @param {Segment} opt.segment
 * @returns {Observable}
 */
function regularSegmentLoader(_ref) {
  var url = _ref.url,
      segment = _ref.segment;
  var range = segment.range,
      indexRange = segment.indexRange;

  // fire a single time contiguous init and index ranges.

  if (range && indexRange && range[1] === indexRange[0] - 1) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__request_js__["a" /* default */])({
      url: url,
      responseType: "arraybuffer",
      headers: {
        Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_js__["c" /* byteRange */])([range[0], indexRange[1]])
      }
    });
  }

  var mediaHeaders = range ? { Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_js__["c" /* byteRange */])(range) } : null;

  var mediaOrInitRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__request_js__["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    headers: mediaHeaders
  });

  // If init segment has indexRange metadata, we need to fetch
  // both the initialization data and the index metadata. We do
  // this in parallel and send the both blobs into the pipeline.
  if (indexRange) {
    var indexRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__request_js__["a" /* default */])({
      url: url,
      responseType: "arraybuffer",
      headers: { "Range": __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_js__["c" /* byteRange */])(indexRange) }
    });
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(mediaOrInitRequest, indexRequest);
  } else {
    return mediaOrInitRequest;
  }
}

/**
 * Generate a segment loader for the application
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */
var segmentPreLoader = function segmentPreLoader(customSegmentLoader) {
  return function (_ref2) {
    var segment = _ref2.segment,
        adaptation = _ref2.adaptation,
        representation = _ref2.representation,
        manifest = _ref2.manifest;
    var media = segment.media,
        range = segment.range,
        indexRange = segment.indexRange,
        isInit = segment.isInit;

    // init segment without initialization media/range/indexRange:
    // we do nothing on the network

    if (isInit && !(media || range || indexRange)) {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
    }

    // construct url for the segment
    var path = media ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_js__["a" /* replaceTokens */])(media, segment, representation) : "";
    var url = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_url__["b" /* resolveURL */])(representation.baseURL, path);

    var args = {
      adaptation: adaptation,
      representation: representation,
      manifest: manifest,
      segment: segment,
      transport: "dash",
      url: url
    };

    if (!customSegmentLoader) {
      return regularSegmentLoader(args);
    }

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
      var hasFinished = false;
      var hasFallbacked = false;

      /**
       * Callback triggered when the custom segment loader has a response.
       * @param {Object} args
       * @param {*} args.data - The segment data
       * @param {Number} args.size - The segment size
       * @param {Number} args.duration - The duration of the request, in ms
       */
      var resolve = function resolve() {
        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!hasFallbacked) {
          hasFinished = true;
          obs.next({
            responseData: args.data,
            size: args.size || 0,
            duration: args.duration || 0
          });
          obs.complete();
        }
      };

      /**
       * Callback triggered when the custom segment loader fails
       * @param {*} [err={}] - The corresponding error encountered
       */
      var reject = function reject() {
        var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };

      /**
       * Callback triggered when the custom segment loader wants to fallback to
       * the "regular" implementation
       */
      var fallback = function fallback() {
        hasFallbacked = true;
        regularSegmentLoader(args).subscribe(obs);
      };

      var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
      var abort = customSegmentLoader(args, callbacks);

      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  };
};

/* harmony default export */ __webpack_exports__["a"] = (segmentPreLoader);

/***/ }),
/* 814 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TextTrackLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TextTrackParser; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_strings_js__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parsers_containers_isobmff_js__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__request_js__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__isobmff_timing_infos_js__ = __webpack_require__(360);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_js__ = __webpack_require__(154);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/**
 * Perform requests for "text" segments
 * TODO DRY this (code too similar to segmentPipeline)
 *
 * @param {Object} infos
 * @param {Segment} infos.segment
 * @param {Representation} infos.representation
 * @returns {Observable.<Object>}
 */
function TextTrackLoader(_ref) {
  var segment = _ref.segment,
      representation = _ref.representation;
  var media = segment.media,
      range = segment.range,
      indexRange = segment.indexRange,
      isInit = segment.isInit;

  /**
   * ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
   * @type string
   */

  var responseType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["b" /* isMP4EmbeddedTrack */])(representation) ? "arraybuffer" : "text";

  // init segment without initialization media/range/indexRange:
  // we do nothing on the network
  if (isInit && !(media || range || indexRange)) {
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
  }

  /**
   * filename
   * @type string
   */
  var path = media ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["a" /* replaceTokens */])(media, segment, representation) : "";

  /**
   * Complete path of the segment.
   * @type string
   */
  var mediaUrl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_url__["b" /* resolveURL */])(representation.baseURL, path);

  // fire a single time contiguous init and index ranges.
  // TODO Find a solution for indicating that special case to the parser
  if (range && indexRange && range[1] === indexRange[0] - 1) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__request_js__["a" /* default */])({
      url: mediaUrl,
      responseType: responseType,
      headers: {
        Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["c" /* byteRange */])([range[0], indexRange[1]])
      }
    });
  }

  /**
   * Segment request.
   * @type Observable.<Object>
   */
  var mediaOrInitRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__request_js__["a" /* default */])({
    url: mediaUrl,
    responseType: responseType,
    headers: range ? {
      Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["c" /* byteRange */])(range)
    } : null
  });

  // If init segment has indexRange metadata, we need to fetch
  // both the initialization data and the index metadata. We do
  // this in parallel and send the both blobs into the pipeline.
  // TODO Find a solution for calling only one time the parser
  if (indexRange) {
    var indexRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__request_js__["a" /* default */])({
      url: mediaUrl,
      responseType: responseType,
      headers: {
        Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["c" /* byteRange */])(indexRange)
      }
    });
    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].merge(mediaOrInitRequest, indexRequest);
  } else {
    return mediaOrInitRequest;
  }
}

/**
 * Parse TextTrack data.
 *
 * @param {Object} infos
 * @param {Segment} infos.segment
 * @param {Adaptation} infos.adaptation
 * @param {Representation} infos.representation
 * @param {Object} infos.init
 * @returns {Observable.<Object>}
 */
function TextTrackParser(_ref2) {
  var response = _ref2.response,
      segment = _ref2.segment,
      adaptation = _ref2.adaptation,
      representation = _ref2.representation,
      init = _ref2.init;
  var language = adaptation.language;
  var isInit = segment.isInit,
      indexRange = segment.indexRange;

  var responseData = void 0;
  var nextSegments = void 0,
      segmentInfos = void 0;
  var segmentData = void 0;

  var isMP4 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_js__["b" /* isMP4EmbeddedTrack */])(representation);
  if (isMP4) {
    responseData = new Uint8Array(response.responseData);

    var sidxSegments = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__parsers_containers_isobmff_js__["a" /* parseSidx */])(responseData, indexRange ? indexRange[0] : 0);

    if (sidxSegments) {
      nextSegments = sidxSegments;
    }
    if (!isInit) {
      segmentInfos = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__isobmff_timing_infos_js__["a" /* default */])(segment, responseData, sidxSegments, init);
    }
  } else {
    // if not MP4
    responseData = response.responseData;
    segmentInfos = {
      time: segment.time,
      duration: segment.duration,
      timescale: segment.timescale
    };
  }

  if (isInit) {
    segmentInfos = { time: -1, duration: 0 };
    if (isMP4) {
      var timescale = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__parsers_containers_isobmff_js__["b" /* getMDHDTimescale */])(responseData);
      if (timescale > 0) {
        segmentInfos.timescale = timescale;
      }
    }

    // void data
    segmentData = {
      start: 0,
      end: 0,
      timescale: segmentInfos.timescale || 0,
      data: []
    };
  } else {
    // if not init
    var segmentDataBase = {
      start: segmentInfos.time,
      end: segmentInfos.time + segmentInfos.duration,
      language: language,
      timescale: segmentInfos.timescale
    };
    if (isMP4) {
      var _representation$codec = representation.codec,
          codec = _representation$codec === undefined ? "" : _representation$codec;

      var type = void 0;

      switch (codec.toLowerCase()) {
        case "stpp":
          // stpp === TTML in MP4
          type = "ttml";
          break;
        case "wvtt":
          // wvtt === WebVTT in MP4
          type = "vtt";
      }

      if (!type) {
        throw new Error("The codec used for the subtitle is not managed yet.");
      }

      segmentData = __WEBPACK_IMPORTED_MODULE_1_object_assign___default()({
        data: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_strings_js__["a" /* stringFromUTF8 */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__parsers_containers_isobmff_js__["d" /* getMdat */])(responseData)),
        type: type
      }, segmentDataBase);
    } else {
      // not MP4: check for plain text subtitles
      var _type = void 0;

      var _representation$mimeT = representation.mimeType.mimeType,
          mimeType = _representation$mimeT === undefined ? "" : _representation$mimeT;

      switch (representation.mimeType) {
        case "application/ttml+xml":
          _type = "ttml";
          break;
        case "application/x-sami":
        case "application/smil":
          _type = "sami";
          break;
        case "text/vtt":
          _type = "vtt";
      }

      if (!_type) {
        var _representation$codec2 = representation.codec,
            _codec = _representation$codec2 === undefined ? "" : _representation$codec2;

        var codeLC = _codec.toLowerCase();
        if (codeLC === "srt") {
          _type = "srt";
        } else {
          throw new Error("could not find a text-track parser for the type " + mimeType);
        }
      }

      segmentData = __WEBPACK_IMPORTED_MODULE_1_object_assign___default()({
        data: responseData,
        type: _type
      }, segmentDataBase);
    }
  }
  return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos, nextSegments: nextSegments });
}



/***/ }),
/* 815 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var manifestPipeline = {
  loader: function loader(_ref) {
    var url = _ref.url;

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ url: url });
  },
  parser: function parser(_ref2) {
    var url = _ref2.url;

    var manifest = {
      transportType: "directfile",
      locations: [url],
      periods: [],
      isLive: false,
      duration: Infinity,
      adaptations: null
    };

    return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ manifest: manifest, url: url });
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    directFile: true,
    manifest: manifestPipeline
  };
});

/***/ }),
/* 816 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var exported = {};
if (true) {
  exported.smooth = __webpack_require__(817).default;
}
if (true) {
  exported.dash = __webpack_require__(808).default;
}
if (true) {
  exported.directfile = __webpack_require__(815).default;
}

/* harmony default export */ __webpack_exports__["a"] = (exported);

/***/ }),
/* 817 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_strings_js__ = __webpack_require__(371);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_request__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__parser__ = __webpack_require__(819);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__parsers_images_bif_js__ = __webpack_require__(364);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mp4_js__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__request_js__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_js__ = __webpack_require__(363);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__isobmff_timings_infos_js__ = __webpack_require__(818);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__segment_loader_js__ = __webpack_require__(820);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















var patchSegment = __WEBPACK_IMPORTED_MODULE_6__mp4_js__["a" /* default */].patchSegment,
    getMdat = __WEBPACK_IMPORTED_MODULE_6__mp4_js__["a" /* default */].getMdat;


var WSX_REG = /\.wsx?(\?token=\S+)?/;

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var smoothManifestParser = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__parser__["a" /* default */])(options);
  var segmentLoader = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__segment_loader_js__["a" /* default */])(options.segmentLoader);

  var manifestPipeline = {
    resolver: function resolver(_ref) {
      var url = _ref.url;

      var resolving = void 0;
      var token = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["a" /* extractToken */])(url);

      // TODO Remove WSX logic
      if (WSX_REG.test(url)) {
        resolving = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_request__["a" /* default */])({
          url: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["b" /* replaceToken */])(url, ""),
          responseType: "document",
          ignoreProgressEvents: true
        }).map(function (_ref2) {
          var value = _ref2.value;
          return value;
        }).map(__WEBPACK_IMPORTED_MODULE_8__utils_js__["c" /* extractISML */]); // TODO remove completely
      } else {
        resolving = __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of(url);
      }

      return resolving.map(function (url) {
        return { url: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["b" /* replaceToken */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["d" /* resolveManifest */])(url), token) };
      });
    },
    loader: function loader(_ref3) {
      var url = _ref3.url;

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__request_js__["a" /* default */])({
        url: url,
        responseType: "document"
      });
    },
    parser: function parser(_ref4) {
      var response = _ref4.response;

      var manifest = smoothManifestParser(response.responseData);
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ manifest: manifest, url: response.url });
    }
  };

  var segmentPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          representation = _ref5.representation,
          adaptation = _ref5.adaptation,
          manifest = _ref5.manifest;

      return segmentLoader({
        segment: segment,
        representation: representation,
        adaptation: adaptation,
        manifest: manifest
      });
    },
    parser: function parser(_ref6) {
      var segment = _ref6.segment,
          response = _ref6.response,
          manifest = _ref6.manifest;
      var responseData = response.responseData;


      if (segment.isInit) {
        // smooth init segments are crafted by hand. Their timescale is the one
        // from the manifest.
        var _segmentInfos = {
          timescale: segment.timescale,
          time: -1,
          duration: 0
        };
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: responseData, segmentInfos: _segmentInfos });
      }

      var responseBuffer = new Uint8Array(responseData);

      var _extractTimingsInfos = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__isobmff_timings_infos_js__["a" /* default */])(responseBuffer, segment, manifest.isLive),
          nextSegments = _extractTimingsInfos.nextSegments,
          segmentInfos = _extractTimingsInfos.segmentInfos;

      var segmentData = patchSegment(responseBuffer, segmentInfos.time);
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos, nextSegments: nextSegments });
    }
  };

  var textTrackPipeline = {
    loader: function loader(_ref7) {
      var segment = _ref7.segment,
          representation = _ref7.representation;

      if (segment.isInit) {
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
      }

      var mimeType = representation.mimeType;

      var base = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_url__["b" /* resolveURL */])(representation.baseURL);
      var url = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["e" /* buildSegmentURL */])(base, representation, segment);

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__request_js__["a" /* default */])({
        url: url,
        responseType: mimeType.indexOf("mp4") >= 0 ? "arraybuffer" : "text"
      });
    },
    parser: function parser(_ref8) {
      var response = _ref8.response,
          segment = _ref8.segment,
          representation = _ref8.representation,
          adaptation = _ref8.adaptation,
          manifest = _ref8.manifest;
      var language = adaptation.language;
      var _representation$mimeT = representation.mimeType,
          mimeType = _representation$mimeT === undefined ? "" : _representation$mimeT,
          _representation$codec = representation.codec,
          codec = _representation$codec === undefined ? "" : _representation$codec;


      var responseData = response.responseData;
      var nextSegments = void 0,
          segmentInfos = void 0;
      var segmentData = { language: language };
      var isMP4 = mimeType.indexOf("mp4") >= 0;

      if (isMP4) {
        responseData = new Uint8Array(responseData);
        var timings = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__isobmff_timings_infos_js__["a" /* default */])(responseData, segment, manifest.isLive);

        nextSegments = timings.nextSegments;
        segmentInfos = timings.segmentInfos || {};
        segmentData.start = segmentInfos.time;
        segmentData.end = segmentInfos.duration != null ? segmentInfos.time + segmentInfos.duration : undefined;
        segmentData.timescale = segmentInfos.timescale;
      } else {
        // vod is simple WebVTT or TTML text
        segmentData.start = segment.time;
        segmentData.end = segment.duration != null ? segment.time + segment.duration : undefined;
        segmentData.timescale = segment.timescale;
      }

      if (isMP4) {
        var lcCodec = codec.toLowerCase();
        if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp") {
          segmentData.type = "ttml";
        } else if (lcCodec === "wvtt") {
          segmentData.type = "vtt";
        } else {
          throw new Error("could not find a text-track parser for the type " + mimeType);
        }
        segmentData.data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_strings_js__["a" /* stringFromUTF8 */])(getMdat(responseData));
      } else {
        switch (mimeType) {
          case "application/x-sami":
          case "application/smil":
            // TODO SMIL should be its own format, no?
            segmentData.type = "sami";
            break;
          case "application/ttml+xml":
            segmentData.type = "ttml";
            break;
          case "text/vtt":
            segmentData.type = "vtt";
            break;
        }
        if (!segmentData.type) {
          var _lcCodec = codec.toLowerCase();
          if (_lcCodec === "srt") {
            segmentData.type = "srt";
          } else {
            throw new Error("could not find a text-track parser for the type " + mimeType);
          }
        }
        segmentData.data = responseData;
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos, nextSegments: nextSegments });
    }
  };

  var imageTrackPipeline = {
    loader: function loader(_ref9) {
      var segment = _ref9.segment,
          representation = _ref9.representation;

      if (segment.isInit) {
        return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
      } else {
        var baseURL = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_url__["b" /* resolveURL */])(representation.baseURL);
        var url = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__utils_js__["e" /* buildSegmentURL */])(baseURL, representation, segment);
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__request_js__["a" /* default */])({ url: url, responseType: "arraybuffer" });
      }
    },
    parser: function parser(_ref10) {
      var response = _ref10.response;

      var responseData = response.responseData;
      var blob = new Uint8Array(responseData);

      var segmentInfos = {
        time: 0,
        duration: Number.MAX_VALUE
      };

      var segmentData = void 0;
      if (blob) {
        var bif = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__parsers_images_bif_js__["a" /* default */])(blob);
        segmentData = bif.thumbs;
        segmentInfos.timescale = bif.timescale;

        // var firstThumb = blob[0];
        // var lastThumb  = blob[blob.length - 1];

        // segmentInfos = {
        //   time: firstThumb.ts,
        //   duration: lastThumb.ts
        // };
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ segmentData: segmentData, segmentInfos: segmentInfos });
    }
  };

  return {
    directFile: false,
    manifest: manifestPipeline,
    audio: segmentPipeline,
    video: segmentPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});

/***/ }),
/* 818 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_log__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parsers_containers_isobmff_js__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mp4_js__ = __webpack_require__(155);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var getTraf = __WEBPACK_IMPORTED_MODULE_2__mp4_js__["a" /* default */].getTraf,
    parseTfrf = __WEBPACK_IMPORTED_MODULE_2__mp4_js__["a" /* default */].parseTfrf,
    parseTfxd = __WEBPACK_IMPORTED_MODULE_2__mp4_js__["a" /* default */].parseTfxd;


function extractTimingsInfos(responseData, segment, isLive) {
  var nextSegments = void 0;
  var segmentInfos = void 0;

  if (isLive) {
    var traf = getTraf(responseData);
    if (traf) {
      nextSegments = parseTfrf(traf);
      segmentInfos = parseTfxd(traf);
    } else {
      __WEBPACK_IMPORTED_MODULE_0__utils_log__["a" /* default */].warn("smooth: could not find traf atom");
    }
  } else {
    nextSegments = null;
  }

  if (!segmentInfos) {
    // we could always make a mistake when reading a container.
    // If the estimate is too far from what the segment seems to imply, take
    // the segment infos instead.
    var maxDecodeTimeDelta = Math.min(0.9 * segment.timescale, segment.duration / 4);

    var trunDuration = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parsers_containers_isobmff_js__["f" /* getDurationFromTrun */])(responseData);
    if (trunDuration >= 0 && Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta) {
      segmentInfos = {
        time: segment.time,
        duration: trunDuration
      };
    } else {
      segmentInfos = {
        time: segment.time,
        duration: segment.duration
      };
    }
  }

  if (nextSegments) {
    for (var i = nextSegments.length - 1; i >= 0; i--) {
      nextSegments[i].timescale = segment.timescale;
    }
  }

  if (segmentInfos) {
    segmentInfos.timescale = segment.timescale;
  }
  return { nextSegments: nextSegments, segmentInfos: segmentInfos };
}

/* harmony default export */ __webpack_exports__["a"] = (extractTimingsInfos);

/***/ }),
/* 819 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__config_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_bytes__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_assert__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_languages__ = __webpack_require__(108);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var DEFAULT_MIME_TYPES = {
  audio: "audio/mp4",
  video: "video/mp4",
  text: "application/ttml+xml"
};

var DEFAULT_CODECS = {
  audio: "mp4a.40.2",
  video: "avc1.4D401E"
};

var MIME_TYPES = {
  "AACL": "audio/mp4",
  "AVC1": "video/mp4",
  "H264": "video/mp4",
  "TTML": "application/ttml+xml+mp4"
};

var profiles = {
  audio: [["Bitrate", "bitrate", parseInt], ["AudioTag", "audiotag", parseInt], ["FourCC", "mimeType", MIME_TYPES], ["Channels", "channels", parseInt], ["SamplingRate", "samplingRate", parseInt], ["BitsPerSample", "bitsPerSample", parseInt], ["PacketSize", "packetSize", parseInt], ["CodecPrivateData", "codecPrivateData", String]],
  video: [["Bitrate", "bitrate", parseInt], ["FourCC", "mimeType", MIME_TYPES], ["CodecPrivateData", "codecs", extractVideoCodecs], ["MaxWidth", "width", parseInt], ["MaxHeight", "height", parseInt], ["CodecPrivateData", "codecPrivateData", String]],
  text: [["Bitrate", "bitrate", parseInt], ["FourCC", "mimeType", MIME_TYPES]]
};

function extractVideoCodecs(codecPrivateData) {
  // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
  var _ref = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData) || [],
      avcProfile = _ref[1];

  return avcProfile ? "avc1." + avcProfile : "";
}

function extractAudioCodecs(fourCC, codecPrivateData) {
  var mpProfile = void 0;
  if (fourCC == "AACH") {
    mpProfile = 5; // High Efficiency AAC Profile
  } else {
    if (codecPrivateData) {
      mpProfile = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;
    } else {
      mpProfile = 2; // AAC Main Low Complexity
    }
  }
  return mpProfile ? "mp4a.40." + mpProfile : "";
}

function parseBoolean(val) {
  if (typeof val == "boolean") {
    return val;
  } else if (typeof val == "string") {
    return val.toUpperCase() === "TRUE";
  } else {
    return false;
  }
}

function calcLastRef(adaptation) {
  if (!adaptation) {
    return Infinity;
  }
  var index = adaptation.index;
  var _index$timeline = index.timeline[index.timeline.length - 1],
      ts = _index$timeline.ts,
      r = _index$timeline.r,
      d = _index$timeline.d;

  return (ts + (r + 1) * d) / index.timescale;
}

function getKeySystems(keyIdBytes) {
  return [{
    // Widevine
    systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
    privateData: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["i" /* concat */])([0x08, 0x01, 0x12, 0x10], keyIdBytes)
    // keyIds: [keyIdBytes],
  }];
}

function createSmoothStreamingParser() {
  var parserOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


  var SUGGESTED_PERSENTATION_DELAY = parserOptions.suggestedPresentationDelay == null ? __WEBPACK_IMPORTED_MODULE_1__config_js__["a" /* default */].DEFAULT_SUGGESTED_PRESENTATION_DELAY.SMOOTH : parserOptions.suggestedPresentationDelay;

  var REFERENCE_DATE_TIME = parserOptions.referenceDateTime || Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000;
  var MIN_REPRESENTATION_BITRATE = parserOptions.minRepresentationBitrate || 190000;

  var keySystems = parserOptions.keySystems || getKeySystems;

  function getHexKeyId(buf) {
    var len = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["d" /* le2toi */])(buf, 8);
    var xml = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["l" /* bytesToUTF16Str */])(buf.subarray(10, 10 + len));
    var doc = new DOMParser().parseFromString(xml, "application/xml");
    var kid = doc.querySelector("KID").textContent;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["m" /* guidToUuid */])(atob(kid)).toLowerCase();
  }

  function reduceChildren(root, fn, init) {
    var node = root.firstElementChild,
        r = init;
    while (node) {
      r = fn(r, node.nodeName, node);
      node = node.nextElementSibling;
    }
    return r;
  }

  function parseProtection(root) {
    var header = root.firstElementChild;
    __WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */].equal(header.nodeName, "ProtectionHeader", "Protection should have ProtectionHeader child");
    var privateData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["b" /* strToBytes */])(atob(header.textContent));
    var keyId = getHexKeyId(privateData);
    var keyIdBytes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_bytes__["k" /* hexToBytes */])(keyId);

    // remove possible braces
    var systemId = header.getAttribute("SystemID").toLowerCase().replace(/\{|\}/g, "");

    return {
      keyId: keyId,
      keySystems: [{
        systemId: systemId,
        privateData: privateData
        // keyIds: [keyIdBytes],
      }].concat(keySystems(keyIdBytes))
    };
  }

  function parseC(node, timeline) {
    var l = timeline.length;
    var prev = l > 0 ? timeline[l - 1] : { d: 0, ts: 0, r: 0 };
    var d = +node.getAttribute("d");
    var t = node.getAttribute("t");
    var r = +node.getAttribute("r");

    // in smooth streaming format,
    // r refers to number of same duration
    // chunks, not repetitions (defers from DASH)
    if (r) {
      r--;
    }

    if (l > 0 && !prev.d) {
      prev.d = t - prev.ts;
      timeline[l - 1] = prev;
    }

    if (l > 0 && d == prev.d && t == null) {
      prev.r += (r || 0) + 1;
    } else {
      var ts = t == null ? prev.ts + prev.d * (prev.r + 1) : +t;
      timeline.push({ d: d, ts: ts, r: r });
    }
    return timeline;
  }

  function parseQualityLevel(q, prof) {
    var obj = {};
    for (var i = 0; i < prof.length; i++) {
      var _prof$i = prof[i],
          key = _prof$i[0],
          name = _prof$i[1],
          parse = _prof$i[2];

      obj[name] = typeof parse == "function" ? parse(q.getAttribute(key)) : parse[q.getAttribute(key)];
    }
    return obj;
  }

  // Parse the adaptations (<StreamIndex>) tree containing
  // representations (<QualityLevels>) and timestamp indexes (<c>).
  // Indexes can be quite huge, and this function needs to
  // to be optimized.
  function parseAdaptation(root, timescale) {
    if (root.hasAttribute("Timescale")) {
      timescale = +root.getAttribute("Timescale");
    }

    var type = root.getAttribute("Type");
    var subType = root.getAttribute("Subtype");
    var name = root.getAttribute("Name");
    var language = root.getAttribute("Language");
    var normalizedLanguage = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_languages__["a" /* normalize */])(language);
    var baseURL = root.getAttribute("Url");
    var profile = profiles[type];

    var accessibility = [];

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */])(profile, "unrecognized QualityLevel type " + type);

    var representationCount = 0;

    var _reduceChildren = reduceChildren(root, function (res, name, node) {
      switch (name) {
        case "QualityLevel":
          var rep = parseQualityLevel(node, profile);

          if (type == "audio") {
            var fourCC = node.getAttribute("FourCC") || "";
            rep.codecs = extractAudioCodecs(fourCC, rep.codecPrivateData);
          }

          // filter out video representations with small bitrates
          if (type != "video" || rep.bitrate > MIN_REPRESENTATION_BITRATE) {
            rep.id = representationCount++;
            res.representations.push(rep);
          }
          break;
        case "c":
          res.index.timeline = parseC(node, res.index.timeline);
          break;
      }
      return res;
    }, {
      representations: [],
      index: {
        timeline: [],
        indexType: "smooth",
        timescale: timescale,
        initialization: {}
      }
    }),
        representations = _reduceChildren.representations,
        index = _reduceChildren.index;

    // we assume that all representations have the same
    // codec and mimeType


    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */])(representations.length, "adaptation should have at least one representation");

    // apply default codec if non-supported
    representations.forEach(function (rep) {
      return rep.codecs = rep.codecs || DEFAULT_CODECS[type];
    });

    // apply default mimetype if non-supported
    representations.forEach(function (rep) {
      return rep.mimeType = rep.mimeType || DEFAULT_MIME_TYPES[type];
    });

    // TODO(pierre): real ad-insert support
    if (subType == "ADVT") {
      return null;
    } else if (type === "text" && subType === "DESC") {
      accessibility.push("hardOfHearing");
    }

    // TODO check that one, I did not find it in the spec
    // else if (type === "audio" && subType === "DESC") {
    //   accessibility.push("visuallyImpaired");
    // }

    return {
      type: type,
      accessibility: accessibility,
      index: index,
      representations: representations,
      name: name,
      language: language,
      normalizedLanguage: normalizedLanguage,
      baseURL: baseURL
    };
  }

  function parseFromString(manifest) {
    return parseFromDocument(new DOMParser().parseFromString(manifest, "application/xml"));
  }

  function parseFromDocument(doc) {
    var root = doc.documentElement;
    __WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */].equal(root.nodeName, "SmoothStreamingMedia", "document root should be SmoothStreamingMedia");
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_assert__["a" /* default */])(/^[2]-[0-2]$/.test(root.getAttribute("MajorVersion") + "-" + root.getAttribute("MinorVersion")), "Version should be 2.0, 2.1 or 2.2");

    var timescale = +root.getAttribute("Timescale") || 10000000;
    var adaptationIds = [];

    var _reduceChildren2 = reduceChildren(root, function (res, name, node) {
      switch (name) {
        case "Protection":
          res.protection = parseProtection(node);break;
        case "StreamIndex":
          var ada = parseAdaptation(node, timescale);
          if (ada) {
            var i = 0;
            var id = void 0;
            do {
              id = ada.type + "_" + (ada.language ? ada.language + "_" : "") + i++;
            } while (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(adaptationIds, id));
            ada.id = id;
            adaptationIds.push(id);
            res.adaptations.push(ada);
          }
          break;
      }
      return res;
    }, {
      protection: null,
      adaptations: []
    }),
        protection = _reduceChildren2.protection,
        adaptations = _reduceChildren2.adaptations;

    adaptations.forEach(function (a) {
      return a.smoothProtection = protection;
    });

    var suggestedPresentationDelay = void 0,
        presentationLiveGap = void 0,
        timeShiftBufferDepth = void 0,
        availabilityStartTime = void 0;

    var isLive = parseBoolean(root.getAttribute("IsLive"));
    if (isLive) {
      suggestedPresentationDelay = SUGGESTED_PERSENTATION_DELAY;
      timeShiftBufferDepth = +root.getAttribute("DVRWindowLength") / timescale;
      availabilityStartTime = REFERENCE_DATE_TIME;
      var video = adaptations.filter(function (a) {
        return a.type == "video";
      })[0];
      var audio = adaptations.filter(function (a) {
        return a.type == "audio";
      })[0];
      var lastRef = Math.min(calcLastRef(video), calcLastRef(audio));
      presentationLiveGap = Date.now() / 1000 - (lastRef + availabilityStartTime);
    }

    return {
      transportType: "smooth",
      profiles: "",
      type: isLive ? "dynamic" : "static",
      suggestedPresentationDelay: suggestedPresentationDelay,
      timeShiftBufferDepth: timeShiftBufferDepth,
      presentationLiveGap: presentationLiveGap,
      availabilityStartTime: availabilityStartTime,
      periods: [{
        duration: (+root.getAttribute("Duration") || Infinity) / timescale,
        adaptations: adaptations,
        laFragCount: +root.getAttribute("LookAheadFragmentCount")
      }]
    };
  }

  function parser(val) {
    if (typeof val == "string") {
      return parseFromString(val);
    } else {
      return parseFromDocument(val);
    }
  }

  parser.parseFromString = parseFromString;
  parser.parseFromDocument = parseFromDocument;

  return parser;
}

/* harmony default export */ __webpack_exports__["a"] = (createSmoothStreamingParser);

/***/ }),
/* 820 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_url__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mp4_js__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__request_js__ = __webpack_require__(362);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_js__ = __webpack_require__(363);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var createVideoInitSegment = __WEBPACK_IMPORTED_MODULE_2__mp4_js__["a" /* default */].createVideoInitSegment,
    createAudioInitSegment = __WEBPACK_IMPORTED_MODULE_2__mp4_js__["a" /* default */].createAudioInitSegment;


function regularSegmentLoader(_ref) {
  var url = _ref.url,
      segment = _ref.segment;

  var headers = void 0;
  var range = segment.range;
  if (range) {
    headers = {
      Range: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_js__["f" /* byteRange */])(range)
    };
  }

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__request_js__["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    headers: headers
  });
}

/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */
var segmentLoader = function segmentLoader(customSegmentLoader) {
  return function (_ref2) {
    var segment = _ref2.segment,
        representation = _ref2.representation,
        adaptation = _ref2.adaptation,
        manifest = _ref2.manifest;

    if (segment.isInit) {
      var responseData = {};
      var protection = adaptation._smoothProtection || {};

      switch (adaptation.type) {
        case "video":
          responseData = createVideoInitSegment(segment.timescale, representation.width, representation.height, 72, 72, 4, // vRes, hRes, nal
          representation._codecPrivateData, protection.keyId, // keyId
          protection.keySystems // pssList
          );
          break;
        case "audio":
          responseData = createAudioInitSegment(segment.timescale, representation._channels, representation._bitsPerSample, representation._packetSize, representation._samplingRate, representation._codecPrivateData, protection.keyId, // keyId
          protection.keySystems // pssList
          );
          break;
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].of({ type: "data", value: { responseData: responseData } });
    } else {
      var url = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_js__["e" /* buildSegmentURL */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_url__["b" /* resolveURL */])(representation.baseURL), representation, segment);

      var args = {
        adaptation: adaptation,
        representation: representation,
        segment: segment,
        transport: "smooth",
        url: url,
        manifest: manifest
      };

      if (!customSegmentLoader) {
        return regularSegmentLoader(args);
      }

      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].create(function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;

        var resolve = function resolve() {
          var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (!hasFallbacked) {
            hasFinished = true;
            obs.next({
              type: "response",
              value: {
                responseData: args.data,
                size: args.size || 0,
                duration: args.duration || 0
              }
            });
            obs.complete();
          }
        };

        var reject = function reject() {
          var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (!hasFallbacked) {
            hasFinished = true;
            obs.error(err);
          }
        };

        var fallback = function fallback() {
          hasFallbacked = true;
          regularSegmentLoader(args).subscribe(obs);
        };

        var callbacks = { reject: reject, resolve: resolve, fallback: fallback };
        var abort = customSegmentLoader(args, callbacks);

        return function () {
          if (!hasFinished && !hasFallbacked && typeof abort === "function") {
            abort();
          }
        };
      });
    }
  };
};

/* harmony default export */ __webpack_exports__["a"] = (segmentLoader);

/***/ }),
/* 821 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_assert__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.

// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.



var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;

// Really basic CSS parsers using regular-expressions.
function classCSSRules(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = void 0;
  while (m = ruleRe.exec(str)) {
    var name = m[1];
    var lang = propCss(m[2], "lang");
    if (name && lang) {
      langs[lang] = name;
    }
  }
  return langs;
}

function pCSSRules(str) {
  var pRuleRegex = /p\s*{([^}]*)}/gi;
  var rule = pRuleRegex.exec(str);
  return rule[1];
}

function propCss(str, name) {
  return str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"))[1];
}

function decodeEntities(text) {
  return text.replace(HTML_ENTITIES, function ($0, $1) {
    return String.fromCharCode($1);
  });
}

/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {string} lang
 */
function parseSami(smi, lang) {
  var syncOpen = /<sync[ >]/ig;
  var syncClose = /<sync[ >]|<\/body>/ig;

  var subs = [];

  var _smi$match = smi.match(STYLE),
      css = _smi$match[1];

  var up = void 0,
      to = syncClose.exec(smi);

  var langs = classCSSRules(css);
  var pCSS = pCSSRules(css);
  var klass = langs[lang];

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_assert__["a" /* default */])(klass, "sami: could not find lang " + lang + " in CSS");

  for (;;) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);
    if (!up && !to) {
      break;
    }
    if (!up || !to || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);
    if (!tim) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];
    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendSub(subs, str.split("\n"), start / 1000);
  }

  return subs;

  function appendSub(subs, lines, start) {
    var i = lines.length;
    while (--i >= 0) {
      var paragraphInfos = lines[i].match(PARAG);
      if (!paragraphInfos) {
        continue;
      }

      var className = paragraphInfos[1],
          txt = paragraphInfos[2];


      if (klass !== className) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        var wrapperEl = document.createElement("DIV");
        wrapperEl.className = "rxp-texttrack-region";

        var divEl = document.createElement("DIV");
        divEl.className = "rxp-texttrack-div";
        divEl.style.position = "absolute";
        divEl.style.bottom = 0;
        divEl.style.width = "100%";
        divEl.style.color = "#fff";
        divEl.style.textShadow = "-1px -1px 0 #000," + "1px -1px 0 #000," + "-1px 1px 0 #000," + "1px 1px 0 #000";

        var pEl = document.createElement("div");
        pEl.className = "rxp-texttrack-p";
        if (pCSS) {
          pEl.style.cssText = pCSS;
        }

        var textEls = txt.split(BR);
        for (var j = 0; j < textEls.length; j++) {
          if (j) {
            pEl.appendChild(document.createElement("BR"));
          }
          var spanEl = document.createElement("SPAN");
          spanEl.className = "rxp-texttrack-span";
          spanEl.textContent = decodeEntities(textEls[j]);

          pEl.appendChild(spanEl);
        }
        divEl.appendChild(pEl);
        wrapperEl.appendChild(divEl);

        subs.push({ element: wrapperEl, start: start });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 822 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_assert__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p class=([^>]+)>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;

/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} - Objects containing the start, end and text.
 * @returns {Array.<VTTCue>}
 */
function createCuesFromArray(cuesArray) {
  var nativeCues = [];
  for (var i = 0; i < cuesArray.length; i++) {
    var _cuesArray$i = cuesArray[i],
        start = _cuesArray$i.start,
        end = _cuesArray$i.end,
        text = _cuesArray$i.text;

    if (text) {
      var cue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__compat__["o" /* makeCue */])(start, end, text);
      if (cue != null) {
        nativeCues.push(cue);
      }
    }
  }
  return nativeCues;
}

// Really basic CSS parsers using regular-expressions.
function rulesCss(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = void 0;
  while (m = ruleRe.exec(str)) {
    var name = m[1];
    var lang = propCss(m[2], "lang");
    if (name && lang) {
      langs[lang] = name;
    }
  }
  return langs;
}

function propCss(str, name) {
  return str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"))[1];
}

function decodeEntities(text) {
  return text.replace(BR, "\n").replace(HTML_ENTITIES, function ($0, $1) {
    return String.fromCharCode($1);
  });
}

/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {string} lang
 */
function parseSami(smi, lang) {
  var syncOp = /<sync[ >]/ig;
  var syncCl = /<sync[ >]|<\/body>/ig;

  var subs = [];

  var _smi$match = smi.match(STYLE),
      css = _smi$match[1];

  var up = void 0,
      to = syncCl.exec(smi);

  var langs = rulesCss(css);
  var klass = langs[lang];

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils_assert__["a" /* default */])(klass, "sami: could not find lang " + lang + " in CSS");

  for (;;) {
    up = syncOp.exec(smi);
    to = syncCl.exec(smi);
    if (!up && !to) {
      break;
    }
    if (!up || !to || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);
    if (!tim) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];
    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendSub(subs, str.split("\n"), start / 1000);
  }

  return createCuesFromArray(subs);

  function appendSub(subs, lines, start) {
    var i = lines.length,
        m = void 0;
    while (--i >= 0) {
      m = lines[i].match(PARAG);
      if (!m) {
        continue;
      }

      var _m = m,
          kl = _m[1],
          txt = _m[2];


      if (klass !== kl) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        subs.push({ text: decodeEntities(txt), start: start });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 823 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = parseSRTStringToHTML;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parseTimestamp_js__ = __webpack_require__(365);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Parse SRT subtitles into HTML.

// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.



/**
 * @param {string}
 * @returns {Array.<Object>}
 */
function parseSRTStringToHTML(srtStr) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);

  var cueBlocks = [];

  for (var i = 0; i < lines.length; i++) {
    if (lines[i]) {
      var startingI = i;
      i++;

      while (lines[i]) {
        i++;
      }
      cueBlocks.push(lines.slice(startingI, i));
    }
  }

  var cues = [];
  for (var _i = 0; _i < cueBlocks.length; _i++) {
    var cue = parseCue(cueBlocks[_i]);
    if (cue) {
      cues.push(cue);
    }
  }
  return cues;
}

/**
 * @param {Array.<string>} cueLines
 * @returns {Object}
 */
function parseCue(cueLines) {
  var _cueLines$1$split = cueLines[1].split(" --> "),
      startString = _cueLines$1$split[0],
      endString = _cueLines$1$split[1];

  var payloadLines = cueLines.slice(2, cueLines.length);
  if (!startString | !endString | !payloadLines.length) {
    return null;
  }

  var start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__parseTimestamp_js__["a" /* default */])(startString);
  var end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__parseTimestamp_js__["a" /* default */])(endString);

  var pEl = document.createElement("div");
  pEl.className = "rxp-texttrack-p";
  pEl.style.fontSize = "28px";
  pEl.style.position = "absolute";
  pEl.style.bottom = "5%";
  pEl.style.width = "100%";
  pEl.style.textAlign = "center";
  pEl.style.color = "#fff";
  pEl.style.textShadow = "-1px -1px 2px #000," + "1px -1px 2px #000," + "-1px 1px 2px #000," + "1px 1px 2px #000";

  for (var i = 0; i < payloadLines.length; i++) {
    if (i) {
      pEl.appendChild(document.createElement("br"));
    }
    var span = generateSpansFromSRTText(payloadLines[i]);
    pEl.appendChild(span);
  }

  return {
    start: start,
    end: end,
    element: pEl
  };
}

/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */
function generateSpansFromSRTText(text) {
  var secureDiv = document.createElement("div");
  secureDiv.innerHTML = text;

  var _loop = function _loop(node) {
    var childNodes = node.childNodes;
    var span = document.createElement("span");
    span.className = "rxp-texttrack-span";

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        span.innerHTML += currentNode.textContent;
      } else if (currentNode.nodeName === "B") {
        var spanChild = _loop(currentNode);
        spanChild.style.fontWeight = "bold";
        span.appendChild(spanChild);
      } else if (currentNode.nodeName === "I") {
        var _spanChild = _loop(currentNode);
        _spanChild.style.fontStyle = "italic";
        span.appendChild(_spanChild);
      } else if (currentNode.nodeName === "U") {
        var _spanChild2 = _loop(currentNode);
        _spanChild2.style.textDecoration = "underline";
        span.appendChild(_spanChild2);
      } else if (currentNode.nodeName === "FONT" && currentNode.color) {
        var _spanChild3 = _loop(currentNode);
        _spanChild3.style.color = currentNode.color;
        span.appendChild(_spanChild3);
      } else {
        var _spanChild4 = _loop(currentNode);
        span.appendChild(_spanChild4);
      }
    }
    return span;
  };

  return _loop(secureDiv);
}

/***/ }),
/* 824 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = parseSRTStringToVTTCues;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compat_index_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__ = __webpack_require__(365);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation




/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string}
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSRTStringToVTTCues(srtStr) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);

  var cueBlocks = [];

  for (var i = 0; i < lines.length; i++) {
    if (lines[i]) {
      var startingI = i;
      i++;

      while (lines[i]) {
        i++;
      }
      cueBlocks.push(lines.slice(startingI, i));
    }
  }

  var cues = [];
  for (var _i = 0; _i < cueBlocks.length; _i++) {
    var cue = parseCue(cueBlocks[_i]);
    if (cue) {
      cues.push(cue);
    }
  }
  return cues;
}

/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @returns {TextTrackCue|VTTCue|null}
 */
function parseCue(cueLines) {
  var _cueLines$1$split = cueLines[1].split(" --> "),
      startString = _cueLines$1$split[0],
      endString = _cueLines$1$split[1];

  var payloadLines = cueLines.slice(2, cueLines.length);
  if (!startString | !endString | !payloadLines.length) {
    return null;
  }

  var start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__["a" /* default */])(startString);
  var end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__["a" /* default */])(endString);
  var payload = payloadLines.join("\n");
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__compat_index_js__["o" /* makeCue */])(start, end, payload);
}

/***/ }),
/* 825 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return STYLE_ATTRIBUTES; });
var STYLE_ATTRIBUTES = ["backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode"];

/***/ }),
/* 826 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createElement;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__regexps_js__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getParentElementsByTagName_js__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_js__ = __webpack_require__(158);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// import getAttributeInElements from "../getAttributeInElements.js";

// Styling which can be applied to <span> from any level upper.
// Added here as an optimization
var SPAN_LEVEL_ATTRIBUTES = ["color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption"];

/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
function ttmlColorToCSSColor(color) {
  // TODO check all possible color fomats
  var regRes = void 0;
  regRes = __WEBPACK_IMPORTED_MODULE_1__regexps_js__["h" /* REGXP_8_HEX_COLOR */].exec(color);
  if (regRes != null) {
    return "rgba(" + parseInt(regRes[1], 16) + "," + parseInt(regRes[2], 16) + "," + parseInt(regRes[3], 16) + "," + parseInt(regRes[4], 16) / 255 + ")";
  }
  regRes = __WEBPACK_IMPORTED_MODULE_1__regexps_js__["i" /* REGXP_4_HEX_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + parseInt(regRes[1] + regRes[1], 16) + "," + parseInt(regRes[2] + regRes[2], 16) + "," + parseInt(regRes[3] + regRes[3], 16) + "," + parseInt(regRes[4] + regRes[4], 16) / 255 + ")";
  }
  return color;
}

/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
  return "-1px -1px " + thickness + " " + color + "," + ("1px -1px " + thickness + " " + color + ",") + ("-1px 1px " + thickness + " " + color + ",") + ("1px 1px " + thickness + " " + color);
}

// TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)

/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */
function applyTextStyle(element, style) {
  // applies to span
  var color = style.color;
  if (color) {
    element.style.color = ttmlColorToCSSColor(color);
  }

  // applies to body, div, p, region, span
  var backgroundColor = style.backgroundColor;
  if (backgroundColor) {
    element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
  }

  // applies to span
  var wrapOption = style.wrapOption;
  if (wrapOption && wrapOption === "noWrap") {
    element.style.whiteSpace = "nowrap";
  }

  // applies to span
  var textOutline = style.textOutline;
  if (textOutline) {
    var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
    var len = outlineData.length;
    if (len === 3) {
      var outlineColor = ttmlColorToCSSColor(outlineData[0]);
      var thickness = outlineData[1];
      element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
    } else if (color && len === 1) {
      var _thickness = outlineData[0];
      element.style.textShadow = generateCSSTextOutline(color, _thickness);
    } else if (len === 2) {
      var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
      var isFirstArgANumber = /^[0-9]/.test(outlineData[0]);

      // XOR-ing to be sure we get what we have
      if (isFirstArgAColor ^ isFirstArgANumber) {
        if (isFirstArgAColor) {
          var _outlineColor = ttmlColorToCSSColor(outlineData[0]);
          var _thickness2 = outlineData[1];
          element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
        } else if (color) {
          var _thickness3 = outlineData[0];
          element.style.textShadow = generateCSSTextOutline(color, _thickness3);
        }
      }
    }
  }

  // applies to span
  var textDecoration = style.textDecoration;
  if (textDecoration) {
    if (textDecoration === "noUnderline" || textDecoration === "noLineThrough" || textDecoration === "noOverline") {
      element.style.textDecoration = "none";
    } else if (textDecoration === "lineThrough") {
      element.style.textDecoration = "line-through";
    } else {
      element.style.textDecoration = textDecoration;
    }
  }

  // applies to span
  var fontFamily = style.fontFamily;
  if (fontFamily) {
    switch (fontFamily) {

      case "proportionalSansSerif":
        element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
        break;

      // TODO monospace or sans-serif or font with both?
      case "monospaceSansSerif":
      case "sansSerif":
        element.style.fontFamily = "sans-serif";
        break;

      case "monospaceSerif":
      case "default":
        element.style.fontFamily = "Courier New, Liberation Mono, monospace";
        break;

      // TODO font with both?
      case "proportionalSerif":
        element.style.fontFamily = "serif";
        break;

      default:
        element.style.fontFamily = fontFamily;
    }
  }

  // applies to span
  var fontStyle = style.fontStyle;
  if (fontStyle) {
    element.style.fontStyle = fontStyle;
  }

  // applies to span
  var fontWeight = style.fontWeight;
  if (fontWeight) {
    element.style.fontWeight = fontWeight;
  }

  // applies to span
  var fontSize = style.fontSize;
  if (fontSize) {
    // TODO Check if formats are always really 1:1
    element.style.fontSize = fontSize;
  }

  // applies to p, span
  var direction = style.direction;
  if (direction) {
    element.style.direction = direction;
  }

  // applies to p, span
  var unicodeBidi = style.unicodeBidi;
  if (unicodeBidi) {
    switch (unicodeBidi) {
      case "bidiOverride":
        element.style.unicodeBidi = "bidi-override";
        break;
      case "embed":
        element.style.unicodeBidi = "embed";
        break;
      default:
        element.style.unicodeBidi = "normal";
    }
  }

  // applies to body, div, p, region, span
  var visibility = style.visibility;
  if (visibility) {
    element.style.visibility = visibility;
  }

  // applies to body, div, p, region, span
  var display = style.display;
  if (display === "none") {
    element.style.display = "none";
  }
}

/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */
function applyGeneralStyle(element, style) {
  // applies to tt, region
  var extent = style.extent;
  if (extent) {
    var results = __WEBPACK_IMPORTED_MODULE_1__regexps_js__["a" /* REGXP_PERCENT_VALUES */].exec(extent);
    if (results != null) {
      element.style.width = results[1] + "%";
      element.style.height = results[2] + "%";
    }
  }

  // applies to region
  var writingMode = style.writingMode;
  if (writingMode) {}
  // TODO


  // applies to region
  var overflow = style.overflow;
  if (overflow) {
    element.style.overflow = overflow;
  } else {
    element.style.overflow = "hidden";
  }

  // applies to region
  var padding = style.padding;
  if (padding) {
    element.style.padding = padding;
  }

  // applies to region
  var origin = style.origin;
  if (origin) {
    var resultsPercent = __WEBPACK_IMPORTED_MODULE_1__regexps_js__["a" /* REGXP_PERCENT_VALUES */].exec(origin);
    if (resultsPercent != null) {
      element.style.position = "relative";
      element.style.left = resultsPercent[1] + "%";
      element.style.top = resultsPercent[2] + "%";
    } else {
      // TODO also px
    }
  }

  // applies to region
  var displayAlign = style.displayAlign;
  element.style.display = "flex";
  element.style.flexDirection = "column";
  if (displayAlign) {
    switch (displayAlign) {
      case "before":
        element.style.justifyContent = "flex-start";
        break;
      case "center":
        element.style.justifyContent = "center";
        break;
      case "after":
        element.style.justifyContent = "flex-end";
        break;
    }
  }

  // applies to region
  var opacity = style.opacity;
  if (opacity) {
    element.style.opacity = opacity;
  }

  // applies to body, div, p, region, span
  var visibility = style.visibility;
  if (visibility) {
    element.style.visibility = visibility;
  }

  // applies to body, div, p, region, span
  var display = style.display;
  if (display === "none") {
    element.style.display = "none";
  }
}

/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */
function applyPStyle(element, style) {
  // applies to body, div, p, region, span
  var paragraphBackgroundColor = style.backgroundColor;
  if (paragraphBackgroundColor) {
    element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
  }

  // applies to p
  var lineHeight = style.lineHeight;
  if (lineHeight) {
    element.style.lineHeight = lineHeight;
  }

  // applies to p
  var textAlign = style.textAlign;
  if (textAlign) {
    if (textAlign === "center") {
      element.style.textAlign = "center";
    } else if (textAlign === "left" || textAlign === "start") {
      // TODO check what start means (difference with left, writing direction?)
      element.style.textAlign = "left";
    } else if (textAlign === "right" || textAlign === "end") {
      // TODO check what end means (difference with right, writing direction?)
      element.style.textAlign = "right";
    }
  }
}

/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Array.<Element>} spans - <span> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} p - <p> tag which contain the element.
 * @param {Array.<Element>} divs - <div> tags which contain the element. In
 * order of closeness (from the closest to the least one)
 * @param {Element|null} body - <body> tag which contain the element.
 * @param {Array.<Object>} regions - Every <region> tag which can apply to
 * this element.
 * @param {Array.<Object>} styles - Every <style> tag which can apply to
 * this element.
 * @param {Boolean} shouldTrimWhiteSpaceParam - True if the space should be
 * trimmed by default. From the <tt> xml:space parameter.
 * @returns {HTMLElement}
 */
function createTextElement(el, style, shouldTrimWhiteSpaceParam) {
  var textElement = document.createElement("span");

  var textContent = el.textContent || "";

  var shouldTrimWhiteSpace = shouldTrimWhiteSpaceParam;

  // TODO Also parse it from parent elements
  // const spaceAttr = getAttributeInElements("xml:space", [
  //   ...spans, p, ...divs, body,
  // ]);
  // const shouldTrimWhiteSpace = spaceAttr ?
  //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
  if (shouldTrimWhiteSpace) {
    // 1. Trim leading and trailing whitespace.
    // 2. Collapse multiple spaces into one.
    var trimmed = textContent.trim();
    trimmed = trimmed.replace(/\s+/g, " ");
    textContent = trimmed;
  }

  textElement.innerHTML = textContent;
  textElement.className = "rxp-texttrack-span";

  applyTextStyle(textElement, style);
  return textElement;
}

/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */
function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @returns {Array.<HTMLElement>}
   */
  function loop(node, style, spans) {
    var childNodes = node.childNodes;
    var elements = [];
    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        var _getStylingAttributes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__style_js__["b" /* getStylingAttributes */])(["backgroundColor"], spans, styles, regions),
            backgroundColor = _getStylingAttributes.backgroundColor;

        if (backgroundColor) {
          style.backgroundColor = backgroundColor;
        } else {
          delete style.backgroundColor;
        }
        var el = createTextElement(currentNode, style, shouldTrimWhiteSpace);
        elements.push(el);
      } else if (currentNode.nodeName === "br") {
        var br = document.createElement("BR");
        elements.push(br);
      } else if (currentNode.nodeName === "span" && currentNode.childNodes.length > 0) {
        // compute the new applyable style
        var newStyle = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, style, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__style_js__["b" /* getStylingAttributes */])(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
        elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans)));
      }
    }
    return elements;
  }
  return loop(paragraph, __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, paragraphStyle), []);
}

/**
* @param {Element} paragraph
* @param {Element} body
* @param {Array.<Object>} regions
* @param {Array.<Object>} styles
* @param {Object} styles
* @param {Boolean} shouldTrimWhiteSpace
* @returns {HTMLElement}
*/
function createElement(paragraph, body, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
  var divs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__getParentElementsByTagName_js__["a" /* default */])(paragraph, "div");

  var parentElement = document.createElement("DIV");
  parentElement.className = "rxp-texttrack-region";

  applyGeneralStyle(parentElement, paragraphStyle);
  if (body) {
    // applies to body, div, p, region, span
    var _getStylingAttributes2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__style_js__["b" /* getStylingAttributes */])(["backgroundColor"], [].concat(divs, [body]), styles, regions),
        bodyBackgroundColor = _getStylingAttributes2.bodyBackgroundColor;

    if (bodyBackgroundColor) {
      parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
    }
  }

  var pElement = document.createElement("p");
  pElement.className = "rxp-texttrack-p";
  applyPStyle(pElement, paragraphStyle);

  var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);

  for (var i = 0; i < textContent.length; i++) {
    pElement.appendChild(textContent[i]);
  }

  // NOTE:
  // The following code is for the inclusion of div elements. This has no
  // advantage for now, and might only with future evolutions.
  // (This is only an indication of what the base of the code could look like).
  // if (divs.length) {
  //   let container = parentElement;
  //   for (let i = divs.length - 1; i >= 0; i--) {
  //     // TODO manage style at div level?
  //     // They are: visibility, display and backgroundColor
  //     // All these do not have any difference if applied to the <p> element
  //     // instead of the div.
  //     // The advantage might only be for multiple <p> elements dispatched
  //     // in multiple div Which we do not manage anyway for now.
  //     const divEl = document.createElement("DIV");
  //     divEl.className = "rxp-texttrack-div";
  //     container.appendChild(divEl);
  //     container = divEl;
  //   }
  //   container.appendChild(pElement);
  //   parentElement.appendChild(container);
  // } else {
  //   parentElement.appendChild(pElement);
  // }

  parentElement.appendChild(pElement);
  return parentElement;
}

/***/ }),
/* 827 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = parseTTMLStringToDIV;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getParameters_js__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodes_js__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__getParentElementsByTagName_js__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_js__ = __webpack_require__(825);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__style_js__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__parseCue_js__ = __webpack_require__(828);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @returns {Array.<Object>} */
function parseTTMLStringToDIV(str) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];
    if (!tt) {
      throw new Error("invalid XML");
    }

    var body = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__nodes_js__["a" /* getBodyNode */])(tt);
    var styleNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__nodes_js__["b" /* getStyleNodes */])(tt);
    var regionNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__nodes_js__["c" /* getRegionNodes */])(tt);
    var textNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__nodes_js__["d" /* getTextNodes */])(tt);
    var params = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getParameters_js__["a" /* default */])(tt);

    // construct styles array based on the xml as an optimization
    var styles = [];
    for (var i = 0; i <= styleNodes.length - 1; i++) {
      // TODO styles referencing other styles
      styles.push({
        id: styleNodes[i].getAttribute("xml:id"),
        style: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style_js__["a" /* getStylingFromElement */])(styleNodes[i])
      });
    }

    // construct regions array based on the xml as an optimization
    var regions = [];

    var _loop = function _loop(_i) {
      var regionId = regionNodes[_i].getAttribute("xml:id");
      var regionStyle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style_js__["a" /* getStylingFromElement */])(regionNodes[_i]);

      var associatedStyle = regionNodes[_i].getAttribute("style");
      if (associatedStyle) {
        var style = styles.find(function (x) {
          return x.id === associatedStyle;
        });
        if (style) {
          regionStyle = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, style.style, regionStyle);
        }
      }
      regions.push({
        id: regionId,
        style: regionStyle
      });
    };

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      _loop(_i);
    }

    // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.

    // TODO Compute corresponding CSS style here (as soon as we now the TTML
    // style) to speed up the process even
    // more.
    var bodyStyle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style_js__["b" /* getStylingAttributes */])(__WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* STYLE_ATTRIBUTES */], [body], styles, regions);
    for (var _i2 = 0; _i2 < textNodes.length; _i2++) {
      var paragraph = textNodes[_i2];
      var divs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__getParentElementsByTagName_js__["a" /* default */])(paragraph, "div");
      var paragraphStyle = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, bodyStyle, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style_js__["b" /* getStylingAttributes */])(__WEBPACK_IMPORTED_MODULE_4__constants_js__["a" /* STYLE_ATTRIBUTES */], [paragraph].concat(divs), styles, regions));

      var cue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__parseCue_js__["a" /* default */])(paragraph, 0, // offset
      styles, regions, body, paragraphStyle, params);
      if (cue) {
        ret.push(cue);
      }
    }
  }
  return ret;
}

/***/ }),
/* 828 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCue;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getTimeDelimiters_js__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createElement_js__ = __webpack_require__(826);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} ttParams
 * @returns {Object|null}
 */
function parseCue(paragraph, offset, styles, regions, body, styleBase, ttParams) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) {
    return null;
  }

  var _getTimeDelimiters = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__getTimeDelimiters_js__["a" /* default */])(paragraph, ttParams),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var element = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__createElement_js__["a" /* default */])(paragraph, body, regions, styles, styleBase, ttParams.spaceStyle === "default");
  return {
    start: start + offset,
    end: end + offset,
    element: element
  };
}

/***/ }),
/* 829 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compat__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__regexps__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__nodes__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getParameters__ = __webpack_require__(366);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__style__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__getParentElementsByTagName__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__getTimeDelimiters__ = __webpack_require__(367);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Style attributes currently used.
 */
var WANTED_STYLE_ATTRIBUTES = ["extent", "writingMode", "origin", "align"];

/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_LIGN_ALIGN = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};

/**
 * @type {Object}
 */
var TEXT_ALIGN_TO_POSITION_ALIGN = {
  left: "line-left",
  center: "center",
  right: "line-right"
};

function parseTTMLStringToVTT(str) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];
    if (!tt) {
      throw new Error("invalid XML");
    }

    var body = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__nodes__["a" /* getBodyNode */])(tt);
    var styleNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__nodes__["b" /* getStyleNodes */])(tt);
    var regionNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__nodes__["c" /* getRegionNodes */])(tt);
    var textNodes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__nodes__["d" /* getTextNodes */])(tt);
    var params = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getParameters__["a" /* default */])(tt);

    // construct styles array based on the xml as an optimization
    var styles = [];
    for (var i = 0; i <= styleNodes.length - 1; i++) {
      // TODO styles referencing other styles
      styles.push({
        id: styleNodes[i].getAttribute("xml:id"),
        style: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style__["a" /* getStylingFromElement */])(styleNodes[i])
      });
    }

    // construct regions array based on the xml as an optimization
    var regions = [];

    var _loop = function _loop(_i) {
      var regionId = regionNodes[_i].getAttribute("xml:id");
      var regionStyle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style__["a" /* getStylingFromElement */])(regionNodes[_i]);

      var associatedStyle = regionNodes[_i].getAttribute("style");
      if (associatedStyle) {
        var style = styles.find(function (x) {
          return x.id === associatedStyle;
        });
        if (style) {
          regionStyle = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, style.style, regionStyle);
        }
      }
      regions.push({
        id: regionId,
        style: regionStyle
      });
    };

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      _loop(_i);
    }

    // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.
    var bodyStyle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style__["b" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [body], styles, regions);

    for (var _i2 = 0; _i2 < textNodes.length; _i2++) {
      var paragraph = textNodes[_i2];
      var divs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__getParentElementsByTagName__["a" /* default */])(paragraph, "div");
      var paragraphStyle = __WEBPACK_IMPORTED_MODULE_0_object_assign___default()({}, bodyStyle, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__style__["b" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));

      var cue = parseCue(paragraph, 0, // offset
      styles, regions, paragraphStyle, params);
      if (cue) {
        ret.push(cue);
      }
    }
  }

  return ret;
}

/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @returns {TextTrackCue|null}
 */
function parseCue(paragraph, offset, styles, regions, paragraphStyle, params) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent || "")) {
    return null;
  }

  var _getTimeDelimiters = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__getTimeDelimiters__["a" /* default */])(paragraph, params),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var text = generateTextContent(paragraph, params.spaceStyle === "default");
  var cue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__compat__["o" /* makeCue */])(start + offset, end + offset, text);
  if (!cue) {
    return null;
  }
  addStyle(cue, paragraphStyle);
  return cue;
}

/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {string}
 */
function generateTextContent(paragraph, shouldTrimWhiteSpace) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
  function loop(node) {
    var childNodes = node.childNodes;
    var text = "";
    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];
      if (currentNode.nodeName === "#text") {
        var textContent = currentNode.textContent;

        // TODO Also parse it from parent elements
        // const spaceAttr = getAttribute("xml:space", [
        //   ...spans, p, ...divs, body,
        // ]);
        // const shouldTrimWhiteSpace = spaceAttr ?
        //   spaceAttr === "default" : shouldTrimWhiteSpaceParam;
        if (shouldTrimWhiteSpace) {
          // 1. Trim leading and trailing whitespace.
          // 2. Collapse multiple spaces into one.
          var trimmed = textContent.trim();
          trimmed = trimmed.replace(/\s+/g, " ");
          textContent = trimmed;
        }
        text += textContent;
      } else if (currentNode.nodeName === "br") {
        text += "\n";
      } else if (currentNode.nodeName === "span" && currentNode.childNodes.length > 0) {
        text += loop(currentNode);
      }
    }
    return text;
  }
  return loop(paragraph);
}

/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */
function addStyle(cue, style) {
  var extent = style.extent;
  if (extent) {
    var results = __WEBPACK_IMPORTED_MODULE_2__regexps__["a" /* REGXP_PERCENT_VALUES */].exec(extent);
    if (results != null) {
      // Use width value of the extent attribute for size.
      // Height value is ignored.
      cue.size = Number(results[1]);
    }
  }

  var writingMode = style.writingMode;
  var isVerticalText = true;
  if (writingMode === "tb" || writingMode === "tblr") {
    cue.vertical = "lr";
  } else if (writingMode === "tbrl") {
    cue.vertical = "rl";
  } else {
    isVerticalText = false;
  }

  var origin = style.origin;
  if (origin) {
    var _results = __WEBPACK_IMPORTED_MODULE_2__regexps__["a" /* REGXP_PERCENT_VALUES */].exec(origin);
    if (_results != null) {
      // for vertical text use first coordinate of tts:origin
      // to represent line of the cue and second - for position.
      // Otherwise (horizontal), use them the other way around.
      if (isVerticalText) {
        // TODO check and uncomment
        // cue.position = Number(results[2]);
        // cue.line = Number(results[1]);
      } else {}
        // TODO check and uncomment
        // cue.position = Number(results[1]);
        // cue.line = Number(results[2]);

        // A boolean indicating whether the line is an integer
        // number of lines (using the line dimensions of the first
        // line of the cue), or whether it is a percentage of the
        // dimension of the video. The flag is set to true when lines
        // are counted, and false otherwise.
        // TODO check and uncomment
        // cue.snapToLines = false;
    }
  }

  var align = style.align;
  if (align) {
    cue.align = align;
    if (align === "center") {
      if (cue.align !== "center") {
        // Workaround for a Chrome bug http://crbug.com/663797
        // Chrome does not support align = "center"
        cue.align = "middle";
      }
      cue.position = "auto";
    }
    cue.positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align] || "";
    cue.lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align] || "";
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseTTMLStringToVTT);

/***/ }),
/* 830 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__regexps_js__ = __webpack_require__(157);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse TTML Time formats to seconds.
 *
 * Largely inspired from what the shaka-player does for TTML time parsing.
 * But rewritten to a more rx-player style.
 */



/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */
function parseTime(text, ttParams) {
  if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["b" /* REGXP_TIME_COLON_FRAMES */].test(text)) {
    return parseColonTimeWithFrames(ttParams, text);
  } else if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["c" /* REGXP_TIME_COLON */].test(text)) {
    return parseTimeFromRegExp(__WEBPACK_IMPORTED_MODULE_0__regexps_js__["c" /* REGXP_TIME_COLON */], text);
  } else if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["d" /* REGXP_TIME_COLON_MS */].test(text)) {
    return parseTimeFromRegExp(__WEBPACK_IMPORTED_MODULE_0__regexps_js__["d" /* REGXP_TIME_COLON_MS */], text);
  } else if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["e" /* REGXP_TIME_FRAMES */].test(text)) {
    return parseFramesTime(ttParams, text);
  } else if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["f" /* REGXP_TIME_TICK */].test(text)) {
    return parseTickTime(ttParams, text);
  } else if (__WEBPACK_IMPORTED_MODULE_0__regexps_js__["g" /* REGXP_TIME_HMS */].test(text)) {
    return parseTimeFromRegExp(__WEBPACK_IMPORTED_MODULE_0__regexps_js__["g" /* REGXP_TIME_HMS */], text);
  }
}

/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseFramesTime(ttParams, text) {
  // 75f or 75.5f
  var results = __WEBPACK_IMPORTED_MODULE_0__regexps_js__["e" /* REGXP_TIME_FRAMES */].exec(text);
  var frames = Number(results[1]);
  return frames / ttParams.frameRate;
}

/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseTickTime(ttParams, text) {
  // 50t or 50.5t
  var results = __WEBPACK_IMPORTED_MODULE_0__regexps_js__["f" /* REGXP_TIME_TICK */].exec(text);
  var ticks = Number(results[1]);
  return ticks / ttParams.tickRate;
}

/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseColonTimeWithFrames(ttParams, text) {
  // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
  var results = __WEBPACK_IMPORTED_MODULE_0__regexps_js__["b" /* REGXP_TIME_COLON_FRAMES */].exec(text);

  var hours = Number(results[1]);
  var minutes = Number(results[2]);
  var seconds = Number(results[3]);
  var frames = Number(results[4]);
  var subframes = Number(results[5]) || 0;

  frames += subframes / ttParams.subFrameRate;
  seconds += frames / ttParams.frameRate;

  return seconds + minutes * 60 + hours * 3600;
}

/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */
function parseTimeFromRegExp(regex, text) {
  var results = regex.exec(text);
  if (results === null || results[0] === "") {
    return null;
  }
  // This capture is optional, but will still be in the array as undefined,
  // default to 0.
  var hours = Number(results[1]) || 0;
  var minutes = Number(results[2]) || 0;
  var seconds = Number(results[3]) || 0;
  var miliseconds = Number(results[4]) || 0;

  return miliseconds / 1000 + seconds + minutes * 60 + hours * 3600;
}

/* harmony default export */ __webpack_exports__["a"] = (parseTime);

/***/ }),
/* 831 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = parseWebVTT;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_log_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__ = __webpack_require__(833);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
* Parse WebVTT from text. Returns an array with:
* - start : start of current cue, in seconds
* - end : end of current cue, in seconds
* - content : HTML formatted cue.
*
* Global style is parsed and applied to div element.
* Specific style is parsed and applied to class element.
*
* @param {string} text
* @return {Array.<Object>}
* @throws Error - Throws if the given WebVTT string is invalid.
*/
function parseWebVTT(text) {
  var newLineChar = /\r\n|\n|\r/g;
  var linified = text.split(newLineChar);
  var cuesArray = [];
  var styleElements = [];
  if (!linified[0].match(/^WEBVTT( |\t|\n|\r|$)/)) {
    throw new Error("Can't parse WebVTT: Invalid File.");
  }

  for (var i = 1; i < linified.length; i++) {
    if (isStartOfStyleBlock(linified[i])) {
      var startOfStyleBlock = i;
      i++;

      // continue incrementing i until either:
      //   - empty line
      //   - end of file
      while (!(linified[i].length === 0)) {
        i++;
      }
      var styleBlock = linified.slice(startOfStyleBlock, i);
      var parsedStyles = parseStyleBlock(styleBlock);
      styleElements.push.apply(styleElements, parsedStyles);
    }
  }

  // Parse cues, format and apply style.
  for (var _i = 1; _i < linified.length; _i++) {
    if (!(linified[_i].length === 0)) {
      if (isStartOfCueBlock(linified[_i])) {
        var startOfCueBlock = _i;
        _i++;
        // continue incrementing i until either:
        //   - empty line
        //   - end of file
        while (!(linified[_i].length === 0)) {
          _i++;
        }
        var cueBlock = linified.slice(startOfCueBlock, _i);
        var cue = parseCue(cueBlock, styleElements);
        if (cue) {
          cuesArray.push(cue);
        }
      } else {
        while (!(linified[_i].length === 0)) {
          _i++;
        }
      }
    }
  }
  return cuesArray;
}

/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfStyleBlock(text) {
  return text.match(/^STYLE.*?/g);
}

/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfNoteBlock(text) {
  return text.match(/^NOTE.*?/g);
}

/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfRegionBlock(text) {
  return text.match(/^REGION.*?/g);
}

/**
 * Returns true if the given line looks like the beginning of a cue block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfCueBlock(text) {
  return !isStartOfNoteBlock(text) && !isStartOfStyleBlock(text) && !isStartOfRegionBlock(text) && text.length !== 0;
}

/**
 *
 * Parse style element from WebVTT.
 * @param {Array.<string>} styleBlock
 * @return {Array.<Object>} styleElements
 */
function parseStyleBlock(styleBlock) {
  var styleElements = [];
  var index = 1;
  var classNames = [];
  if (styleBlock[index].match(/::cue {/)) {
    classNames.push({ isGlobalStyle: true });
    index++;
  } else {
    while (styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/)) {
      var cueClassLine = styleBlock[index].match(/::cue\(\.?(.*?)\)(?:,| {)/);
      classNames.push({
        className: cueClassLine[1],
        isGlobalStyle: false
      });
      index++;
    }
  }

  var styleContent = "";

  while (!(styleBlock[index].match(/}/) || styleBlock[index].length === 0)) {
    styleContent += styleBlock[index];
    index++;
  }
  classNames.forEach(function (name) {
    styleElements.push({
      className: name.className,
      isGlobalStyle: name.isGlobalStyle,
      styleContent: styleContent.replace(/\s/g, "")
    });
  });
  return styleElements;
}

/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {number} index
 * @param {Array.<string>} linified
 * @param {Array.<Object>} styleElements
 * @returns {Object|undefined}
 */
function parseCue(cueBlock, styleElements) {
  var region = document.createElement("div");
  var regionAttr = document.createAttribute("style");
  var index = 0;
  regionAttr.value = "width:100%; \
    height:100%; \
    display:flex; \
    flex-direction:column; \
    justify-content:flex-end; \
    align-items:center;";
  region.setAttributeNode(regionAttr);

  // Get Header. It may be a class name associated with cue.
  var header = cueBlock[index];
  index++;

  // Get time ranges.
  var timeCodes = cueBlock[index];
  var range = parseTimeCode(timeCodes);
  if (!range || range.start == null || range.end == null) {
    __WEBPACK_IMPORTED_MODULE_0__utils_log_js__["a" /* default */].warn("VTT: Invalid cue, the timecode line could not be parsed.");
    return; // cancel if we do not find the start or end of this cue
  }

  index++;

  // Get content, format and apply style.
  var pElement = document.createElement("p");
  var pAttr = document.createAttribute("style");
  pAttr.value = "text-align:center";
  pElement.setAttributeNode(pAttr);

  var spanElement = document.createElement("span");
  var attr = document.createAttribute("style");

  // set color and background-color default values, as indicated in:
  // https://www.w3.org/TR/webvtt1/#applying-css-properties
  attr.value = "background-color:rgba(0,0,0,0.8); \
    color:white;";
  spanElement.setAttributeNode(attr);

  var styles = styleElements.filter(function (styleElement) {
    return styleElement.className === header && !styleElement.isGlobalStyle || styleElement.isGlobalStyle;
  }).map(function (styleElement) {
    return styleElement.styleContent;
  });

  if (styles) {
    attr.value += styles.join();
    spanElement.setAttributeNode(attr);
  }

  while (cueBlock[index]) {

    if (spanElement.childNodes.length != 0) {
      spanElement.appendChild(document.createElement("br"));
    }

    formatWebVTTtoHTML(cueBlock[index], styleElements).forEach(function (child) {
      spanElement.appendChild(child);
    });

    index++;
  }

  region.appendChild(pElement);
  pElement.appendChild(spanElement);

  return {
    start: range.start,
    end: range.end,
    element: region
  };
}

/**
 * Parse the VTT timecode line given and construct an object with two
 * properties:
 *   - start {Number|undefined}: the corresponding start time in seconds
 *   - end {Number|undefined}: the corresponding end time in seconds
 * @example
 * ```js
 * parseTimeCode("00:02:30 -> 00:03:00");
 * // -> {
 * //      start: 150,
 * //      end: 180,
 * //    }
 * ```
 * @param {string} text
 * @returns {Object|undefined}
 */
function parseTimeCode(text) {
  var tsRegex = "((?:[0-9]{2}\:?)[0-9]{2}:[0-9]{2}.[0-9]{2,3})";
  var startEndRegex = tsRegex + "(?:\ |\t)-->(?:\ |\t)" + tsRegex;
  var ranges = text.match(startEndRegex);
  if (startEndRegex) {
    var start = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__["a" /* default */])(ranges[1]);
    var end = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__parseTimestamp_js__["a" /* default */])(ranges[2]);

    return { start: start, end: end };
  }
}

/**
* Format WebVTT tags and classes into usual HTML.
* <b *> => <b>
* <u *> => <u>
* <i *> => <i>
* <c.class *> => <c.class>
* Style is inserted if associated to tag or class.
* @param {string} text
* @param {Array.<Object>} styleElements
* @returns {Array.<Node>}
*/
function formatWebVTTtoHTML(text, styleElements) {
  var HTMLTags = ["u", "i", "b"];
  var webVTTTags = ["u", "i", "b", "c", "#text"];
  var styleClasses = styleElements.map(function (styleElement) {
    return styleElement.className;
  });
  var filtered = text
  // Remove timestamp tags
  .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "")
  // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
  .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");

  var parser = new DOMParser();
  var parsedWebVTT = parser.parseFromString(filtered, "text/html");
  var nodes = parsedWebVTT.body.childNodes;

  /**
  * Apply styles to specifig tag in children nodes.
  * (e.g. If class "b" has style, then : <b style="content">
  * )
  * Change class tags into span with associated style, or text*
  * First it was: <c.class>...</c>. Then <class></class>.
  * Finally <span style="content"></span> or text.
  * @param {Array.<Node>} childNodes
  * @returns {Array.<Node>}
  */
  function parseNode(nodeToParse) {
    var parsedNodeArray = [];
    for (var i = 0; i < nodeToParse.length; i++) {
      parsedNodeArray[i] = createStyleElement(nodeToParse[i]);
    }

    /**
     * Construct an HTMLElement/TextNode representing the given node and apply
     * the right styling on it.
     * @param {Node} baseNode
     * @returns {Node}
     */
    function createStyleElement(baseNode) {
      var mainTag = baseNode.nodeName.toLowerCase().split(".")[0];
      var nodeWithStyle = void 0;
      if (webVTTTags.includes(mainTag)) {
        // If element accepted
        if (mainTag === "#text") {
          nodeWithStyle = document.createTextNode(baseNode.wholeText);
        } else {
          var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
          var classIndexes = [];
          nodeClasses.forEach(function (nodeClass) {
            if (styleClasses.indexOf(nodeClass) !== -1) {
              classIndexes.push(styleClasses.indexOf(nodeClass));
            }
          });
          if (classIndexes.length !== 0) {
            // If style must be applied
            var attr = document.createAttribute("style");
            classIndexes.forEach(function (index) {
              attr.value += styleElements[index].styleContent;
            });
            var nameClass = HTMLTags.includes(mainTag) ? mainTag : "span";
            nodeWithStyle = document.createElement(nameClass);
            nodeWithStyle.setAttributeNode(attr);
          } else {
            // If style mustn't be applied. Rebuild element with tag name
            var elementTag = !HTMLTags.includes(mainTag) ? "span" : mainTag;
            nodeWithStyle = document.createElement(elementTag);
          }
          for (var j = 0; j < baseNode.childNodes.length; j++) {
            nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[j]));
          }
        }
      } else {
        nodeWithStyle = document.createElement("span");
        for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
          nodeWithStyle.appendChild(createStyleElement(baseNode.childNodes[_j]));
        }
      }

      return nodeWithStyle;
    }

    return parsedNodeArray;
  }

  return parseNode(nodes);
}

/***/ }),
/* 832 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = parseVTTStringToVTTCues;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__compat_index_js__ = __webpack_require__(22);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// Simple VTT to VTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.

/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string}
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseVTTStringToVTTCues(vttStr) {
  // WEBVTT authorize CRLF, LF or CR as line terminators
  var lines = vttStr.split(/\r\n|\n|\r/);

  if (!/^WEBVTT($ | |\t)/.test(lines[0])) {
    throw new Error("Can't parse WebVTT: Invalid file.");
  }

  var cueBlocks = [];

  for (var i = 1; i < lines.length; i++) {
    if (isStartOfCueBlock(lines[i])) {
      var startingI = i;
      i++;

      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (lines[i]) {
        i++;
      }
      cueBlocks.push(lines.slice(startingI, i));
    } else if (lines[i]) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (lines[i]) {
        i++;
      }
    }
  }

  var cues = [];
  for (var _i = 0; _i < cueBlocks.length; _i++) {
    var cue = parseCue(cueBlocks[_i]);
    if (cue) {
      cues.push(cue);
    }
  }
  return cues;
}

/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {string} line
 * @returns {Boolean}
 */
function isStartOfCueBlock(line) {
  // checked cases:
  //   - empty lines
  //   - start of a comment
  //   - start of a region
  //   - start of a style
  // Anything else should be a cue. TODO re-check with the spec
  if (!line || /^(NOTE)|(REGION)|(STYLE)($| |\t)/.test(line)) {
    return false;
  }
  return true;
}

/**
 * Parse cue block into a cue.
 * @param {Array.<string>} cueLines
 * @returns {TextTrackCue|VTTCue}
 */
function parseCue(cueLines) {
  var timingRegexp = /-->/;
  var timeString = void 0;
  var payloadLines = void 0;

  if (!timingRegexp.test(cueLines[0])) {
    if (!timingRegexp.test(cueLines[1])) {
      // not a cue
      return null;
    }
    timeString = cueLines[1];
    payloadLines = cueLines.slice(2, cueLines.length);
  } else {
    timeString = cueLines[0];
    payloadLines = cueLines.slice(1, cueLines.length);
  }

  var timeAndSettings = parseTimeAndSettings(timeString);
  if (!timeAndSettings) {
    return null;
  }

  var start = timeAndSettings.start,
      end = timeAndSettings.end,
      settings = timeAndSettings.settings;

  var payload = payloadLines.join("\n");
  var cue = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__compat_index_js__["o" /* makeCue */])(start, end, payload);
  setSettingsOnCue(settings, cue);

  return cue;
}

/**
 * Parse a single WEBVTT timestamp into seconds
 * @param {string} timestampString
 * @returns {Number}
 */
function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":");
  if (splittedTS.length === 3) {
    var hours = parseInt(splittedTS[0], 10);
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[2], 10);
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return;
    }
    return hours * 60 * 60 + minutes * 60 + seconds;
  } else if (splittedTS.length === 2) {
    var _minutes = parseInt(splittedTS[1], 10);
    var _seconds = parseFloat(splittedTS[2], 10);
    if (isNaN(_minutes) || isNaN(_seconds)) {
      return;
    }
    return _minutes * 60 + _seconds;
  }
}

/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
function parseSettings(settingsString) {
  var splittedSettings = settingsString.split(/ |\t/);
  return splittedSettings.reduce(function (acc, setting) {
    var splittedSetting = setting.split(":");
    if (splittedSetting.length === 2) {
      acc[splittedSetting[0]] = splittedSetting[1];
    }
    return acc;
  }, {});
}

/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */
function parseTimeAndSettings(timeString) {
  /*
   * RegExp for the timestamps + settings line.
   *
   * Capture groups:
   *   1 -> start timestamp
   *   2 -> end timestamp
   *   3 - settings
   * @type {RegExp}
   */
  var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;

  var matches = timeString.match(lineRegex);
  if (!matches) {
    return null;
  }

  var start = parseTimestamp(matches[1]);
  var end = parseTimestamp(matches[2]);
  if (start == null || end == null) {
    return null;
  }

  var settings = parseSettings(matches[3]);

  return {
    start: start,
    end: end,
    settings: settings
  };
}

/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {VTTCue|TextTrackCue} cue
 */
function setSettingsOnCue(settings, cue) {
  if (settings.vertical && (settings.vertical === "rl" || settings.vertical === "lr")) {
    cue.vertical = settings.vertical;
  }

  if (settings.line) {

    /**
     * Capture groups:
     *   1 -> percentage position
     *   2 -> optional decimals from percentage position
     *   3 -> optional follow-up of the string indicating alignment value
     *   4 -> alignment value
     * @type {RegExp}
     */
    var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
    var percentageMatches = settings.line.match(percentagePosition);
    if (percentageMatches) {
      cue.line = percentageMatches[1];
      cue.snapToLines = false;
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(["start", "center", "end"], percentageMatches[4])) {
        cue.lineAlign = percentageMatches[4];
      }
    } else {
      /**
       * Capture groups:
       *   1 -> line number
       *   2 -> optional follow-up of the string indicating alignment value
       *   3 -> alignment value
       * @type {RegExp}
       */
      var linePosition = /^(-?\d+)(,([a-z]+))?/;
      var lineMatches = settings.line.match(linePosition);

      if (lineMatches) {
        cue.line = lineMatches[1];
        cue.snapToLines = true;
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(["start", "center", "end"], percentageMatches[3])) {
          cue.lineAlign = percentageMatches[3];
        }
      }
    }
  }

  if (settings.position) {
    var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
    var positionArr = positionRegex.exec(settings.position);
    var position = parseInt(positionArr[1], 10);
    if (!isNaN(position)) {
      cue.position = position;

      if (positionArr[2]) {
        cue.positionAlign = positionArr[2];
      }
    }
  }

  if (settings.size) {
    cue.size = settings.size;
  }

  if (settings.align && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_array_includes_js__["a" /* default */])(["start", "center", "end", "left"], settings.align)) {
    cue.align = settings.align;
  }
}

/***/ }),
/* 833 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseTimestamp;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":").reverse();

  if (splittedTS[2] || splittedTS[1]) {
    var hours = splittedTS[2] ? parseInt(splittedTS[2], 10) : 0;
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[0].replace(",", "."), 10);
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return;
    }
    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}

/***/ }),
/* 834 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimpleSet; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple hash-based set.
 * @class SimpleSet
 */
var SimpleSet = function () {
  function SimpleSet() {
    _classCallCheck(this, SimpleSet);

    this.hash = {};
  }

  SimpleSet.prototype.add = function add(x) {
    this.hash[x] = true;
  };

  SimpleSet.prototype.remove = function remove(x) {
    delete this.hash[x];
  };

  SimpleSet.prototype.test = function test(x) {
    return this.hash[x] === true;
  };

  return SimpleSet;
}();



/***/ }),
/* 835 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 */
var InitializationSegmentCache = function () {
  function InitializationSegmentCache() {
    _classCallCheck(this, InitializationSegmentCache);

    this.cache = {};
  }

  InitializationSegmentCache.prototype.add = function add(_ref, response) {
    var segment = _ref.segment;

    if (segment.isInit) {
      this.cache[segment.id] = response;
    }
  };

  InitializationSegmentCache.prototype.get = function get(_ref2) {
    var segment = _ref2.segment;

    if (segment.isInit) {
      var value = this.cache[segment.id];
      if (value != null) {
        return value;
      }
    }
    return null;
  };

  return InitializationSegmentCache;
}();

/* harmony default export */ __webpack_exports__["a"] = (InitializationSegmentCache);

/***/ }),
/* 836 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
/* harmony default export */ __webpack_exports__["a"] = ({
  aa: "aar", // Afar
  ab: "abk", // Abkhazian
  ae: "ave", // Avestan
  af: "afr", // Afrikaans
  ak: "aka", // Akan
  am: "amh", // Amharic
  an: "arg", // Aragonese
  ar: "ara", // Arabic
  as: "asm", // Assamese
  av: "ava", // Avaric
  ay: "aym", // Aymara
  az: "aze", // Azerbaijani
  ba: "bak", // Bashkir
  be: "bel", // Belarusian
  bg: "bul", // Bulgarian
  bi: "bis", // Bislama
  bm: "bam", // Bambara
  bn: "ben", // Bengali
  bo: "bod", // Tibetan
  br: "bre", // Breton
  bs: "bos", // Bosnian
  ca: "cat", // Catalan, Valencian
  ce: "che", // Chechen
  ch: "cha", // Chamorro
  co: "cos", // Corsican
  cr: "cre", // Cree
  cs: "ces", // Czech
  cu: "chu", // Church Slavic, Church Slavonic, Old Church Slavonic,
  // Old Slavonic, Old Bulgarian
  cv: "chv", // Chuvash
  cy: "cym", // Welsh
  da: "dan", // Danish
  de: "deu", // German
  dv: "div", // Divehi, Dhivehi, Maldivian
  dz: "dzo", // Dzongkha
  ee: "ewe", // Ewe
  el: "ell", // Greek (modern)
  en: "eng", // English
  eo: "epo", // Esperanto
  es: "spa", // Spanish, Castilian
  et: "est", // Estonian
  eu: "eus", // Basque
  fa: "fas", // Persian
  ff: "ful", // Fulah
  fi: "fin", // Finnish
  fj: "fij", // Fijian
  fo: "fao", // Faroese
  fr: "fra", // French
  fy: "fry", // Western Frisian
  ga: "gle", // Irish
  gd: "gla", // Gaelic, Scottish Gaelic
  gl: "glg", // Galician
  gn: "grn", // Guaran
  gu: "guj", // Gujarati
  gv: "glv", // Manx
  ha: "hau", // Hausa
  he: "heb", // Hebrew (modern)
  hi: "hin", // Hindi
  ho: "hmo", // Hiri Motu
  hr: "hrv", // Croatian
  ht: "hat", // Haitian, Haitian Creole
  hu: "hun", // Hungarian
  hy: "hye", // Armenian
  hz: "her", // Herero
  ia: "ina", // Interlingua
  id: "ind", // Indonesian
  ie: "ile", // Interlingue
  ig: "ibo", // Igbo
  ii: "iii", // Sichuan Yi, Nuosu
  ik: "ipk", // Inupiaq
  io: "ido", // Ido
  is: "isl", // Icelandic
  it: "ita", // Italian
  iu: "iku", // Inuktitut
  ja: "jpn", // Japanese
  jv: "jav", // Javanese
  ka: "kat", // Georgian
  kg: "kon", // Kongo
  ki: "kik", // Kikuyu, Gikuyu
  kj: "kua", // Kuanyama, Kwanyama
  kk: "kaz", // Kazakh
  kl: "kal", // Kalaallisut, Greenlandic
  km: "khm", // Central Khmer
  kn: "kan", // Kannada
  ko: "kor", // Korean
  kr: "kau", // Kanuri
  ks: "kas", // Kashmiri
  ku: "kur", // Kurdish
  kv: "kom", // Komi
  kw: "cor", // Cornish
  ky: "kir", // Kirghiz, Kyrgyz
  la: "lat", // Latin
  lb: "ltz", // Luxembourgish, Letzeburgesch
  lg: "lug", // Ganda
  li: "lim", // Limburgan, Limburger, Limburgish
  ln: "lin", // Lingala
  lo: "lao", // Lao
  lt: "lit", // Lithuanian
  lu: "lub", // Luba-Katanga
  lv: "lav", // Latvian
  mg: "mlg", // Malagasy
  mh: "mah", // Marshallese
  mi: "mri", // Maori
  mk: "mkd", // Macedonian
  ml: "mal", // Malayalam
  mn: "mon", // Mongolian
  mr: "mar", // Marathi
  ms: "msa", // Malay
  mt: "mlt", // Maltese
  my: "mya", // Burmese
  na: "nau", // Nauru
  nb: "nob", // Norwegian Bokml
  nd: "nde", // North Ndebele
  ne: "nep", // Nepali
  ng: "ndo", // Ndonga
  nl: "nld", // Dutch, Flemish
  nn: "nno", // Norwegian Nynorsk
  no: "nor", // Norwegian
  nr: "nbl", // South Ndebele
  nv: "nav", // Navajo, Navaho
  ny: "nya", // Chichewa, Chewa, Nyanja
  oc: "oci", // Occitan
  oj: "oji", // Ojibwa
  om: "orm", // Oromo
  or: "ori", // Oriya
  os: "oss", // Ossetian, Ossetic
  pa: "pan", // Panjabi, Punjabi
  pi: "pli", // Pali
  pl: "pol", // Polish
  ps: "pus", // Pashto, Pushto
  pt: "por", // Portuguese
  qu: "que", // Quechua
  rm: "roh", // Romansh
  rn: "run", // Rundi
  ro: "ron", // Romanian, Moldavian, Moldovan
  ru: "rus", // Russian
  rw: "kin", // Kinyarwanda
  sa: "san", // Sanskrit
  sc: "srd", // Sardinian
  sd: "snd", // Sindhi
  se: "sme", // Northern Sami
  sg: "sag", // Sango
  si: "sin", // Sinhala, Sinhalese
  sk: "slk", // Slovak
  sl: "slv", // Slovenian
  sm: "smo", // Samoan
  sn: "sna", // Shona
  so: "som", // Somali
  sq: "sqi", // Albanian
  sr: "srp", // Serbian
  ss: "ssw", // Swati
  st: "sot", // Southern Sotho
  su: "sun", // Sundanese
  sv: "swe", // Swedish
  sw: "swa", // Swahili
  ta: "tam", // Tamil
  te: "tel", // Telugu
  tg: "tgk", // Tajik
  th: "tha", // Thai
  ti: "tir", // Tigrinya
  tk: "tuk", // Turkmen
  tl: "tgl", // Tagalog
  tn: "tsn", // Tswana
  to: "ton", // Tonga (Tonga Islands)
  tr: "tur", // Turkish
  ts: "tso", // Tsonga
  tt: "tat", // Tatar
  tw: "twi", // Twi
  ty: "tah", // Tahitian
  ug: "uig", // Uighur, Uyghur
  uk: "ukr", // Ukrainian
  ur: "urd", // Urdu
  uz: "uzb", // Uzbek
  ve: "ven", // Venda
  vi: "vie", // Vietnamese
  vo: "vol", // Volapk
  wa: "wln", // Walloon
  wo: "wol", // Wolof
  xh: "xho", // Xhosa
  yi: "yid", // Yiddish
  yo: "yor", // Yoruba
  za: "zha", // Zhuang, Chuang
  zh: "zho", // Chinese
  zu: "zul" // Zulu
});

/***/ }),
/* 837 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
/* harmony default export */ __webpack_exports__["a"] = ({
  alb: "sqi", // Albanian
  arm: "hye", // Armenian
  baq: "eus", // Basque
  bur: "mya", // Burmese
  chi: "zho", // Chinese
  cze: "ces", // Czech
  dut: "nld", // Dutch; Flemish
  fre: "fra", // French
  geo: "kat", // Georgian
  ger: "deu", // German
  gre: "ell", // Modern Greek (1453)
  ice: "isl", // Icelandic
  mac: "mkd", // Macedonian
  mao: "mri", // Maori
  may: "msa", // Malay
  per: "fas", // Persian
  slo: "slk", // Slovak
  rum: "ron", // Moldovan
  tib: "bod", // Tibetan
  wel: "cym" // Welsh
});

/***/ }),
/* 838 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = listToMap;
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Transform an array of strings into an Object with the key and value
 * mirrored.
 * @param {Array.<string>} list
 * @returns {Object}
 */
function listToMap(list) {
  var map = list.reduce(function (map, name) {
    map[name] = name;
    return map;
  }, {});

  map.keys = list;
  return map;
}

/***/ }),
/* 839 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = throttle;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__castToObservable_js__ = __webpack_require__(45);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Throttle an asynchronous function (returning an Observable or Promise) to
 * drop calls done before a previous one has finished or failed.
 *
 * @example
 * ```js
 * const fn = (time) => Observable.timer(time);
 * const throttled = throttle(fn);
 *
 * const Obs1 = throttled(2000); // -> call fn(2000) and returns its Observable
 * const Obs2 = throttled(1000); // -> won't do anything, Obs2 is an empty
 *                               //    observable (it directly completes)
 * setTimeout(() => {
 *   const Obs3 = throttled(1000); // -> will call fn(1000)
 * }, 2001);
 * ```
 *
 * @param {Function} func
 * @returns {Function} - Function taking in argument the arguments you want
 * to give your function, and returning an Observable.
 */
function throttle(func) {
  var isPending = false;

  return function () {
    if (isPending) {
      return __WEBPACK_IMPORTED_MODULE_0_rxjs_Observable__["Observable"].empty();
    }

    isPending = true;
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__castToObservable_js__["a" /* default */])(func.apply(undefined, arguments)).do(null, function () {
      return isPending = false;
    }, function () {
      return isPending = false;
    });
  };
}

/***/ }),
/* 840 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first argument given different from undefined.
 * @param {...*} args
 * @returns {*}
 */
/* harmony default export */ __webpack_exports__["a"] = (function () {
  var i = 0;
  var len = arguments.length;
  while (i < len) {
    if ((arguments.length <= i ? undefined : arguments[i]) !== undefined) {
      return arguments.length <= i ? undefined : arguments[i];
    }
    i++;
  }
});

/***/ }),
/* 841 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first argument given different from undefined or null.
 * @param {...*} args
 * @returns {*}
 */
/* harmony default export */ __webpack_exports__["a"] = (function () {
  var i = 0;
  var len = arguments.length;
  while (i < len) {
    if ((arguments.length <= i ? undefined : arguments[i]) != null) {
      return arguments.length <= i ? undefined : arguments[i];
    }
    i++;
  }
});

/***/ }),
/* 842 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 221,
	"./af.js": 221,
	"./ar": 228,
	"./ar-dz": 222,
	"./ar-dz.js": 222,
	"./ar-kw": 223,
	"./ar-kw.js": 223,
	"./ar-ly": 224,
	"./ar-ly.js": 224,
	"./ar-ma": 225,
	"./ar-ma.js": 225,
	"./ar-sa": 226,
	"./ar-sa.js": 226,
	"./ar-tn": 227,
	"./ar-tn.js": 227,
	"./ar.js": 228,
	"./az": 229,
	"./az.js": 229,
	"./be": 230,
	"./be.js": 230,
	"./bg": 231,
	"./bg.js": 231,
	"./bn": 232,
	"./bn.js": 232,
	"./bo": 233,
	"./bo.js": 233,
	"./br": 234,
	"./br.js": 234,
	"./bs": 235,
	"./bs.js": 235,
	"./ca": 236,
	"./ca.js": 236,
	"./cs": 237,
	"./cs.js": 237,
	"./cv": 238,
	"./cv.js": 238,
	"./cy": 239,
	"./cy.js": 239,
	"./da": 240,
	"./da.js": 240,
	"./de": 243,
	"./de-at": 241,
	"./de-at.js": 241,
	"./de-ch": 242,
	"./de-ch.js": 242,
	"./de.js": 243,
	"./dv": 244,
	"./dv.js": 244,
	"./el": 245,
	"./el.js": 245,
	"./en-au": 246,
	"./en-au.js": 246,
	"./en-ca": 247,
	"./en-ca.js": 247,
	"./en-gb": 248,
	"./en-gb.js": 248,
	"./en-ie": 249,
	"./en-ie.js": 249,
	"./en-nz": 250,
	"./en-nz.js": 250,
	"./eo": 251,
	"./eo.js": 251,
	"./es": 253,
	"./es-do": 252,
	"./es-do.js": 252,
	"./es.js": 253,
	"./et": 254,
	"./et.js": 254,
	"./eu": 255,
	"./eu.js": 255,
	"./fa": 256,
	"./fa.js": 256,
	"./fi": 257,
	"./fi.js": 257,
	"./fo": 258,
	"./fo.js": 258,
	"./fr": 261,
	"./fr-ca": 259,
	"./fr-ca.js": 259,
	"./fr-ch": 260,
	"./fr-ch.js": 260,
	"./fr.js": 261,
	"./fy": 262,
	"./fy.js": 262,
	"./gd": 263,
	"./gd.js": 263,
	"./gl": 264,
	"./gl.js": 264,
	"./gom-latn": 265,
	"./gom-latn.js": 265,
	"./he": 266,
	"./he.js": 266,
	"./hi": 267,
	"./hi.js": 267,
	"./hr": 268,
	"./hr.js": 268,
	"./hu": 269,
	"./hu.js": 269,
	"./hy-am": 270,
	"./hy-am.js": 270,
	"./id": 271,
	"./id.js": 271,
	"./is": 272,
	"./is.js": 272,
	"./it": 273,
	"./it.js": 273,
	"./ja": 274,
	"./ja.js": 274,
	"./jv": 275,
	"./jv.js": 275,
	"./ka": 276,
	"./ka.js": 276,
	"./kk": 277,
	"./kk.js": 277,
	"./km": 278,
	"./km.js": 278,
	"./kn": 279,
	"./kn.js": 279,
	"./ko": 280,
	"./ko.js": 280,
	"./ky": 281,
	"./ky.js": 281,
	"./lb": 282,
	"./lb.js": 282,
	"./lo": 283,
	"./lo.js": 283,
	"./lt": 284,
	"./lt.js": 284,
	"./lv": 285,
	"./lv.js": 285,
	"./me": 286,
	"./me.js": 286,
	"./mi": 287,
	"./mi.js": 287,
	"./mk": 288,
	"./mk.js": 288,
	"./ml": 289,
	"./ml.js": 289,
	"./mr": 290,
	"./mr.js": 290,
	"./ms": 292,
	"./ms-my": 291,
	"./ms-my.js": 291,
	"./ms.js": 292,
	"./my": 293,
	"./my.js": 293,
	"./nb": 294,
	"./nb.js": 294,
	"./ne": 295,
	"./ne.js": 295,
	"./nl": 297,
	"./nl-be": 296,
	"./nl-be.js": 296,
	"./nl.js": 297,
	"./nn": 298,
	"./nn.js": 298,
	"./pa-in": 299,
	"./pa-in.js": 299,
	"./pl": 300,
	"./pl.js": 300,
	"./pt": 302,
	"./pt-br": 301,
	"./pt-br.js": 301,
	"./pt.js": 302,
	"./ro": 303,
	"./ro.js": 303,
	"./ru": 304,
	"./ru.js": 304,
	"./sd": 305,
	"./sd.js": 305,
	"./se": 306,
	"./se.js": 306,
	"./si": 307,
	"./si.js": 307,
	"./sk": 308,
	"./sk.js": 308,
	"./sl": 309,
	"./sl.js": 309,
	"./sq": 310,
	"./sq.js": 310,
	"./sr": 312,
	"./sr-cyrl": 311,
	"./sr-cyrl.js": 311,
	"./sr.js": 312,
	"./ss": 313,
	"./ss.js": 313,
	"./sv": 314,
	"./sv.js": 314,
	"./sw": 315,
	"./sw.js": 315,
	"./ta": 316,
	"./ta.js": 316,
	"./te": 317,
	"./te.js": 317,
	"./tet": 318,
	"./tet.js": 318,
	"./th": 319,
	"./th.js": 319,
	"./tl-ph": 320,
	"./tl-ph.js": 320,
	"./tlh": 321,
	"./tlh.js": 321,
	"./tr": 322,
	"./tr.js": 322,
	"./tzl": 323,
	"./tzl.js": 323,
	"./tzm": 325,
	"./tzm-latn": 324,
	"./tzm-latn.js": 324,
	"./tzm.js": 325,
	"./uk": 326,
	"./uk.js": 326,
	"./ur": 327,
	"./ur.js": 327,
	"./uz": 329,
	"./uz-latn": 328,
	"./uz-latn.js": 328,
	"./uz.js": 329,
	"./vi": 330,
	"./vi.js": 330,
	"./x-pseudo": 331,
	"./x-pseudo.js": 331,
	"./yo": 332,
	"./yo.js": 332,
	"./zh-cn": 333,
	"./zh-cn.js": 333,
	"./zh-hk": 334,
	"./zh-hk.js": 334,
	"./zh-tw": 335,
	"./zh-tw.js": 335
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 842;

/***/ })
/******/ ]);