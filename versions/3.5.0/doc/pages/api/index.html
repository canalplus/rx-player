<head><meta name="viewport" content="width=device-width, initial-scale=1"><meta charset="utf-8"><link rel="stylesheet" href="../../styles/style.css"/><link rel="stylesheet" href="../../styles/code.css"/><title>Rx-Player API - RxPlayer Documentation</title></head><body><div class="page-wrapper"><div class="sidebar"><div class="sidebar-nav"><a href="../index.html"><span class="nav-icon">üè†</span><span class="nav-text">Home</span></a><a href="../../list.html"><span class="nav-icon">üóé</span><span class="nav-text">Page List</span></a><a href="#"><span class="nav-icon">‚Üë</span><span class="nav-text">Top</span></a></div><div class="toc"><p><a href="#title-Rx-Player%20API">Rx-Player API</a></p>
<ul>
<li><a href="#chapter-Overview">Overview</a></li>
<li><a href="#chapter-Instantiation">Instantiation</a></li>
<li><a href="#chapter-Static%20properties">Static properties</a>
<ul>
<li><a href="#subchapter-version">version</a></li>
<li><a href="#subchapter-ErrorTypes">ErrorTypes</a></li>
<li><a href="#subchapter-ErrorCodes">ErrorCodes</a></li>
<li><a href="#subchapter-LogLevel">LogLevel</a></li>
</ul>
</li>
<li><a href="#chapter-Tools">Tools</a>
<ul>
<li><a href="#subchapter-MediaCapabilitiesProber">MediaCapabilitiesProber</a></li>
</ul>
</li>
<li><a href="#chapter-Methods">Methods</a>
<ul>
<li><a href="#subchapter-loadVideo">loadVideo</a></li>
<li><a href="#subchapter-getVideoElement">getVideoElement</a></li>
<li><a href="#subchapter-getPlayerState">getPlayerState</a></li>
<li><a href="#subchapter-addEventListener">addEventListener</a></li>
<li><a href="#subchapter-removeEventListener">removeEventListener</a></li>
<li><a href="#subchapter-play">play</a></li>
<li><a href="#subchapter-pause">pause</a></li>
<li><a href="#subchapter-stop">stop</a></li>
<li><a href="#subchapter-getPosition">getPosition</a></li>
<li><a href="#subchapter-getWallClockTime">getWallClockTime</a></li>
<li><a href="#subchapter-getVideoDuration">getVideoDuration</a></li>
<li><a href="#subchapter-getVolume">getVolume</a></li>
<li><a href="#subchapter-getError">getError</a></li>
<li><a href="#subchapter-seekTo">seekTo</a></li>
<li><a href="#subchapter-isLive">isLive</a></li>
<li><a href="#subchapter-getUrl">getUrl</a></li>
<li><a href="#subchapter-isFullscreen">isFullscreen</a></li>
<li><a href="#subchapter-getAvailableVideoBitrates">getAvailableVideoBitrates</a></li>
<li><a href="#subchapter-getAvailableAudioBitrates">getAvailableAudioBitrates</a></li>
<li><a href="#subchapter-getVideoBitrate">getVideoBitrate</a></li>
<li><a href="#subchapter-getAudioBitrate">getAudioBitrate</a></li>
<li><a href="#subchapter-getMaxVideoBitrate">getMaxVideoBitrate</a></li>
<li><a href="#subchapter-getMaxAudioBitrate">getMaxAudioBitrate</a></li>
<li><a href="#subchapter-setVideoBitrate">setVideoBitrate</a></li>
<li><a href="#subchapter-setAudioBitrate">setAudioBitrate</a></li>
<li><a href="#subchapter-getManualVideoBitrate">getManualVideoBitrate</a></li>
<li><a href="#subchapter-getManualAudioBitrate">getManualAudioBitrate</a></li>
<li><a href="#subchapter-setMaxVideoBitrate">setMaxVideoBitrate</a></li>
<li><a href="#subchapter-setMaxAudioBitrate">setMaxAudioBitrate</a></li>
<li><a href="#subchapter-setWantedBufferAhead">setWantedBufferAhead</a></li>
<li><a href="#subchapter-getWantedBufferAhead">getWantedBufferAhead</a></li>
<li><a href="#subchapter-setMaxBufferBehind">setMaxBufferBehind</a></li>
<li><a href="#subchapter-getMaxBufferBehind">getMaxBufferBehind</a></li>
<li><a href="#subchapter-setMaxBufferAhead">setMaxBufferAhead</a></li>
<li><a href="#subchapter-getMaxBufferAhead">getMaxBufferAhead</a></li>
<li><a href="#subchapter-setFullscreen">setFullscreen</a></li>
<li><a href="#subchapter-exitFullscreen">exitFullscreen</a></li>
<li><a href="#subchapter-setVolume">setVolume</a></li>
<li><a href="#subchapter-mute">mute</a></li>
<li><a href="#subchapter-unMute">unMute</a></li>
<li><a href="#subchapter-isMute">isMute</a></li>
<li><a href="#subchapter-getAvailableAudioTracks">getAvailableAudioTracks</a></li>
<li><a href="#subchapter-getAvailableTextTracks">getAvailableTextTracks</a></li>
<li><a href="#subchapter-getAudioTrack">getAudioTrack</a></li>
<li><a href="#subchapter-getTextTrack">getTextTrack</a></li>
<li><a href="#subchapter-setAudioTrack">setAudioTrack</a></li>
<li><a href="#subchapter-setTextTrack">setTextTrack</a></li>
<li><a href="#subchapter-disableTextTrack">disableTextTrack</a></li>
<li><a href="#subchapter-getManifest">getManifest</a></li>
<li><a href="#subchapter-getCurrentAdaptations">getCurrentAdaptations</a></li>
<li><a href="#subchapter-getCurrentRepresentations">getCurrentRepresentations</a></li>
<li><a href="#subchapter-dispose">dispose</a></li>
<li><a href="#subchapter-getNativeTextTrack">getNativeTextTrack</a></li>
<li><a href="#subchapter-getVideoLoadedTime">getVideoLoadedTime</a></li>
<li><a href="#subchapter-getVideoPlayedTime">getVideoPlayedTime</a></li>
<li><a href="#subchapter-getVideoBufferGap">getVideoBufferGap</a></li>
<li><a href="#subchapter-getPlaybackRate">getPlaybackRate</a></li>
<li><a href="#subchapter-setPlaybackRate">setPlaybackRate</a></li>
<li><a href="#subchapter-getCurrentKeySystem">getCurrentKeySystem</a></li>
<li><a href="#subchapter-getImageTrackData">getImageTrackData</a></li>
<li><a href="#subchapter-getMinimumPosition">getMinimumPosition</a></li>
<li><a href="#subchapter-getMaximumPosition">getMaximumPosition</a></li>
</ul>
</li>
</ul>
</div></div><div class="content-wrapper"><div class="header"><div class="header-content"><a href="../index.html"><span class="nav-icon">üè†</span><span class="nav-text">Home</span></a><a href="../../list.html"><span class="nav-icon">üóé</span><span class="nav-text">Page List</span></a><a href="#"><span class="nav-icon">‚Üë</span><span class="nav-text">Top</span></a></div></div><div class="content"><html><head></head><body><p><a name="title-Rx-Player%20API"></a></p>
<h1>Rx-Player API</h1>
<p><a name="overview"></a>
<a name="chapter-Overview"></a></p>
<h2>Overview</h2>
<p>The Rx-player has a complete API allowing you to:</p>
<ul>
<li>load and stop streams</li>
<li>perform trickmodes (play, pause, seek, etc.) as a content is loaded.</li>
<li>get multiple informations on the current stream and on the player&#x2019;s state.</li>
<li>choose a specific audio language or subtitles track</li>
<li>set your own bitrate and buffer length</li>
<li>and more</li>
</ul>
<p>The following pages define the entire API.</p>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> Only variables and methods defined here are considered as part of the
API. Any other property or method you might find by using our library can change
without notice (not considered as part of the API).</p>
<p>Only use the documented variables and open an issue if you think it&#x2019;s not
enough.</p>
<p><em>Note: As some terms used here might be too foreign or slightly different than
the one you&#x2019;re used to, we also wrote a list of terms and definitions used by
the RxPlayer <a href="../terms.html">here</a>.</em></p>
<p><a name="instantiation"></a>
<a name="chapter-Instantiation"></a></p>
<h2>Instantiation</h2>
<p>Instantiating a new player is straightforward:</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> RxPlayer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rx-player&quot;</span>;
<span class="hljs-keyword">const</span> player = <span class="hljs-keyword">new</span> RxPlayer(options);
</code></pre>
<p>The options are all&#x2026; optional. They are all defined in the <a href="player_options.html">Player Options
page</a>.</p>
<p><a name="static"></a>
<a name="chapter-Static%20properties"></a></p>
<h2>Static properties</h2>
<p><a name="static-version"></a>
<a name="subchapter-version"></a></p>
<h3>version</h3>
<p><em>type</em>: <code>Number</code></p>
<p>The current version of the RxPlayer.</p>
<p><a name="static-ErrorTypes"></a>
<a name="subchapter-ErrorTypes"></a></p>
<h3>ErrorTypes</h3>
<p><em>type</em>: <code>Object</code></p>
<p>The different &#x201C;types&#x201D; of Error you can get on playback error,</p>
<p>See <a href="errors.html">the Player Error documentation</a> for more informations.</p>
<p><a name="static-ErrorCodes"></a>
<a name="subchapter-ErrorCodes"></a></p>
<h3>ErrorCodes</h3>
<p><em>type</em>: <code>Object</code></p>
<p>The different Error &#x201C;codes&#x201D; you can get on playback error,</p>
<p>See <a href="errors.html">the Player Error documentation</a> for more informations.</p>
<p><a name="static-LogLevel"></a>
<a name="subchapter-LogLevel"></a></p>
<h3>LogLevel</h3>
<p><em>type</em>: <code>string</code></p>
<p><em>default</em>: <code>&quot;NONE&quot;</code></p>
<p>The current level of verbosity for the RxPlayer logs. Those logs all use the
console.</p>
<p>From the less verbose to the most:</p>
<ul>
<li>
<p><code>&quot;NONE&quot;</code>: no log</p>
</li>
<li>
<p><code>&quot;ERROR&quot;</code>: unexpected errors (via <code>console.error</code>)</p>
</li>
<li>
<p><code>&quot;WARNING&quot;</code>: The previous level + minor problems encountered (via
<code>console.warn</code>)</p>
</li>
<li>
<p><code>&quot;INFO&quot;</code>: The previous levels + noteworthy events (via <code>console.info</code>)</p>
</li>
<li>
<p><code>&quot;DEBUG&quot;</code>: The previous levels + normal events of the player (via
<code>console.log</code>)</p>
</li>
</ul>
<p>If the value set to this property is different than those, it will be
automatically set to <code>&quot;NONE&quot;</code>.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">import</span> RxPlayer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rx-player&quot;</span>;
RxPlayer.LogLevel = <span class="hljs-string">&quot;WARNING&quot;</span>;
</code></pre>
<p><a name="tools"></a>
<a name="chapter-Tools"></a></p>
<h2>Tools</h2>
<p><a name="tools-mediaCapabilitiesProber"></a>
<a name="subchapter-MediaCapabilitiesProber"></a></p>
<h3>MediaCapabilitiesProber</h3>
<p><em>type</em>: <code>Object</code></p>
<p>An experimental tool to probe browser media capabilities:</p>
<ul>
<li>Decoding capabilities</li>
<li>DRM support</li>
<li>HDCP support</li>
<li>Display capabilities</li>
</ul>
<p>You can find its documentation <a href="mediaCapabilitiesProber.html">here</a>.</p>
<p><a name="meth"></a>
<a name="chapter-Methods"></a></p>
<h2>Methods</h2>
<p><a name="meth-loadVideo"></a>
<a name="subchapter-loadVideo"></a></p>
<h3>loadVideo</h3>
<p><em>arguments</em>:</p>
<ul>
<li><em>options</em> (<code>Object</code>)</li>
</ul>
<p>Loads a new video described in the argument.</p>
<p>The options possible as arguments are all defined in <a href="loadVideo_options.html">this
page</a>.</p>
<h4>Example</h4>
<pre><code class="language-js">player.loadVideo({
  <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://vm2.dashif.org/livesim-dev/segtimeline_1/testpic_6s/Manifest.mpd&quot;</span>,
  <span class="hljs-attr">transport</span>: <span class="hljs-string">&quot;dash&quot;</span>,
  <span class="hljs-attr">autoPlay</span>: <span class="hljs-literal">true</span>,
});
</code></pre>
<p><a name="meth-getVideoElement"></a>
<a name="subchapter-getVideoElement"></a></p>
<h3>getVideoElement</h3>
<p><em>return value</em>: <code>HTMLMediaElement</code></p>
<p>Returns the video element used by the player.</p>
<p>You&#x2019;re not encouraged to use its API, you should always prefer the Player&#x2019;s API.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> videoElement = player.getVideoElement();
videoElement.className = <span class="hljs-string">&quot;my-video-element&quot;</span>;
</code></pre>
<p><a name="meth-getPlayerState"></a>
<a name="subchapter-getPlayerState"></a></p>
<h3>getPlayerState</h3>
<p><em>return value</em>: <code>string</code></p>
<p>The current player&#x2019;s state.
Can be either one of those strings:</p>
<ul>
<li>
<p><code>&quot;STOPPED&quot;</code>: The player is idle. No content is loading nor is loaded.</p>
</li>
<li>
<p><code>&quot;LOADING&quot;</code>: The player is loading a new content.</p>
</li>
<li>
<p><code>&quot;LOADED&quot;</code>: The player can begin to play a new stream.</p>
</li>
<li>
<p><code>&quot;PLAYING&quot;</code>: The player is currently playing the stream.</p>
</li>
<li>
<p><code>&quot;PAUSED&quot;</code>: The player has paused.</p>
</li>
<li>
<p><code>&quot;ENDED&quot;</code>: The player has reached the end of the stream.</p>
</li>
<li>
<p><code>&quot;BUFFERING&quot;</code>: the player has reached the end of the buffer and is waiting
for data to be appended.</p>
</li>
<li>
<p><code>&quot;SEEKING&quot;</code>: The player has reached the end of the buffer because a seek
has been performed, new segments are being loaded.</p>
</li>
</ul>
<p>State chart:</p>
<pre><code>    +---------+
    | STOPPED | &lt;-------------------+
    +---------+                     | stop() or &quot;error&quot; event
       |                            |
+------| loadVideo() ----------------------------------------------------+
|      |                           +---------------------+               |
|      V                           |                     |               |
|  +---------+     +--------+   play()   +---------+     |    +-------+  |
|  | LOADING | --&gt; | LOADED | -----|---&gt; | PLAYING | ----|--&gt; | ENDED |  |
|  +---------+     +--------+  autoPlay  +---------+     |    +-------+  |
|                                  |         | ^         |               |
|       +-----------+              |         | |         |               |
|       | BUFFERING |  &lt;--------&gt;  |  play() | | pause() |               |
|       +-----------+              |         | |         |               |
|                                  |         | |         |               |
|       +---------+    seekTo()    |         V |         |               |
|       |         |  &lt;-----------  |     +--------+      |               |
|       | SEEKING |                |     | PAUSED |      |               |
|       |         |  -----------&gt;  |     +--------+      |               |
|       +---------+                |                     |               |
|                                  +---------------------+               |
+------------------------------------------------------------------------+
</code></pre>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">switch</span> (player.getPlayerState()) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;STOPPED&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;No content is/will be playing&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;LOADING&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;A new content is currently loading&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;LOADED&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The new content is loaded and ready to be played&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;PLAYING&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The content is currently playing&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;PAUSED&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The content is currently paused&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;BUFFERING&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The content is buffering new data&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;SEEKING&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The content is still seeking, waiting for new data&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ENDED&quot;</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The content has reached the end.&quot;</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;This is impossible (issue material!).&quot;</span>)
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><a name="meth-addEventListener"></a>
<a name="subchapter-addEventListener"></a></p>
<h3>addEventListener</h3>
<p><em>arguments</em>:</p>
<ul>
<li>
<p><em>event</em> (<code>string</code>): The event name.</p>
</li>
<li>
<p><em>callback</em> (<code>Function</code>): The callback for the event.
The same callback may be used again when calling <code>removeEventListener</code>.</p>
</li>
</ul>
<p>Add an event listener to trigger a callback as it happens. The callback will
have the event payload as a single argument.</p>
<p>To have the complete list of player events, consult the <a href="player_events.html">Player events
page</a>.</p>
<h4>Example</h4>
<pre><code class="language-js">player.addEventListener(<span class="hljs-string">&quot;Error&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The player crashed: <span class="hljs-subst">${err.message}</span>`</span>);
});
</code></pre>
<p><a name="meth-removeEventListener"></a>
<a name="subchapter-removeEventListener"></a></p>
<h3>removeEventListener</h3>
<p><em>arguments</em>:</p>
<ul>
<li><em>event</em> (<code>string</code>): The event name.</li>
<li><em>callback</em> (optional) (<code>Function</code>): The callback given when calling the
corresponding <code>addEventListener</code> API.</li>
</ul>
<p>Remove an event listener. That is, stop your registered callback (with
<code>addEventListener</code>) to be called as events happen and free up ressources.</p>
<p>The callback given is optional: if not given, <em>every</em> registered callback to
that event will be removed. That&#x2019;s why using both arguments is recommended for
most usecase.</p>
<h4>Example</h4>
<pre><code class="language-js">player.removeEventListener(<span class="hljs-string">&quot;playerStateChange&quot;</span>, listenerCallback);
</code></pre>
<p><a name="meth-play"></a>
<a name="subchapter-play"></a></p>
<h3>play</h3>
<p>Play/resume the current video. Equivalent to a video element&#x2019;s play method.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> resumeContent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  player.play();
};
</code></pre>
<p><a name="meth-pause"></a>
<a name="subchapter-pause"></a></p>
<h3>pause</h3>
<p>Pause the current video. Equivalent to a video element&#x2019;s pause method.</p>
<p>Note that a content can be paused even if its current state is <code>BUFFERING</code> or
<code>SEEKING</code>.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> pauseContent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  player.pause();
};
</code></pre>
<p><a name="meth-stop"></a>
<a name="subchapter-stop"></a></p>
<h3>stop</h3>
<p>Stop playback of the current content if one.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> stopVideo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  player.stop();
};
</code></pre>
<p><a name="meth-getPosition"></a>
<a name="subchapter-getPosition"></a></p>
<h3>getPosition</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns the video element&#x2019;s current position, in seconds.</p>
<p>The difference with the <code>getWallClockTime</code> method is that for live contents
the position is not re-calculated to match a live timestamp.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> pos = player.getPosition();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The video element&apos;s current position is: <span class="hljs-subst">${pos}</span> second(s)`</span>);
</code></pre>
<p><a name="meth-getWallClockTime"></a>
<a name="subchapter-getWallClockTime"></a></p>
<h3>getWallClockTime</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns the wall-clock-time of the current position in seconds.</p>
<p>That is:</p>
<ul>
<li>for live content, get a timestamp in seconds of the current position.</li>
<li>for static content, returns the position from beginning, also in seconds.</li>
</ul>
<p>Use this method to display the current position to the user.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> wallClockTime = player.getWallClockTime();
<span class="hljs-keyword">const</span> nowInSeconds = <span class="hljs-built_in">Date</span>.now() / <span class="hljs-number">1000</span>;
<span class="hljs-keyword">const</span> delta = nowInSeconds - wallClockTime;

<span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">5</span>) { <span class="hljs-comment">// (5 seconds of margin)</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;You&apos;re playing live&quot;</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`You&apos;re playing <span class="hljs-subst">${delta}</span> seconds behind the live content`</span>);
}
</code></pre>
<p><a name="meth-getVideoDuration"></a>
<a name="subchapter-getVideoDuration"></a></p>
<h3>getVideoDuration</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns the duration of the current video, directly from the video element.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> pos = player.getPosition();
<span class="hljs-keyword">const</span> dur = player.getVideoDuration();

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`current position: <span class="hljs-subst">${pos}</span> / <span class="hljs-subst">${dur}</span>`</span>);
</code></pre>
<p><a name="meth-getVolume"></a>
<a name="subchapter-getVolume"></a></p>
<h3>getVolume</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Current volume of the player, from 0 (no sound) to 1 (maximum sound). 0 if muted
(different than videoElement.muted).</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> volume = player.getVolume();

<span class="hljs-keyword">if</span> (volume === <span class="hljs-number">1</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;You&apos;re playing at maximum volume&quot;</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (volume === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;You&apos;re playing at no volume&quot;</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (volume &gt; <span class="hljs-number">0.5</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;You&apos;re playing at a high volume&quot;</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;You&apos;re playing at a low volume&quot;</span>);
}
</code></pre>
<p><a name="meth-getError"></a>
<a name="subchapter-getError"></a></p>
<h3>getError</h3>
<p><em>return value</em>: <code>Error|null</code></p>
<p>Returns the fatal error if it happened. null otherwise.</p>
<p>See <a href="errors.html">the Player Error documentation</a> for more informations.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> error = player.getError();

<span class="hljs-keyword">if</span> (!error) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The player did not crash&quot;</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.code === <span class="hljs-string">&quot;PIPELINE_LOAD_ERROR&quot;</span>) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;The player crashed due to a failing request&quot;</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`The player crashed: <span class="hljs-subst">${error.code}</span>`</span>);
}
</code></pre>
<p><a name="meth-seekTo"></a>
<a name="subchapter-seekTo"></a></p>
<h3>seekTo</h3>
<p><em>arguments</em>: <code>Object|Number</code></p>
<p>Seek in the current content.</p>
<p>The argument can be an object with a single <code>Number</code> property, either:</p>
<ul>
<li>
<p><code>relative</code>: seek relatively to the current position</p>
</li>
<li>
<p><code>position</code>: seek to the given absolute position (equivalent to
<code>player.getVideoElement().currentTime = newPosition</code>)</p>
</li>
<li>
<p><code>wallClockTime</code>: seek to the given wallClock position, as returned by
<code>getWallClockTime</code>.</p>
</li>
</ul>
<p>The argument can also just be a <code>Number</code> property, which will have the same
effect than the <code>position</code> property (absolute position).</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-comment">// seeking to 54 seconds from the start of the content</span>
player.seekTo({ <span class="hljs-attr">position</span>: <span class="hljs-number">54</span> });

<span class="hljs-comment">// equivalent to just:</span>
player.seekTo(<span class="hljs-number">54</span>);

<span class="hljs-comment">// seeking 5 seconds after the current position</span>
player.seekTo({ <span class="hljs-attr">relative</span>: <span class="hljs-number">5</span> });

<span class="hljs-comment">// seeking 5 seconds before the current position</span>
player.seekTo({ <span class="hljs-attr">relative</span>: <span class="hljs-number">-5</span> });

<span class="hljs-comment">// seeking to live content</span>
player.seekTo({ <span class="hljs-attr">wallClockTime</span>: <span class="hljs-built_in">Date</span>.now() / <span class="hljs-number">1000</span> });
</code></pre>
<p><a name="meth-isLive"></a>
<a name="subchapter-isLive"></a></p>
<h3>isLive</h3>
<p><em>return value</em>: <code>Boolean</code></p>
<p>Returns <code>true</code> if the content is &#x201C;live&#x201D;. <code>false</code> otherwise.</p>
<p>Also <code>false</code> if no content is loaded yet.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (player.isLive()) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;We&apos;re playing a live content&quot;</span>);
}
</code></pre>
<p><a name="meth-getUrl"></a>
<a name="subchapter-getUrl"></a></p>
<h3>getUrl</h3>
<p><em>return value</em>: <code>string|undefined</code></p>
<p>Returns the URL of the downloaded manifest.</p>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns the URL of the content
being played.</p>
<p>Returns <code>undefined</code> if no content is loaded yet.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> url = player.getUrl();
<span class="hljs-keyword">if</span> (url) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;We are playing the following content:&quot;</span>, url);
}
</code></pre>
<p><a name="meth-isFullscreen"></a>
<a name="subchapter-isFullscreen"></a></p>
<h3>isFullscreen</h3>
<p><em>return value</em>: <code>Boolean</code></p>
<p>Returns <code>true</code> if the video element is in fullscreen mode, <code>false</code>
otherwise.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (player.isFullscreen()) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The player is in fullscreen mode&quot;</span>);
}
</code></pre>
<p><a name="meth-getAvailableVideoBitrates"></a>
<a name="subchapter-getAvailableVideoBitrates"></a></p>
<h3>getAvailableVideoBitrates</h3>
<p><em>return value</em>: <code>Array.&lt;Number&gt;</code></p>
<p>The different bitrates available for the current video adaptation, in bits per
seconds.</p>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns an empty Array.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> videoBitrates = player.getAvailableVideoBitrates();
<span class="hljs-keyword">if</span> (videoBitrates.length) {
  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">&quot;The current video is available in the following bitrates&quot;</span>,
    videoBitrates.join(<span class="hljs-string">&quot;, &quot;</span>)
  );
}
</code></pre>
<p><a name="meth-getAvailableAudioBitrates"></a>
<a name="subchapter-getAvailableAudioBitrates"></a></p>
<h3>getAvailableAudioBitrates</h3>
<p><em>return value</em>: <code>Array.&lt;Number&gt;</code></p>
<p>The different bitrates available for the current audio adaptation, in bits per
seconds.</p>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns an empty Array.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> audioBitrates = player.getAvailableAudioBitrates();
<span class="hljs-keyword">if</span> (audioBitrates.length) {
  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">&quot;The current audio is available in the following bitrates&quot;</span>,
    audioBitrates.join(<span class="hljs-string">&quot;, &quot;</span>)
  );
}
</code></pre>
<p><a name="meth-getVideoBitrate"></a>
<a name="subchapter-getVideoBitrate"></a></p>
<h3>getVideoBitrate</h3>
<p><em>return value</em>: <code>Number|undefined</code></p>
<p>Returns the video bitrate of the last downloaded video segment, in bits per
seconds.</p>
<p>Returns <code>undefined</code> if no content is loaded.</p>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns <code>undefined</code>.</p>
<p><a name="meth-getAudioBitrate"></a>
<a name="subchapter-getAudioBitrate"></a></p>
<h3>getAudioBitrate</h3>
<p><em>return value</em>: <code>Number|undefined</code></p>
<p>Returns the audio bitrate of the last downloaded audio segment, in bits per
seconds.</p>
<p>Returns <code>undefined</code> if no content is loaded.</p>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns <code>undefined</code>.</p>
<p><a name="meth-getMaxVideoBitrate"></a>
<a name="subchapter-getMaxVideoBitrate"></a></p>
<h3>getMaxVideoBitrate</h3>
<p><em>return value</em>: <code>Number|undefined</code></p>
<p>Returns the maximum set video bitrate to which switching is possible, in bits
per seconds.</p>
<p>This only affects adaptive strategies (you can bypass this limit by calling
<code>setVideoBitrate</code>), and is set to <code>Infinity</code> when no limit has been set.</p>
<p><a name="meth-getMaxAudioBitrate"></a>
<a name="subchapter-getMaxAudioBitrate"></a></p>
<h3>getMaxAudioBitrate</h3>
<p><em>return value</em>: <code>Number&quot;undefined</code></p>
<p>Returns the maximum set audio bitrate to which switching is possible, in bits
per seconds.</p>
<p>This only affects adaptive strategies (you can bypass this limit by calling
<code>setAudioBitrate</code>), and is set to <code>Infinity</code> when no limit has been set.</p>
<p><a name="meth-setVideoBitrate"></a>
<a name="subchapter-setVideoBitrate"></a></p>
<h3>setVideoBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Force the current video track to be of a certain bitrate.</p>
<p>If a video representation is found with the exact same bitrate, this
representation will be set.</p>
<p>If no video representation is found with the exact same bitrate, either:</p>
<ul>
<li>
<p>the video representation immediately inferior to it will be chosen instead
(the closest inferior)</p>
</li>
<li>
<p>if no video representation has a bitrate lower than that value, the video
representation with the lowest bitrate will be chosen instead.</p>
</li>
</ul>
<p>Set to <code>-1</code> to deactivate (and thus re-activate adaptive streaming for video
tracks).</p>
<p>When active (called with a positive value), adaptive streaming for video tracks
will be disabled to stay in the chosen representation.</p>
<p>You can use <code>getAvailableVideoBitrates</code> to get the list of available bitrates
you can set on the current content.</p>
<p>Note that the value set is persistent between <code>loadVideo</code> calls.
As such, this method can also be called when no content is playing (the same
rules apply for future contents).</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-setAudioBitrate"></a>
<a name="subchapter-setAudioBitrate"></a></p>
<h3>setAudioBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Force the current audio track to be of a certain bitrate.</p>
<p>If an audio representation (in the current audio adaptation) is found with the
exact same bitrate, this representation will be set.</p>
<p>If no audio representation is found with the exact same bitrate, either:</p>
<ul>
<li>
<p>the audio representation immediately inferior to it will be chosen instead
(the closest inferior)</p>
</li>
<li>
<p>if no audio representation has a bitrate lower than that value, the audio
representation with the lowest bitrate will be chosen instead.</p>
</li>
</ul>
<p>Set to <code>-1</code> to deactivate (and thus re-activate adaptive streaming for audio
tracks).</p>
<p>When active (called with a positive value), adaptive streaming for audio tracks
will be disabled to stay in the chosen representation.</p>
<p>You can use <code>getAvailableAudioBitrates</code> to get the list of available bitrates
you can set on the current content.</p>
<p>Note that the value set is persistent between <code>loadVideo</code> calls.
As such, this method can also be called when no content is playing (the same
rules apply for future contents).</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-getManualVideoBitrate"></a>
<a name="subchapter-getManualVideoBitrate"></a></p>
<h3>getManualVideoBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Get the last video bitrate manually set. Either via <code>setVideoBitrate</code> or via
the <code>initialVideoBitrate</code> constructor option.</p>
<p>This value can be different than the one returned by <code>getVideoBitrate</code>:</p>
<ul>
<li><code>getManualVideoBitrate</code> returns the last bitrate set manually by the user</li>
<li><code>getVideoBitrate</code> returns the actual bitrate of the current video track</li>
</ul>
<p><code>-1</code> when no video bitrate is forced.</p>
<p><a name="meth-getManualAudioBitrate"></a>
<a name="subchapter-getManualAudioBitrate"></a></p>
<h3>getManualAudioBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Get the last audio bitrate manually set. Either via <code>setAudioBitrate</code> or via
the <code>initialAudioBitrate</code> constructor option.</p>
<p>This value can be different than the one returned by <code>getAudioBitrate</code>:</p>
<ul>
<li><code>getManualAudioBitrate</code> returns the last bitrate set manually by the user</li>
<li><code>getAudioBitrate</code> returns the actual bitrate of the current audio track</li>
</ul>
<p><code>-1</code> when no audio bitrate is forced.</p>
<p><a name="meth-setMaxVideoBitrate"></a>
<a name="subchapter-setMaxVideoBitrate"></a></p>
<h3>setMaxVideoBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the maximum video bitrate reachable through adaptive streaming. The player
will never automatically switch to a video representation with a higher bitrate.</p>
<p>This limit can be removed by setting it to <code>Infinity</code>:</p>
<pre><code class="language-js"><span class="hljs-comment">// remove video bitrate limit</span>
player.setMaxVideoBitrate(<span class="hljs-literal">Infinity</span>);
</code></pre>
<p>This only affects adaptive strategies (you can bypass this limit by calling
<code>setVideoBitrate</code>).</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-setMaxAudioBitrate"></a>
<a name="subchapter-setMaxAudioBitrate"></a></p>
<h3>setMaxAudioBitrate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the maximum audio bitrate reachable through adaptive streaming. The player
will never automatically switch to a audio representation with a higher bitrate.</p>
<p>This limit can be removed by setting it to <code>Infinity</code>:</p>
<pre><code class="language-js"><span class="hljs-comment">// remove audio bitrate limit</span>
player.setMaxAudioBitrate(<span class="hljs-literal">Infinity</span>);
</code></pre>
<p>This only affects adaptive strategies (you can bypass this limit by calling
<code>setAudioBitrate</code>).</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-setWantedBufferAhead"></a>
<a name="subchapter-setWantedBufferAhead"></a></p>
<h3>setWantedBufferAhead</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the buffering goal, as a duration ahead of the current position, in seconds.
Once this size of buffer reached, the player won&#x2019;t try to download new video
segments anymore.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-getWantedBufferAhead"></a>
<a name="subchapter-getWantedBufferAhead"></a></p>
<h3>getWantedBufferAhead</h3>
<p><em>return value</em>: <code>Number</code>
<em>defaults</em>: <code>30</code></p>
<p>returns the buffering goal, as a duration ahead of the current position, in
seconds.</p>
<p><a name="meth-setMaxBufferBehind"></a>
<a name="subchapter-setMaxBufferBehind"></a></p>
<h3>setMaxBufferBehind</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the maximum kept past buffer, in seconds.
Everything before that limit (<code>currentPosition - maxBufferBehind</code>) will be
automatically garbage collected.</p>
<p>This feature is not necessary as the browser is already supposed to deallocate
memory from old segments if/when the memory is scarce.</p>
<p>However on some custom targets, or just to better control the memory imprint
of the player, you might want to set this limit. You can set it to
<code>Infinity</code> to remove any limit and just let the browser do this job.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-getMaxBufferBehind"></a>
<a name="subchapter-getMaxBufferBehind"></a></p>
<h3>getMaxBufferBehind</h3>
<p><em>return value</em>: <code>Number</code>
<em>defaults</em>: <code>Infinity</code></p>
<p>Returns the maximum kept past buffer, in seconds.</p>
<p><a name="meth-setMaxBufferAhead"></a>
<a name="subchapter-setMaxBufferAhead"></a></p>
<h3>setMaxBufferAhead</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the maximum kept buffer ahead of the current position, in seconds.
Everything superior to that limit (<code>currentPosition + maxBufferAhead</code>) will
be automatically garbage collected. This feature is not necessary as
the browser is already supposed to deallocate memory from old segments if/when
the memory is scarce.</p>
<p>However on some custom targets, or just to better control the memory imprint of
the player, you might want to set this limit. You can set it to <code>Infinity</code> to
remove any limit and just let the browser do this job.</p>
<p>The minimum value between this one and the one returned by
<code>getWantedBufferAhead</code> will be considered when downloading new segments.</p>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> Bear in mind that a too-low configuration there (e.g. inferior to
<code>10</code>) might prevent the browser to play the content at all.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-getMaxBufferAhead"></a>
<a name="subchapter-getMaxBufferAhead"></a></p>
<h3>getMaxBufferAhead</h3>
<p><em>return value</em>: <code>Number</code>
<em>defaults</em>: <code>Infinity</code></p>
<p>Returns the maximum kept buffer ahead of the current position, in seconds.</p>
<p><a name="meth-setFullscreen"></a>
<a name="subchapter-setFullscreen"></a></p>
<h3>setFullscreen</h3>
<p><em>arguments</em>: <code>Boolean</code></p>
<p>Switch or exit the <code>&lt;video&gt;</code> element to fullscreen mode. The argument is an
optional boolean:</p>
<ul>
<li>
<p>if set:</p>
<ul>
<li><code>true</code>: enters fullscreen</li>
<li><code>false</code>: exit fullscreen</li>
</ul>
</li>
<li>
<p>if not set: enter fullscreen</p>
</li>
</ul>
<p>Note that <strong>only the video element will be set to fullscreen mode</strong>. You might
prefer to implement your own method to include your controls in the final UI.</p>
<p><a name="meth-exitFullscreen"></a>
<a name="subchapter-exitFullscreen"></a></p>
<h3>exitFullscreen</h3>
<p>Exit fullscreen mode. Same than <code>setFullscreen(false)</code>.</p>
<p><a name="meth-setVolume"></a>
<a name="subchapter-setVolume"></a></p>
<h3>setVolume</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Set the new volume, from 0 (no sound) to 1 (the maximum sound level).</p>
<p><a name="meth-mute"></a>
<a name="subchapter-mute"></a></p>
<h3>mute</h3>
<p>Cut the volume. Basically set the volume to 0 while keeping in memory the
previous volume.</p>
<p><a name="meth-unMute"></a>
<a name="subchapter-unMute"></a></p>
<h3>unMute</h3>
<p>Restore the volume when it has been muted, to the one previous the <code>mute</code>
call.</p>
<p><a name="meth-isMute"></a>
<a name="subchapter-isMute"></a></p>
<h3>isMute</h3>
<p><em>returns</em>: <code>Boolean</code></p>
<p>Returns true if the volume is muted i.e., set to 0.</p>
<p><a name="meth-getAvailableAudioTracks"></a>
<a name="subchapter-getAvailableAudioTracks"></a></p>
<h3>getAvailableAudioTracks</h3>
<p><em>returns</em>: <code>Array.&lt;Object&gt;</code></p>
<p>Returns the list of available audio tracks for the current content.</p>
<p>Each of the objects in the returned array have the following properties:</p>
<ul>
<li>
<p><code>id</code> (<code>Number|string</code>): The id used to identify the track. Use it for
setting the track via <code>setAudioTrack</code>.</p>
</li>
<li>
<p><code>language</code> (<code>string</code>): The language the audio track is in, as set in
the manifest.</p>
</li>
<li>
<p><code>normalized</code> (<code>string</code>): An attempt to translate the <code>language</code>
property into an ISO 639-3 language code (for now only support translations
from ISO 639-1 and ISO 639-2 language codes). If the translation attempt
fails (no corresponding ISO 639-3 language code is found), it will equal the
value of <code>language</code></p>
</li>
<li>
<p><code>audioDescription</code> (<code>Boolean</code>): Whether the track is an audio
description (for the visually impaired or not).</p>
</li>
<li>
<p><code>active</code> (<code>Boolean</code>): Whether the track is the one currently active or
not.</p>
</li>
</ul>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns an empty Array.</p>
<p><a name="meth-getAvailableTextTracks"></a>
<a name="subchapter-getAvailableTextTracks"></a></p>
<h3>getAvailableTextTracks</h3>
<p><em>returns</em>: <code>Array.&lt;Object&gt;</code></p>
<p>Returns the list of available text tracks (subtitles) for the current content.</p>
<p>Each of the objects in the returned array have the following properties:</p>
<ul>
<li>
<p><code>id</code> (<code>Number|string</code>): The id used to identify the track. Use it for
setting the track via <code>setTextTrack</code>.</p>
</li>
<li>
<p><code>language</code> (<code>string</code>): The language the text track is in, as set in the
manifest.</p>
</li>
<li>
<p><code>normalized</code> (<code>string</code>): An attempt to translate the <code>language</code>
property into an ISO 639-3 language code (for now only support translations
from ISO 639-1 and ISO 639-2 language codes). If the translation attempt
fails (no corresponding ISO 639-3 language code is found), it will equal the
value of <code>language</code></p>
</li>
<li>
<p><code>closedCaption</code> (<code>Boolean</code>): Whether the track is specially adapted for
the hard of hearing or not.</p>
</li>
<li>
<p><code>active</code> (<code>Boolean</code>): Whether the track is the one currently active or
not.</p>
</li>
</ul>
<p>In <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>), returns an empty Array.</p>
<p><a name="meth-getAudioTrack"></a>
<a name="subchapter-getAudioTrack"></a></p>
<h3>getAudioTrack</h3>
<p><em>returns</em>: <code>Object|null|undefined</code></p>
<p>Get the audio track currently set. <code>null</code> if no audio track is enabled right
now.</p>
<p>The track is an object with the following properties:</p>
<ul>
<li>
<p><code>id</code> (<code>Number|string</code>): The id used to identify the track. Use it for
setting the track via <code>setAudioTrack</code>.</p>
</li>
<li>
<p><code>language</code> (<code>string</code>): The language the audio track is in, as set in the
manifest.</p>
</li>
<li>
<p><code>normalized</code> (<code>string</code>): An attempt to translate the <code>language</code>
property into an ISO 639-3 language code (for now only support translations
from ISO 639-1 and ISO 639-3 language codes). If the translation attempt
fails (no corresponding ISO 639-3 language code is found), it will equal the
value of <code>language</code></p>
</li>
<li>
<p><code>audioDescription</code> (<code>Boolean</code>): Whether the track is an audio
description (for the visually impaired or not).</p>
</li>
</ul>
<p><code>undefined</code> if no content has been loaded yet.</p>
<p><code>undefined</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p><a name="meth-getTextTrack"></a>
<a name="subchapter-getTextTrack"></a></p>
<h3>getTextTrack</h3>
<p><em>returns</em>: <code>Object|null</code></p>
<p>Get the audio track currently set. <code>null</code> if no text track is enabled right
now.</p>
<p>The track is an object with the following properties:</p>
<ul>
<li>
<p><code>id</code> (<code>Number|string</code>): The id used to identify the track. Use it for
setting the track via <code>setTextTrack</code>.</p>
</li>
<li>
<p><code>language</code> (<code>string</code>): The language the text track is in, as set in the
manifest.</p>
</li>
<li>
<p><code>normalized</code> (<code>string</code>): An attempt to translate the <code>language</code>
property into an ISO 639-3 language code (for now only support translations
from ISO 639-1 and ISO 639-3 language codes). If the translation attempt
fails (no corresponding ISO 639-3 language code is found), it will equal the
value of <code>language</code></p>
</li>
<li>
<p><code>closedCaption</code> (<code>Boolean</code>): Whether the track is specially adapted for
the hard of hearing or not.</p>
</li>
</ul>
<p><code>undefined</code> if no content has been loaded yet.</p>
<p><code>undefined</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p><a name="meth-setAudioTrack"></a>
<a name="subchapter-setAudioTrack"></a></p>
<h3>setAudioTrack</h3>
<p><em>arguments</em>: <code>string|Number</code></p>
<p>Set a new audio track from its id, recuperated from <code>getAvailableAudioTracks</code>.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-setTextTrack"></a>
<a name="subchapter-setTextTrack"></a></p>
<h3>setTextTrack</h3>
<p><em>arguments</em>: <code>string</code></p>
<p>Set a new text track from its id, recuperated from <code>getAvailableTextTracks</code>.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-disableTextTrack"></a>
<a name="subchapter-disableTextTrack"></a></p>
<h3>disableTextTrack</h3>
<p>Deactivate the current text track, if one.</p>
<hr>
<p><span class="emoji emoji_warning">&#x26A0;&#xFE0F;</span> This option will have no effect for contents loaded in <em>DirectFile</em>
mode (see <a href="loadVideo_options.html#prop-transport">loadVideo options</a>).</p>
<hr>
<p><a name="meth-getManifest"></a>
<a name="subchapter-getManifest"></a></p>
<h3>getManifest</h3>
<p><em>return value</em>: <code>Manifest|null</code></p>
<p>Returns the current loaded Manifest if one. A manifest object structure is
relatively complex and is described in the <a href="manifest.html">Manifest Object structure
page</a>.</p>
<p><code>null</code> if the player is either stopped or not loaded.</p>
<p><code>null</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p>The manifest will be available before the player reaches the <code>&quot;LOADED&quot;</code> state.</p>
<p><a name="meth-getCurrentAdaptations"></a>
<a name="subchapter-getCurrentAdaptations"></a></p>
<h3>getCurrentAdaptations</h3>
<p><em>return value</em>: <code>Object|null</code></p>
<p>Returns the Adaptations being loaded per type if a manifest is loaded. The
returned object will have at most a key for each type (&#x201C;video&#x201D;, &#x201C;audio&#x201D;, &#x201C;text&#x201D;
and &#x201C;image&#x201D;) which will each contain an array of Adaptation Objects.</p>
<p>An Adaptation object structure is relatively complex and is described in the
<a href="manifest.html#adaptation">Manifest Object structure page</a>.</p>
<p><code>null</code> if the current Adaptations are not known yet.</p>
<p><code>null</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p><a name="meth-getCurrentRepresentations"></a>
<a name="subchapter-getCurrentRepresentations"></a></p>
<h3>getCurrentRepresentations</h3>
<p><em>return value</em>: <code>Object|null</code></p>
<p>Returns the Representations being loaded per type if a manifest is loaded. The
returned object will have at most a key for each type (&#x201C;video&#x201D;, &#x201C;audio&#x201D;, &#x201C;text&#x201D;
and &#x201C;image&#x201D;) which will each contain an array of Representation Objects.</p>
<p>An Representation object structure is relatively complex and is described in the
<a href="manifest.html#representation">Manifest Object structure page</a>.</p>
<p><code>null</code> if the current Representations are not known yet.</p>
<p><code>null</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p><a name="meth-dispose"></a>
<a name="subchapter-dispose"></a></p>
<h3>dispose</h3>
<p>Free the ressources used by the player.</p>
<p>!warning!: The player won&#x2019;t work correctly after calling this method.</p>
<p><a name="meth-getNativeTextTrack"></a>
<a name="subchapter-getNativeTextTrack"></a></p>
<h3>getNativeTextTrack</h3>
<p><em>return value</em>: <code>TextTrack|null</code></p>
<p>Returns the first text track of the video&#x2019;s element, null if none.</p>
<p>This is equivalent to:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> el = player.getVideoElement();
<span class="hljs-keyword">const</span> textTrack = el.textTracks.length ? el.textTracks[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;
</code></pre>
<p><a name="meth-getVideoLoadedTime"></a>
<a name="subchapter-getVideoLoadedTime"></a></p>
<h3>getVideoLoadedTime</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns in seconds the difference between:</p>
<ul>
<li>the start of the current contiguous loaded range.</li>
<li>the end of it.</li>
</ul>
<p><a name="meth-getVideoPlayedTime"></a>
<a name="subchapter-getVideoPlayedTime"></a></p>
<h3>getVideoPlayedTime</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns in seconds the difference between:</p>
<ul>
<li>the start of the current contiguous loaded range.</li>
<li>the current time.</li>
</ul>
<p><a name="meth-getVideoBufferGap"></a>
<a name="subchapter-getVideoBufferGap"></a></p>
<h3>getVideoBufferGap</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns in seconds the difference between:</p>
<ul>
<li>the current time.</li>
<li>the end of the current contiguous loaded range.</li>
</ul>
<p><a name="meth-getPlaybackRate"></a>
<a name="subchapter-getPlaybackRate"></a></p>
<h3>getPlaybackRate</h3>
<p><em>return value</em>: <code>Number</code></p>
<p>Returns the current video normal playback rate (speed when playing). <code>1</code> for
normal playback, <code>2</code> when playing *2, etc.</p>
<p><a name="meth-setPlaybackRate"></a>
<a name="subchapter-setPlaybackRate"></a></p>
<h3>setPlaybackRate</h3>
<p><em>arguments</em>: <code>Number</code></p>
<p>Updates the &#x201C;normal&#x201D; (when playing) playback rate for the video.</p>
<p><a name="meth-getCurrentKeySystem"></a>
<a name="subchapter-getCurrentKeySystem"></a></p>
<h3>getCurrentKeySystem</h3>
<p><em>return value</em>: <code>string|undefined</code></p>
<p>Returns the type of keySystem used for DRM-protected contents.</p>
<p><a name="meth-getImageTrackData"></a>
<a name="subchapter-getImageTrackData"></a></p>
<h3>getImageTrackData</h3>
<p><em>return value</em>: <code>Array.&lt;Object&gt;|null</code></p>
<p>The current image track&#x2019;s data, null if no content is loaded / no image track
data is available.</p>
<p>The returned array follows the usual image playlist structure, defined
<a href="images.html#api-structure">here</a>.</p>
<p><code>null</code> in <em>DirectFile</em> mode (see <a href="loadVideo_options.html#prop-transport">loadVideo
options</a>).</p>
<p><a name="meth-getMinimumPosition"></a>
<a name="subchapter-getMinimumPosition"></a></p>
<h3>getMinimumPosition</h3>
<p><em>return value</em>: <code>Number|null</code></p>
<p>The minimum seekable player position. <code>null</code> if no content is loaded.</p>
<p>This is useful for live contents, where server-side buffer size are often not
infinite. This method allows thus to seek at the earliest possible time.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-comment">// seeking to the earliest position possible (beginning of the buffer for live</span>
<span class="hljs-comment">// contents, position &apos;0&apos; for non-live contents).</span>
player.seekTo({
  <span class="hljs-attr">position</span>: player.getMinimumPosition()
});
</code></pre>
<p><a name="meth-getMaximumPosition"></a>
<a name="subchapter-getMaximumPosition"></a></p>
<h3>getMaximumPosition</h3>
<p><em>return value</em>: <code>Number|null</code></p>
<p>The maximum seekable player position. <code>null</code> if no content is loaded.</p>
<p>This is useful for live contents, where the buffer end updates continously.
This method allows thus to seek directly at the live edge of the content.</p>
<h4>Example</h4>
<pre><code class="language-js"><span class="hljs-comment">// seeking to the end</span>
player.seekTo({
  <span class="hljs-attr">position</span>: player.getMaximumPosition()
});
</code></pre>
</body></html></div></div></div></body>