(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 215);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(40);

// CONCATENATED MODULE: ./src/utils/logger.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_LOG_LEVEL = "NONE";
/**
 * Logger implementation.
 * @class Logger
 */

var logger_Logger = /*#__PURE__*/function () {
  function Logger() {
    this.error = noop["a" /* default */];
    this.warn = noop["a" /* default */];
    this.info = noop["a" /* default */];
    this.debug = noop["a" /* default */];
    this.LEVELS = {
      NONE: 0,
      ERROR: 1,
      WARNING: 2,
      INFO: 3,
      DEBUG: 4
    };
    this.currentLevel = DEFAULT_LOG_LEVEL;
  }
  /**
   * @param {string} levelStr
   */


  var _proto = Logger.prototype;

  _proto.setLevel = function setLevel(levelStr) {
    var level;
    var foundLevel = this.LEVELS[levelStr];

    if (typeof foundLevel === "number") {
      level = foundLevel;
      this.currentLevel = levelStr;
    } else {
      // not found
      level = 0;
      this.currentLevel = "NONE";
    }
    /* tslint:disable no-invalid-this */

    /* tslint:disable no-console */


    this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop["a" /* default */];
    this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop["a" /* default */];
    this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop["a" /* default */];
    this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop["a" /* default */];
    /* tslint:enable no-console */

    /* tslint:enable no-invalid-this */
  }
  /**
   * @returns {string}
   */
  ;

  _proto.getLevel = function getLevel() {
    return this.currentLevel;
  };

  return Logger;
}();


// CONCATENATED MODULE: ./src/log.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 // create a logger specifically for the RxPlayer.

var logger = new logger_Logger();
/* harmony default export */ var log = __webpack_exports__["a"] = (logger);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return be2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return be3toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return be4toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return be8toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return le2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return le4toi; });
/* unused harmony export le8toi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return itobe2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return itobe4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return itobe8; });
/* unused harmony export itole2 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return itole4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isABEqualBytes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */
function concat() {
  var l = arguments.length;
  var i = -1;
  var len = 0;
  var arg;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];
    len += typeof arg === "number" ? arg : arg.length;
  }

  var arr = new Uint8Array(len);
  var offset = 0;
  i = -1;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof arg === "number") {
      offset += arg;
    } else if (arg.length > 0) {
      arr.set(arg, offset);
      offset += arg.length;
    }
  }

  return arr;
}
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be2toi(bytes, offset) {
  return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
}
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be3toi(bytes, offset) {
  return bytes[offset + 0] * 0x0010000 + bytes[offset + 1] * 0x0000100 + bytes[offset + 2];
}
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be4toi(bytes, offset) {
  return bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3];
}
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be8toi(bytes, offset) {
  return (bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3]) * 0x100000000 + bytes[offset + 4] * 0x1000000 + bytes[offset + 5] * 0x0010000 + bytes[offset + 6] * 0x0000100 + bytes[offset + 7];
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe2(num) {
  return new Uint8Array([num >>> 8 & 0xFF, num & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe4(num) {
  return new Uint8Array([num >>> 24 & 0xFF, num >>> 16 & 0xFF, num >>> 8 & 0xFF, num & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h >>> 24 & 0xFF, h >>> 16 & 0xFF, h >>> 8 & 0xFF, h & 0xFF, l >>> 24 & 0xFF, l >>> 16 & 0xFF, l >>> 8 & 0xFF, l & 0xFF]);
}
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le2toi(bytes, offset) {
  return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
}
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le4toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000;
}
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le8toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000 + (bytes[offset + 4] + bytes[offset + 5] * 0x0000100 + bytes[offset + 6] * 0x0010000 + bytes[offset + 7] * 0x1000000) * 0x100000000;
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itole2(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itole4(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF, num >>> 16 & 0xFF, num >>> 24 & 0xFF]);
}
/**
 * Check if an ArrayBuffer is equal to the bytes given.
 * @param {ArrayBuffer} buffer
 * @param {Uint8Array} bytes
 * @returns {Boolean}
 */


function isABEqualBytes(buffer, bytes) {
  var view = new DataView(buffer);
  var len = view.byteLength;

  if (len !== bytes.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (view.getUint8(i) !== bytes[i]) {
      return false;
    }
  }

  return true;
}



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNonEmptyString; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {*} x
 * @returns {string}
 */
function isNonEmptyString(x) {
  return typeof x === "string" && x.length > 0;
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNullOrUndefined; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the argument given is either null or undefined.
 * This function was added to have a clearer alternative to `== null` which is
 * not always understood by newcomers to the code, and which can be overused when
 * only one of the possibility can arise.
 * @param {*} x
 * @returns {*}
 */
function isNullOrUndefined(x) {
  return x === null || x === undefined;
}

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
  /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
  DEFAULT_UNMUTED_VOLUME: 0.1,

  /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
  DEFAULT_REQUEST_TIMEOUT: 30 * 1000,

  /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
  DEFAULT_TEXT_TRACK_MODE: "native",

  /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
  DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",

  /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
  DEFAULT_AUTO_PLAY: false,

  /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
  DEFAULT_SHOW_NATIVE_SUBTITLE: true,

  /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
  DEFAULT_STOP_AT_END: true,

  /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
  DEFAULT_WANTED_BUFFER_AHEAD: 30,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_AHEAD: Infinity,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_BEHIND: Infinity,

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_AHEAD: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_BEHIND: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
  DEFAULT_INITIAL_BITRATES: {
    audio: 0,
    video: 0,
    other: 0
  },

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MAX_BITRATES: {
    audio: Infinity,
    video: Infinity,
    other: Infinity
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
  INACTIVITY_DELAY: 60 * 1000,

  /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_WHEN_HIDDEN: false,

  /**
   * If true, if the video is considered in a "hidden" state for a delay specified by
   * the INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,

  /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
  DEFAULT_LIMIT_VIDEO_WIDTH: false,

  /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
  DEFAULT_LIVE_GAP: {
    DEFAULT: 10,
    LOW_LATENCY: 3
  },

  /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
  BUFFER_DISCONTINUITY_THRESHOLD: 1,

  /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
  BITRATE_REBUFFERING_RATIO: 1.5,

  /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
  BUFFER_GC_GAPS: {
    /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
    CALM: 240,

    /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
    BEEFY: 30
  },

  /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,

  /**
   * The default number of times a segment request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,

  /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE: Infinity,

  /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  INITIAL_BACKOFF_DELAY_BASE: {
    REGULAR: 200,
    LOW_LATENCY: 50
  },

  /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  MAX_BACKOFF_DELAY_BASE: {
    REGULAR: 3000,
    LOW_LATENCY: 1000
  },

  /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock used to regularly check which segments should be loaded
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
  SAMPLING_INTERVAL_MEDIASOURCE: 1000,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
   * @type {Number}
   */
  SAMPLING_INTERVAL_LOW_LATENCY: 250,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
  SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,

  /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
  ABR_MINIMUM_TOTAL_BYTES: 150e3,

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_CHUNK_SIZE: 16e3,

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Object}
   */
  ABR_STARVATION_FACTOR: {
    DEFAULT: 0.72,
    LOW_LATENCY: 0.72
  },

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Object}
   */
  ABR_REGULAR_FACTOR: {
    DEFAULT: 0.8,
    LOW_LATENCY: 0.8
  },

  /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Object}
   */
  ABR_STARVATION_GAP: {
    DEFAULT: 5,
    LOW_LATENCY: 5
  },
  OUT_OF_STARVATION_GAP: {
    DEFAULT: 7,
    LOW_LATENCY: 7
  },

  /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
  ABR_STARVATION_DURATION_DELTA: 0.1,

  /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_FAST_EMA: 2,

  /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_SLOW_EMA: 10,

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
  RESUME_GAP_AFTER_SEEKING: {
    DEFAULT: 1.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
  RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
  RESUME_GAP_AFTER_BUFFERING: {
    DEFAULT: 5,
    LOW_LATENCY: 0.5
  },

  /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
  STALL_GAP: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.2
  },

  /**
   * Maximum authorized difference between what we calculated to be the
   * beginning or end of the segment in the SourceBuffer and what we
   * actually are noticing now.
   *
   * If the segment seems to have removed more than this size in seconds, we
   * will infer that the segment has been garbage collected and we might try to
   * re-download it.
   * @type {Number}
   */
  MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,

  /**
   * The maximum authorized difference, in seconds, between the real buffered
   * time of a given chunk and what the segment information of the Manifest
   * tells us.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments).
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,

  /**
   * The maximum authorized difference, in seconds, between the duration a
   * segment should have according to the Manifest and the actual duration it
   * seems to have once pushed to the SourceBuffer.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments). This last point
   * could lead to unnecessary segment re-downloading.
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,

  /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
  MINIMUM_SEGMENT_SIZE: 0.005,

  /**
   * Append windows allow to filter media data from segments if they are outside
   * a given limit.
   * Coded frames with presentation timestamp within this range are allowed to
   * be appended to the SourceBuffer while coded frames outside this range are
   * filtered out.
   *
   * Those are often set to be the start and end of the "Period" the segment is
   * in.
   * However, we noticed that some browsers were too aggressive when the exact
   * limits were set: more data than needed was removed, often leading to
   * discontinuities.
   *
   * Those securities are added to the set windows (substracted from the window
   * start and added to the window end) to avoid those problems.
   * @type {Object}
   */
  APPEND_WINDOW_SECURITIES: {
    START: 0.2,
    END: 0.1
  },

  /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
  MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,

  /**
   * On browsers with no ResizeObserver API, this will be the interval in
   * milliseconds at which we should check if the text track element has
   * changed its size, and updates proportional text-track data accordingly
   * (like a proportional font-size).
   *
   * This is only used:
   *   - in an "html" textTrackMode
   *   - when some styling is proportional in the text track data
   *
   * Putting a value too low will render faster but might use to much proc time.
   * Putting a value too high might provoke a re-render too late after the user
   * changed the element's size (e.g. when going to fullscreen mode).
   *
   * @type {Number}
   */
  TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,

  /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is above
   * the padding described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the padding too low would increase the risk of re-bufferings.
   *
   * Keeping the padding too high would delay visible quality increase.
   *
   * @type {Object}
   */
  BUFFER_PADDING: {
    audio: 1,
    video: 3,
    other: 1
  },

  /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * In the RxPlayer's code, each step is then translated in to a priority
   * number.
   * The lower is that number, the lower is the step and the lower is the step,
   * the higher is the priority.
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority number (and thus to a
   * specific step), we have to consider the distance between the current
   * position and the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * distances:
   *   1. inferior to 5 => first step (priority number = 0)
   *   2. between 5 and 11 => second step (priority number = 1)
   *   3. between 11 and 17 => third step (priority number = 2)
   *   4. between 17 and 25 => fourth step (priority number = 3)
   *   5. superior to 25 => fifth step (priority number = 4)
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
  SEGMENT_PRIORITIES_STEPS: [2, 4, 8, 12, 18, 25],
  // 7th Step (priority number = 6):  >= 25

  /**
   * Some segment requests are said to be "high priority".
   *
   * Requests in that category once done will cancel any segment request that
   * has a low priority number (see `SEGMENT_PRIORITIES_STEPS`) - meaning a
   * priority number equal to `MIN_CANCELABLE_PRIORITY` or more.
   *
   * Enter here the last priority number that is considered high priority
   * (beginning by the first step, which has the priority number `0`).
   * @type {number}
   */
  MAX_HIGH_PRIORITY_LEVEL: 1,

  /**
   * Enter here the first priority step (see `SEGMENT_PRIORITIES_STEPS`) that
   * will be considered as low priority.
   *
   * Segment requests with a low priority will be cancelled if a high priority
   * segment request (see MAX_HIGH_PRIORITY_LEVEL) is scheduled while they are
   * pending.
   *
   * This number should be strictly superior to the value indicated in
   * `MAX_HIGH_PRIORITY_LEVEL`.
   * @type {number}
   */
  MIN_CANCELABLE_PRIORITY: 3,

  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO"],

  /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */

  /* tslint:disable no-object-literal-type-assertion */
  EME_KEY_SYSTEMS: {
    clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
    widevine: ["com.widevine.alpha"],
    playready: ["com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready"],
    fairplay: ["com.apple.fps.1_0"]
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * The Manifest parsing logic has a notion of "unsafeMode" which allows to
   * speed-up this process a lot with a small risk of de-synchronization with
   * what actually is on the server.
   * Because using that mode is risky, and can lead to all sort of problems, we
   * regularly should fall back to a regular "safe" parsing every once in a
   * while.
   * This value defines how many consecutive time maximum the "unsafeMode"
   * parsing can be done.
   */
  MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE: 10,

  /**
   * Minimum time spent parsing the Manifest before we can authorize parsing
   * it in an "unsafeMode", to speed-up the process with a little risk.
   * Please note that this parsing time also sometimes includes idle time such
   * as when the parser is waiting for a request to finish.
   */
  MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE: 200,

  /**
   * Minimum amount of <S> elements in a DASH MPD's <SegmentTimeline> element
   * necessary to begin parsing the current SegmentTimeline element in an
   * unsafe manner (meaning: with risks of de-synchronization).
   * This is only done when the "unsafeMode" parsing mode is enabled.
   */
  MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY: 300,

  /**
   * When we detect that the local Manifest might be out-of-sync with the
   * server's one, we schedule a Manifest refresh.
   * However, as this "unsynchronization" is only a theory and as we do not want
   * to send too many Manifest requests, we keep a delay between the last
   * Manifest refresh done and that one.
   * This value indicates which delay we want. Note that the Manifest could
   * still be refreshed before this delay for other reasons.
   * @type {Number}
   */
  OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,

  /**
   * When a partial Manifest update (that is an update with a partial sub-set
   * of the Manifest) fails, we will perform an update with the whole Manifest
   * instead.
   * To not overload the client - as parsing a Manifest can be resource heavy -
   * we set a minimum delay to wait before doing the corresponding request.
   * @type {Number}
   */
  FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3000,

  /**
   * DASH Manifest based on a SegmentTimeline should normally have an
   * MPD@minimumUpdatePeriod attribute which should be sufficient to
   * know when to refresh it.
   * However, there is a specific case, for when it is equal to 0.
   * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a
   * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD
   * unless told to do so through inband events, in the stream.
   * In reality however, we found it to not always be the case (even with
   * DASH-IF own streams) and moreover to not always be the best thing to do.
   * We prefer to refresh in average at a regular interval when we do not have
   * this information.
   * /!\ This value is expressed in seconds.
   */
  DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,

  /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
  EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,

  /**
   * When playing contents with a persistent license, we will usually store some
   * information related to that MediaKeySession, to be able to play it at a
   * later time.
   *
   * Those information are removed once a MediaKeySession is not considered
   * as "usable" anymore. But to know that, the RxPlayer has to load it.
   *
   * But the RxPlayer does not re-load every persisted MediaKeySession every
   * time to check each one of them one by one, as this would not be a
   * performant thing to do.
   *
   * So this is only done when and if the corresponding content is encountered
   * again and only if it contains the same initialization data.
   *
   * We have to consider that those "information" contain binary data which can
   * be of arbitrary length. Size taken by an array of them can relatively
   * rapidly take a lot of space in JS memory.
   *
   * So to avoid this storage to take too much space (would it be in the chosen
   * browser's storage or in JS memory), we now set a higher bound for the
   * amount of MediaKeySession information that can be stored at the same time.
   *
   * I set the value of 1000 here, as it seems big enough to not be considered a
   * problem (though it can become one, when contents have a lot of keys per
   * content), and still low enough so it should not cause much problem (my
   * method to choose that number was to work with power of 10s and choosing the
   * amount which seemed the most sensible one).
   *
   * This wasn't battle-tested however.
   */
  EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION: 1000,

  /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
  FORCED_ENDED_THRESHOLD: 0.001,

  /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
  ADAPTATION_SWITCH_BUFFER_PADDINGS: {
    video: {
      before: 0.5,
      after: 1
    },
    audio: {
      before: 0.5,
      after: 2
    },
    text: {
      before: 0,
      after: 0
    },
    image: {
      before: 0,
      after: 0
    }
  },

  /**
   * Interval, in milliseconds, at which we should manually flush
   * SourceBuffers.
   * Some browsers (happened with firefox 66) sometimes "forget" to send us
   * `update` or `updateend` events.
   * In that case, we're completely unable to continue the queue here and
   * stay locked in a waiting state.
   * This interval is here to check at regular intervals if the underlying
   * SourceBuffer is currently updating.
   * @type {Number}
   */
  SOURCE_BUFFER_FLUSHING_INTERVAL: 500,

  /**
   * Padding under which we should not buffer from the current time, on
   * Safari. To avoid some buffer appending issues on it, we decide not
   * to load a segment if it may be pushed during playback time.
   * @type {Number} - in seconds
   */
  CONTENT_REPLACEMENT_PADDING: 2,

  /**
   * For video and audio segments, determines two thresholds below which :
   * - The segment is considered as loaded from cache
   * - The segment may be loaded from cache depending on the previous request
   */
  CACHE_LOAD_DURATION_THRESHOLDS: {
    video: 50,
    audio: 10
  },

  /** Interval we will use to poll for checking if an event shall be emitted */
  STREAM_EVENT_EMITTER_POLL_INTERVAL: 250
});

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __extends; });
/* unused harmony export __assign */
/* unused harmony export __rest */
/* unused harmony export __decorate */
/* unused harmony export __param */
/* unused harmony export __metadata */
/* unused harmony export __awaiter */
/* unused harmony export __generator */
/* unused harmony export __createBinding */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __spreadArrays */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/* unused harmony export __classPrivateFieldGet */
/* unused harmony export __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 6 */,
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function objectAssign(target) {
  if (target === null || target === undefined) {
    throw new TypeError("Cannot convert undefined or null to object");
  }

  var to = Object(target);

  for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    var source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        /* tslint:disable no-unnecessary-type-assertion */
        to[key] = source[key];
        /* tslint:enable no-unnecessary-type-assertion */
      }
    }
  }

  return to;
}
/* tslint:disable no-unbound-method */


/* harmony default export */ __webpack_exports__["a"] = (typeof Object.assign === "function" ? Object.assign :
/* tslint:enable no-unbound-method */
objectAssign);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ event_listeners; });

// UNUSED EXPORTS: addClassName, addTextTrack, canPatchISOBMFFSegment, clearElementSrc, closeSession, CustomMediaKeySystemAccess, exitFullscreen, generateKeyRequest, getInitData, hasEMEAPIs, isCodecSupported, isFullscreen, isOffline, isPlaybackStuck, isVTTCue, makeVTTCue, MediaSource_, onHeightWidthChange, play$, requestFullscreen, requestMediaKeySystemAccess, setElementSrc$, setMediaKeys, shouldReloadMediaSourceOnDecipherabilityUpdate, shouldRenewMediaKeys, shouldUnsetMediaKeys, shouldValidateMetadata, shouldWaitForDataBeforeLoaded, tryToChangeSourceBufferType, VTTCue_, whenLoadedMetadata$, whenMediaSourceOpen$

// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(81);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(30);

// CONCATENATED MODULE: ./src/compat/patch_webkit_source_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


 // TODO This is the last ugly side-effect here.
// Either remove it or find the best way to implement that

function patchWebkitSourceBuffer() {
  // old WebKit SourceBuffer implementation,
  // where a synchronous append is used instead of appendBuffer

  /* tslint:disable no-unsafe-any */
  if (!is_node["a" /* default */] && window.WebKitSourceBuffer != null && !window.WebKitSourceBuffer.prototype.addEventListener) {
    var sourceBufferWebkitRef = window.WebKitSourceBuffer;
    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;
    /* tslint:enable no-unsafe-any */

    for (var fnName in event_emitter["a" /* default */].prototype) {
      if (event_emitter["a" /* default */].prototype.hasOwnProperty(fnName)) {
        /* tslint:disable no-unsafe-any */
        sourceBufferWebkitProto[fnName] = event_emitter["a" /* default */].prototype[fnName];
        /* tslint:enable no-unsafe-any */
      }
    }
    /* tslint:disable no-unsafe-any */


    sourceBufferWebkitProto._listeners = [];

    sourceBufferWebkitProto.__emitUpdate = function (eventName, val) {
      var _this = this;

      next_tick_default()(function () {
        /* tslint:disable no-invalid-this */
        _this.trigger(eventName, val);

        _this.updating = false;

        _this.trigger("updateend");
        /* tslint:enable no-invalid-this */

      });
    };

    sourceBufferWebkitProto.appendBuffer = function (data) {
      /* tslint:disable no-invalid-this */
      if (this.updating) {
        throw new Error("updating");
      }

      this.trigger("updatestart");
      this.updating = true;

      try {
        this.append(data);
      } catch (error) {
        this.__emitUpdate("error", error);

        return;
      }

      this.__emitUpdate("update");
      /* tslint:enable no-invalid-this */

    };
    /* tslint:enable no-unsafe-any */

  }
}
// CONCATENATED MODULE: ./src/compat/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

























 // TODO To remove. This seems to be the only side-effect done on import, which
// we  would prefer to disallow (both for the understandability of the code and
// to better exploit tree shaking.

patchWebkitSourceBuffer();


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscriber; });
/* unused harmony export SafeSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */







var Subscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"];
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"];
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__[/* rxSubscriber */ "a"]] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"]));

var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "a"])(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"]) {
                context = Object.create(observerOrNext);
                if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "a"])(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

//# sourceMappingURL=Subscriber.js.map


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bytesToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hexToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return strToUtf8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return utf8ToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return strToLeUtf16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return leUtf16ToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return guidToUuid; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in little-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */

function strToLeUtf16(str) {
  var buffer = new ArrayBuffer(str.length * 2);
  var res = new Uint8Array(buffer);

  for (var i = 0; i < res.length; i += 2) {
    var value = str.charCodeAt(i / 2);
    res[i] = value & 0xFF;
    res[i + 1] = value >> 8 & 0xFF;
  }

  return res;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */


function leUtf16ToStr(bytes) {
  var str = "";

  for (var i = 0; i < bytes.length; i += 2) {
    str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
  }

  return str;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-8 code
 * units.
 * @param {string} str
 * @returns {Uint8Array}
 */


function strToUtf8(str) {
  // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.
  // (Note you have to dig deeper to understand it but I have more faith in
  // stackoverflow not going down in the future so I leave that link.)
  // Briefly said, `utf8Str` will contain a version of `str` where every
  // non-ASCII characters will be replaced by an escape sequence of the
  // corresponding representation of those characters in UTF-8.
  // It does sound weird and unnecessarily complicated, but it works!
  //
  // Here is actually what happens with more words. We will rely on two browser
  // APIs:
  //
  //   - `encodeURIComponent` will take a string and convert the non-ASCII
  //     characters in it into the percent-encoded version of the corresponding
  //     UTF-8 bytes
  //     Example: encodeURIComponent("") => 0xC3 0xA9 => `"%C3%A9"`
  //
  //   - `unescape` unescapes (so far so good) a percent-encoded string. But it
  //     does it in a really simple way: percent-encoded byte by percent-encoded
  //     byte into the corresponding extended ASCII representation on 8 bits.
  //     As a result, we end-up with a string which actually contains instead of
  //     each of its original characters, the UTF-8 code units (8 bits) of
  //     those characters.
  //     Let's take our previous `"" => "%C3%A9"` example. Here we would get:
  //     unecape("%C3%A9") => "\u00c3\u00a9" === "" (in extended ASCII)
  //
  // By iterating on the resulting string, we will then be able to generate a
  // Uint8Array containing the UTF-8 representation of that original string, by
  // just calling the charCodeAt API on it.
  var utf8Str;
  var pcStr = encodeURIComponent(str); // As "unescape" is a deprecated function we want to declare a fallback in the
  // case a browser decide to not implement it.

  if (typeof unescape === "function") {
    utf8Str = unescape(pcStr);
  } else {
    // Let's implement a simple unescape function (got to admit it was for the challenge)
    // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string
    var isHexChar = /[0-9a-fA-F]/;
    var pcStrLen = pcStr.length;
    utf8Str = "";

    for (var i = 0; i < pcStr.length; i++) {
      var wasPercentEncoded = false;

      if (pcStr[i] === "%") {
        if (i <= pcStrLen - 6 && pcStr[i + 1] === "u" && isHexChar.test(pcStr[i + 2]) && isHexChar.test(pcStr[i + 3]) && isHexChar.test(pcStr[i + 4]) && isHexChar.test(pcStr[i + 5])) {
          var charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
          utf8Str += String.fromCharCode(charCode);
          wasPercentEncoded = true;
          i += 5; // Skip the next 5 chars
        } else if (i <= pcStrLen - 3 && isHexChar.test(pcStr[i + 1]) && isHexChar.test(pcStr[i + 2])) {
          var _charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);

          utf8Str += String.fromCharCode(_charCode);
          wasPercentEncoded = true;
          i += 2; // Skip the next 2 chars
        }
      }

      if (!wasPercentEncoded) {
        utf8Str += pcStr[i];
      }
    }
  } // Now let's just build our array from every other bytes of that string's
  // UTF-16 representation


  var res = new Uint8Array(utf8Str.length);

  for (var _i = 0; _i < utf8Str.length; _i++) {
    res[_i] = utf8Str.charCodeAt(_i) & 0xFF; // first byte should be 0x00 anyway
  }

  return res;
}
/**
 * Creates a new string from the given array of char codes.
 * @param {Uint8Array} args
 * @returns {string}
 */


function stringFromCharCodes(args) {
  var max = 16000;
  var ret = "";

  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max); // NOTE: ugly I know, but TS is problematic here (you can try)

    ret += String.fromCharCode.apply(null, subArray);
  }

  return ret;
}
/**
 * Transform an integer into an hexadecimal string of the given length, padded
 * to the left with `0` if needed.
 * @example
 * ```
 * intToHex(5, 4); // => "0005"
 * intToHex(5, 2); // => "05"
 * intToHex(10, 1); // => "a"
 * intToHex(268, 3); // => "10c"
 * intToHex(4584, 6) // => "0011e8"
 * intToHex(123456, 4); // => "1e240" (we do nothing when going over 4 chars)
 * ```
 * @param {number} num
 * @param {number} size
 * @returns {string}
 */


function intToHex(num, size) {
  var toStr = num.toString(16);
  return toStr.length >= size ? toStr : new Array(size - toStr.length + 1).join("0") + toStr;
}
/**
 * Creates a string from the given Uint8Array containing utf-8 code units.
 * @param {Uint8Array} bytes
 * @returns {string}
 */


function utf8ToStr(data) {
  var uint8 = data; // If present, strip off the UTF-8 BOM.

  if (uint8[0] === 0xEF && uint8[1] === 0xBB && uint8[2] === 0xBF) {
    uint8 = uint8.subarray(3);
  } // We're basically doing strToUtf8 in reverse.
  // You can look at that other function for the whole story.
  // Generate string containing escaped UTF-8 code units


  var utf8Str = stringFromCharCodes(uint8);
  var escaped;

  if (typeof escape === "function") {
    // Transform UTF-8 escape sequence into percent-encoded escape sequences.
    escaped = escape(utf8Str);
  } else {
    // Let's implement a simple escape function
    // http://ecma-international.org/ecma-262/9.0/#sec-escape-string
    var nonEscapedChar = /[A-Za-z0-9*_\+-\.\/]/;
    escaped = "";

    for (var i = 0; i < utf8Str.length; i++) {
      if (nonEscapedChar.test(utf8Str[i])) {
        escaped += utf8Str[i];
      } else {
        var charCode = utf8Str.charCodeAt(i);
        escaped += charCode >= 256 ? "%u" + intToHex(charCode, 4) : "%" + intToHex(charCode, 2);
      }
    }
  } // Decode the percent-encoded UTF-8 string into the proper JS string.
  // Example: "g#%E3%82%AC" -> "g#"


  return decodeURIComponent(escaped);
}
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */


function hexToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len / 2);

  for (var i = 0, j = 0; i < len; i += 2, j++) {
    arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xFF;
  }

  return arr;
}
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */


function bytesToHex(bytes, sep) {
  if (sep === void 0) {
    sep = "";
  }

  var hex = "";

  for (var i = 0; i < bytes.byteLength; i++) {
    hex += (bytes[i] >>> 4).toString(16);
    hex += (bytes[i] & 0xF).toString(16);

    if (sep.length > 0 && i < bytes.byteLength - 1) {
      hex += sep;
    }
  }

  return hex;
}
/**
 * Convert little-endian GUID into big-endian UUID.
 * @param {Uint8Array} guid
 * @returns {Uint8Array} - uuid
 * @throws AssertionError - The guid length is not 16
 */


function guidToUuid(guid) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"])(guid.length === 16, "GUID length should be 16");
  var p1A = guid[0];
  var p1B = guid[1];
  var p1C = guid[2];
  var p1D = guid[3];
  var p2A = guid[4];
  var p2B = guid[5];
  var p3A = guid[6];
  var p3B = guid[7];
  var uuid = new Uint8Array(16); // swapping byte endian on 4 bytes
  // [1, 2, 3, 4] => [4, 3, 2, 1]

  uuid[0] = p1D;
  uuid[1] = p1C;
  uuid[2] = p1B;
  uuid[3] = p1A; // swapping byte endian on 2 bytes
  // [5, 6] => [6, 5]

  uuid[4] = p2B;
  uuid[5] = p2A; // swapping byte endian on 2 bytes
  // [7, 8] => [8, 7]

  uuid[6] = p3B;
  uuid[7] = p3A;
  uuid.set(guid.subarray(8, 16), 8);
  return uuid;
}



/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Observable_Observable; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber["a" /* Subscriber */]) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
//# sourceMappingURL=canReportError.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber = __webpack_require__(82);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
var Observer = __webpack_require__(95);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber["a" /* Subscriber */]) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber["a" /* rxSubscriber */]]) {
            return nextOrObserver[rxSubscriber["a" /* rxSubscriber */]]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber["a" /* Subscriber */](Observer["a" /* empty */]);
    }
    return new Subscriber["a" /* Subscriber */](nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(109);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js
/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity["a" /* identity */];
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
var config = __webpack_require__(46);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */





var Observable_Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config["a" /* config */].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config["a" /* config */].useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config["a" /* config */].useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable["a" /* observable */]] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config["a" /* config */].Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayIncludes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }], obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }], { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
function arrayIncludes(arr, searchElement, fromIndex) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.includes === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable ban */
    return arr.includes(searchElement, fromIndex);
    /* tslint:enable ban */
  }

  var len = arr.length >>> 0;

  if (len === 0) {
    return false;
  }

  var n = fromIndex | 0;
  var k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);

  var areTheSame = function areTheSame(x, y) {
    return x === y || // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
  };

  while (k < len) {
    if (areTheSame(arr[k], searchElement)) {
      return true;
    }

    k++;
  }

  return false;
}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */

/**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */

var features = {
  directfile: null,
  emeManager: null,
  htmlTextTracksBuffer: null,
  htmlTextTracksParsers: {},
  imageBuffer: null,
  imageParser: null,
  nativeTextTracksBuffer: null,
  nativeTextTracksParsers: {},
  transports: {}
};
/* harmony default export */ __webpack_exports__["a"] = (features);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayFind; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFind(arr, predicate, thisArg) {
  if (typeof Array.prototype.find === "function") {
    /* tslint:disable no-unsafe-any */

    /* tslint:disable ban */
    return arr.find(predicate, thisArg);
    /* tslint:enable ban */

    /* tslint:enable no-unsafe-any */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    var val = arr[i];

    if (predicate.call(thisArg, val, i, arr)) {
      return val;
    }
  }

  return undefined;
}

/***/ }),
/* 16 */
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REGXP_4_HEX_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REGXP_8_HEX_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return REGXP_RGB_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return REGXP_RGBA_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return REGXP_LENGTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return REGXP_PERCENT_VALUES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return REGXP_TIME_COLON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return REGXP_TIME_COLON_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return REGXP_TIME_COLON_MS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return REGXP_TIME_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return REGXP_TIME_HMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return REGXP_TIME_TICK; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/; // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)

var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/; // examples: 01:02:43.0345555 or 02:43.03

var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/; // examples: 75f or 75.5f

var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/; // examples: 50t or 50.5t

var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/; // examples: 3.45h, 3m or 4.20s

var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/; // examples: 50% 10%

var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
var REGXP_LENGTH = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
var REGXP_RGB_COLOR = /^rgb\( *(\d+) *, *(\d+) *, *(\d+) *\)/;
var REGXP_RGBA_COLOR = /^rgba\( *(\d+) *, *(\d+) *, *(\d+) *, *(\d+) *\)/;


/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return takeFirstSet; });
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function takeFirstSet() {
  var i = 0;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var len = args.length;

  while (i < len) {
    var arg = args[i];

    if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(arg)) {
      return arg;
    }

    i++;
  }
}

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getIndexSegmentEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return toIndexTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromIndexTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTimescaledRange; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// byte-range

/**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} maxPosition
 * @returns {Number}
 */
function calculateRepeat(element, nextElement, maxPosition) {
  var repeatCount = element.repeatCount;

  if (repeatCount >= 0) {
    return repeatCount;
  } // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.


  var segmentEnd;

  if (nextElement != null) {
    segmentEnd = nextElement.start;
  } else if (maxPosition != null) {
    segmentEnd = maxPosition;
  } else {
    segmentEnd = Number.MAX_VALUE;
  }

  return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
}
/**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */

function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
  var start = segment.start,
      duration = segment.duration;

  if (duration <= 0) {
    return start;
  }

  var repeat = calculateRepeat(segment, nextSegment, maxPosition);
  return start + (repeat + 1) * duration;
}
/**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function toIndexTime(time, indexOptions) {
  return time * indexOptions.timescale + indexOptions.indexTimeOffset;
}
/**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function fromIndexTime(time, indexOptions) {
  return (time - indexOptions.indexTimeOffset) / indexOptions.timescale;
}
/**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */

function getTimescaledRange(start, duration, timescale) {
  return [start * timescale, (start + duration) * timescale];
}

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return warnOnce; });
/* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var WARNED_MESSAGES = [];
/**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */

function warnOnce(message) {
  if (!Object(_array_includes__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(WARNED_MESSAGES, message)) {
    /* tslint:disable no-console */
    console.warn(message);
    /* tslint:enable no-console */

    WARNED_MESSAGES.push(message);
  }
}

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return convertToRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return excludeFromRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getInnerAndOuterTimeRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getLeftSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getNextRangeGap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getPlayedSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return insertInto; });
/* unused harmony export isAfter */
/* unused harmony export isBefore */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isTimeInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isTimeInRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return keepRangeIntersection; });
/* unused harmony export mergeContiguousRanges */
/* unused harmony export removeEmptyRanges */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
var EPSILON = 1 / 60;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */

function nearlyEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */


function createRangeUnion(range1, range2) {
  var start = Math.min(range1.start, range2.start);
  var end = Math.max(range1.end, range2.end);
  return {
    start: start,
    end: end
  };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */


function removeEmptyRanges(ranges) {
  for (var index = 0; index < ranges.length; index++) {
    var range = ranges[index];

    if (range.start === range.end) {
      ranges.splice(index--, 1);
    }
  }

  return ranges;
}
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */


function mergeContiguousRanges(ranges) {
  for (var index = 1; index < ranges.length; index++) {
    var prevRange = ranges[index - 1];
    var currRange = ranges[index];

    if (areRangesNearlyContiguous(prevRange, currRange)) {
      var unionRange = createRangeUnion(prevRange, currRange);
      ranges.splice(--index, 2, unionRange);
    }
  }

  return ranges;
}
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function isAfter(range1, range2) {
  return range1.start >= range2.end;
}
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function isBefore(range1, range2) {
  return range1.end <= range2.start;
}
/**
 * Returns true if the time given can be considered as part of any of the given
 * ranges.
 * @param {Array.<Object>} ranges
 * @param {number} time
 * @returns {boolean}
 */


function isTimeInRanges(ranges, time) {
  for (var i = 0; i < ranges.length; i++) {
    if (isTimeInRange(ranges[i], time)) {
      return true;
    }
  }

  return false;
}
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */


function isTimeInRange(_ref, time) {
  var start = _ref.start,
      end = _ref.end;
  return start <= time && time < end;
}
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function areRangesOverlapping(range1, range2) {
  return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function areRangesNearlyContiguous(range1, range2) {
  return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */


function convertToRanges(timeRanges) {
  var ranges = [];

  for (var i = 0; i < timeRanges.length; i++) {
    ranges.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }

  return ranges;
}
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */


function getRange(timeRanges, time) {
  for (var i = timeRanges.length - 1; i >= 0; i--) {
    var start = timeRanges.start(i);

    if (time >= start) {
      var end = timeRanges.end(i);

      if (time < end) {
        return {
          start: start,
          end: end
        };
      }
    }
  }

  return null;
}
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */


function getNextRangeGap(timeRanges, time) {
  var len = timeRanges.length;

  for (var i = 0; i < len; i++) {
    var start = timeRanges.start(i);

    if (time < start) {
      return start - time;
    }
  }

  return Infinity;
}
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */


function getInnerAndOuterTimeRanges(timeRanges, time) {
  var innerRange = null;
  var outerRanges = [];

  for (var i = 0; i < timeRanges.length; i++) {
    var start = timeRanges.start(i);
    var end = timeRanges.end(i);

    if (time < start || time >= end) {
      outerRanges.push({
        start: start,
        end: end
      });
    } else {
      innerRange = {
        start: start,
        end: end
      };
    }
  }

  return {
    outerRanges: outerRanges,
    innerRange: innerRange
  };
}
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - range.start : 0;
}
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getPlayedSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? currentTime - range.start : 0;
}
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getLeftSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - currentTime : Infinity;
}
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */


function insertInto(ranges, rangeToAddArg) {
  if (rangeToAddArg.start === rangeToAddArg.end) {
    return ranges;
  }

  var rangeToAdd = rangeToAddArg; // For each present range check if we need to:
  // - In case we are overlapping or contiguous:
  //   - if added range has the same bitrate as the overlapped or
  //     contiguous one, we can merge themcurrentRange
  //   - if added range has a different bitrate we need to insert it
  //     in place
  // - Need to insert in place, we we are completely, not overlapping
  //   and not contiguous in between two ranges.

  var index = 0;

  for (; index < ranges.length; index++) {
    var range = ranges[index];
    var overlapping = areRangesOverlapping(rangeToAdd, range);
    var contiguous = areRangesNearlyContiguous(rangeToAdd, range); // We assume ranges are ordered and two ranges can not be
    // completely overlapping.

    if (overlapping || contiguous) {
      rangeToAdd = createRangeUnion(rangeToAdd, range);
      ranges.splice(index--, 1);
    } else {
      // Check the case for which there is no more to do
      if (index === 0) {
        if (isBefore(rangeToAdd, ranges[0])) {
          // First index, and we are completely before that range (and
          // not contiguous, nor overlapping). We just need to be
          // inserted here.
          break;
        }
      } else {
        if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {
          // We are exactly after the current previous range, and
          // before the current range, while not overlapping with none
          // of them. Insert here.
          break;
        }
      }
    }
  } // Now that we are sure we don't overlap with any range, just add it.


  ranges.splice(index, 0, rangeToAdd);
  return mergeContiguousRanges(removeEmptyRanges(ranges));
}
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */


function findOverlappingRanges(range, ranges) {
  var resultingRanges = [];

  for (var i = 0; i < ranges.length; i++) {
    if (areRangesOverlapping(range, ranges[i])) {
      resultingRanges.push(ranges[i]);
    }
  }

  return resultingRanges;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */


function keepRangeIntersection(ranges1, ranges2) {
  var result = [];

  for (var i = 0; i < ranges1.length; i++) {
    var range = ranges1[i];
    var overlappingRanges = findOverlappingRanges(range, ranges2);

    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        result.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }
  }

  return result;
}
/**
 * Exclude from the `baseRanges` everything that is in `rangesToExclude`.
 * Example:
 *
 * Let's say we have the following base ranges:
 *       |==========|        |===============| |======|    |==========|
 *
 * From which we want to "exclude" the following ranges:
 *          |=========| |==|        |===|  |=====|
 *
 * We will obtain the first ranges from which we remove the second ranges:
 * -----------------------------------------------------------------------
 *       |==========|        |===============| |======|    |==========|
 *          |=========| |==|        |===|  |=====|
 * _______________________________________________________________________
 *                                     |
 *                                     |
 *                                     V
 * -----------------------------------------------------------------------
 *       |==|                |======|   |==|     |====|    |==========|
 * -----------------------------------------------------------------------
 *
 * @param {Array.<Object} baseRanges
 * @param {Array.<Object} rangesToExclude
 * @return {Array.<Object>}
 */


function excludeFromRanges(baseRanges, rangesToExclude) {
  var result = []; // For every range in `baseRanges`, find overlapping ranges with
  // `rangesToExclude` and remove them.

  for (var i = 0; i < baseRanges.length; i++) {
    var range = baseRanges[i];
    var intersections = [];
    var overlappingRanges = findOverlappingRanges(range, rangesToExclude);

    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        intersections.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }

    if (intersections.length === 0) {
      result.push(range);
    } else {
      var lastStart = range.start;

      for (var _j = 0; _j < intersections.length; _j++) {
        if (intersections[_j].start > lastStart) {
          result.push({
            start: lastStart,
            end: intersections[_j].start
          });
        }

        lastStart = intersections[_j].end;
      }

      if (lastStart < range.end) {
        result.push({
          start: lastStart,
          end: range.end
        });
      }
    }
  }

  return result;
}



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimpleInnerSubscriber; });
/* unused harmony export ComplexInnerSubscriber */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SimpleOuterSubscriber; });
/* unused harmony export ComplexOuterSubscriber */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return innerSubscribe; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */




var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

var ComplexInnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](ComplexInnerSubscriber, _super);
    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

var ComplexOuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](ComplexOuterSubscriber, _super);
    function ComplexOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber.prototype.notifyError = function (error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ "a"]) {
        return result.subscribe(innerSubscriber);
    }
    return Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__[/* subscribeTo */ "a"])(result)(innerSubscriber);
}
//# sourceMappingURL=innerSubscribe.js.map


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isEdgeChromium; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isIE11; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isIEOrEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isSafariMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isSamsungBrowser; });
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;

 // true on IE11
// false on Edge and other IEs/browsers.

var isIE11 = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && !!window.MSInputMethodContext && !!document.documentMode; // true for IE / Edge

var isIEOrEdge = _is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] ? false : navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent);
var isEdgeChromium = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && navigator.userAgent.toLowerCase().indexOf("edg/") !== -1;
var isFirefox = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
var isSamsungBrowser = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && /SamsungBrowser/.test(navigator.userAgent);
var isSafari = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && (
/* tslint:disable ban */
Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") >= 0 ||
/* tslint:enable ban */

/* tslint:disable no-unsafe-any */
((_a = window.safari) === null || _a === void 0 ? void 0 : _a.pushNotification.toString()) === "[object SafariRemoteNotification]"
/* tslint:enable no-unsafe-any */
);
var isSafariMobile = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && typeof navigator.platform === "string" && /iPad|iPhone|iPod/.test(navigator.platform);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromEvent; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Simple but fully type-safe EventEmitter implementation.
 * @class EventEmitter
 */

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    this._listeners = {};
  }
  /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */


  var _proto = EventEmitter.prototype;

  _proto.addEventListener = function addEventListener(evt, fn) {
    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      this._listeners[evt] = [fn];
    } else {
      listeners.push(fn);
    }
  }
  /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */
  ;

  _proto.removeEventListener = function removeEventListener(evt, fn) {
    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(evt)) {
      this._listeners = {};
      return;
    }

    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      return;
    }

    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(fn)) {
      delete this._listeners[evt];
      return;
    }

    var index = listeners.indexOf(fn);

    if (index !== -1) {
      listeners.splice(index, 1);
    }

    if (listeners.length === 0) {
      delete this._listeners[evt];
    }
  }
  /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */
  ;

  _proto.trigger = function trigger(evt, arg) {
    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      return;
    }

    listeners.slice().forEach(function (listener) {
      try {
        listener(arg);
      } catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].error(e, e instanceof Error ? e.stack : null);
      }
    });
  };

  return EventEmitter;
}();
/**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */



function fromEvent(target, eventName) {
  return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
    function handler(event) {
      obs.next(event);
    }

    target.addEventListener(eventName, handler);
    return function () {
      target.removeEventListener(eventName, handler);
    };
  });
}

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(177);
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pinkie__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = (typeof Promise === "function" ? Promise : pinkie__WEBPACK_IMPORTED_MODULE_0___default.a);

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Subscription_Subscription; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(108);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js
var isFunction = __webpack_require__(68);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */




var Subscription_Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (Object(isFunction["a" /* isFunction */])(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (Object(isArray["a" /* isArray */])(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (Object(isObject["a" /* isObject */])(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());

function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: fetchIsSupported, fetchRequest, xhr

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(146);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// CONCATENATED MODULE: ./src/utils/request/xhr.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var DEFAULT_REQUEST_TIMEOUT = config["a" /* default */].DEFAULT_REQUEST_TIMEOUT;
var DEFAULT_RESPONSE_TYPE = "json";
/**
 * @param {string} data
 * @returns {Object|null}
 */

function toJSONForIE(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}

function request(options) {
  var requestOptions = {
    url: options.url,
    headers: options.headers,
    responseType: Object(is_null_or_undefined["a" /* default */])(options.responseType) ? DEFAULT_RESPONSE_TYPE : options.responseType,
    timeout: Object(is_null_or_undefined["a" /* default */])(options.timeout) ? DEFAULT_REQUEST_TIMEOUT : options.timeout
  };
  return new Observable["a" /* Observable */](function (obs) {
    var url = requestOptions.url,
        headers = requestOptions.headers,
        responseType = requestOptions.responseType,
        timeout = requestOptions.timeout;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if (timeout >= 0) {
      xhr.timeout = timeout;
    }

    xhr.responseType = responseType;

    if (xhr.responseType === "document") {
      xhr.overrideMimeType("text/xml");
    }

    if (!Object(is_null_or_undefined["a" /* default */])(headers)) {
      var _headers = headers;

      for (var key in _headers) {
        if (_headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, _headers[key]);
        }
      }
    }

    var sendingTime = performance.now();

    xhr.onerror = function onXHRError() {
      obs.error(new request_error["a" /* default */](url, xhr.status, "ERROR_EVENT", xhr));
    };

    xhr.ontimeout = function onXHRTimeout() {
      obs.error(new request_error["a" /* default */](url, xhr.status, "TIMEOUT", xhr));
    };

    if (options.sendProgressEvents === true) {
      xhr.onprogress = function onXHRProgress(event) {
        var currentTime = performance.now();
        obs.next({
          type: "progress",
          value: {
            url: url,
            duration: currentTime - sendingTime,
            sendingTime: sendingTime,
            currentTime: currentTime,
            size: event.loaded,
            totalSize: event.total
          }
        });
      };
    }

    xhr.onload = function onXHRLoad(event) {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          var receivedTime = performance.now();
          var totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;
          var status = xhr.status;
          var loadedResponseType = xhr.responseType;

          var _url = Object(is_non_empty_string["a" /* default */])(xhr.responseURL) ? xhr.responseURL : url;

          var responseData;

          if (loadedResponseType === "json") {
            // IE bug where response is string with responseType json
            responseData = typeof xhr.response === "object" ?
            /* tslint:disable no-unsafe-any */
            xhr.response :
            /* tslint:enable no-unsafe-any */
            toJSONForIE(xhr.responseText);
          } else {
            /* tslint:disable no-unsafe-any */
            responseData = xhr.response;
            /* tslint:enable no-unsafe-any */
          }

          if (Object(is_null_or_undefined["a" /* default */])(responseData)) {
            obs.error(new request_error["a" /* default */](url, xhr.status, "PARSE_ERROR", xhr));
            return;
          }

          obs.next({
            type: "data-loaded",
            value: {
              status: status,
              url: _url,
              responseType: loadedResponseType,
              sendingTime: sendingTime,
              receivedTime: receivedTime,
              duration: receivedTime - sendingTime,
              size: totalSize,
              responseData: responseData
            }
          });
          obs.complete();
        } else {
          obs.error(new request_error["a" /* default */](url, xhr.status, "ERROR_HTTP_CODE", xhr));
        }
      }
    };

    xhr.send();
    return function () {
      if (!Object(is_null_or_undefined["a" /* default */])(xhr) && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
}

/* harmony default export */ var request_xhr = (request);
// CONCATENATED MODULE: ./src/utils/request/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var utils_request = __webpack_exports__["a"] = (request_xhr);


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function castToObservable(value) {
  if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"]) {
    return value;
  }
  /* tslint:disable no-unsafe-any */


  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(value) && typeof value.subscribe === "function") {
    /* tslint:enable no-unsafe-any */
    var valObsLike = value;
    return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
      var sub = valObsLike.subscribe(function (val) {
        obs.next(val);
      }, function (err) {
        obs.error(err);
      }, function () {
        obs.complete();
      });
      return function () {
        if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(sub) && typeof sub.dispose === "function") {
          sub.dispose();
        } else if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(sub) && typeof sub.unsubscribe === "function") {
          sub.unsubscribe();
        }
      };
    });
  }
  /* tslint:disable no-unsafe-any */


  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(value) && typeof value.then === "function") {
    /* tslint:enable no-unsafe-any */
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* from */ "a"])(value);
  }

  return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (castToObservable);

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var isNode = typeof window === "undefined";
/* harmony default export */ __webpack_exports__["a"] = (isNode);

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return of; });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__[/* isScheduler */ "a"])(scheduler)) {
        args.pop();
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__[/* scheduleArray */ "a"])(args, scheduler);
    }
    else {
        return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__[/* fromArray */ "a"])(args);
    }
}
//# sourceMappingURL=of.js.map


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
/* unused harmony export MapOperator */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());

var MapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=map.js.map


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a "loaded" event.
 * @returns {Object}
 */
function loaded(sourceBuffersStore) {
  return {
    type: "loaded",
    value: {
      sourceBuffersStore: sourceBuffersStore
    }
  };
}
/**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */


function stalled(stalling) {
  return {
    type: "stalled",
    value: stalling
  };
}
/**
 * Construct a "decipherabilityUpdate" event.
 * @param {Array.<Object>} arg
 * @returns {Object}
 */


function decipherabilityUpdate(arg) {
  return {
    type: "decipherabilityUpdate",
    value: arg
  };
}
/**
 * Construct a "manifestReady" event.
 * @param {Object} manifest
 * @returns {Object}
 */


function manifestReady(manifest) {
  return {
    type: "manifestReady",
    value: {
      manifest: manifest
    }
  };
}
/**
 * Construct a "manifestUpdate" event.
 * @returns {Object}
 */


function manifestUpdate() {
  return {
    type: "manifestUpdate",
    value: null
  };
}
/**
 * Construct a "speedChanged" event.
 * @param {Number} speed
 * @returns {Object}
 */


function speedChanged(speed) {
  return {
    type: "speedChanged",
    value: speed
  };
}
/**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */


function nullRepresentation(type, period) {
  return {
    type: "representationChange",
    value: {
      type: type,
      representation: null,
      period: period
    }
  };
}
/**
 * construct a "warning" event.
 * @param {error} value
 * @returns {object}
 */


function warning(value) {
  return {
    type: "warning",
    value: value
  };
}
/**
 * construct a "reloading-media-source" event.
 * @returns {object}
 */


function reloadingMediaSource() {
  return {
    type: "reloading-media-source",
    value: undefined
  };
}

var INIT_EVENTS = {
  loaded: loaded,
  decipherabilityUpdate: decipherabilityUpdate,
  manifestReady: manifestReady,
  manifestUpdate: manifestUpdate,
  nullRepresentation: nullRepresentation,
  reloadingMediaSource: reloadingMediaSource,
  speedChanged: speedChanged,
  stalled: stalled,
  warning: warning
};
/* harmony default export */ __webpack_exports__["a"] = (INIT_EVENTS);

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTMLElement_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MediaKeys_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MediaSource_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return READY_STATES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return VTTCue_; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Shortcut to the global browser object `window`. Set to an empty object in
 * non-browser platforms
 */

var win = _is_node__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"] ? {} : window;
/* tslint:disable no-unsafe-any */

/** Browser implementation of an HTMLElement. */

var HTMLElement_ = win.HTMLElement;
/** TextTrack cue constructor, as implemented by the browser. */

var VTTCue_ = !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.VTTCue) ? win.VTTCue : win.TextTrackCue;
/* tslint:enable no-unsafe-any */

/* tslint:disable no-unsafe-any */

/** MediaSource implementation, including vendored implementations. */

var MediaSource_ = !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.MediaSource) ? win.MediaSource : !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.MozMediaSource) ? win.MozMediaSource : !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.WebKitMediaSource) ? win.WebKitMediaSource : win.MSMediaSource;
/* tslint:enable no-unsafe-any */

/**
 * MediaKeys implementation, including vendored implementations and a fallback
 * one which will throw when calling one of its methods.
 */

var MediaKeys_ = function () {
  /* tslint:disable no-unsafe-any */
  return !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.MediaKeys) ? win.MediaKeys : !Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(win.MozMediaKeys) ? win.MozMediaKeys :
  /*#__PURE__*/
  // fallback implementation if not supported
  function () {
    function _class() {
      var noMediaKeys = function noMediaKeys() {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found " + "in the current browser.");
      };

      this.create = noMediaKeys;
      this.createSession = noMediaKeys;
      this.isTypeSupported = noMediaKeys;
      this.setServerCertificate = noMediaKeys;
    }

    return _class;
  }();
  /* tslint:enable no-unsafe-any */
}();
/** List an HTMLMediaElement's possible values for its readyState property. */


var READY_STATES = {
  HAVE_NOTHING: 0,
  HAVE_METADATA: 1,
  HAVE_CURRENT_DATA: 2,
  HAVE_FUTURE_DATA: 3,
  HAVE_ENOUGH_DATA: 4
};


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBoxContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getBoxOffsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getNextBoxOffsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getUuidContent; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */

function getBoxContent(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[1], offsets[2]) : null;
}
/**
 * Returns an ISOBMFF box - size and name included - based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */


function getBox(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[0], offsets[2]) : null;
}
/**
 * Returns byte offsets for the start of the box, the start of its content and
 * the end of the box (not inclusive).
 *
 * `null` if not found.
 *
 * If found, the tuple returned has three elements, all numbers:
 *   1. The starting byte corresponding to the start of the box (from its size)
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {Array.<number>|null}
 */


function getBoxOffsets(buf, boxName) {
  var len = buf.length;
  var boxBaseOffset = 0;
  var name;
  var lastBoxSize = 0;
  var lastOffset;

  while (boxBaseOffset + 8 <= len) {
    lastOffset = boxBaseOffset;
    lastBoxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, lastOffset);
    lastOffset += 4;
    name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, lastOffset);
    lastOffset += 4;

    if (lastBoxSize === 0) {
      lastBoxSize = len - boxBaseOffset;
    } else if (lastBoxSize === 1) {
      if (lastOffset + 8 > len) {
        return null;
      }

      lastBoxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(buf, lastOffset);
      lastOffset += 8;
    }

    if (lastBoxSize < 0) {
      throw new Error("ISOBMFF: Size out of range");
    }

    if (name === boxName) {
      if (boxName === 0x75756964
      /* === "uuid" */
      ) {
          lastOffset += 16; // Skip uuid name
        }

      return [boxBaseOffset, lastOffset, boxBaseOffset + lastBoxSize];
    } else {
      boxBaseOffset += lastBoxSize;
    }
  }

  return null;
}
/**
 * Gives the content of a specific UUID box.
 * `undefined` if that box is not found.
 *
 * If found, the returned Uint8Array contains just the box's content: the box
 * without its name and size.
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */


function getUuidContent(buf, id1, id2, id3, id4) {
  var len = buf.length;
  var boxSize;

  for (var boxBaseOffset = 0; boxBaseOffset < len; boxBaseOffset += boxSize) {
    var currentOffset = boxBaseOffset;
    boxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset);
    currentOffset += 4;
    var boxName = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset);
    currentOffset += 4;

    if (boxSize === 0) {
      boxSize = len - boxBaseOffset;
    } else if (boxSize === 1) {
      if (currentOffset + 8 > len) {
        return undefined;
      }

      boxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(buf, currentOffset);
      currentOffset += 8;
    }

    if (boxName === 0x75756964
    /* === "uuid" */
    && currentOffset + 16 <= len && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset) === id1 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset + 4) === id2 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset + 8) === id3 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, currentOffset + 12) === id4) {
      currentOffset += 16;
      return buf.subarray(currentOffset, boxBaseOffset + boxSize);
    }
  }
}
/**
 * For the next encountered box, return byte offsets corresponding to:
 *   1. the starting byte offset for the next box (should always be equal to
 *       `0`).
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 *
 * `null` if no box is found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 */


function getNextBoxOffsets(buf) {
  var len = buf.length;

  if (len < 8) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("ISOBMFF: box inferior to 8 bytes, cannot find offsets");
    return null;
  }

  var lastOffset = 0;
  var boxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, lastOffset);
  lastOffset += 4;
  var name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, lastOffset);
  lastOffset += 4;

  if (boxSize === 0) {
    boxSize = len;
  } else if (boxSize === 1) {
    if (lastOffset + 8 > len) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("ISOBMFF: box too short, cannot find offsets");
      return null;
    }

    boxSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(buf, lastOffset);
    lastOffset += 8;
  }

  if (boxSize < 0) {
    throw new Error("ISOBMFF: Size out of range");
  }

  if (name === 0x75756964
  /* === "uuid" */
  ) {
      lastOffset += 16; // Skip uuid name
    }

  return [0, lastOffset, boxSize];
}



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayFindIndex; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFindIndex(arr, predicate, thisArg) {
  if (typeof Array.prototype.findIndex === "function") {
    /* tslint:disable no-unsafe-any */

    /* tslint:disable ban */
    return arr.findIndex(predicate, thisArg);
    /* tslint:enable ban */

    /* tslint:enable no-unsafe-any */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    if (predicate.call(thisArg, arr[i], i, arr)) {
      return i;
    }
  }

  return -1;
}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(201);

var setPrototypeOf = __webpack_require__(161);

var isNativeFunction = __webpack_require__(202);

var construct = __webpack_require__(203);

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "isActive", function() { return /* binding */ isActive; });
__webpack_require__.d(__webpack_exports__, "isVideoVisible", function() { return /* binding */ isVideoVisible; });
__webpack_require__.d(__webpack_exports__, "videoWidth$", function() { return /* binding */ videoWidth$; });
__webpack_require__.d(__webpack_exports__, "onPlayPause$", function() { return /* binding */ event_listeners_onPlayPause$; });
__webpack_require__.d(__webpack_exports__, "onTextTrackChanges$", function() { return /* binding */ event_listeners_onTextTrackChanges$; });
__webpack_require__.d(__webpack_exports__, "onLoadedMetadata$", function() { return /* binding */ onLoadedMetadata$; });
__webpack_require__.d(__webpack_exports__, "onSeeking$", function() { return /* binding */ onSeeking$; });
__webpack_require__.d(__webpack_exports__, "onSeeked$", function() { return /* binding */ onSeeked$; });
__webpack_require__.d(__webpack_exports__, "onEnded$", function() { return /* binding */ onEnded$; });
__webpack_require__.d(__webpack_exports__, "onTimeUpdate$", function() { return /* binding */ onTimeUpdate$; });
__webpack_require__.d(__webpack_exports__, "onFullscreenChange$", function() { return /* binding */ onFullscreenChange$; });
__webpack_require__.d(__webpack_exports__, "onSourceOpen$", function() { return /* binding */ onSourceOpen$; });
__webpack_require__.d(__webpack_exports__, "onUpdate$", function() { return /* binding */ onUpdate$; });
__webpack_require__.d(__webpack_exports__, "onRemoveSourceBuffers$", function() { return /* binding */ onRemoveSourceBuffers$; });
__webpack_require__.d(__webpack_exports__, "onEncrypted$", function() { return /* binding */ onEncrypted$; });
__webpack_require__.d(__webpack_exports__, "onKeyMessage$", function() { return /* binding */ onKeyMessage$; });
__webpack_require__.d(__webpack_exports__, "onKeyAdded$", function() { return /* binding */ onKeyAdded$; });
__webpack_require__.d(__webpack_exports__, "onKeyError$", function() { return /* binding */ onKeyError$; });
__webpack_require__.d(__webpack_exports__, "onKeyStatusesChange$", function() { return /* binding */ onKeyStatusesChange$; });
__webpack_require__.d(__webpack_exports__, "onPictureInPictureEvent$", function() { return /* binding */ onPictureInPictureEvent$; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(226);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
var noop = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/never.js
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/ new Observable["a" /* Observable */](noop["a" /* noop */]);
function never() {
    return NEVER;
}
//# sourceMappingURL=never.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(86);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var interval = __webpack_require__(227);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(184);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(156);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(142);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(114);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(85);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/delay.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay_delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    var absoluteDelay = Object(isDate["a" /* isDate */])(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new delay_DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var delay_DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification["a" /* Notification */].createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification["a" /* Notification */].createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber["a" /* Subscriber */]));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(185);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttle.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new throttle_ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var throttle_ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = Object(innerSubscribe["c" /* innerSubscribe */])(duration, new innerSubscribe["a" /* SimpleInnerSubscriber */](this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(innerSubscribe["b" /* SimpleOuterSubscriber */]));
//# sourceMappingURL=throttle.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttleTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new throttleTime_ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var throttleTime_ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber["a" /* Subscriber */]));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

// EXTERNAL MODULE: ./src/config.ts
var src_config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(34);

// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(30);

// EXTERNAL MODULE: ./src/compat/should_favour_custom_safari_EME.ts
var should_favour_custom_safari_EME = __webpack_require__(115);

// CONCATENATED MODULE: ./src/compat/event_listeners.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */








var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
var INACTIVITY_DELAY = src_config["a" /* default */].INACTIVITY_DELAY;
var pixelRatio = is_node["a" /* default */] || window.devicePixelRatio == null || window.devicePixelRatio === 0 ? 1 : window.devicePixelRatio;
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */

function isEventSupported(element, eventNameSuffix) {
  var clone = document.createElement(element.tagName);
  var eventName = "on" + eventNameSuffix;

  if (eventName in clone) {
    return true;
  } else {
    clone.setAttribute(eventName, "return;");
    return typeof clone[eventName] === "function";
  }
}
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */


function findSupportedEvent(element, eventNames) {
  return eventNames.filter(function (name) {
    return isEventSupported(element, name);
  })[0];
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */


function eventPrefixed(eventNames, prefixes) {
  return eventNames.reduce(function (parent, name) {
    return parent.concat((prefixes == null ? BROWSER_PREFIXES : prefixes).map(function (p) {
      return p + name;
    }));
  }, []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */


function compatibleListener(eventNames, prefixes) {
  var mem;
  var prefixedEvents = eventPrefixed(eventNames, prefixes);
  return function (element) {
    // if the element is a HTMLElement we can detect
    // the supported event, and memoize it in `mem`
    if (element instanceof browser_compatibility_types["a" /* HTMLElement_ */]) {
      if (typeof mem === "undefined") {
        mem = findSupportedEvent(element, prefixedEvents);
      }

      if (Object(is_non_empty_string["a" /* default */])(mem)) {
        return Object(fromEvent["a" /* fromEvent */])(element, mem);
      } else {
        if (false) {}

        return NEVER;
      }
    } // otherwise, we need to listen to all the events
    // and merge them into one observable sequence


    return merge["a" /* merge */].apply(void 0, prefixedEvents.map(function (eventName) {
      return Object(fromEvent["a" /* fromEvent */])(element, eventName);
    }));
  };
}
/**
 * Returns an observable:
 *   - emitting true when the document is visible
 *   - emitting false when the document is hidden
 * @returns {Observable}
 */


function visibilityChange() {
  var prefix;
  var doc = document;

  if (doc.hidden != null) {
    prefix = "";
  } else if (doc.mozHidden != null) {
    prefix = "moz";
  } else if (doc.msHidden != null) {
    prefix = "ms";
  } else if (doc.webkitHidden != null) {
    prefix = "webkit";
  }

  var hidden = Object(is_non_empty_string["a" /* default */])(prefix) ? prefix + "Hidden" : "hidden";
  var visibilityChangeEvent = Object(is_non_empty_string["a" /* default */])(prefix) ? prefix + "visibilitychange" : "visibilitychange";
  return Object(defer["a" /* defer */])(function () {
    var isHidden = document[hidden];
    return Object(fromEvent["a" /* fromEvent */])(document, visibilityChangeEvent).pipe(Object(map["a" /* map */])(function () {
      return !document[hidden];
    }), Object(startWith["a" /* startWith */])(!isHidden), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
  });
}
/**
 * @returns {Observable}
 */


function videoSizeChange() {
  return Object(fromEvent["a" /* fromEvent */])(window, "resize");
}
/**
 * Emit `true` if the page is considered active.
 * `false` when considered inactive.
 * Emit the original value on subscription.
 * @returns {Observable}
 */


function isActive() {
  return visibilityChange().pipe(Object(switchMap["a" /* switchMap */])(function (x) {
    if (!x) {
      return Object(of["a" /* of */])(x).pipe(delay_delay(INACTIVITY_DELAY));
    }

    return Object(of["a" /* of */])(x);
  }));
}
/**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */


function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
  var width = pipWindow.width,
      height = pipWindow.height;
  var videoRatio = mediaElement.clientHeight / mediaElement.clientWidth;
  var calcWidth = height / videoRatio;
  return Math.min(width, calcWidth);
}
/**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function onPictureInPictureEvent$(mediaElement) {
  return Object(defer["a" /* defer */])(function () {
    if (mediaElement.webkitSupportsPresentationMode && typeof mediaElement.webkitSetPresentationMode === "function") {
      var isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
      return Object(fromEvent["a" /* fromEvent */])(mediaElement, "webkitpresentationmodechanged").pipe(Object(map["a" /* map */])(function () {
        return {
          isEnabled: mediaElement.webkitPresentationMode === "picture-in-picture",
          pipWindow: null
        };
      }), Object(startWith["a" /* startWith */])({
        isEnabled: isWebKitPIPEnabled,
        pipWindow: null
      }));
    }

    var isPIPEnabled = document.pictureInPictureElement && document.pictureInPictureElement === mediaElement;
    var initialState = {
      isEnabled: isPIPEnabled,
      pipWindow: null
    };
    return Object(merge["a" /* merge */])(Object(fromEvent["a" /* fromEvent */])(mediaElement, "enterpictureinpicture").pipe(Object(map["a" /* map */])(function (evt) {
      return {
        isEnabled: true,

        /* tslint:disable no-unsafe-any */
        pipWindow: evt.pictureInPictureWindow
      };
    })),
    /* tslint:enable no-unsafe-any */
    Object(fromEvent["a" /* fromEvent */])(mediaElement, "leavepictureinpicture").pipe(Object(mapTo["a" /* mapTo */])({
      isEnabled: false,
      pipWindow: null
    }))).pipe(Object(startWith["a" /* startWith */])(initialState));
  });
}
/**
 * Returns `true` when video is considered as visible (the page is visible and/or
 * the Picture-In-Picture is activated). Returns `false` otherwise.
 * @param {Observable} pip$
 * @returns {Observable}
 */


function isVideoVisible(pip$) {
  return Object(combineLatest["a" /* combineLatest */])([visibilityChange(), pip$]).pipe(Object(switchMap["a" /* switchMap */])(function (_ref) {
    var isVisible = _ref[0],
        pip = _ref[1];

    if (pip.isEnabled || isVisible) {
      return Object(of["a" /* of */])(true);
    }

    return Object(of["a" /* of */])(false).pipe(delay_delay(INACTIVITY_DELAY));
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
/**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function videoWidth$(mediaElement, pip$) {
  return Object(combineLatest["a" /* combineLatest */])([pip$, Object(interval["a" /* interval */])(20000).pipe(Object(startWith["a" /* startWith */])(null)), videoSizeChange().pipe(throttleTime(500), Object(startWith["a" /* startWith */])(null))]).pipe(Object(switchMap["a" /* switchMap */])(function (_ref2) {
    var pip = _ref2[0];

    if (!pip.isEnabled) {
      return Object(of["a" /* of */])(mediaElement.clientWidth * pixelRatio);
    } else if (pip.pipWindow != null) {
      var pipWindow = pip.pipWindow;
      var firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow); // RxJS typing issue (for the "as any")

      return Object(fromEvent["a" /* fromEvent */])(pipWindow, "resize").pipe(Object(startWith["a" /* startWith */])(firstWidth * pixelRatio), Object(map["a" /* map */])(function () {
        return getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio;
      }));
    } else {
      return Object(of["a" /* of */])(Infinity);
    }
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeking$ = compatibleListener(["seeking"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeked$ = compatibleListener(["seeked"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEnded$ = compatibleListener(["ended"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onTimeUpdate$ = compatibleListener(["timeupdate"]);
/**
 * @param {HTMLElement} element
 * @returns {Observable}
 */

var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], // On IE11, fullscreen change events is called MSFullscreenChange
BROWSER_PREFIXES.concat("MS"));
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var event_listeners_onPlayPause$ = function onPlayPause$(mediaElement) {
  return Object(merge["a" /* merge */])(compatibleListener(["play"])(mediaElement), compatibleListener(["pause"])(mediaElement));
};
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


var event_listeners_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
  return Object(merge["a" /* merge */])(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
};
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */


var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
/**
 * @param {SourceBuffer} sourceBuffer
 * @returns {Observable}
 */

var onUpdate$ = compatibleListener(["update"]);
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

var onRemoveSourceBuffers$ = compatibleListener(["onremovesourcebuffer"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEncrypted$ = compatibleListener(Object(should_favour_custom_safari_EME["a" /* default */])() ? ["needkey"] : ["encrypted", "needkey"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyError$ = compatibleListener(["keyerror", "error"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */

/* tslint:disable:no-empty */
/* harmony default export */ __webpack_exports__["a"] = (function () {});
/* tslint:enable:no-empty */

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getStylingAttributes; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getStylingFromElement; });

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/utils/starts_with.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
function startsWith(completeString, searchString, position) {
  /* tslint:disable no-unbound-method */
  if (typeof String.prototype.startsWith === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable ban */
    return completeString.startsWith(searchString, position);
    /* tslint:enable ban */
  }

  var initialPosition = typeof position === "number" ? Math.max(position, 0) : 0;
  return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */

function getStylingAttributes(attributes, nodes, styles, regions) {
  var currentStyle = {};
  var leftAttributes = attributes.slice();

  for (var i = 0; i <= nodes.length - 1; i++) {
    var node = nodes[i];

    if (node !== undefined) {
      var _ret = function () {
        var styleID = void 0;
        var regionID = void 0; // 1. the style is directly set on a "tts:" attribute

        if (node.nodeType === Node.ELEMENT_NODE) {
          var element = node;

          for (var j = 0; j <= element.attributes.length - 1; j++) {
            var attribute = element.attributes[j];
            var name = attribute.name;

            if (name === "style") {
              styleID = attribute.value;
            } else if (name === "region") {
              regionID = attribute.value;
            } else {
              var nameWithoutTTS = name.substring(4);

              if (Object(array_includes["a" /* default */])(leftAttributes, nameWithoutTTS)) {
                currentStyle[nameWithoutTTS] = attribute.value;
                leftAttributes.splice(j, 1);

                if (leftAttributes.length === 0) {
                  return {
                    v: currentStyle
                  };
                }
              }
            }
          }
        } // 2. the style is referenced on a "style" attribute


        if (Object(is_non_empty_string["a" /* default */])(styleID)) {
          var style = Object(array_find["a" /* default */])(styles, function (x) {
            return x.id === styleID;
          });

          if (style !== undefined) {
            for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
              var _attribute = leftAttributes[_j];

              if (!Object(is_non_empty_string["a" /* default */])(currentStyle[_attribute])) {
                if (Object(is_non_empty_string["a" /* default */])(style.style[_attribute])) {
                  currentStyle[_attribute] = style.style[_attribute];
                  leftAttributes.splice(_j, 1);

                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }

                  _j--;
                }
              }
            }
          }
        } // 3. the node reference a region (which can have a value for the
        //    corresponding style)


        if (Object(is_non_empty_string["a" /* default */])(regionID)) {
          var region = Object(array_find["a" /* default */])(regions, function (x) {
            return x.id === regionID;
          });

          if (region !== undefined) {
            for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
              var _attribute2 = leftAttributes[_j2];

              if (!Object(is_non_empty_string["a" /* default */])(currentStyle[_attribute2])) {
                if (Object(is_non_empty_string["a" /* default */])(region.style[_attribute2])) {
                  currentStyle[_attribute2] = region.style[_attribute2];
                  leftAttributes.splice(_j2, 1);

                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }

                  _j2--;
                }
              }
            }
          }
        }
      }();

      if (typeof _ret === "object") return _ret.v;
    }
  }

  return currentStyle;
}
/**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */

function getStylingFromElement(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return {};
  }

  var element = node;
  var currentStyle = {};

  for (var i = 0; i <= element.attributes.length - 1; i++) {
    var styleAttribute = element.attributes[i];

    if (startsWith(styleAttribute.name, "tts")) {
      var nameWithoutTTS = styleAttribute.name.substring(4);
      currentStyle[nameWithoutTTS] = styleAttribute.value;
    }
  }

  return currentStyle;
}

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tryCatch; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */

function tryCatch(func, args) {
  try {
    return func(args);
  } catch (e) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* throwError */ "a"])(e);
  }
}

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Store the MediaKeys infos attached to a media element.
var currentMediaState = new WeakMap();
/* harmony default export */ __webpack_exports__["a"] = ({
  /**
   * Update MediaKeys infos set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} state
   */
  setState: function setState(mediaElement, state) {
    currentMediaState.set(mediaElement, state);
  },

  /**
   * Get MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @returns {Object}
   */
  getState: function getState(mediaElement) {
    var currentState = currentMediaState.get(mediaElement);
    return currentState === undefined ? null : currentState;
  },

  /**
   * Remove MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   */
  clearState: function clearState(mediaElement) {
    currentMediaState.set(mediaElement, null);
  }
});

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return NetworkErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorCodes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ErrorTypes = {
  NETWORK_ERROR: "NETWORK_ERROR",
  MEDIA_ERROR: "MEDIA_ERROR",
  ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
  OTHER_ERROR: "OTHER_ERROR"
};
var NetworkErrorTypes = {
  TIMEOUT: "TIMEOUT",
  ERROR_EVENT: "ERROR_EVENT",
  ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
  PARSE_ERROR: "PARSE_ERROR"
};
var ErrorCodes = {
  PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
  PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
  INTEGRITY_ERROR: "INTEGRITY_ERROR",
  MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
  MANIFEST_UPDATE_ERROR: "MANIFEST_UPDATE_ERROR",
  MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
  MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
  MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
  MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
  MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
  NO_PLAYABLE_REPRESENTATION: "NO_PLAYABLE_REPRESENTATION",
  MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
  CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
  KEY_ERROR: "KEY_ERROR",
  KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
  KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
  KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
  KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
  KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
  INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
  INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
  INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
  LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
  MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
  BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
  BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
  BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
  MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
  MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
  MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
  MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
  MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
  MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
  MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
  MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
  MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
  MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
  NONE: "NONE"
};


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return config; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export asyncScheduler */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return async; });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var asyncScheduler = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__[/* AsyncScheduler */ "a"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__[/* AsyncAction */ "a"]);
var async = asyncScheduler;
//# sourceMappingURL=async.js.map


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areArraysOfNumbersEqual; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if two two arrays containing only numbers are equal.
 * @param {Array.<number>|TypedArray} arr1
 * @param {Array.<number>|TypedArray} arr2
 * @returns {Boolean}
 */
function areArraysOfNumbersEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (var i = arr1.length - 1; i >= 0; i--) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertUnreachable; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TypeScript hack to make sure a code path is never taken.
 *
 * This can for example be used to ensure that a switch statement handle all
 * possible cases by adding a default clause calling assertUnreachable with
 * an argument (it doesn't matter which one).
 *
 * @example
 * function parseBinary(str : "0" | "1") : number {
 *   switch (str) {
 *     case "0:
 *       return 0;
 *     case "1":
 *       return 1;
 *     default:
 *       // branch never taken. If it can be, TypeScript will yell at us because
 *       // its argument (here, `str`) is not of the right type.
 *       assertUnreachable(str);
 *   }
 * }
 * @param {*} _
 * @throws AssertionError - Throw an AssertionError when called. If we're
 * sufficiently strict with how we use TypeScript, this should never happen.
 */

function assertUnreachable(_) {
  throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("Unreachable path taken");
}

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return byteRange; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
function byteRange(_ref) {
  var start = _ref[0],
      end = _ref[1];
  return end === Infinity ? "bytes=" + start + "-" : "bytes=" + start + "-" + end;
}

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeMap; });
/* unused harmony export MergeMapOperator */
/* unused harmony export MergeMapSubscriber */
/* unused harmony export flatMap */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__[/* from */ "a"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_1__[/* map */ "a"])(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());

var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* SimpleInnerSubscriber */ "a"](this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* innerSubscribe */ "c"])(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* SimpleOuterSubscriber */ "b"]));

var flatMap = mergeMap;
//# sourceMappingURL=mergeMap.js.map


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return bytesToBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return base64ToBytes; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* tslint:disable file-header */

/*
MIT License
Copyright (c) 2020 Egor Nepomnyaschih
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */

/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
  A = "A".charCodeAt(0),
  a = "a".charCodeAt(0),
  n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
  base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
 */

var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
  base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
  base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
 */

var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
/**
 * Obtain the value corresponding to a base64 char code.
 * /!\ Can throw if the char code given is invalid.
 * @param {number} charCode
 * @returns {number}
 */

function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new Error("Unable to parse base64 string.");
  }

  var code = base64codes[charCode];

  if (code === 255) {
    throw new Error("Unable to parse base64 string.");
  }

  return code;
}
/**
 * Convert an array of bytes into a base64 string.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */


function bytesToBase64(bytes) {
  var result = "";
  var i;
  var length = bytes.length;

  for (i = 2; i < length; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0F) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 0x3F];
  }

  if (i === length + 1) {
    // 1 octet yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4];
    result += "==";
  }

  if (i === length) {
    // 2 octets yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0F) << 2];
    result += "=";
  }

  return result;
}
/**
 * Convert a base64 string into the corresponding Uint8Array containing its
 * corresponding binary data.
 * /!\ Can throw if an invalid base64 string was given.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */

function base64ToBytes(str) {
  var paddingNeeded = str.length % 4;
  var paddedStr = str;

  if (paddingNeeded !== 0) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("base64ToBytes: base64 given miss padding");
    paddedStr += paddingNeeded === 3 ? "=" : paddingNeeded === 2 ? "==" : "==="; // invalid, but we will catch it
  }

  var index = paddedStr.indexOf("=");

  if (index !== -1 && index < paddedStr.length - 2) {
    throw new Error("Unable to parse base64 string.");
  }

  var missingOctets = paddedStr.endsWith("==") ? 2 : paddedStr.endsWith("=") ? 1 : 0;
  var n = paddedStr.length;
  var result = new Uint8Array(n / 4 * 3);
  var buffer;

  for (var i = 0, j = 0; i < n; i += 4, j += 3) {
    buffer = getBase64Code(paddedStr.charCodeAt(i)) << 18 | getBase64Code(paddedStr.charCodeAt(i + 1)) << 12 | getBase64Code(paddedStr.charCodeAt(i + 2)) << 6 | getBase64Code(paddedStr.charCodeAt(i + 3));
    result[j] = buffer >> 16;
    result[j + 1] = buffer >> 8 & 0xFF;
    result[j + 2] = buffer & 0xFF;
  }

  return result.subarray(0, result.length - missingOctets);
}

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertInterface; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */

function assert(assertion, message) {
  if (!assertion) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](message === undefined ? "invalid assertion" : message);
  }
}
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */

function assertInterface(o, iface, name) {
  if (name === void 0) {
    name = "object";
  }

  assert(!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(o), name + " should be an object");

  for (var k in iface) {
    if (iface.hasOwnProperty(k)) {
      /* tslint:disable:max-line-length */
      assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
      /* tslint:enable:max-line-length */
    }
  }
}

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isScheduler; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SubjectSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subject; });
/* unused harmony export AnonymousSubject */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(116);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */







var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__[/* Subscriber */ "a"]));

var Subject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__[/* rxSubscriber */ "a"]] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__[/* SubjectSubscription */ "a"](this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"]();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"]));

var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ deferSubscriptions; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var RESOLVED = /*@__PURE__*/ (function () { return /*@__PURE__*/ Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
var TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};
//# sourceMappingURL=Immediate.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(93);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */



var AsapAction_AsapAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction["a" /* AsyncAction */]));

//# sourceMappingURL=AsapAction.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(92);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AsapScheduler_AsapScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler["a" /* AsyncScheduler */]));

//# sourceMappingURL=AsapScheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asapScheduler = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);
var asap = asapScheduler;
//# sourceMappingURL=asap.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isNumeric.js
var isNumeric = __webpack_require__(83);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable_SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!Object(isNumeric["a" /* isNumeric */])(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable["a" /* Observable */]));

//# sourceMappingURL=SubscribeOnObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new subscribeOn_SubscribeOnOperator(scheduler, delay));
    };
}
var subscribeOn_SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map

// CONCATENATED MODULE: ./src/utils/defer_subscriptions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * At subscription, instead of "running" the Observable right away, wait until
 * the current task has finished executing before actually running this
 * Observable.
 *
 * This can be important for example when you want in a given function to
 * exploit the same shared Observable which may send synchronous events directly
 * after subscription.
 *
 * Here, you might be left in a situation where the first element subscribing to
 * that Observable will receive those synchronous events immediately on
 * subscription. Further subscriptions on that Observable will miss out on those
 * events - even if those subscriptions happen synchronously after the first
 * one.
 *
 * Calling `deferSubscriptions` in those cases will make sure that all such
 * subscriptions can be registered before the Observable start emitting events
 * (as long as such Subscriptions are done synchronously).
 *
 * @example
 * ```js
 * const myObservable = rxjs.timer(100).pipe(mapTo("ASYNC MSG"),
 *                                           startWith("SYNCHRONOUS MSG"),
 *                                           share());
 *
 * myObservable.subscribe(x => console.log("Sub1:", x));
 * myObservable.subscribe(x => console.log("Sub2:", x));
 *
 * setTimeout(() => {
 *   myObservable.subscribe(x => console.log("Sub3:", x));
 * }, 50);
 *
 * // You will get:
 * // Sub1: SYNCHRONOUS MSG
 * // Sub1: ASYNC MSG
 * // Sub2: ASYNC MSG
 * // Sub3: ASYNC MSG
 *
 * // ------------------------------
 *
 * const myObservableDeferred = rxjs.timer(100).pipe(mapTo("ASYNC MSG"),
 *                                                   startWith("SYNCHRONOUS MSG"),
 *                                                   deferSubscriptions(),
 *                                                   // NOTE: the order is important here
 *                                                   share());
 *
 * myObservableDeferred.subscribe(x => console.log("Sub1:", x));
 * myObservableDeferred.subscribe(x => console.log("Sub2:", x));
 *
 * setTimeout(() => {
 *   myObservableDeferred.subscribe(x => console.log("Sub3:", x));
 * }, 50);
 *
 * // You will get:
 * // Sub1: SYNCHRONOUS MSG
 * // Sub2: SYNCHRONOUS MSG
 * // Sub1: ASYNC MSG
 * // Sub2: ASYNC MSG
 * // Sub3: ASYNC MSG
 * ```
 * @returns {function}
 */

function deferSubscriptions() {
  return function (source) {
    // TODO asapScheduler seems to not push the subscription in the microtask
    // queue as nextTick does but in a regular event loop queue.
    // This means that the subscription will be run even later that we wish for.
    // This is not dramatic but it could be better.
    // Either this is a problem with RxJS or this was wanted, in which case we
    // may need to add our own scheduler.
    return source.pipe(subscribeOn(asapScheduler));
  };
}

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(107);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = (_normalize__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return noop; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }
//# sourceMappingURL=noop.js.map


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */

var MediaError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(MediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function MediaError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), MediaError.prototype);
    _this.name = "MediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_3__[/* ErrorTypes */ "b"].MEDIA_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return MediaError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return observable; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map


/***/ }),
/* 62 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return empty; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return idGenerator; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */
function idGenerator() {
  var prefix = "";
  var currId = -1;
  return function generateNewId() {
    currId++;

    if (currId >= Number.MAX_SAFE_INTEGER) {
      prefix += "0";
      currId = 0;
    }

    return prefix + String(currId);
  };
}

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ObjectUnsubscribedError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBodyNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getStyleNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getRegionNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTextNodes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
  return tt.getElementsByTagName("body")[0];
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getStyleNodes(tt) {
  return tt.getElementsByTagName("style");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getRegionNodes(tt) {
  return tt.getElementsByTagName("region");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getTextNodes(tt) {
  return tt.getElementsByTagName("p");
}



/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: areSameContent, Period, Adaptation, Representation, StaticRepresentationIndex, SUPPORTED_ADAPTATIONS_TYPE

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(48);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(64);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(21);

// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 1 modules
var manifest_adaptation = __webpack_require__(74);

// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(181);

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(59);

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(78);

// CONCATENATED MODULE: ./src/manifest/period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Class representing the tracks and qualities available from a given time
 * period in the the Manifest.
 * @class Period
 */

var period_Period = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
  function Period(args, representationFilter) {
    var _this = this;

    this.parsingErrors = [];
    this.id = args.id;
    this.adaptations = Object.keys(args.adaptations).reduce(function (acc, type) {
      var adaptationsForType = args.adaptations[type];

      if (adaptationsForType == null) {
        return acc;
      }

      var filteredAdaptations = adaptationsForType.map(function (adaptation) {
        var _this$parsingErrors;

        var newAdaptation = null;

        try {
          newAdaptation = new manifest_adaptation["b" /* default */](adaptation, {
            representationFilter: representationFilter
          });
        } catch (err) {
          if (Object(is_known_error["a" /* default */])(err) && err.code === "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE") {
            _this.parsingErrors.push(err);

            return null;
          }

          throw err;
        }

        (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, newAdaptation.parsingErrors);

        return newAdaptation;
      }).filter(function (adaptation) {
        return adaptation != null && adaptation.representations.length > 0;
      });

      if (filteredAdaptations.length === 0 && adaptationsForType.length > 0 && (type === "video" || type === "audio")) {
        throw new media_error["a" /* default */]("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
      }

      if (filteredAdaptations.length > 0) {
        acc[type] = filteredAdaptations;
      }

      return acc;
    }, {});

    if (!Array.isArray(this.adaptations.video) && !Array.isArray(this.adaptations.audio)) {
      throw new media_error["a" /* default */]("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
    }

    this.duration = args.duration;
    this.start = args.start;

    if (this.duration != null && this.start != null) {
      this.end = this.start + this.duration;
    }

    this.streamEvents = args.streamEvents === undefined ? [] : args.streamEvents;
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */


  var _proto = Period.prototype;

  _proto.getAdaptations = function getAdaptations() {
    var adaptationsByType = this.adaptations;
    return Object(object_values["a" /* default */])(adaptationsByType).reduce(function (acc, adaptations) {
      return (// Note: the second case cannot happen. TS is just being dumb here
        adaptations != null ? acc.concat(adaptations) : acc
      );
    }, []);
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period for a
   * given type.
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    var adaptationsForType = this.adaptations[adaptationType];
    return adaptationsForType == null ? [] : adaptationsForType;
  }
  /**
   * Returns the Adaptation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */
  ;

  _proto.getAdaptation = function getAdaptation(wantedId) {
    return Object(array_find["a" /* default */])(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  _proto.getPlayableAdaptations = function getPlayableAdaptations(type) {
    if (type === undefined) {
      return this.getAdaptations().filter(function (ada) {
        return ada.isSupported && ada.decipherable !== false;
      });
    }

    var adaptationsForType = this.adaptations[type];

    if (adaptationsForType === undefined) {
      return [];
    }

    return adaptationsForType.filter(function (ada) {
      return ada.isSupported && ada.decipherable !== false;
    });
  };

  return Period;
}();


// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(237);

// CONCATENATED MODULE: ./src/manifest/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Enumerate the different ways a Manifest update can be done. */
var MANIFEST_UPDATE_TYPE;

(function (MANIFEST_UPDATE_TYPE) {
  /** The full version of the Manifest has been re-downloaded. */
  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Full"] = 0] = "Full";
  /** Only a shortened version of the Manifest has been downloaded. */

  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Partial"] = 1] = "Partial";
})(MANIFEST_UPDATE_TYPE || (MANIFEST_UPDATE_TYPE = {}));
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(36);

// CONCATENATED MODULE: ./src/manifest/update_period_in_place.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */

function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {
  oldPeriod.start = newPeriod.start;
  oldPeriod.end = newPeriod.end;
  oldPeriod.duration = newPeriod.duration;
  var oldAdaptations = oldPeriod.getAdaptations();
  var newAdaptations = newPeriod.getAdaptations();

  var _loop = function _loop(j) {
    var oldAdaptation = oldAdaptations[j];
    var newAdaptation = Object(array_find["a" /* default */])(newAdaptations, function (a) {
      return a.id === oldAdaptation.id;
    });

    if (newAdaptation === undefined) {
      log["a" /* default */].warn("Manifest: Adaptation \"" + oldAdaptations[j].id + "\" not found when merging.");
    } else {
      var oldRepresentations = oldAdaptations[j].representations;
      var newRepresentations = newAdaptation.representations;

      var _loop2 = function _loop2(k) {
        var oldRepresentation = oldRepresentations[k];
        var newRepresentation = Object(array_find["a" /* default */])(newRepresentations, function (representation) {
          return representation.id === oldRepresentation.id;
        });

        if (newRepresentation === undefined) {
          log["a" /* default */].warn("Manifest: Representation \"" + oldRepresentations[k].id + "\" " + "not found when merging.");
        } else {
          if (updateType === MANIFEST_UPDATE_TYPE.Full) {
            oldRepresentation.index._replace(newRepresentation.index);
          } else {
            oldRepresentation.index._update(newRepresentation.index);
          }
        }
      };

      for (var k = 0; k < oldRepresentations.length; k++) {
        _loop2(k);
      }
    }
  };

  for (var j = 0; j < oldAdaptations.length; j++) {
    _loop(j);
  }
}
// CONCATENATED MODULE: ./src/manifest/update_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */

function replacePeriods(oldPeriods, newPeriods) {
  var firstUnhandledPeriodIdx = 0;

  for (var i = 0; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var j = firstUnhandledPeriodIdx;
    var oldPeriod = oldPeriods[j];

    while (oldPeriod != null && oldPeriod.id !== newPeriod.id) {
      j++;
      oldPeriod = oldPeriods[j];
    }

    if (oldPeriod != null) {
      updatePeriodInPlace(oldPeriod, newPeriod, MANIFEST_UPDATE_TYPE.Full);
      var periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
      var nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;
      oldPeriods.splice.apply(oldPeriods, [firstUnhandledPeriodIdx, nbrOfPeriodsToRemove].concat(periodsToInclude));
      firstUnhandledPeriodIdx = i + 1;
    }
  }

  if (firstUnhandledPeriodIdx > oldPeriods.length) {
    log["a" /* default */].error("Manifest: error when updating Periods");
    return;
  }

  if (firstUnhandledPeriodIdx < oldPeriods.length) {
    oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
  }

  var remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);

  if (remainingNewPeriods.length > 0) {
    oldPeriods.push.apply(oldPeriods, remainingNewPeriods);
  }
}
/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */

function updatePeriods(oldPeriods, newPeriods) {
  if (oldPeriods.length === 0) {
    oldPeriods.splice.apply(oldPeriods, [0, 0].concat(newPeriods));
    return;
  }

  if (newPeriods.length === 0) {
    return;
  }

  var oldLastPeriod = oldPeriods[oldPeriods.length - 1];

  if (oldLastPeriod.start < newPeriods[0].start) {
    if (oldLastPeriod.end !== newPeriods[0].start) {
      throw new media_error["a" /* default */]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
    }

    oldPeriods.push.apply(oldPeriods, newPeriods);
    return;
  }

  var indexOfNewFirstPeriod = Object(array_find_index["a" /* default */])(oldPeriods, function (_ref) {
    var id = _ref.id;
    return id === newPeriods[0].id;
  });

  if (indexOfNewFirstPeriod < 0) {
    throw new media_error["a" /* default */]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: incoherent data");
  } // The first updated Period can only be a partial part


  updatePeriodInPlace(oldPeriods[indexOfNewFirstPeriod], newPeriods[0], MANIFEST_UPDATE_TYPE.Partial);
  var prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;

  for (var i = 1; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var indexOfNewPeriod = -1;

    for (var j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
      if (newPeriod.id === oldPeriods[j].id) {
        indexOfNewPeriod = j;
        break; // end the loop
      }
    }

    if (indexOfNewPeriod < 0) {
      oldPeriods.splice.apply(oldPeriods, [prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod].concat(newPeriods.slice(i, newPeriods.length)));
      return;
    }

    if (indexOfNewPeriod > prevIndexOfNewPeriod) {
      oldPeriods.splice(prevIndexOfNewPeriod, indexOfNewPeriod - prevIndexOfNewPeriod);
      indexOfNewPeriod = prevIndexOfNewPeriod;
    } // Later Periods can be fully replaced


    updatePeriodInPlace(oldPeriods[indexOfNewPeriod], newPeriod, MANIFEST_UPDATE_TYPE.Full);
    prevIndexOfNewPeriod++;
  }

  if (prevIndexOfNewPeriod < oldPeriods.length) {
    oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod);
  }
}
// CONCATENATED MODULE: ./src/manifest/manifest.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var generateSupplementaryTrackID = Object(id_generator["a" /* default */])();
var generateNewManifestId = Object(id_generator["a" /* default */])();
/**
 * Normalized Manifest structure.
 *
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth, DASH etc.).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a dynamic manifest or when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 *
 * @class Manifest
 */

var manifest_Manifest = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(Manifest, _EventEmitter);

  /**
   * Construct a Manifest instance from a parsed Manifest object (as returned by
   * Manifest parsers) and options.
   *
   * Some minor errors can arise during that construction. `this.parsingErrors`
   * will contain all such errors, in the order they have been encountered.
   * @param {Object} parsedManifest
   * @param {Object} options
   */
  function Manifest(parsedManifest, options) {
    var _this;

    var _a;

    _this = _EventEmitter.call(this) || this;
    var _options$supplementar = options.supplementaryTextTracks,
        supplementaryTextTracks = _options$supplementar === void 0 ? [] : _options$supplementar,
        _options$supplementar2 = options.supplementaryImageTracks,
        supplementaryImageTracks = _options$supplementar2 === void 0 ? [] : _options$supplementar2,
        representationFilter = options.representationFilter;
    _this.parsingErrors = [];
    _this.id = generateNewManifestId();
    _this.expired = (_a = parsedManifest.expired) !== null && _a !== void 0 ? _a : null;
    _this.transport = parsedManifest.transportType;
    _this.clockOffset = parsedManifest.clockOffset;
    _this.periods = parsedManifest.periods.map(function (parsedPeriod) {
      var _this$parsingErrors;

      var period = new period_Period(parsedPeriod, representationFilter);

      (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, period.parsingErrors);

      return period;
    }).sort(function (a, b) {
      return a.start - b.start;
    });
    /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */

    /* tslint:disable:deprecation */

    _this.adaptations = _this.periods[0] === undefined ? {} : _this.periods[0].adaptations;
    /* tslint:enable:deprecation */

    _this.minimumTime = parsedManifest.minimumTime;
    _this.isDynamic = parsedManifest.isDynamic;
    _this.isLive = parsedManifest.isLive;
    _this.uris = parsedManifest.uris === undefined ? [] : parsedManifest.uris;
    _this.lifetime = parsedManifest.lifetime;
    _this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;
    _this.availabilityStartTime = parsedManifest.availabilityStartTime;
    _this.maximumTime = parsedManifest.maximumTime;

    if (supplementaryImageTracks.length > 0) {
      _this.addSupplementaryImageAdaptations(supplementaryImageTracks);
    }

    if (supplementaryTextTracks.length > 0) {
      _this.addSupplementaryTextAdaptations(supplementaryTextTracks);
    }

    return _this;
  }
  /**
   * Returns the Period corresponding to the given `id`.
   * Returns `undefined` if there is none.
   * @param {string} id
   * @returns {Object|undefined}
   */


  var _proto = Manifest.prototype;

  _proto.getPeriod = function getPeriod(id) {
    return Object(array_find["a" /* default */])(this.periods, function (period) {
      return id === period.id;
    });
  }
  /**
   * Returns the Period encountered at the given time.
   * Returns `undefined` if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Object|undefined}
   */
  ;

  _proto.getPeriodForTime = function getPeriodForTime(time) {
    return Object(array_find["a" /* default */])(this.periods, function (period) {
      return time >= period.start && (period.end === undefined || period.end > time);
    });
  }
  /**
   * Returns the Period coming chronologically just after another given Period.
   * Returns `undefined` if not found.
   * @param {Object} period
   * @returns {Object|null}
   */
  ;

  _proto.getPeriodAfter = function getPeriodAfter(period) {
    var endOfPeriod = period.end;

    if (endOfPeriod === undefined) {
      return null;
    }

    var nextPeriod = Object(array_find["a" /* default */])(this.periods, function (_period) {
      return _period.end === undefined || endOfPeriod < _period.end;
    });
    return nextPeriod === undefined ? null : nextPeriod;
  }
  /**
   * Returns the most important URL from which the Manifest can be refreshed.
   * `undefined` if no URL is found.
   * @returns {string|undefined}
   */
  ;

  _proto.getUrl = function getUrl() {
    return this.uris[0];
  }
  /**
   * Update the current Manifest properties by giving a new updated version.
   * This instance will be updated with the new information coming from it.
   * @param {Object} newManifest
   */
  ;

  _proto.replace = function replace(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Full);
  }
  /**
   * Update the current Manifest properties by giving a new but shorter version
   * of it.
   * This instance will add the new information coming from it and will
   * automatically clean old Periods that shouldn't be available anymore.
   *
   * /!\ Throws if the given Manifest cannot be used or is not sufficient to
   * update the Manifest.
   * @param {Object} newManifest
   */
  ;

  _proto.update = function update(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Partial);
  }
  /**
   * Get the minimum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */
  ;

  _proto.getMinimumPosition = function getMinimumPosition() {
    var minimumTime = this.minimumTime;

    if (minimumTime === undefined) {
      return 0;
    }

    if (!minimumTime.isContinuous) {
      return minimumTime.value;
    }

    var timeDiff = performance.now() - minimumTime.time;
    return minimumTime.value + timeDiff / 1000;
  }
  /**
   * Get the maximum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */
  ;

  _proto.getMaximumPosition = function getMaximumPosition() {
    var maximumTime = this.maximumTime;

    if (maximumTime === undefined) {
      if (this.isLive) {
        var ast = this.availabilityStartTime !== undefined ? this.availabilityStartTime : 0;

        if (this.clockOffset === undefined) {
          // server's time not known, rely on user's clock
          return Date.now() / 1000 - ast;
        }

        var serverTime = performance.now() + this.clockOffset;
        return serverTime / 1000 - ast;
      }

      return Infinity;
    }

    if (!maximumTime.isContinuous) {
      return maximumTime.value;
    }

    var timeDiff = performance.now() - maximumTime.time;
    return maximumTime.value + timeDiff / 1000;
  }
  /**
   * Look in the Manifest for Representations linked to the given key ID,
   * and mark them as being impossible to decrypt.
   * Then trigger a "blacklist-update" event to notify everyone of the changes
   * performed.
   * @param {Array.<ArrayBuffer>} keyIDs
   */
  ;

  _proto.addUndecipherableKIDs = function addUndecipherableKIDs(keyIDs) {
    var updates = updateDeciperability(this, function (representation) {
      if (representation.decipherable === false || representation.contentProtections === undefined) {
        return true;
      }

      var contentKIDs = representation.contentProtections.keyIds;

      for (var i = 0; i < contentKIDs.length; i++) {
        var elt = contentKIDs[i];

        for (var j = 0; j < keyIDs.length; j++) {
          if (Object(byte_parsing["f" /* isABEqualBytes */])(keyIDs[j], elt.keyId)) {
            return false;
          }
        }
      }

      return true;
    });

    if (updates.length > 0) {
      this.trigger("decipherabilityUpdate", updates);
    }
  }
  /**
   * Look in the Manifest for Representations linked to the given content
   * protection initialization data and mark them as being impossible to
   * decrypt.
   * Then trigger a "blacklist-update" event to notify everyone of the changes
   * performed.
   * @param {Array.<ArrayBuffer>} keyIDs
   */
  ;

  _proto.addUndecipherableProtectionData = function addUndecipherableProtectionData(initDataType, initData) {
    var updates = updateDeciperability(this, function (representation) {
      if (representation.decipherable === false) {
        return true;
      }

      var segmentProtections = representation.getProtectionsInitializationData();

      for (var i = 0; i < segmentProtections.length; i++) {
        if (segmentProtections[i].type === initDataType) {
          if (Object(are_arrays_of_numbers_equal["a" /* default */])(initData, segmentProtections[i].data)) {
            return false;
          }
        }
      }

      return true;
    });

    if (updates.length > 0) {
      this.trigger("decipherabilityUpdate", updates);
    }
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptations = function getAdaptations() {
    Object(warn_once["a" /* default */])("manifest.getAdaptations() is deprecated." + " Please use manifest.period[].getAdaptations() instead");
    var firstPeriod = this.periods[0];

    if (firstPeriod === undefined) {
      return [];
    }

    var adaptationsByType = firstPeriod.adaptations;
    var adaptationsList = [];

    for (var adaptationType in adaptationsByType) {
      if (adaptationsByType.hasOwnProperty(adaptationType)) {
        var adaptations = adaptationsByType[adaptationType];
        adaptationsList.push.apply(adaptationsList, adaptations);
      }
    }

    return adaptationsList;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    Object(warn_once["a" /* default */])("manifest.getAdaptationsForType(type) is deprecated." + " Please use manifest.period[].getAdaptationsForType(type) instead");
    var firstPeriod = this.periods[0];

    if (firstPeriod === undefined) {
      return [];
    }

    var adaptationsForType = firstPeriod.adaptations[adaptationType];
    return adaptationsForType === undefined ? [] : adaptationsForType;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptation = function getAdaptation(wantedId) {
    Object(warn_once["a" /* default */])("manifest.getAdaptation(id) is deprecated." + " Please use manifest.period[].getAdaptation(id) instead");
    /* tslint:disable:deprecation */

    return Object(array_find["a" /* default */])(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
    /* tslint:enable:deprecation */
  }
  /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} imageTracks
   */
  ;

  _proto.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(
  /* tslint:disable deprecation */
  imageTracks
  /* tslint:enable deprecated */
  ) {
    var _this2 = this;

    var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];

    var newImageTracks = _imageTracks.map(function (_ref2) {
      var _this2$parsingErrors;

      var mimeType = _ref2.mimeType,
          url = _ref2.url;
      var adaptationID = "gen-image-ada-" + generateSupplementaryTrackID();
      var representationID = "gen-image-rep-" + generateSupplementaryTrackID();
      var newAdaptation = new manifest_adaptation["b" /* default */]({
        id: adaptationID,
        type: "image",
        representations: [{
          bitrate: 0,
          id: representationID,
          mimeType: mimeType,
          index: new representation_index_static["a" /* default */]({
            media: url
          })
        }]
      }, {
        isManuallyAdded: true
      });

      (_this2$parsingErrors = _this2.parsingErrors).push.apply(_this2$parsingErrors, newAdaptation.parsingErrors);

      return newAdaptation;
    });

    if (newImageTracks.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.image = adaptations.image != null ? adaptations.image.concat(newImageTracks) : newImageTracks;
    }
  }
  /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} textTracks
   */
  ;

  _proto.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(
  /* tslint:disable deprecation */
  textTracks
  /* tslint:enable deprecation */
  ) {
    var _this3 = this;

    var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];

    var newTextAdaptations = _textTracks.reduce(function (allSubs, _ref3) {
      var mimeType = _ref3.mimeType,
          codecs = _ref3.codecs,
          url = _ref3.url,
          language = _ref3.language,
          languages = _ref3.languages,
          closedCaption = _ref3.closedCaption;
      var langsToMapOn = language != null ? [language] : languages != null ? languages : [];
      return allSubs.concat(langsToMapOn.map(function (_language) {
        var _this3$parsingErrors;

        var adaptationID = "gen-text-ada-" + generateSupplementaryTrackID();
        var representationID = "gen-text-rep-" + generateSupplementaryTrackID();
        var newAdaptation = new manifest_adaptation["b" /* default */]({
          id: adaptationID,
          type: "text",
          language: _language,
          closedCaption: closedCaption,
          representations: [{
            bitrate: 0,
            id: representationID,
            mimeType: mimeType,
            codecs: codecs,
            index: new representation_index_static["a" /* default */]({
              media: url
            })
          }]
        }, {
          isManuallyAdded: true
        });

        (_this3$parsingErrors = _this3.parsingErrors).push.apply(_this3$parsingErrors, newAdaptation.parsingErrors);

        return newAdaptation;
      }));
    }, []);

    if (newTextAdaptations.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.text = adaptations.text != null ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
    }
  }
  /**
   * @param {Object} newManifest
   * @param {number} type
   */
  ;

  _proto._performUpdate = function _performUpdate(newManifest, updateType) {
    this.availabilityStartTime = newManifest.availabilityStartTime;
    this.expired = newManifest.expired;
    this.isDynamic = newManifest.isDynamic;
    this.isLive = newManifest.isLive;
    this.lifetime = newManifest.lifetime;
    this.maximumTime = newManifest.maximumTime;
    this.parsingErrors = newManifest.parsingErrors;
    this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
    this.transport = newManifest.transport;

    if (updateType === MANIFEST_UPDATE_TYPE.Full) {
      this.minimumTime = newManifest.minimumTime;
      this.uris = newManifest.uris;
      replacePeriods(this.periods, newManifest.periods);
    } else {
      updatePeriods(this.periods, newManifest.periods); // Partial updates do not remove old Periods.
      // This can become a memory problem when playing a content long enough.
      // Let's clean manually Periods behind the minimum possible position.

      var min = this.getMinimumPosition();

      while (this.periods.length > 0) {
        var period = this.periods[0];

        if (period.end === undefined || period.end > min) {
          break;
        }

        this.periods.shift();
      }
    } // Re-set this.adaptations for retro-compatibility in v3.x.x

    /* tslint:disable:deprecation */


    this.adaptations = this.periods[0] === undefined ? {} : this.periods[0].adaptations;
    /* tslint:enable:deprecation */
    // Let's trigger events at the end, as those can trigger side-effects.
    // We do not want the current Manifest object to be incomplete when those
    // happen.

    this.trigger("manifestUpdate", null);
  };

  return Manifest;
}(event_emitter["a" /* default */]);
/**
 * Update decipherability based on a predicate given.
 * Do nothing for a Representation when the predicate returns false, mark as
 * undecipherable when the predicate returns false. Returns every updates in
 * an array.
 * @param {Manifest} manifest
 * @param {Function} predicate
 * @returns {Array.<Object>}
 */




function updateDeciperability(manifest, predicate) {
  var updates = [];

  for (var i = 0; i < manifest.periods.length; i++) {
    var period = manifest.periods[i];
    var adaptations = period.getAdaptations();

    for (var j = 0; j < adaptations.length; j++) {
      var adaptation = adaptations[j];
      var representations = adaptation.representations;

      for (var k = 0; k < representations.length; k++) {
        var representation = representations[k];

        if (!predicate(representation)) {
          updates.push({
            manifest: manifest,
            period: period,
            adaptation: adaptation,
            representation: representation
          });
          representation.decipherable = false;
        }
      }
    }
  }

  return updates;
}
// CONCATENATED MODULE: ./src/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/* harmony default export */ var manifest = __webpack_exports__["a"] = (manifest_Manifest);


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isFunction; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return resolveURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return normalizeBaseURL; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Scheme part of an url (e.g. "http://").
var schemeRe = /^(?:[a-z]+:)?\/\//i; // Captures "/../" or "/./".

var selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */

function _normalizeUrl(url) {
  // fast path if no ./ or ../ are present in the url
  if (!selfDirRe.test(url)) {
    return url;
  }

  var newUrl = [];
  var oldUrl = url.split("/");

  for (var i = 0, l = oldUrl.length; i < l; i++) {
    if (oldUrl[i] === "..") {
      newUrl.pop();
    } else if (oldUrl[i] === ".") {
      continue;
    } else {
      newUrl.push(oldUrl[i]);
    }
  }

  return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */


function resolveURL() {
  var len = arguments.length;

  if (len === 0) {
    return "";
  }

  var base = "";

  for (var i = 0; i < len; i++) {
    var part = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof part !== "string" || part === "") {
      continue;
    }

    if (schemeRe.test(part)) {
      base = part;
    } else {
      // trim if begins with "/"
      if (part[0] === "/") {
        part = part.substring(1);
      } // trim if ends with "/"


      if (base[base.length - 1] === "/") {
        base = base.substring(0, base.length - 1);
      }

      base = base + "/" + part;
    }
  }

  return _normalizeUrl(base);
}
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */

function normalizeBaseURL(url) {
  var indexOfLastSlash = url.lastIndexOf("/");

  if (indexOfLastSlash < 0) {
    return url;
  }

  if (schemeRe.test(url)) {
    var firstSlashIndex = url.indexOf("/");

    if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {
      // The "/" detected is actually the one from the protocol part of the URL
      // ("https://")
      return url;
    }
  }

  var indexOfQuestionMark = url.indexOf("?");

  if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {
    // There are query parameters. Let's ignore them and re-run the logic
    // without
    return normalizeBaseURL(url.substring(0, indexOfQuestionMark));
  }

  return url.substring(0, indexOfLastSlash + 1);
}



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getFirstLineAfterHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isStartOfCueBlock; });
/* unused harmony export isStartOfNoteBlock */
/* unused harmony export isStartOfRegionBlock */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isStartOfStyleBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findEndOfCueBlock; });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */

function getFirstLineAfterHeader(linified) {
  var i = 0;

  while (i < linified.length) {
    if (linified[i] === "") {
      return i + 1;
    }

    i++;
  }

  return i;
}
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfStyleBlock(lines, index) {
  return typeof lines[index] === "string" && /^STYLE( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "STYLE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfNoteBlock(lines, index) {
  return typeof lines[index] === "string" && /^NOTE( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "NOTE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfRegionBlock(lines, index) {
  return typeof lines[index] === "string" && /^REGION( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "REGION". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */


function isStartOfCueBlock(lines, index) {
  // checked cases:
  //   - empty lines
  //   - start of a comment
  //   - start of a region
  //   - start of a style
  // Anything else whose first or second line is a timestamp line is a cue.
  var firstLine = lines[index];

  if (firstLine === undefined || firstLine === "" || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) {
    return false;
  }

  if (firstLine.indexOf("-->") >= 0) {
    return true;
  }

  var secondLine = lines[index + 1];
  return secondLine !== undefined && secondLine.indexOf("-->") >= 0;
}
/**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */


function findEndOfCueBlock(linified, startOfCueBlock) {
  var firstEmptyLineIndex = startOfCueBlock + 1; // continue incrementing i until either:
  //   - empty line
  //   - end

  while (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }

  return firstEmptyLineIndex;
}



/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ from; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
var subscribeTo = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var symbol_observable = __webpack_require__(61);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */



function scheduleObservable(input, scheduler) {
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        sub.add(scheduler.schedule(function () {
            var observable = input[symbol_observable["a" /* observable */]]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function schedulePromise(input, scheduler) {
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}
//# sourceMappingURL=schedulePromise.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
var scheduleArray = __webpack_require__(87);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(76);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */



function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[symbol_iterator["a" /* iterator */]]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleIterable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
    return input && typeof input[symbol_observable["a" /* observable */]] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(113);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(111);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
    return input && typeof input[symbol_iterator["a" /* iterator */]] === 'function';
}
//# sourceMappingURL=isIterable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */








function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        else if (Object(isPromise["a" /* isPromise */])(input)) {
            return schedulePromise(input, scheduler);
        }
        else if (Object(isArrayLike["a" /* isArrayLike */])(input)) {
            return Object(scheduleArray["a" /* scheduleArray */])(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=scheduled.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */



function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable["a" /* Observable */]) {
            return input;
        }
        return new Observable["a" /* Observable */](Object(subscribeTo["a" /* subscribeTo */])(input));
    }
    else {
        return scheduled(input, scheduler);
    }
}
//# sourceMappingURL=from.js.map


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hostReportError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
//# sourceMappingURL=hostReportError.js.map


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WebKitMediaKeysConstructor; });
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var WebKitMediaKeysConstructor;

if (!_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {
  /* tslint:disable no-unsafe-any */
  var _window = window,
      WebKitMediaKeys = _window.WebKitMediaKeys;

  if (WebKitMediaKeys !== undefined && typeof WebKitMediaKeys.isTypeSupported === "function" && typeof WebKitMediaKeys.prototype.createSession === "function" && typeof HTMLMediaElement.prototype.webkitSetMediaKeys === "function") {
    WebKitMediaKeysConstructor = WebKitMediaKeys;
  }
  /* tslint:enable no-unsafe-any */

}



/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ SUPPORTED_ADAPTATIONS_TYPE; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ adaptation_Adaptation; });

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(59);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(57);

// CONCATENATED MODULE: ./src/utils/uniq.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromFilter(arr) {
  return arr.filter(function (val, i, self) {
    return self.indexOf(val) === i;
  });
}
/**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */


function uniqFromSet(arr) {
  return Array.from(new Set(arr));
}
/**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */


/* harmony default export */ var uniq = (typeof window !== "undefined" && typeof window.Set === "function" ? uniqFromSet : uniqFromFilter);

// EXTERNAL MODULE: ./src/manifest/representation.ts
var manifest_representation = __webpack_require__(106);

// CONCATENATED MODULE: ./src/manifest/adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** List in an array every possible value for the Adaptation's `type` property. */

var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];
/**
 * Returns true if the given Adaptation's `type` is a valid `type` property.
 * @param {string} adaptationType
 * @returns {boolean}
 */

function isSupportedAdaptationType(adaptationType) {
  return Object(array_includes["a" /* default */])(SUPPORTED_ADAPTATIONS_TYPE, adaptationType);
}
/**
 * Normalized Adaptation structure.
 * An Adaptation describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */


var adaptation_Adaptation = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} parsedAdaptation
   * @param {Object|undefined} [options]
   */
  function Adaptation(parsedAdaptation, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        representationFilter = _options.representationFilter,
        isManuallyAdded = _options.isManuallyAdded;
    this.parsingErrors = [];
    this.id = parsedAdaptation.id;

    if (!isSupportedAdaptationType(parsedAdaptation.type)) {
      log["a" /* default */].info("Manifest: Not supported adaptation type", parsedAdaptation.type);
      throw new media_error["a" /* default */]("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", "\"" + parsedAdaptation.type + "\" is not a valid " + "Adaptation type.");
    }

    this.type = parsedAdaptation.type;

    if (parsedAdaptation.language !== undefined) {
      this.language = parsedAdaptation.language;
      this.normalizedLanguage = Object(languages["a" /* default */])(parsedAdaptation.language);
    }

    if (parsedAdaptation.closedCaption !== undefined) {
      this.isClosedCaption = parsedAdaptation.closedCaption;
    }

    if (parsedAdaptation.audioDescription !== undefined) {
      this.isAudioDescription = parsedAdaptation.audioDescription;
    }

    if (parsedAdaptation.isDub !== undefined) {
      this.isDub = parsedAdaptation.isDub;
    }

    if (parsedAdaptation.isSignInterpreted !== undefined) {
      this.isSignInterpreted = parsedAdaptation.isSignInterpreted;
    }

    var argsRepresentations = parsedAdaptation.representations;
    var representations = [];
    var decipherable = false;
    var isSupported = false;

    for (var i = 0; i < argsRepresentations.length; i++) {
      var representation = new manifest_representation["a" /* default */](argsRepresentations[i], {
        type: this.type
      });
      var shouldAdd = Object(is_null_or_undefined["a" /* default */])(representationFilter) || representationFilter(representation, {
        bufferType: this.type,
        language: this.language,
        normalizedLanguage: this.normalizedLanguage,
        isClosedCaption: this.isClosedCaption,
        isDub: this.isDub,
        isAudioDescription: this.isAudioDescription,
        isSignInterpreted: this.isSignInterpreted
      });

      if (shouldAdd) {
        representations.push(representation);

        if (decipherable === false && representation.decipherable !== false) {
          decipherable = representation.decipherable;
        }

        if (!isSupported && representation.isSupported) {
          isSupported = true;
        }
      }
    }

    representations.sort(function (a, b) {
      return a.bitrate - b.bitrate;
    });
    this.representations = representations;
    this.decipherable = decipherable;
    this.isSupported = isSupported; // for manuallyAdded adaptations (not in the manifest)

    this.manuallyAdded = isManuallyAdded === true;

    if (this.representations.length > 0 && !isSupported) {
      log["a" /* default */].warn("Incompatible codecs for adaptation", parsedAdaptation);
      var error = new media_error["a" /* default */]("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.");
      this.parsingErrors.push(error);
    }
  }
  /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */


  var _proto = Adaptation.prototype;

  _proto.getAvailableBitrates = function getAvailableBitrates() {
    var bitrates = [];

    for (var i = 0; i < this.representations.length; i++) {
      var representation = this.representations[i];

      if (representation.decipherable !== false) {
        bitrates.push(representation.bitrate);
      }
    }

    return uniq(bitrates);
  }
  /**
   * Returns all Representation in this Adaptation that can be played (that is:
   * not undecipherable and with a supported codec).
   * @returns {Array.<Representation>}
   */
  ;

  _proto.getPlayableRepresentations = function getPlayableRepresentations() {
    return this.representations.filter(function (rep) {
      return rep.isSupported && rep.decipherable !== false;
    });
  }
  /**
   * Returns the Representation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */
  ;

  _proto.getRepresentation = function getRepresentation(wantedId) {
    return Object(array_find["a" /* default */])(this.representations, function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  return Adaptation;
}();



/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return errorMessage; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
  return name + " (" + code + ") " + reason;
}

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getSymbolIterator */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return iterator; });
/* unused harmony export $$iterator */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;
//# sourceMappingURL=iterator.js.map


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fromArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__[/* subscribeToArray */ "a"])(input));
    }
    else {
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__[/* scheduleArray */ "a"])(input, scheduler);
    }
}
//# sourceMappingURL=fromArray.js.map


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export objectValues */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */
function objectValues(o) {
  return Object.keys(o).map(function (k) {
    return o[k];
  });
}
/* tslint:disable no-unbound-method */


/* harmony default export */ __webpack_exports__["a"] = (typeof Object.values === "function" ? Object.values : objectValues);
/* tslint:enable no-unbound-method */



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OtherError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @class OtherError
 * @extends Error
 */

var OtherError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(OtherError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function OtherError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), OtherError.prototype);
    _this.name = "OtherError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_3__[/* ErrorTypes */ "b"].OTHER_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return OtherError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findCompleteBox; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */

function findCompleteBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;

  while (i + 8 <= len) {
    var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i);

    if (size === 0) {
      size = len - i;
    } else if (size === 1) {
      if (i + 16 > len) {
        return -1;
      }

      size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be8toi */ "d"])(buf, i + 8);
    }

    if (isNaN(size) || size <= 0) {
      // should not happen
      return -1;
    }

    var name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 4);

    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }

      return -1;
    }

    i += size;
  }

  return -1;
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ensureCallable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

var byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		ensureCallable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
		return process.nextTick;
	}

	// queueMicrotask
	if (typeof queueMicrotask === "function") {
		return function (cb) { queueMicrotask(ensureCallable(cb)); };
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(ensureCallable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(ensureCallable(cb), 0); };
	}

	return null;
}());


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rxSubscriber; });
/* unused harmony export $$rxSubscriber */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();
var $$rxSubscriber = rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNumeric; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
    return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__[/* isArray */ "a"])(val) && (val - parseFloat(val) + 1) >= 0;
}
//# sourceMappingURL=isNumeric.js.map


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filterMap; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(159);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Special kind of map which will ignore the result when the value emitted
 * corresponds to a given token.
 *
 * This can also be performed through a `mergeMap` (by returning the `EMPTY`
 * Observable when we want to ignore events) but using `filterMap` is both more
 * straightforward and more performant.
 * @param {function} callback
 * @param {*} filteringToken
 * @returns {function}
 */

function filterMap(callback, filteringToken) {
  return function (source) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
      return source.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* map */ "a"])(callback), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* filter */ "a"])(function (x) {
        return x !== filteringToken;
      }));
    });
  };
}

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NotificationKind */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Notification; });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(this.value);
            case 'E':
                return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(this.error);
            case 'C':
                return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__[/* empty */ "b"])();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

//# sourceMappingURL=Notification.js.map


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__[/* from */ "a"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "b"])();
        return source.subscribe(subscriber);
    });
}
//# sourceMappingURL=defer.js.map


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return scheduleArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function scheduleArray(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ "a"]();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleArray.js.map


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OuterSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

//# sourceMappingURL=OuterSubscriber.js.map


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getParentElementsByTagName; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
  if (!(element.parentNode instanceof Element)) {
    return [];
  }

  function constructArray(_element) {
    var elements = [];

    if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
      elements.push(_element);
    }

    var parentNode = _element.parentNode;

    if (parentNode instanceof Element) {
      elements.push.apply(elements, constructArray(parentNode));
    }

    return elements;
  }

  return constructArray(element.parentNode);
}

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ subscribeTo; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray = __webpack_require__(112);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/hostReportError.js
var hostReportError = __webpack_require__(72);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError["a" /* hostReportError */]);
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToPromise.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(76);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[symbol_iterator["a" /* iterator */]]();
        do {
            var item = void 0;
            try {
                item = iterator.next();
            }
            catch (err) {
                subscriber.error(err);
                return subscriber;
            }
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToIterable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(61);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable["a" /* observable */]]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};
//# sourceMappingURL=subscribeToObservable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(111);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(113);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(108);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */









var subscribeTo = function (result) {
    if (!!result && typeof result[observable["a" /* observable */]] === 'function') {
        return subscribeToObservable(result);
    }
    else if (Object(isArrayLike["a" /* isArrayLike */])(result)) {
        return Object(subscribeToArray["a" /* subscribeToArray */])(result);
    }
    else if (Object(isPromise["a" /* isPromise */])(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[symbol_iterator["a" /* iterator */]] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = Object(isObject["a" /* isObject */])(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ abstract_source_buffer_AbstractSourceBuffer; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(81);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(43);

// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(22);

// CONCATENATED MODULE: ./src/custom_source_buffers/time_ranges.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */

var time_ranges_ManualTimeRanges = /*#__PURE__*/function () {
  function ManualTimeRanges() {
    this._ranges = [];
    this.length = 0;
  }

  var _proto = ManualTimeRanges.prototype;

  _proto.insert = function insert(start, end) {
    if (false) {}

    Object(ranges["i" /* insertInto */])(this._ranges, {
      start: start,
      end: end
    });
    this.length = this._ranges.length;
  };

  _proto.remove = function remove(start, end) {
    if (false) {}

    var rangesToIntersect = [];

    if (start > 0) {
      rangesToIntersect.push({
        start: 0,
        end: start
      });
    }

    if (end < Infinity) {
      rangesToIntersect.push({
        start: end,
        end: Infinity
      });
    }

    this._ranges = Object(ranges["l" /* keepRangeIntersection */])(this._ranges, rangesToIntersect);
    this.length = this._ranges.length;
  };

  _proto.start = function start(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }

    return this._ranges[index].start;
  };

  _proto.end = function end(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }

    return this._ranges[index].end;
  };

  return ManualTimeRanges;
}();


// CONCATENATED MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */

var abstract_source_buffer_AbstractSourceBuffer = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(AbstractSourceBuffer, _EventEmitter);

  function AbstractSourceBuffer() {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this.updating = false;
    _this.readyState = "opened";
    _this.buffered = new time_ranges_ManualTimeRanges();
    _this.timestampOffset = 0;
    _this.appendWindowStart = 0;
    _this.appendWindowEnd = Infinity;
    return _this;
  }
  /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append a segment to the
   * buffer.
   * @param {*} data
   */


  var _proto = AbstractSourceBuffer.prototype;

  _proto.appendBuffer = function appendBuffer(data) {
    var _this2 = this;

    this._lock(function () {
      return _this2._append(data);
    });
  }
  /**
   * Mimic the SourceBuffer _remove_ method: remove buffered segments.
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.remove = function remove(from, to) {
    var _this3 = this;

    this._lock(function () {
      return _this3._remove(from, to);
    });
  }
  /**
   * Call `appendBuffer` synchronously (do not wait for nextTick).
   * @param {*} data
   */
  ;

  _proto.appendBufferSync = function appendBufferSync(data) {
    var _this4 = this;

    this._lockSync(function () {
      return _this4._append(data);
    });
  }
  /**
   * Call `remove` synchronously (do not wait for nextTick).
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.removeSync = function removeSync(from, to) {
    var _this5 = this;

    this._lockSync(function () {
      return _this5._remove(from, to);
    });
  }
  /**
   * Mimic the SourceBuffer _abort_ method.
   */
  ;

  _proto.abort = function abort() {
    this.updating = false;
    this.readyState = "closed";

    this._abort();
  }
  /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */
  ;

  _proto._lock = function _lock(func) {
    var _this6 = this;

    if (this.updating) {
      throw new Error("SourceBuffer: SourceBuffer already updating.");
    }

    this.updating = true;
    this.trigger("updatestart", undefined);
    var result = Object(rx_try_catch["a" /* default */])(function () {
      func();
      return Object(of["a" /* of */])(undefined);
    }, undefined);
    result.subscribe(function () {
      return next_tick_default()(function () {
        _this6.updating = false;

        _this6.trigger("update", undefined);

        _this6.trigger("updateend", undefined);
      });
    }, function (e) {
      return next_tick_default()(function () {
        _this6.updating = false;

        _this6.trigger("error", e);

        _this6.trigger("updateend", undefined);
      });
    });
  }
  /**
   * Call SourceBuffer function but throw errors and emit events synchronously.
   * Throws if another function is already active.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   * @param {*} data
   */
  ;

  _proto._lockSync = function _lockSync(func) {
    if (this.updating) {
      throw new Error("SourceBuffer: SourceBuffer already updating.");
    }

    this.updating = true;
    this.trigger("updatestart", undefined);

    try {
      func();
    } catch (e) {
      this.updating = false;
      this.trigger("error", e);
      this.trigger("updateend", undefined);
      throw e;
    }

    this.updating = false;
    this.trigger("update", undefined);
    this.trigger("updateend", undefined);
  };

  return AbstractSourceBuffer;
}(event_emitter["a" /* default */]);



/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ AsyncScheduler_AsyncScheduler; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */


var AsyncScheduler_AsyncScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

//# sourceMappingURL=AsyncScheduler.js.map


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ AsyncAction_AsyncAction; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/Action.js
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var Action_Action = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription["a" /* Subscription */]));

//# sourceMappingURL=Action.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */


var AsyncAction_AsyncAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_Action));

//# sourceMappingURL=AsyncAction.js.map


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ subscribeToResult; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var InnerSubscriber_InnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber["a" /* Subscriber */]));

//# sourceMappingURL=InnerSubscriber.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
var subscribeTo = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) {
        innerSubscriber = new InnerSubscriber_InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable["a" /* Observable */]) {
        return result.subscribe(innerSubscriber);
    }
    return Object(subscribeTo["a" /* subscribeTo */])(result)(innerSubscriber);
}
//# sourceMappingURL=subscribeToResult.js.map


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return empty; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__[/* hostReportError */ "a"])(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fetchIsSupported; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(146);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3);



/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var DEFAULT_REQUEST_TIMEOUT = _config__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].DEFAULT_REQUEST_TIMEOUT;

var _Headers = typeof Headers === "function" ? Headers : null;

var _AbortController = typeof AbortController === "function" ? AbortController : null;

function fetchRequest(options) {
  var headers;

  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(options.headers)) {
    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(_Headers)) {
      headers = options.headers;
    } else {
      headers = new _Headers();
      var headerNames = Object.keys(options.headers);

      for (var i = 0; i < headerNames.length; i++) {
        var headerName = headerNames[i];
        headers.append(headerName, options.headers[headerName]);
      }
    }
  }

  return new rxjs__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ "a"](function (obs) {
    _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].debug("Fetch: Called with URL", options.url);
    var hasAborted = false;
    var timeouted = false;
    var isDone = false;
    var sendingTime = performance.now();
    var abortController = !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(_AbortController) ? new _AbortController() : null;
    /**
     * Abort current fetchRequest by triggering AbortController signal.
     * @returns {void}
     */

    function abortRequest() {
      if (!isDone) {
        if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(abortController)) {
          return abortController.abort();
        }

        _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].warn("Fetch: AbortController API not available.");
      }
    }

    var requestTimeout = Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(options.timeout) ? DEFAULT_REQUEST_TIMEOUT : options.timeout;
    var timeout = window.setTimeout(function () {
      timeouted = true;
      abortRequest();
    }, requestTimeout);
    fetch(options.url, {
      headers: headers,
      method: "GET",
      signal: !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(abortController) ? abortController.signal : undefined
    }).then(function (response) {
      if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(timeout)) {
        clearTimeout(timeout);
      }

      if (response.status >= 300) {
        _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].warn("Fetch: Request HTTP Error", response);
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_5__[/* NetworkErrorTypes */ "c"].ERROR_HTTP_CODE));
        return undefined;
      }

      if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(response.body)) {
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_5__[/* NetworkErrorTypes */ "c"].PARSE_ERROR));
        return undefined;
      }

      var contentLengthHeader = response.headers.get("Content-Length");
      var contentLength = !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(contentLengthHeader) && !isNaN(+contentLengthHeader) ? +contentLengthHeader : undefined;
      var reader = response.body.getReader();
      var size = 0;
      return readBufferAndSendEvents();

      function readBufferAndSendEvents() {
        return _readBufferAndSendEvents.apply(this, arguments);
      }

      function _readBufferAndSendEvents() {
        _readBufferAndSendEvents = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
          var data, currentTime, dataChunk, receivedTime, duration;
          return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return reader.read();

                case 2:
                  data = _context.sent;

                  if (!(!data.done && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(data.value))) {
                    _context.next = 11;
                    break;
                  }

                  size += data.value.byteLength;
                  currentTime = performance.now();
                  dataChunk = {
                    type: "data-chunk",
                    value: {
                      url: response.url,
                      currentTime: currentTime,
                      duration: currentTime - sendingTime,
                      sendingTime: sendingTime,
                      chunkSize: data.value.byteLength,
                      chunk: data.value.buffer,
                      size: size,
                      totalSize: contentLength
                    }
                  };
                  obs.next(dataChunk);
                  return _context.abrupt("return", readBufferAndSendEvents());

                case 11:
                  if (data.done) {
                    receivedTime = performance.now();
                    duration = receivedTime - sendingTime;
                    isDone = true;
                    obs.next({
                      type: "data-complete",
                      value: {
                        duration: duration,
                        receivedTime: receivedTime,
                        sendingTime: sendingTime,
                        size: size,
                        status: response.status,
                        url: response.url
                      }
                    });
                    obs.complete();
                  }

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _readBufferAndSendEvents.apply(this, arguments);
      }
    })["catch"](function (err) {
      if (hasAborted) {
        _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].debug("Fetch: Request aborted.");
        return;
      }

      if (timeouted) {
        _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].warn("Fetch: Request timeouted.");
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_5__[/* NetworkErrorTypes */ "c"].TIMEOUT));
        return;
      }

      _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].warn("Fetch: Request Error", err instanceof Error ? err.toString() : "");
      obs.error(new _errors__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_5__[/* NetworkErrorTypes */ "c"].ERROR_EVENT));
      return;
    });
    return function () {
      hasAborted = true;
      abortRequest();
    };
  });
}
/**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */


function fetchIsSupported() {
  return typeof window.fetch === "function" && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(_AbortController) && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(_Headers);
}
/* harmony default export */ __webpack_exports__["a"] = (fetchRequest);

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearElementSrc; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Clear element's src attribute.
 * @param {HTMLMediaElement} element
 */

function clearElementSrc(element) {
  // On Firefox, we also have to make sure the textTracks elements are both
  // disabled and removed from the DOM.
  // If we do not do that, we may be left with displayed text tracks on the
  // screen
  if (_browser_detection__WEBPACK_IMPORTED_MODULE_1__[/* isFirefox */ "b"]) {
    var textTracks = element.textTracks;

    for (var i = 0; i < textTracks.length; i++) {
      textTracks[i].mode = "disabled";
    }

    if (element.hasChildNodes()) {
      var childNodes = element.childNodes;

      for (var j = childNodes.length - 1; j >= 0; j--) {
        if (childNodes[j].nodeName === "track") {
          try {
            element.removeChild(childNodes[j]);
          } catch (err) {
            _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Could not remove text track child from element.");
          }
        }
      }
    }
  }

  element.src = ""; // On IE11, element.src = "" is not sufficient as it
  // does not clear properly the current MediaKey Session.
  // Microsoft recommended to use element.removeAttr("src").

  element.removeAttribute("src");
}

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return throwError; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return flatMap; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>}originalArray
 * @param {Function}fn
 */
function flatMap(originalArray, fn) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.flatMap === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable no-unsafe-any */
    return originalArray.flatMap(fn);
    /* tslint:enable no-unsafe-any */
  }

  return originalArray.reduce(function (acc, arg) {
    var r = fn(arg);

    if (Array.isArray(r)) {
      acc.push.apply(acc, r);
      return acc;
    }

    acc.push(r);
    return acc;
  }, []);
}

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MAX_32_BIT_INT; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Maximum integer that can be stored on 32 bits.
 *
 * This can be used for example to know what is the maximum ISOBMFF box size
 * that can be stored on the first four bytes of a box. Any value higher than
 * that will need 8 bytes (64 bits) to be stored.
 */
var MAX_32_BIT_INT = Math.pow(2, 32) - 1;

/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkISOBMFFIntegrity; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _find_complete_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if an ISOBMFF segment has all the right box needed to be decoded.
 * Throw if that's not the case.
 * @param {Uint8Array} buffer - The whole ISOBMFF segment
 * @param {boolean} isInitSegment - `true` if this is an initialization segment,
 * `false` otherwise.
 */

function checkISOBMFFIntegrity(buffer, isInitSegment) {
  if (isInitSegment) {
    var ftypIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x66747970
    /* ftyp */
    );

    if (ftypIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `ftyp` box");
    }

    var moovIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D6F6F76
    /* moov */
    );

    if (moovIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `moov` box");
    }
  } else {
    var moofIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D6F6F66
    /* moof */
    );

    if (moofIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `moof` box");
    }

    var mdatIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `mdat` box");
    }
  }
}

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ multicast; });

// UNUSED EXPORTS: MulticastOperator

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(127);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */






var ConnectableObservable_ConnectableObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription["a" /* Subscription */]();
            connection.add(this.source
                .subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription["a" /* Subscription */].EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return Object(refCount["a" /* refCount */])()(this);
    };
    return ConnectableObservable;
}(Observable["a" /* Observable */]));

var connectableObservableDescriptor = /*@__PURE__*/ (function () {
    var connectableProto = ConnectableObservable_ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableObservable_ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject["b" /* SubjectSubscriber */]));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new ConnectableObservable_RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var ConnectableObservable_RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=ConnectableObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concat; });
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(176);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */


function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__[/* concatAll */ "a"])()(_of__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"].apply(void 0, observables));
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EncryptedMediaError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */

var EncryptedMediaError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(EncryptedMediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @Param {Boolean} fatal
   */
  function EncryptedMediaError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), EncryptedMediaError.prototype);
    _this.name = "EncryptedMediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_3__[/* ErrorTypes */ "b"].ENCRYPTED_MEDIA_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return EncryptedMediaError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return requestFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exitFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isFullscreen; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 */
function requestFullscreen(element) {
  if (!isFullscreen()) {
    var elt = element;
    /* tslint:disable no-unbound-method */

    if (typeof elt.requestFullscreen === "function") {
      /* tslint:enable no-unbound-method */

      /* tslint:disable no-floating-promises */
      elt.requestFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (typeof elt.msRequestFullscreen === "function") {
      elt.msRequestFullscreen();
    } else if (typeof elt.mozRequestFullScreen === "function") {
      elt.mozRequestFullScreen();
    } else if (typeof elt.webkitRequestFullscreen === "function") {
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}
/**
 * Exit fullscreen if an element is currently in fullscreen.
 */


function exitFullscreen() {
  if (isFullscreen()) {
    var doc = document;
    /* tslint:disable no-unbound-method */

    if (typeof doc.exitFullscreen === "function") {
      /* tslint:enable no-unbound-method */

      /* tslint:disable no-floating-promises */
      doc.exitFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (typeof doc.msExitFullscreen === "function") {
      doc.msExitFullscreen();
    } else if (typeof doc.mozCancelFullScreen === "function") {
      doc.mozCancelFullScreen();
    } else if (typeof doc.webkitExitFullscreen === "function") {
      doc.webkitExitFullscreen();
    }
  }
}
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */


function isFullscreen() {
  var doc = document;
  return doc.fullscreenElement != null || doc.mozFullScreenElement != null || doc.webkitFullscreenElement != null || doc.msFullscreenElement != null;
}



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalized Representation structure.
 * @class Representation
 */

var Representation = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function Representation(args, opts) {
    this.id = args.id;
    this.bitrate = args.bitrate;
    this.codec = args.codecs;

    if (args.height != null) {
      this.height = args.height;
    }

    if (args.width != null) {
      this.width = args.width;
    }

    if (args.mimeType != null) {
      this.mimeType = args.mimeType;
    }

    if (args.contentProtections !== undefined) {
      this.contentProtections = args.contentProtections;
    }

    if (args.frameRate != null) {
      this.frameRate = args.frameRate;
    }

    this.index = args.index;
    this.isSupported = opts.type === "audio" || opts.type === "video" ? Object(_compat__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this.getMimeTypeString()) : true; // TODO for other types
  }
  /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */


  var _proto = Representation.prototype;

  _proto.getMimeTypeString = function getMimeTypeString() {
    var _a, _b;

    return ((_a = this.mimeType) !== null && _a !== void 0 ? _a : "") + ";codecs=\"" + ((_b = this.codec) !== null && _b !== void 0 ? _b : "") + "\"";
  }
  /**
   * Returns every protection initialization data concatenated.
   * This data can then be used through the usual EME APIs.
   * `null` if this Representation has no detected protection initialization
   * data.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getProtectionsInitializationData = function getProtectionsInitializationData() {
    var contentProtections = this.contentProtections;

    if (contentProtections === undefined) {
      return [];
    }

    return Object.keys(contentProtections.initData).reduce(function (acc, initDataType) {
      var initDataArr = contentProtections.initData[initDataType];

      if (initDataArr === undefined || initDataArr.length === 0) {
        return acc;
      }

      var initData = _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* concat */ "e"].apply(void 0, initDataArr.map(function (_ref) {
        var data = _ref.data;
        return data;
      }));
      acc.push({
        type: initDataType,
        data: initData
      });
      return acc;
    }, []);
  }
  /**
   * Add protection data to the Representation to be able to properly blacklist
   * it if that data is.
   * /!\ Mutates the current Representation
   * @param {string} initDataArr
   * @param {string} systemId
   * @param {Uint8Array} data
   */
  ;

  _proto._addProtectionData = function _addProtectionData(initDataType, systemId, data) {
    var newElement = {
      systemId: systemId,
      data: data
    };

    if (this.contentProtections === undefined) {
      var _initData;

      this.contentProtections = {
        keyIds: [],
        initData: (_initData = {}, _initData[initDataType] = [newElement], _initData)
      };
      return;
    }

    var initDataArr = this.contentProtections.initData[initDataType];

    if (initDataArr === undefined) {
      this.contentProtections.initData[initDataType] = [newElement];
      return;
    }

    for (var i = initDataArr.length - 1; i >= 0; i--) {
      if (initDataArr[i].systemId === systemId) {
        if (Object(_utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(initDataArr[i].data, data)) {
          return;
        }

        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Manifest: Two PSSH for the same system ID");
      }
    }

    initDataArr.push(newElement);
  };

  return Representation;
}();

/* harmony default export */ __webpack_exports__["a"] = (Representation);

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ normalizeAudioTrack; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ normalizeTextTrack; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
var ISO_MAP_1_TO_3 = {
  aa: "aar",
  ab: "abk",
  ae: "ave",
  af: "afr",
  ak: "aka",
  am: "amh",
  an: "arg",
  ar: "ara",
  as: "asm",
  av: "ava",
  ay: "aym",
  az: "aze",
  ba: "bak",
  be: "bel",
  bg: "bul",
  bi: "bis",
  bm: "bam",
  bn: "ben",
  bo: "bod",
  br: "bre",
  bs: "bos",
  ca: "cat",
  ce: "che",
  ch: "cha",
  co: "cos",
  cr: "cre",
  cs: "ces",
  cu: "chu",
  // Old Slavonic, Old Bulgarian
  cv: "chv",
  cy: "cym",
  da: "dan",
  de: "deu",
  dv: "div",
  dz: "dzo",
  ee: "ewe",
  el: "ell",
  en: "eng",
  eo: "epo",
  es: "spa",
  et: "est",
  eu: "eus",
  fa: "fas",
  ff: "ful",
  fi: "fin",
  fj: "fij",
  fo: "fao",
  fr: "fra",
  fy: "fry",
  ga: "gle",
  gd: "gla",
  gl: "glg",
  gn: "grn",
  gu: "guj",
  gv: "glv",
  ha: "hau",
  he: "heb",
  hi: "hin",
  ho: "hmo",
  hr: "hrv",
  ht: "hat",
  hu: "hun",
  hy: "hye",
  hz: "her",
  ia: "ina",
  id: "ind",
  ie: "ile",
  ig: "ibo",
  ii: "iii",
  ik: "ipk",
  io: "ido",
  is: "isl",
  it: "ita",
  iu: "iku",
  ja: "jpn",
  jv: "jav",
  ka: "kat",
  kg: "kon",
  ki: "kik",
  kj: "kua",
  kk: "kaz",
  kl: "kal",
  km: "khm",
  kn: "kan",
  ko: "kor",
  kr: "kau",
  ks: "kas",
  ku: "kur",
  kv: "kom",
  kw: "cor",
  ky: "kir",
  la: "lat",
  lb: "ltz",
  lg: "lug",
  li: "lim",
  ln: "lin",
  lo: "lao",
  lt: "lit",
  lu: "lub",
  lv: "lav",
  mg: "mlg",
  mh: "mah",
  mi: "mri",
  mk: "mkd",
  ml: "mal",
  mn: "mon",
  mr: "mar",
  ms: "msa",
  mt: "mlt",
  my: "mya",
  na: "nau",
  nb: "nob",
  nd: "nde",
  ne: "nep",
  ng: "ndo",
  nl: "nld",
  nn: "nno",
  no: "nor",
  nr: "nbl",
  nv: "nav",
  ny: "nya",
  oc: "oci",
  oj: "oji",
  om: "orm",
  or: "ori",
  os: "oss",
  pa: "pan",
  pi: "pli",
  pl: "pol",
  ps: "pus",
  pt: "por",
  qu: "que",
  rm: "roh",
  rn: "run",
  ro: "ron",
  ru: "rus",
  rw: "kin",
  sa: "san",
  sc: "srd",
  sd: "snd",
  se: "sme",
  sg: "sag",
  si: "sin",
  sk: "slk",
  sl: "slv",
  sm: "smo",
  sn: "sna",
  so: "som",
  sq: "sqi",
  sr: "srp",
  ss: "ssw",
  st: "sot",
  su: "sun",
  sv: "swe",
  sw: "swa",
  ta: "tam",
  te: "tel",
  tg: "tgk",
  th: "tha",
  ti: "tir",
  tk: "tuk",
  tl: "tgl",
  tn: "tsn",
  to: "ton",
  tr: "tur",
  ts: "tso",
  tt: "tat",
  tw: "twi",
  ty: "tah",
  ug: "uig",
  uk: "ukr",
  ur: "urd",
  uz: "uzb",
  ve: "ven",
  vi: "vie",
  vo: "vol",
  wa: "wln",
  wo: "wol",
  xh: "xho",
  yi: "yid",
  yo: "yor",
  za: "zha",
  zh: "zho",
  zu: "zul"
};
/* harmony default export */ var ISO_639_1_to_ISO_639_3 = (ISO_MAP_1_TO_3);
// CONCATENATED MODULE: ./src/utils/languages/ISO_639-2_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
var ISO_MAP_2_TO_3 = {
  alb: "sqi",
  arm: "hye",
  baq: "eus",
  bur: "mya",
  chi: "zho",
  cze: "ces",
  dut: "nld",
  fre: "fra",
  geo: "kat",
  ger: "deu",
  gre: "ell",
  ice: "isl",
  mac: "mkd",
  mao: "mri",
  may: "msa",
  per: "fas",
  slo: "slk",
  rum: "ron",
  tib: "bod",
  wel: "cym"
};
/* harmony default export */ var ISO_639_2_to_ISO_639_3 = (ISO_MAP_2_TO_3);
// CONCATENATED MODULE: ./src/utils/languages/normalize.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */

function normalizeLanguage(_language) {
  if (Object(is_null_or_undefined["a" /* default */])(_language) || _language === "") {
    return "";
  }

  var fields = ("" + _language).toLowerCase().split("-");

  var base = fields[0];
  var normalizedBase = normalizeBase(base);

  if (Object(is_non_empty_string["a" /* default */])(normalizedBase)) {
    return normalizedBase;
  }

  return _language;
}
/**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */


function normalizeBase(base) {
  var result;

  switch (base.length) {
    case 2:
      result = ISO_639_1_to_ISO_639_3[base];
      break;

    case 3:
      result = ISO_639_2_to_ISO_639_3[base];
      break;
  }

  return result;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */


function normalizeTextTrack(_language) {
  if (!Object(is_null_or_undefined["a" /* default */])(_language)) {
    var language;
    var closedCaption = false;

    if (typeof _language === "string") {
      language = _language;
    } else {
      language = _language.language;

      if (_language.closedCaption === true) {
        closedCaption = true;
      }
    }

    return {
      language: language,
      closedCaption: closedCaption,
      normalized: normalizeLanguage(language)
    };
  }

  return _language;
}
/**
 * Normalize audio track from a user given input into an object
 * with the following properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 *   - isDub {Boolean|undefined}: if true, this is a dub.
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */


function normalizeAudioTrack(_language) {
  if (Object(is_null_or_undefined["a" /* default */])(_language)) {
    return _language;
  }

  if (typeof _language === "string") {
    return {
      language: _language,
      audioDescription: false,
      normalized: normalizeLanguage(_language)
    };
  }

  var normalized = {
    language: _language.language,
    audioDescription: _language.audioDescription === true,
    normalized: normalizeLanguage(normalizeLanguage(_language.language))
  };

  if (_language.isDub === true) {
    normalized.isDub = true;
  }

  return normalized;
}

/* harmony default export */ var normalize = __webpack_exports__["a"] = (normalizeLanguage);


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isObject; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return identity; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeAll; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__[/* identity */ "a"], concurrent);
}
//# sourceMappingURL=mergeAll.js.map


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArrayLike; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return subscribeToArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};
//# sourceMappingURL=subscribeToArray.js.map


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPromise; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isDate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldFavourCustomSafariEME; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _eme_custom_media_keys_webkit_media_keys_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // On Safari 12.1, it seems that since fairplay CDM implementation
// within the browser is not standard with EME w3c current spec, the
// requestMediaKeySystemAccess API doesn't resolve positively, even
// if the drm (fairplay in most cases) is supported.

function shouldFavourCustomSafariEME() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSafari */ "e"] && _eme_custom_media_keys_webkit_media_keys_constructor__WEBPACK_IMPORTED_MODULE_1__[/* WebKitMediaKeysConstructor */ "a"] !== undefined;
}

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SubjectSubscription; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ "a"]));

//# sourceMappingURL=SubjectSubscription.js.map


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArgumentOutOfRangeError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PSSH_TO_INTEGER; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // The way "pssh" will be written in ISOBMFF files

var PSSH_TO_INTEGER = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__[/* strToUtf8 */ "f"])("pssh"), 0);

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getFuzzedDelay; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */

function getFuzzedDelay(retryDelay) {
  var fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
  return retryDelay * (fuzzingFactor + 1); // Max 1.3 Min 0.7
}

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disposeMediaKeys; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(191);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(193);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */

function disposeMediaKeys(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].getState(mediaElement);

    if (currentState === null) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(null);
    }

    _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].info("EME: Disposing of the current MediaKeys");
    var loadedSessionsStore = currentState.loadedSessionsStore;
    _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].clearState(mediaElement);
    return loadedSessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* mergeMapTo */ "a"])(Object(_compat__WEBPACK_IMPORTED_MODULE_3__[/* setMediaKeys */ "b"])(mediaElement, null)));
  });
}

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isSegmentStillAvailable; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURLs of the segment.
 * @param {Object} segment
 * @param {Array.<Object>} timescale
 * @param {number} timeline
 * @returns {Boolean|undefined}
 */
function isSegmentStillAvailable(segment, timeline, timescale, indexTimeOffset) {
  if (timescale !== segment.timescale) {
    // weird case (update?)
    // In any case, it would be over-engineering to do time scaling here.
    return undefined;
  }

  for (var i = 0; i < timeline.length; i++) {
    var tSegment = timeline[i];
    var tSegmentTime = tSegment.start - indexTimeOffset;

    if (tSegmentTime > segment.time) {
      return false;
    } else if (tSegmentTime === segment.time) {
      // there should be only one here
      if (tSegment.duration !== segment.duration) {
        return false;
      }

      if (tSegment.range == null) {
        return segment.range == null;
      }

      return segment.range != null && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1];
    } else {
      // tSegment.start < segment.time
      if (tSegment.repeatCount >= 0 && tSegment.duration != null) {
        var timeDiff = tSegmentTime - tSegment.start;
        var repeat = timeDiff / tSegment.duration - 1;
        return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
      }
    }
  }

  return false;
}

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return updateSegmentTimeline; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _index_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update a complete array of segments in a given timeline with a [generally]
 * smaller but [generally] newer set of segments.
 * @param {Array.<Object>} oldTimeline
 * @param {Array.<Object>} newTimeline
 */

function updateSegmentTimeline(oldTimeline, newTimeline) {
  var prevTimelineLength = oldTimeline.length;

  if (oldTimeline.length === 0) {
    oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
    return;
  }

  if (newTimeline.length === 0) {
    return;
  }

  var newIndexStart = newTimeline[0].start;
  var oldLastElt = oldTimeline[prevTimelineLength - 1];
  var oldIndexEnd = Object(_index_helpers__WEBPACK_IMPORTED_MODULE_2__[/* getIndexSegmentEnd */ "c"])(oldLastElt, newTimeline[0]);

  if (oldIndexEnd < newIndexStart) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
  }

  for (var i = prevTimelineLength - 1; i >= 0; i--) {
    var currStart = oldTimeline[i].start;

    if (currStart === newIndexStart) {
      // replace that one and those after it
      oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
      return;
    } else if (currStart < newIndexStart) {
      // first to be before
      var currElt = oldTimeline[i];

      if (currElt.start + currElt.duration > newIndexStart) {
        // the new Manifest overlaps a previous segment (weird). Remove the latter.
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: Manifest update removed previous segments");
        oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
        return;
      } else if (currElt.repeatCount === undefined || currElt.repeatCount <= 0) {
        if (currElt.repeatCount < 0) {
          currElt.repeatCount = Math.floor((newIndexStart - currElt.start) / currElt.duration) - 1;
        }

        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return;
      } // else, there is a positive repeat we might want to update


      var eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);

      if (eltLastTime <= newIndexStart) {
        // our new index comes directly after
        // put it after this one
        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return;
      }

      var newCurrRepeat = (newIndexStart - currElt.start) / currElt.duration - 1;

      if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {
        var newRepeatCount = newTimeline[0].repeatCount < 0 ? -1 : // === maximum possible repeat
        newTimeline[0].repeatCount + newCurrRepeat + 1; // replace that one and those after it

        oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
        oldTimeline[i].start = currElt.start;
        oldTimeline[i].repeatCount = newRepeatCount;
        return;
      }

      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: Manifest update removed previous segments");
      oldTimeline[i].repeatCount = Math.floor(newCurrRepeat); // put it after this one

      oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
      return;
    }
  } // if we got here, it means that every segments in the previous manifest are
  // after the new one. This is unusual.
  // Either the new one has more depth or it's an older one.


  var prevLastElt = oldTimeline[oldTimeline.length - 1];
  var newLastElt = newTimeline[newTimeline.length - 1];

  if (prevLastElt.repeatCount !== undefined && prevLastElt.repeatCount < 0) {
    if (prevLastElt.start > newLastElt.start) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is older than the previous one");
      return; // the old comes after
    } else {
      // the new has more depth
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
      oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
      return;
    }
  }

  var prevLastTime = prevLastElt.start + prevLastElt.duration * (prevLastElt.repeatCount + 1);
  var newLastTime = newLastElt.start + newLastElt.duration * (newLastElt.repeatCount + 1);

  if (prevLastTime >= newLastTime) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is older than the previous one");
    return; // the old comes after
  } // the new one has more depth. full update


  _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
  oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
  return;
}

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearTimelineFromPosition; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number}
 */
function clearTimelineFromPosition(timeline, firstAvailablePosition) {
  while (timeline.length > 0) {
    var firstElt = timeline[0];

    if (firstElt.start >= firstAvailablePosition) {
      return; // all clear
    }

    if (firstElt.repeatCount <= 0) {
      timeline.shift();
    } else {
      // we have a segment repetition
      var nextElt = timeline[1];

      if (nextElt != null && nextElt.start <= firstAvailablePosition) {
        timeline.shift();
      } else {
        // no next segment or next segment is available
        if (firstElt.duration <= 0) {
          return;
        }

        var nextStart = firstElt.start + firstElt.duration;
        var nextRepeat = 1;

        while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {
          nextStart += firstElt.duration;
          nextRepeat++;
        }

        if (nextRepeat > firstElt.repeatCount) {
          // every start is before
          timeline.shift();
        } else {
          // some repetitions start after and some before
          var newRepeat = firstElt.repeatCount - nextRepeat;
          firstElt.start = nextStart;
          firstElt.repeatCount = newRepeat;
          return;
        }
      }
    }
  }
}

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateManifestLoader; });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(125);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @returns {Observable}
 */

function regularManifestLoader(_ref) {
  var url = _ref.url;

  if (url === undefined) {
    throw new Error("Cannot perform HTTP(s) request. URL not known");
  }

  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
    url: url,
    responseType: "text"
  });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */


function generateManifestLoader(_ref2) {
  var customManifestLoader = _ref2.customManifestLoader;

  if (Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(customManifestLoader)) {
    return regularManifestLoader;
  }

  return Object(_call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(customManifestLoader, regularManifestLoader);
}

/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return callCustomManifestLoader; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
  return function (args) {
    return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
      var url = args.url;
      var timeAPIsDelta = Date.now() - performance.now();
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom manifest loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          var receivedTime = _args.receivingTime !== undefined ? _args.receivingTime - timeAPIsDelta : undefined;
          var sendingTime = _args.sendingTime !== undefined ? _args.sendingTime - timeAPIsDelta : undefined;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration,
              url: _args.url,
              receivedTime: receivedTime,
              sendingTime: sendingTime
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom manifest loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject(err) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };
      /**
       * Callback triggered when the custom manifest loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        fallbackManifestLoader(args).subscribe(obs);
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        fallback: fallback
      };
      var abort = customManifestLoader(url, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  };
}

/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return returnParsedManifest; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(103);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * As a Manifest instance is obtained, emit the right `warning` events
 * (according to the Manifest's `parsingErrors` property`) followed by the right
 * `parsed` event, as expected from a Manifest parser.
 * @param {Manifest} manifest
 * @param {string|undefined} url
 * @returns {Observable}
 */

function returnParsedManifest(manifest, url) {
  var warningEvts$ = rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"].apply(void 0, manifest.parsingErrors.map(function (error) {
    return {
      type: "warning",
      value: error
    };
  }));
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* concat */ "a"])(warningEvts$, Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])({
    type: "parsed",
    value: {
      manifest: manifest,
      url: url
    }
  }));
}

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return refCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=refCount.js.map


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCueBlocks; });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */

function getCueBlocks(linified, headerOffset) {
  var cueBlocks = [];

  for (var i = headerOffset; i < linified.length; i++) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isStartOfCueBlock */ "c"])(linified, i)) {
      var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* findEndOfCueBlock */ "a"])(linified, i);
      cueBlocks.push(linified.slice(i, endOfCue));
      i = endOfCue;
    } else if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[i])) {
        i++;
      }
    }
  }

  return cueBlocks;
}

/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return makeCue; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */

function makeCue(startTime, endTime, payload) {
  if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__[/* VTTCue_ */ "e"] == null) {
    throw new Error("VTT cues not supported in your target");
  }

  if (startTime >= endTime) {
    // IE/Edge will throw in this case.
    // See issue #501
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Invalid cue times: " + startTime + " - " + endTime);
    return null;
  }

  return new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__[/* VTTCue_ */ "e"](startTime, endTime, payload);
}

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getParameters; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var CELL_RESOLUTION_REGEXP = /(\d+) (\d+)/;
/**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */

function getParameters(tt) {
  var parsedFrameRate = tt.getAttribute("ttp:frameRate");
  var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
  var parsedTickRate = tt.getAttribute("ttp:tickRate");
  var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
  var parsedSpaceStyle = tt.getAttribute("xml:space");
  var parsedCellResolution = tt.getAttribute("ttp:cellResolution");
  var cellResolution = {
    columns: 32,
    rows: 15
  };

  if (parsedCellResolution !== null) {
    var extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);

    if (extractedData === null || extractedData.length < 3) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: Invalid cellResolution");
    } else {
      var columns = parseInt(extractedData[1], 10);
      var rows = parseInt(extractedData[2], 10);

      if (isNaN(columns) || isNaN(rows)) {
        _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: Invalid cellResolution");
      } else {
        cellResolution = {
          columns: columns,
          rows: rows
        };
      }
    }
  }

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(parsedSpaceStyle) && parsedSpaceStyle !== "default" && parsedSpaceStyle !== "preserve") {
    throw new Error("Invalid spacing style");
  }

  var nbFrameRate = Number(parsedFrameRate);

  if (isNaN(nbFrameRate) || nbFrameRate <= 0) {
    nbFrameRate = 30;
  }

  var nbSubFrameRate = Number(parsedSubFrameRate);

  if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {
    nbSubFrameRate = 1;
  }

  var nbTickRate = Number(parsedTickRate);

  if (isNaN(nbTickRate) || nbTickRate <= 0) {
    nbTickRate = undefined;
  }

  var frameRate = nbFrameRate;
  var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
  var spaceStyle = parsedSpaceStyle !== null ? parsedSpaceStyle : "default";
  var tickRate = nbTickRate !== undefined ? nbTickRate : nbFrameRate * nbSubFrameRate;

  if (parsedFrameRateMultiplier !== null) {
    var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);

    if (multiplierResults !== null) {
      var numerator = Number(multiplierResults[1]);
      var denominator = Number(multiplierResults[2]);
      var multiplierNum = numerator / denominator;
      frameRate = nbFrameRate * multiplierNum;
    }
  }

  return {
    cellResolution: cellResolution,
    tickRate: tickRate,
    frameRate: frameRate,
    subFrameRate: subFrameRate,
    spaceStyle: spaceStyle
  };
}

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return resolveStylesInheritance; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_array_find_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var _utils_array_includes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _utils_object_assign__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Transform all styles inheriting from other styles to the same styles but with
 * the inheritance removed (by resolving those inheritance here).
 *
 * Note that the original style object is directly mutated with every
 * inheritance they had resolved and removed.
 *
 * To make a pseudo-code analogy this would be equivalent to transform those
 * two classes:
 * ```
 * class A {
 *   methodA() {}
 * }
 *
 * class B extends A {
 *   method B() {}
 * }
 * ```
 * into the same two classes without inheritance:
 * ```
 * class A {
 *   methodA() {}
 * }
 * class B {
 *   methodA() {} // inherited from class A
 *   methodB() {}
 * }
 * ```
 *
 * Doing this here allows to simplify further treatment of those styles.
 * @param {Array.<Object>} styles
 */

function resolveStylesInheritance(styles) {
  // keep track of all the indexes parsed to avoid infinite loops
  var recursivelyBrowsedIndexes = [];

  function resolveStyleInheritance(styleElt, index) {
    recursivelyBrowsedIndexes.push(index);

    var _loop = function _loop(j) {
      var extendedStyleID = styleElt.extendsStyles[j];
      var extendedStyleIndex = Object(_utils_array_find_index__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(styles, function (x) {
        return x.id === extendedStyleID;
      });

      if (extendedStyleIndex < 0) {
        _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: unknown style inheritance: " + extendedStyleID);
      } else {
        var extendedStyle = styles[extendedStyleIndex];

        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(recursivelyBrowsedIndexes, extendedStyleIndex)) {
          _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: infinite style inheritance loop avoided");
        } else {
          resolveStyleInheritance(extendedStyle, extendedStyleIndex);
        }

        styleElt.style = Object(_utils_object_assign__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])({}, extendedStyle.style, styleElt.style);
      }
    };

    for (var j = 0; j < styleElt.extendsStyles.length; j++) {
      _loop(j);
    }

    styleElt.extendsStyles.length = 0;
  }

  for (var i = 0; i < styles.length; i++) {
    resolveStyleInheritance(styles[i], i);
    recursivelyBrowsedIndexes.length = 0; // reset
  }
}

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return seekAndLoadOnMediaEvents; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(159);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(145);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(185);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(187);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(158);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(190);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(151);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(133);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(152);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(153);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Emit once a "can-play" message as soon as the clock$ anounce that the content
 * can begin to be played.
 *
 * Warn you if the metadata is not yet loaded metadata by emitting a
 * "not-loaded-metadata" message first.
 * @param {Observable} clock$
 * @returns {Observable}
 */

function canPlay(clock$, mediaElement, isDirectfile) {
  var isLoaded$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* filter */ "a"])(function (tick) {
    var seeking = tick.seeking,
        stalled = tick.stalled,
        readyState = tick.readyState,
        currentRange = tick.currentRange;

    if (seeking || stalled !== null) {
      return false;
    }

    if (!Object(_compat__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"])(isDirectfile, mediaElement.hasAttribute("playsinline"))) {
      return readyState >= 1 && mediaElement.duration > 0;
    }

    if (readyState >= 4 || readyState === 3 && currentRange !== null) {
      return Object(_compat__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])() ? mediaElement.duration > 0 : true;
    }

    return false;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mapTo */ "a"])("can-play"));

  if (Object(_compat__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])() && mediaElement.duration === 0) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("not-loaded-metadata"), isLoaded$);
  }

  return isLoaded$;
}
/**
 * Try to play content then handle autoplay errors.
 * @param {HTMLMediaElement} - mediaElement
 * @returns {Observable}
 */


function autoPlay$(mediaElement) {
  return Object(_compat__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mapTo */ "a"])("autoplay"), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* catchError */ "a"])(function (error) {
    if (error instanceof Error && error.name === "NotAllowedError") {
      // auto-play was probably prevented.
      _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].warn("Init: Media element can't play." + " It may be due to browser auto-play policies.");
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("autoplay-blocked");
    } else {
      throw error;
    }
  }));
}
/**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {Object} args
 * @returns {Object}
 */


function seekAndLoadOnMediaEvents(_ref) {
  var clock$ = _ref.clock$,
      mediaElement = _ref.mediaElement,
      startTime = _ref.startTime,
      mustAutoPlay = _ref.mustAutoPlay,
      isDirectfile = _ref.isDirectfile;
  var seek$ = Object(_compat__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function () {
    _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].info("Init: Set initial time", startTime);
    mediaElement.currentTime = typeof startTime === "function" ? startTime() : startTime;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* shareReplay */ "a"])({
    refCount: true
  }));
  var load$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* mergeMap */ "a"])(function () {
    return canPlay(clock$, mediaElement, isDirectfile).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function () {
      return _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].info("Init: Can begin to play content");
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* mergeMap */ "a"])(function (evt) {
      if (evt === "can-play") {
        if (!mustAutoPlay) {
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("loaded");
        }

        return autoPlay$(mediaElement);
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(evt);
    }));
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* shareReplay */ "a"])({
    refCount: true
  }));
  return {
    seek$: seek$,
    load$: load$
  };
}

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldValidateMetadata; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */

function shouldValidateMetadata() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSamsungBrowser */ "g"];
}

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createEMEManager; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(154);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(104);
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var onEncrypted$ = _compat___WEBPACK_IMPORTED_MODULE_3__[/* events */ "a"].onEncrypted$;
/**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Observable<Object>} contentProtections$
 * @returns {Observable}
 */

function createEMEManager(mediaElement, keySystems, contentProtections$) {
  if (_features__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].emeManager == null) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Encrypted event but EME feature not activated");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "EME feature not activated.");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  if (keySystems.length === 0) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Ciphered media and no keySystem passed");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "Media is encrypted and no `keySystems` given");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  if (!Object(_compat___WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])()) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Encrypted event but no EME API available");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "Encryption APIs not found.");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].debug("Init: Creating EMEManager");
  return _features__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].emeManager(mediaElement, keySystems, contentProtections$);
}

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return throwOnMediaError; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function throwOnMediaError(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* fromEvent */ "a"])(mediaElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* mergeMap */ "a"])(function () {
    var errorCode = mediaElement.error == null ? 0 : mediaElement.error.code;

    switch (errorCode) {
      case 1:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_ABORTED", "The fetching of the associated resource was aborted " + "by the user's request.");

      case 2:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_NETWORK", "A network error occurred which prevented the media " + "from being successfully fetched");

      case 3:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_DECODE", "An error occurred while trying to decode the media " + "resource");

      case 4:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_SRC_NOT_SUPPORTED", "The media resource has been found to be unsuitable.");

      default:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_UNKNOWN", "The HTMLMediaElement errored due to an unknown reason.");
    }
  }));
}

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return updatePlaybackRate; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(184);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(156);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(142);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(158);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$ - Current playback conditions
 * @param {Object} options - Contains the following properties:
 *   - pauseWhenStalled {Boolean|undefined} - true if the player
 *     stalling should lead to a pause until it un-stalls. True by default.
 * @returns {Observable}
 */

function updatePlaybackRate(mediaElement, speed$, clock$, _ref) {
  var _ref$pauseWhenStalled = _ref.pauseWhenStalled,
      pauseWhenStalled = _ref$pauseWhenStalled === void 0 ? true : _ref$pauseWhenStalled;
  var forcePause$;

  if (!pauseWhenStalled) {
    forcePause$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(false);
  } else {
    forcePause$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function (timing) {
      return timing.stalled !== null;
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* startWith */ "a"])(false), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* distinctUntilChanged */ "a"])());
  }

  return forcePause$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* switchMap */ "a"])(function (shouldForcePause) {
    if (shouldForcePause) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* defer */ "a"])(function () {
        _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].info("Init: Pause playback to build buffer");
        mediaElement.playbackRate = 0;
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(0);
      });
    }

    return speed$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function (speed) {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].info("Init: Resume playback speed", speed);
      mediaElement.playbackRate = speed;
    }));
  }));
}

/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getStalledEvents; });
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(192);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(156);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {Observable} clock$
 * @returns {Observable}
 */

function getStalledEvents(clock$) {
  return clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__[/* share */ "a"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* map */ "a"])(function (tick) {
    return tick.stalled;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* distinctUntilChanged */ "a"])(function (wasStalled, isStalled) {
    return wasStalled === null && isStalled === null || wasStalled !== null && isStalled !== null && wasStalled.reason === isStalled.reason;
  }));
}

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getCueBlocks; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */

function findEndOfCueBlock(linified, startIndex) {
  var firstEmptyLineIndex = startIndex + 1; // continue incrementing i until either:
  //   - an empty line
  //   - the end

  while (Object(is_non_empty_string["a" /* default */])(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }

  return firstEmptyLineIndex;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */

function getCueBlocks(linified) {
  var cueBlocks = [];

  for (var i = 0; i < linified.length; i++) {
    if (Object(is_non_empty_string["a" /* default */])(linified[i])) {
      var endOfCue = findEndOfCueBlock(linified, i);
      var cueBlockCandidate = linified.slice(i, endOfCue);

      if (cueBlockCandidate.length > 0) {
        if (cueBlockCandidate.length === 1) {
          if (cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        } else {
          if (cueBlockCandidate[1].indexOf("-->") >= 0 || cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        }
      }

      i = endOfCue;
    }
  }

  return cueBlocks;
}

/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ parseCueBlock; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */

function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":");

  if (Object(is_non_empty_string["a" /* default */])(splittedTS[2])) {
    var hours = parseInt(splittedTS[0], 10);
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[2].replace(",", "."));

    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }

    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */

function parseCueBlock(cueLines, timeOffset) {
  if (cueLines.length === 0) {
    return null;
  }

  var startTimeString;
  var endTimeString;
  var payload = []; // normally in srt, the timing is at second position.
  // We still authorize to put it in the first position for resilience

  if (Object(is_non_empty_string["a" /* default */])(cueLines[1]) && cueLines[1].indexOf("-->") !== -1) {
    var _cueLines$1$split$map = cueLines[1].split("-->").map(function (s) {
      return s.trim();
    });

    startTimeString = _cueLines$1$split$map[0];
    endTimeString = _cueLines$1$split$map[1];
    payload = cueLines.slice(2, cueLines.length);
  }

  if (!Object(is_non_empty_string["a" /* default */])(startTimeString) || !Object(is_non_empty_string["a" /* default */])(endTimeString)) {
    // Try to see if we find them in the first position
    var _cueLines$0$split$map = cueLines[0].split("-->").map(function (s) {
      return s.trim();
    });

    startTimeString = _cueLines$0$split$map[0];
    endTimeString = _cueLines$0$split$map[1];
    payload = cueLines.slice(1, cueLines.length);
  }

  if (!Object(is_non_empty_string["a" /* default */])(startTimeString) || !Object(is_non_empty_string["a" /* default */])(endTimeString)) {
    // if the time is still not found, exit
    return null;
  }

  var start = parseTimestamp(startTimeString);
  var end = parseTimestamp(endTimeString);

  if (start === undefined || end === undefined) {
    return null;
  }

  return {
    start: start + timeOffset,
    end: end + timeOffset,
    payload: payload
  };
}

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ parseCueBlock; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */

function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":").reverse();

  if (Object(is_non_empty_string["a" /* default */])(splittedTS[2]) || Object(is_non_empty_string["a" /* default */])(splittedTS[1])) {
    var hours = Object(is_non_empty_string["a" /* default */])(splittedTS[2]) ? parseInt(splittedTS[2], 10) : 0;
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[0].replace(",", "."));

    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }

    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */

function parseSettings(settingsString) {
  var splittedSettings = settingsString.split(/ |\t/);
  return splittedSettings.reduce(function (acc, setting) {
    var splittedSetting = setting.split(":");

    if (splittedSetting.length === 2) {
      acc[splittedSetting[0]] = splittedSetting[1];
    }

    return acc;
  }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */


function parseTimeAndSettings(timeString) {
  // RegExp for the timestamps + settings line.
  // Capture groups:
  //   1 -> start timestamp
  //   2 -> end timestamp
  //   3 - settings
  var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
  var matches = timeString.match(lineRegex);

  if (matches === null) {
    return null;
  }

  var start = parseTimestamp(matches[1]);
  var end = parseTimestamp(matches[2]);

  if (start == null || end == null) {
    return null;
  }

  var settings = parseSettings(matches[3]);
  return {
    start: start,
    end: end,
    settings: settings
  };
}
/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */


function parseCueBlock(cueLines, timeOffset) {
  var timingRegexp = /-->/;
  var timeString;
  var payload;
  var header;

  if (!timingRegexp.test(cueLines[0])) {
    if (!timingRegexp.test(cueLines[1])) {
      // not a cue
      return null;
    }

    header = cueLines[0];
    timeString = cueLines[1];
    payload = cueLines.slice(2, cueLines.length);
  } else {
    timeString = cueLines[0];
    payload = cueLines.slice(1, cueLines.length);
  }

  var timeAndSettings = parseTimeAndSettings(timeString);

  if (timeAndSettings === null) {
    return null;
  }

  var start = timeAndSettings.start,
      end = timeAndSettings.end,
      settings = timeAndSettings.settings;
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    settings: settings,
    payload: payload,
    header: header
  };
}

/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getTimeDelimiters; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(17);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */

function parseTime(text, ttParams) {
  if (regexps["h" /* REGXP_TIME_COLON_FRAMES */].test(text)) {
    return parseColonTimeWithFrames(ttParams, text);
  } else if (regexps["g" /* REGXP_TIME_COLON */].test(text)) {
    return parseTimeFromRegExp(regexps["g" /* REGXP_TIME_COLON */], text);
  } else if (regexps["i" /* REGXP_TIME_COLON_MS */].test(text)) {
    return parseTimeFromRegExp(regexps["i" /* REGXP_TIME_COLON_MS */], text);
  } else if (regexps["j" /* REGXP_TIME_FRAMES */].test(text)) {
    return parseFramesTime(ttParams, text);
  } else if (regexps["l" /* REGXP_TIME_TICK */].test(text)) {
    return parseTickTime(ttParams, text);
  } else if (regexps["k" /* REGXP_TIME_HMS */].test(text)) {
    return parseTimeFromRegExp(regexps["k" /* REGXP_TIME_HMS */], text);
  }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseFramesTime(ttParams, text) {
  // 75f or 75.5f
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["j" /* REGXP_TIME_FRAMES */].exec(text);
  var frames = Number(results[1]);
  return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseTickTime(ttParams, text) {
  // 50t or 50.5t
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["l" /* REGXP_TIME_TICK */].exec(text);
  var ticks = Number(results[1]);
  return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseColonTimeWithFrames(ttParams, text) {
  // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["h" /* REGXP_TIME_COLON_FRAMES */].exec(text);
  var hours = Number(results[1]);
  var minutes = Number(results[2]);
  var seconds = Number(results[3]);
  var frames = Number(results[4]);
  var subframes = Number(results[5]);

  if (isNaN(subframes)) {
    subframes = 0;
  }

  frames += subframes / ttParams.subFrameRate;
  seconds += frames / ttParams.frameRate;
  return seconds + minutes * 60 + hours * 3600;
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */


function parseTimeFromRegExp(regex, text) {
  var results = regex.exec(text);

  if (results === null || results[0] === "") {
    return null;
  } // This capture is optional, but will still be in the array as undefined,
  // default to 0.


  var hours = Number(results[1]);

  if (isNaN(hours)) {
    hours = 0;
  }

  var minutes = Number(results[2]);

  if (isNaN(minutes)) {
    minutes = 0;
  }

  var seconds = Number(results[3]);

  if (isNaN(seconds)) {
    seconds = 0;
  }

  var milliseconds = Number(results[4]);

  if (isNaN(milliseconds)) {
    milliseconds = 0;
  }

  return milliseconds / 1000 + seconds + minutes * 60 + hours * 3600;
}

/* harmony default export */ var time_parsing = (parseTime);
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */

function getTimeDelimiters(element, ttParams) {
  var beginAttr = element.getAttribute("begin");
  var durationAttr = element.getAttribute("dur");
  var endAttr = element.getAttribute("end");
  var start = Object(is_non_empty_string["a" /* default */])(beginAttr) ? time_parsing(beginAttr, ttParams) : null;
  var duration = Object(is_non_empty_string["a" /* default */])(durationAttr) ? time_parsing(durationAttr, ttParams) : null;
  var parsedEnd = Object(is_non_empty_string["a" /* default */])(endAttr) ? time_parsing(endAttr, ttParams) : null;

  if (start == null || parsedEnd == null && duration == null) {
    throw new Error("Invalid text cue");
  } // Huh? Is TypeScript that dumb here?


  var end = parsedEnd == null ? start + duration : parsedEnd;
  return {
    start: start,
    end: end
  };
}

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return switchMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__[/* from */ "a"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_1__[/* map */ "a"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* SimpleInnerSubscriber */ "a"](this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* innerSubscribe */ "c"])(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__[/* SimpleOuterSubscriber */ "b"]));
//# sourceMappingURL=switchMap.js.map


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getTRAF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getMDAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMDIA; });
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */

function getTRAF(buffer) {
  var moof = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buffer, 0x6D6F6F66
  /* moof */
  );

  if (moof === null) {
    return null;
  }

  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(moof, 0x74726166
  /* traf */
  );
}
/**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */


function getMDAT(buf) {
  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buf, 0x6D646174
  /* "mdat" */
  );
}
/**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */


function getMDIA(buf) {
  var moov = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buf, 0x6D6F6F76
  /* moov */
  );

  if (moov === null) {
    return null;
  }

  var trak = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(moov, 0x7472616B
  /* "trak" */
  );

  if (trak === null) {
    return null;
  }

  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(trak, 0x6D646961
  /* "mdia" */
  );
}



/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return merge; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"]) {
        return observables[0];
    }
    return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__[/* mergeAll */ "a"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__[/* fromArray */ "a"])(observables, scheduler));
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return take; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__[/* empty */ "b"])();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__[/* ArgumentOutOfRangeError */ "a"];
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=take.js.map


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RequestError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */
var RequestError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(RequestError, _Error);

  /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
  function RequestError(url, status, type, xhr) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), RequestError.prototype);
    _this.name = "RequestError";
    _this.url = url;
    _this.xhr = xhr;
    _this.status = status;
    _this.type = type;
    _this.message = type;
    return _this;
  }

  return RequestError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "clearEMESession", function() { return /* reexport */ clear_eme_session["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "disposeEME", function() { return /* reexport */ dispose_eme["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() { return /* reexport */ get_current_key_system["a" /* default */]; });

// EXTERNAL MODULE: ./src/core/eme/clear_eme_session.ts
var clear_eme_session = __webpack_require__(163);

// EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
var dispose_eme = __webpack_require__(164);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(98);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(190);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(159);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(145);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(158);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(187);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(157);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(9);

// EXTERNAL MODULE: ./src/compat/eme/get_init_data.ts
var get_init_data = __webpack_require__(235);

// EXTERNAL MODULE: ./src/compat/eme/generate_key_request.ts
var generate_key_request = __webpack_require__(236);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
var encrypted_media_error = __webpack_require__(104);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts
var assert_unreachable = __webpack_require__(49);

// EXTERNAL MODULE: ./src/utils/filter_map.ts
var filter_map = __webpack_require__(84);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// CONCATENATED MODULE: ./src/core/eme/clean_old_stored_persistent_info.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Remove old information from a PersistentSessionsStore so that it respects the
 * given `limit` as a maximum size. This can be used to prevent its size from
 * growing indefinitely.
 *
 * This is needed because our persistent session information storage is
 * un-bounded in size, adding more data will just add more data without removing
 * the old one - which can be valid or invalid.
 *
 * This is problematic for at least two reasons:
 *   - This data is loaded into JS memory which is finite (and which maximum
 *     bounds depends on the user environment).
 *   - The final storage used (as chosen by the application using the RxPlayer)
 *     will in most cases have a maximum storage size.
 */

function cleanOldStoredPersistentInfo(persistentSessionsStore, limit) {
  if (isNaN(limit) || limit < 0 || limit >= persistentSessionsStore.getLength()) {
    return;
  }

  var numberOfPersistentSessions = persistentSessionsStore.getLength();
  var toDelete = numberOfPersistentSessions - limit;
  log["a" /* default */].info("EME: Too many stored persistent sessions, removing some.", numberOfPersistentSessions, toDelete);
  persistentSessionsStore.deleteOldSessions(toDelete);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(86);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(185);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(184);

// CONCATENATED MODULE: ./src/core/eme/clean_old_loaded_sessions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Close sessions from the loadedSessionsStore to allow at maximum `limit`
 * stored MediaKeySessions in it.
 *
 * Emit event when a MediaKeySession begin to be closed and another when the
 * MediaKeySession is closed.
 * @param {Object} loadedSessionsStore
 * @returns {Observable}
 */

function cleanOldLoadedSessions(loadedSessionsStore, limit) {
  if (limit < 0 || limit >= loadedSessionsStore.getLength()) {
    return empty["a" /* EMPTY */];
  }

  var cleaningOldSessions$ = [];
  var entries = loadedSessionsStore.getAll().slice(); // clone

  var toDelete = entries.length - limit;

  for (var i = 0; i < toDelete; i++) {
    var entry = entries[i];
    var cleaning$ = loadedSessionsStore.closeSession(entry.initData, entry.initDataType).pipe(Object(mapTo["a" /* mapTo */])({
      type: "cleaned-old-session",
      value: entry
    }), Object(startWith["a" /* startWith */])({
      type: "cleaning-old-session",
      value: entry
    }));
    cleaningOldSessions$.push(cleaning$);
  }

  return merge["a" /* merge */].apply(void 0, cleaningOldSessions$);
}
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(29);

// CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */

function isSessionUsable(loadedSession) {
  if (loadedSession.sessionId === "") {
    return false;
  }

  var keyStatusesMap = loadedSession.keyStatuses;
  var keyStatuses = [];
  keyStatusesMap.forEach(function (keyStatus) {
    keyStatuses.push(keyStatus);
  });

  if (keyStatuses.length > 0 && !Object(array_includes["a" /* default */])(keyStatuses, "expired") && !Object(array_includes["a" /* default */])(keyStatuses, "internal-error")) {
    log["a" /* default */].debug("EME: Reuse loaded session", loadedSession.sessionId);
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./src/core/eme/create_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */

function loadPersistentSession(sessionId, session) {
  return Object(defer["a" /* defer */])(function () {
    log["a" /* default */].info("EME: Load persisted session", sessionId);
    return Object(cast_to_observable["a" /* default */])(session.load(sessionId));
  });
}
/**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if loadedSessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */


function create_session_createSession(initData, initDataType, mediaKeysInfos) {
  return Object(defer["a" /* defer */])(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        loadedSessionsStore = mediaKeysInfos.loadedSessionsStore,
        persistentSessionsStore = mediaKeysInfos.persistentSessionsStore;
    var mksConfig = mediaKeySystemAccess.getConfiguration();
    var sessionTypes = mksConfig.sessionTypes;
    var hasPersistence = sessionTypes != null && Object(array_includes["a" /* default */])(sessionTypes, "persistent-license");
    var sessionType = hasPersistence && persistentSessionsStore != null && keySystemOptions.persistentLicense === true ? "persistent-license" : "temporary";
    log["a" /* default */].info("EME: Create a new " + sessionType + " session");
    var session = loadedSessionsStore.createSession(initData, initDataType, sessionType); // Re-check for Dumb typescript. Equivalent to `sessionType === "temporary"`.

    if (!hasPersistence || persistentSessionsStore == null || keySystemOptions.persistentLicense !== true) {
      return Object(of["a" /* of */])({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }

    var storedEntry = persistentSessionsStore.getAndReuse(initData, initDataType);

    if (storedEntry === null) {
      return Object(of["a" /* of */])({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }
    /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */


    var recreatePersistentSession = function recreatePersistentSession() {
      log["a" /* default */].info("EME: Removing previous persistent session.");

      if (persistentSessionsStore.get(initData, initDataType) !== null) {
        persistentSessionsStore["delete"](initData, initDataType);
      }

      return loadedSessionsStore.closeSession(initData, initDataType).pipe(Object(map["a" /* map */])(function () {
        var newSession = loadedSessionsStore.createSession(initData, initDataType, sessionType);
        return {
          type: "created-session",
          value: {
            mediaKeySession: newSession,
            sessionType: sessionType
          }
        };
      }));
    };

    return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap["a" /* mergeMap */])(function (hasLoadedSession) {
      if (!hasLoadedSession) {
        log["a" /* default */].warn("EME: No data stored for the loaded session");
        persistentSessionsStore["delete"](initData, initDataType);
        return Object(of["a" /* of */])({
          type: "created-session",
          value: {
            mediaKeySession: session,
            sessionType: sessionType
          }
        });
      }

      if (hasLoadedSession && isSessionUsable(session)) {
        persistentSessionsStore.add(initData, initDataType, session);
        log["a" /* default */].info("EME: Succeeded to load persistent session.");
        return Object(of["a" /* of */])({
          type: "loaded-persistent-session",
          value: {
            mediaKeySession: session,
            sessionType: sessionType
          }
        });
      } // Unusable persistent session: recreate a new session from scratch.


      log["a" /* default */].warn("EME: Previous persistent session not usable anymore.");
      return recreatePersistentSession();
    }), Object(catchError["a" /* catchError */])(function (err) {
      log["a" /* default */].warn("EME: Unable to load persistent session: " + (err instanceof Error ? err.toString() : "Unknown Error"));
      return recreatePersistentSession();
    }));
  });
}
// CONCATENATED MODULE: ./src/core/eme/get_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS = config["a" /* default */].EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a MediaKeySession, recuperate a previous MediaKeySession or
 * load a persistent session.
 *
 * Some previously created MediaKeySession can be closed in this process to
 * respect the maximum limit of concurrent MediaKeySession, as defined by the
 * `EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS` config property.
 *
 * You can refer to the events emitted to know about the current situation.
 * @param {Event} initializationDataInfo
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */

function getSession(initializationDataInfo, mediaKeysInfos) {
  return Object(defer["a" /* defer */])(function () {
    var initDataType = initializationDataInfo.type,
        initData = initializationDataInfo.data;
    /**
     * Store previously-loaded MediaKeySession with the same initialization data, if one.
     */

    var previousLoadedSession = null;
    var loadedSessionsStore = mediaKeysInfos.loadedSessionsStore;
    var entry = loadedSessionsStore.getAndReuse(initData, initDataType);

    if (entry !== null) {
      previousLoadedSession = entry.mediaKeySession;

      if (isSessionUsable(previousLoadedSession)) {
        log["a" /* default */].info("EME: Reuse loaded session", previousLoadedSession.sessionId);
        return Object(of["a" /* of */])({
          type: "loaded-open-session",
          value: {
            mediaKeySession: previousLoadedSession,
            sessionType: entry.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        });
      } else if (mediaKeysInfos.persistentSessionsStore != null) {
        // If the session is not usable anymore, we can also remove it from the
        // PersistentSessionsStore.
        // TODO Are we sure this is always what we want?
        mediaKeysInfos.persistentSessionsStore["delete"](new Uint8Array(initData), initDataType);
      }
    }

    return (previousLoadedSession != null ? loadedSessionsStore.closeSession(initData, initDataType) : Object(of["a" /* of */])(null)).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return Object(concat["a" /* concat */])(cleanOldLoadedSessions(loadedSessionsStore, EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS - 1), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map["a" /* map */])(function (evt) {
        return {
          type: evt.type,
          value: {
            mediaKeySession: evt.value.mediaKeySession,
            sessionType: evt.value.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        };
      })));
    }));
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(183);

// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/index.ts + 5 modules
var custom_media_keys = __webpack_require__(193);

// EXTERNAL MODULE: ./src/core/eme/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(44);

// CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Dispose the media keys on media element.
 * @param {Object} mediaElement
 * @returns {Observable}
 */

function disableMediaKeys(mediaElement) {
  return Object(defer["a" /* defer */])(function () {
    media_keys_infos_store["a" /* default */].setState(mediaElement, null);
    return Object(custom_media_keys["b" /* setMediaKeys */])(mediaElement, null);
  });
}
/**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function attachMediaKeys(mediaKeysInfos, mediaElement) {
  return Object(defer["a" /* defer */])(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        mediaKeys = mediaKeysInfos.mediaKeys,
        loadedSessionsStore = mediaKeysInfos.loadedSessionsStore;
    var previousState = media_keys_infos_store["a" /* default */].getState(mediaElement);
    var closeAllSessions$ = previousState !== null && previousState.loadedSessionsStore !== loadedSessionsStore ? previousState.loadedSessionsStore.closeAllSessions() : Object(of["a" /* of */])(null);
    return closeAllSessions$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      media_keys_infos_store["a" /* default */].setState(mediaElement, {
        keySystemOptions: keySystemOptions,
        mediaKeySystemAccess: mediaKeySystemAccess,
        mediaKeys: mediaKeys,
        loadedSessionsStore: loadedSessionsStore
      });

      if (mediaElement.mediaKeys === mediaKeys) {
        return Object(of["a" /* of */])(null);
      }

      log["a" /* default */].info("EME: Attaching MediaKeys to the media element");
      return Object(custom_media_keys["b" /* setMediaKeys */])(mediaElement, mediaKeys).pipe(Object(tap["a" /* tap */])(function () {
        log["a" /* default */].info("EME: MediaKeys attached with success");
      }));
    }));
  });
}
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(43);

// EXTERNAL MODULE: ./src/compat/should_renew_media_keys.ts
var should_renew_media_keys = __webpack_require__(162);

// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(99);

// CONCATENATED MODULE: ./src/core/eme/find_key_system.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config["a" /* default */].EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
    EME_KEY_SYSTEMS = config["a" /* default */].EME_KEY_SYSTEMS;
/**
 * @param {Array.<Object>} keySystems
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */

function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
  var mksConfiguration = currentKeySystemAccess.getConfiguration();

  if (Object(should_renew_media_keys["a" /* default */])() || mksConfiguration == null) {
    return null;
  }

  var firstCompatibleOption = keySystems.filter(function (ks) {
    // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
    if (ks.type !== currentKeySystemOptions.type) {
      return false;
    }

    if ((ks.persistentLicense === true || ks.persistentStateRequired === true) && mksConfiguration.persistentState !== "required") {
      return false;
    }

    if (ks.distinctiveIdentifierRequired === true && mksConfiguration.distinctiveIdentifier !== "required") {
      return false;
    }

    return true;
  })[0];

  if (firstCompatibleOption != null) {
    return {
      keySystemOptions: firstCompatibleOption,
      keySystemAccess: currentKeySystemAccess
    };
  }

  return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */


function findKeySystemCanonicalName(ksType) {
  for (var _i = 0, _Object$keys = Object.keys(EME_KEY_SYSTEMS); _i < _Object$keys.length; _i++) {
    var ksName = _Object$keys[_i];

    if (Object(array_includes["a" /* default */])(EME_KEY_SYSTEMS[ksName], ksType)) {
      return ksName;
    }
  }

  return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */


function buildKeySystemConfigurations(ksName, keySystem) {
  var sessionTypes = ["temporary"];
  var persistentState = "optional";
  var distinctiveIdentifier = "optional";

  if (keySystem.persistentLicense === true) {
    persistentState = "required";
    sessionTypes.push("persistent-license");
  }

  if (keySystem.persistentStateRequired === true) {
    persistentState = "required";
  }

  if (keySystem.distinctiveIdentifierRequired === true) {
    distinctiveIdentifier = "required";
  } // Set robustness, in order of consideration:
  //   1. the user specified its own robustnesses
  //   2. a "widevine" key system is used, in that case set the default widevine
  //      robustnesses as defined in the config
  //   3. set an undefined robustness


  var videoRobustnesses = keySystem.videoRobustnesses != null ? keySystem.videoRobustnesses : ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : [];
  var audioRobustnesses = keySystem.audioRobustnesses != null ? keySystem.audioRobustnesses : ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : [];

  if (videoRobustnesses.length === 0) {
    videoRobustnesses.push(undefined);
  }

  if (audioRobustnesses.length === 0) {
    audioRobustnesses.push(undefined);
  } // From the W3 EME spec, we have to provide videoCapabilities and
  // audioCapabilities.
  // These capabilities must specify a codec (even though you can use a
  // completely different codec afterward).
  // It is also strongly recommended to specify the required security
  // robustness. As we do not want to forbide any security level, we specify
  // every existing security level from highest to lowest so that the best
  // security level is selected.
  // More details here:
  // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
  // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent


  var videoCapabilities = Object(flat_map["a" /* default */])(videoRobustnesses, function (robustness) {
    return [{
      contentType: "video/mp4;codecs=\"avc1.4d401e\"",
      robustness: robustness
    }, {
      contentType: "video/mp4;codecs=\"avc1.42e01e\"",
      robustness: robustness
    }, {
      contentType: "video/webm;codecs=\"vp8\"",
      robustness: robustness
    }];
  });
  var audioCapabilities = Object(flat_map["a" /* default */])(audioRobustnesses, function (robustness) {
    return [{
      contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
      robustness: robustness
    }, {
      contentType: "audio/webm;codecs=opus",
      robustness: robustness
    }];
  }); // TODO Re-test with a set contentType but an undefined robustness on the
  // STBs on which this problem was found.
  //
  // add another with no {audio,video}Capabilities for some legacy browsers.
  // As of today's spec, this should return NotSupported but the first
  // candidate configuration should be good, so we should have no downside
  // doing that.
  // initDataTypes: ["cenc"],
  // videoCapabilities: undefined,
  // audioCapabilities: undefined,
  // distinctiveIdentifier,
  // persistentState,
  // sessionTypes,

  return [{
    initDataTypes: ["cenc"],
    videoCapabilities: videoCapabilities,
    audioCapabilities: audioCapabilities,
    distinctiveIdentifier: distinctiveIdentifier,
    persistentState: persistentState,
    sessionTypes: sessionTypes
  }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */


function getMediaKeySystemAccess(mediaElement, keySystemsConfigs) {
  return Object(defer["a" /* defer */])(function () {
    log["a" /* default */].info("EME: Searching for compatible MediaKeySystemAccess");
    var currentState = media_keys_infos_store["a" /* default */].getState(mediaElement);

    if (currentState != null) {
      // Fast way to find a compatible keySystem if the currently loaded
      // one as exactly the same compatibility options.
      var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);

      if (cachedKeySystemAccess !== null) {
        log["a" /* default */].info("EME: Found cached compatible keySystem", cachedKeySystemAccess);
        return Object(of["a" /* of */])({
          type: "reuse-media-key-system-access",
          value: {
            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
            options: cachedKeySystemAccess.keySystemOptions
          }
        });
      }
    }
    /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */


    var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {
      var managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
      var ksType;

      if (managedRDNs != null) {
        ksType = managedRDNs.map(function (keyType) {
          var keyName = keySystemOptions.type;
          return {
            keyName: keyName,
            keyType: keyType,
            keySystemOptions: keySystemOptions
          };
        });
      } else {
        var keyName = findKeySystemCanonicalName(keySystemOptions.type);
        var keyType = keySystemOptions.type;
        ksType = [{
          keyName: keyName,
          keyType: keyType,
          keySystemOptions: keySystemOptions
        }];
      }

      return arr.concat(ksType);
    }, []);
    return recursivelyTestKeySystems(0);
    /**
     * Test all key system configuration stored in `keySystemsType` one by one
     * recursively.
     * Returns an Observable which emit the MediaKeySystemAccess if one was
     * found compatible with one of the configurations or just throws if none
     * were found to be compatible.
     * @param {Number} index - The index in `keySystemsType` to start from.
     * Should be set to `0` when calling directly.
     * @returns {Observable}
     */

    function recursivelyTestKeySystems(index) {
      // if we iterated over the whole keySystemsType Array, quit on error
      if (index >= keySystemsType.length) {
        var error = new encrypted_media_error["a" /* default */]("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your " + "wanted configuration has been found " + "in the current browser.");
        return Object(throwError["a" /* throwError */])(error);
      }

      if (custom_media_keys["a" /* requestMediaKeySystemAccess */] == null) {
        var _error = Error("requestMediaKeySystemAccess is not " + "implemented in your browser.");

        return Object(throwError["a" /* throwError */])(_error);
      }

      var _keySystemsType$index = keySystemsType[index],
          keyName = _keySystemsType$index.keyName,
          keyType = _keySystemsType$index.keyType,
          keySystemOptions = _keySystemsType$index.keySystemOptions;
      var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
      log["a" /* default */].debug("EME: Request keysystem access " + keyType + "," + (index + 1 + " of " + keySystemsType.length), keySystemConfigurations);
      return Object(custom_media_keys["a" /* requestMediaKeySystemAccess */])(keyType, keySystemConfigurations).pipe(Object(map["a" /* map */])(function (keySystemAccess) {
        log["a" /* default */].info("EME: Found compatible keysystem", keyType, keySystemConfigurations);
        return {
          type: "create-media-key-system-access",
          value: {
            options: keySystemOptions,
            mediaKeySystemAccess: keySystemAccess
          }
        };
      }), Object(catchError["a" /* catchError */])(function () {
        log["a" /* default */].debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations);
        return recursivelyTestKeySystems(index + 1);
      }));
    }
  });
}
// EXTERNAL MODULE: ./src/compat/eme/close_session.ts
var close_session = __webpack_require__(234);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(48);

// CONCATENATED MODULE: ./src/utils/hash_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert given buffer to a 32bit integer hash
 *
 * This algorithm is the same one that Java `String.hashCode()` one which
 * is a fast hashing function adapted to short ASCII strings.
 * This consequently might not be the most adapted to buffers of various length
 * containing a various amount of data but still has the advantage of being
 * fast.
 *
 * As this function is used in persistent MediaKeySession storage, we probably
 * should keep this function somewhere as long as we want to support
 * MediaKeySessions persisted in old versions of the RxPlayer.
 *
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
function hashBuffer(buffer) {
  var hash = 0;

  var _char;

  for (var i = 0; i < buffer.length; i++) {
    _char = buffer[i];
    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}
// CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store a unique value associated to an initData and initDataType.
 * @class InitDataStore
 */

var init_data_store_InitDataStore = /*#__PURE__*/function () {
  /** Construct a new InitDataStore.  */
  function InitDataStore() {
    this._storage = [];
  }
  /**
   * Returns all stored value, in the order in which they have been stored.
   * Note: it is possible to move a value to the end of this array by calling
   * the `getAndReuse` method.
   * @returns {Array}
   */


  var _proto = InitDataStore.prototype;

  _proto.getAll = function getAll() {
    return this._storage.map(function (item) {
      return item.value;
    });
  }
  /**
   * Returns the number of stored values.
   * @returns {number}
   */
  ;

  _proto.getLength = function getLength() {
    return this._storage.length;
  }
  /**
   * Returns the element associated with the given initData and initDataType.
   * Returns `undefined` if not found.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {*}
   */
  ;

  _proto.get = function get(initData, initDataType) {
    var initDataHash = hashBuffer(initData);

    var index = this._findIndex(initData, initDataType, initDataHash);

    return index >= 0 ? this._storage[index].value : undefined;
  }
  /**
   * Like `get`, but also move the corresponding value at the end of the store
   * (as returned by `getAll`) if found.
   * This can be used for example to tell when a previously-stored value is
   * re-used to then be able to implement a caching replacement algorithm based
   * on the least-recently-used values by just evicting the first values
   * returned by `getAll`.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {*}
   */
  ;

  _proto.getAndReuse = function getAndReuse(initData, initDataType) {
    var initDataHash = hashBuffer(initData);

    var index = this._findIndex(initData, initDataType, initDataHash);

    if (index === -1) {
      return undefined;
    }

    var item = this._storage.splice(index, 1)[0];

    this._storage.push(item);

    return item.value;
  }
  /**
   * Add to the store a value linked to the corresponding initData and
   * initDataType.
   * If a value was already stored linked to those, replace it.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */
  ;

  _proto.store = function store(initData, initDataType, value) {
    var initDataHash = hashBuffer(initData);

    var indexOf = this._findIndex(initData, initDataType, initDataHash);

    if (indexOf >= 0) {
      // this._storage contains the stored value in the same order they have
      // been put. So here we want to remove the previous element and re-push
      // it to the end.
      this._storage.splice(indexOf, 1);
    }

    this._storage.push({
      initData: initData,
      initDataType: initDataType,
      initDataHash: initDataHash,
      value: value
    });
  }
  /**
   * Add to the store a value linked to the corresponding initData and
   * initDataType.
   * If a value linked to those was already stored, do nothing and returns
   * `false`.
   * If not, add the value and return `true`.
   *
   * This can be used as a more performant version of doing both a `get` call -
   * to see if a value is stored linked to that data - and then if not doing a
   * store. `storeIfNone` is more performant as it will only perform hashing
   * and a look-up a single time.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */
  ;

  _proto.storeIfNone = function storeIfNone(initData, initDataType, value) {
    var initDataHash = hashBuffer(initData);

    var indexOf = this._findIndex(initData, initDataType, initDataHash);

    if (indexOf >= 0) {
      return false;
    }

    this._storage.push({
      initData: initData,
      initDataType: initDataType,
      initDataHash: initDataHash,
      value: value
    });

    return true;
  }
  /**
   * Remove an initDataType and initData combination from this store.
   * Returns the associated value if it has been found, `undefined` otherwise.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {*}
   */
  ;

  _proto.remove = function remove(initData, initDataType) {
    var initDataHash = hashBuffer(initData);

    var indexOf = this._findIndex(initData, initDataType, initDataHash);

    if (indexOf === -1) {
      return undefined;
    }

    return this._storage.splice(indexOf, 1)[0].value;
  }
  /**
   * Find the index of the corresponding initData and initDataType in
   * `this._storage`. Returns `-1` if not found.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {number} initDataHash
   * @returns {boolean}
   */
  ;

  _proto._findIndex = function _findIndex(initData, initDataType, initDataHash) {
    // Begin by the last element as we usually re-encounter the last stored
    // initData sooner than the first one.
    for (var i = this._storage.length - 1; i >= 0; i--) {
      var stored = this._storage[i];

      if (initDataHash === stored.initDataHash && initDataType === stored.initDataType) {
        if (Object(are_arrays_of_numbers_equal["a" /* default */])(initData, stored.initData)) {
          return i;
        }
      }
    }

    return -1;
  };

  return InitDataStore;
}();


// CONCATENATED MODULE: ./src/core/eme/utils/loaded_sessions_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class LoadedSessionsStore
 */

var loaded_sessions_store_LoadedSessionsStore = /*#__PURE__*/function () {
  /**
   * Create a new LoadedSessionsStore, which will store information about
   * loaded MediaKeySessions on the given MediaKeys instance.
   * @param {MediaKeys} mediaKeys
   */
  function LoadedSessionsStore(mediaKeys) {
    this._mediaKeys = mediaKeys;
    this._storage = new init_data_store_InitDataStore();
  }
  /**
   * Returns the stored MediaKeySession information related to the
   * given initDataType and initData if found.
   * Returns `null` if no such MediaKeySession is stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */


  var _proto = LoadedSessionsStore.prototype;

  _proto.get = function get(initData, initDataType) {
    var entry = this._storage.get(initData, initDataType);

    return entry === undefined ? null : {
      mediaKeySession: entry.mediaKeySession,
      sessionType: entry.sessionType
    };
  }
  /**
   * Like `get` but also moves the corresponding MediaKeySession to the end of
   * its internal storage, as returned by the `getAll` method.
   *
   * This can be used for example to tell when a previously-stored
   * MediaKeySession is re-used to then be able to implement a caching
   * replacement algorithm based on the least-recently-used values by just
   * evicting the first values returned by `getAll`.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */
  ;

  _proto.getAndReuse = function getAndReuse(initData, initDataType) {
    var entry = this._storage.getAndReuse(initData, initDataType);

    return entry === undefined ? null : {
      mediaKeySession: entry.mediaKeySession,
      sessionType: entry.sessionType
    };
  }
  /**
   * Create a new MediaKeySession and store it in this store.
   * @throws {EncryptedMediaError}
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {string} sessionType
   * @returns {MediaKeySession}
   */
  ;

  _proto.createSession = function createSession(initData, initDataType, sessionType) {
    var _this = this;

    if (this._storage.get(initData, initDataType) !== undefined) {
      throw new encrypted_media_error["a" /* default */]("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.");
    }

    var mediaKeySession = this._mediaKeys.createSession(sessionType);

    var entry = {
      mediaKeySession: mediaKeySession,
      sessionType: sessionType,
      initData: initData,
      initDataType: initDataType
    };

    if (!Object(is_null_or_undefined["a" /* default */])(mediaKeySession.closed)) {
      mediaKeySession.closed.then(function () {
        var currentEntry = _this._storage.get(initData, initDataType);

        if (currentEntry !== undefined && currentEntry.mediaKeySession === mediaKeySession) {
          _this._storage.remove(initData, initDataType);
        }
      })["catch"](function (e) {
        log["a" /* default */].warn("EME-LSS: MediaKeySession.closed rejected: " + e);
      });
    }

    log["a" /* default */].debug("EME-LSS: Add MediaKeySession", entry);

    this._storage.store(initData, initDataType, entry);

    return mediaKeySession;
  }
  /**
   * Close a MediaKeySession corresponding to an initialization data and remove
   * its related stored information from the LoadedSessionsStore.
   * Emit when done.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Observable}
   */
  ;

  _proto.closeSession = function closeSession(initData, initDataType) {
    var _this2 = this;

    return Object(defer["a" /* defer */])(function () {
      var entry = _this2._storage.remove(initData, initDataType);

      if (entry === undefined) {
        log["a" /* default */].warn("EME-LSS: No MediaKeySession found with " + "the given initData and initDataType");
        return empty["a" /* EMPTY */];
      }

      return safelyCloseMediaKeySession(entry.mediaKeySession);
    });
  }
  /**
   * Returns the number of stored MediaKeySessions in this LoadedSessionsStore.
   * @returns {number}
   */
  ;

  _proto.getLength = function getLength() {
    return this._storage.getLength();
  }
  /**
   * Returns information about all stored MediaKeySession, in the order in which
   * the MediaKeySession have been created.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAll = function getAll() {
    return this._storage.getAll();
  }
  /**
   * Close all sessions in this store.
   * Emit `null` when done.
   * @returns {Observable}
   */
  ;

  _proto.closeAllSessions = function closeAllSessions() {
    var _this3 = this;

    return Object(defer["a" /* defer */])(function () {
      var closing$ = _this3._storage.getAll().map(function (entry) {
        return safelyCloseMediaKeySession(entry.mediaKeySession);
      });

      log["a" /* default */].debug("EME-LSS: Closing all current MediaKeySessions", closing$.length); // re-initialize the storage, so that new interactions with the
      // `LoadedSessionsStore` do not rely on MediaKeySessions we're in the
      // process of removing

      _this3._storage = new init_data_store_InitDataStore();
      return Object(concat["a" /* concat */])(merge["a" /* merge */].apply(void 0, closing$).pipe(Object(ignoreElements["a" /* ignoreElements */])()), Object(of["a" /* of */])(null));
    });
  };

  return LoadedSessionsStore;
}();
/**
 * Close a MediaKeySession and do not throw if this action throws an error.
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */




function safelyCloseMediaKeySession(mediaKeySession) {
  log["a" /* default */].debug("EME-LSS: Close MediaKeySession", mediaKeySession);
  return Object(close_session["a" /* default */])(mediaKeySession).pipe(Object(catchError["a" /* catchError */])(function (err) {
    log["a" /* default */].error("EME-LSS: Could not close MediaKeySession: " + (err instanceof Error ? err.toString() : "Unknown error"));
    return Object(of["a" /* of */])(null);
  }));
}
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(53);

// EXTERNAL MODULE: ./src/utils/base64.ts
var utils_base64 = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/core/eme/utils/persistent_sessions_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Throw if the given storage does not respect the right interface.
 * @param {Object} storage
 */

function checkStorage(storage) {
  Object(assert["a" /* assertInterface */])(storage, {
    save: "function",
    load: "function"
  }, "licenseStorage");
}
/** Wrap initialization data and allow linearization of it into base64. */


var persistent_sessions_store_InitDataContainer = /*#__PURE__*/function () {
  /**
   * Create a new container, wrapping the initialization data given and allowing
   * linearization into base64.
   * @param {Uint8Array}
   */
  function InitDataContainer(initData) {
    this.initData = initData;
  }
  /**
   * Convert it to base64.
   * `toJSON` is specially interpreted by JavaScript engines to be able to rely
   * on it when calling `JSON.stringify` on it or any of its parent objects:
   * https://tc39.es/ecma262/#sec-serializejsonproperty
   * @returns {string}
   */


  var _proto = InitDataContainer.prototype;

  _proto.toJSON = function toJSON() {
    return Object(utils_base64["b" /* bytesToBase64 */])(this.initData);
  }
  /**
   * Decode a base64 sequence representing an initialization data back to an
   * Uint8Array.
   * @param {string}
   * @returns {Uint8Array}
   */
  ;

  InitDataContainer.decode = function decode(base64) {
    return Object(utils_base64["a" /* base64ToBytes */])(base64);
  };

  return InitDataContainer;
}();
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistentSessionsStore
 */


var persistent_sessions_store_PersistentSessionsStore = /*#__PURE__*/function () {
  /**
   * Create a new PersistentSessionsStore.
   * @param {Object} storage
   */
  function PersistentSessionsStore(storage) {
    checkStorage(storage);
    this._entries = [];
    this._storage = storage;

    try {
      this._entries = this._storage.load();

      if (!Array.isArray(this._entries)) {
        this._entries = [];
      }
    } catch (e) {
      log["a" /* default */].warn("EME-PSS: Could not get entries from license storage", e);
      this.dispose();
    }
  }
  /**
   * Returns the number of stored values.
   * @returns {number}
   */


  var _proto2 = PersistentSessionsStore.prototype;

  _proto2.getLength = function getLength() {
    return this._entries.length;
  }
  /**
   * Returns information about all stored MediaKeySession, in the order in which
   * the MediaKeySession have been created.
   * @returns {Array.<Object>}
   */
  ;

  _proto2.getAll = function getAll() {
    return this._entries;
  }
  /**
   * Retrieve an entry based on its initialization data.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */
  ;

  _proto2.get = function get(initData, initDataType) {
    var index = this.getIndex(initData, initDataType);
    return index === -1 ? null : this._entries[index];
  }
  /**
   * Like `get`, but also move the corresponding value at the end of the store
   * (as returned by `getAll`) if found.
   * This can be used for example to tell when a previously-stored value is
   * re-used to then be able to implement a caching replacement algorithm based
   * on the least-recently-used values by just evicting the first values
   * returned by `getAll`.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {*}
   */
  ;

  _proto2.getAndReuse = function getAndReuse(initData, initDataType) {
    var index = this.getIndex(initData, initDataType);

    if (index === -1) {
      return null;
    }

    var item = this._entries.splice(index, 1)[0];

    this._entries.push(item);

    return item;
  }
  /**
   * Add a new entry in the PersistentSessionsStore.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */
  ;

  _proto2.add = function add(initData, initDataType, session) {
    if (Object(is_null_or_undefined["a" /* default */])(session) || !Object(is_non_empty_string["a" /* default */])(session.sessionId)) {
      log["a" /* default */].warn("EME-PSS: Invalid Persisten Session given.");
      return;
    }

    var sessionId = session.sessionId;
    var currentEntry = this.get(initData, initDataType);

    if (currentEntry !== null && currentEntry.sessionId === sessionId) {
      return;
    } else if (currentEntry !== null) {
      // currentEntry has a different sessionId
      this["delete"](initData, initDataType);
    }

    var hash = hashBuffer(initData);
    log["a" /* default */].info("EME-PSS: Add new session", sessionId, session);

    this._entries.push({
      version: 2,
      sessionId: sessionId,
      initData: new persistent_sessions_store_InitDataContainer(initData),
      initDataHash: hash,
      initDataType: initDataType
    });

    this._save();
  }
  /**
   * Delete stored MediaKeySession information based on its initialization
   * data.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   */
  ;

  _proto2["delete"] = function _delete(initData, initDataType) {
    var index = this.getIndex(initData, initDataType);

    if (index === -1) {
      log["a" /* default */].warn("EME-PSS: initData to delete not found.");
      return;
    }

    var entry = this._entries[index];
    log["a" /* default */].warn("EME-PSS: Delete session from store", entry);

    this._entries.splice(index, 1);

    this._save();
  };

  _proto2.deleteOldSessions = function deleteOldSessions(sessionsToDelete) {
    log["a" /* default */].info("EME-PSS: Deleting last " + sessionsToDelete + " sessions.");

    if (sessionsToDelete <= 0) {
      return;
    }

    if (sessionsToDelete <= this._entries.length) {
      this._entries.splice(0, sessionsToDelete);
    } else {
      log["a" /* default */].warn("EME-PSS: Asked to remove more information that it contains", sessionsToDelete, this._entries.length);
      this._entries = [];
    }

    this._save();
  }
  /**
   * Delete all saved entries.
   */
  ;

  _proto2.dispose = function dispose() {
    this._entries = [];

    this._save();
  }
  /**
   * Retrieve index of an entry.
   * Returns `-1` if not found.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {number}
   */
  ;

  _proto2.getIndex = function getIndex(initData, initDataType) {
    var hash = hashBuffer(initData);

    for (var i = 0; i < this._entries.length; i++) {
      var entry = this._entries[i];

      if (entry.initDataType === initDataType) {
        if (entry.version === 2) {
          if (entry.initDataHash === hash) {
            try {
              var decodedInitData = typeof entry.initData === "string" ? persistent_sessions_store_InitDataContainer.decode(entry.initData) : entry.initData.initData;

              if (Object(are_arrays_of_numbers_equal["a" /* default */])(decodedInitData, initData)) {
                return i;
              }
            } catch (e) {
              log["a" /* default */].warn("EME-PSS: Could not decode initialization data.", e);
            }
          }
        } else if (entry.version === 1) {
          if (entry.initDataHash === hash) {
            if (typeof entry.initData.length === "undefined") {
              // If length is undefined, it has been linearized. We could still
              // convert it back to an Uint8Array but this would necessitate some
              // ugly unreadable logic for a very very minor possibility.
              // Just consider that it is a match based on the hash.
              return i;
            } else if (Object(are_arrays_of_numbers_equal["a" /* default */])(entry.initData, initData)) {
              return i;
            }
          }
        } else {
          if (entry.initData === hash) {
            return i;
          }
        }
      }
    }

    return -1;
  }
  /**
   * Use the given storage to store the current entries.
   */
  ;

  _proto2._save = function _save() {
    try {
      this._storage.save(this._entries);
    } catch (e) {
      log["a" /* default */].warn("EME-PSS: Could not save licenses in localStorage");
    }
  };

  return PersistentSessionsStore;
}();


// CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */

function createPersistentSessionsStorage(keySystemOptions) {
  if (keySystemOptions.persistentLicense !== true) {
    return null;
  }

  var licenseStorage = keySystemOptions.licenseStorage;

  if (licenseStorage == null) {
    throw new encrypted_media_error["a" /* default */]("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
  }

  log["a" /* default */].debug("EME: Set the given license storage");
  return new persistent_sessions_store_PersistentSessionsStore(licenseStorage);
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */


function getMediaKeysInfos(mediaElement, keySystemsConfigs) {
  return getMediaKeySystemAccess(mediaElement, keySystemsConfigs).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
    var _evt$value = evt.value,
        options = _evt$value.options,
        mediaKeySystemAccess = _evt$value.mediaKeySystemAccess;
    var currentState = media_keys_infos_store["a" /* default */].getState(mediaElement);
    var persistentSessionsStore = createPersistentSessionsStorage(options);

    if (currentState != null && evt.type === "reuse-media-key-system-access") {
      var mediaKeys = currentState.mediaKeys,
          loadedSessionsStore = currentState.loadedSessionsStore;
      return Object(of["a" /* of */])({
        mediaKeys: mediaKeys,
        loadedSessionsStore: loadedSessionsStore,
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        persistentSessionsStore: persistentSessionsStore
      });
    }

    log["a" /* default */].info("EME: Calling createMediaKeys on the MediaKeySystemAccess");
    return Object(rx_try_catch["a" /* default */])(function () {
      return Object(cast_to_observable["a" /* default */])(mediaKeySystemAccess.createMediaKeys());
    }, undefined).pipe(Object(catchError["a" /* catchError */])(function (error) {
      var message = error instanceof Error ? error.message : "Unknown error when creating MediaKeys.";
      throw new encrypted_media_error["a" /* default */]("CREATE_MEDIA_KEYS_ERROR", message);
    }), Object(map["a" /* map */])(function (mediaKeys) {
      log["a" /* default */].info("EME: MediaKeys created with success", mediaKeys);
      return {
        mediaKeys: mediaKeys,
        loadedSessionsStore: new loaded_sessions_store_LoadedSessionsStore(mediaKeys),
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        persistentSessionsStore: persistentSessionsStore
      };
    }));
  }));
}
// CONCATENATED MODULE: ./src/core/eme/init_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */

function initMediaKeys(mediaElement, keySystemsConfigs) {
  return getMediaKeysInfos(mediaElement, keySystemsConfigs).pipe(Object(mergeMap["a" /* mergeMap */])(function (mediaKeysInfos) {
    var attachMediaKeys$ = new ReplaySubject["a" /* ReplaySubject */](1);
    var shouldDisableOldMediaKeys = mediaElement.mediaKeys !== null && mediaElement.mediaKeys !== undefined && mediaKeysInfos.mediaKeys !== mediaElement.mediaKeys;
    var disableOldMediaKeys$ = shouldDisableOldMediaKeys ? disableMediaKeys(mediaElement) : Object(of["a" /* of */])(null);
    log["a" /* default */].debug("EME: Disabling old MediaKeys");
    return disableOldMediaKeys$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      log["a" /* default */].debug("EME: Disabled old MediaKeys. Waiting to attach new MediaKeys");
      return attachMediaKeys$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
        return attachMediaKeys(mediaKeysInfos, mediaElement);
      }), Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])({
        type: "attached-media-keys",
        value: mediaKeysInfos
      }), Object(startWith["a" /* startWith */])({
        type: "created-media-keys",
        value: {
          mediaKeysInfos: mediaKeysInfos,
          attachMediaKeys$: attachMediaKeys$
        }
      }));
    }));
  }));
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(37);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(38);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(109);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/ (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
var TimeoutError = TimeoutErrorImpl;
//# sourceMappingURL=TimeoutError.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(114);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */




function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    return function (source) {
        var absoluteTimeout = Object(isDate["a" /* isDate */])(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var timeoutWith_TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(Object(innerSubscribe["c" /* innerSubscribe */])(withObservable, new innerSubscribe["a" /* SimpleInnerSubscriber */](subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(innerSubscribe["b" /* SimpleOuterSubscriber */]));
//# sourceMappingURL=timeoutWith.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    return timeoutWith(due, Object(throwError["a" /* throwError */])(new TimeoutError()), scheduler);
}
//# sourceMappingURL=timeout.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return Object(mergeMap["a" /* mergeMap */])(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(233);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(189);

// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(119);

// CONCATENATED MODULE: ./src/utils/rx-retry_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */

function retryObsWithBackoff(obs$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      totalRetry = options.totalRetry,
      shouldRetry = options.shouldRetry,
      onRetry = options.onRetry;
  var retryCount = 0;
  return obs$.pipe(Object(catchError["a" /* catchError */])(function (error, source) {
    if (!Object(is_null_or_undefined["a" /* default */])(shouldRetry) && !shouldRetry(error) || retryCount++ >= totalRetry) {
      throw error;
    }

    if (typeof onRetry === "function") {
      onRetry(error, retryCount);
    }

    var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
    var fuzzedDelay = Object(get_fuzzed_delay["a" /* default */])(delay);
    return Object(timer["a" /* timer */])(fuzzedDelay).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return source;
    }));
  }));
}
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(11);

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(24);

// CONCATENATED MODULE: ./src/compat/eme/get_uuid_kid_from_keystatus_kid.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get KID from MediaKeySession keyStatus, and convert it in usual big-endian kid
 * if necessary. On EDGE, Microsoft Playready KID are presented into little-endian GUID.
 * @param {String} keySystem
 * @param {Uint8Array} baseKeyId
 * @returns {Uint8Array}
 */

function getUUIDKIDFromKeyStatusKID(keySystem, baseKeyId) {
  if (keySystem.indexOf("playready") !== -1 && (browser_detection["d" /* isIEOrEdge */] || browser_detection["a" /* isEdgeChromium */])) {
    return Object(string_parsing["b" /* guidToUuid */])(baseKeyId);
  }

  return baseKeyId;
}
// CONCATENATED MODULE: ./src/core/eme/check_key_statuses.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var KEY_STATUSES = {
  EXPIRED: "expired",
  INTERNAL_ERROR: "internal-error",
  OUTPUT_RESTRICTED: "output-restricted"
};
/**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings and blacklisted key ids.
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} keySystemOptions - Options. Used to known on which situations
 * we can fallback.
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @returns {Array} - Warnings to send and blacklisted key ids.
 */

function checkKeyStatuses(session, keySystemOptions, keySystem) {
  var warnings = [];
  var blacklistedKeyIDs = [];
  var _keySystemOptions$fal = keySystemOptions.fallbackOn,
      fallbackOn = _keySystemOptions$fal === void 0 ? {} : _keySystemOptions$fal,
      throwOnLicenseExpiration = keySystemOptions.throwOnLicenseExpiration;
  /* tslint:disable no-unsafe-any */

  session.keyStatuses.forEach(function (_arg1, _arg2) {
    /* tslint:enable no-unsafe-any */
    // Hack present because the order of the arguments has changed in spec
    // and is not the same between some versions of Edge and Chrome.
    var _ref = function () {
      return typeof _arg1 === "string" ? [_arg1, _arg2] : [_arg2, _arg1];
    }(),
        keyStatus = _ref[0],
        keyStatusKeyId = _ref[1];

    var keyId = getUUIDKIDFromKeyStatusKID(keySystem, new Uint8Array(keyStatusKeyId));

    switch (keyStatus) {
      case KEY_STATUSES.EXPIRED:
        {
          var error = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "A decryption key expired");

          if (throwOnLicenseExpiration !== false) {
            throw error;
          }

          warnings.push({
            type: "warning",
            value: error
          });
          break;
        }

      case KEY_STATUSES.INTERNAL_ERROR:
        {
          var _error = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " + "encountered: " + keyStatus);

          if (fallbackOn.keyInternalError !== true) {
            throw _error;
          }

          warnings.push({
            type: "warning",
            value: _error
          });
          blacklistedKeyIDs.push(keyId);
          break;
        }

      case KEY_STATUSES.OUTPUT_RESTRICTED:
        {
          var _error2 = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " + "encountered: " + keyStatus);

          if (fallbackOn.keyOutputRestricted !== true) {
            throw _error2;
          }

          warnings.push({
            type: "warning",
            value: _error2
          });
          blacklistedKeyIDs.push(keyId);
          break;
        }
    }
  });
  return [warnings, blacklistedKeyIDs];
}
// CONCATENATED MODULE: ./src/core/eme/session_events_listener.ts




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var onKeyError$ = compat["a" /* events */].onKeyError$,
    onKeyMessage$ = compat["a" /* events */].onKeyMessage$,
    onKeyStatusesChange$ = compat["a" /* events */].onKeyStatusesChange$;
/**
 * Error thrown when the MediaKeySession is blacklisted.
 * Such MediaKeySession should not be re-used but other MediaKeySession for the
 * same content can still be used.
 * @class BlacklistedSessionError
 * @extends Error
 */

var session_events_listener_BlacklistedSessionError = /*#__PURE__*/function (_Error) {
  inheritsLoose_default()(BlacklistedSessionError, _Error);

  function BlacklistedSessionError(sessionError) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(assertThisInitialized_default()(_this), BlacklistedSessionError.prototype);
    _this.sessionError = sessionError;
    return _this;
  }

  return BlacklistedSessionError;
}( /*#__PURE__*/wrapNativeSuper_default()(Error));
/**
 * listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystemOptions - The key system options.
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @param {Object} initDataInfo - The initialization data linked to that
 * session.
 * @returns {Observable}
 */

function SessionEventsListener(session, keySystemOptions, keySystem, _ref) {
  var initData = _ref.initData,
      initDataType = _ref.initDataType;
  log["a" /* default */].info("EME: Binding session events", session);
  var sessionWarningSubject$ = new Subject["a" /* Subject */]();
  var _keySystemOptions$get = keySystemOptions.getLicenseConfig,
      getLicenseConfig = _keySystemOptions$get === void 0 ? {} : _keySystemOptions$get;
  var keyErrors = onKeyError$(session).pipe(Object(map["a" /* map */])(function (error) {
    throw new encrypted_media_error["a" /* default */]("KEY_ERROR", error.type);
  }));
  var keyStatusesChange$ = onKeyStatusesChange$(session).pipe(Object(mergeMap["a" /* mergeMap */])(function (keyStatusesEvent) {
    return handleKeyStatusesChangeEvent(session, keySystemOptions, keySystem, keyStatusesEvent);
  }));
  var keyMessages$ = onKeyMessage$(session).pipe(Object(mergeMap["a" /* mergeMap */])(function (messageEvent) {
    var message = new Uint8Array(messageEvent.message);
    var messageType = Object(is_non_empty_string["a" /* default */])(messageEvent.messageType) ? messageEvent.messageType : "license-request";
    log["a" /* default */].info("EME: Received message event, type " + messageType, session, messageEvent);
    var getLicense$ = Object(defer["a" /* defer */])(function () {
      var getLicense = keySystemOptions.getLicense(message, messageType);
      var getLicenseTimeout = Object(is_null_or_undefined["a" /* default */])(getLicenseConfig.timeout) ? 10 * 1000 : getLicenseConfig.timeout;
      return Object(cast_to_observable["a" /* default */])(getLicense).pipe(getLicenseTimeout >= 0 ? timeout(getLicenseTimeout) : identity["a" /* identity */]
      /* noop */
      );
    });
    var backoffOptions = getLicenseBackoffOptions(sessionWarningSubject$, getLicenseConfig.retry);
    return retryObsWithBackoff(getLicense$, backoffOptions).pipe(Object(map["a" /* map */])(function (licenseObject) {
      return {
        type: "key-message-handled",
        value: {
          session: session,
          license: licenseObject
        }
      };
    }), Object(catchError["a" /* catchError */])(function (err) {
      var formattedError = formatGetLicenseError(err);

      if (!Object(is_null_or_undefined["a" /* default */])(err)) {
        var fallbackOnLastTry = err.fallbackOnLastTry;

        if (fallbackOnLastTry === true) {
          log["a" /* default */].warn("EME: Last `getLicense` attempt failed. " + "Blacklisting the current session.");
          throw new session_events_listener_BlacklistedSessionError(formattedError);
        }
      }

      throw formattedError;
    }), Object(startWith["a" /* startWith */])({
      type: "session-message",
      value: {
        messageType: messageType,
        initData: initData,
        initDataType: initDataType
      }
    }));
  }));
  var sessionUpdates = Object(merge["a" /* merge */])(keyMessages$, keyStatusesChange$).pipe(concatMap(function (evt) {
    switch (evt.type) {
      case "key-message-handled":
      case "key-status-change-handled":
        return updateSessionWithMessage(session, evt.value.license, initData, initDataType);

      default:
        return Object(of["a" /* of */])(evt);
    }
  }));
  var sessionEvents = Object(merge["a" /* merge */])(getKeyStatusesEvents(session, keySystemOptions, keySystem), sessionUpdates, keyErrors, sessionWarningSubject$);
  return !Object(is_null_or_undefined["a" /* default */])(session.closed) ? sessionEvents.pipe(Object(takeUntil["a" /* takeUntil */])(Object(cast_to_observable["a" /* default */])(session.closed))) : sessionEvents;
}
/**
 * Check current MediaKeyStatus for each key in the given MediaKeySession and
 * return an Observable which either:
 *    - throw if at least one status is a non-recoverable error
 *    - emit warning events for recoverable errors
 *    - emit blacklist-keys events for key IDs that are not decipherable
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystemOptions - The key system options.
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @returns {Observable}
 */

function getKeyStatusesEvents(session, keySystemOptions, keySystem) {
  return Object(defer["a" /* defer */])(function () {
    var _checkKeyStatuses = checkKeyStatuses(session, keySystemOptions, keySystem),
        warnings = _checkKeyStatuses[0],
        blacklistedKeyIDs = _checkKeyStatuses[1];

    var warnings$ = warnings.length > 0 ? of["a" /* of */].apply(void 0, warnings) : empty["a" /* EMPTY */];
    var blackListUpdate$ = blacklistedKeyIDs.length > 0 ? Object(of["a" /* of */])({
      type: "blacklist-keys",
      value: blacklistedKeyIDs
    }) : empty["a" /* EMPTY */];
    return Object(concat["a" /* concat */])(warnings$, blackListUpdate$);
  });
}
/**
 * Format an error returned by a `getLicense` call to a proper form as defined
 * by the RxPlayer's API.
 * @param {*} error
 * @returns {Error}
 */


function formatGetLicenseError(error) {
  if (error instanceof TimeoutError) {
    return new encrypted_media_error["a" /* default */]("KEY_LOAD_TIMEOUT", "The license server took too much time to " + "respond.");
  }

  var err = new encrypted_media_error["a" /* default */]("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");

  if (!Object(is_null_or_undefined["a" /* default */])(error) && Object(is_non_empty_string["a" /* default */])(error.message)) {
    err.message = error.message;
  }

  return err;
}
/**
 * Call MediaKeySession.update with the given `message`, if defined.
 * Returns the right event depending on the action taken.
 * @param {MediaKeySession} session
 * @param {ArrayBuffer|TypedArray|null} message
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @returns {Observable}
 */


function updateSessionWithMessage(session, message, initData, initDataType) {
  if (Object(is_null_or_undefined["a" /* default */])(message)) {
    log["a" /* default */].info("EME: No message given, skipping session.update");
    return Object(of["a" /* of */])({
      type: "no-update",
      value: {
        initData: initData,
        initDataType: initDataType
      }
    });
  }

  log["a" /* default */].info("EME: Updating MediaKeySession with message");
  return Object(cast_to_observable["a" /* default */])(session.update(message)).pipe(Object(catchError["a" /* catchError */])(function (error) {
    var reason = error instanceof Error ? error.toString() : "`session.update` failed";
    throw new encrypted_media_error["a" /* default */]("KEY_UPDATE_ERROR", reason);
  }), Object(tap["a" /* tap */])(function () {
    log["a" /* default */].info("EME: MediaKeySession update succeeded.");
  }), Object(mapTo["a" /* mapTo */])({
    type: "session-updated",
    value: {
      session: session,
      license: message,
      initData: initData,
      initDataType: initDataType
    }
  }));
}
/**
 * @param {MediaKeySession}
 * @param {Object} keySystem
 * @param {Event} keyStatusesEvent
 * @returns {Observable}
 */


function handleKeyStatusesChangeEvent(session, keySystemOptions, keySystem, keyStatusesEvent) {
  log["a" /* default */].info("EME: keystatuseschange event received", session, keyStatusesEvent);
  var callback$ = Object(defer["a" /* defer */])(function () {
    if (typeof keySystemOptions.onKeyStatusesChange !== "function") {
      return empty["a" /* EMPTY */];
    }

    return Object(cast_to_observable["a" /* default */])(keySystemOptions.onKeyStatusesChange(keyStatusesEvent, session));
  }).pipe(Object(map["a" /* map */])(function (licenseObject) {
    return {
      type: "key-status-change-handled",
      value: {
        session: session,
        license: licenseObject
      }
    };
  }), Object(catchError["a" /* catchError */])(function (error) {
    var err = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");

    if (!Object(is_null_or_undefined["a" /* default */])(error) && Object(is_non_empty_string["a" /* default */])(error.message)) {
      err.message = error.message;
    }

    throw err;
  }));
  return Object(concat["a" /* concat */])(getKeyStatusesEvents(session, keySystemOptions, keySystem), callback$);
}
/**
 * Construct backoff options for the getLicense call.
 * @param {Subject} sessionWarningSubject$ - Subject through which retry
 * warnings will be sent.
 * @param {number|undefined} numberOfRetry - Maximum of amount retried.
 * Equal to `2` if not defined.
 * @returns {Object}
 */


function getLicenseBackoffOptions(sessionWarningSubject$, numberOfRetry) {
  return {
    totalRetry: numberOfRetry !== null && numberOfRetry !== void 0 ? numberOfRetry : 2,
    baseDelay: 200,
    maxDelay: 3000,
    shouldRetry: function shouldRetry(error) {
      return error instanceof TimeoutError || Object(is_null_or_undefined["a" /* default */])(error) || error.noRetry !== true;
    },
    onRetry: function onRetry(error) {
      return sessionWarningSubject$.next({
        type: "warning",
        value: formatGetLicenseError(error)
      });
    }
  };
}
// CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Call the setServerCertificate API with the given certificate.
 * Complete observable on success, throw when failed.
 *
 * TODO Handle returned value?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */

function setServerCertificate(mediaKeys, serverCertificate) {
  return Object(defer["a" /* defer */])(function () {
    return Object(rx_try_catch["a" /* default */])(function () {
      return Object(cast_to_observable["a" /* default */])(mediaKeys.setServerCertificate(serverCertificate));
    }, undefined).pipe(Object(catchError["a" /* catchError */])(function (error) {
      log["a" /* default */].warn("EME: mediaKeys.setServerCertificate returned an error", error);
      var reason = error instanceof Error ? error.toString() : "`setServerCertificate` error";
      throw new encrypted_media_error["a" /* default */]("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
    }));
  });
}
/**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */


function trySettingServerCertificate(mediaKeys, serverCertificate) {
  return Object(defer["a" /* defer */])(function () {
    if (typeof mediaKeys.setServerCertificate !== "function") {
      log["a" /* default */].warn("EME: Could not set the server certificate." + " mediaKeys.setServerCertificate is not a function");
      return empty["a" /* EMPTY */];
    }

    log["a" /* default */].info("EME: Setting server certificate on the MediaKeys");
    return setServerCertificate(mediaKeys, serverCertificate).pipe(Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {
      return Object(of["a" /* of */])({
        type: "warning",
        value: error
      });
    }));
  });
}

// CONCATENATED MODULE: ./src/core/eme/eme_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















var EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION = config["a" /* default */].EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION;
var onEncrypted$ = compat["a" /* events */].onEncrypted$;
/**
 * EME abstraction used to communicate with the Content Decryption Module (or
 * CDM) to be able to decrypt contents.
 *
 * The `EMEManager` can be given one or multiple key systems. It will choose the
 * appropriate one depending on user settings and browser support.
 * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
 * associated to a MediaKeys object
 * @param {Array.<Object>} keySystemsConfigs - key system configuration
 * @param {Observable} contentProtections$ - Observable emitting external
 * initialization data.
 * @returns {Observable}
 */

function EMEManager(mediaElement, keySystemsConfigs, contentProtections$) {
  log["a" /* default */].debug("EME: Starting EMEManager logic.");
  /**
   * Keep track of all initialization data handled for the current `EMEManager`
   * instance.
   * This allows to avoid handling multiple times the same encrypted events.
   */

  var handledInitData = new init_data_store_InitDataStore();
  /**
   * Keep track of which initialization data have been blacklisted (linked to
   * non-decypherable content).
   * If the same initialization data is encountered again, we can directly emit
   * the same `BlacklistedSessionError`.
   */

  var blacklistedInitData = new init_data_store_InitDataStore();
  /** Emit the MediaKeys instance and its related information when ready. */

  var mediaKeysInfos$ = initMediaKeys(mediaElement, keySystemsConfigs).pipe(Object(shareReplay["a" /* shareReplay */])()); // Share side-effects and cache success

  /** Emit when the MediaKeys instance has been attached the HTMLMediaElement. */

  var attachedMediaKeys$ = mediaKeysInfos$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "attached-media-keys";
  }), Object(take["a" /* take */])(1));
  /** Parsed `encrypted` events coming from the HTMLMediaElement. */

  var mediaEncryptedEvents$ = onEncrypted$(mediaElement).pipe(Object(tap["a" /* tap */])(function (evt) {
    log["a" /* default */].debug("EME: Encrypted event received from media element.", evt);
  }), Object(filter_map["a" /* default */])(function (evt) {
    var _getInitData = Object(get_init_data["a" /* default */])(evt),
        initData = _getInitData.initData,
        initDataType = _getInitData.initDataType;

    if (initData === null) {
      return null;
    }

    return {
      type: initDataType,
      data: initData
    };
  }, null), Object(shareReplay["a" /* shareReplay */])({
    refCount: true
  })); // multiple Observables listen to that one
  // as soon as the EMEManager is subscribed

  /** Encryption events coming from the `contentProtections$` argument. */

  var externalEvents$ = contentProtections$.pipe(Object(tap["a" /* tap */])(function (evt) {
    log["a" /* default */].debug("EME: Encrypted event received from Player", evt);
  }));
  /** Emit events signaling that an encryption initialization data is encountered. */

  var encryptedEvents$ = Object(merge["a" /* merge */])(externalEvents$, mediaEncryptedEvents$);
  /** Create MediaKeySessions and handle the corresponding events. */

  var bindSession$ = encryptedEvents$.pipe( // Add attached MediaKeys info once available
  Object(mergeMap["a" /* mergeMap */])(function (encryptedEvt) {
    return attachedMediaKeys$.pipe(Object(map["a" /* map */])(function (mediaKeysEvt) {
      return [encryptedEvt, mediaKeysEvt];
    }));
  }),
  /* Attach server certificate and create/reuse MediaKeySession */
  Object(mergeMap["a" /* mergeMap */])(function (_ref, i) {
    var encryptedEvent = _ref[0],
        mediaKeysEvent = _ref[1];
    var mediaKeysInfos = mediaKeysEvent.value;
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeys = mediaKeysInfos.mediaKeys;
    var serverCertificate = keySystemOptions.serverCertificate;
    var initDataType = encryptedEvent.type,
        initData = encryptedEvent.data;
    var blacklistError = blacklistedInitData.get(initData, initDataType);

    if (blacklistError !== undefined) {
      if (initDataType === undefined) {
        log["a" /* default */].error("EME: The current session has already been blacklisted " + "but the current content is not known. Throwing.");
        var sessionError = blacklistError.sessionError;
        sessionError.fatal = true;
        return Object(throwError["a" /* throwError */])(sessionError);
      }

      log["a" /* default */].warn("EME: The current session has already been blacklisted. " + "Blacklisting content.");
      return Object(of["a" /* of */])({
        type: "blacklist-protection-data",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }

    if (!handledInitData.storeIfNone(initData, initDataType, true)) {
      log["a" /* default */].debug("EME: Init data already received. Skipping it.");
      return Object(of["a" /* of */])({
        type: "init-data-ignored",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }

    var session$ = getSession(encryptedEvent, mediaKeysInfos).pipe(Object(map["a" /* map */])(function (evt) {
      if (evt.type === "cleaning-old-session") {
        handledInitData.remove(evt.value.initData, evt.value.initDataType);
      }

      return {
        type: evt.type,
        value: Object(object_assign["a" /* default */])({
          keySystemOptions: mediaKeysInfos.keySystemOptions,
          persistentSessionsStore: mediaKeysInfos.persistentSessionsStore,
          keySystem: mediaKeysInfos.mediaKeySystemAccess.keySystem
        }, evt.value)
      };
    }));

    if (i === 0) {
      // first encrypted event for the current content
      return Object(merge["a" /* merge */])(serverCertificate != null ? Object(concat["a" /* concat */])(trySettingServerCertificate(mediaKeys, serverCertificate), session$) : session$);
    }

    return session$;
  }),
  /* Trigger license request and manage MediaKeySession events */
  Object(mergeMap["a" /* mergeMap */])(function (sessionInfosEvt) {
    switch (sessionInfosEvt.type) {
      case "warning":
      case "blacklist-protection-data":
      case "init-data-ignored":
        return Object(of["a" /* of */])(sessionInfosEvt);

      case "cleaned-old-session":
      case "cleaning-old-session":
        return empty["a" /* EMPTY */];

      case "created-session":
      case "loaded-open-session":
      case "loaded-persistent-session":
        // Do nothing, just to check every possibility is taken
        break;

      default:
        // Use TypeScript to check if all possibilities have been checked
        Object(assert_unreachable["a" /* default */])(sessionInfosEvt);
    }

    var _sessionInfosEvt$valu = sessionInfosEvt.value,
        initData = _sessionInfosEvt$valu.initData,
        initDataType = _sessionInfosEvt$valu.initDataType,
        mediaKeySession = _sessionInfosEvt$valu.mediaKeySession,
        sessionType = _sessionInfosEvt$valu.sessionType,
        keySystemOptions = _sessionInfosEvt$valu.keySystemOptions,
        persistentSessionsStore = _sessionInfosEvt$valu.persistentSessionsStore,
        keySystem = _sessionInfosEvt$valu.keySystem;
    var generateRequest$ = sessionInfosEvt.type !== "created-session" ? empty["a" /* EMPTY */] : Object(generate_key_request["a" /* default */])(mediaKeySession, initData, initDataType).pipe(Object(tap["a" /* tap */])(function () {
      if (sessionType === "persistent-license" && persistentSessionsStore !== null) {
        cleanOldStoredPersistentInfo(persistentSessionsStore, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION - 1);
        persistentSessionsStore.add(initData, initDataType, mediaKeySession);
      }
    }), Object(catchError["a" /* catchError */])(function (error) {
      throw new encrypted_media_error["a" /* default */]("KEY_GENERATE_REQUEST_ERROR", error instanceof Error ? error.toString() : "Unknown error");
    }), Object(ignoreElements["a" /* ignoreElements */])());
    return Object(merge["a" /* merge */])(SessionEventsListener(mediaKeySession, keySystemOptions, keySystem, {
      initData: initData,
      initDataType: initDataType
    }), generateRequest$).pipe(Object(catchError["a" /* catchError */])(function (err) {
      if (!(err instanceof session_events_listener_BlacklistedSessionError)) {
        throw err;
      }

      blacklistedInitData.store(initData, initDataType, err);
      var sessionError = err.sessionError;

      if (initDataType === undefined) {
        log["a" /* default */].error("EME: Current session blacklisted and content not known. " + "Throwing.");
        sessionError.fatal = true;
        throw sessionError;
      }

      log["a" /* default */].warn("EME: Current session blacklisted. Blacklisting content.");
      return Object(of["a" /* of */])({
        type: "warning",
        value: sessionError
      }, {
        type: "blacklist-protection-data",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }));
  }));
  return Object(merge["a" /* merge */])(mediaKeysInfos$, mediaEncryptedEvents$.pipe(Object(map["a" /* map */])(function (evt) {
    return {
      type: "encrypted-event-received",
      value: evt
    };
  })), bindSession$);
}
// EXTERNAL MODULE: ./src/core/eme/get_current_key_system.ts
var get_current_key_system = __webpack_require__(165);

// CONCATENATED MODULE: ./src/core/eme/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */





/* harmony default export */ var eme = __webpack_exports__["default"] = (EMEManager);


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldUnsetMediaKeys; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */

function shouldUnsetMediaKeys() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIE11 */ "c"];
}

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isCodecSupported; });
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @param {string} mimeType - The MIME media type that you want to test support
 * for in the current browser.
 * This may include the codecs parameter to provide added details about the
 * codecs used within the file.
 * @returns {Boolean}
 */

function isCodecSupported(mimeType) {
  if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"] == null) {
    return false;
  }
  /* tslint:disable no-unbound-method */


  if (typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"].isTypeSupported === "function") {
    /* tslint:enable no-unbound-method */
    return _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"].isTypeSupported(mimeType);
  }

  return true;
}

/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setElementSrc$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _clear_element_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */

function setElementSrc$(mediaElement, url) {
  return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (observer) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Setting URL to Element", url, mediaElement);
    mediaElement.src = url;
    observer.next(undefined);
    return function () {
      Object(_clear_element_src__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(mediaElement);
    };
  });
}

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldWaitForDataBeforeLoaded; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some browsers, the ready state might never go above `1` when autoplay is
 * blocked. On these cases, for now, we just advertise the content as "loaded".
 * We might go into BUFFERING just after that state, but that's a small price to
 * pay.
 * @param {Boolean} isDirectfile
 * @returns {Boolean}
 */

function shouldWaitForDataBeforeLoaded(isDirectfile, mustPlayInline) {
  if (isDirectfile && _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSafariMobile */ "f"]) {
    return mustPlayInline;
  }

  return true;
}

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return play$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function play$(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    return (// mediaElement.play is not always a Promise. In the improbable case it
      // throws, I prefer still to catch to return the error wrapped in an
      // Observable
      Object(_utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(function () {
        return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(mediaElement.play());
      }, undefined)
    );
  });
}

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return whenLoadedMetadata$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(145);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34);
/* harmony import */ var _event_listeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function whenLoadedMetadata$(mediaElement) {
  if (mediaElement.readyState >= _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__[/* READY_STATES */ "d"].HAVE_METADATA) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(null);
  } else {
    return Object(_event_listeners__WEBPACK_IMPORTED_MODULE_3__["onLoadedMetadata$"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* take */ "a"])(1));
  }
}

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hasEMEAPIs; });
/* harmony import */ var _eme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(193);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */

function hasEMEAPIs() {
  return typeof _eme__WEBPACK_IMPORTED_MODULE_0__[/* requestMediaKeySystemAccess */ "a"] === "function";
}

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(208);


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return distinctUntilChanged; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=distinctUntilChanged.js.map


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ignoreElements; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=ignoreElements.js.map


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__[/* isFunction */ "a"])(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
            _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
            _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=tap.js.map


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filter; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=filter.js.map


/***/ }),
/* 160 */,
/* 161 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldRenewMediaKeys; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */

function shouldRenewMediaKeys() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIE11 */ "c"];
}

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearEMESession; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(157);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(148);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _dispose_media_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(120);
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(44);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function clearEMESession(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].info("EME: Clearing-up EME session.");

    if (Object(_compat___WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])()) {
      _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].info("EME: disposing current MediaKeys.");
      return Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* ignoreElements */ "a"])());
    }

    var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].getState(mediaElement);

    if (currentState !== null && currentState.keySystemOptions.closeSessionsOnStop === true) {
      _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].info("EME: closing all current sessions.");
      return currentState.loadedSessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* ignoreElements */ "a"])());
    }

    _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].info("EME: Nothing to clear. Returning right away. No state =", currentState === null);
    return rxjs__WEBPACK_IMPORTED_MODULE_1__[/* EMPTY */ "a"];
  });
}

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disposeEME; });
/* harmony import */ var _utils_noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Free up all ressources taken by the EME management.
 */

function disposeEME(mediaElement) {
  Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(mediaElement).subscribe(_utils_noop__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);
}

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCurrentKeySystem; });
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the name of the current key system used.
 * @param {HTMLMediaElement} mediaElement
 * @returns {string|null}
 */

function getCurrentKeySystem(mediaElement) {
  var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getState(mediaElement);
  return currentState == null ? null : currentState.keySystemOptions.type;
}

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return canPatchISOBMFFSegment; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */

function canPatchISOBMFFSegment() {
  return !_browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIEOrEdge */ "d"];
}

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addTextTrack; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add text track to the given media element.
 *
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden - If `true`, the text track will be hidden by
 * default. If `false`, the text track will be directly showing.
 * @returns {Object}
 */

function addTextTrack(mediaElement, hidden) {
  var _a, _b;

  var track;
  var trackElement;
  var kind = "subtitles";

  if (_browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIEOrEdge */ "d"]) {
    var tracksLength = mediaElement.textTracks.length;
    track = tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);
    track.mode = hidden ? (_a = track.HIDDEN) !== null && _a !== void 0 ? _a : "hidden" : (_b = track.SHOWING) !== null && _b !== void 0 ? _b : "showing";
  } else {
    trackElement = document.createElement("track");
    mediaElement.appendChild(trackElement);
    track = trackElement.track;
    trackElement.kind = kind;
    track.mode = hidden ? "hidden" : "showing";
  }

  return {
    track: track,
    trackElement: trackElement
  };
}

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isVTTCue; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
function isVTTCue(cue) {
  /* tslint:disable no-unsafe-any */
  return typeof window.VTTCue === "function" && cue instanceof window.VTTCue;
  /* tslint:enable no-unsafe-any */
}

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return onHeightWidthChange; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(227);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(184);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(156);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var _ResizeObserver = _is_node__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"] ? undefined : window.ResizeObserver;
/* tslint:enable no-unsafe-any */

/**
 * Emit the current height and width of the given `element` on subscribtion
 * and each time it changes.
 *
 * On some browsers, we might not be able to rely on a native API to know when
 * it changes, the `interval` argument allow us to provide us an inverval in
 * milliseconds at which we should query that element's size.
 * @param {HTMLElement} element
 * @param {number} interval
 * @returns {Observable}
 */


function onHeightWidthChange(element, interval) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    if (_ResizeObserver !== undefined) {
      var lastHeight = -1;
      var lastWidth = -1;
      return new rxjs__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"](function (obs) {
        var resizeObserver = new _ResizeObserver(function (entries) {
          if (entries.length === 0) {
            _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].error("Compat: Resized but no observed element.");
            return;
          }

          var entry = entries[0];
          var _entry$contentRect = entry.contentRect,
              height = _entry$contentRect.height,
              width = _entry$contentRect.width;

          if (height !== lastHeight || width !== lastWidth) {
            lastHeight = height;
            lastWidth = width;
            obs.next({
              height: height,
              width: width
            });
          }
        });
        resizeObserver.observe(element);
        return function () {
          resizeObserver.disconnect();
        };
      });
    }

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* interval */ "a"])(interval).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* startWith */ "a"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function () {
      var _element$getBoundingC = element.getBoundingClientRect(),
          height = _element$getBoundingC.height,
          width = _element$getBoundingC.width;

      return {
        height: height,
        width: width
      };
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* distinctUntilChanged */ "a"])(function (o, n) {
      return o.height === n.height && o.width === n.width;
    }));
  });
}

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addClassName; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var hasClassList;
/**
 * Add className to an HTMLElement. Do nothing if the className was already
 * added.
 * @param {HTMLElement} elt
 * @param {string} className
 */

function addClassName(elt, className) {
  if (hasClassList === undefined) {
    hasClassList = elt.classList !== undefined &&
    /* tslint:disable no-unbound-method */
    typeof elt.classList.add === "function";
    /* tslint:enable no-unbound-method */
  }

  if (hasClassList) {
    elt.classList.add(className);
  } else {
    var classNamesWithSpaces = " " + elt.className + " ";

    if (classNamesWithSpaces.indexOf(" " + className + " ") < 0) {
      elt.className += " " + className;
    }
  }
}

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isOffline; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
  /* tslint:disable no-boolean-literal-compare */
  return navigator.onLine === false;
  /* tslint:enable no-boolean-literal-compare */
}

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areSameContent; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */
function areSameContent(content1, content2) {
  return content1.segment.id === content2.segment.id && content1.representation.id === content2.representation.id && content1.adaptation.id === content2.adaptation.id && content1.period.id === content2.period.id;
}

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tryToChangeSourceBufferType; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */

function tryToChangeSourceBufferType(sourceBuffer, codec) {
  if (typeof sourceBuffer.changeType === "function") {
    try {
      sourceBuffer.changeType(codec);
    } catch (e) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Could not call 'changeType' on the given SourceBuffer:", e);
      return false;
    }

    return true;
  }

  return false;
}

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPlaybackStuck; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */

function isPlaybackStuck(time, currentRange, state, isStalled) {
  var FREEZE_THRESHOLD = 10; // freeze threshold in seconds

  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isFirefox */ "b"] && isStalled && state === "timeupdate" && currentRange != null && currentRange.end - time > FREEZE_THRESHOLD;
}

/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldReloadMediaSourceOnDecipherabilityUpdate; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if we have to reload the MediaSource due to an update in the
 * decipherability status of some segments based on the current key sytem.
 *
 * We found that on all Widevine targets tested, a simple seek is sufficient.
 * As widevine clients make a good chunk of users, we can make a difference
 * between them and others as it is for the better.
 * @param {string|null} currentKeySystem
 * @returns {Boolean}
 */
function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {
  return currentKeySystem === null || currentKeySystem.indexOf("widevine") < 0;
}

/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concatAll; });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(110);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
    return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__[/* mergeAll */ "a"])(1);
}
//# sourceMappingURL=concatAll.js.map


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var NOOP = function () {};
var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
	// run promise callbacks
	for (var i = 0; i < asyncQueue.length; i++) {
		asyncQueue[i][0](asyncQueue[i][1]);
	}

	// reset async asyncQueue
	asyncQueue = [];
	asyncTimer = false;
}

function asyncCall(callback, arg) {
	asyncQueue.push([callback, arg]);

	if (!asyncTimer) {
		asyncTimer = true;
		asyncSetTimer(asyncFlush, 0);
	}
}

function invokeResolver(resolver, promise) {
	function resolvePromise(value) {
		resolve(promise, value);
	}

	function rejectPromise(reason) {
		reject(promise, reason);
	}

	try {
		resolver(resolvePromise, rejectPromise);
	} catch (e) {
		rejectPromise(e);
	}
}

function invokeCallback(subscriber) {
	var owner = subscriber.owner;
	var settled = owner._state;
	var value = owner._data;
	var callback = subscriber[settled];
	var promise = subscriber.then;

	if (typeof callback === 'function') {
		settled = FULFILLED;
		try {
			value = callback(value);
		} catch (e) {
			reject(promise, e);
		}
	}

	if (!handleThenable(promise, value)) {
		if (settled === FULFILLED) {
			resolve(promise, value);
		}

		if (settled === REJECTED) {
			reject(promise, value);
		}
	}
}

function handleThenable(promise, value) {
	var resolved;

	try {
		if (promise === value) {
			throw new TypeError('A promises callback cannot return that same promise.');
		}

		if (value && (typeof value === 'function' || typeof value === 'object')) {
			// then should be retrieved only once
			var then = value.then;

			if (typeof then === 'function') {
				then.call(value, function (val) {
					if (!resolved) {
						resolved = true;

						if (value === val) {
							fulfill(promise, val);
						} else {
							resolve(promise, val);
						}
					}
				}, function (reason) {
					if (!resolved) {
						resolved = true;

						reject(promise, reason);
					}
				});

				return true;
			}
		}
	} catch (e) {
		if (!resolved) {
			reject(promise, e);
		}

		return true;
	}

	return false;
}

function resolve(promise, value) {
	if (promise === value || !handleThenable(promise, value)) {
		fulfill(promise, value);
	}
}

function fulfill(promise, value) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = value;

		asyncCall(publishFulfillment, promise);
	}
}

function reject(promise, reason) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = reason;

		asyncCall(publishRejection, promise);
	}
}

function publish(promise) {
	promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
	promise._state = FULFILLED;
	publish(promise);
}

function publishRejection(promise) {
	promise._state = REJECTED;
	publish(promise);
	if (!promise._handled && isNode) {
		global.process.emit('unhandledRejection', promise._data, promise);
	}
}

function notifyRejectionHandled(promise) {
	global.process.emit('rejectionHandled', promise);
}

/**
 * @class
 */
function Promise(resolver) {
	if (typeof resolver !== 'function') {
		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
	}

	if (this instanceof Promise === false) {
		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
	}

	this._then = [];

	invokeResolver(resolver, this);
}

Promise.prototype = {
	constructor: Promise,

	_state: PENDING,
	_then: null,
	_data: undefined,
	_handled: false,

	then: function (onFulfillment, onRejection) {
		var subscriber = {
			owner: this,
			then: new this.constructor(NOOP),
			fulfilled: onFulfillment,
			rejected: onRejection
		};

		if ((onRejection || onFulfillment) && !this._handled) {
			this._handled = true;
			if (this._state === REJECTED && isNode) {
				asyncCall(notifyRejectionHandled, this);
			}
		}

		if (this._state === FULFILLED || this._state === REJECTED) {
			// already resolved, call callback async
			asyncCall(invokeCallback, subscriber);
		} else {
			// subscribe
			this._then.push(subscriber);
		}

		return subscriber.then;
	},

	catch: function (onRejection) {
		return this.then(null, onRejection);
	}
};

Promise.all = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.all().');
	}

	return new Promise(function (resolve, reject) {
		var results = [];
		var remaining = 0;

		function resolver(index) {
			remaining++;
			return function (value) {
				results[index] = value;
				if (!--remaining) {
					resolve(results);
				}
			};
		}

		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolver(i), reject);
			} else {
				results[i] = promise;
			}
		}

		if (!remaining) {
			resolve(results);
		}
	});
};

Promise.race = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.race().');
	}

	return new Promise(function (resolve, reject) {
		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolve, reject);
			} else {
				resolve(promise);
			}
		}
	});
};

Promise.resolve = function (value) {
	if (value && typeof value === 'object' && value.constructor === Promise) {
		return value;
	}

	return new Promise(function (resolve) {
		resolve(value);
	});
};

Promise.reject = function (reason) {
	return new Promise(function (resolve, reject) {
		reject(reason);
	});
};

module.exports = Promise;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(205)))

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomMediaKeySystemAccess; });
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */

var CustomMediaKeySystemAccess = /*#__PURE__*/function () {
  /**
   * @param {string} _keyType - type of key system (e.g. "widevine" or
   * "com.widevine.alpha").
   * @param {Object} _mediaKeys - MediaKeys implementation
   * @param {Object} _configuration - Configuration accepted for this
   * MediaKeySystemAccess.
   */
  function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
    this._keyType = _keyType;
    this._mediaKeys = _mediaKeys;
    this._configuration = _configuration;
  }
  /**
   * @returns {string} - current key system type (e.g. "widevine" or
   * "com.widevine.alpha").
   */


  var _proto = CustomMediaKeySystemAccess.prototype;

  /**
   * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
   * MediaKeySystemAccess. Never rejects.
   */
  _proto.createMediaKeys = function createMediaKeys() {
    var _this = this;

    return new _utils_promise__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"](function (res) {
      return res(_this._mediaKeys);
    });
  }
  /**
   * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
   */
  ;

  _proto.getConfiguration = function getConfiguration() {
    return this._configuration;
  };

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0___default()(CustomMediaKeySystemAccess, [{
    key: "keySystem",
    get: function get() {
      return this._keyType;
    }
  }]);

  return CustomMediaKeySystemAccess;
}();



/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NetworkError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */

var NetworkError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(NetworkError, _Error);

  /**
   * @param {string} code
   * @param {Error} options
   * @param {Boolean} fatal
   */
  function NetworkError(code, options) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), NetworkError.prototype);
    _this.name = "NetworkError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_3__[/* ErrorTypes */ "b"].NETWORK_ERROR;
    _this.xhr = options.xhr === undefined ? null : options.xhr;
    _this.url = options.url;
    _this.status = options.status;
    _this.errorType = options.type;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_this.name, _this.code, options.message);
    _this.fatal = false;
    return _this;
  }
  /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */


  var _proto = NetworkError.prototype;

  _proto.isHttpError = function isHttpError(httpErrorCode) {
    return this.errorType === _error_codes__WEBPACK_IMPORTED_MODULE_3__[/* NetworkErrorTypes */ "c"].ERROR_HTTP_CODE && this.status === httpErrorCode;
  };

  return NetworkError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createBoxWithChildren; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */

var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */

function boxName(str) {
  if (boxNamesMem[str] != null) {
    return boxNamesMem[str];
  }

  var nameInBytes = Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__[/* strToUtf8 */ "f"])(str);
  boxNamesMem[str] = nameInBytes;
  return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */


function createBox(name, buff) {
  var len = buff.length + 8;
  return len <= _constants__WEBPACK_IMPORTED_MODULE_2__[/* MAX_32_BIT_INT */ "a"] ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "e"])(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* itobe4 */ "h"])(len), boxName(name), buff) : Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "e"])(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* itobe4 */ "h"])(1), boxName(name), Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* itobe8 */ "i"])(len + 8), buff);
}
/**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */


function createBoxWithChildren(name, children) {
  return createBox(name, _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "e"].apply(void 0, children));
}



/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isKnownError; });
/* harmony import */ var _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _media_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59);
/* harmony import */ var _network_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(179);
/* harmony import */ var _other_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(79);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */

function isKnownError(error) {
  return (error instanceof _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] || error instanceof _media_error__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"] || error instanceof _other_error__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"] || error instanceof _network_error__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) && Object.keys(_error_codes__WEBPACK_IMPORTED_MODULE_1__[/* ErrorTypes */ "b"]).indexOf(error.type) >= 0;
}

/***/ }),
/* 182 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ ReplaySubject_ReplaySubject; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(93);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var QueueAction_QueueAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction["a" /* AsyncAction */]));

//# sourceMappingURL=QueueAction.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(92);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var QueueScheduler_QueueScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler["a" /* AsyncScheduler */]));

//# sourceMappingURL=QueueScheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/queue.js
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queueScheduler = /*@__PURE__*/ new QueueScheduler_QueueScheduler(QueueAction_QueueAction);
var queue = queueScheduler;
//# sourceMappingURL=queue.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(85);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/observeOn.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());

var observeOn_ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification["a" /* Notification */].createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification["a" /* Notification */].createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification["a" /* Notification */].createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber["a" /* Subscriber */]));

var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

//# sourceMappingURL=observeOn.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(65);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription = __webpack_require__(116);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */







var ReplaySubject_ReplaySubject = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError["a" /* ObjectUnsubscribedError */]();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription["a" /* Subscription */].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription["a" /* SubjectSubscription */](this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject["a" /* Subject */]));

var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return startWith; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(scheduler)) {
        array.pop();
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(array, source, scheduler); };
    }
    else {
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(array, source); };
    }
}
//# sourceMappingURL=startWith.js.map


/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mapTo; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=mapTo.js.map


/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AssertionError; });
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__);




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */
var AssertionError = /*#__PURE__*/function (_Error) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(AssertionError, _Error);

  /**
   * @param {string} message
   */
  function AssertionError(message) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0___default()(_this), AssertionError.prototype);
    _this.name = "AssertionError";
    _this.message = message;
    return _this;
  }

  return AssertionError;
}( /*#__PURE__*/_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2___default()(Error));



/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return catchError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* SimpleInnerSubscriber */ "a"](this);
            this.add(innerSubscriber);
            var innerSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* innerSubscribe */ "c"])(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* SimpleOuterSubscriber */ "b"]));
//# sourceMappingURL=catchError.js.map


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return race; });
/* unused harmony export RaceOperator */
/* unused harmony export RaceSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "a"])(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_2__[/* fromArray */ "a"])(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());

var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__[/* subscribeToResult */ "a"])(this, observable, undefined, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* OuterSubscriber */ "a"]));

//# sourceMappingURL=race.js.map


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return timer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__[/* isScheduler */ "a"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__[/* isScheduler */ "a"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shareReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(183);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__[/* ReplaySubject */ "a"](bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeMapTo; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return share; });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new _Subject__WEBPACK_IMPORTED_MODULE_2__[/* Subject */ "a"]();
}
function share() {
    return function (source) { return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__[/* refCount */ "a"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__[/* multicast */ "a"])(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ custom_media_keys_requestMediaKeySystemAccess; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ custom_media_keys_setMediaKeys; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(98);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(86);

// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(29);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(34);

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(24);

// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(30);

// EXTERNAL MODULE: ./src/compat/should_favour_custom_safari_EME.ts
var should_favour_custom_safari_EME = __webpack_require__(115);

// EXTERNAL MODULE: ./src/compat/eme/custom_key_system_access.ts
var custom_key_system_access = __webpack_require__(178);

// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ms_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MSMediaKeysConstructor;

if (!is_node["a" /* default */]) {
  /* tslint:disable no-unsafe-any */
  var _window = window,
      MSMediaKeys = _window.MSMediaKeys;

  if (MSMediaKeys !== undefined && MSMediaKeys.prototype !== undefined && typeof MSMediaKeys.isTypeSupported === "function" && typeof MSMediaKeys.prototype.createSession === "function") {
    MSMediaKeysConstructor = MSMediaKeys;
  }
  /* tslint:enable no-unsafe-any */

}


// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(62);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(233);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/promise.ts
var promise = __webpack_require__(26);

// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(39);

// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ie11_media_keys.ts



/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var ie11_media_keys_IE11MediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(IE11MediaKeySession, _EventEmitter);

  function IE11MediaKeySession(mk) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this.expiration = NaN;
    _this.keyStatuses = new Map();
    _this._mk = mk;
    _this._closeSession$ = new Subject["a" /* Subject */]();
    _this.closed = new promise["a" /* default */](function (resolve) {
      _this._closeSession$.subscribe(resolve);
    });

    _this.update = function (license) {
      return new promise["a" /* default */](function (resolve, reject) {
        if (_this._ss === undefined) {
          return reject("MediaKeySession not set.");
        }

        try {
          resolve(
          /* tslint:disable no-unsafe-any */
          _this._ss.update(license,
          /* sessionId */
          "")
          /* tslint:enable no-unsafe-any */
          );
        } catch (err) {
          reject(err);
        }
      });
    };

    return _this;
  }

  var _proto = IE11MediaKeySession.prototype;

  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this2 = this;

    return new promise["a" /* default */](function (resolve) {
      /* tslint:disable no-unsafe-any */
      _this2._ss = _this2._mk.createSession("video/mp4", initData);
      /* tslint:enable no-unsafe-any */

      Object(merge["a" /* merge */])(event_listeners["onKeyMessage$"](_this2._ss), event_listeners["onKeyAdded$"](_this2._ss), event_listeners["onKeyError$"](_this2._ss)).pipe(Object(takeUntil["a" /* takeUntil */])(_this2._closeSession$)).subscribe(function (evt) {
        return _this2.trigger(evt.type, evt);
      });
      resolve();
    });
  };

  _proto.close = function close() {
    var _this3 = this;

    return new promise["a" /* default */](function (resolve) {
      if (_this3._ss != null) {
        /* tslint:disable no-floating-promises */
        _this3._ss.close();
        /* tslint:enable no-floating-promises */


        _this3._ss = undefined;
      }

      _this3._closeSession$.next();

      _this3._closeSession$.complete();

      resolve();
    });
  };

  _proto.load = function load() {
    return promise["a" /* default */].resolve(false);
  };

  _proto.remove = function remove() {
    return promise["a" /* default */].resolve();
  };

  createClass_default()(IE11MediaKeySession, [{
    key: "sessionId",
    get: function get() {
      var _a, _b;

      return (_b = (_a = this._ss) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
    }
  }]);

  return IE11MediaKeySession;
}(event_emitter["a" /* default */]);

var ie11_media_keys_IE11CustomMediaKeys = /*#__PURE__*/function () {
  function IE11CustomMediaKeys(keyType) {
    if (MSMediaKeysConstructor === undefined) {
      throw new Error("No MSMediaKeys API.");
    }

    this._mediaKeys = new MSMediaKeysConstructor(keyType);
  }

  var _proto2 = IE11CustomMediaKeys.prototype;

  _proto2._setVideo = function _setVideo(videoElement) {
    this._videoElement = videoElement;
    /* tslint:disable no-unsafe-any */

    if (this._videoElement.msSetMediaKeys !== undefined) {
      return this._videoElement.msSetMediaKeys(this._mediaKeys);
    }
    /* tslint:enable no-unsafe-any */

  };

  _proto2.createSession = function createSession()
  /* sessionType */
  {
    if (this._videoElement === undefined || this._mediaKeys === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }

    return new ie11_media_keys_IE11MediaKeySession(this._mediaKeys);
  };

  _proto2.setServerCertificate = function setServerCertificate() {
    throw new Error("Server certificate is not implemented in your browser");
  };

  return IE11CustomMediaKeys;
}();

function getIE11MediaKeysCallbacks() {
  var isTypeSupported = function isTypeSupported(keySystem, type) {
    if (MSMediaKeysConstructor === undefined) {
      throw new Error("No MSMediaKeys API.");
    }

    if (type !== undefined) {
      return MSMediaKeysConstructor.isTypeSupported(keySystem, type);
    }

    return MSMediaKeysConstructor.isTypeSupported(keySystem);
  };

  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new ie11_media_keys_IE11CustomMediaKeys(keyType);
  };

  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      // msSetMediaKeys only accepts native MSMediaKeys as argument.
      // Calling it with null or undefined will raise an exception.
      // There is no way to unset the mediakeys in that case, so return here.
      return;
    }

    if (!(mediaKeys instanceof ie11_media_keys_IE11CustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with IE11 custom MediaKeys.");
    }

    return mediaKeys._setVideo(elt);
  };

  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}

// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(11);

// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/old_webkit_media_keys.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns true if the given media element has old webkit methods
 * corresponding to the IOldWebkitHTMLMediaElement interface.
 * @param {HTMLMediaElement} element
 * @returns {Boolean}
 */

function isOldWebkitMediaElement(element) {
  return typeof element.webkitGenerateKeyRequest === "function";
}

var old_webkit_media_keys_OldWebkitMediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(OldWebkitMediaKeySession, _EventEmitter);

  function OldWebkitMediaKeySession(mediaElement, keySystem) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this._closeSession$ = new Subject["a" /* Subject */]();
    _this._vid = mediaElement;
    _this._key = keySystem;
    _this.sessionId = "";
    _this.closed = new promise["a" /* default */](function (resolve) {
      _this._closeSession$.subscribe(resolve);
    });
    _this.keyStatuses = new Map();
    _this.expiration = NaN;
    Object(merge["a" /* merge */])(event_listeners["onKeyMessage$"](mediaElement), event_listeners["onKeyAdded$"](mediaElement), event_listeners["onKeyError$"](mediaElement)).pipe(Object(takeUntil["a" /* takeUntil */])(_this._closeSession$)).subscribe(function (evt) {
      return _this.trigger(evt.type, evt);
    });

    _this.update = function (license) {
      return new promise["a" /* default */](function (resolve, reject) {
        try {
          if (_this._key.indexOf("clearkey") >= 0) {
            var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;
            /* tslint:disable no-unsafe-any */

            var json = JSON.parse(Object(string_parsing["g" /* utf8ToStr */])(licenseTypedArray));
            var key = Object(base64["a" /* base64ToBytes */])(json.keys[0].k);
            var kid = Object(base64["a" /* base64ToBytes */])(json.keys[0].kid);
            /* tslint:enable no-unsafe-any */

            resolve(_this._vid.webkitAddKey(_this._key, key, kid,
            /* sessionId */
            ""));
          } else {
            resolve(_this._vid.webkitAddKey(_this._key, license, null,
            /* sessionId */
            ""));
          }
        } catch (err) {
          reject(err);
        }
      });
    };

    return _this;
  }

  var _proto = OldWebkitMediaKeySession.prototype;

  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this2 = this;

    return new promise["a" /* default */](function (resolve) {
      _this2._vid.webkitGenerateKeyRequest(_this2._key, initData);

      resolve();
    });
  };

  _proto.close = function close() {
    var _this3 = this;

    return new promise["a" /* default */](function (resolve) {
      _this3._closeSession$.next();

      _this3._closeSession$.complete();

      resolve();
    });
  };

  _proto.load = function load() {
    return promise["a" /* default */].resolve(false);
  };

  _proto.remove = function remove() {
    return promise["a" /* default */].resolve();
  };

  return OldWebkitMediaKeySession;
}(event_emitter["a" /* default */]);

var OldWebKitCustomMediaKeys = /*#__PURE__*/function () {
  function OldWebKitCustomMediaKeys(keySystem) {
    this.ks_ = keySystem;
  }

  var _proto2 = OldWebKitCustomMediaKeys.prototype;

  _proto2._setVideo = function _setVideo(videoElement) {
    if (!isOldWebkitMediaElement(videoElement)) {
      throw new Error("Video not attached to the MediaKeys");
    }

    this._videoElement = videoElement;
  };

  _proto2.createSession = function createSession()
  /* sessionType */
  {
    if (this._videoElement == null) {
      throw new Error("Video not attached to the MediaKeys");
    }

    return new old_webkit_media_keys_OldWebkitMediaKeySession(this._videoElement, this.ks_);
  };

  _proto2.setServerCertificate = function setServerCertificate() {
    throw new Error("Server certificate is not implemented in your browser");
  };

  return OldWebKitCustomMediaKeys;
}();

function getOldWebKitMediaKeysCallbacks() {
  var isTypeSupported = function isTypeSupported(keyType) {
    // get any <video> element from the DOM or create one
    // and try the `canPlayType` method
    var videoElement = document.querySelector("video");

    if (videoElement == null) {
      videoElement = document.createElement("video");
    }
    /* tslint:disable no-unsafe-any */

    /* tslint:disable no-unbound-method */


    if (videoElement != null && typeof videoElement.canPlayType === "function") {
      /* tslint:enable no-unbound-method */
      return !!videoElement.canPlayType("video/mp4", keyType);
      /* tslint:enable no-unsafe-any */
    } else {
      return false;
    }
  };

  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new OldWebKitCustomMediaKeys(keyType);
  };

  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      return;
    }

    if (!(mediaKeys instanceof OldWebKitCustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with old webkit custom MediaKeys.");
    }

    return mediaKeys._setVideo(elt);
  };

  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// CONCATENATED MODULE: ./src/compat/eme/get_webkit_fairplay_initdata.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create formatted fairplay initdata for WebKit createSession.
 * Layout is :
 * [initData][4 byte: idLength][idLength byte: id]
 * [4 byte:certLength][certLength byte: cert]
 * @param {Uint8Array} initData
 * @param {Uint8Array} serverCertificate
 * @returns {Uint8Array}
 */

function getWebKitFairPlayInitData(initDataBytes, serverCertificateBytes) {
  var initData = initDataBytes instanceof Uint8Array ? initDataBytes : new Uint8Array(initDataBytes);
  var serverCertificate = serverCertificateBytes instanceof Uint8Array ? serverCertificateBytes : new Uint8Array(serverCertificateBytes);
  var length = Object(byte_parsing["l" /* le4toi */])(initData, 0);

  if (length + 4 !== initData.length) {
    throw new Error("Unsupported WebKit initData.");
  }

  var initDataUri = Object(string_parsing["d" /* leUtf16ToStr */])(initData);
  var skdIndexInInitData = initDataUri.indexOf("skd://");
  var contentIdStr = skdIndexInInitData > -1 ? initDataUri.substring(skdIndexInInitData + 6) : initDataUri;
  var id = Object(string_parsing["e" /* strToLeUtf16 */])(contentIdStr);
  var offset = 0;
  var res = new Uint8Array(initData.byteLength
  /* id length */
  + 4 + id.byteLength
  /* certificate length */
  + 4 + serverCertificate.byteLength);
  res.set(initData);
  offset += initData.length;
  res.set(Object(byte_parsing["j" /* itole4 */])(id.byteLength), offset);
  offset += 4;
  res.set(id, offset);
  offset += id.byteLength;
  res.set(Object(byte_parsing["j" /* itole4 */])(serverCertificate.byteLength), offset);
  offset += 4;
  res.set(serverCertificate, offset);
  return res;
}
// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys_constructor.ts
var webkit_media_keys_constructor = __webpack_require__(73);

// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys.ts



/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Check if keyType is for fairplay DRM
 * @param {string} keyType
 * @returns {boolean}
 */

function isFairplayKeyType(keyType) {
  return keyType === "com.apple.fps.1_0" || keyType === "com.apple.fps.2_0";
}
/**
 * Set media keys on video element using native HTMLMediaElement
 * setMediaKeys from WebKit.
 * @param {HTMLMediaElement} videoElement
 * @param {Object|null} mediaKeys
 */


function setWebKitMediaKeys(videoElement, mediaKeys) {
  /* tslint:disable no-unsafe-any */
  if (videoElement.webkitSetMediaKeys === undefined) {
    throw new Error("No webKitMediaKeys API.");
  }

  return videoElement.webkitSetMediaKeys(mediaKeys);
  /* tslint:enable no-unsafe-any */
}
/**
 * On Safari browsers (>= 9), there are specific webkit prefixed APIs for cyphered
 * content playback. Standard EME APIs are therefore available since Safari 12.1, but they
 * don't allow to play fairplay cyphered content.
 *
 * This class implements a standard EME API polyfill that wraps webkit prefixed Safari
 * EME custom APIs.
 */


var webkit_media_keys_WebkitMediaKeySession = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(WebkitMediaKeySession, _EventEmitter);

  function WebkitMediaKeySession(mediaElement, serverCertificate, keyType) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this._serverCertificate = serverCertificate;
    _this._closeSession$ = new Subject["a" /* Subject */]();
    _this._videoElement = mediaElement;
    _this._keyType = keyType;
    _this.closed = new promise["a" /* default */](function (resolve) {
      _this._closeSession$.subscribe(resolve);
    });
    _this.keyStatuses = new Map();
    _this.expiration = NaN;

    _this.update = function (license) {
      /* tslint:disable no-unsafe-any */
      return new promise["a" /* default */](function (resolve, reject) {
        if (_this._nativeSession === undefined || _this._nativeSession.update === undefined || typeof _this._nativeSession.update !== "function") {
          return reject("Unavailable WebKit key session.");
        }

        try {
          resolve(_this._nativeSession.update(license));
        } catch (err) {
          reject(err);
        }
      });
      /* tslint:enable no-unsafe-any */
    };

    return _this;
  }
  /* tslint:disable no-unsafe-any */


  var _proto = WebkitMediaKeySession.prototype;

  _proto.listenEvent = function listenEvent(session) {
    var _this2 = this;

    Object(merge["a" /* merge */])(event_listeners["onKeyMessage$"](session), event_listeners["onKeyAdded$"](session), event_listeners["onKeyError$"](session)).pipe(Object(takeUntil["a" /* takeUntil */])(this._closeSession$)).subscribe(function (evt) {
      _this2.trigger(evt.type, evt);
    });
  }
  /* tslint:enable no-unsafe-any */
  ;

  _proto.generateRequest = function generateRequest(_initDataType, initData) {
    var _this3 = this;

    return new promise["a" /* default */](function (resolve) {
      /* tslint:disable no-unsafe-any */
      if (_this3._videoElement.webkitKeys === undefined || _this3._videoElement.webkitKeys.createSession === undefined) {
        throw new Error("No WebKitMediaKeys API.");
      }

      var formattedInitData = isFairplayKeyType(_this3._keyType) ? getWebKitFairPlayInitData(initData, _this3._serverCertificate) : initData;

      var keySession = _this3._videoElement.webkitKeys.createSession("video/mp4", formattedInitData);
      /* tslint:enable no-unsafe-any */


      if (keySession === undefined || keySession === null) {
        throw new Error("Impossible to get the key sessions");
      }

      _this3.listenEvent(keySession);

      _this3._nativeSession = keySession;
      resolve();
    });
  };

  _proto.close = function close() {
    var _this4 = this;

    return new promise["a" /* default */](function (resolve, reject) {
      _this4._closeSession$.next();

      _this4._closeSession$.complete();
      /* tslint:disable no-unsafe-any */


      if (_this4._nativeSession === undefined) {
        reject("No session to close.");
      }

      _this4._nativeSession.close();
      /* tslint:enable no-unsafe-any */


      resolve();
    });
  };

  _proto.load = function load() {
    return promise["a" /* default */].resolve(false);
  };

  _proto.remove = function remove() {
    return promise["a" /* default */].resolve();
  };

  createClass_default()(WebkitMediaKeySession, [{
    key: "sessionId",
    get: function get() {
      var _a, _b;
      /* tslint:disable */


      return (_b = (_a = this._nativeSession) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
      /* tslint:enable */
    }
  }]);

  return WebkitMediaKeySession;
}(event_emitter["a" /* default */]);

var webkit_media_keys_WebKitCustomMediaKeys = /*#__PURE__*/function () {
  function WebKitCustomMediaKeys(keyType) {
    if (webkit_media_keys_constructor["a" /* WebKitMediaKeysConstructor */] === undefined) {
      throw new Error("No WebKitMediaKeys API.");
    }

    this._keyType = keyType;
    this._mediaKeys = new webkit_media_keys_constructor["a" /* WebKitMediaKeysConstructor */](keyType);
  }

  var _proto2 = WebKitCustomMediaKeys.prototype;

  _proto2._setVideo = function _setVideo(videoElement) {
    this._videoElement = videoElement;

    if (this._videoElement === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }

    return setWebKitMediaKeys(this._videoElement, this._mediaKeys);
  };

  _proto2.createSession = function createSession()
  /* sessionType */
  {
    if (this._videoElement === undefined || this._mediaKeys === undefined || this._serverCertificate === undefined) {
      throw new Error("Video not attached to the MediaKeys");
    }

    return new webkit_media_keys_WebkitMediaKeySession(this._videoElement, this._serverCertificate, this._keyType);
  };

  _proto2.setServerCertificate = function setServerCertificate(serverCertificate) {
    this._serverCertificate = serverCertificate;
    return promise["a" /* default */].resolve();
  };

  return WebKitCustomMediaKeys;
}();

function getWebKitMediaKeysCallbacks() {
  if (webkit_media_keys_constructor["a" /* WebKitMediaKeysConstructor */] === undefined) {
    throw new Error("No WebKitMediaKeys API.");
  }

  var isTypeSupported = webkit_media_keys_constructor["a" /* WebKitMediaKeysConstructor */].isTypeSupported;

  var createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new webkit_media_keys_WebKitCustomMediaKeys(keyType);
  };

  var setMediaKeys = function setMediaKeys(elt, mediaKeys) {
    if (mediaKeys === null) {
      return setWebKitMediaKeys(elt, mediaKeys);
    }

    if (!(mediaKeys instanceof webkit_media_keys_WebKitCustomMediaKeys)) {
      throw new Error("Custom setMediaKeys is supposed to be called " + "with webkit custom MediaKeys.");
    }

    return mediaKeys._setVideo(elt);
  };

  return {
    isTypeSupported: isTypeSupported,
    createCustomMediaKeys: createCustomMediaKeys,
    setMediaKeys: setMediaKeys
  };
}
// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var custom_media_keys_requestMediaKeySystemAccess = null;

var _setMediaKeys = function defaultSetMediaKeys(elt, mediaKeys) {
  /* tslint:disable no-unbound-method */
  if (typeof elt.setMediaKeys === "function") {
    return elt.setMediaKeys(mediaKeys);
  }
  /* tslint:enable no-unbound-method */
  // If we get in the following code, it means that no compat case has been
  // found and no standard setMediaKeys API exists. This case is particulary
  // rare. We will try to call each API with native media keys.


  if (elt.webkitSetMediaKeys) {
    /* tslint:disable no-unsafe-any */
    return elt.webkitSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }

  if (elt.mozSetMediaKeys) {
    /* tslint:disable no-unsafe-any */
    return elt.mozSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }

  if (elt.msSetMediaKeys && mediaKeys !== null) {
    /* tslint:disable no-unsafe-any */
    return elt.msSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }
};
/**
 * Since Safari 12.1, EME APIs are available without webkit prefix.
 * However, it seems that since fairplay CDM implementation within the browser is not
 * standard with EME w3c current spec, the requestMediaKeySystemAccess API doesn't resolve
 * positively, even if the drm (fairplay in most cases) is supported.
 *
 * Therefore, we prefer not to use requestMediaKeySystemAccess on Safari when webkit API
 * is available.
 */


if (is_node["a" /* default */] || navigator.requestMediaKeySystemAccess != null && !Object(should_favour_custom_safari_EME["a" /* default */])()) {
  custom_media_keys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
    return Object(cast_to_observable["a" /* default */])(navigator.requestMediaKeySystemAccess(a, b));
  };
} else {
  var custom_media_keys_isTypeSupported = function isTypeSupported(keyType) {
    if (browser_compatibility_types["b" /* MediaKeys_ */].isTypeSupported === undefined) {
      throw new Error("No isTypeSupported on MediaKeys.");
    }
    /* tslint:disable no-unsafe-any */


    return browser_compatibility_types["b" /* MediaKeys_ */].isTypeSupported(keyType);
    /* tslint:enable no-unsafe-any */
  };

  var custom_media_keys_createCustomMediaKeys = function createCustomMediaKeys(keyType) {
    return new browser_compatibility_types["b" /* MediaKeys_ */](keyType);
  }; // This is for Chrome with unprefixed EME api


  if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
    var callbacks = getOldWebKitMediaKeysCallbacks();
    custom_media_keys_isTypeSupported = callbacks.isTypeSupported;
    custom_media_keys_createCustomMediaKeys = callbacks.createCustomMediaKeys;
    _setMediaKeys = callbacks.setMediaKeys; // This is for WebKit with prefixed EME api
  } else if (webkit_media_keys_constructor["a" /* WebKitMediaKeysConstructor */] !== undefined) {
    var _callbacks = getWebKitMediaKeysCallbacks();
    /* tslint:disable no-unsafe-any */


    custom_media_keys_isTypeSupported = _callbacks.isTypeSupported;
    /* tslint:enable no-unsafe-any */

    custom_media_keys_createCustomMediaKeys = _callbacks.createCustomMediaKeys;
    _setMediaKeys = _callbacks.setMediaKeys;
  } else if (browser_detection["c" /* isIE11 */] && MSMediaKeysConstructor !== undefined) {
    var _callbacks2 = getIE11MediaKeysCallbacks();
    /* tslint:disable no-unsafe-any */


    custom_media_keys_isTypeSupported = _callbacks2.isTypeSupported;
    /* tslint:enable no-unsafe-any */

    custom_media_keys_createCustomMediaKeys = _callbacks2.createCustomMediaKeys;
    _setMediaKeys = _callbacks2.setMediaKeys;
  }

  custom_media_keys_requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
    // TODO Why TS Do not understand that isTypeSupported exists here?

    /* tslint:disable no-unsafe-any */
    if (!custom_media_keys_isTypeSupported(keyType)) {
      /* tslint:enable no-unsafe-any */
      return Object(throwError["a" /* throwError */])(undefined);
    }

    for (var i = 0; i < keySystemConfigurations.length; i++) {
      var keySystemConfiguration = keySystemConfigurations[i];
      var videoCapabilities = keySystemConfiguration.videoCapabilities,
          audioCapabilities = keySystemConfiguration.audioCapabilities,
          initDataTypes = keySystemConfiguration.initDataTypes,
          distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
      var supported = true;
      supported = supported && (initDataTypes == null || initDataTypes.some(function (idt) {
        return idt === "cenc";
      }));
      supported = supported && distinctiveIdentifier !== "required";

      if (supported) {
        var keySystemConfigurationResponse = {
          videoCapabilities: videoCapabilities,
          audioCapabilities: audioCapabilities,
          initDataTypes: ["cenc"],
          distinctiveIdentifier: "not-allowed",
          persistentState: "required",
          sessionTypes: ["temporary", "persistent-license"]
        };
        var customMediaKeys = custom_media_keys_createCustomMediaKeys(keyType);
        return Object(of["a" /* of */])(new custom_key_system_access["a" /* default */](keyType,
        /* tslint:disable no-unsafe-any */
        customMediaKeys,
        /* tslint:enable no-unsafe-any */
        keySystemConfigurationResponse));
      }
    }

    return Object(throwError["a" /* throwError */])(undefined);
  };
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */


function custom_media_keys_setMediaKeys(elt, mediaKeys) {
  return Object(defer["a" /* defer */])(function () {
    return Object(cast_to_observable["a" /* default */])(_setMediaKeys(elt, mediaKeys));
  });
}



/***/ }),
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 202 */
/***/ (function(module, exports) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(161);

var isNativeReflectConstruct = __webpack_require__(204);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),
/* 204 */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),
/* 205 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */

function parseBif(buf) {
  var pos = 0;
  var length = buf.length;
  var fileFormat = Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__[/* utf8ToStr */ "g"])(buf.subarray(pos + 1, pos + 8));
  pos += 8;

  if (buf[0] !== 0x89 || fileFormat !== "BIF\r\n\x1A\n") {
    throw new Error("Invalid BIF file");
  }

  var minorVersion = buf[pos];
  pos += 1;
  var majorVersion = buf[pos];
  pos += 1;
  var patchVersion = buf[pos];
  pos += 1;
  var increVersion = buf[pos];
  pos += 1;
  var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");

  if (majorVersion > 0) {
    throw new Error("Unhandled version: " + majorVersion);
  }

  var imageCount = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "l"])(buf, pos);
  pos += 4;
  var framewiseSeparation = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "l"])(buf, pos);
  pos += 4;
  var format = Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__[/* utf8ToStr */ "g"])(buf.subarray(pos, pos + 4));
  pos += 4;
  var width = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le2toi */ "k"])(buf, pos);
  pos += 2;
  var height = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le2toi */ "k"])(buf, pos);
  pos += 2;
  var aspectRatio = [buf[pos], buf[pos + 1]].join(":");
  pos += 2;
  var isVod = buf[pos] === 1; // bytes 0x1F to 0x40 is unused data for now

  pos = 0x40;
  var thumbs = [];

  if (imageCount === 0) {
    throw new Error("bif: no images to parse");
  }

  var index = 0;
  var previousImageInfo = null;

  while (pos < length) {
    var currentImageTimestamp = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "l"])(buf, pos);
    pos += 4;
    var currentImageOffset = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "l"])(buf, pos);
    pos += 4;

    if (previousImageInfo !== null) {
      // calculate for index-1
      var ts = previousImageInfo.timestamp * framewiseSeparation;
      var duration = framewiseSeparation;
      var data = buf.slice(previousImageInfo.offset, currentImageOffset);
      thumbs.push({
        index: index,
        duration: duration,
        ts: ts,
        data: data
      });
      index++;
    }

    if (currentImageTimestamp === 0xFFFFFFFF) {
      break;
    }

    previousImageInfo = {
      timestamp: currentImageTimestamp,
      offset: currentImageOffset
    };
  }

  return {
    fileFormat: "BIF",
    version: version,
    imageCount: imageCount,
    timescale: 1000,
    format: format,
    width: width,
    height: height,
    aspectRatio: aspectRatio,
    isVod: isVod,
    thumbs: thumbs
  };
}

/* harmony default export */ __webpack_exports__["default"] = (parseBif);

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getPlayReadyKIDFromPrivateData; });
/* harmony import */ var _utils_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */

function getPlayReadyKIDFromPrivateData(data) {
  var xmlLength = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* le2toi */ "k"])(data, 8);
  var xml = Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__[/* leUtf16ToStr */ "d"])(data.subarray(10, xmlLength + 10));
  var doc = new DOMParser().parseFromString(xml, "application/xml");
  var kidElement = doc.querySelector("KID");

  if (kidElement === null) {
    throw new Error("Cannot parse PlayReady private data: invalid XML");
  }

  var b64guidKid = kidElement.textContent === null ? "" : kidElement.textContent;
  var uuidKid = Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__[/* guidToUuid */ "b"])(Object(_utils_base64__WEBPACK_IMPORTED_MODULE_0__[/* base64ToBytes */ "a"])(b64guidKid));
  return Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__[/* bytesToHex */ "a"])(uuidKid).toLowerCase();
}

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */

function createCuesFromArray(cuesArray) {
  var nativeCues = [];

  for (var i = 0; i < cuesArray.length; i++) {
    var _cuesArray$i = cuesArray[i],
        start = _cuesArray$i.start,
        end = _cuesArray$i.end,
        text = _cuesArray$i.text;

    if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(text) && end != null) {
      var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(start, end, text);

      if (cue != null) {
        nativeCues.push(cue);
      }
    }
  }

  return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */


function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);

  while (Array.isArray(m)) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");

    if (name != null && lang != null) {
      langs[lang] = name;
    }

    m = ruleRe.exec(str);
  }

  return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */


function getCSSProperty(str, name) {
  var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */


function decodeEntities(text) {
  return text.replace(BR, "\n")
  /* tslint:disable no-unsafe-any */
  .replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode($1);
  });
  /* tslint:enable no-unsafe-any */
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */


function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/ig;
  var syncClose = /<sync[ >]|<\/body>/ig;
  var subs = [];
  var styleMatches = smi.match(STYLE);
  var css = styleMatches !== null ? styleMatches[1] : "";
  var up;
  var to; // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used

  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var klass;

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(lang)) {
    klass = langs[lang];

    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }

  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);

    if (up === null && to === null) {
      break;
    }

    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);

    if (tim === null) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];

    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendToSubs(str.split("\n"), start / 1000);
  }

  return createCuesFromArray(subs);

  function appendToSubs(lines, start) {
    var i = lines.length;
    var m;

    while (--i >= 0) {
      m = lines[i].match(PARAG);

      if (m === null) {
        continue;
      }

      var _m = m,
          kl = _m[1],
          txt = _m[2];

      if (klass !== kl) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        subs.push({
          text: decodeEntities(txt),
          start: start + timeOffset
        });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseSRTStringToVTTCues; });
/* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation



/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */

function parseSRTStringToVTTCues(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(lines);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(cueBlocks[i], timeOffset);

    if (cueObject !== null) {
      var nativeCue = toNativeCue(cueObject);

      if (nativeCue !== null) {
        cues.push(nativeCue);
      }
    }
  }

  return cues;
}
/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */

function toNativeCue(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var text = payload.join("\n");
  return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(start, end, text);
}

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */

function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);

  while (m !== null) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");

    if (name != null && lang != null) {
      langs[lang] = name;
    }

    m = ruleRe.exec(str);
  }

  return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */


function getPCSSRules(str) {
  var pRuleRegex = /p\s*{([^}]*)}/gi;
  var rule = pRuleRegex.exec(str);

  if (rule === null) {
    return "";
  }

  return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */


function getCSSProperty(str, name) {
  var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * @param {string} text
 * @returns {string}
 */


function decodeEntities(text) {
  return text
  /* tslint:disable no-unsafe-any */
  .replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode($1);
  });
  /* tslint:enable no-unsafe-any */
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */


function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/ig;
  var syncClose = /<sync[ >]|<\/body>/ig;
  var subs = [];
  var styleMatches = smi.match(STYLE);
  var css = Array.isArray(styleMatches) ? styleMatches[1] : "";
  var up;
  var to; // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used

  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var pCSS = getPCSSRules(css);
  var klass;

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(lang)) {
    klass = langs[lang];

    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }

  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);

    if (up === null && to === null) {
      break;
    }

    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);

    if (!Array.isArray(tim)) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];

    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendToSubs(str.split("\n"), start / 1000);
  }

  return subs;

  function appendToSubs(lines, start) {
    var i = lines.length;

    while (--i >= 0) {
      var paragraphInfos = lines[i].match(PARAG);

      if (!Array.isArray(paragraphInfos)) {
        continue;
      }

      var className = paragraphInfos[1],
          txt = paragraphInfos[2];

      if (klass !== className) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        var wrapperEl = document.createElement("DIV");
        wrapperEl.className = "rxp-texttrack-region";
        var divEl = document.createElement("DIV");
        divEl.className = "rxp-texttrack-div";
        divEl.style.position = "absolute";
        divEl.style.bottom = "0";
        divEl.style.width = "100%";
        divEl.style.color = "#fff";
        divEl.style.textShadow = "-1px -1px 0 #000," + "1px -1px 0 #000," + "-1px 1px 0 #000," + "1px 1px 0 #000";
        var pEl = document.createElement("div");
        pEl.className = "rxp-texttrack-p";

        if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(pCSS)) {
          pEl.style.cssText = pCSS;
        }

        var textEls = txt.split(BR);

        for (var j = 0; j < textEls.length; j++) {
          if (j !== 0) {
            pEl.appendChild(document.createElement("BR"));
          }

          var spanEl = document.createElement("SPAN");
          spanEl.className = "rxp-texttrack-span";
          spanEl.textContent = decodeEntities(textEls[j]);
          pEl.appendChild(spanEl);
        }

        divEl.appendChild(pEl);
        wrapperEl.appendChild(divEl);
        subs.push({
          element: wrapperEl,
          start: start + timeOffset,
          end: -1
        });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseSRTStringToHTML; });
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(139);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.


/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */

function parseSRTStringToHTML(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(lines);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var htmlCue = toHTML(cueObject);

      if (htmlCue != null) {
        cues.push(htmlCue);
      }
    }
  }

  return cues;
}
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */

function toHTML(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var pEl = document.createElement("div");
  pEl.className = "rxp-texttrack-p";
  pEl.style.fontSize = "28px";
  pEl.style.position = "absolute";
  pEl.style.bottom = "5%";
  pEl.style.width = "100%";
  pEl.style.textAlign = "center";
  pEl.style.color = "#fff";
  pEl.style.textShadow = "-1px -1px 2px #000," + "1px -1px 2px #000," + "-1px 1px 2px #000," + "1px 1px 2px #000";

  for (var i = 0; i < payload.length; i++) {
    if (i !== 0) {
      pEl.appendChild(document.createElement("br"));
    }

    var span = generateSpansFromSRTText(payload[i]);
    pEl.appendChild(span);
  }

  return {
    start: start,
    end: end,
    element: pEl
  };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */


function generateSpansFromSRTText(text) {
  var secureDiv = document.createElement("div");
  secureDiv.innerHTML = text;

  var _loop = function _loop(node) {
    var childNodes = node.childNodes;
    var span = document.createElement("span");
    span.className = "rxp-texttrack-span";

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var linifiedText = currentNode.wholeText.split("\n");

        for (var line = 0; line < linifiedText.length; line++) {
          if (line !== 0) {
            span.appendChild(document.createElement("br"));
          }

          if (linifiedText[line].length > 0) {
            var textNode = document.createTextNode(linifiedText[line]);
            span.appendChild(textNode);
          }
        }
      } else if (currentNode.nodeName === "B") {
        var spanChild = _loop(currentNode);

        spanChild.style.fontWeight = "bold";
        span.appendChild(spanChild);
      } else if (currentNode.nodeName === "I") {
        var _spanChild = _loop(currentNode);

        _spanChild.style.fontStyle = "italic";
        span.appendChild(_spanChild);
      } else if (currentNode.nodeName === "U") {
        var _spanChild2 = _loop(currentNode);

        _spanChild2.style.textDecoration = "underline";
        span.appendChild(_spanChild2);
      } else if (currentNode.nodeName === "FONT" && currentNode.color != null) {
        // TODO loop through attributes to find color?
        var _spanChild3 = _loop(currentNode);
        /* tslint:disable no-unsafe-any */


        _spanChild3.style.color = currentNode.color;
        /* tslint:enable no-unsafe-any */

        span.appendChild(_spanChild3);
      } else {
        var _spanChild4 = _loop(currentNode);

        span.appendChild(_spanChild4);
      }
    }

    return span;
  };

  return _loop(secureDiv);
}

/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return initializeDirectfileContent; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(144);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(192);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(159);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(145);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(191);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(157);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(97);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(150);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(59);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(0);
/* harmony import */ var _utils_defer_subscriptions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(56);
/* harmony import */ var _create_eme_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(134);
/* harmony import */ var _events_generators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(33);
/* harmony import */ var _get_stalled_events__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(137);
/* harmony import */ var _initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(132);
/* harmony import */ var _throw_on_media_error__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(135);
/* harmony import */ var _update_playback_rate__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(136);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */












/**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */

function getDirectFileInitialTime(mediaElement, startAt) {
  if (startAt == null) {
    return 0;
  }

  if (startAt.position != null) {
    return startAt.position;
  } else if (startAt.wallClockTime != null) {
    return startAt.wallClockTime;
  } else if (startAt.fromFirstPosition != null) {
    return startAt.fromFirstPosition;
  }

  var duration = mediaElement.duration;

  if (duration == null || !isFinite(duration)) {
    _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].warn("startAt.fromLastPosition set but no known duration, " + "beginning at 0.");
    return 0;
  }

  if (typeof startAt.fromLastPosition === "number") {
    return Math.max(0, duration + startAt.fromLastPosition);
  } else if (startAt.percentage != null) {
    var percentage = startAt.percentage;

    if (percentage >= 100) {
      return duration;
    } else if (percentage <= 0) {
      return 0;
    }

    var ratio = +percentage / 100;
    return duration * ratio;
  }

  return 0;
}
/**
 * Launch a content in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */


function initializeDirectfileContent(_ref) {
  var autoPlay = _ref.autoPlay,
      clock$ = _ref.clock$,
      keySystems = _ref.keySystems,
      mediaElement = _ref.mediaElement,
      speed$ = _ref.speed$,
      startAt = _ref.startAt,
      url = _ref.url;
  Object(_compat__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])(mediaElement);

  if (url == null) {
    throw new Error("No URL for a DirectFile content");
  } // Start everything! (Just put the URL in the element's src).


  var linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])(mediaElement, url);
  _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].debug("Init: Calculating initial time");

  var initialTime = function initialTime() {
    return getDirectFileInitialTime(mediaElement, startAt);
  };

  _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].debug("Init: Initial time calculated:", initialTime);

  var _seekAndLoadOnMediaEv = Object(_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])({
    clock$: clock$,
    mediaElement: mediaElement,
    startTime: initialTime,
    mustAutoPlay: autoPlay,
    isDirectfile: true
  }),
      seek$ = _seekAndLoadOnMediaEv.seek$,
      load$ = _seekAndLoadOnMediaEv.load$; // Create EME Manager, an observable which will manage every EME-related
  // issue.


  var emeManager$ = linkURL$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* mergeMap */ "a"])(function () {
    return Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"])(mediaElement, keySystems, rxjs__WEBPACK_IMPORTED_MODULE_0__[/* EMPTY */ "a"]);
  }), Object(_utils_defer_subscriptions__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* share */ "a"])()); // Translate errors coming from the media element into RxPlayer errors
  // through a throwing Observable.

  var mediaError$ = Object(_throw_on_media_error__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"])(mediaElement); // Set the speed set by the user on the media element while pausing a
  // little longer while the buffer is empty.

  var playbackRate$ = Object(_update_playback_rate__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"])(mediaElement, speed$, clock$, {
    pauseWhenStalled: true
  }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* map */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].speedChanged)); // Create Stalling Manager, an observable which will try to get out of
  // various infinite stalling issues

  var stalled$ = Object(_get_stalled_events__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"])(clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* map */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].stalled)); // Manage "loaded" event and warn if autoplay is blocked on the current browser

  var loadedEvent$ = emeManager$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* filter */ "a"])(function isEMEReady(evt) {
    return evt.type === "eme-disabled" || evt.type === "attached-media-keys" || evt.type === "created-media-keys" && evt.value.mediaKeysInfos.keySystemOptions.disableMediaKeysAttachmentLock === true;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* mergeMapTo */ "a"])(load$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* mergeMap */ "a"])(function (evt) {
    if (evt === "autoplay-blocked") {
      var error = new _errors__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " + "your browser does not allow it.");
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].warning(error), _events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].loaded(null));
    } else if (evt === "not-loaded-metadata") {
      var _error = new _errors__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"]("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " + "falsely announced having loaded the content.");

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].warning(_error));
    }

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].loaded(null));
  }));
  var initialSeek$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* ignoreElements */ "a"])());
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* merge */ "a"])(loadedEvent$, initialSeek$, emeManager$, mediaError$, playbackRate$, stalled$);
}

/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MediaElementTrackChoiceManager; });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _utils_languages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if track array is different from an other one
 * @param {Array.<Object>} oldTrackArray
 * @param {Array.<Object>} newTrackArray
 * @returns {boolean}
 */

function areTrackArraysDifferent(oldTrackArray, newTrackArray) {
  var _a;

  if (newTrackArray.length !== oldTrackArray.length) {
    return true;
  }

  for (var i = 0; i < newTrackArray.length; i++) {
    if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) === null || _a === void 0 ? void 0 : _a.nativeTrack)) {
      return true;
    }
  }

  return false;
}
/**
 * Create audio tracks from native audio tracks.
 * @param {AudioTrackList} audioTracks
 * @returns {Array.<Object>}
 */


function createAudioTracks(audioTracks) {
  var _a;

  var newAudioTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < audioTracks.length; i++) {
    var audioTrack = audioTracks[i];
    var language = audioTrack.language === "" ? "nolang" : audioTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_audio_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    var track = {
      language: audioTrack.language,
      id: id,
      normalized: Object(_utils_languages__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(audioTrack.language),
      audioDescription: false,
      representations: []
    };
    newAudioTracks.push({
      track: track,
      nativeTrack: audioTrack
    });
  }

  return newAudioTracks;
}
/**
 * Create text tracks from native text tracks.
 * @param {TextTrackList} textTracks
 * @returns {Array.<Object>}
 */


function createTextTracks(textTracks) {
  var _a;

  var newTextTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < textTracks.length; i++) {
    var textTrack = textTracks[i];
    var language = textTrack.language === "" ? "nolang" : textTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_text_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    var track = {
      language: textTrack.language,
      id: id,
      normalized: Object(_utils_languages__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(textTrack.language),
      closedCaption: textTrack.kind === "captions"
    };
    newTextTracks.push({
      track: track,
      nativeTrack: textTrack
    });
  }

  return newTextTracks;
}
/**
 * Create video tracks from native video tracks.
 * @param {VideoTrackList} videoTracks
 * @returns {Array.<Object>}
 */


function createVideoTracks(videoTracks) {
  var _a;

  var newVideoTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < videoTracks.length; i++) {
    var videoTrack = videoTracks[i];
    var language = videoTrack.language === "" ? "nolang" : videoTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_video_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    newVideoTracks.push({
      track: {
        id: id,
        representations: []
      },
      nativeTrack: videoTrack
    });
  }

  return newVideoTracks;
}
/**
 * Manage video, audio and text tracks for current direct file content.
 * @class MediaElementTrackChoiceManager
 */


var MediaElementTrackChoiceManager = /*#__PURE__*/function (_EventEmitter) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default()(MediaElementTrackChoiceManager, _EventEmitter);

  function MediaElementTrackChoiceManager(mediaElement) {
    var _this;

    var _a, _b, _c;

    _this = _EventEmitter.call(this) || this;
    _this._preferredAudioTracks = [];
    _this._preferredTextTracks = [];
    _this._preferredVideoTracks = []; // TODO In practice, the audio/video/text tracks API are not always implemented on
    // the media element, although Typescript HTMLMediaElement types tend to mean
    // that can't be undefined.

    _this._nativeAudioTracks = mediaElement.audioTracks;
    _this._nativeVideoTracks = mediaElement.videoTracks;
    _this._nativeTextTracks = mediaElement.textTracks;
    _this._audioTracks = _this._nativeAudioTracks !== undefined ? createAudioTracks(_this._nativeAudioTracks) : [];
    _this._videoTracks = _this._nativeVideoTracks !== undefined ? createVideoTracks(_this._nativeVideoTracks) : [];
    _this._textTracks = _this._nativeTextTracks !== undefined ? createTextTracks(_this._nativeTextTracks) : [];
    _this._lastEmittedNativeAudioTrack = (_a = _this._getPrivateChosenAudioTrack()) === null || _a === void 0 ? void 0 : _a.nativeTrack;
    _this._lastEmittedNativeVideoTrack = (_b = _this._getPrivateChosenVideoTrack()) === null || _b === void 0 ? void 0 : _b.nativeTrack;
    _this._lastEmittedNativeTextTrack = (_c = _this._getPrivateChosenTextTrack()) === null || _c === void 0 ? void 0 : _c.nativeTrack;

    _this._handleNativeTracksCallbacks();

    return _this;
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} preferredAudioTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */


  var _proto = MediaElementTrackChoiceManager.prototype;

  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
    this._preferredAudioTracks = preferredAudioTracks;

    if (shouldApply) {
      this._applyAudioPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} preferredTextTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredTextTracks = function setPreferredTextTracks(preferredTextTracks, shouldApply) {
    this._preferredTextTracks = preferredTextTracks;

    if (shouldApply) {
      this._applyTextPreferences();
    }
  }
  /**
   * Set the list of preferred video tracks, in preference order.
   * @param {Array.<Object>} preferredVideoTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
    this._preferredVideoTracks = preferredVideoTracks;

    if (shouldApply) {
      this._applyVideoPreferences();
    }
  }
  /**
   * Update the currently active audio track by setting the wanted audio track's
   * ID property.
   * Throws if the wanted audio track is not found.
   * @param {string|number|undefined} id
   */
  ;

  _proto.setAudioTrackById = function setAudioTrackById(id) {
    for (var i = 0; i < this._audioTracks.length; i++) {
      var _this$_audioTracks$i = this._audioTracks[i],
          track = _this$_audioTracks$i.track,
          nativeTrack = _this$_audioTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.enabled = true;
        this._audioTrackLockedOn = nativeTrack;
        return;
      }
    }

    throw new Error("Audio track not found.");
  }
  /**
   * Disable the currently-active text track, if one.
   */
  ;

  _proto.disableTextTrack = function disableTextTrack() {
    disableTextTracks(this._textTracks);
    this._textTrackLockedOn = null;
  }
  /**
   * Update the currently active text track by setting the wanted text track's
   * ID property.
   * Throws if the wanted text track is not found.
   * @param {string|number|undefined} id
   */
  ;

  _proto.setTextTrackById = function setTextTrackById(id) {
    var hasSetTrack = false;

    for (var i = 0; i < this._textTracks.length; i++) {
      var _this$_textTracks$i = this._textTracks[i],
          track = _this$_textTracks$i.track,
          nativeTrack = _this$_textTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.mode = "showing";
        hasSetTrack = true;
        this._textTrackLockedOn = nativeTrack;
      } else if (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden") {
        nativeTrack.mode = "disabled";
      }
    }

    if (!hasSetTrack) {
      throw new Error("Text track not found.");
    }
  }
  /**
   * Disable the currently-active video track, if one.
   */
  ;

  _proto.disableVideoTrack = function disableVideoTrack() {
    disableVideoTracks(this._videoTracks);
    this._videoTrackLockedOn = null;
  }
  /**
   * Update the currently active video track by setting the wanted video track's
   * ID property.
   * Throws if the wanted video track is not found.
   * @param {string|number|undefined} id
   */
  ;

  _proto.setVideoTrackById = function setVideoTrackById(id) {
    for (var i = 0; i < this._videoTracks.length; i++) {
      var _this$_videoTracks$i = this._videoTracks[i],
          track = _this$_videoTracks$i.track,
          nativeTrack = _this$_videoTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.selected = true;
        this._videoTrackLockedOn = nativeTrack;
        return;
      }
    }

    throw new Error("Video track not found.");
  }
  /**
   * Returns the currently active audio track.
   * Returns `null` if no audio track is active.
   * Returns `undefined` if we cannot know which audio track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenAudioTrack = function getChosenAudioTrack() {
    var chosenPrivateAudioTrack = this._getPrivateChosenAudioTrack();

    if (chosenPrivateAudioTrack != null) {
      return chosenPrivateAudioTrack.track;
    }

    return chosenPrivateAudioTrack;
  }
  /**
   * Returns the currently active text track.
   * Returns `null` if no text track is active.
   * Returns `undefined` if we cannot know which text track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenTextTrack = function getChosenTextTrack() {
    var chosenPrivateTextTrack = this._getPrivateChosenTextTrack();

    if (chosenPrivateTextTrack != null) {
      return chosenPrivateTextTrack.track;
    }

    return chosenPrivateTextTrack;
  }
  /**
   * Returns the currently active video track.
   * Returns `null` if no video track is active.
   * Returns `undefined` if we cannot know which video track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenVideoTrack = function getChosenVideoTrack() {
    var chosenPrivateVideoTrack = this._getPrivateChosenVideoTrack();

    if (chosenPrivateVideoTrack != null) {
      return chosenPrivateVideoTrack.track;
    }

    return chosenPrivateVideoTrack;
  }
  /**
   * Returns a description of every available audio tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    return this._audioTracks.map(function (_ref) {
      var track = _ref.track,
          nativeTrack = _ref.nativeTrack;
      return {
        id: track.id,
        language: track.language,
        normalized: track.normalized,
        audioDescription: track.audioDescription,
        active: nativeTrack.enabled,
        representations: track.representations
      };
    });
  }
  /**
   * Returns a description of every available text tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    return this._textTracks.map(function (_ref2) {
      var track = _ref2.track,
          nativeTrack = _ref2.nativeTrack;
      return {
        id: track.id,
        language: track.language,
        normalized: track.normalized,
        closedCaption: track.closedCaption,
        active: nativeTrack.mode === "showing"
      };
    });
  }
  /**
   * Returns a description of every available video tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    return this._videoTracks.map(function (_ref3) {
      var track = _ref3.track,
          nativeTrack = _ref3.nativeTrack;
      return {
        id: track.id,
        representations: track.representations,
        active: nativeTrack.selected
      };
    });
  }
  /**
   * Free the resources used by the MediaElementTrackChoiceManager.
   */
  ;

  _proto.dispose = function dispose() {
    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onchange = null;
      this._nativeVideoTracks.onaddtrack = null;
      this._nativeVideoTracks.onremovetrack = null;
    }

    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onchange = null;
      this._nativeAudioTracks.onaddtrack = null;
      this._nativeAudioTracks.onremovetrack = null;
    }

    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onchange = null;
      this._nativeTextTracks.onaddtrack = null;
      this._nativeTextTracks.onremovetrack = null;
    }

    this.removeEventListener();
  }
  /**
   * Get information about the currently chosen audio track.
   * `undefined` if we cannot know it.
   * `null` if no audio track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenAudioTrack = function _getPrivateChosenAudioTrack() {
    if (this._nativeAudioTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._audioTracks.length; i++) {
      var audioTrack = this._audioTracks[i];

      if (audioTrack.nativeTrack.enabled) {
        return audioTrack;
      }
    }

    return null;
  }
  /**
   * Get information about the currently chosen video track.
   * `undefined` if we cannot know it.
   * `null` if no video track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenVideoTrack = function _getPrivateChosenVideoTrack() {
    if (this._nativeVideoTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._videoTracks.length; i++) {
      var videoTrack = this._videoTracks[i];

      if (videoTrack.nativeTrack.selected) {
        return videoTrack;
      }
    }

    return null;
  }
  /**
   * Get information about the currently chosen text track.
   * `undefined` if we cannot know it.
   * `null` if no text track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenTextTrack = function _getPrivateChosenTextTrack() {
    if (this._nativeTextTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._textTracks.length; i++) {
      var textTrack = this._textTracks[i];

      if (textTrack.nativeTrack.mode === "showing") {
        return textTrack;
      }
    }

    return null;
  }
  /**
   * Iterate over every available audio tracks on the media element and either:
   *   - if the last manually set audio track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, let the one chosen by default
   */
  ;

  _proto._setOptimalAudioTrack = function _setOptimalAudioTrack() {
    // First check if the last set track is available, set it if that's the case
    if (this._audioTrackLockedOn !== undefined) {
      for (var i = 0; i < this._audioTracks.length; i++) {
        var nativeTrack = this._audioTracks[i].nativeTrack;

        if (nativeTrack === this._audioTrackLockedOn) {
          nativeTrack.enabled = true;
          return;
        }
      }
    }

    this._applyAudioPreferences();
  }
  /**
   * Try to find a track corresponding to the audio track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen audio track by default
   */
  ;

  _proto._applyAudioPreferences = function _applyAudioPreferences() {
    // Re-set the last manually set audio track
    this._audioTrackLockedOn = undefined;
    var preferredAudioTracks = this._preferredAudioTracks;

    for (var i = 0; i < preferredAudioTracks.length; i++) {
      var track = preferredAudioTracks[i];

      if (track !== null && track.language !== undefined) {
        var normalized = Object(_utils_languages__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(track.language);

        for (var j = 0; j < this._audioTracks.length; j++) {
          var audioTrack = this._audioTracks[j];

          if (audioTrack.track.normalized === normalized && audioTrack.track.audioDescription === track.audioDescription) {
            audioTrack.nativeTrack.enabled = true;
            return;
          }
        }
      }
    } // else just let the default one instead

  }
  /**
   * Iterate over every available text tracks on the media element and either:
   *   - if the last manually set text track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, just disable it.
   */
  ;

  _proto._setOptimalTextTrack = function _setOptimalTextTrack() {
    // First check if the last set track is available, set it if that's the case
    if (this._textTrackLockedOn === null) {
      disableTextTracks(this._textTracks);
      return;
    } else if (this._textTrackLockedOn !== undefined) {
      for (var i = 0; i < this._textTracks.length; i++) {
        var nativeTrack = this._textTracks[i].nativeTrack;

        if (nativeTrack === this._textTrackLockedOn) {
          // disable the rest
          disableAllTextTracksBut(this._textTracks, nativeTrack);

          if (nativeTrack.mode !== "showing") {
            nativeTrack.mode = "showing";
          }

          return;
        }
      }
    } // Else set the preferred one


    this._applyTextPreferences();
  }
  /**
   * Try to find a track corresponding to the text track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen text track by default
   */
  ;

  _proto._applyTextPreferences = function _applyTextPreferences() {
    // Re-set the last manually set audio track
    this._textTrackLockedOn = undefined;
    var preferredTextTracks = this._preferredTextTracks;

    for (var i = 0; i < preferredTextTracks.length; i++) {
      var track = preferredTextTracks[i];

      if (track === null) {
        disableTextTracks(this._textTracks);
        return;
      }

      var normalized = Object(_utils_languages__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(track.language);

      for (var j = 0; j < this._textTracks.length; j++) {
        var textTrack = this._textTracks[j];

        if (textTrack.track.normalized === normalized && textTrack.track.closedCaption === track.closedCaption) {
          // disable the rest
          disableAllTextTracksBut(this._textTracks, textTrack.nativeTrack);

          if (textTrack.nativeTrack.mode !== "showing") {
            textTrack.nativeTrack.mode = "showing";
          }

          return;
        }
      }
    } // Else just disable text tracks


    disableTextTracks(this._textTracks);
  }
  /**
   * Iterate over every available video tracks on the media element and either:
   *   - if the last manually set video track is found, set that one.
   *   - if not, set the most preferred one
   *   - if we still do not find an optimal track, let the one chosen by default
   */
  ;

  _proto._setOptimalVideoTrack = function _setOptimalVideoTrack() {
    // 1. first check if the last set track is available, set it if that's the case
    if (this._videoTrackLockedOn === null) {
      disableVideoTracks(this._videoTracks);
      return;
    } else if (this._videoTrackLockedOn !== undefined) {
      for (var i = 0; i < this._videoTracks.length; i++) {
        var nativeTrack = this._videoTracks[i].nativeTrack;

        if (nativeTrack === this._videoTrackLockedOn) {
          nativeTrack.selected = true;
          return;
        }
      }
    } // Else set the preferred one


    this._applyVideoPreferences();
  }
  /**
   * Try to find a track corresponding to the text track preferences:
   *   - if found, set it as the active track
   *   - if not found, let the chosen text track by default
   */
  ;

  _proto._applyVideoPreferences = function _applyVideoPreferences() {
    // Re-set the last manually set video track
    this._videoTrackLockedOn = undefined; // NOTE: As we cannot access either codec information or sign interpretation
    // information easily about the different codecs. It is the same case than
    // if we had only tracks where those were set to undefined.
    // Based on that, we should disable the video track as long as one of the
    // set preferrence is "no video track" (i.e. `null`) as this is the only
    // constraint that we know we can respect.
    // Else, just chose the first track.

    var preferredVideoTracks = this._preferredVideoTracks;
    var hasNullPreference = preferredVideoTracks.some(function (p) {
      return p === null;
    });

    if (hasNullPreference) {
      disableVideoTracks(this._videoTracks);
    } // else just let the default one instead

  }
  /**
   * Monitor native tracks add, remove and change callback and trigger the
   * change events.
   */
  ;

  _proto._handleNativeTracksCallbacks = function _handleNativeTracksCallbacks() {
    var _this2 = this;

    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);

          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;

            _this2._setOptimalAudioTrack();

            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());

            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();

            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeAudioTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);

          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;

            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());

            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();

            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeAudioTracks.onchange = function () {
        if (_this2._audioTracks !== undefined) {
          for (var i = 0; i < _this2._audioTracks.length; i++) {
            var _this2$_audioTracks$i = _this2._audioTracks[i],
                track = _this2$_audioTracks$i.track,
                nativeTrack = _this2$_audioTracks$i.nativeTrack;

            if (nativeTrack.enabled) {
              if (nativeTrack !== _this2._lastEmittedNativeAudioTrack) {
                _this2.trigger("audioTrackChange", track);

                _this2._lastEmittedNativeAudioTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeAudioTrack !== null) {
          _this2.trigger("audioTrackChange", null);

          _this2._lastEmittedNativeAudioTrack = null;
        }

        return;
      };
    }

    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);

          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;

            _this2._setOptimalTextTrack();

            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());

            var chosenTextTrack = _this2._getPrivateChosenTextTrack();

            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeTextTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);

          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;

            _this2._setOptimalTextTrack();

            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());

            var chosenTextTrack = _this2._getPrivateChosenTextTrack();

            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeTextTracks.onchange = function () {
        if (_this2._textTracks !== undefined) {
          for (var i = 0; i < _this2._textTracks.length; i++) {
            var _this2$_textTracks$i = _this2._textTracks[i],
                track = _this2$_textTracks$i.track,
                nativeTrack = _this2$_textTracks$i.nativeTrack;

            if (nativeTrack.mode === "showing") {
              if (nativeTrack !== _this2._lastEmittedNativeTextTrack) {
                _this2.trigger("textTrackChange", track);

                _this2._lastEmittedNativeTextTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeTextTrack !== null) {
          _this2.trigger("textTrackChange", null);

          _this2._lastEmittedNativeTextTrack = null;
        }

        return;
      };
    }

    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);

          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;

            _this2._setOptimalVideoTrack();

            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());

            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();

            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeVideoTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);

          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;

            _this2._setOptimalVideoTrack();

            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());

            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();

            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeVideoTracks.onchange = function () {
        if (_this2._videoTracks !== undefined) {
          for (var i = 0; i < _this2._videoTracks.length; i++) {
            var _this2$_videoTracks$i = _this2._videoTracks[i],
                track = _this2$_videoTracks$i.track,
                nativeTrack = _this2$_videoTracks$i.nativeTrack;

            if (nativeTrack.selected) {
              if (nativeTrack !== _this2._lastEmittedNativeVideoTrack) {
                _this2.trigger("videoTrackChange", track);

                _this2._lastEmittedNativeVideoTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeVideoTrack !== null) {
          _this2.trigger("videoTrackChange", null);

          _this2._lastEmittedNativeVideoTrack = null;
        }

        return;
      };
    }
  };

  return MediaElementTrackChoiceManager;
}(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);
/**
 * Disable all text track elements in the given array from showing.
 * @param {Array.<Object>} textTracks
 */




function disableTextTracks(textTracks) {
  for (var i = 0; i < textTracks.length; i++) {
    var nativeTrack = textTracks[i].nativeTrack;
    nativeTrack.mode = "disabled";
  }
}
/**
 * Disable all text track elements in the given array from showing but one which
 * should stay in the same state it was before.
 * @param {Array.<Object>} textTracks
 * @param {TextTrack} track
 */


function disableAllTextTracksBut(textTracks, track) {
  for (var i = 0; i < textTracks.length; i++) {
    var nativeTrack = textTracks[i].nativeTrack;

    if (nativeTrack !== track && (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden")) {
      nativeTrack.mode = "disabled";
    }
  }
}
/**
 * Disable all video track elements in the given array from showing.
 * Note that browser need to support that use case, which they often do not.
 * @param {Array.<Object>} videoTracks
 */


function disableVideoTracks(videoTracks) {
  for (var i = 0; i < videoTracks.length; i++) {
    var nativeTrack = videoTracks[i].nativeTrack;
    nativeTrack.selected = false;
  }
}

/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(62);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(183);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(65);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/BehaviorSubject.js
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */



var BehaviorSubject_BehaviorSubject = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError["a" /* ObjectUnsubscribedError */]();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject["a" /* Subject */]));

//# sourceMappingURL=BehaviorSubject.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(233);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(156);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(145);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js + 1 modules
var multicast = __webpack_require__(102);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        Object(multicast["a" /* multicast */])(function () { return new Subject["a" /* Subject */](); }, selector) :
        Object(multicast["a" /* multicast */])(new Subject["a" /* Subject */]());
}
//# sourceMappingURL=publish.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(159);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(192);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(184);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(185);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new skipWhile_SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var skipWhile_SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=skipWhile.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(241);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
var mergeMapTo = __webpack_require__(191);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(48);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(40);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// EXTERNAL MODULE: ./src/utils/promise.ts
var promise = __webpack_require__(26);

// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(22);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(21);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(9);

// EXTERNAL MODULE: ./src/compat/fullscreen.ts
var fullscreen = __webpack_require__(105);

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(59);

// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(181);

// EXTERNAL MODULE: ./src/errors/other_error.ts
var other_error = __webpack_require__(79);

// CONCATENATED MODULE: ./src/errors/format_error.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */

function formatError(error, _ref) {
  var defaultCode = _ref.defaultCode,
      defaultReason = _ref.defaultReason;

  if (Object(is_known_error["a" /* default */])(error)) {
    return error;
  }

  var reason = error instanceof Error ? error.toString() : defaultReason;
  return new other_error["a" /* default */](defaultCode, reason);
}
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(45);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
var dispose_eme = __webpack_require__(164);

// EXTERNAL MODULE: ./src/core/eme/get_current_key_system.ts
var get_current_key_system = __webpack_require__(165);

// EXTERNAL MODULE: ./src/core/eme/clear_eme_session.ts
var clear_eme_session = __webpack_require__(163);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(190);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 6 modules
var from = __webpack_require__(71);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return Object(from["a" /* from */])(project(a, i)).pipe(Object(map["a" /* map */])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var exhaustMap_ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new innerSubscribe["a" /* SimpleInnerSubscriber */](this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = Object(innerSubscribe["c" /* innerSubscribe */])(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(innerSubscribe["b" /* SimpleOuterSubscriber */]));
//# sourceMappingURL=exhaustMap.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(158);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var finalize_FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription["a" /* Subscription */](callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=finalize.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(142);

// EXTERNAL MODULE: ./src/compat/should_reload_media_source_on_decipherability_update.ts
var should_reload_media_source_on_decipherability_update = __webpack_require__(175);

// EXTERNAL MODULE: ./src/utils/defer_subscriptions.ts + 6 modules
var defer_subscriptions = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// CONCATENATED MODULE: ./src/utils/rx-throttle.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function throttle(func) {
  var isPending = false;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Observable["a" /* Observable */](function (obs) {
      if (isPending) {
        obs.complete();
        return undefined;
      }

      isPending = true;
      var funcSubscription = func.apply(void 0, args).subscribe(function (i) {
        obs.next(i);
      }, function (e) {
        isPending = false;
        obs.error(e);
      }, function () {
        isPending = false;
        obs.complete();
      });
      return function () {
        funcSubscription.unsubscribe();
        isPending = false;
      };
    });
  };
}
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(19);

// CONCATENATED MODULE: ./src/core/abr/ewma.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
var EWMA = /*#__PURE__*/function () {
  /**
   * @param {number} halfLife
   */
  function EWMA(halfLife) {
    // (half-life = log(1/2) / log(Decay Factor)
    this._alpha = Math.exp(Math.log(0.5) / halfLife);
    this._lastEstimate = 0;
    this._totalWeight = 0;
  }
  /**
   * @param {number} weight
   * @param {number} value
   */


  var _proto = EWMA.prototype;

  _proto.addSample = function addSample(weight, value) {
    var adjAlpha = Math.pow(this._alpha, weight);
    var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;

    if (!isNaN(newEstimate)) {
      this._lastEstimate = newEstimate;
      this._totalWeight += weight;
    }
  }
  /**
   * @returns {number} value
   */
  ;

  _proto.getEstimate = function getEstimate() {
    var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
    return this._lastEstimate / zeroFactor;
  };

  return EWMA;
}();


// CONCATENATED MODULE: ./src/core/abr/bandwidth_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ABR_MINIMUM_TOTAL_BYTES = config["a" /* default */].ABR_MINIMUM_TOTAL_BYTES,
    ABR_MINIMUM_CHUNK_SIZE = config["a" /* default */].ABR_MINIMUM_CHUNK_SIZE,
    ABR_FAST_EMA = config["a" /* default */].ABR_FAST_EMA,
    ABR_SLOW_EMA = config["a" /* default */].ABR_SLOW_EMA;
/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */

var bandwidth_estimator_BandwidthEstimator = /*#__PURE__*/function () {
  function BandwidthEstimator() {
    /**
     * A fast-moving average.
     * @private
     */
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    /**
     * A slow-moving average.
     * @private
     */

    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    /**
     * Number of bytes sampled.
     * @private
     */

    this._bytesSampled = 0;
  }
  /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */


  var _proto = BandwidthEstimator.prototype;

  _proto.addSample = function addSample(durationInMs, numberOfBytes) {
    if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
      return;
    }

    var bandwidth = numberOfBytes * 8000 / durationInMs;
    var weight = durationInMs / 1000;
    this._bytesSampled += numberOfBytes;

    this._fastEWMA.addSample(weight, bandwidth);

    this._slowEWMA.addSample(weight, bandwidth);
  }
  /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */
  ;

  _proto.getEstimate = function getEstimate() {
    if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
      return undefined;
    } // Take the minimum of these two estimates.  This should have the effect of
    // adapting down quickly, but up more slowly.


    return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
  }
  /**
   * Reset the bandwidth estimation.
   */
  ;

  _proto.reset = function reset() {
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    this._bytesSampled = 0;
  };

  return BandwidthEstimator;
}();


// CONCATENATED MODULE: ./src/core/abr/create_filters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create Observable that merge several throttling Observables into one.
 * @param {Observable} limitWidth$ - Emit the width at which the chosen
 * Representation should be limited.
 * @param {Observable} throttleBitrate$ - Emit the maximum bitrate authorized.
 * @param {Observable} throttle$ - Also emit the maximum bitrate authorized.
 * Here for legacy reasons.
 * @returns {Observable}
 */

function createFilters(limitWidth$, throttleBitrate$, throttle$) {
  var deviceEventsArray = [];

  if (limitWidth$ != null) {
    deviceEventsArray.push(limitWidth$.pipe(Object(map["a" /* map */])(function (width) {
      return {
        width: width
      };
    })));
  }

  if (throttle$ != null) {
    deviceEventsArray.push(throttle$.pipe(Object(map["a" /* map */])(function (bitrate) {
      return {
        bitrate: bitrate
      };
    })));
  }

  if (throttleBitrate$ != null) {
    deviceEventsArray.push(throttleBitrate$.pipe(Object(map["a" /* map */])(function (bitrate) {
      return {
        bitrate: bitrate
      };
    })));
  } // Emit restrictions on the pools of available representations to choose
  // from.


  return deviceEventsArray.length > 0 ? Object(combineLatest["a" /* combineLatest */])(deviceEventsArray).pipe(Object(map["a" /* map */])(function (args) {
    return object_assign["a" /* default */].apply(void 0, [{}].concat(args));
  })) : Object(of["a" /* of */])({});
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(86);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(157);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js + 1 modules
var subscribeToResult = __webpack_require__(94);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new withLatestFrom_WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var withLatestFrom_WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(Object(subscribeToResult["a" /* subscribeToResult */])(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber["a" /* OuterSubscriber */]));
//# sourceMappingURL=withLatestFrom.js.map

// CONCATENATED MODULE: ./src/core/abr/get_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Return "Buffer Levels" which are steps of available buffers from which we
 * are normally able switch safely to the next available bitrate.
 * (Following an algorithm close to BOLA)
 * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in
 * ascending order.
 * @returns {Array.<number>}
 */
function getBufferLevels(bitrates) {
  var logs = bitrates.map(function (b) {
    return Math.log(b / bitrates[0]);
  });
  var utilities = logs.map(function (l) {
    return l - logs[0] + 1;
  }); // normalize

  var gp = (utilities[utilities.length - 1] - 1) / (bitrates.length * 2 + 10);
  var Vp = 1 / gp;
  return bitrates.map(function (_, i) {
    return minBufferLevelForBitrate(i);
  });
  /**
   * Get minimum buffer we should keep ahead to pick this bitrate.
   * @param {number} index
   * @returns {number}
   */

  function minBufferLevelForBitrate(index) {
    if (index === 0) {
      return 0;
    }

    var boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
    return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] - bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) + 4;
  }
}
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(36);

// CONCATENATED MODULE: ./src/core/abr/get_estimate_from_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * From the buffer gap, choose a representation.
 * @param {Object} clockTick
 * @param {Array.<Number>} bitrates
 * @param {Array.<Number>} bufferLevels
 * @returns {Object|undefined}
 */

function getEstimateFromBufferLevels(clockTick, bitrates, bufferLevels) {
  var bufferGap = clockTick.bufferGap,
      currentBitrate = clockTick.currentBitrate,
      currentScore = clockTick.currentScore,
      speed = clockTick.speed;

  if (currentBitrate == null) {
    return bitrates[0];
  }

  var currentBitrateIndex = Object(array_find_index["a" /* default */])(bitrates, function (b) {
    return b === currentBitrate;
  });

  if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {
    log["a" /* default */].error("ABR: Current Bitrate not found in the calculated levels");
    return bitrates[0];
  }

  var scaledScore;

  if (currentScore != null) {
    scaledScore = speed === 0 ? currentScore : currentScore / speed;
  }

  if (scaledScore != null && scaledScore > 1) {
    var currentBufferLevel = bufferLevels[currentBitrateIndex];

    var nextIndex = function () {
      for (var i = currentBitrateIndex + 1; i < bufferLevels.length; i++) {
        if (bufferLevels[i] > currentBufferLevel) {
          return i;
        }
      }
    }();

    if (nextIndex != null) {
      var nextBufferLevel = bufferLevels[nextIndex];

      if (bufferGap >= nextBufferLevel) {
        return bitrates[nextIndex];
      }
    }
  }

  if (scaledScore == null || scaledScore < 1.15) {
    var _currentBufferLevel = bufferLevels[currentBitrateIndex];

    if (bufferGap < _currentBufferLevel) {
      for (var i = currentBitrateIndex - 1; i >= 0; i--) {
        if (bitrates[i] < currentBitrate) {
          return bitrates[i];
        }
      }

      return currentBitrate;
    }
  }

  return currentBitrate;
}
// CONCATENATED MODULE: ./src/core/abr/buffer_based_chooser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Choose a bitrate based on the currently available buffer.
 *
 * This algorithm is based on the deviation of the BOLA algorithm.
 * It is a hybrid solution that also relies on a given bitrate's
 * "maintainability".
 * Each time a chunk is downloaded, from the ratio between the chunk duration
 * and chunk's request time, we can assume that the representation is
 * "maintanable" or not.
 * If so, we may switch to a better quality, or conversely to a worse quality.
 *
 * @param {Observable} update$
 * @param {Array.<number>} bitrates
 * @returns {Observable}
 */

function BufferBasedChooser(update$, bitrates) {
  var levelsMap = getBufferLevels(bitrates);
  log["a" /* default */].debug("ABR: Steps for buffer based chooser.", levelsMap.map(function (l, i) {
    return {
      bufferLevel: l,
      bitrate: bitrates[i]
    };
  }));
  return update$.pipe(Object(map["a" /* map */])(function (clockTick) {
    return getEstimateFromBufferLevels(clockTick, bitrates, levelsMap);
  }));
}
// CONCATENATED MODULE: ./src/core/abr/cached_segment_detector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CACHE_LOAD_DURATION_THRESHOLDS = config["a" /* default */].CACHE_LOAD_DURATION_THRESHOLDS;
/**
 * From segment download duration, tells if a segment
 * may have been loaded from cache.
 * @param {string} contentType
 * @param {number} downloadDuration
 */

function mayBeFromCache(contentType, downloadDuration) {
  var cacheLoadDurationThreshold = CACHE_LOAD_DURATION_THRESHOLDS[contentType];
  return downloadDuration < cacheLoadDurationThreshold;
}
/**
 * Returns a function used to determine if a segment was loaded
 * from cache or not.
 * @returns {function}
 */


function generateCachedSegmentDetector() {
  var hasAlreadyLoadedNonCachedContent = false;
  /**
   * Determines with request duration if a loaded chunk may have been loaded
   * from cache, and return true if should ignore the metrics for representation
   * chooser.
   * @param {Object} content
   * @param {number} duration
   * @returns {boolean}
   */

  return function shouldIgnoreMetrics(content, downloadDuration) {
    var contentType = content.adaptation.type;

    if (contentType === "text" || contentType === "image") {
      return false;
    }

    var segmentMayBeFromCache = mayBeFromCache(contentType, downloadDuration);

    if (segmentMayBeFromCache && hasAlreadyLoadedNonCachedContent) {
      // We already loaded not cached segments.
      // Do not consider cached segments anymore.
      return true;
    }

    if (!segmentMayBeFromCache && !hasAlreadyLoadedNonCachedContent) {
      // First segment not loaded from cache.
      hasAlreadyLoadedNonCachedContent = true;
    }

    return false;
  };
}
// CONCATENATED MODULE: ./src/core/abr/filter_by_bitrate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get only representations lower or equal to a given bitrate.
 * If no representation is lower than the given bitrate, returns an array containing
 * all Representation(s) with the lowest available bitrate.
 * @param {Array.<Object>} representations - All Representations available
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */

function filterByBitrate(representations, bitrate) {
  if (representations.length === 0) {
    return [];
  }

  representations.sort(function (ra, rb) {
    return ra.bitrate - rb.bitrate;
  });
  var minimumBitrate = representations[0].bitrate;
  var bitrateCeil = Math.max(bitrate, minimumBitrate);
  var firstSuperiorBitrateIndex = Object(array_find_index["a" /* default */])(representations, function (representation) {
    return representation.bitrate > bitrateCeil;
  });

  if (firstSuperiorBitrateIndex === -1) {
    return representations; // All representations have lower bitrates.
  }

  return representations.slice(0, firstSuperiorBitrateIndex);
}
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// CONCATENATED MODULE: ./src/core/abr/filter_by_width.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */

function filterByWidth(representations, width) {
  var sortedRepsByWidth = representations.slice() // clone
  .sort(function (a, b) {
    return Object(take_first_set["a" /* default */])(a.width, 0) - Object(take_first_set["a" /* default */])(b.width, 0);
  });
  var repWithMaxWidth = Object(array_find["a" /* default */])(sortedRepsByWidth, function (representation) {
    return typeof representation.width === "number" && representation.width >= width;
  });

  if (repWithMaxWidth === undefined) {
    return representations;
  }

  var maxWidth = typeof repWithMaxWidth.width === "number" ? repWithMaxWidth.width : 0;
  return representations.filter(function (representation) {
    return typeof representation.width === "number" ? representation.width <= maxWidth : true;
  });
}
// CONCATENATED MODULE: ./src/core/abr/from_bitrate_ceil.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation|undefined}
 */

function fromBitrateCeil(representations, bitrate) {
  var tooHighIndex = Object(array_find_index["a" /* default */])(representations, function (representation) {
    return representation.bitrate > bitrate;
  });

  if (tooHighIndex === -1) {
    return representations[representations.length - 1];
  }

  return representations[tooHighIndex - 1];
}
// CONCATENATED MODULE: ./src/core/abr/network_analyzer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var ABR_REGULAR_FACTOR = config["a" /* default */].ABR_REGULAR_FACTOR,
    ABR_STARVATION_DURATION_DELTA = config["a" /* default */].ABR_STARVATION_DURATION_DELTA,
    ABR_STARVATION_FACTOR = config["a" /* default */].ABR_STARVATION_FACTOR,
    ABR_STARVATION_GAP = config["a" /* default */].ABR_STARVATION_GAP,
    OUT_OF_STARVATION_GAP = config["a" /* default */].OUT_OF_STARVATION_GAP;
/**
 * Get pending segment request(s) starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {Array.<Object>}
 */

function getConcernedRequests(requests, neededPosition) {
  /** Index of the request for the next needed segment, in `requests`. */
  var nextSegmentIndex = Object(array_find_index["a" /* default */])(requests, function (request) {
    if (request.duration <= 0) {
      return false;
    }

    var segmentEnd = request.time + request.duration;
    return segmentEnd > neededPosition && Math.abs(neededPosition - request.time) < -0.3;
  });

  if (nextSegmentIndex < 0) {
    // Not found
    return [];
  }

  var nextRequest = requests[nextSegmentIndex];
  var segmentTime = nextRequest.time;
  var filteredRequests = [nextRequest]; // Get the possibly multiple requests for that segment's position

  for (var i = nextSegmentIndex + 1; i < requests.length; i++) {
    if (requests[i].time === segmentTime) {
      filteredRequests.push(requests[i]);
    } else {
      break;
    }
  }

  return filteredRequests;
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */


function estimateRequestBandwidth(request) {
  if (request.progress.length < 5) {
    // threshold from which we can consider
    // progress events reliably
    return undefined;
  } // try to infer quickly the current bitrate based on the
  // progress events


  var ewma1 = new EWMA(2);
  var progress = request.progress;

  for (var i = 1; i < progress.length; i++) {
    var bytesDownloaded = progress[i].size - progress[i - 1].size;
    var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
    var reqBitrate = bytesDownloaded * 8 / (timeElapsed / 1000);
    ewma1.addSample(timeElapsed / 1000, reqBitrate);
  }

  return ewma1.getEstimate();
}
/**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */


function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
  var remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;
  return Math.max(remainingData / bandwidthEstimate, 0);
}
/**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} playbackInfo - Information on the current playback.
 * @param {Object|null} currentRepresentation - The Representation being
 * presently being loaded.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimate emitted.
 * @returns {Number|undefined}
 */


function estimateStarvationModeBitrate(pendingRequests, playbackInfo, currentRepresentation, lastEstimatedBitrate) {
  var nextNeededPosition = playbackInfo.currentTime + playbackInfo.bufferGap;
  var concernedRequests = getConcernedRequests(pendingRequests, nextNeededPosition);

  if (concernedRequests.length !== 1) {
    // 0  == no request
    // 2+ == too complicated to calculate
    return undefined;
  }

  var concernedRequest = concernedRequests[0];
  var chunkDuration = concernedRequest.duration;
  var now = performance.now();
  var lastProgressEvent = concernedRequest.progress.length > 0 ? concernedRequest.progress[concernedRequest.progress.length - 1] : undefined; // first, try to do a quick estimate from progress events

  var bandwidthEstimate = estimateRequestBandwidth(concernedRequest);

  if (lastProgressEvent !== undefined && bandwidthEstimate !== undefined) {
    var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate); // if the remaining time does seem reliable

    if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime) {
      // Calculate estimated time spent rebuffering if we continue doing that request.
      var expectedRebufferingTime = remainingTime - playbackInfo.bufferGap / playbackInfo.speed;

      if (expectedRebufferingTime > 2000) {
        return bandwidthEstimate;
      }
    }
  }

  var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1000;
  var reasonableElapsedTime = requestElapsedTime <= (chunkDuration * 1.5 + 2) / playbackInfo.speed;

  if (currentRepresentation == null || reasonableElapsedTime) {
    return undefined;
  } // calculate a reduced bitrate from the current one


  var factor = chunkDuration / requestElapsedTime;
  var reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);

  if (lastEstimatedBitrate === undefined || reducedBitrate < lastEstimatedBitrate) {
    return reducedBitrate;
  }
}
/**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} playbackInfo
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @param {number} abrStarvationGap - "Buffer gap" from which we enter a
 * "starvation mode".
 * @returns {boolean}
 */


function shouldDirectlySwitchToLowBitrate(playbackInfo, requests) {
  var nextNeededPosition = playbackInfo.currentTime + playbackInfo.bufferGap;
  var nextRequest = Object(array_find["a" /* default */])(requests, function (r) {
    return r.duration > 0 && r.time + r.duration > nextNeededPosition;
  });

  if (nextRequest === undefined) {
    return true;
  }

  var now = performance.now();
  var lastProgressEvent = nextRequest.progress.length > 0 ? nextRequest.progress[nextRequest.progress.length - 1] : undefined; // first, try to do a quick estimate from progress events

  var bandwidthEstimate = estimateRequestBandwidth(nextRequest);

  if (lastProgressEvent === undefined || bandwidthEstimate === undefined) {
    return true;
  }

  var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);

  if ((now - lastProgressEvent.timestamp) / 1000 > remainingTime * 1.2) {
    return true;
  }

  var expectedRebufferingTime = remainingTime - playbackInfo.bufferGap / playbackInfo.speed;
  return expectedRebufferingTime > -1.5;
}
/**
 * Analyze the current network conditions and give a bandwidth estimate as well
 * as a maximum bitrate a Representation should be.
 * @class NetworkAnalyzer
 */


var network_analyzer_NetworkAnalyzer = /*#__PURE__*/function () {
  function NetworkAnalyzer(initialBitrate, lowLatencyMode) {
    this._initialBitrate = initialBitrate;
    this._inStarvationMode = false;

    if (lowLatencyMode) {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
        regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY
      };
    } else {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.DEFAULT,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
        regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT
      };
    }
  }
  /**
   * Gives an estimate of the current bandwidth and of the bitrate that should
   * be considered for chosing a `representation`.
   * This estimate is only based on network metrics.
   * @param {Object} playbackInfo - Gives current information about playback
   * @param {Object} bandwidthEstimator
   * @param {Object|null} currentRepresentation
   * @param {Array.<Object>} currentRequests
   * @param {number|undefined} lastEstimatedBitrate
   * @returns {Object}
   */


  var _proto = NetworkAnalyzer.prototype;

  _proto.getBandwidthEstimate = function getBandwidthEstimate(playbackInfo, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
    var newBitrateCeil; // bitrate ceil for the chosen Representation

    var bandwidthEstimate;
    var localConf = this._config;
    var bufferGap = playbackInfo.bufferGap,
        currentTime = playbackInfo.currentTime,
        duration = playbackInfo.duration; // check if should get in/out of starvation mode

    if (isNaN(duration) || bufferGap + currentTime < duration - ABR_STARVATION_DURATION_DELTA) {
      if (!this._inStarvationMode && bufferGap <= localConf.starvationGap) {
        log["a" /* default */].info("ABR: enter starvation mode.");
        this._inStarvationMode = true;
      } else if (this._inStarvationMode && bufferGap >= localConf.outOfStarvationGap) {
        log["a" /* default */].info("ABR: exit starvation mode.");
        this._inStarvationMode = false;
      }
    } else if (this._inStarvationMode) {
      log["a" /* default */].info("ABR: exit starvation mode.");
      this._inStarvationMode = false;
    } // If in starvation mode, check if a quick new estimate can be done
    // from the last requests.
    // If so, cancel previous estimates and replace it by the new one


    if (this._inStarvationMode) {
      bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, playbackInfo, currentRepresentation, lastEstimatedBitrate);

      if (bandwidthEstimate != null) {
        log["a" /* default */].info("ABR: starvation mode emergency estimate:", bandwidthEstimate);
        bandwidthEstimator.reset();
        newBitrateCeil = currentRepresentation == null ? bandwidthEstimate : Math.min(bandwidthEstimate, currentRepresentation.bitrate);
      }
    } // if newBitrateCeil is not yet defined, do the normal estimation


    if (newBitrateCeil == null) {
      bandwidthEstimate = bandwidthEstimator.getEstimate();

      if (bandwidthEstimate != null) {
        newBitrateCeil = bandwidthEstimate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else if (lastEstimatedBitrate != null) {
        newBitrateCeil = lastEstimatedBitrate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else {
        newBitrateCeil = this._initialBitrate;
      }
    }

    if (playbackInfo.speed > 1) {
      newBitrateCeil /= playbackInfo.speed;
    }

    return {
      bandwidthEstimate: bandwidthEstimate,
      bitrateChosen: newBitrateCeil
    };
  }
  /**
   * For a given wanted bitrate, tells if should switch urgently.
   * @param {number} bitrate
   * @param {Object} playbackInfo
   * @returns {boolean}
   */
  ;

  _proto.isUrgent = function isUrgent(bitrate, currentRepresentation, currentRequests, playbackInfo) {
    if (currentRepresentation === null) {
      return true;
    } else if (bitrate === currentRepresentation.bitrate) {
      return false;
    } else if (bitrate > currentRepresentation.bitrate) {
      return !this._inStarvationMode;
    }

    return shouldDirectlySwitchToLowBitrate(playbackInfo, currentRequests);
  };

  return NetworkAnalyzer;
}();


// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(78);

// CONCATENATED MODULE: ./src/core/abr/pending_requests_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store information about pending requests, like information about:
 *   - for which segments they are
 *   - how the request's progress goes
 * @class PendingRequestsStore
 */

var pending_requests_store_PendingRequestsStore = /*#__PURE__*/function () {
  function PendingRequestsStore() {
    this._currentRequests = {};
  }
  /**
   * Add information about a new pending request.
   * @param {string} id
   * @param {Object} payload
   */


  var _proto = PendingRequestsStore.prototype;

  _proto.add = function add(payload) {
    var id = payload.id,
        time = payload.time,
        duration = payload.duration,
        requestTimestamp = payload.requestTimestamp;
    this._currentRequests[id] = {
      time: time,
      duration: duration,
      requestTimestamp: requestTimestamp,
      progress: []
    };
  }
  /**
   * Notify of the progress of a currently pending request.
   * @param {Object} progress
   */
  ;

  _proto.addProgress = function addProgress(progress) {
    var request = this._currentRequests[progress.id];

    if (request == null) {
      if (false) {}

      log["a" /* default */].warn("ABR: progress for a request not added");
      return;
    }

    request.progress.push(progress);
  }
  /**
   * Remove a request previously set as pending.
   * @param {string} id
   */
  ;

  _proto.remove = function remove(id) {
    if (this._currentRequests[id] == null) {
      if (false) {}

      log["a" /* default */].warn("ABR: can't remove unknown request");
    }

    delete this._currentRequests[id];
  }
  /**
   * Returns information about all pending requests, in segment's chronological
   * order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getRequests = function getRequests() {
    return Object(object_values["a" /* default */])(this._currentRequests).filter(function (x) {
      return x != null;
    }).sort(function (reqA, reqB) {
      return reqA.time - reqB.time;
    });
  };

  return PendingRequestsStore;
}();


// CONCATENATED MODULE: ./src/core/abr/representation_score_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Calculate the "maintainability score" of a given Representation:
 *   - A score higher than 1 means that the Representation can theorically
 *     be downloaded faster than the duration of the media it represents.
 *     (e.g. a segment representing 4 seconds can be downloaded in less than 4
 *     seconds).
 *   - A score lower or equal to 1 means that the Representation cannot be
 *     downloaded
 *
 * The score follows a simple linear relation to both variables it is based
 * on:
 *   - if n seconds of content can be downloaded in 2*n seconds, the score will
 *     be `0.5`.
 *   - if n seconds of content can be downloaded in n seconds, the score will be
 *     `1`.
 *   - if n seconds of content can be downloaded in n/2 seconds, the score will
 *     be `2`.
 *   - ...
 *
 * The score is mainly here to tell you when your buffer-based guesses are
 * actually higher than the quality you should normally reach.
 *
 * /!\ Please bear in mind that we don't consider the playback rate in those
 * operations.
 * Still, integrating the playback rate a posteriori should not be difficult
 * (e.g. you can just divide the score by that rate).
 *
 * @class RepresentationScoreCalculator
 */

var representation_score_calculator_RepresentationScoreCalculator = /*#__PURE__*/function () {
  function RepresentationScoreCalculator() {
    this._currentRepresentationData = null;
    this._lastRepresentationWithGoodScore = null;
  }
  /**
   * Add new sample data.
   * @param {Representation} representation
   * @param {number} requestDuration - duration taken for doing the request for
   * the whole segment.
   * @param {number} segmentDuration - media duration of the whole segment, in
   * seconds.
   */


  var _proto = RepresentationScoreCalculator.prototype;

  _proto.addSample = function addSample(representation, requestDuration, segmentDuration) {
    var ratio = segmentDuration / requestDuration;

    var oldEwma = this._getEWMA(representation);

    var currentEWMA;

    if (oldEwma != null) {
      currentEWMA = oldEwma;
      oldEwma.addSample(requestDuration, ratio);
    } else {
      currentEWMA = new EWMA(5);
      currentEWMA.addSample(requestDuration, ratio);
      this._currentRepresentationData = {
        representation: representation,
        ewma: currentEWMA
      };
    }

    if (currentEWMA.getEstimate() > 1 && this._lastRepresentationWithGoodScore !== representation) {
      log["a" /* default */].debug("ABR: New last stable representation", representation);
      this._lastRepresentationWithGoodScore = representation;
    }
  }
  /**
   * Get score estimate for the given Representation.
   * undefined if no estimate is available.
   * @param {Representation} representation
   * @returns {number|undefined}
   */
  ;

  _proto.getEstimate = function getEstimate(representation) {
    var ewma = this._getEWMA(representation);

    if (ewma != null) {
      return ewma.getEstimate();
    }
  }
  /**
   * Returns last Representation which had reached a score superior to 1.
   * This Representation is the last known one which could be maintained.
   * Useful to know if a current guess is higher than what you should
   * normally be able to play.
   * `null` if no Representation ever reach that score.
   * @returns {Representation|null}
   */
  ;

  _proto.getLastStableRepresentation = function getLastStableRepresentation() {
    return this._lastRepresentationWithGoodScore;
  }
  /**
   * Returns EWMA for the given Representation.
   * null if no EWMA is currently stored for it.
   * @param {Representation} representation
   * @returns {EWMA|null}
   */
  ;

  _proto._getEWMA = function _getEWMA(representation) {
    if (this._currentRepresentationData != null && this._currentRepresentationData.representation.id === representation.id) {
      return this._currentRepresentationData.ewma;
    }

    return null;
  };

  return RepresentationScoreCalculator;
}();


// CONCATENATED MODULE: ./src/core/abr/representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * @returns {Array.<Representation>}
 */

function getFilteredRepresentations(representations, filters) {
  var _representations = representations;

  if (filters.bitrate != null) {
    _representations = filterByBitrate(_representations, filters.bitrate);
  }

  if (filters.width != null) {
    _representations = filterByWidth(_representations, filters.width);
  }

  return _representations;
}
/**
 * Estimate regularly the current network bandwidth and the best Representation
 * that can be played according to the current network and playback conditions.
 *
 * A `RepresentationEstimator` only does estimations for a given type (e.g.
 * "audio", "video" etc.) and Period.
 *
 * If estimates for multiple types and/or Periods are needed, you should
 * create as many `RepresentationEstimator`.
 * @param {Object} args
 * @returns {Observable}
 */


function RepresentationEstimator(_ref) {
  var bandwidthEstimator = _ref.bandwidthEstimator,
      clock$ = _ref.clock$,
      filters$ = _ref.filters$,
      initialBitrate = _ref.initialBitrate,
      lowLatencyMode = _ref.lowLatencyMode,
      manualBitrate$ = _ref.manualBitrate$,
      maxAutoBitrate$ = _ref.maxAutoBitrate$,
      representations = _ref.representations,
      streamEvents$ = _ref.streamEvents$;
  var scoreCalculator = new representation_score_calculator_RepresentationScoreCalculator();
  var networkAnalyzer = new network_analyzer_NetworkAnalyzer(initialBitrate == null ? 0 : initialBitrate, lowLatencyMode);
  var requestsStore = new pending_requests_store_PendingRequestsStore();
  var shouldIgnoreMetrics = generateCachedSegmentDetector();
  /**
   * Callback to call when new metrics are available
   * @param {Object} value
   */

  function onMetric(value) {
    var duration = value.duration,
        size = value.size,
        content = value.content;

    if (shouldIgnoreMetrics(content, duration)) {
      // We already loaded not cached segments.
      // Do not consider cached segments anymore.
      return;
    } // calculate bandwidth


    bandwidthEstimator.addSample(duration, size); // calculate "maintainability score"

    var segment = content.segment;

    if (segment.duration == null) {
      return;
    }

    var requestDuration = duration / 1000;
    var segmentDuration = segment.duration / segment.timescale;
    var representation = content.representation;
    scoreCalculator.addSample(representation, requestDuration, segmentDuration);
  }

  var metrics$ = streamEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "metrics";
  }), Object(tap["a" /* tap */])(function (_ref2) {
    var value = _ref2.value;
    return onMetric(value);
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var requests$ = streamEvents$.pipe(Object(tap["a" /* tap */])(function (evt) {
    switch (evt.type) {
      case "requestBegin":
        requestsStore.add(evt.value);
        break;

      case "requestEnd":
        requestsStore.remove(evt.value.id);
        break;

      case "progress":
        requestsStore.addProgress(evt.value);
        break;
    }
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var currentRepresentation$ = streamEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "representationChange";
  }), Object(map["a" /* map */])(function (e) {
    return e.value.representation;
  }), Object(startWith["a" /* startWith */])(null));
  var estimate$ = Object(defer["a" /* defer */])(function () {
    if (representations.length === 0) {
      throw new Error("ABRManager: no representation choice given");
    }

    if (representations.length === 1) {
      return Object(of["a" /* of */])({
        bitrate: undefined,
        representation: representations[0],
        manual: false,
        urgent: true,
        knownStableBitrate: undefined
      });
    }

    return manualBitrate$.pipe(Object(switchMap["a" /* switchMap */])(function (manualBitrate) {
      if (manualBitrate >= 0) {
        // -- MANUAL mode --
        var manualRepresentation = function () {
          var fromBitrate = fromBitrateCeil(representations, manualBitrate);

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          return representations[0];
        }();

        return Object(of["a" /* of */])({
          representation: manualRepresentation,
          bitrate: undefined,
          knownStableBitrate: undefined,
          manual: true,
          urgent: true
        });
      } // -- AUTO mode --


      var lastEstimatedBitrate;
      var forceBandwidthMode = true; // Emit each time a buffer-based estimation should be actualized (each
      // time a segment is added).

      var bufferBasedClock$ = streamEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
        return e.type === "added-segment";
      }), withLatestFrom(clock$), Object(map["a" /* map */])(function (_ref3) {
        var evtValue = _ref3[0].value,
            _ref3$ = _ref3[1],
            speed = _ref3$.speed,
            currentTime = _ref3$.currentTime;
        var timeRanges = evtValue.buffered;
        var bufferGap = Object(ranges["d" /* getLeftSizeOfRange */])(timeRanges, currentTime);
        var representation = evtValue.content.representation;
        var currentScore = scoreCalculator.getEstimate(representation);
        var currentBitrate = representation.bitrate;
        return {
          bufferGap: bufferGap,
          currentBitrate: currentBitrate,
          currentScore: currentScore,
          speed: speed
        };
      }));
      var bitrates = representations.map(function (r) {
        return r.bitrate;
      });
      var bufferBasedEstimation$ = BufferBasedChooser(bufferBasedClock$, bitrates).pipe(Object(startWith["a" /* startWith */])(undefined));
      return Object(combineLatest["a" /* combineLatest */])([clock$, maxAutoBitrate$, filters$, bufferBasedEstimation$]).pipe(withLatestFrom(currentRepresentation$), Object(map["a" /* map */])(function (_ref4) {
        var _ref4$ = _ref4[0],
            clock = _ref4$[0],
            maxAutoBitrate = _ref4$[1],
            filters = _ref4$[2],
            bufferBasedBitrate = _ref4$[3],
            currentRepresentation = _ref4[1];

        var _representations = getFilteredRepresentations(representations, filters);

        var requests = requestsStore.getRequests();

        var _networkAnalyzer$getB = networkAnalyzer.getBandwidthEstimate(clock, bandwidthEstimator, currentRepresentation, requests, lastEstimatedBitrate),
            bandwidthEstimate = _networkAnalyzer$getB.bandwidthEstimate,
            bitrateChosen = _networkAnalyzer$getB.bitrateChosen;

        lastEstimatedBitrate = bandwidthEstimate;
        var stableRepresentation = scoreCalculator.getLastStableRepresentation();
        var knownStableBitrate = stableRepresentation == null ? undefined : stableRepresentation.bitrate / (clock.speed > 0 ? clock.speed : 1);
        var bufferGap = clock.bufferGap;

        if (!forceBandwidthMode && bufferGap <= 5) {
          forceBandwidthMode = true;
        } else if (forceBandwidthMode && Number.isFinite(bufferGap) && bufferGap > 10) {
          forceBandwidthMode = false;
        }

        var chosenRepFromBandwidth = function () {
          var fromBitrate = fromBitrateCeil(_representations, Math.min(bitrateChosen, maxAutoBitrate));

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          if (_representations.length > 0) {
            return _representations[0];
          }

          return representations[0];
        }();

        if (forceBandwidthMode) {
          log["a" /* default */].debug("ABR: Choosing representation with bandwidth estimation.", chosenRepFromBandwidth);
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBandwidth,
            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
            manual: false,
            knownStableBitrate: knownStableBitrate
          };
        }

        if (bufferBasedBitrate == null || chosenRepFromBandwidth.bitrate >= bufferBasedBitrate) {
          log["a" /* default */].debug("ABR: Choosing representation with bandwidth estimation.", chosenRepFromBandwidth);
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBandwidth,
            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
            manual: false,
            knownStableBitrate: knownStableBitrate
          };
        }

        var limitedBitrate = Math.min(bufferBasedBitrate, maxAutoBitrate);

        var chosenRepresentation = function () {
          var fromBitrate = fromBitrateCeil(_representations, limitedBitrate);

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          if (_representations.length > 0) {
            return _representations[0];
          }

          return representations[0];
        }();

        if (bufferBasedBitrate <= maxAutoBitrate) {
          log["a" /* default */].debug("ABR: Choosing representation with buffer based bitrate ceiling.", chosenRepresentation);
        }

        return {
          bitrate: bandwidthEstimate,
          representation: chosenRepresentation,
          urgent: networkAnalyzer.isUrgent(bufferBasedBitrate, currentRepresentation, requests, clock),
          manual: false,
          knownStableBitrate: knownStableBitrate
        };
      }));
    }));
  });
  return Object(merge["a" /* merge */])(metrics$, requests$, estimate$);
}
// CONCATENATED MODULE: ./src/core/abr/abr_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Adaptive BitRate Manager.
 *
 * Select the right Representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */

var abr_manager_ABRManager = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   */
  function ABRManager(options) {
    this._manualBitrates = options.manualBitrates;
    this._maxAutoBitrates = options.maxAutoBitrates;
    this._initialBitrates = options.initialBitrates;
    this._throttlers = options.throttlers;
    this._bandwidthEstimators = {};
    this._lowLatencyMode = options.lowLatencyMode;
  }
  /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Array.<Representation>|undefined} representations
   * @param {Observable<Object>} clock$
   * @param {Observable<Object>} streamEvents$
   * @returns {Observable}
   */


  var _proto = ABRManager.prototype;

  _proto.get$ = function get$(type, representations, clock$, streamEvents$) {
    if (representations === void 0) {
      representations = [];
    }

    var bandwidthEstimator = this._getBandwidthEstimator(type);

    var manualBitrate$ = Object(take_first_set["a" /* default */])(this._manualBitrates[type], Object(of["a" /* of */])(-1));
    var maxAutoBitrate$ = Object(take_first_set["a" /* default */])(this._maxAutoBitrates[type], Object(of["a" /* of */])(Infinity));
    var initialBitrate = Object(take_first_set["a" /* default */])(this._initialBitrates[type], 0);
    var filters$ = createFilters(this._throttlers.limitWidth[type], this._throttlers.throttleBitrate[type], this._throttlers.throttle[type]);
    return RepresentationEstimator({
      bandwidthEstimator: bandwidthEstimator,
      streamEvents$: streamEvents$,
      clock$: clock$,
      filters$: filters$,
      initialBitrate: initialBitrate,
      manualBitrate$: manualBitrate$,
      maxAutoBitrate$: maxAutoBitrate$,
      representations: representations,
      lowLatencyMode: this._lowLatencyMode
    });
  }
  /**
   * @param {string} bufferType
   * @returns {Object}
   */
  ;

  _proto._getBandwidthEstimator = function _getBandwidthEstimator(bufferType) {
    var originalBandwidthEstimator = this._bandwidthEstimators[bufferType];

    if (originalBandwidthEstimator == null) {
      log["a" /* default */].debug("ABR: Creating new BandwidthEstimator for ", bufferType);
      var bandwidthEstimator = new bandwidth_estimator_BandwidthEstimator();
      this._bandwidthEstimators[bufferType] = bandwidthEstimator;
      return bandwidthEstimator;
    }

    return originalBandwidthEstimator;
  };

  return ABRManager;
}();


// CONCATENATED MODULE: ./src/core/abr/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var abr = (abr_manager_ABRManager);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(187);

// EXTERNAL MODULE: ./src/utils/filter_map.ts
var filter_map = __webpack_require__(84);

// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(43);

// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(146);

// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(179);

// CONCATENATED MODULE: ./src/core/fetchers/utils/error_selector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */

function errorSelector(error) {
  if (error instanceof request_error["a" /* default */]) {
    return new network_error["a" /* default */]("PIPELINE_LOAD_ERROR", error);
  }

  return formatError(error, {
    defaultCode: "PIPELINE_LOAD_ERROR",
    defaultReason: "Unknown error when fetching the Manifest"
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(189);

// EXTERNAL MODULE: ./src/compat/is_offline.ts
var is_offline = __webpack_require__(171);

// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(119);

// CONCATENATED MODULE: ./src/core/fetchers/utils/try_urls_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Called on a loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */

function shouldRetry(error) {
  if (error instanceof request_error["a" /* default */]) {
    if (error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_HTTP_CODE) {
      return error.status >= 500 || error.status === 404 || error.status === 415 || // some CDN seems to use that code when
      // requesting low-latency segments too much
      // in advance
      error.status === 412;
    }

    return error.type === error_codes["c" /* NetworkErrorTypes */].TIMEOUT || error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_EVENT;
  }

  return Object(is_known_error["a" /* default */])(error) && error.code === "INTEGRITY_ERROR";
}
/**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */


function isOfflineRequestError(error) {
  return error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_EVENT && Object(is_offline["a" /* default */])();
}

var REQUEST_ERROR_TYPES;

(function (REQUEST_ERROR_TYPES) {
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["None"] = 0] = "None";
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Regular"] = 1] = "Regular";
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Offline"] = 2] = "Offline";
})(REQUEST_ERROR_TYPES || (REQUEST_ERROR_TYPES = {}));
/**
 * Guess the type of error obtained.
 * @param {*} error
 * @returns {number}
 */


function getRequestErrorType(error) {
  return error instanceof request_error["a" /* default */] && isOfflineRequestError(error) ? REQUEST_ERROR_TYPES.Offline : REQUEST_ERROR_TYPES.Regular;
}
/**
 * Specific algorithm used to perform segment and manifest requests.
 *
 * Here how it works:
 *
 *   1. we give it one or multiple URLs available for the element we want to
 *      request, the request callback and some options
 *
 *   2. it tries to call the request callback with the first URL:
 *        - if it works as expected, it wrap the response in a `response` event.
 *        - if it fails, it emits a `retry` event and try with the next one.
 *
 *   3. When all URLs have been tested (and failed), it decides - according to
 *      the error counters, configuration and errors received - if it can retry
 *      at least one of them, in the same order:
 *        - If it can, it increments the corresponding error counter, wait a
 *          delay (based on an exponential backoff) and restart the same logic
 *          for all retry-able URL.
 *        - If it can't it just throws the error.
 *
 * Note that there are in fact two separate counters:
 *   - one for "offline" errors
 *   - one for other xhr errors
 * Both counters are resetted if the error type changes from an error to the
 * next.
 * @param {Array.<string} obs$
 * @param {Function} request$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */


function tryURLsWithBackoff(urls, request$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      maxRetryRegular = options.maxRetryRegular,
      maxRetryOffline = options.maxRetryOffline;
  var retryCount = 0;
  var lastError = REQUEST_ERROR_TYPES.None;
  var urlsToTry = urls.slice();

  if (urlsToTry.length === 0) {
    log["a" /* default */].warn("Fetchers: no URL given to `tryURLsWithBackoff`.");
    return empty["a" /* EMPTY */];
  }

  return tryURLsRecursively(urlsToTry[0], 0);
  /**
   * Try to do the request of a given `url` which corresponds to the `index`
   * argument in the `urlsToTry` Array.
   *
   * If it fails try the next one.
   *
   * If all URLs fail, start a timer and retry the first element in that array
   * by following the configuration.
   *
   * @param {string|null} url
   * @param {number} index
   * @returns {Observable}
   */

  function tryURLsRecursively(url, index) {
    return request$(url).pipe(Object(map["a" /* map */])(function (res) {
      return {
        type: "response",
        value: res
      };
    }), Object(catchError["a" /* catchError */])(function (error) {
      if (!shouldRetry(error)) {
        // ban this URL
        if (urlsToTry.length <= 1) {
          // This was the last one, throw
          throw error;
        } // else, remove that element from the array and go the next URL


        urlsToTry.splice(index, 1);
        var newIndex = index >= urlsToTry.length - 1 ? 0 : index;
        return tryURLsRecursively(urlsToTry[newIndex], newIndex).pipe(Object(startWith["a" /* startWith */])({
          type: "retry",
          value: error
        }));
      }

      var currentError = getRequestErrorType(error);
      var maxRetry = currentError === REQUEST_ERROR_TYPES.Offline ? maxRetryOffline : maxRetryRegular;

      if (currentError !== lastError) {
        retryCount = 0;
        lastError = currentError;
      }

      if (index < urlsToTry.length - 1) {
        // there is still URLs to test
        var _newIndex = index + 1;

        return tryURLsRecursively(urlsToTry[_newIndex], _newIndex).pipe(Object(startWith["a" /* startWith */])({
          type: "retry",
          value: error
        }));
      } // Here, we were using the last element of the `urlsToTry` array.
      // Increment counter and restart with the first URL


      retryCount++;

      if (retryCount > maxRetry) {
        throw error;
      }

      var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
      var fuzzedDelay = Object(get_fuzzed_delay["a" /* default */])(delay);
      var nextURL = urlsToTry[0];
      return Object(timer["a" /* timer */])(fuzzedDelay).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
        return tryURLsRecursively(nextURL, 0);
      }), Object(startWith["a" /* startWith */])({
        type: "retry",
        value: error
      }));
    }));
  }
}
/**
 * Lightweight version of the request algorithm, this time with only a simple
 * Observable given.
 * @param {Function} request$
 * @param {Object} options
 * @returns {Observable}
 */

function tryRequestObservableWithBackoff(request$, options) {
  // same than for a single unknown URL
  return tryURLsWithBackoff([null], function () {
    return request$;
  }, options);
}
// CONCATENATED MODULE: ./src/core/fetchers/utils/create_request_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function createRequestScheduler(backoffOptions, warning$) {
  /**
   * Allow the parser to schedule a new request.
   * @param {Function} request - Function performing the request.
   * @returns {Function}
   */
  return function scheduleRequest(request) {
    return tryRequestObservableWithBackoff(Object(rx_try_catch["a" /* default */])(request, undefined), backoffOptions).pipe(Object(filter_map["a" /* default */])(function (evt) {
      if (evt.type === "retry") {
        warning$.next(errorSelector(evt.value));
        return null;
      }

      return evt.value;
    }, null), Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/create_manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Returns function allowing to download the Manifest through a
 * `resolver -> loader` transport pipeline.
 *
 * The function returned takes the loader's data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a minor request error is encountered (in which case the request
 *     is usually retried).
 *   - The loaded Manifest's data
 *
 * This observable will throw if, following the options given, the request and
 * possible retries all failed.
 * @param {Object} manifestPipeline
 * @param {Object} backoffOptions
 * @returns {Function}
 */

function createManifestLoader(manifestPipeline, backoffOptions) {
  var loader = manifestPipeline.loader; // TODO Remove the resolver completely in the next major version

  var resolver = manifestPipeline.resolver != null ? manifestPipeline.resolver :
  /* tslint:disable deprecation */
  of["a" /* of */];
  /* tslint:enable deprecation */

  /**
   * Call the transport's resolver - if it exists - with the given data.
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */

  function callResolver(resolverArgument) {
    return Object(rx_try_catch["a" /* default */])(resolver, resolverArgument).pipe(Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }));
  }
  /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */


  function loadData(loaderArgument) {
    var loader$ = Object(rx_try_catch["a" /* default */])(loader, loaderArgument);
    return tryRequestObservableWithBackoff(loader$, backoffOptions).pipe(Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }), Object(map["a" /* map */])(function (evt) {
      return evt.type === "retry" ? {
        type: "warning",
        value: errorSelector(evt.value)
      } : evt.value;
    }));
  }
  /**
   * Load the corresponding data.
   * @param {sObject} pipelineInputData
   * @returns {Observable}
   */


  return function loadManifest(loaderArgs) {
    return callResolver(loaderArgs).pipe(Object(mergeMap["a" /* mergeMap */])(loadData));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/get_manifest_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_MAX_MANIFEST_REQUEST_RETRY = config["a" /* default */].DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    INITIAL_BACKOFF_DELAY_BASE = config["a" /* default */].INITIAL_BACKOFF_DELAY_BASE,
    MAX_BACKOFF_DELAY_BASE = config["a" /* default */].MAX_BACKOFF_DELAY_BASE;
/**
 * Parse config to replace missing manifest backoff options.
 * @param {Object} backoffOptions
 * @returns {Object}
 */

function getManifestBackoffOptions(_ref) {
  var maxRetryRegular = _ref.maxRetryRegular,
      maxRetryOffline = _ref.maxRetryOffline,
      lowLatencyMode = _ref.lowLatencyMode;
  var baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
  var maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
  return {
    baseDelay: baseDelay,
    maxDelay: maxDelay,
    maxRetryRegular: maxRetryRegular !== undefined ? maxRetryRegular : DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    maxRetryOffline: maxRetryOffline !== undefined ? maxRetryOffline : DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/create_manifest_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Create function allowing to easily fetch and parse a Manifest from its URL.
 * @example
 * ```js
 * const manifestFetcher = createManifestFetcher(pipelines, options);
 * manifestFetcher.fetch(manifestURL).pipe(
 *   // Filter only responses (might also receive warning events)
 *   filter((evt) => evt.type === "response");
 *   // Parse the Manifest
 *   mergeMap(res => res.parse({ externalClockOffset }))
 *   // (again)
 *   filter((evt) => evt.type === "parsed");
 * ).subscribe(({ value }) => {
 *   console.log("Manifest:", value.manifest);
 * });
 * ```
 * @param {Object} pipelines
 * @param {Subject} backoffOptions
 * @returns {Object}
 */

function createManifestFetcher(pipelines, options) {
  var backoffOptions = getManifestBackoffOptions(options);
  var loader = createManifestLoader(pipelines.manifest, backoffOptions);
  var parser = pipelines.manifest.parser;
  return {
    /**
     * Fetch the manifest corresponding to the URL given.
     * @param {string} url - URL of the manifest
     * @returns {Observable}
     */
    fetch: function fetch(url) {
      return loader({
        url: url
      }).pipe(Object(map["a" /* map */])(function (evt) {
        if (evt.type === "warning") {
          return evt;
        }

        var _evt$value = evt.value,
            sendingTime = _evt$value.sendingTime,
            receivedTime = _evt$value.receivedTime;
        var parsingTimeStart = performance.now();
        var schedulerWarnings$ = new Subject["a" /* Subject */]();
        var scheduleRequest = createRequestScheduler(backoffOptions, schedulerWarnings$);
        return {
          type: "response",
          parse: function parse(parserOptions) {
            return Object(merge["a" /* merge */])(schedulerWarnings$.pipe(Object(map["a" /* map */])(function (err) {
              return {
                type: "warning",
                value: err
              };
            })), parser({
              response: evt.value,
              url: url,
              externalClockOffset: parserOptions.externalClockOffset,
              previousManifest: parserOptions.previousManifest,
              scheduleRequest: scheduleRequest,
              unsafeMode: parserOptions.unsafeMode
            }).pipe(Object(catchError["a" /* catchError */])(function (error) {
              throw formatError(error, {
                defaultCode: "PIPELINE_PARSE_ERROR",
                defaultReason: "Unknown error when parsing the Manifest"
              });
            }), Object(map["a" /* map */])(function (parsingEvt) {
              if (parsingEvt.type === "warning") {
                var formatted = formatError(parsingEvt.value, {
                  defaultCode: "PIPELINE_PARSE_ERROR",
                  defaultReason: "Unknown error when parsing the Manifest"
                });
                return {
                  type: "warning",
                  value: formatted
                };
              } // 2 - send response


              var parsingTime = performance.now() - parsingTimeStart;
              return {
                type: "parsed",
                manifest: parsingEvt.value.manifest,
                sendingTime: sendingTime,
                receivedTime: receivedTime,
                parsingTime: parsingTime
              };
            }), finalize(function () {
              schedulerWarnings$.complete();
            })));
          }
        };
      }));
    }
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var fetchers_manifest = (createManifestFetcher);
// CONCATENATED MODULE: ./src/core/fetchers/segment/get_segment_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE = config["a" /* default */].INITIAL_BACKOFF_DELAY_BASE,
    get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE = config["a" /* default */].MAX_BACKOFF_DELAY_BASE;
/**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */

function getSegmentBackoffOptions(bufferType, _ref) {
  var maxRetryRegular = _ref.maxRetryRegular,
      maxRetryOffline = _ref.maxRetryOffline,
      lowLatencyMode = _ref.lowLatencyMode;
  return {
    maxRetryRegular: bufferType === "image" ? 0 : maxRetryRegular !== null && maxRetryRegular !== void 0 ? maxRetryRegular : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    maxRetryOffline: maxRetryOffline !== null && maxRetryOffline !== void 0 ? maxRetryOffline : get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    baseDelay: lowLatencyMode ? get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.REGULAR,
    maxDelay: lowLatencyMode ? get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.REGULAR
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritized_segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */

function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
  /**
   * The Observables returned by `createRequest` are not exactly the same than
   * the one created by the `ObservablePrioritizer`. Because we still have to
   * keep a handle on that value.
   */
  var taskHandlers = new WeakMap();
  return {
    /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be requested.
     * Lower number == higher priority.
     * @returns {Observable}
     */
    createRequest: function createRequest(content, priority) {
      if (priority === void 0) {
        priority = 0;
      }

      var task = prioritizer.create(fetcher(content), priority);
      var flattenTask = task.pipe(Object(map["a" /* map */])(function (evt) {
        return evt.type === "data" ? evt.value : evt;
      }));
      taskHandlers.set(flattenTask, task);
      return flattenTask;
    },

    /**
     * Update the priority of a pending request, created through
     * `createRequest`.
     * @param {Observable} observable - The Observable returned by `createRequest`.
     * @param {Number} priority - The new priority value.
     */
    updatePriority: function updatePriority(observable, priority) {
      var correspondingTask = taskHandlers.get(observable);

      if (correspondingTask === undefined) {
        log["a" /* default */].warn("Fetchers: Cannot update the priority of a request: task not found.");
        return;
      }

      prioritizer.updatePriority(correspondingTask, priority);
    }
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritizer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can link an Observables to a priority number.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such returned Observables - called "tasks" - will then basically wait for
 * pending task with more priority (i.e. a lower priority number) to finish
 * before "starting".
 *
 * This only applies for non-pending tasks. For pending tasks, those are usually
 * not interrupted except in the following case:
 *
 * When a task with a "high priority" (which is a configurable priority
 * value) is created, pending tasks with a "low priority" (also configurable)
 * will be interrupted. Those tasks will be restarted when all tasks with a
 * higher priority are finished.
 *
 * You can also update the priority of an already-created task.
 *
 * ```js
 * const observable1 = Observable.timer(100).pipe(mapTo(1));
 * const observable2 = Observable.timer(100).pipe(mapTo(2));
 * const observable3 = Observable.timer(100).pipe(mapTo(3));
 * const observable4 = Observable.timer(100).pipe(mapTo(4));
 * const observable5 = Observable.timer(100).pipe(mapTo(5));
 *
 * // Instanciate ObservablePrioritizer.
 * // Also provide a `high` priority step - the maximum priority number a "high
 * // priority task" has and a `low` priority step - the minimum priority number
 * // a "low priority task" has.
 * const prioritizer = new ObservablePrioritizer({
 *   prioritySteps: { high: 0, low: 20 }
 * });
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((evt) => {
 *   if (evt.type === "data") {
 *     console.log(i);
 *
 *     // To spice things up, update pObservable1 priority to go before
 *     // pObservable4
 *     if (i === 5) { // if pObservable5 is currently emitting
 *       prioritizer.updatePriority(pObservable1, 1);
 *     }
 *   }
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */

var prioritizer_ObservablePrioritizer = /*#__PURE__*/function () {
  /**
   * @param {Options} prioritizerOptions
   */
  function ObservablePrioritizer(_ref) {
    var prioritySteps = _ref.prioritySteps;
    this._minPendingPriority = null;
    this._waitingQueue = [];
    this._pendingTasks = [];
    this._prioritySteps = prioritySteps;

    if (this._prioritySteps.high >= this._prioritySteps.low) {
      throw new Error("FP Error: the max high level priority should be given a lower" + "priority number than the min low priority.");
    }
  }
  /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   *
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */


  var _proto = ObservablePrioritizer.prototype;

  _proto.create = function create(obs, priority) {
    var _this = this;

    var pObs$ = Object(defer["a" /* defer */])(function () {
      var trigger = new Subject["a" /* Subject */]();
      var newTask = {
        observable: pObs$,
        priority: priority,
        trigger: trigger
      };
      /**
       * Function executed each time the `trigger` Subject emits.
       * @param {Boolean} shouldRun - If `true`, the observable can run. If
       * `false` it means that it has just been interrupted.
       * @returns {Observable} - Returns events corresponding to the lifecycle
       * of the observable.
       */

      var onTrigger = function onTrigger(shouldRun) {
        if (!shouldRun) {
          return Object(of["a" /* of */])({
            type: "interrupted"
          });
        }

        _this._onTaskBegin(newTask);

        return Object(concat["a" /* concat */])(obs.pipe(Object(map["a" /* map */])(function (data) {
          return {
            type: "data",
            value: data
          };
        })), Object(of["a" /* of */])({
          type: "ended"
        })).pipe(finalize(function () {
          _this._onTaskEnd(newTask);
        }));
      };

      if (!_this._canBeStartedNow(newTask)) {
        // This task doesn't have priority yet. Start it on trigger
        _this._waitingQueue.push(newTask);

        return trigger.pipe(Object(switchMap["a" /* switchMap */])(onTrigger));
      } // Start it right away


      var startTask$ = trigger.pipe(Object(startWith["a" /* startWith */])(true), Object(switchMap["a" /* switchMap */])(onTrigger));
      return !_this._isHighPriority(newTask) ? startTask$ : Object(merge["a" /* merge */])(startTask$, // Note: we want to begin interrupting low-priority tasks just
      // after starting the current one because the interrupting
      // logic can call external code.
      // This would mean re-entrancy, itself meaning that some weird
      // half-state could be reached unless we're very careful.
      // To be sure no harm is done, we put that code at the last
      // possible position (the previous Observable sould be
      // performing all its initialization synchronously).
      Object(defer["a" /* defer */])(function () {
        _this._interruptCancellableTasks();

        return empty["a" /* EMPTY */];
      }));
    });
    return pObs$;
  }
  /**
   * Update the priority of an Observable created through the `create` method.
   * @param {Observable} obs
   * @param {number} priority
   */
  ;

  _proto.updatePriority = function updatePriority(obs, priority) {
    var waitingQueueIndex = Object(array_find_index["a" /* default */])(this._waitingQueue, function (elt) {
      return elt.observable === obs;
    });

    if (waitingQueueIndex >= 0) {
      // If it was still waiting for its turn
      var waitingQueueElt = this._waitingQueue[waitingQueueIndex];

      if (waitingQueueElt.priority === priority) {
        return;
      }

      waitingQueueElt.priority = priority;

      if (!this._canBeStartedNow(waitingQueueElt)) {
        return;
      }

      this._startTask(waitingQueueIndex);

      if (this._isHighPriority(waitingQueueElt)) {
        // This task has high priority.
        // We should cancel every "cancellable" pending task
        //
        // Note: We start the task before interrupting cancellable tasks on
        // purpose.
        // Because both `_startTask` and `_interruptCancellableTasks` can emit
        // events and thus call external code, we could retrieve ourselves in a
        // very weird state at this point (for example, the different Observable
        // priorities could all be shuffled up, new Observables could have been
        // started in the meantime, etc.).
        //
        // By starting the task first, we ensure that this is manageable:
        // `_minPendingPriority` has already been updated to the right value at
        // the time we reached external code, the priority of the current
        // Observable has just been re-checked by `_isHighPriority`, and
        // `_interruptCancellableTasks` will ensure that we're basing ourselves
        // on the last `priority` value each time.
        // Doing it in the reverse order is an order of magnitude more difficult
        // to write and to reason about.
        this._interruptCancellableTasks();
      }

      return;
    }

    var pendingTasksIndex = Object(array_find_index["a" /* default */])(this._pendingTasks, function (elt) {
      return elt.observable === obs;
    });

    if (pendingTasksIndex < 0) {
      log["a" /* default */].warn("FP: request to update the priority of a non-existent task");
      return;
    }

    var task = this._pendingTasks[pendingTasksIndex];

    if (task.priority === priority) {
      return;
    }

    var oldPriority = task.priority;
    task.priority = priority;

    if (priority < oldPriority) {
      if (this._isHighPriority(task)) {
        this._interruptCancellableTasks();
      }

      return;
    }

    if (this._minPendingPriority !== null && this._minPendingPriority <= this._prioritySteps.high) {
      // We could need to interrupt this task
      this._interruptPendingTask(task);
    }
  }
  /**
   * Interrupt and move back to the waiting queue all pending tasks that are
   * low priority (having a higher priority number than
   * `this._prioritySteps.low`).
   */
  ;

  _proto._interruptCancellableTasks = function _interruptCancellableTasks() {
    for (var i = 0; i < this._pendingTasks.length; i++) {
      var pendingObj = this._pendingTasks[i];

      if (pendingObj.priority >= this._prioritySteps.low) {
        this._interruptPendingTask(pendingObj); // The previous call could have a lot of potential side-effects.
        // It is safer to re-start the function to not miss any pending
        // task that needs to be cancelled.


        return this._interruptCancellableTasks();
      }
    }
  }
  /**
   * Start task which is at the given index in the waiting queue.
   * The task will be removed from the waiting queue in the process.
   * @param {number} index
   */
  ;

  _proto._startTask = function _startTask(index) {
    var task = this._waitingQueue.splice(index, 1)[0];

    task.trigger.next(true);
  }
  /**
   * Move back pending task to the waiting queue and interrupt it.
   * @param {object} task
   */
  ;

  _proto._interruptPendingTask = function _interruptPendingTask(task) {
    var pendingTasksIndex = Object(array_find_index["a" /* default */])(this._pendingTasks, function (elt) {
      return elt.observable === task.observable;
    });

    if (pendingTasksIndex < 0) {
      log["a" /* default */].warn("FP: Interrupting a non-existent pending task. Aborting...");
      return;
    } // Stop task and put it back in the waiting queue


    this._pendingTasks.splice(pendingTasksIndex, 1);

    this._waitingQueue.push(task);

    if (this._pendingTasks.length === 0) {
      this._minPendingPriority = null;
    } else if (this._minPendingPriority === task.priority) {
      this._minPendingPriority = Math.min.apply(Math, this._pendingTasks.map(function (t) {
        return t.priority;
      }));
    }

    task.trigger.next(false);
  }
  /**
   * Logic ran when a task begin.
   * @param {Object} task
   */
  ;

  _proto._onTaskBegin = function _onTaskBegin(task) {
    this._minPendingPriority = this._minPendingPriority === null ? task.priority : Math.min(this._minPendingPriority, task.priority);

    this._pendingTasks.push(task);
  }
  /**
   * Logic ran when a task has ended.
   * @param {Object} task
   */
  ;

  _proto._onTaskEnd = function _onTaskEnd(task) {
    var pendingTasksIndex = Object(array_find_index["a" /* default */])(this._pendingTasks, function (elt) {
      return elt.observable === task.observable;
    });

    if (pendingTasksIndex < 0) {
      return; // Happen for example when the task has been interrupted
    }

    task.trigger.complete();

    this._pendingTasks.splice(pendingTasksIndex, 1);

    if (this._pendingTasks.length > 0) {
      return; // still waiting for Observables to finish
    }

    this._minPendingPriority = null;

    if (this._waitingQueue.length === 0) {
      return; // no more task to do
    } // Calculate minimum waiting priority


    this._minPendingPriority = this._waitingQueue.reduce(function (acc, elt) {
      return acc === null || acc > elt.priority ? elt.priority : acc;
    }, null); // Start all tasks with that minimum priority

    for (var i = 0; i < this._waitingQueue.length; i++) {
      var elt = this._waitingQueue[i];

      if (elt.priority === this._minPendingPriority) {
        this._startTask(i);

        i--; // previous operation should have removed that element from the
        // the waiting queue
      }
    }
  }
  /**
   * Return `true` if the given task can be started immediately based on its
   * priority.
   * @param {Object} task
   * @returns {boolean}
   */
  ;

  _proto._canBeStartedNow = function _canBeStartedNow(task) {
    return this._minPendingPriority === null || task.priority <= this._minPendingPriority;
  }
  /**
   * Returns `true` if the given task can be considered "high priority".
   * returns false otherwise.
   * @param {Object} task
   * @returns {boolean}
   */
  ;

  _proto._isHighPriority = function _isHighPriority(task) {
    return task.priority <= this._prioritySteps.high;
  };

  return ObservablePrioritizer;
}();


// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts
var assert_unreachable = __webpack_require__(49);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(64);

// CONCATENATED MODULE: ./src/utils/initialization_segment_cache.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 * @class InitializationSegmentCache
 */
var InitializationSegmentCache = /*#__PURE__*/function () {
  function InitializationSegmentCache() {
    this._cache = new WeakMap();
  }
  /**
   * @param {Object} obj
   * @param {*} response
   */


  var _proto = InitializationSegmentCache.prototype;

  _proto.add = function add(_ref, response) {
    var representation = _ref.representation,
        segment = _ref.segment;

    if (segment.isInit) {
      this._cache.set(representation, response);
    }
  }
  /**
   * @param {Object} obj
   * @returns {*} response
   */
  ;

  _proto.get = function get(_ref2) {
    var representation = _ref2.representation,
        segment = _ref2.segment;

    if (segment.isInit) {
      var value = this._cache.get(representation);

      if (value !== undefined) {
        return value;
      }
    }

    return null;
  };

  return InitializationSegmentCache;
}();

/* harmony default export */ var initialization_segment_cache = (InitializationSegmentCache);
// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(29);

// CONCATENATED MODULE: ./src/core/fetchers/segment/create_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns a function allowing to load any wanted segment.
 *
 * The function returned takes in argument information about the wanted segment
 * and returns an Observable which will emit various events related to the
 * segment request (see ISegmentLoaderEvent).
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting all the segment's data.
 *
 * Type parameters:
 *   - T: type of the data emitted
 *
 * @param {Function} loader
 * @param {Object | undefined} cache
 * @param {Object} options
 * @returns {Function}
 */

function createSegmentLoader(loader, cache, backoffOptions) {
  /**
   * Try to retrieve the segment from the cache and if not found call the
   * pipeline's loader (with possible retries) to load it.
   * @param {Object} loaderArgument - Context for the wanted segment.
   * @returns {Observable}
   */
  function loadData(wantedContent) {
    /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
    function startLoaderWithBackoff() {
      var _a;

      var request$ = function request$(url) {
        var loaderArgument = Object(object_assign["a" /* default */])({
          url: url
        }, wantedContent);
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
          type: "request",
          value: loaderArgument
        }), Object(rx_try_catch["a" /* default */])(loader, loaderArgument));
      };

      return tryURLsWithBackoff((_a = wantedContent.segment.mediaURLs) !== null && _a !== void 0 ? _a : [null], request$, backoffOptions).pipe(Object(catchError["a" /* catchError */])(function (error) {
        throw errorSelector(error);
      }), Object(map["a" /* map */])(function (evt) {
        if (evt.type === "retry") {
          return {
            type: "warning",
            value: errorSelector(evt.value)
          };
        } else if (evt.value.type === "request") {
          return evt.value;
        }

        var response = evt.value;

        if (response.type === "data-loaded" && cache != null) {
          cache.add(wantedContent, response.value);
        }

        return evt.value;
      }));
    }

    var dataFromCache = cache != null ? cache.get(wantedContent) : null;

    if (dataFromCache != null) {
      return Object(cast_to_observable["a" /* default */])(dataFromCache).pipe(Object(map["a" /* map */])(function (response) {
        return {
          type: "cache",
          value: response
        };
      }), Object(catchError["a" /* catchError */])(startLoaderWithBackoff));
    }

    return startLoaderWithBackoff();
  }
  /**
   * Load the corresponding segment.
   * @param {Object} content
   * @returns {Observable}
   */


  return function loadSegment(content) {
    return loadData(content).pipe(Object(mergeMap["a" /* mergeMap */])(function (arg) {
      var metrics$;

      if ((arg.type === "data-chunk-complete" || arg.type === "data-loaded") && arg.value.size !== undefined && arg.value.duration !== undefined) {
        metrics$ = Object(of["a" /* of */])({
          type: "metrics",
          value: {
            size: arg.value.size,
            duration: arg.value.duration,
            content: content
          }
        });
      } else {
        metrics$ = empty["a" /* EMPTY */];
      }

      switch (arg.type) {
        case "warning":
        case "request":
        case "progress":
          return Object(of["a" /* of */])(arg);

        case "cache":
        case "data-created":
        case "data-loaded":
          return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
            type: "data",
            value: arg.value
          }), metrics$);

        case "data-chunk":
          return Object(of["a" /* of */])({
            type: "chunk",
            value: arg.value
          });

        case "data-chunk-complete":
          return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
            type: "chunk-complete",
            value: null
          }), metrics$);

        default:
          Object(assert_unreachable["a" /* default */])(arg);
      }
    }));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var generateRequestID = Object(id_generator["a" /* default */])();
/**
 * Create a function which will fetch and parse segments.
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} requests$
 * @param {Object} options
 * @returns {Function}
 */

function segment_fetcher_createSegmentFetcher(bufferType, transport, requests$, options) {
  var cache = Object(array_includes["a" /* default */])(["audio", "video"], bufferType) ? new initialization_segment_cache() : undefined;
  var segmentLoader = createSegmentLoader(transport[bufferType].loader, cache, options);
  var segmentParser = transport[bufferType].parser; // deal with it

  /**
   * Process the segmentLoader observable to adapt it to the the rest of the
   * code:
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {Object} content
   * @returns {Observable}
   */

  return function fetchSegment(content) {
    var id = generateRequestID();
    var requestBeginSent = false;
    return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (arg) {
      switch (arg.type) {
        case "metrics":
          {
            requests$.next(arg);
            break;
          }

        case "request":
          {
            var value = arg.value; // format it for ABR Handling

            var segment = value.segment;

            if (segment == null || segment.duration == null) {
              return;
            }

            requestBeginSent = true;
            var duration = segment.duration / segment.timescale;
            var time = segment.time / segment.timescale;
            requests$.next({
              type: "requestBegin",
              value: {
                duration: duration,
                time: time,
                requestTimestamp: performance.now(),
                id: id
              }
            });
            break;
          }

        case "progress":
          {
            var _value = arg.value;

            if (_value.totalSize != null && _value.size < _value.totalSize) {
              requests$.next({
                type: "progress",
                value: {
                  duration: _value.duration,
                  size: _value.size,
                  totalSize: _value.totalSize,
                  timestamp: performance.now(),
                  id: id
                }
              });
            }

            break;
          }
      }
    }), finalize(function () {
      if (requestBeginSent) {
        requests$.next({
          type: "requestEnd",
          value: {
            id: id
          }
        });
      }
    }), Object(filter["a" /* filter */])(function (e) {
      switch (e.type) {
        case "warning":
        case "chunk":
        case "chunk-complete":
        case "data":
          return true;

        case "progress":
        case "metrics":
        case "request":
          return false;

        default:
          Object(assert_unreachable["a" /* default */])(e);
      }
    }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "warning") {
        return Object(of["a" /* of */])(evt);
      }

      if (evt.type === "chunk-complete") {
        return Object(of["a" /* of */])({
          type: "chunk-complete"
        });
      }

      var isChunked = evt.type === "chunk";
      var data = {
        type: "chunk",

        /**
         * Parse the loaded data.
         * @param {Object} [initTimescale]
         * @returns {Observable}
         */
        parse: function parse(initTimescale) {
          var response = {
            data: evt.value.responseData,
            isChunked: isChunked
          };
          /* tslint:disable no-unsafe-any */

          return segmentParser({
            response: response,
            initTimescale: initTimescale,
            content: content
          })
          /* tslint:enable no-unsafe-any */
          .pipe(Object(catchError["a" /* catchError */])(function (error) {
            throw formatError(error, {
              defaultCode: "PIPELINE_PARSE_ERROR",
              defaultReason: "Unknown parsing error"
            });
          }));
        }
      };

      if (isChunked) {
        return Object(of["a" /* of */])(data);
      }

      return Object(concat["a" /* concat */])(Object(of["a" /* of */])(data), Object(of["a" /* of */])({
        type: "chunk-complete"
      }));
    }), Object(share["a" /* share */])() // avoid multiple side effects if multiple subs
    );
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher_creator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var MIN_CANCELABLE_PRIORITY = config["a" /* default */].MIN_CANCELABLE_PRIORITY,
    MAX_HIGH_PRIORITY_LEVEL = config["a" /* default */].MAX_HIGH_PRIORITY_LEVEL;
/**
 * Interact with the transport pipelines to download segments with the right
 * priority.
 *
 * @class SegmentFetcherCreator
 *
 * @example
 * ```js
 * const creator = new SegmentFetcherCreator(transport);
 *
 * // 2 - create a new fetcher with its backoff options
 * const fetcher = creator.createSegmentFetcher("audio", {
 *   maxRetryRegular: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * fetcher.createRequest(myContent, 1)
 *   // 4 - parse it
 *   .pipe(
 *     filter(evt => evt.type === "chunk"),
 *     mergeMap(response => response.parse());
 *   )
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio chunk downloaded:", res));
 * ```
 */

var segment_fetcher_creator_SegmentFetcherCreator = /*#__PURE__*/function () {
  /**
   * @param {Object} transport
   */
  function SegmentFetcherCreator(transport, options) {
    this._transport = transport;
    this._prioritizer = new prioritizer_ObservablePrioritizer({
      prioritySteps: {
        high: MAX_HIGH_PRIORITY_LEVEL,
        low: MIN_CANCELABLE_PRIORITY
      }
    });
    this._backoffOptions = options;
  }
  /**
   * Create a segment fetcher, allowing to easily perform segment requests.
   * @param {string} bufferType - The type of buffer concerned (e.g. "audio",
   * "video", etc.)
   * @param {Subject} requests$ - Subject through which request-related events
   * (such as those needed by the ABRManager) will be sent.
   * @returns {Object}
   */


  var _proto = SegmentFetcherCreator.prototype;

  _proto.createSegmentFetcher = function createSegmentFetcher(bufferType, requests$) {
    var backoffOptions = getSegmentBackoffOptions(bufferType, this._backoffOptions);

    var segmentFetcher = segment_fetcher_createSegmentFetcher(bufferType, this._transport, requests$, backoffOptions);

    return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
  };

  return SegmentFetcherCreator;
}();


// CONCATENATED MODULE: ./src/core/fetchers/segment/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var fetchers_segment = (segment_fetcher_creator_SegmentFetcherCreator);
// EXTERNAL MODULE: ./src/core/init/create_eme_manager.ts
var create_eme_manager = __webpack_require__(134);

// EXTERNAL MODULE: ./src/compat/clear_element_src.ts
var clear_element_src = __webpack_require__(97);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(34);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/core/init/create_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var onSourceOpen$ = compat["a" /* events */].onSourceOpen$;
/**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */

function setDurationToMediaSource(mediaSource, duration) {
  var newDuration = duration === Infinity ? Number.MAX_VALUE : duration;

  if (mediaSource.duration !== newDuration) {
    log["a" /* default */].info("Init: Setting duration", newDuration);
    mediaSource.duration = newDuration;
  }
}
/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */

function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
  if (mediaSource !== null && mediaSource.readyState !== "closed") {
    var readyState = mediaSource.readyState,
        sourceBuffers = mediaSource.sourceBuffers;

    for (var i = sourceBuffers.length - 1; i >= 0; i--) {
      var sourceBuffer = sourceBuffers[i];

      try {
        if (readyState === "open") {
          log["a" /* default */].info("Init: Removing SourceBuffer from mediaSource", sourceBuffer);
          sourceBuffer.abort();
        }

        mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        log["a" /* default */].warn("Init: Error while disposing SourceBuffer", e);
      }
    }

    if (sourceBuffers.length > 0) {
      log["a" /* default */].warn("Init: Not all SourceBuffers could have been removed.");
    }
  }

  Object(clear_element_src["a" /* default */])(mediaElement);

  if (mediaSourceURL !== null) {
    try {
      log["a" /* default */].debug("Init: Revoking previous URL");
      URL.revokeObjectURL(mediaSourceURL);
    } catch (e) {
      log["a" /* default */].warn("Init: Error while revoking the media source URL", e);
    }
  }
}
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource SourceBuffers
 * and custom SourceBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function createMediaSource(mediaElement) {
  return new Observable["a" /* Observable */](function (observer) {
    if (browser_compatibility_types["c" /* MediaSource_ */] == null) {
      throw new media_error["a" /* default */]("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
    } // make sure the media has been correctly reset


    var oldSrc = Object(is_non_empty_string["a" /* default */])(mediaElement.src) ? mediaElement.src : null;
    resetMediaSource(mediaElement, null, oldSrc);
    log["a" /* default */].info("Init: Creating MediaSource");
    var mediaSource = new browser_compatibility_types["c" /* MediaSource_ */]();
    var objectURL = URL.createObjectURL(mediaSource);
    log["a" /* default */].info("Init: Attaching MediaSource URL to the media element", objectURL);
    mediaElement.src = objectURL;
    observer.next(mediaSource);
    return function () {
      resetMediaSource(mediaElement, mediaSource, objectURL);
    };
  });
}
/**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function openMediaSource(mediaElement) {
  return createMediaSource(mediaElement).pipe(Object(mergeMap["a" /* mergeMap */])(function (mediaSource) {
    return onSourceOpen$(mediaSource).pipe(Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(mediaSource));
  }));
}
// EXTERNAL MODULE: ./src/core/init/events_generators.ts
var events_generators = __webpack_require__(33);

// CONCATENATED MODULE: ./src/core/init/get_initial_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var DEFAULT_LIVE_GAP = config["a" /* default */].DEFAULT_LIVE_GAP;
/**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest information
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {boolean} lowLatencyMode
 * @param {Object} startAt
 * @returns {Number}
 */

function getInitialTime(manifest, lowLatencyMode, startAt) {
  log["a" /* default */].debug("Init: calculating initial time");

  if (startAt != null) {
    var min = manifest.getMinimumPosition();
    var max = manifest.getMaximumPosition();

    if (startAt.position != null) {
      log["a" /* default */].debug("Init: using startAt.minimumPosition");
      return Math.max(Math.min(startAt.position, max), min);
    } else if (startAt.wallClockTime != null) {
      log["a" /* default */].debug("Init: using startAt.wallClockTime");
      var ast = manifest.availabilityStartTime == null ? 0 : manifest.availabilityStartTime;
      var position = startAt.wallClockTime - ast;
      return Math.max(Math.min(position, max), min);
    } else if (startAt.fromFirstPosition != null) {
      log["a" /* default */].debug("Init: using startAt.fromFirstPosition");
      var fromFirstPosition = startAt.fromFirstPosition;
      return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);
    } else if (startAt.fromLastPosition != null) {
      log["a" /* default */].debug("Init: using startAt.fromLastPosition");
      var fromLastPosition = startAt.fromLastPosition;
      return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
    } else if (startAt.percentage != null) {
      log["a" /* default */].debug("Init: using startAt.percentage");
      var percentage = startAt.percentage;

      if (percentage > 100) {
        return max;
      } else if (percentage < 0) {
        return min;
      }

      var ratio = +percentage / 100;
      var extent = max - min;
      return min + extent * ratio;
    }
  }

  var minimumPosition = manifest.getMinimumPosition();

  if (manifest.isLive) {
    var suggestedPresentationDelay = manifest.suggestedPresentationDelay,
        clockOffset = manifest.clockOffset;
    var maximumPosition = manifest.getMaximumPosition();
    var liveTime;

    if (clockOffset == null) {
      log["a" /* default */].info("Init: no clock offset found for a live content, " + "starting close to maximum available position");
      liveTime = maximumPosition;
    } else {
      log["a" /* default */].info("Init: clock offset found for a live content, " + "checking if we can start close to it");

      var _ast = manifest.availabilityStartTime == null ? 0 : manifest.availabilityStartTime;

      var clockRelativeLiveTime = (performance.now() + clockOffset) / 1000 - _ast;

      liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
    }

    log["a" /* default */].debug("Init: " + liveTime + " defined as the live time, applying a live gap" + (" of " + suggestedPresentationDelay));

    if (suggestedPresentationDelay !== undefined) {
      return Math.max(liveTime - suggestedPresentationDelay, minimumPosition);
    }

    var defaultStartingPos = liveTime - (lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT);
    return Math.max(defaultStartingPos, minimumPosition);
  }

  log["a" /* default */].info("Init: starting at the minimum available position:", minimumPosition);
  return minimumPosition;
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var observable_interval = __webpack_require__(227);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(226);

// EXTERNAL MODULE: ./src/compat/change_source_buffer_type.ts
var change_source_buffer_type = __webpack_require__(173);

// EXTERNAL MODULE: ./src/manifest/are_same_content.ts
var are_same_content = __webpack_require__(172);

// CONCATENATED MODULE: ./src/core/source_buffers/segment_inventory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = config["a" /* default */].MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE = config["a" /* default */].MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE,
    MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * Keep track of every chunk downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which chunks are already pushed to
 * the SourceBuffer, at which bitrate, and which have been garbage-collected
 * since by the browser (and thus may need to be re-loaded).
 * @class SegmentInventory
 */

var segment_inventory_SegmentInventory = /*#__PURE__*/function () {
  function SegmentInventory() {
    this.inventory = [];
  }
  /**
   * Reset the whole inventory.
   */


  var _proto = SegmentInventory.prototype;

  _proto.reset = function reset() {
    this.inventory.length = 0;
  }
  /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given.
   *
   * The TimeRanges object given should come from the SourceBuffer linked to
   * that SegmentInventory.
   *
   * /!\ A SegmentInventory should not be associated to multiple SourceBuffers
   * at a time, so each `synchronizeBuffered` call should be given a TimeRanges
   * coming from the same SourceBuffer instance.
   * @param {TimeRanges}
   */
  ;

  _proto.synchronizeBuffered = function synchronizeBuffered(buffered) {
    var inventory = this.inventory;
    var inventoryIndex = 0; // Current index considered.

    var thisSegment = inventory[0]; // Current segmentInfos considered

    /** Type of buffer considered, used for logs */

    var bufferType = thisSegment === null || thisSegment === void 0 ? void 0 : thisSegment.infos.adaptation.type;
    var rangesLength = buffered.length;

    for (var i = 0; i < rangesLength; i++) {
      if (thisSegment === undefined) {
        // we arrived at the end of our inventory
        return;
      } // take the i'nth contiguous buffered TimeRange


      var rangeStart = buffered.start(i);
      var rangeEnd = buffered.end(i);

      if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
        log["a" /* default */].warn("SI: skipped TimeRange when synchronizing because it was too small", bufferType, rangeStart, rangeEnd);
        continue;
      }

      var indexBefore = inventoryIndex; // keep track of that number
      // Find the first segment either within this TimeRange or completely past
      // it:
      // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the
      // start of that range.

      while (thisSegment !== undefined && Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {
        thisSegment = inventory[++inventoryIndex];
      } // Contains infos about the last garbage-collected segment before
      // `thisSegment`.


      var lastDeletedSegmentInfos = {
        end: -1,
        precizeEnd: false
      }; // remove garbage-collected segments
      // (not in that TimeRange nor in the previous one)

      var numberOfSegmentToDelete = inventoryIndex - indexBefore;

      if (numberOfSegmentToDelete > 0) {
        var lastDeletedSegment = // last garbage-collected segment
        inventory[indexBefore + numberOfSegmentToDelete - 1];
        lastDeletedSegmentInfos.end = Object(take_first_set["a" /* default */])(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);
        lastDeletedSegmentInfos.precizeEnd = lastDeletedSegment.precizeEnd;
        log["a" /* default */].debug("SI: " + numberOfSegmentToDelete + " segments GCed.", bufferType);
        inventory.splice(indexBefore, numberOfSegmentToDelete);
        inventoryIndex = indexBefore;
      }

      if (thisSegment === undefined) {
        return;
      } // If the current segment is actually completely outside that range (it
      // is contained in one of the next one), skip that part.


      if (rangeEnd - Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
        guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos, bufferType);

        if (inventoryIndex === inventory.length - 1) {
          guessBufferedEndFromRangeEnd(thisSegment, rangeEnd, bufferType);
          return;
        }

        thisSegment = inventory[++inventoryIndex]; // Make contiguous until first segment outside that range

        var thisSegmentStart = Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start);
        var thisSegmentEnd = Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end);
        var nextRangeStart = i < rangesLength - 1 ? buffered.start(i + 1) : undefined;

        while (thisSegment !== undefined && rangeEnd - thisSegmentStart >= MINIMUM_SEGMENT_SIZE && (nextRangeStart === undefined || rangeEnd - thisSegmentStart >= thisSegmentEnd - nextRangeStart)) {
          var prevSegment = inventory[inventoryIndex - 1]; // those segments are contiguous, we have no way to infer their real
          // end

          if (prevSegment.bufferedEnd === undefined) {
            prevSegment.bufferedEnd = thisSegment.precizeStart ? thisSegment.start : prevSegment.end;
            log["a" /* default */].debug("SI: calculating buffered end of contiguous segment", bufferType, prevSegment.bufferedEnd, prevSegment.end);
          }

          thisSegment.bufferedStart = prevSegment.bufferedEnd;
          thisSegment = inventory[++inventoryIndex];

          if (thisSegment !== undefined) {
            thisSegmentStart = Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start);
            thisSegmentEnd = Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end);
          }
        }
      } // update the bufferedEnd of the last segment in that range


      var lastSegmentInRange = inventory[inventoryIndex - 1];

      if (lastSegmentInRange !== undefined) {
        guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType);
      }
    } // if we still have segments left, they are not affiliated to any range.
    // They might have been garbage collected, delete them from here.


    if (thisSegment != null) {
      log["a" /* default */].debug("SI: last segments have been GCed", bufferType, inventoryIndex, inventory.length);
      inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
    }

    if (bufferType !== undefined && log["a" /* default */].getLevel() === "DEBUG") {
      log["a" /* default */].debug("SI: current " + bufferType + " inventory timeline:\n" + prettyPrintInventory(this.inventory));
    }
  }
  /**
   * Add a new chunk in the inventory.
   *
   * Chunks are decodable sub-parts of a whole segment. Once all chunks in a
   * segment have been inserted, you should call the `completeSegment` method.
   * @param {Object} chunkInformation
   */
  ;

  _proto.insertChunk = function insertChunk(_ref) {
    var period = _ref.period,
        adaptation = _ref.adaptation,
        representation = _ref.representation,
        segment = _ref.segment,
        start = _ref.start,
        end = _ref.end;

    if (segment.isInit) {
      return;
    }

    var bufferType = adaptation.type;

    if (start >= end) {
      log["a" /* default */].warn("SI: Invalid chunked inserted: starts before it ends", bufferType, start, end);
      return;
    }

    var inventory = this.inventory;
    var newSegment = {
      partiallyPushed: true,
      estimatedStart: start,
      start: start,
      end: end,
      precizeStart: false,
      precizeEnd: false,
      bufferedStart: undefined,
      bufferedEnd: undefined,
      infos: {
        segment: segment,
        period: period,
        adaptation: adaptation,
        representation: representation
      }
    }; // begin by the end as in most use cases this will be faster

    for (var i = inventory.length - 1; i >= 0; i--) {
      var segmentI = inventory[i];

      if (segmentI.start <= start) {
        if (segmentI.end <= start) {
          // our segment is after, push it after this one
          //
          // Case 1:
          //   prevSegment  : |------|
          //   newSegment   :        |======|
          //   ===>         : |------|======|
          //
          // Case 2:
          //   prevSegment  : |------|
          //   newSegment   :          |======|
          //   ===>         : |------| |======|
          log["a" /* default */].debug("SI: Pushing segment strictly after previous one.", bufferType, start, segmentI.end);
          this.inventory.splice(i + 1, 0, newSegment);
          i += 2; // Go to segment immediately after newSegment

          while (i < inventory.length && inventory[i].start < newSegment.end) {
            if (inventory[i].end > newSegment.end) {
              // The next segment ends after newSegment.
              // Mutate the next segment.
              //
              // Case 1:
              //   prevSegment  : |------|
              //   newSegment   :        |======|
              //   nextSegment  :            |----|
              //   ===>         : |------|======|-|
              log["a" /* default */].debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
              inventory[i].start = newSegment.end;
              inventory[i].bufferedStart = undefined;
              inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
              return;
            } // The next segment was completely contained in newSegment.
            // Remove it.
            //
            // Case 1:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |---|
            //   ===>         : |------|======|
            //
            // Case 2:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |----|
            //   ===>         : |------|======|


            log["a" /* default */].debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
            inventory.splice(i, 1);
          }

          return;
        } else {
          if (segmentI.start === start) {
            if (segmentI.end <= end) {
              // In those cases, replace
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   : |=======|
              //  ===>         : |=======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   : |==========|
              //  ===>         : |==========|
              log["a" /* default */].debug("SI: Segment pushed replace another one", bufferType, start, end, segmentI.end);
              this.inventory.splice(i, 1, newSegment);
              i += 1; // Go to segment immediately after newSegment

              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log["a" /* default */].debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                } // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|


                log["a" /* default */].debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                inventory.splice(i, 1);
              }

              return;
            } else {
              // The previous segment starts at the same time and finishes
              // after the new segment.
              // Update the start of the previous segment and put the new
              // segment before.
              //
              // Case 1:
              //  prevSegment  : |------------|
              //  newSegment   : |==========|
              //  ===>         : |==========|-|
              log["a" /* default */].debug("SI: Segment pushed ends before another with the same start", bufferType, start, end, segmentI.end);
              inventory.splice(i, 0, newSegment);
              segmentI.start = newSegment.end;
              segmentI.bufferedStart = undefined;
              segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd;
              return;
            }
          } else {
            if (segmentI.end <= newSegment.end) {
              // our segment has a "complex" relation with this one,
              // update the old one end and add this one after it.
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   :    |======|
              //  ===>         : |--|======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|
              log["a" /* default */].debug("SI: Segment pushed updates end of previous one", bufferType, start, end, segmentI.start, segmentI.end);
              this.inventory.splice(i + 1, 0, newSegment);
              segmentI.end = newSegment.start;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              i += 2; // Go to segment immediately after newSegment

              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log["a" /* default */].debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                } // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|


                log["a" /* default */].debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                inventory.splice(i, 1);
              }

              return;
            } else {
              // The previous segment completely recovers the new segment.
              // Split the previous segment into two segments, before and after
              // the new segment.
              //
              // Case 1:
              //  prevSegment  : |---------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|-|
              log["a" /* default */].debug("SI: Segment pushed is contained in a previous one", bufferType, start, end, segmentI.start, segmentI.end);
              var nextSegment = {
                partiallyPushed: segmentI.partiallyPushed,
                start: newSegment.end,
                end: segmentI.end,
                precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,
                precizeEnd: segmentI.precizeEnd,
                bufferedStart: undefined,
                bufferedEnd: segmentI.end,
                infos: segmentI.infos
              };
              segmentI.end = newSegment.start;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              inventory.splice(i + 1, 0, newSegment);
              inventory.splice(i + 2, 0, nextSegment);
              return;
            }
          }
        }
      }
    } // if we got here, we are at the first segment
    // check bounds of the previous first segment


    var firstSegment = this.inventory[0];

    if (firstSegment === undefined) {
      // we do not have any segment yet
      log["a" /* default */].debug("SI: first segment pushed", bufferType, start, end);
      this.inventory.push(newSegment);
      return;
    }

    if (firstSegment.start >= end) {
      // our segment is before, put it before
      //
      // Case 1:
      //  firstSegment :      |----|
      //  newSegment   : |====|
      //  ===>         : |====|----|
      //
      // Case 2:
      //  firstSegment :        |----|
      //  newSegment   : |====|
      //  ===>         : |====| |----|
      log["a" /* default */].debug("SI: Segment pushed comes before all previous ones", bufferType, start, end, firstSegment.start);
      this.inventory.splice(0, 0, newSegment);
    } else if (firstSegment.end <= end) {
      // Our segment is bigger, replace the first
      //
      // Case 1:
      //  firstSegment :   |---|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      //
      // Case 2:
      //  firstSegment :   |-----|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      log["a" /* default */].debug("SI: Segment pushed starts before and completely " + "recovers the previous first one", bufferType, start, end, firstSegment.start, firstSegment.end);
      this.inventory.splice(0, 1, newSegment);

      while (inventory.length > 1 && inventory[1].start < newSegment.end) {
        if (inventory[1].end > newSegment.end) {
          // The next segment ends after newSegment.
          // Mutate the next segment.
          //
          // Case 1:
          //   newSegment   : |======|
          //   nextSegment  :      |----|
          //   ===>         : |======|--|
          log["a" /* default */].debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[1].start);
          inventory[1].start = newSegment.end;
          inventory[1].bufferedStart = undefined;
          inventory[1].precizeStart = newSegment.precizeEnd;
          return;
        } // The next segment was completely contained in newSegment.
        // Remove it.
        //
        // Case 1:
        //   newSegment   : |======|
        //   nextSegment  :   |---|
        //   ===>         : |======|
        //
        // Case 2:
        //   newSegment   : |======|
        //   nextSegment  :   |----|
        //   ===>         : |======|


        log["a" /* default */].debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[1].start, inventory[1].end);
        inventory.splice(1, 1);
      }

      return;
    } else {
      // our segment has a "complex" relation with the first one,
      // update the old one start and add this one before it.
      //
      // Case 1:
      //  firstSegment :    |------|
      //  newSegment   : |======|
      //  ===>         : |======|--|
      log["a" /* default */].debug("SI: Segment pushed start of the next one", bufferType, start, end, firstSegment.start, firstSegment.end);
      firstSegment.start = end;
      firstSegment.bufferedStart = undefined;
      firstSegment.precizeStart = newSegment.precizeEnd;
      this.inventory.splice(0, 0, newSegment);
      return;
    }
  }
  /**
   * Indicate that inserted chunks can now be considered as a complete segment.
   * Take in argument the same content than what was given to `insertChunk` for
   * the corresponding chunks.
   * @param {Object} content
   */
  ;

  _proto.completeSegment = function completeSegment(content) {
    if (content.segment.isInit) {
      return;
    }

    var inventory = this.inventory;
    var foundIt = false;

    for (var i = 0; i < inventory.length; i++) {
      if (Object(are_same_content["a" /* default */])(inventory[i].infos, content)) {
        if (foundIt) {
          log["a" /* default */].warn("SI: Completed Segment is splitted.", content);
        }

        foundIt = true;
        var firstI = i;
        i += 1;

        while (i < inventory.length && Object(are_same_content["a" /* default */])(inventory[i].infos, content)) {
          i++;
        }

        var lastI = i - 1;
        var length = lastI - firstI;
        var lastEnd = inventory[lastI].end;
        var lastBufferedEnd = inventory[lastI].bufferedEnd;

        if (length > 0) {
          this.inventory.splice(firstI + 1, length);
          i -= length;
        }

        this.inventory[firstI].partiallyPushed = false;
        this.inventory[firstI].end = lastEnd;
        this.inventory[firstI].bufferedEnd = lastBufferedEnd;
      }
    }

    if (!foundIt) {
      log["a" /* default */].warn("SI: Completed Segment not found", content);
    }
  }
  /**
   * Returns the whole inventory.
   *
   * To get a list synchronized with what a SourceBuffer actually has buffered
   * you might want to call `synchronizeBuffered` before calling this method.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getInventory = function getInventory() {
    return this.inventory;
  };

  return SegmentInventory;
}();
/**
 * Returns `true` if the buffered start of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */




function bufferedStartLooksCoherent(thisSegment) {
  if (thisSegment.bufferedStart === undefined || thisSegment.partiallyPushed) {
    return false;
  }

  var start = thisSegment.start,
      end = thisSegment.end;
  var duration = end - start;
  return Math.abs(start - thisSegment.bufferedStart) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && (thisSegment.bufferedEnd === undefined || thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
}
/**
 * Returns `true` if the buffered end of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */


function bufferedEndLooksCoherent(thisSegment) {
  if (thisSegment.bufferedEnd === undefined || thisSegment.partiallyPushed) {
    return false;
  }

  var start = thisSegment.start,
      end = thisSegment.end;
  var duration = end - start;
  return Math.abs(end - thisSegment.bufferedEnd) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && thisSegment.bufferedStart != null && thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
}
/**
 * Evaluate the given buffered Chunk's buffered start from its range's start,
 * considering that this chunk is the first one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} lastDeletedSegmentInfos
 */


function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos, bufferType) {
  if (firstSegmentInRange.bufferedStart !== undefined) {
    if (firstSegmentInRange.bufferedStart < rangeStart) {
      log["a" /* default */].debug("SI: Segment partially GCed at the start", bufferType, firstSegmentInRange.bufferedStart, rangeStart);
      firstSegmentInRange.bufferedStart = rangeStart;
    }

    if (!firstSegmentInRange.precizeStart && bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = firstSegmentInRange.bufferedStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.precizeStart) {
    log["a" /* default */].debug("SI: buffered start is precize start", bufferType, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
  } else if (lastDeletedSegmentInfos.end >= 0 && lastDeletedSegmentInfos.end > rangeStart && (lastDeletedSegmentInfos.precizeEnd || firstSegmentInRange.start - lastDeletedSegmentInfos.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {
    log["a" /* default */].debug("SI: buffered start is end of previous segment", bufferType, rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end);
    firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;

    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = lastDeletedSegmentInfos.end;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.start - rangeStart <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
    log["a" /* default */].debug("SI: found true buffered start", bufferType, rangeStart, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = rangeStart;

    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = rangeStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (rangeStart < firstSegmentInRange.start) {
    log["a" /* default */].debug("SI: range start too far from expected start", bufferType, rangeStart, firstSegmentInRange.start);
  } else {
    log["a" /* default */].debug("SI: Segment appears immediately garbage collected at the start", bufferType, firstSegmentInRange.bufferedStart, rangeStart);
    firstSegmentInRange.bufferedStart = rangeStart;
  }
}
/**
 * Evaluate the given buffered Chunk's buffered end from its range's end,
 * considering that this chunk is the last one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} infos
 */


function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType) {
  if (lastSegmentInRange.bufferedEnd !== undefined) {
    if (lastSegmentInRange.bufferedEnd > rangeEnd) {
      log["a" /* default */].debug("SI: Segment partially GCed at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
      lastSegmentInRange.bufferedEnd = rangeEnd;
    }

    if (!lastSegmentInRange.precizeEnd && bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.precizeEnd = true;
      lastSegmentInRange.end = rangeEnd;
    }
  } else if (lastSegmentInRange.precizeEnd) {
    log["a" /* default */].debug("SI: buffered end is precize end", bufferType, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
  } else if (rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
    log["a" /* default */].debug("SI: found true buffered end", bufferType, rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = rangeEnd;

    if (bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.end = rangeEnd;
      lastSegmentInRange.precizeEnd = true;
    }
  } else if (rangeEnd > lastSegmentInRange.end) {
    log["a" /* default */].debug("SI: range end too far from expected end", bufferType, rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;

    if (bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.end = rangeEnd;
      lastSegmentInRange.precizeEnd = true;
    }
  } else {
    log["a" /* default */].debug("SI: Segment appears immediately garbage collected at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
    lastSegmentInRange.bufferedEnd = rangeEnd;
  }
}
/**
 * Pretty print the inventory, to easily note which segments are where in the
 * current buffer.
 *
 * This is mostly useful when logging.
 *
 * @example
 * This function is called by giving it the inventory, such as:
 * ```js
 * prettyPrintInventory(inventory);
 * ```
 *
 * Let's consider this possible return:
 * ```
 * 0.00|A|9.00 ~ 9.00|B|45.08 ~ 282.08|B|318.08
 * [A] P: gen-dash-period-0 || R: video/5(2362822)
 * [B] P: gen-dash-period-0 || R: video/6(2470094)
 * ```
 * We have a first part, from 0 to 9 seconds, which contains segments for
 * the Representation with the id "video/5" and an associated bitrate of
 * 2362822 bits per seconds (in the Period with the id "gen-dash-period-0").
 *
 * Then from 9.00 seconds to 45.08 seconds, we have segments from another
 * Representation from the same Period (with the id "video/6" and a bitrate
 * of 2470094 bits per seconds).
 *
 * At last we have a long time between 45.08 and 282.08 with no segment followed
 * by a segment from that same Representation between 282.08 seconds and 318.08
 * seconds.
 * @param {Array.<Object>} inventory
 * @returns {string}
 */


function prettyPrintInventory(inventory) {
  var roundingError = 1 / 60;
  var encounteredReps = {};
  var letters = [];
  var lastChunk = null;
  var lastLetter = null;

  function generateNewLetter(infos) {
    var currentLetter = String.fromCharCode(letters.length + 65);
    letters.push({
      letter: currentLetter,
      periodId: infos.period.id,
      representationId: infos.representation.id,
      bitrate: infos.representation.bitrate
    });
    return currentLetter;
  }

  var str = "";

  for (var i = 0; i < inventory.length; i++) {
    var chunk = inventory[i];

    if (chunk.bufferedStart !== undefined && chunk.bufferedEnd !== undefined) {
      var periodId = chunk.infos.period.id;
      var representationId = chunk.infos.representation.id;
      var encounteredPeriod = encounteredReps[periodId];
      var currentLetter = void 0;

      if (encounteredPeriod === undefined) {
        var _encounteredReps$peri;

        currentLetter = generateNewLetter(chunk.infos);
        encounteredReps[periodId] = (_encounteredReps$peri = {}, _encounteredReps$peri[representationId] = currentLetter, _encounteredReps$peri);
      } else if (encounteredPeriod[representationId] === undefined) {
        currentLetter = generateNewLetter(chunk.infos);
        encounteredPeriod[representationId] = currentLetter;
      } else {
        currentLetter = encounteredPeriod[representationId];
      }

      if (lastChunk === null) {
        str += chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|";
      } else if (lastLetter === currentLetter) {
        if (lastChunk.bufferedEnd + roundingError < chunk.bufferedStart) {
          str += lastChunk.bufferedEnd.toFixed(2) + " ~ " + (chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|");
        }
      } else {
        str += lastChunk.bufferedEnd.toFixed(2) + " ~ " + (chunk.bufferedStart.toFixed(2) + "|" + currentLetter + "|");
      }

      lastChunk = chunk;
      lastLetter = currentLetter;
    }
  }

  if (lastChunk !== null) {
    str += String(lastChunk.end.toFixed(2));
  }

  letters.forEach(function (letterInfo) {
    str += "\n[" + letterInfo.letter + "] " + ("P: " + letterInfo.periodId + " || R: " + letterInfo.representationId) + ("(" + letterInfo.bitrate + ")");
  });
  return str;
}
// CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var APPEND_WINDOW_SECURITIES = config["a" /* default */].APPEND_WINDOW_SECURITIES,
    SOURCE_BUFFER_FLUSHING_INTERVAL = config["a" /* default */].SOURCE_BUFFER_FLUSHING_INTERVAL;
/**
 * Enum used by the QueuedSourceBuffer as a discriminant in its queue of
 * "operations".
 */

var SourceBufferOperation;

(function (SourceBufferOperation) {
  SourceBufferOperation[SourceBufferOperation["Push"] = 0] = "Push";
  SourceBufferOperation[SourceBufferOperation["Remove"] = 1] = "Remove";
  SourceBufferOperation[SourceBufferOperation["EndOfSegment"] = 2] = "EndOfSegment";
})(SourceBufferOperation || (SourceBufferOperation = {}));
/**
 * Allows to push and remove new Segments to a SourceBuffer in a FIFO queue (not
 * doing so can lead to browser Errors) while keeping an inventory of what has
 * been pushed and what is being pushed.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */


var queued_source_buffer_QueuedSourceBuffer = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} bufferType
   * @param {string} codec
   * @param {SourceBuffer} sourceBuffer
   */
  function QueuedSourceBuffer(bufferType, codec, sourceBuffer) {
    var _this = this;

    this._destroy$ = new Subject["a" /* Subject */]();
    this.bufferType = bufferType;
    this._sourceBuffer = sourceBuffer;
    this._queue = [];
    this._pendingTask = null;
    this._lastInitSegment = null;
    this._currentCodec = codec;
    this._segmentInventory = new segment_inventory_SegmentInventory(); // Some browsers (happened with firefox 66) sometimes "forget" to send us
    // `update` or `updateend` events.
    // In that case, we're completely unable to continue the queue here and
    // stay locked in a waiting state.
    // This interval is here to check at regular intervals if the underlying
    // SourceBuffer is currently updating.

    Object(observable_interval["a" /* interval */])(SOURCE_BUFFER_FLUSHING_INTERVAL).pipe(Object(tap["a" /* tap */])(function () {
      return _this._flush();
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
    Object(fromEvent["a" /* fromEvent */])(this._sourceBuffer, "error").pipe(Object(tap["a" /* tap */])(function (err) {
      return _this._onError(err);
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
    Object(fromEvent["a" /* fromEvent */])(this._sourceBuffer, "updateend").pipe(Object(tap["a" /* tap */])(function () {
      return _this._flush();
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
  }
  /**
   * Public access to the SourceBuffer's current codec.
   * @returns {string}
   */


  var _proto = QueuedSourceBuffer.prototype;

  /**
   * Push a chunk of the media segment given to the attached SourceBuffer, in a
   * FIFO queue.
   *
   * Once all chunks of a single Segment have been given to `pushChunk`, you
   * should call `endOfSegment` to indicate that the whole Segment has been
   * pushed.
   *
   * Depending on the type of data appended, the pushed chunk might rely on an
   * initialization segment, given through the `data.initSegment` property.
   *
   * Such initialization segment will be first pushed to the SourceBuffer if the
   * last pushed segment was associated to another initialization segment.
   * This detection is entirely reference-based so make sure that the same
   * `data.initSegment` argument given share the same reference (in the opposite
   * case, we would just unnecessarily push again the same initialization
   * segment).
   *
   * If you don't need any initialization segment to push the wanted chunk, you
   * can just set `data.initSegment` to `null`.
   *
   * You can also only push an initialization segment by setting the
   * `data.chunk` argument to null.
   *
   * @param {Object} infos
   * @returns {Observable}
   */
  _proto.pushChunk = function pushChunk(infos) {
    log["a" /* default */].debug("QSB: receiving order to push data to the SourceBuffer", this.bufferType, infos);
    return this._addToQueue({
      type: SourceBufferOperation.Push,
      value: infos
    });
  }
  /**
   * Remove buffered data (added to the same FIFO queue than `pushChunk`).
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Observable}
   */
  ;

  _proto.removeBuffer = function removeBuffer(start, end) {
    log["a" /* default */].debug("QSB: receiving order to remove data from the SourceBuffer", this.bufferType, start, end);
    return this._addToQueue({
      type: SourceBufferOperation.Remove,
      value: {
        start: start,
        end: end
      }
    });
  }
  /**
   * Indicate that every chunks from a Segment has been given to pushChunk so
   * far.
   * This will update our internal Segment inventory accordingly.
   * The returned Observable will emit and complete successively once the whole
   * segment has been pushed and this indication is acknowledged.
   * @param {Object} infos
   * @returns {Observable}
   */
  ;

  _proto.endOfSegment = function endOfSegment(infos) {
    log["a" /* default */].debug("QSB: receiving order for validating end of segment", this.bufferType, infos.segment);
    return this._addToQueue({
      type: SourceBufferOperation.EndOfSegment,
      value: infos
    });
  }
  /**
   * The maintained inventory can fall out of sync from garbage collection or
   * other events.
   *
   * This methods allow to manually trigger a synchronization. It should be
   * called before retrieving Segment information from it (e.g. with
   * `getInventory`).
   */
  ;

  _proto.synchronizeInventory = function synchronizeInventory() {
    this._segmentInventory.synchronizeBuffered(this.getBufferedRanges());
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */
  ;

  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._sourceBuffer.buffered;
  }
  /**
   * Returns the currently buffered data for which the content is known with
   * the corresponding content information.
   * /!\ This data can fall out of sync with the real buffered ranges. Please
   * call `synchronizeInventory` before to make sure it is correctly
   * synchronized.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getInventory = function getInventory() {
    return this._segmentInventory.getInventory();
  }
  /**
   * Returns the list of every operations that the `QueuedSourceBuffer` is still
   * processing. From the one with the highest priority (like the one being
   * processed)
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPendingOperations = function getPendingOperations() {
    var parseQueuedOperation = function parseQueuedOperation(op) {
      // Had to be written that way for TypeScrypt
      switch (op.type) {
        case SourceBufferOperation.Push:
          return {
            type: op.type,
            value: op.value
          };

        case SourceBufferOperation.Remove:
          return {
            type: op.type,
            value: op.value
          };

        case SourceBufferOperation.EndOfSegment:
          return {
            type: op.type,
            value: op.value
          };
      }
    };

    var queued = this._queue.map(parseQueuedOperation);

    return this._pendingTask === null ? queued : [parseQueuedOperation(this._pendingTask)].concat(queued);
  }
  /**
   * Dispose of the resources used by this QueuedSourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
  ;

  _proto.dispose = function dispose() {
    this._destroy$.next();

    this._destroy$.complete();

    if (this._pendingTask !== null) {
      this._pendingTask.subject.complete();

      this._pendingTask = null;
    }

    while (this._queue.length > 0) {
      var nextElement = this._queue.shift();

      if (nextElement !== undefined) {
        nextElement.subject.complete();
      }
    }
  }
  /**
   * Abort the linked SourceBuffer.
   * You should call this only if the linked MediaSource is still "open".
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
  ;

  _proto.abort = function abort() {
    this._sourceBuffer.abort();
  }
  /**
   * @private
   * @param {Event} error
   */
  ;

  _proto._onError = function _onError(err) {
    var error = err instanceof Error ? err : new Error("An unknown error occured when appending buffer");
    this._lastInitSegment = null; // initialize init segment as a security

    if (this._pendingTask !== null) {
      this._pendingTask.subject.error(error);
    }
  }
  /**
   * When the returned observable is subscribed:
   *   1. Add your operation to the queue.
   *   2. Begin the queue if not pending.
   *
   * Cancel queued operation on unsubscription.
   * @private
   * @param {Object} operation
   * @returns {Observable}
   */
  ;

  _proto._addToQueue = function _addToQueue(operation) {
    var _this2 = this;

    return new Observable["a" /* Observable */](function (obs) {
      var shouldRestartQueue = _this2._queue.length === 0 && _this2._pendingTask === null;
      var subject = new Subject["a" /* Subject */]();
      var queueItem = Object(object_assign["a" /* default */])({
        subject: subject
      }, operation);

      _this2._queue.push(queueItem);

      var subscription = subject.subscribe(obs);

      if (shouldRestartQueue) {
        _this2._flush();
      }

      return function () {
        subscription.unsubscribe(); // Remove the corresponding element from the QueuedSourceBuffer's queue.
        // If the operation was a pending task, it should still continue to not
        // let the QueuedSourceBuffer in a weird state.

        var index = _this2._queue.indexOf(queueItem);

        if (index >= 0) {
          _this2._queue.splice(index, 1);
        }
      };
    });
  }
  /**
   * Perform next task if one.
   * @private
   */
  ;

  _proto._flush = function _flush() {
    if (this._sourceBuffer.updating) {
      return; // still processing `this._pendingTask`
    } // handle end of previous task if needed


    if (this._pendingTask !== null) {
      if (this._pendingTask.type !== SourceBufferOperation.Push || this._pendingTask.steps.length === 0) {
        switch (this._pendingTask.type) {
          case SourceBufferOperation.Push:
            this._segmentInventory.insertChunk(this._pendingTask.inventoryData);

            break;

          case SourceBufferOperation.EndOfSegment:
            this._segmentInventory.completeSegment(this._pendingTask.value);

            break;

          case SourceBufferOperation.Remove:
            this.synchronizeInventory();
            break;

          default:
            Object(assert_unreachable["a" /* default */])(this._pendingTask);
        }

        var subject = this._pendingTask.subject;
        this._pendingTask = null;
        subject.next();
        subject.complete();

        if (this._queue.length > 0) {
          this._flush();
        }

        return;
      }
    } else if (this._queue.length === 0) {
      return; // we have nothing left to do
    } else {
      var newQueueItem = this._queue.shift();

      if (newQueueItem === undefined) {
        // TODO TypeScrypt do not get the previous length check. Find solution /
        // open issue
        throw new Error("An item from the QueuedSourceBuffer queue was not defined");
      }

      this._pendingTask = convertQueueItemToTask(newQueueItem);

      if (this._pendingTask === null) {
        // nothing to do, complete and go to next item
        newQueueItem.subject.next();
        newQueueItem.subject.complete();

        this._flush();

        return;
      }
    } // now handle current task


    var task = this._pendingTask;

    try {
      switch (task.type) {
        case SourceBufferOperation.EndOfSegment:
          // nothing to do, we will just acknowledge the segment.
          log["a" /* default */].debug("QSB: Acknowledging complete segment", task.value);

          this._flush();

          return;

        case SourceBufferOperation.Push:
          var nextStep = task.steps.shift();

          if (nextStep === undefined || nextStep.isInit && this._lastInitSegment === nextStep.segmentData) {
            this._flush();

            return;
          }

          this._pushSegmentData(nextStep);

          break;

        case SourceBufferOperation.Remove:
          var _task$value = task.value,
              start = _task$value.start,
              end = _task$value.end;
          log["a" /* default */].debug("QSB: removing data from SourceBuffer", this.bufferType, start, end);

          this._sourceBuffer.remove(start, end);

          break;

        default:
          Object(assert_unreachable["a" /* default */])(task);
      }
    } catch (e) {
      this._onError(e);
    }
  }
  /**
   * Push given data to the underlying SourceBuffer.
   * /!\ Heavily mutates the private state.
   * @param {Object} task
   */
  ;

  _proto._pushSegmentData = function _pushSegmentData(data) {
    var isInit = data.isInit,
        segmentData = data.segmentData,
        timestampOffset = data.timestampOffset,
        appendWindow = data.appendWindow,
        codec = data.codec;

    if (this._currentCodec !== codec) {
      log["a" /* default */].debug("QSB: updating codec");
      var couldUpdateType = Object(change_source_buffer_type["a" /* default */])(this._sourceBuffer, codec);

      if (couldUpdateType) {
        this._currentCodec = codec;
      } else {
        log["a" /* default */].warn("QSB: could not update codec", codec, this._currentCodec);
      }
    }

    if (this._sourceBuffer.timestampOffset !== timestampOffset) {
      var newTimestampOffset = timestampOffset;
      log["a" /* default */].debug("QSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset);
      this._sourceBuffer.timestampOffset = newTimestampOffset;
    }

    if (appendWindow[0] === undefined) {
      if (this._sourceBuffer.appendWindowStart > 0) {
        this._sourceBuffer.appendWindowStart = 0;
      }
    } else if (appendWindow[0] !== this._sourceBuffer.appendWindowStart) {
      if (appendWindow[0] >= this._sourceBuffer.appendWindowEnd) {
        this._sourceBuffer.appendWindowEnd = appendWindow[0] + 1;
      }

      this._sourceBuffer.appendWindowStart = appendWindow[0];
    }

    if (appendWindow[1] === undefined) {
      if (this._sourceBuffer.appendWindowEnd !== Infinity) {
        this._sourceBuffer.appendWindowEnd = Infinity;
      }
    } else if (appendWindow[1] !== this._sourceBuffer.appendWindowEnd) {
      this._sourceBuffer.appendWindowEnd = appendWindow[1];
    }

    log["a" /* default */].debug("QSB: pushing new data to SourceBuffer", this.bufferType);

    if (isInit) {
      this._lastInitSegment = segmentData;
    }

    this._sourceBuffer.appendBuffer(segmentData);
  };

  createClass_default()(QueuedSourceBuffer, [{
    key: "codec",
    get: function get() {
      return this._currentCodec;
    }
  }]);

  return QueuedSourceBuffer;
}();
/**
 * @param {Object} item
 * @returns {Object|null}
 */




function convertQueueItemToTask(item) {
  switch (item.type) {
    case SourceBufferOperation.Push:
      // Push operation with both an init segment and a regular segment need
      // to be separated into two steps
      var steps = [];
      var itemValue = item.value;
      var data = itemValue.data,
          inventoryInfos = itemValue.inventoryInfos;
      var estimatedDuration = inventoryInfos.estimatedDuration,
          estimatedStart = inventoryInfos.estimatedStart,
          segment = inventoryInfos.segment; // Cutting exactly at the start or end of the appendWindow can lead to
      // cases of infinite rebuffering due to how browser handle such windows.
      // To work-around that, we add a small offset before and after those.

      var safeAppendWindow = [data.appendWindow[0] !== undefined ? Math.max(0, data.appendWindow[0] - APPEND_WINDOW_SECURITIES.START) : undefined, data.appendWindow[1] !== undefined ? data.appendWindow[1] + APPEND_WINDOW_SECURITIES.END : undefined];

      if (data.initSegment !== null) {
        steps.push({
          isInit: true,
          segmentData: data.initSegment,
          codec: data.codec,
          timestampOffset: data.timestampOffset,
          appendWindow: safeAppendWindow
        });
      }

      if (data.chunk !== null) {
        steps.push({
          isInit: false,
          segmentData: data.chunk,
          codec: data.codec,
          timestampOffset: data.timestampOffset,
          appendWindow: safeAppendWindow
        });
      }

      if (steps.length === 0) {
        return null;
      }

      var start = estimatedStart === undefined ? segment.time / segment.timescale : estimatedStart;
      var duration = estimatedDuration === undefined ? segment.duration / segment.timescale : estimatedDuration;
      var end = start + duration;

      if (safeAppendWindow[0] !== undefined) {
        start = Math.max(start, safeAppendWindow[0]);
      }

      if (safeAppendWindow[1] !== undefined) {
        end = Math.min(end, safeAppendWindow[1]);
      }

      var inventoryData = {
        period: inventoryInfos.period,
        adaptation: inventoryInfos.adaptation,
        representation: inventoryInfos.representation,
        segment: inventoryInfos.segment,
        start: start,
        end: end
      };
      return Object(object_assign["a" /* default */])({
        steps: steps,
        inventoryData: inventoryData
      }, item);

    case SourceBufferOperation.Remove:
    case SourceBufferOperation.EndOfSegment:
      return item;

    default:
      Object(assert_unreachable["a" /* default */])(item);
  }
}
// CONCATENATED MODULE: ./src/core/source_buffers/source_buffers_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var POSSIBLE_BUFFER_TYPES = ["audio", "video", "text", "image"];
/**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one SourceBuffer per type is allowed at the same time:
 *
 *   - SourceBuffers for native types (which are "audio" and "video" and which
 *     depend on the native SourceBuffer implementation) are reused if one is
 *     re-created.
 *
 *   - SourceBuffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation and queue all its actions.
 *
 * To be able to use a native SourceBuffer, you will first need to create it,
 * but also wait until the other one is either created or explicitely
 * disabled through the `disableSourceBuffer` method.
 * The Observable returned by `waitForUsableSourceBuffers` will emit when
 * that is the case.
 *
 * @class SourceBuffersStore
 */

var source_buffers_store_SourceBuffersStore = /*#__PURE__*/function () {
  /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */
  function SourceBuffersStore(mediaElement, mediaSource) {
    this._mediaElement = mediaElement;
    this._mediaSource = mediaSource;
    this._initializedSourceBuffers = {};
    this._onNativeSourceBufferAddedOrDisabled = [];
  }
  /**
   * Returns true if the SourceBuffer is "native".
   * Native SourceBuffers needed for the current content must all be created
   * before the content begins to be played and cannot be disposed during
   * playback.
   * @param {string} bufferType
   * @returns {Boolean}
   */


  SourceBuffersStore.isNative = function isNative(bufferType) {
    return shouldHaveNativeSourceBuffer(bufferType);
  }
  /**
   * Get all currently available buffer types.
   * /!\ This list can evolve at runtime depending on feature switching.
   * @returns {Array.<string>}
   */
  ;

  var _proto = SourceBuffersStore.prototype;

  _proto.getBufferTypes = function getBufferTypes() {
    var bufferTypes = this.getNativeBufferTypes();

    if (features["a" /* default */].nativeTextTracksBuffer != null || features["a" /* default */].htmlTextTracksBuffer != null) {
      bufferTypes.push("text");
    }

    if (features["a" /* default */].imageBuffer != null) {
      bufferTypes.push("image");
    }

    return bufferTypes;
  }
  /**
   * Get all "native" buffer types that should be created before beginning to
   * push contents.
   * @returns {Array.<string>}
   */
  ;

  _proto.getNativeBufferTypes = function getNativeBufferTypes() {
    return this._mediaElement.nodeName === "AUDIO" ? ["audio"] : ["video", "audio"];
  }
  /**
   * Returns the current "status" of the SourceBuffer linked to the buffer type
   * given.
   *
   * This function will return  an object containing a key named `type` which
   * can be equal to either one of those three value:
   *
   *   - "initialized": A SourceBuffer has been created for that type.
   *     You will in this case also have a second key, `value`, which will
   *     contain the related QueuedSourceBuffer instance.
   *     Please note that you will need to wait until
   *     `this.waitForUsableSourceBuffers()` has emitted before pushing segment
   *     data to a native QueuedSourceBuffer.
   *
   *   - "disabled": The SourceBuffer has been explicitely disabled for this
   *     type.
   *
   *   - "uninitialized": No action has yet been yet for that SourceBuffer.
   *
   * @param {string} bufferType
   * @returns {QueuedSourceBuffer|null}
   */
  ;

  _proto.getStatus = function getStatus(bufferType) {
    var initializedBuffer = this._initializedSourceBuffers[bufferType];
    return initializedBuffer === undefined ? {
      type: "uninitialized"
    } : initializedBuffer === null ? {
      type: "disabled"
    } : {
      type: "initialized",
      value: initializedBuffer
    };
  }
  /**
   * Native SourceBuffers (audio and video) needed for playing the current
   * content need to all be created before any one can be used.
   *
   * This function will return an Observable emitting when any and all native
   * SourceBuffers through this store can be used.
   *
   * From https://w3c.github.io/media-source/#methods
   *   For example, a user agent may throw a QuotaExceededError
   *   exception if the media element has reached the HAVE_METADATA
   *   readyState. This can occur if the user agent's media engine
   *   does not support adding more tracks during playback.
   * @return {Observable}
   */
  ;

  _proto.waitForUsableSourceBuffers = function waitForUsableSourceBuffers() {
    var _this = this;

    if (this._areNativeSourceBuffersUsable()) {
      return Object(of["a" /* of */])(undefined);
    }

    return new Observable["a" /* Observable */](function (obs) {
      _this._onNativeSourceBufferAddedOrDisabled.push(function () {
        if (_this._areNativeSourceBuffersUsable()) {
          obs.next(undefined);
          obs.complete();
        }
      });
    });
  }
  /**
   * Explicitely disable the SourceBuffer for a given buffer type.
   * A call to this function is needed at least for unused native buffer types
   * (usually "audio" and "video"), to be able to emit through
   * `waitForUsableSourceBuffers` when conditions are met.
   * @param {string}
   */
  ;

  _proto.disableSourceBuffer = function disableSourceBuffer(bufferType) {
    var currentValue = this._initializedSourceBuffers[bufferType];

    if (currentValue === null) {
      log["a" /* default */].warn("SBS: The " + bufferType + " SourceBuffer was already disabled.");
      return;
    }

    if (currentValue !== undefined) {
      throw new Error("Cannot disable an active SourceBuffer.");
    }

    this._initializedSourceBuffers[bufferType] = null;

    if (SourceBuffersStore.isNative(bufferType)) {
      this._onNativeSourceBufferAddedOrDisabled.forEach(function (cb) {
        return cb();
      });
    }
  }
  /**
   * Creates a new QueuedSourceBuffer for the SourceBuffer type.
   * Reuse an already created one if a QueuedSourceBuffer for the given type
   * already exists.
   *
   * Please note that you will need to wait until `this.waitForUsableSourceBuffers()`
   * has emitted before pushing segment data to a native QueuedSourceBuffer.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {QueuedSourceBuffer}
   */
  ;

  _proto.createSourceBuffer = function createSourceBuffer(bufferType, codec, options) {
    if (options === void 0) {
      options = {};
    }

    var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];

    if (shouldHaveNativeSourceBuffer(bufferType)) {
      if (memorizedSourceBuffer != null) {
        if (memorizedSourceBuffer.codec !== codec) {
          log["a" /* default */].warn("SB: Reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec);
        } else {
          log["a" /* default */].info("SB: Reusing native SourceBuffer with codec", codec);
        }

        return memorizedSourceBuffer;
      }

      log["a" /* default */].info("SB: Adding native SourceBuffer with codec", codec);
      var nativeSourceBuffer = createNativeQueuedSourceBuffer(bufferType, this._mediaSource, codec);
      this._initializedSourceBuffers[bufferType] = nativeSourceBuffer;

      this._onNativeSourceBufferAddedOrDisabled.forEach(function (cb) {
        return cb();
      });

      return nativeSourceBuffer;
    }

    if (memorizedSourceBuffer != null) {
      log["a" /* default */].info("SB: Reusing a previous custom SourceBuffer for the type", bufferType);
      return memorizedSourceBuffer;
    }

    if (bufferType === "text") {
      log["a" /* default */].info("SB: Creating a new text SourceBuffer with codec", codec);
      var sourceBuffer;

      if (options.textTrackMode === "html") {
        if (features["a" /* default */].htmlTextTracksBuffer == null) {
          throw new Error("HTML Text track feature not activated");
        }

        sourceBuffer = new features["a" /* default */].htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
      } else {
        if (features["a" /* default */].nativeTextTracksBuffer == null) {
          throw new Error("Native Text track feature not activated");
        }

        sourceBuffer = new features["a" /* default */].nativeTextTracksBuffer(this._mediaElement, options.hideNativeSubtitle === true);
      }

      var queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("text", codec, sourceBuffer);
      this._initializedSourceBuffers.text = queuedSourceBuffer;
      return queuedSourceBuffer;
    } else if (bufferType === "image") {
      if (features["a" /* default */].imageBuffer == null) {
        throw new Error("Image buffer feature not activated");
      }

      log["a" /* default */].info("SB: Creating a new image SourceBuffer with codec", codec);

      var _sourceBuffer = new features["a" /* default */].imageBuffer();

      var _queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("image", codec, _sourceBuffer);

      this._initializedSourceBuffers.image = _queuedSourceBuffer;
      return _queuedSourceBuffer;
    }

    log["a" /* default */].error("SB: Unknown buffer type:", bufferType);
    throw new media_error["a" /* default */]("BUFFER_TYPE_UNKNOWN", "The player wants to create a SourceBuffer of an unknown type.");
  }
  /**
   * Dispose of the active SourceBuffer for the given type.
   * @param {string} bufferType
   */
  ;

  _proto.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
    var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];

    if (memorizedSourceBuffer == null) {
      log["a" /* default */].warn("SB: Trying to dispose a SourceBuffer that does not exist");
      return;
    }

    log["a" /* default */].info("SB: Aborting SourceBuffer", bufferType);
    memorizedSourceBuffer.dispose();

    if (!shouldHaveNativeSourceBuffer(bufferType) || this._mediaSource.readyState === "open") {
      try {
        memorizedSourceBuffer.abort();
      } catch (e) {
        log["a" /* default */].warn("SB: Failed to abort a " + bufferType + " SourceBuffer:", e);
      }
    }

    delete this._initializedSourceBuffers[bufferType];
  }
  /**
   * Dispose of all QueuedSourceBuffer created on this SourceBuffersStore.
   */
  ;

  _proto.disposeAll = function disposeAll() {
    var _this2 = this;

    POSSIBLE_BUFFER_TYPES.forEach(function (bufferType) {
      if (_this2.getStatus(bufferType).type === "initialized") {
        _this2.disposeSourceBuffer(bufferType);
      }
    });
  }
  /**
   * Returns `true` when we're ready to push and decode contents through our
   * created native SourceBuffers.
   */
  ;

  _proto._areNativeSourceBuffersUsable = function _areNativeSourceBuffersUsable() {
    var _this3 = this;

    var nativeBufferTypes = this.getNativeBufferTypes();

    if (nativeBufferTypes.some(function (sbType) {
      return _this3._initializedSourceBuffers[sbType] === undefined;
    })) {
      // one is not yet initialized/disabled
      return false;
    }

    if (nativeBufferTypes.every(function (sbType) {
      return _this3._initializedSourceBuffers[sbType] === null;
    })) {
      // they all are disabled: we can't play the content
      return false;
    }

    return true;
  };

  return SourceBuffersStore;
}();
/**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */




function createNativeQueuedSourceBuffer(bufferType, mediaSource, codec) {
  var sourceBuffer = mediaSource.addSourceBuffer(codec);
  return new queued_source_buffer_QueuedSourceBuffer(bufferType, codec, sourceBuffer);
}
/**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */


function shouldHaveNativeSourceBuffer(bufferType) {
  return bufferType === "audio" || bufferType === "video";
}
// CONCATENATED MODULE: ./src/core/source_buffers/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ var source_buffers = (source_buffers_store_SourceBuffersStore);

// CONCATENATED MODULE: ./src/utils/sorted_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeElement(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */

var sorted_list_SortedList = /*#__PURE__*/function () {
  /**
   * @param {Function} sortingFunction
   */
  function SortedList(sortingFunction) {
    this._array = [];
    this._sortingFn = sortingFunction;
  }
  /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */


  var _proto = SortedList.prototype;

  _proto.add = function add() {
    for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) {
      elements[_key] = arguments[_key];
    }

    elements.sort(this._sortingFn);
    var j = 0;

    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var inserted = false;

      while (!inserted && j < this._array.length) {
        if (this._sortingFn(element, this._array[j]) < 0) {
          this._array.splice(j, 0, element);

          inserted = true;
        } else {
          j++;
        }
      }

      if (!inserted) {
        this._array.push(element);
      }
    }
  }
  /**
   * Returns the current length of the list.
   * @returns {number}
   */
  ;

  _proto.length = function length() {
    return this._array.length;
  }
  /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */
  ;

  _proto.get = function get(index) {
    if (index < 0 || index >= this._array.length) {
      throw new Error("Invalid index.");
    }

    return this._array[index];
  }
  /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */
  ;

  _proto.findFirst = function findFirst(fn) {
    return Object(array_find["a" /* default */])(this._array, fn);
  }
  /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */
  ;

  _proto.has = function has(element) {
    return Object(array_includes["a" /* default */])(this._array, element);
  }
  /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */
  ;

  _proto.removeElement = function removeElement(element) {
    var indexOf = this._array.indexOf(element);

    if (indexOf >= 0) {
      this._array.splice(indexOf, 1);

      return indexOf;
    }
  }
  /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
  ;

  _proto.head = function head() {
    return this._array[0];
  }
  /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
  ;

  _proto.last = function last() {
    return this._array[this._array.length - 1];
  }
  /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
  ;

  _proto.shift = function shift() {
    return this._array.shift();
  }
  /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
  ;

  _proto.pop = function pop() {
    return this._array.pop();
  };

  return SortedList;
}();


// CONCATENATED MODULE: ./src/utils/weak_map_memory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */
var WeakMapMemory = /*#__PURE__*/function () {
  /**
   * @param {Function}
   */
  function WeakMapMemory(fn) {
    this._weakMap = new WeakMap();
    this._fn = fn;
  }
  /**
   * @param {Object} obj
   * @returns {*}
   */


  var _proto = WeakMapMemory.prototype;

  _proto.get = function get(obj) {
    var fromMemory = this._weakMap.get(obj);

    if (fromMemory === undefined) {
      var newElement = this._fn(obj);

      this._weakMap.set(obj, newElement);

      return newElement;
    } else {
      return fromMemory;
    }
  }
  /**
   * @param {Object} obj
   */
  ;

  _proto.destroy = function destroy(obj) {
    this._weakMap["delete"](obj);
  };

  return WeakMapMemory;
}();


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatAll.js
var concatAll = __webpack_require__(176);

// CONCATENATED MODULE: ./src/core/source_buffers/garbage_collector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */

function BufferGarbageCollector(_ref) {
  var queuedSourceBuffer = _ref.queuedSourceBuffer,
      clock$ = _ref.clock$,
      maxBufferBehind$ = _ref.maxBufferBehind$,
      maxBufferAhead$ = _ref.maxBufferAhead$;
  return Object(combineLatest["a" /* combineLatest */])([clock$, maxBufferBehind$, maxBufferAhead$]).pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
    var currentTime = _ref2[0],
        maxBufferBehind = _ref2[1],
        maxBufferAhead = _ref2[2];
    return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
  }));
}
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer data when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */

function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
  if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
    return empty["a" /* EMPTY */];
  }

  var cleanedupRanges = [];

  var _getInnerAndOuterTime = Object(ranges["c" /* getInnerAndOuterTimeRanges */])(qSourceBuffer.getBufferedRanges(), position),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var collectBufferBehind = function collectBufferBehind() {
    if (!isFinite(maxBufferBehind)) {
      return;
    } // begin from the oldest


    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];

      if (position - maxBufferBehind >= outerRange.end) {
        cleanedupRanges.push(outerRange);
      } else if (position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end) {
        cleanedupRanges.push({
          start: outerRange.start,
          end: position - maxBufferBehind
        });
      }
    }

    if (innerRange != null) {
      if (position - maxBufferBehind > innerRange.start) {
        cleanedupRanges.push({
          start: innerRange.start,
          end: position - maxBufferBehind
        });
      }
    }
  };

  var collectBufferAhead = function collectBufferAhead() {
    if (!isFinite(maxBufferAhead)) {
      return;
    } // begin from the oldest


    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];

      if (position + maxBufferAhead <= outerRange.start) {
        cleanedupRanges.push(outerRange);
      } else if (position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: outerRange.end
        });
      }
    }

    if (innerRange != null) {
      if (position + maxBufferAhead < innerRange.end) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: innerRange.end
        });
      }
    }
  };

  collectBufferBehind();
  collectBufferAhead();
  var clean$ = Object(from["a" /* from */])(cleanedupRanges.map(function (range) {
    log["a" /* default */].debug("GC: cleaning range from SourceBuffer", range);
    return qSourceBuffer.removeBuffer(range.start, range.end);
  })).pipe(Object(concatAll["a" /* concatAll */])(), Object(ignoreElements["a" /* ignoreElements */])());
  return clean$;
}
// CONCATENATED MODULE: ./src/core/stream/events_generators.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EVENTS = {
  activeStream: function activeStream(bufferType) {
    return {
      type: "active-stream",
      value: {
        bufferType: bufferType
      }
    };
  },
  activePeriodChanged: function activePeriodChanged(period) {
    return {
      type: "activePeriodChanged",
      value: {
        period: period
      }
    };
  },
  adaptationChange: function adaptationChange(bufferType, adaptation, period) {
    return {
      type: "adaptationChange",
      value: {
        type: bufferType,
        adaptation: adaptation,
        period: period
      }
    };
  },
  addedSegment: function addedSegment(content, segment, buffered, segmentData) {
    return {
      type: "added-segment",
      value: {
        content: content,
        segment: segment,
        segmentData: segmentData,
        buffered: buffered
      }
    };
  },
  bitrateEstimationChange: function bitrateEstimationChange(type, bitrate) {
    return {
      type: "bitrateEstimationChange",
      value: {
        type: type,
        bitrate: bitrate
      }
    };
  },
  streamComplete: function streamComplete(bufferType) {
    return {
      type: "complete-stream",
      value: {
        type: bufferType
      }
    };
  },
  discontinuityEncountered: function discontinuityEncountered(gap, bufferType) {
    return {
      type: "discontinuity-encountered",
      value: {
        bufferType: bufferType,
        gap: gap
      }
    };
  },
  endOfStream: function endOfStream() {
    return {
      type: "end-of-stream",
      value: undefined
    };
  },
  fullStream: function fullStream(bufferType) {
    return {
      type: "full-stream",
      value: {
        bufferType: bufferType
      }
    };
  },
  needsManifestRefresh: function needsManifestRefresh() {
    return {
      type: "needs-manifest-refresh",
      value: undefined
    };
  },
  manifestMightBeOufOfSync: function manifestMightBeOufOfSync() {
    return {
      type: "manifest-might-be-out-of-sync",
      value: undefined
    };
  },
  needsMediaSourceReload: function needsMediaSourceReload(period, _ref) {
    var currentTime = _ref.currentTime,
        isPaused = _ref.isPaused;
    return {
      type: "needs-media-source-reload",
      value: {
        currentTime: currentTime,
        isPaused: isPaused,
        period: period
      }
    };
  },
  needsDecipherabilityFlush: function needsDecipherabilityFlush(_ref2) {
    var currentTime = _ref2.currentTime,
        isPaused = _ref2.isPaused,
        duration = _ref2.duration;
    return {
      type: "needs-decipherability-flush",
      value: {
        currentTime: currentTime,
        isPaused: isPaused,
        duration: duration
      }
    };
  },
  periodStreamReady: function periodStreamReady(type, period, adaptation$) {
    return {
      type: "periodStreamReady",
      value: {
        type: type,
        period: period,
        adaptation$: adaptation$
      }
    };
  },
  periodStreamCleared: function periodStreamCleared(type, period) {
    return {
      type: "periodStreamCleared",
      value: {
        type: type,
        period: period
      }
    };
  },
  protectedSegment: function protectedSegment(initDataInfo) {
    return {
      type: "protected-segment",
      value: initDataInfo
    };
  },
  representationChange: function representationChange(type, period, representation) {
    return {
      type: "representationChange",
      value: {
        type: type,
        period: period,
        representation: representation
      }
    };
  },
  streamTerminating: function streamTerminating() {
    return {
      type: "stream-terminating",
      value: undefined
    };
  },
  resumeStream: function resumeStream() {
    return {
      type: "resume-stream",
      value: undefined
    };
  },
  warning: function warning(value) {
    return {
      type: "warning",
      value: value
    };
  }
};
/* harmony default export */ var stream_events_generators = (EVENTS);
// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(81);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var takeWhile_TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=takeWhile.js.map

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(24);

// CONCATENATED MODULE: ./src/compat/should_append_buffer_after_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * When the player decides to load another quality and replace
 * currently buffered one, it may append buffer on current playback time.
 *
 * On Safari, with HSS contents, this provoques green macro-block screens
 * during the transition. To avoid this situation, we decide not to load a
 * segment if it may be pushed during playback time. We should not buffer
 * under a certain padding from the current time.
 */

var shouldAppendBufferAfterPadding = browser_detection["e" /* isSafari */];
/* harmony default export */ var should_append_buffer_after_padding = (shouldAppendBufferAfterPadding);
// CONCATENATED MODULE: ./src/core/stream/representation/get_needed_segments.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create RepresentationStreams.
 *
 * A RepresentationStream downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */






var CONTENT_REPLACEMENT_PADDING = config["a" /* default */].CONTENT_REPLACEMENT_PADDING,
    BITRATE_REBUFFERING_RATIO = config["a" /* default */].BITRATE_REBUFFERING_RATIO,
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config["a" /* default */].MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT,
    get_needed_segments_MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * Epsilon compensating for rounding errors when comparing the start and end
 * time of multiple segments.
 */

var ROUNDING_ERROR = Math.min(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE);
/**
 * @param {Object} segmentFilterArgument
 * @returns {Array.<Object>}
 */

function getNeededSegments(_ref) {
  var content = _ref.content,
      currentPlaybackTime = _ref.currentPlaybackTime,
      knownStableBitrate = _ref.knownStableBitrate,
      neededRange = _ref.neededRange,
      queuedSourceBuffer = _ref.queuedSourceBuffer;
  var segmentInventory = queuedSourceBuffer.getInventory();
  /**
   * Every segment awaiting an "EndOfSegment" operation, which indicates that a
   * completely-loaded segment is still being pushed to the QueuedSourceBuffer.
   */

  var segmentsBeingPushed = queuedSourceBuffer.getPendingOperations().filter(function (operation) {
    return operation.type === SourceBufferOperation.EndOfSegment;
  }).map(function (operation) {
    return operation.value;
  }); // 1 - construct lists of segments possible and actually pushed

  var segmentsForRange = content.representation.index.getSegments(neededRange.start, neededRange.end - neededRange.start);
  var bufferedSegments = getPlayableBufferedSegments({
    start: Math.max(neededRange.start - 0.5, 0),
    end: neededRange.end + 0.5
  }, segmentInventory); // 2 - remove from pushed list of current segments the contents we want to replace

  bufferedSegments = bufferedSegments.filter(function (bufferedSegment) {
    return !shouldContentBeReplaced(bufferedSegment.infos, content, currentPlaybackTime, knownStableBitrate);
  }); // 3 - remove from that list the segments who appeared to have been GCed

  bufferedSegments = filterGarbageCollectedSegments(bufferedSegments, neededRange); // 4 - now filter the list of segments we can download

  return segmentsForRange.filter(function (segment) {
    var contentObject = Object(object_assign["a" /* default */])({
      segment: segment
    }, content); // First, check that the segment is not already being pushed

    if (segmentsBeingPushed.length > 0) {
      var isAlreadyBeingPushed = segmentsBeingPushed.some(function (pendingSegment) {
        return Object(are_same_content["a" /* default */])(contentObject, pendingSegment);
      });

      if (isAlreadyBeingPushed) {
        return false;
      }
    }

    var duration = segment.duration,
        time = segment.time,
        timescale = segment.timescale;

    if (segment.isInit || duration === undefined) {
      return true; // never skip those
    }

    if (duration / timescale < get_needed_segments_MINIMUM_SEGMENT_SIZE) {
      return false; // too small
    }

    var scaledTime = time / timescale;
    var scaledDuration = duration / timescale;
    var scaledEnd = scaledTime + scaledDuration; // Check if the same segment from another Representation is not already
    // being pushed.

    if (segmentsBeingPushed.length > 0) {
      var waitForPushedSegment = segmentsBeingPushed.some(function (pendingSegment) {
        if (pendingSegment.period.id !== content.period.id || pendingSegment.adaptation.id !== content.adaptation.id) {
          return false;
        }

        var oldSegment = pendingSegment.segment;
        var oldSegmentStart = oldSegment.time / oldSegment.timescale;

        if (oldSegmentStart - ROUNDING_ERROR > scaledTime) {
          return false;
        }

        var oldSegmentEnd = oldSegmentStart + oldSegment.duration / oldSegment.timescale;

        if (oldSegmentEnd + ROUNDING_ERROR < scaledEnd) {
          return false;
        }

        return !shouldContentBeReplaced(pendingSegment, contentObject, currentPlaybackTime, knownStableBitrate);
      });

      if (waitForPushedSegment) {
        return false;
      }
    } // check if the segment is already downloaded


    for (var i = 0; i < bufferedSegments.length; i++) {
      var completeSeg = bufferedSegments[i];
      var areFromSamePeriod = completeSeg.infos.period.id === content.period.id; // Check if content are from same period, as there can't be overlapping
      // periods, we should consider a segment as already downloaded if
      // it is from same period (but can be from different adaptation or
      // representation)

      if (areFromSamePeriod) {
        var segTime = completeSeg.infos.segment.time;
        var segDuration = completeSeg.infos.segment.duration;
        var segTimeScale = completeSeg.infos.segment.timescale;
        var scaledSegTime = segTime / segTimeScale;
        var scaledSegEnd = scaledSegTime + segDuration / segTimeScale;

        if (scaledTime - scaledSegTime > -ROUNDING_ERROR && scaledSegEnd - scaledEnd > -ROUNDING_ERROR) {
          return false; // already downloaded
        }
      }
    } // check if there is an hole in place of the segment currently


    for (var _i = 0; _i < bufferedSegments.length; _i++) {
      var _completeSeg = bufferedSegments[_i];

      if (_completeSeg.end > scaledTime) {
        if (_completeSeg.start > scaledTime + ROUNDING_ERROR) {
          return true;
        }

        var j = _i + 1; // go through all contiguous segments and take the last one

        while (j < bufferedSegments.length - 1 && bufferedSegments[j - 1].end + ROUNDING_ERROR > bufferedSegments[j].start) {
          j++;
        }

        j--; // index of last contiguous segment

        return bufferedSegments[j].end < scaledEnd + ROUNDING_ERROR;
      }
    }

    return true;
  });
}
/**
 * Returns `true` if segments linked to the given `oldContent` currently present
 * in the buffer should be replaced by segments coming from `currentContent`.
 * @param {Object} oldContent
 * @param {Object} currentContent
 * @param {number} currentPlaybackTime
 * @param {number} [knownStableBitrate]
 * @returns {boolean}
 */

function shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, knownStableBitrate) {
  if (oldContent.period.id !== currentContent.period.id) {
    return false; // keep segments from another Period by default.
  }

  var segment = oldContent.segment;

  if (should_append_buffer_after_padding && segment.time / segment.timescale < currentPlaybackTime + CONTENT_REPLACEMENT_PADDING) {
    return false;
  }

  if (oldContent.adaptation.id !== currentContent.adaptation.id) {
    return true; // replace segments from another Adaptation
  }

  return canFastSwitch(oldContent.representation, currentContent.representation, knownStableBitrate);
}
/**
 * Returns `true` if segments from the new Representation can replace
 * previously-loaded segments from the old Representation given.
 *
 * This behavior is called "fast-switching".
 * @param {Object} oldSegmentRepresentation
 * @param {Object} newSegmentRepresentation
 * @param {number|undefined} knownStableBitrate
 * @returns {boolean}
 */


function canFastSwitch(oldSegmentRepresentation, newSegmentRepresentation, knownStableBitrate) {
  var oldContentBitrate = oldSegmentRepresentation.bitrate;

  if (knownStableBitrate === undefined) {
    // only re-load comparatively-poor bitrates for the same Adaptation.
    var bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
    return newSegmentRepresentation.bitrate > bitrateCeil;
  }

  return oldContentBitrate < knownStableBitrate && newSegmentRepresentation.bitrate > oldContentBitrate;
}
/**
 * Returns an Array which removed the segments from `consideredSegments` which
 * appeared to have been garbage collected.
 * @param {Array.<Object>} consideredSegments
 * @param {Object} neededRange
 * @returns {Array.<Object>}
 */


function filterGarbageCollectedSegments(consideredSegments, neededRange) {
  var completeSegments = [];

  for (var i = 0; i < consideredSegments.length; i++) {
    var currentSeg = consideredSegments[i];
    var prevSeg = i === 0 ? null : consideredSegments[i - 1];
    var nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];

    if (!isStartGarbageCollected(currentSeg, prevSeg, neededRange.start) && !isEndGarbageCollected(currentSeg, nextSeg, neededRange.end)) {
      completeSegments.push(currentSeg);
    }
  }

  return completeSegments;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the start.
 * Return `false` if the segment is complete at least from `maximumStartTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} prevSeg - The segment information for the previous
 * buffered segment, if one (`null` if none).
 * @param {number} maximumStartTime - Only consider the data after that time.
 * If `currentSeg` has only been garbage collected for some data which is before
 * that time, we will return `false`.
 */


function isStartGarbageCollected(currentSeg, prevSeg, maximumStartTime) {
  if (currentSeg.bufferedStart === undefined) {
    log["a" /* default */].warn("Stream: Start of a segment unknown. " + "Assuming it is garbage collected by default.", currentSeg);
    return true;
  }

  if (prevSeg !== null && prevSeg.bufferedEnd !== undefined && currentSeg.bufferedStart - prevSeg.bufferedEnd < 0.1) {
    return false;
  }

  if (maximumStartTime < currentSeg.bufferedStart && currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
    log["a" /* default */].info("Stream: The start of the wanted segment has been garbage collected", currentSeg);
    return true;
  }

  return false;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the end.
 * Return `false` if the segment is complete at least until `minimumEndTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} nextSeg - The segment information for the next buffered
 * segment, if one (`null` if none).
 * @param {number} minimumEndTime - Only consider the data before that time.
 * If `currentSeg` has only been garbage collected for some data which is after
 * that time, we will return `false`.
 */


function isEndGarbageCollected(currentSeg, nextSeg, minimumEndTime) {
  if (currentSeg.bufferedEnd === undefined) {
    log["a" /* default */].warn("Stream: End of a segment unknown. " + "Assuming it is garbage collected by default.", currentSeg);
    return true;
  }

  if (nextSeg !== null && nextSeg.bufferedStart !== undefined && nextSeg.bufferedStart - currentSeg.bufferedEnd < 0.1) {
    return false;
  }

  if (minimumEndTime > currentSeg.bufferedEnd && currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
    log["a" /* default */].info("Stream: The end of the wanted segment has been garbage collected", currentSeg);
    return true;
  }

  return false;
}
/**
 * From the given SegmentInventory, filters the "playable" (in a supported codec
 * and not known to be undecipherable) buffered Segment Objects which overlap
 * with the given range.
 * @param {Object} neededRange
 * @param {Array.<Object>} segmentInventory
 * @returns {Array.<Object>}
 */


function getPlayableBufferedSegments(neededRange, segmentInventory) {
  var segmentRoundingError = Math.max(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE);
  var minEnd = neededRange.start + segmentRoundingError;
  var maxStart = neededRange.end - segmentRoundingError;
  var overlappingChunks = [];

  for (var i = segmentInventory.length - 1; i >= 0; i--) {
    var eltInventory = segmentInventory[i];
    var representation = eltInventory.infos.representation;

    if (!eltInventory.partiallyPushed && representation.decipherable !== false && representation.isSupported) {
      var inventorySegment = eltInventory.infos.segment;
      var eltInventoryStart = inventorySegment.time / inventorySegment.timescale;
      var eltInventoryEnd = inventorySegment.duration == null ? eltInventory.end : eltInventoryStart + inventorySegment.duration / inventorySegment.timescale;

      if (eltInventoryEnd > minEnd && eltInventoryStart < maxStart || eltInventory.end > minEnd && eltInventory.start < maxStart) {
        overlappingChunks.unshift(eltInventory);
      }
    }
  }

  return overlappingChunks;
}
// CONCATENATED MODULE: ./src/core/stream/representation/get_segment_priority.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SEGMENT_PRIORITIES_STEPS = config["a" /* default */].SEGMENT_PRIORITIES_STEPS;
/**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 *
 * Note that a segment starting behind the current time will always have the
 * highest priority.
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */

function getSegmentPriority(segment, clockTick) {
  var segmentStart = segment.time / segment.timescale;
  return getPriorityForTime(segmentStart, clockTick);
}
/**
 * Calculate the priority number for a given time, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * Note that a `timeWanted` given behind the current time will always have the
 * highest priority.
 * @param {number} timeWanted
 * @param {Object} clockTick
 * @returns {number}
 */

function getPriorityForTime(timeWanted, clockTick) {
  var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset;
  var distance = timeWanted - currentTime;

  for (var priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
    if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
      return priority;
    }
  }

  return SEGMENT_PRIORITIES_STEPS.length;
}
// CONCATENATED MODULE: ./src/core/stream/representation/get_wanted_range.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} tick
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */
function getWantedRange(hardLimits, tick, bufferGoal) {
  var currentTime = tick.currentTime + tick.wantedTimeOffset;
  var startHardLimit = hardLimits.start == null ? 0 : hardLimits.start;
  var endHardLimit = hardLimits.end == null ? Infinity : hardLimits.end;
  var boundedLimits = {
    start: Math.max(startHardLimit, currentTime),
    end: endHardLimit
  };
  return {
    start: Math.min(boundedLimits.end, Math.max(currentTime, boundedLimits.start)),
    end: Math.min(boundedLimits.end, Math.max(currentTime + bufferGoal, boundedLimits.start))
  };
}
// CONCATENATED MODULE: ./src/core/stream/representation/force_garbage_collection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var GC_GAP_CALM = config["a" /* default */].BUFFER_GC_GAPS.CALM;
var GC_GAP_BEEFY = config["a" /* default */].BUFFER_GC_GAPS.BEEFY;
/**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */

function forceGarbageCollection(timings$, bufferingQueue) {
  // wait for next timing event
  return timings$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (timing) {
    log["a" /* default */].warn("Stream: Running garbage collector");
    var buffered = bufferingQueue.getBufferedRanges();
    var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM); // more aggressive GC if we could not find any range to clean

    if (cleanedupRanges.length === 0) {
      cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);
    }

    log["a" /* default */].debug("Stream: GC cleaning", cleanedupRanges);
    return Object(from["a" /* from */])(cleanedupRanges.map(function (_ref) {
      var start = _ref.start,
          end = _ref.end;
      return bufferingQueue.removeBuffer(start, end);
    })).pipe(Object(concatAll["a" /* concatAll */])());
  }));
}
/**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */

function selectGCedRanges(currentTime, buffered, gcGap) {
  var _getInnerAndOuterTime = Object(ranges["c" /* getInnerAndOuterTimeRanges */])(buffered, currentTime),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var cleanedupRanges = []; // start by trying to remove all ranges that do not contain the
  // current time and respect the gcGap
  // respect the gcGap? FIXME?

  for (var i = 0; i < outerRanges.length; i++) {
    var outerRange = outerRanges[i];

    if (currentTime - gcGap < outerRange.end) {
      cleanedupRanges.push(outerRange);
    } else if (currentTime + gcGap > outerRange.start) {
      cleanedupRanges.push(outerRange);
    }
  } // try to clean up some space in the current range


  if (innerRange != null) {
    log["a" /* default */].debug("Stream: GC removing part of inner range", cleanedupRanges);

    if (currentTime - gcGap > innerRange.start) {
      cleanedupRanges.push({
        start: innerRange.start,
        end: currentTime - gcGap
      });
    }

    if (currentTime + gcGap < innerRange.end) {
      cleanedupRanges.push({
        start: currentTime + gcGap,
        end: innerRange.end
      });
    }
  }

  return cleanedupRanges;
}
// CONCATENATED MODULE: ./src/core/stream/representation/append_segment_to_source_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows any Stream to push data to a QueuedSourceBuffer.
 */




/**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */

function appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, dataInfos) {
  var append$ = queuedSourceBuffer.pushChunk(dataInfos);
  return append$.pipe(Object(catchError["a" /* catchError */])(function (appendError) {
    if (!(appendError instanceof Error) || appendError.name !== "QuotaExceededError") {
      var reason = appendError instanceof Error ? appendError.toString() : "An unknown error happened when pushing content";
      throw new media_error["a" /* default */]("BUFFER_APPEND_ERROR", reason);
    }

    return Object(concat["a" /* concat */])(forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(ignoreElements["a" /* ignoreElements */])()), append$).pipe(Object(catchError["a" /* catchError */])(function (forcedGCError) {
      var reason = forcedGCError instanceof Error ? forcedGCError.toString() : "Could not clean the buffer";
      throw new media_error["a" /* default */]("BUFFER_FULL_ERROR", reason);
    }));
  }));
}
// CONCATENATED MODULE: ./src/core/stream/representation/push_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Push the initialization segment to the QueuedSourceBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */

function pushInitSegment(_ref) {
  var clock$ = _ref.clock$,
      content = _ref.content,
      segment = _ref.segment,
      segmentData = _ref.segmentData,
      queuedSourceBuffer = _ref.queuedSourceBuffer;
  return Object(defer["a" /* defer */])(function () {
    if (segmentData === null) {
      return empty["a" /* EMPTY */];
    }

    var codec = content.representation.getMimeTypeString();
    var data = {
      initSegment: segmentData,
      chunk: null,
      timestampOffset: 0,
      appendWindow: [undefined, undefined],
      codec: codec
    };
    var inventoryInfos = Object(object_assign["a" /* default */])({
      segment: segment
    }, content);
    return appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, {
      data: data,
      inventoryInfos: inventoryInfos
    }).pipe(Object(map["a" /* map */])(function () {
      var buffered = queuedSourceBuffer.getBufferedRanges();
      return stream_events_generators.addedSegment(content, segment, buffered, segmentData);
    }));
  });
}
// CONCATENATED MODULE: ./src/core/stream/representation/push_media_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Push a given media segment (non-init segment) to a QueuedSourceBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */

function pushMediaSegment(_ref) {
  var clock$ = _ref.clock$,
      content = _ref.content,
      initSegmentData = _ref.initSegmentData,
      parsedSegment = _ref.parsedSegment,
      segment = _ref.segment,
      queuedSourceBuffer = _ref.queuedSourceBuffer;
  return Object(defer["a" /* defer */])(function () {
    if (parsedSegment.chunkData === null) {
      return empty["a" /* EMPTY */];
    }

    var chunkData = parsedSegment.chunkData,
        chunkInfos = parsedSegment.chunkInfos,
        chunkOffset = parsedSegment.chunkOffset,
        appendWindow = parsedSegment.appendWindow;
    var codec = content.representation.getMimeTypeString();
    var data = {
      initSegment: initSegmentData,
      chunk: chunkData,
      timestampOffset: chunkOffset,
      appendWindow: appendWindow,
      codec: codec
    };
    var estimatedStart;
    var estimatedDuration;

    if (chunkInfos !== null) {
      estimatedStart = chunkInfos.time / chunkInfos.timescale;
      estimatedDuration = chunkInfos.duration !== undefined ? chunkInfos.duration / chunkInfos.timescale : undefined;
    }

    var inventoryInfos = Object(object_assign["a" /* default */])({
      segment: segment,
      estimatedStart: estimatedStart,
      estimatedDuration: estimatedDuration
    }, content);
    return appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, {
      data: data,
      inventoryInfos: inventoryInfos
    }).pipe(Object(map["a" /* map */])(function () {
      var buffered = queuedSourceBuffer.getBufferedRanges();
      return stream_events_generators.addedSegment(content, segment, buffered, chunkData);
    }));
  });
}
// CONCATENATED MODULE: ./src/core/stream/representation/representation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create RepresentationStreams.
 *
 * A RepresentationStream downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */












/**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationStream observables can run on the same SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args
 * @returns {Observable}
 */

function RepresentationStream(_ref) {
  var bufferGoal$ = _ref.bufferGoal$,
      clock$ = _ref.clock$,
      content = _ref.content,
      knownStableBitrate$ = _ref.knownStableBitrate$,
      queuedSourceBuffer = _ref.queuedSourceBuffer,
      segmentFetcher = _ref.segmentFetcher,
      terminate$ = _ref.terminate$;
  var manifest = content.manifest,
      period = content.period,
      adaptation = content.adaptation,
      representation = content.representation;
  var bufferType = adaptation.type;
  var initSegment = representation.index.getInitSegment();
  /**
   * Saved initialization segment state for this representation.
   * `null` if the initialization segment hasn't been loaded yet.
   */

  var initSegmentObject = initSegment == null ? {
    initializationData: null,
    segmentProtections: [],
    initTimescale: undefined
  } : null;
  /** Segments queued for download in this RepresentationStream. */

  var downloadQueue = [];
  /** Emit to start/restart a downloading Queue. */

  var startDownloadingQueue$ = new ReplaySubject["a" /* ReplaySubject */](1);
  /** Emit when the RepresentationStream asks to re-check which segments are needed. */

  var reCheckNeededSegments$ = new Subject["a" /* Subject */]();
  /**
   * Keep track of the information about the pending segment request.
   * `null` if no segment request is pending in that RepresentationStream.
   */

  var currentSegmentRequest = null;
  var status$ = Object(combineLatest["a" /* combineLatest */])([clock$, bufferGoal$, terminate$.pipe(Object(take["a" /* take */])(1), Object(startWith["a" /* startWith */])(null)), reCheckNeededSegments$.pipe(Object(startWith["a" /* startWith */])(undefined))]).pipe(withLatestFrom(knownStableBitrate$), Object(map["a" /* map */])(function getCurrentStatus(_ref2) {
    var _ref2$ = _ref2[0],
        timing = _ref2$[0],
        bufferGoal = _ref2$[1],
        terminate = _ref2$[2],
        knownStableBitrate = _ref2[1];
    queuedSourceBuffer.synchronizeInventory();
    var neededRange = getWantedRange(period, timing, bufferGoal);
    var discontinuity = timing.stalled != null ? representation.index.checkDiscontinuity(timing.currentTime) : -1;
    var shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end);
    var neededSegments = [];

    if (!representation.index.isInitialized()) {
      if (initSegment === null) {
        log["a" /* default */].warn("Stream: Uninitialized index without an initialization segment");
      } else if (initSegmentObject !== null) {
        log["a" /* default */].warn("Stream: Uninitialized index with an already loaded " + "initialization segment");
      } else {
        neededSegments.push({
          segment: initSegment,
          priority: getPriorityForTime(period.start, timing)
        });
      }
    } else {
      neededSegments = getNeededSegments({
        content: content,
        currentPlaybackTime: timing.currentTime,
        knownStableBitrate: knownStableBitrate,
        neededRange: neededRange,
        queuedSourceBuffer: queuedSourceBuffer
      }).map(function (segment) {
        return {
          priority: getSegmentPriority(segment, timing),
          segment: segment
        };
      });

      if (neededSegments.length > 0 && initSegment !== null && initSegmentObject === null) {
        // prepend initialization segment
        var initSegmentPriority = neededSegments[0].priority;
        neededSegments = [{
          segment: initSegment,
          priority: initSegmentPriority
        }].concat(neededSegments);
      }
    }
    /**
     * `true` if the current Stream has loaded all the needed segments for
     * this Representation until the end of the Period.
     */


    var isFull;

    if (neededSegments.length > 0 || period.end == null) {
      // Either we still have segments to download or the current Period is
      // not yet ended: not full
      isFull = false;
    } else {
      var lastPosition = representation.index.getLastPosition();

      if (lastPosition === undefined) {
        // We do not know the end of this index.
        // If we reached the end of the period, check that all segments are
        // available.
        isFull = neededRange.end >= period.end && representation.index.isFinished();
      } else if (lastPosition === null) {
        // There is no available segment in the index currently. If the index
        // tells us it has finished generating new segments, we're done.
        isFull = representation.index.isFinished();
      } else {
        // We have a declared end. Check that our range went until the last
        // position available in the index. If that's the case and we're left
        // with no segments after filtering them, it means we already have
        // downloaded the last segments and have nothing left to do: full.
        var endOfRange = period.end != null ? Math.min(period.end, lastPosition) : lastPosition;
        isFull = neededRange.end >= endOfRange && representation.index.isFinished();
      }
    }

    return {
      discontinuity: discontinuity,
      isFull: isFull,
      terminate: terminate,
      neededSegments: neededSegments,
      shouldRefreshManifest: shouldRefreshManifest
    };
  }), Object(mergeMap["a" /* mergeMap */])(function handleStatus(status) {
    var neededSegments = status.neededSegments;
    var mostNeededSegment = neededSegments[0];

    if (status.terminate !== null) {
      downloadQueue = [];

      if (status.terminate.urgent) {
        log["a" /* default */].debug("Stream: urgent termination request, terminate.", bufferType);
        startDownloadingQueue$.complete(); // complete the downloading queue

        return Object(of["a" /* of */])(stream_events_generators.streamTerminating());
      } else if (currentSegmentRequest === null) {
        log["a" /* default */].debug("Stream: no request, terminate.", bufferType);
        startDownloadingQueue$.complete(); // complete the downloading queue

        return Object(of["a" /* of */])(stream_events_generators.streamTerminating());
      } else if (mostNeededSegment == null || currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
        log["a" /* default */].debug("Stream: cancel request and terminate.", bufferType);
        startDownloadingQueue$.next(); // interrupt the current request

        startDownloadingQueue$.complete(); // complete the downloading queue

        return Object(of["a" /* of */])(stream_events_generators.streamTerminating());
      } else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
        var _currentSegmentReques = currentSegmentRequest,
            request$ = _currentSegmentReques.request$;
        currentSegmentRequest.priority = mostNeededSegment.priority;
        segmentFetcher.updatePriority(request$, mostNeededSegment.priority);
      }

      log["a" /* default */].debug("Stream: terminate after request.", bufferType);
      return empty["a" /* EMPTY */];
    }

    var neededActions = [];

    if (status.discontinuity > 1) {
      var nextTime = status.discontinuity + 1;
      var gap = [status.discontinuity, nextTime];
      neededActions.push(stream_events_generators.discontinuityEncountered(gap, bufferType));
    }

    if (status.shouldRefreshManifest) {
      neededActions.push(stream_events_generators.needsManifestRefresh());
    }

    if (mostNeededSegment == null) {
      if (currentSegmentRequest !== null) {
        log["a" /* default */].debug("Stream: interrupt segment request.", bufferType);
      }

      downloadQueue = [];
      startDownloadingQueue$.next(); // (re-)start with an empty queue

      return Object(concat["a" /* concat */])(of["a" /* of */].apply(void 0, neededActions), status.isFull ? Object(of["a" /* of */])(stream_events_generators.fullStream(bufferType)) : empty["a" /* EMPTY */]);
    }

    if (currentSegmentRequest === null) {
      log["a" /* default */].debug("Stream: start downloading queue.", bufferType);
      downloadQueue = neededSegments;
      startDownloadingQueue$.next(); // restart the queue
    } else if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
      log["a" /* default */].debug("Stream: restart download queue.", bufferType);
      downloadQueue = neededSegments;
      startDownloadingQueue$.next(); // restart the queue
    } else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
      log["a" /* default */].debug("Stream: update request priority.", bufferType);
      var _currentSegmentReques2 = currentSegmentRequest,
          _request$ = _currentSegmentReques2.request$;
      currentSegmentRequest.priority = mostNeededSegment.priority;
      segmentFetcher.updatePriority(_request$, mostNeededSegment.priority);
    } else {
      log["a" /* default */].debug("Stream: update downloading queue", bufferType); // Update the previous queue to be all needed segments but the first one,
      // for which a request is already pending

      downloadQueue = neededSegments.slice().splice(1, neededSegments.length);
    }

    return Object(concat["a" /* concat */])(of["a" /* of */].apply(void 0, neededActions), Object(of["a" /* of */])(stream_events_generators.activeStream(bufferType)));
  }), takeWhile(function (e) {
    return e.type !== "stream-terminating";
  }, true));
  /**
   * Stream Queue:
   *   - download every segments queued sequentially
   *   - when a segment is loaded, append it to the SourceBuffer
   */

  var streamQueue$ = startDownloadingQueue$.pipe(Object(switchMap["a" /* switchMap */])(function () {
    return downloadQueue.length > 0 ? loadSegmentsFromQueue() : empty["a" /* EMPTY */];
  }), Object(mergeMap["a" /* mergeMap */])(onLoaderEvent));
  return Object(merge["a" /* merge */])(status$, streamQueue$).pipe(Object(share["a" /* share */])());
  /**
   * Request every Segment in the ``downloadQueue`` on subscription.
   * Emit the data of a segment when a request succeeded.
   *
   * Important side-effects:
   *   - Mutates `currentSegmentRequest` when doing and finishing a request.
   *   - Will emit from reCheckNeededSegments$ Subject when it's done.
   *
   * Might emit warnings when a request is retried.
   *
   * Throws when the request will not be retried (configuration or un-retryable
   * error).
   * @returns {Observable}
   */

  function loadSegmentsFromQueue() {
    var requestNextSegment$ = Object(defer["a" /* defer */])(function () {
      var currentNeededSegment = downloadQueue.shift();

      if (currentNeededSegment == null) {
        next_tick_default()(function () {
          reCheckNeededSegments$.next();
        });
        return empty["a" /* EMPTY */];
      }

      var segment = currentNeededSegment.segment,
          priority = currentNeededSegment.priority;
      var context = {
        manifest: manifest,
        period: period,
        adaptation: adaptation,
        representation: representation,
        segment: segment
      };
      var request$ = segmentFetcher.createRequest(context, priority);
      currentSegmentRequest = {
        segment: segment,
        priority: priority,
        request$: request$
      };
      return request$.pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
        switch (evt.type) {
          case "warning":
            return Object(of["a" /* of */])({
              type: "retry",
              value: {
                segment: segment,
                error: evt.value
              }
            });

          case "chunk-complete":
            currentSegmentRequest = null;
            return Object(of["a" /* of */])({
              type: "end-of-segment",
              value: {
                segment: segment
              }
            });

          case "interrupted":
            log["a" /* default */].info("Stream: segment request interrupted temporarly.", segment);
            return empty["a" /* EMPTY */];

          case "chunk":
            var initTimescale = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initTimescale;
            return evt.parse(initTimescale).pipe(Object(map["a" /* map */])(function (parserResponse) {
              return Object(object_assign["a" /* default */])({
                segment: segment
              }, parserResponse);
            }));

          case "ended":
            return requestNextSegment$;

          default:
            Object(assert_unreachable["a" /* default */])(evt);
        }
      }));
    });
    return requestNextSegment$.pipe(finalize(function () {
      currentSegmentRequest = null;
    }));
  }
  /**
   * React to event from `loadSegmentsFromQueue`.
   * @param {Object} evt
   * @returns {Observable}
   */


  function onLoaderEvent(evt) {
    var _a;

    switch (evt.type) {
      case "retry":
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
          type: "warning",
          value: evt.value.error
        }), Object(defer["a" /* defer */])(function () {
          var retriedSegment = evt.value.segment;
          var index = representation.index;

          if (index.isSegmentStillAvailable(retriedSegment) === false) {
            reCheckNeededSegments$.next();
          } else if (index.canBeOutOfSyncError(evt.value.error, retriedSegment)) {
            return Object(of["a" /* of */])(stream_events_generators.manifestMightBeOufOfSync());
          }

          return empty["a" /* EMPTY */]; // else, ignore.
        }));

      case "parsed-init-segment":
        initSegmentObject = evt.value;
        var protectedEvents$ = of["a" /* of */].apply(void 0, evt.value.segmentProtections.map(function (segmentProt) {
          return stream_events_generators.protectedSegment(segmentProt);
        }));
        var pushEvent$ = pushInitSegment({
          clock$: clock$,
          content: content,
          segment: evt.segment,
          segmentData: evt.value.initializationData,
          queuedSourceBuffer: queuedSourceBuffer
        });
        return Object(merge["a" /* merge */])(protectedEvents$, pushEvent$);

      case "parsed-segment":
        var initSegmentData = (_a = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initializationData) !== null && _a !== void 0 ? _a : null;
        return pushMediaSegment({
          clock$: clock$,
          content: content,
          initSegmentData: initSegmentData,
          parsedSegment: evt.value,
          segment: evt.segment,
          queuedSourceBuffer: queuedSourceBuffer
        });

      case "end-of-segment":
        {
          var segment = evt.value.segment;
          return queuedSourceBuffer.endOfSegment(Object(object_assign["a" /* default */])({
            segment: segment
          }, content)).pipe(Object(ignoreElements["a" /* ignoreElements */])());
        }

      default:
        Object(assert_unreachable["a" /* default */])(evt);
    }
  }
}
// CONCATENATED MODULE: ./src/core/stream/representation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var stream_representation = (RepresentationStream);
// CONCATENATED MODULE: ./src/core/stream/adaptation/create_representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create an "estimator$" Observable which will emit which Representation (from
 * the given `Adaptation`) is the best fit (see `IABREstimate` type definition)
 * corresponding to the current network and playback conditions.
 *
 * This function also returns two subjects that should be used to add feedback
 * helping the estimator to make its choices:
 *
 *   - `requestFeedback$`: Subject through which information about new requests
 *     and network metrics should be emitted.
 *
 *   - `streamFeedback$`: Subject through which stream-related events should be
 *      emitted.
 *
 * You can look at the types defined for both of those Subjects to have more
 * information on what data is expected. The idea is to provide as much data as
 * possible so the estimation is as adapted as possible.
 *
 * @param {Object} adaptation
 * @param {Object} abrManager
 * @param {Observable} clock$
 * @returns {Object}
 */

function createRepresentationEstimator(adaptation, abrManager, clock$) {
  var streamFeedback$ = new Subject["a" /* Subject */]();
  var requestFeedback$ = new Subject["a" /* Subject */]();
  var abrEvents$ = Object(merge["a" /* merge */])(streamFeedback$, requestFeedback$);
  /** Representations for which a `RepresentationStream` can be created. */

  var playableRepresentations = adaptation.getPlayableRepresentations();

  if (playableRepresentations.length <= 0) {
    var noRepErr = new media_error["a" /* default */]("NO_PLAYABLE_REPRESENTATION", "No Representation in the chosen " + "Adaptation can be played");
    throw noRepErr;
  }

  var estimator$ = abrManager.get$(adaptation.type, playableRepresentations, clock$, abrEvents$);
  return {
    estimator$: estimator$,
    streamFeedback$: streamFeedback$,
    requestFeedback$: requestFeedback$
  };
}
// CONCATENATED MODULE: ./src/core/stream/adaptation/adaptation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create `AdaptationStream`s.
 *
 * An `AdaptationStream` downloads and push segment for a single Adaptation
 * (e.g.  a single audio, video or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates a RepresentationStream, which will download and
 * push segments corresponding to a chosen Representation.
 */








/**
 * Create new AdaptationStream Observable, which task will be to download the
 * media data for a given Adaptation (i.e. "track").
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * After being subscribed to, it will start running and will emit various events
 * to report its current status.
 *
 * @param {Object} args
 * @returns {Observable}
 */

function AdaptationStream(_ref) {
  var abrManager = _ref.abrManager,
      clock$ = _ref.clock$,
      content = _ref.content,
      options = _ref.options,
      queuedSourceBuffer = _ref.queuedSourceBuffer,
      segmentFetcherCreator = _ref.segmentFetcherCreator,
      wantedBufferAhead$ = _ref.wantedBufferAhead$;
  var directManualBitrateSwitching = options.manualBitrateSwitchingMode === "direct";
  var manifest = content.manifest,
      period = content.period,
      adaptation = content.adaptation;
  /**
   * The buffer goal ratio base itself on the value given by `wantedBufferAhead`
   * to determine a more dynamic buffer goal for a given Representation.
   *
   * It can help in cases such as : the current browser has issues with
   * buffering and tells us that we should try to bufferize less data :
   * https://developers.google.com/web/updates/2017/10/quotaexceedederror
   */

  var bufferGoalRatioMap = {};

  var _createRepresentation = createRepresentationEstimator(adaptation, abrManager, clock$),
      estimator$ = _createRepresentation.estimator$,
      requestFeedback$ = _createRepresentation.requestFeedback$,
      streamFeedback$ = _createRepresentation.streamFeedback$;
  /** Allows the `RepresentationStream` to easily fetch media segments. */


  var segmentFetcher = segmentFetcherCreator.createSegmentFetcher(adaptation.type, requestFeedback$);
  /**
   * Emits each time an estimate is made through the `abrEstimate$` Observable,
   * starting with the last one.
   * This allows to easily rely on that value in inner Observables which might also
   * need the last already-considered value.
   */

  var lastEstimate$ = new BehaviorSubject_BehaviorSubject(null);
  /** Emits abr estimates on Subscription. */

  var abrEstimate$ = estimator$.pipe(Object(tap["a" /* tap */])(function (estimate) {
    lastEstimate$.next(estimate);
  }), Object(defer_subscriptions["a" /* default */])(), Object(share["a" /* share */])());
  /** Emit at each bitrate estimate done by the ABRManager. */

  var bitrateEstimate$ = abrEstimate$.pipe(Object(filter["a" /* filter */])(function (_ref2) {
    var bitrate = _ref2.bitrate;
    return bitrate != null;
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (old, current) {
    return old.bitrate === current.bitrate;
  }), Object(map["a" /* map */])(function (_ref3) {
    var bitrate = _ref3.bitrate;
    log["a" /* default */].debug("Stream: new " + adaptation.type + " bitrate estimate", bitrate);
    return stream_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
  }));
  /** Recursively create `RepresentationStream`s according to the last estimate. */

  var representationStreams$ = abrEstimate$.pipe(exhaustMap(function (estimate, i) {
    return recursivelyCreateRepresentationStreams(estimate, i === 0);
  }));
  return Object(merge["a" /* merge */])(representationStreams$, bitrateEstimate$);
  /**
   * Create `RepresentationStream`s starting with the Representation indicated in
   * `fromEstimate` argument.
   * Each time a new estimate is made, this function will create a new
   * `RepresentationStream` corresponding to that new estimate.
   * @param {Object} fromEstimate - The first estimate we should start with
   * @param {boolean} isFirstEstimate - Whether this is the first time we're
   * creating a RepresentationStream in the corresponding `AdaptationStream`.
   * This is important because manual quality switches might need a full reload
   * of the MediaSource _except_ if we are talking about the first quality chosen.
   * @returns {Observable}
   */

  function recursivelyCreateRepresentationStreams(fromEstimate, isFirstEstimate) {
    var representation = fromEstimate.representation; // A manual bitrate switch might need an immediate feedback.
    // To do that properly, we need to reload the MediaSource

    if (directManualBitrateSwitching && fromEstimate.manual && !isFirstEstimate) {
      return clock$.pipe(Object(map["a" /* map */])(function (t) {
        return stream_events_generators.needsMediaSourceReload(period, t);
      }));
    }
    /**
     * Emit when the current RepresentationStream should be terminated to make
     * place for a new one (e.g. when switching quality).
     */


    var terminateCurrentStream$ = lastEstimate$.pipe(Object(filter["a" /* filter */])(function (newEstimate) {
      return newEstimate === null || newEstimate.representation.id !== representation.id || newEstimate.manual && !fromEstimate.manual;
    }), Object(take["a" /* take */])(1), Object(map["a" /* map */])(function (newEstimate) {
      if (newEstimate === null) {
        log["a" /* default */].info("Stream: urgent Representation termination", adaptation.type);
        return {
          urgent: true
        };
      }

      if (newEstimate.urgent) {
        log["a" /* default */].info("Stream: urgent Representation switch", adaptation.type);
        return {
          urgent: true
        };
      } else {
        log["a" /* default */].info("Stream: slow Representation switch", adaptation.type);
        return {
          urgent: false
        };
      }
    }));
    /**
     * Bitrate higher or equal to this value should not be replaced by segments of
     * better quality.
     * undefined means everything can potentially be replaced
     */

    var knownStableBitrate$ = lastEstimate$.pipe(Object(map["a" /* map */])(function (estimate) {
      return estimate === null ? undefined : estimate.knownStableBitrate;
    }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
    var representationChange$ = Object(of["a" /* of */])(stream_events_generators.representationChange(adaptation.type, period, representation));
    return Object(concat["a" /* concat */])(representationChange$, createRepresentationStream(representation, terminateCurrentStream$, knownStableBitrate$)).pipe(Object(tap["a" /* tap */])(function (evt) {
      if (evt.type === "representationChange" || evt.type === "added-segment") {
        return streamFeedback$.next(evt);
      }
    }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "stream-terminating") {
        var lastEstimate = lastEstimate$.getValue();

        if (lastEstimate === null) {
          return empty["a" /* EMPTY */];
        }

        return recursivelyCreateRepresentationStreams(lastEstimate, false);
      }

      return Object(of["a" /* of */])(evt);
    }));
  }
  /**
   * Create and returns a new RepresentationStream Observable, linked to the
   * given Representation.
   * @param {Representation} representation
   * @returns {Observable}
   */


  function createRepresentationStream(representation, terminateCurrentStream$, knownStableBitrate$) {
    return Object(defer["a" /* defer */])(function () {
      var oldBufferGoalRatio = bufferGoalRatioMap[representation.id];
      var bufferGoalRatio = oldBufferGoalRatio != null ? oldBufferGoalRatio : 1;
      bufferGoalRatioMap[representation.id] = bufferGoalRatio;
      var bufferGoal$ = wantedBufferAhead$.pipe(Object(map["a" /* map */])(function (wba) {
        return wba * bufferGoalRatio;
      }));
      log["a" /* default */].info("Stream: changing representation", adaptation.type, representation);
      return stream_representation({
        clock$: clock$,
        content: {
          representation: representation,
          adaptation: adaptation,
          period: period,
          manifest: manifest
        },
        queuedSourceBuffer: queuedSourceBuffer,
        segmentFetcher: segmentFetcher,
        terminate$: terminateCurrentStream$,
        bufferGoal$: bufferGoal$,
        knownStableBitrate$: knownStableBitrate$
      }).pipe(Object(catchError["a" /* catchError */])(function (err) {
        var formattedError = formatError(err, {
          defaultCode: "NONE",
          defaultReason: "Unknown `RepresentationStream` error"
        });

        if (formattedError.code === "BUFFER_FULL_ERROR") {
          var wantedBufferAhead = wantedBufferAhead$.getValue();
          var lastBufferGoalRatio = bufferGoalRatio;

          if (lastBufferGoalRatio <= 0.25 || wantedBufferAhead * lastBufferGoalRatio <= 2) {
            throw formattedError;
          }

          bufferGoalRatioMap[representation.id] = lastBufferGoalRatio - 0.25;
          return createRepresentationStream(representation, terminateCurrentStream$, knownStableBitrate$);
        }

        throw formattedError;
      }));
    });
  }
}
// CONCATENATED MODULE: ./src/core/stream/adaptation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var stream_adaptation = (AdaptationStream);
// CONCATENATED MODULE: ./src/core/stream/period/create_empty_adaptation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create empty AdaptationStream Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 * @param {Observable} streamClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */

function createEmptyAdaptationStream(streamClock$, wantedBufferAhead$, bufferType, content) {
  var period = content.period;
  return Object(combineLatest["a" /* combineLatest */])([streamClock$, wantedBufferAhead$]).pipe(Object(filter["a" /* filter */])(function (_ref) {
    var clockTick = _ref[0],
        wantedBufferAhead = _ref[1];
    return period.end != null && clockTick.currentTime + wantedBufferAhead >= period.end;
  }), Object(map["a" /* map */])(function () {
    log["a" /* default */].debug("Stream: full \"empty\" AdaptationStream", bufferType);
    return {
      type: "full-stream",
      value: {
        bufferType: bufferType
      }
    };
  }));
}
// CONCATENATED MODULE: ./src/core/stream/period/get_adaptation_switch_strategy.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ADAPTATION_SWITCH_BUFFER_PADDINGS = config["a" /* default */].ADAPTATION_SWITCH_BUFFER_PADDINGS;
/**
 * Find out what to do when switching adaptation, based on the current
 * situation.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @param {Object} clockTick
 * @returns {Object}
 */

function getAdaptationSwitchStrategy(queuedSourceBuffer, period, adaptation, clockTick) {
  var buffered = queuedSourceBuffer.getBufferedRanges();

  if (buffered.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }

  var bufferedRanges = Object(ranges["a" /* convertToRanges */])(buffered);
  var start = period.start;
  var end = period.end == null ? Infinity : period.end;
  var intersection = Object(ranges["l" /* keepRangeIntersection */])(bufferedRanges, [{
    start: start,
    end: end
  }]);

  if (intersection.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  } // remove from that intersection what we know to be the right Adaptation


  var adaptationInBuffer = getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation);
  var currentTime = clockTick.currentTime;

  if (adaptation.type === "video" && clockTick.readyState > 1 && Object(ranges["j" /* isTimeInRange */])({
    start: start,
    end: end
  }, currentTime) && Object(ranges["k" /* isTimeInRanges */])(bufferedRanges, currentTime) && !Object(ranges["k" /* isTimeInRanges */])(adaptationInBuffer, currentTime)) {
    return {
      type: "needs-reload",
      value: undefined
    };
  }

  var unwantedData = Object(ranges["b" /* excludeFromRanges */])(intersection, adaptationInBuffer);
  var bufferType = adaptation.type;
  var paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before;

  if (paddingBefore == null) {
    paddingBefore = 0;
  }

  var paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after;

  if (paddingAfter == null) {
    paddingAfter = 0;
  }

  var toRemove = Object(ranges["b" /* excludeFromRanges */])(unwantedData, [{
    start: Math.max(currentTime - paddingBefore, start),
    end: Math.min(currentTime + paddingAfter, end)
  }]);
  return toRemove.length > 0 ? {
    type: "clean-buffer",
    value: toRemove
  } : {
    type: "continue",
    value: undefined
  };
}
/**
 * Returns buffered ranges of what we know correspond to the given `adaptation`
 * in the SourceBuffer.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @returns {Array.<Object>}
 */

function getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation) {
  queuedSourceBuffer.synchronizeInventory();
  return queuedSourceBuffer.getInventory().reduce(function (acc, chunk) {
    if (chunk.infos.period.id !== period.id || chunk.infos.adaptation.id !== adaptation.id) {
      return acc;
    }

    var bufferedStart = chunk.bufferedStart,
        bufferedEnd = chunk.bufferedEnd;

    if (bufferedStart === undefined || bufferedEnd === undefined) {
      return acc;
    }

    acc.push({
      start: bufferedStart,
      end: bufferedEnd
    });
    return acc;
  }, []);
}
// CONCATENATED MODULE: ./src/core/stream/period/period_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Create single PeriodStream Observable:
 *   - Lazily create (or reuse) a SourceBuffer for the given type.
 *   - Create a Stream linked to an Adaptation each time it changes, to
 *     download and append the corresponding Segments in the SourceBuffer.
 *   - Announce when the Stream is full or is awaiting new Segments through
 *     events
 * @param {Object} args
 * @returns {Observable}
 */

function PeriodStream(_ref) {
  var abrManager = _ref.abrManager,
      bufferType = _ref.bufferType,
      clock$ = _ref.clock$,
      content = _ref.content,
      garbageCollectors = _ref.garbageCollectors,
      segmentFetcherCreator = _ref.segmentFetcherCreator,
      sourceBuffersStore = _ref.sourceBuffersStore,
      options = _ref.options,
      wantedBufferAhead$ = _ref.wantedBufferAhead$;
  var period = content.period; // Emits the chosen Adaptation for the current type.
  // `null` when no Adaptation is chosen (e.g. no subtitles)

  var adaptation$ = new ReplaySubject["a" /* ReplaySubject */](1);
  return adaptation$.pipe(Object(switchMap["a" /* switchMap */])(function (adaptation) {
    if (adaptation === null) {
      log["a" /* default */].info("Stream: Set no " + bufferType + " Adaptation", period);
      var sourceBufferStatus = sourceBuffersStore.getStatus(bufferType);
      var cleanBuffer$;

      if (sourceBufferStatus.type === "initialized") {
        log["a" /* default */].info("Stream: Clearing previous " + bufferType + " SourceBuffer");

        if (source_buffers.isNative(bufferType)) {
          return clock$.pipe(Object(map["a" /* map */])(function (tick) {
            return stream_events_generators.needsMediaSourceReload(period, tick);
          }));
        }

        cleanBuffer$ = sourceBufferStatus.value.removeBuffer(period.start, period.end == null ? Infinity : period.end);
      } else {
        if (sourceBufferStatus.type === "uninitialized") {
          sourceBuffersStore.disableSourceBuffer(bufferType);
        }

        cleanBuffer$ = Object(of["a" /* of */])(null);
      }

      return Object(concat["a" /* concat */])(cleanBuffer$.pipe(Object(mapTo["a" /* mapTo */])(stream_events_generators.adaptationChange(bufferType, null, period))), createEmptyAdaptationStream(clock$, wantedBufferAhead$, bufferType, {
        period: period
      }));
    }

    if (source_buffers.isNative(bufferType) && sourceBuffersStore.getStatus(bufferType).type === "disabled") {
      return clock$.pipe(Object(map["a" /* map */])(function (tick) {
        return stream_events_generators.needsMediaSourceReload(period, tick);
      }));
    }

    log["a" /* default */].info("Stream: Updating " + bufferType + " adaptation", adaptation, period);
    var newStream$ = clock$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (tick) {
      var qSourceBuffer = createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options);
      var strategy = getAdaptationSwitchStrategy(qSourceBuffer, period, adaptation, tick);

      if (strategy.type === "needs-reload") {
        return Object(of["a" /* of */])(stream_events_generators.needsMediaSourceReload(period, tick));
      }

      var cleanBuffer$ = strategy.type === "clean-buffer" ? concat["a" /* concat */].apply(void 0, strategy.value.map(function (_ref2) {
        var start = _ref2.start,
            end = _ref2.end;
        return qSourceBuffer.removeBuffer(start, end);
      })).pipe(Object(ignoreElements["a" /* ignoreElements */])()) : empty["a" /* EMPTY */];
      var bufferGarbageCollector$ = garbageCollectors.get(qSourceBuffer);
      var adaptationStream$ = createAdaptationStream(adaptation, qSourceBuffer);
      return sourceBuffersStore.waitForUsableSourceBuffers().pipe(Object(mergeMap["a" /* mergeMap */])(function () {
        return Object(concat["a" /* concat */])(cleanBuffer$, Object(merge["a" /* merge */])(adaptationStream$, bufferGarbageCollector$));
      }));
    }));
    return Object(concat["a" /* concat */])(Object(of["a" /* of */])(stream_events_generators.adaptationChange(bufferType, adaptation, period)), newStream$);
  }), Object(startWith["a" /* startWith */])(stream_events_generators.periodStreamReady(bufferType, period, adaptation$)));
  /**
   * @param {Object} adaptation
   * @param {Object} qSourceBuffer
   * @returns {Observable}
   */

  function createAdaptationStream(adaptation, qSourceBuffer) {
    var manifest = content.manifest;
    var adaptationStreamClock$ = clock$.pipe(Object(map["a" /* map */])(function (tick) {
      var buffered = qSourceBuffer.getBufferedRanges();
      return Object(object_assign["a" /* default */])({}, tick, {
        bufferGap: Object(ranges["d" /* getLeftSizeOfRange */])(buffered, tick.currentTime)
      });
    }));
    return stream_adaptation({
      abrManager: abrManager,
      clock$: adaptationStreamClock$,
      content: {
        manifest: manifest,
        period: period,
        adaptation: adaptation
      },
      options: options,
      queuedSourceBuffer: qSourceBuffer,
      segmentFetcherCreator: segmentFetcherCreator,
      wantedBufferAhead$: wantedBufferAhead$
    }).pipe(Object(catchError["a" /* catchError */])(function (error) {
      // Stream linked to a non-native SourceBuffer should not impact the
      // stability of the player. ie: if a text buffer sends an error, we want
      // to continue playing without any subtitles
      if (!source_buffers.isNative(bufferType)) {
        log["a" /* default */].error("Stream: " + bufferType + " Stream crashed. Aborting it.", error);
        sourceBuffersStore.disposeSourceBuffer(bufferType);
        var formattedError = formatError(error, {
          defaultCode: "NONE",
          defaultReason: "Unknown `AdaptationStream` error"
        });
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])(stream_events_generators.warning(formattedError)), createEmptyAdaptationStream(clock$, wantedBufferAhead$, bufferType, {
          period: period
        }));
      }

      log["a" /* default */].error("Stream: " + bufferType + " Stream crashed. Stopping playback.", error);
      throw error;
    }));
  }
}
/**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */

function createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options) {
  var sourceBufferStatus = sourceBuffersStore.getStatus(bufferType);

  if (sourceBufferStatus.type === "initialized") {
    log["a" /* default */].info("Stream: Reusing a previous SourceBuffer for the type", bufferType);
    return sourceBufferStatus.value;
  }

  var codec = getFirstDeclaredMimeType(adaptation);
  var sbOptions = bufferType === "text" ? options.textTrackOptions : undefined;
  return sourceBuffersStore.createSourceBuffer(bufferType, codec, sbOptions);
}
/**
 * Get mime-type string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */


function getFirstDeclaredMimeType(adaptation) {
  var representations = adaptation.representations;

  if (representations[0] == null) {
    return "";
  }

  return representations[0].getMimeTypeString();
}
// CONCATENATED MODULE: ./src/core/stream/period/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var stream_period = (PeriodStream);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(240);

// CONCATENATED MODULE: ./src/core/stream/orchestrator/active_period_emitter.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a RepresentationStream associated for every defined BUFFER_TYPES.
 *
 * Emit null if no Period can be considered active currently.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video
 * RepresentationStream.
 *
 * If we are missing a or multiple PeriodStreams in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodStream. As every PeriodStream is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodStream$ - Emit PeriodStream information when
 * one is added.
 * @param {Observable} removePeriodStream$ - Emit PeriodStream information when
 * one is removed.
 * @returns {Observable}
 */

function ActivePeriodEmitter(buffers$) {
  var numberOfStreams = buffers$.length;
  return merge["a" /* merge */].apply(void 0, buffers$).pipe( // not needed to filter, this is an optim
  Object(filter["a" /* filter */])(function (_ref) {
    var type = _ref.type;
    return type === "periodStreamCleared" || type === "adaptationChange" || type === "representationChange";
  }), Object(scan["a" /* scan */])(function (acc, evt) {
    switch (evt.type) {
      case "periodStreamCleared":
        {
          var _evt$value = evt.value,
              period = _evt$value.period,
              type = _evt$value.type;
          var currentInfos = acc[period.id];

          if (currentInfos != null && currentInfos.buffers.has(type)) {
            currentInfos.buffers["delete"](type);

            if (currentInfos.buffers.size === 0) {
              delete acc[period.id];
            }
          }
        }
        break;

      case "adaptationChange":
        {
          // `adaptationChange` with a null Adaptation will not lead to a
          // `representationChange` event
          if (evt.value.adaptation != null) {
            return acc;
          }
        }

      case "representationChange":
        {
          var _evt$value2 = evt.value,
              _period = _evt$value2.period,
              _type = _evt$value2.type;
          var _currentInfos = acc[_period.id];

          if (_currentInfos != null && !_currentInfos.buffers.has(_type)) {
            _currentInfos.buffers.add(_type);
          } else {
            var bufferSet = new Set();
            bufferSet.add(_type);
            acc[_period.id] = {
              period: _period,
              buffers: bufferSet
            };
          }
        }
        break;
    }

    return acc;
  }, {}), Object(map["a" /* map */])(function (list) {
    var activePeriodIDs = Object.keys(list);
    var completePeriods = [];

    for (var i = 0; i < activePeriodIDs.length; i++) {
      var periodInfos = list[activePeriodIDs[i]];

      if (periodInfos != null && periodInfos.buffers.size === numberOfStreams) {
        completePeriods.push(periodInfos.period);
      }
    }

    return completePeriods.reduce(function (acc, period) {
      if (acc == null) {
        return period;
      }

      return period.start < acc.start ? period : acc;
    }, null);
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (a, b) {
    return a == null && b == null || a != null && b != null && a.id === b.id;
  }));
}
// CONCATENATED MODULE: ./src/core/stream/orchestrator/are_streams_complete.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns an Observable which emits ``true`` when all PeriodStreams given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodStream for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodStream in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodStream for a given type means that every
 * segments needed for this Stream have been downloaded.
 *
 * When the Observable returned here emits, every Stream are finished.
 * @param {...Observable} streams
 * @returns {Observable}
 */

function areStreamsComplete() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  /**
   * Array of Observables linked to the Array of Streams which emit:
   *   - true when the corresponding Stream is considered _complete_.
   *   - false when the corresponding Stream is considered _active_.
   * @type {Array.<Observable>}
   */
  var isCompleteArray = streams.map(function (stream) {
    return stream.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "complete-stream" || evt.type === "active-stream";
    }), Object(map["a" /* map */])(function (evt) {
      return evt.type === "complete-stream";
    }), Object(startWith["a" /* startWith */])(false), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
  });
  return Object(combineLatest["a" /* combineLatest */])(isCompleteArray).pipe(Object(map["a" /* map */])(function (areComplete) {
    return areComplete.every(function (isComplete) {
      return isComplete;
    });
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
// CONCATENATED MODULE: ./src/core/stream/orchestrator/get_blacklisted_ranges.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the buffered ranges which hold the given content.
 * Returns the whole buffered ranges if some of it is unknown.
 * @param {Object} queuedSourceBuffer
 * @param {Array.<Object>} contents
 * @returns {Array.<Object>}
 */

function getBlacklistedRanges(queuedSourceBuffer, contents) {
  queuedSourceBuffer.synchronizeInventory();
  var accumulator = [];
  var inventory = queuedSourceBuffer.getInventory();

  var _loop = function _loop(i) {
    var chunk = inventory[i];
    var hasContent = contents.some(function (content) {
      return chunk.infos.period.id === content.period.id && chunk.infos.adaptation.id === content.adaptation.id && chunk.infos.representation.id === content.representation.id;
    });

    if (hasContent) {
      var bufferedStart = chunk.bufferedStart,
          bufferedEnd = chunk.bufferedEnd;

      if (bufferedStart === undefined || bufferedEnd === undefined) {
        log["a" /* default */].warn("SO: No buffered start or end found from a segment.");
        var buffered = queuedSourceBuffer.getBufferedRanges();
        var len = buffered.length;

        if (len === 0) {
          return {
            v: []
          };
        }

        return {
          v: [{
            start: buffered.start(0),
            end: buffered.end(len - 1)
          }]
        };
      }

      var previousLastElement = accumulator[accumulator.length - 1];

      if (previousLastElement !== undefined && previousLastElement.end === bufferedStart) {
        previousLastElement.end = bufferedEnd;
      } else {
        accumulator.push({
          start: bufferedStart,
          end: bufferedEnd
        });
      }
    }
  };

  for (var i = 0; i < inventory.length; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return accumulator;
}
// CONCATENATED MODULE: ./src/core/stream/orchestrator/stream_orchestrator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















var MAXIMUM_MAX_BUFFER_AHEAD = config["a" /* default */].MAXIMUM_MAX_BUFFER_AHEAD,
    MAXIMUM_MAX_BUFFER_BEHIND = config["a" /* default */].MAXIMUM_MAX_BUFFER_BEHIND;
/**
 * Create and manage the various Stream Observables needed for the content to
 * play:
 *
 *   - Create or dispose SourceBuffers depending on the chosen Adaptations.
 *
 *   - Push the right segments to those SourceBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Streams for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit various events to notify of its health and issues
 *
 * Here multiple Streams can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy Streams as they are needed.
 * @param {Object} content
 * @param {Observable} clock$ - Emit position information
 * @param {Object} abrManager - Emit bitrate estimates and best Representation
 * to play.
 * @param {Object} sourceBuffersStore - Will be used to lazily create
 * SourceBuffer instances associated with the current content.
 * @param {Object} segmentFetcherCreator - Allow to download segments.
 * @param {Object} options
 * @returns {Observable}
 */

function StreamOrchestrator(content, clock$, abrManager, sourceBuffersStore, segmentFetcherCreator, options) {
  var manifest = content.manifest,
      initialPeriod = content.initialPeriod;
  var maxBufferAhead$ = options.maxBufferAhead$,
      maxBufferBehind$ = options.maxBufferBehind$,
      wantedBufferAhead$ = options.wantedBufferAhead$; // Keep track of a unique BufferGarbageCollector created per
  // QueuedSourceBuffer.

  var garbageCollectors = new WeakMapMemory(function (qSourceBuffer) {
    var bufferType = qSourceBuffer.bufferType;
    var defaultMaxBehind = MAXIMUM_MAX_BUFFER_BEHIND[bufferType] != null ? MAXIMUM_MAX_BUFFER_BEHIND[bufferType] : Infinity;
    var defaultMaxAhead = MAXIMUM_MAX_BUFFER_AHEAD[bufferType] != null ? MAXIMUM_MAX_BUFFER_AHEAD[bufferType] : Infinity;
    return BufferGarbageCollector({
      queuedSourceBuffer: qSourceBuffer,
      clock$: clock$.pipe(Object(map["a" /* map */])(function (tick) {
        return tick.currentTime;
      })),
      maxBufferBehind$: maxBufferBehind$.pipe(Object(map["a" /* map */])(function (val) {
        return Math.min(val, defaultMaxBehind);
      })),
      maxBufferAhead$: maxBufferAhead$.pipe(Object(map["a" /* map */])(function (val) {
        return Math.min(val, defaultMaxAhead);
      }))
    });
  }); // trigger warnings when the wanted time is before or after the manifest's
  // segments

  var outOfManifest$ = clock$.pipe(Object(filter_map["a" /* default */])(function (_ref) {
    var currentTime = _ref.currentTime,
        wantedTimeOffset = _ref.wantedTimeOffset;
    var position = wantedTimeOffset + currentTime;

    if (position < manifest.getMinimumPosition()) {
      var warning = new media_error["a" /* default */]("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the " + "earliest time announced in the Manifest.");
      return stream_events_generators.warning(warning);
    } else if (position > manifest.getMaximumPosition()) {
      var _warning = new media_error["a" /* default */]("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest " + "time announced in the Manifest.");

      return stream_events_generators.warning(_warning);
    }

    return null;
  }, null));
  var bufferTypes = sourceBuffersStore.getBufferTypes(); // Every PeriodStreams for every possible types

  var streamsArray = bufferTypes.map(function (bufferType) {
    return manageEveryStreams(bufferType, initialPeriod).pipe(Object(defer_subscriptions["a" /* default */])(), Object(share["a" /* share */])());
  }); // Emits the activePeriodChanged events every time the active Period changes.

  var activePeriodChanged$ = ActivePeriodEmitter(streamsArray).pipe(Object(filter["a" /* filter */])(function (period) {
    return period != null;
  }), Object(map["a" /* map */])(function (period) {
    log["a" /* default */].info("Stream: New active period", period);
    return stream_events_generators.activePeriodChanged(period);
  })); // Emits an "end-of-stream" event once every PeriodStream are complete.
  // Emits a 'resume-stream" when it's not

  var endOfStream$ = areStreamsComplete.apply(void 0, streamsArray).pipe(Object(map["a" /* map */])(function (areComplete) {
    return areComplete ? stream_events_generators.endOfStream() : stream_events_generators.resumeStream();
  }));
  return merge["a" /* merge */].apply(void 0, streamsArray.concat([activePeriodChanged$, endOfStream$, outOfManifest$]));
  /**
   * Manage creation and removal of Streams for every Periods for a given type.
   *
   * Works by creating consecutive Streams through the
   * `manageConsecutivePeriodStreams` function, and restarting it when the clock
   * goes out of the bounds of these Streams.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @returns {Observable}
   */

  function manageEveryStreams(bufferType, basePeriod) {
    // Each Period for which there is currently a Stream, chronologically
    var periodList = new sorted_list_SortedList(function (a, b) {
      return a.start - b.start;
    });
    var destroyStreams$ = new Subject["a" /* Subject */](); // When set to `true`, all the currently active PeriodStream will be destroyed
    // and re-created from the new current position if we detect it to be out of
    // their bounds.
    // This is set to false when we're in the process of creating the first
    // PeriodStream, to avoid interferences while no PeriodStream is available.

    var enableOutOfBoundsCheck = false;
    /**
     * @param {Object} period
     * @returns {Observable}
     */

    function launchConsecutiveStreamsForPeriod(period) {
      return manageConsecutivePeriodStreams(bufferType, period, destroyStreams$).pipe(Object(filter_map["a" /* default */])(function (message) {
        switch (message.type) {
          case "needs-media-source-reload":
            // Only reload the MediaSource when the more immediately required
            // Period is the one asking for it
            var firstPeriod = periodList.head();

            if (firstPeriod === undefined || firstPeriod.id !== message.value.period.id) {
              return null;
            }

            break;

          case "periodStreamReady":
            enableOutOfBoundsCheck = true;
            periodList.add(message.value.period);
            break;

          case "periodStreamCleared":
            periodList.removeElement(message.value.period);
            break;
        }

        return message;
      }, null), Object(share["a" /* share */])());
    }
    /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */


    function isOutOfPeriodList(time) {
      var head = periodList.head();
      var last = periodList.last();

      if (head == null || last == null) {
        // if no period
        return true;
      }

      return head.start > time || (last.end == null ? Infinity : last.end) < time;
    } // Restart the current Stream when the wanted time is in another period
    // than the ones already considered


    var restartStreamsWhenOutOfBounds$ = clock$.pipe(Object(filter["a" /* filter */])(function (_ref2) {
      var currentTime = _ref2.currentTime,
          wantedTimeOffset = _ref2.wantedTimeOffset;
      return enableOutOfBoundsCheck && manifest.getPeriodForTime(wantedTimeOffset + currentTime) !== undefined && isOutOfPeriodList(wantedTimeOffset + currentTime);
    }), Object(tap["a" /* tap */])(function (_ref3) {
      var currentTime = _ref3.currentTime,
          wantedTimeOffset = _ref3.wantedTimeOffset;
      log["a" /* default */].info("SO: Current position out of the bounds of the active periods," + "re-creating Streams.", bufferType, currentTime + wantedTimeOffset);
      enableOutOfBoundsCheck = false;
      destroyStreams$.next();
    }), Object(mergeMap["a" /* mergeMap */])(function (_ref4) {
      var currentTime = _ref4.currentTime,
          wantedTimeOffset = _ref4.wantedTimeOffset;
      var newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);

      if (newInitialPeriod == null) {
        throw new media_error["a" /* default */]("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
      }

      return launchConsecutiveStreamsForPeriod(newInitialPeriod);
    }));
    var handleDecipherabilityUpdate$ = Object(event_emitter["b" /* fromEvent */])(manifest, "decipherabilityUpdate").pipe(Object(mergeMap["a" /* mergeMap */])(function (updates) {
      var sourceBufferStatus = sourceBuffersStore.getStatus(bufferType);
      var hasType = updates.some(function (update) {
        return update.adaptation.type === bufferType;
      });

      if (!hasType || sourceBufferStatus.type !== "initialized") {
        return empty["a" /* EMPTY */]; // no need to stop the current Streams.
      }

      var queuedSourceBuffer = sourceBufferStatus.value;
      var rangesToClean = getBlacklistedRanges(queuedSourceBuffer, updates);
      enableOutOfBoundsCheck = false;
      destroyStreams$.next();
      return concat["a" /* concat */].apply(void 0, rangesToClean.map(function (_ref5) {
        var start = _ref5.start,
            end = _ref5.end;
        return queuedSourceBuffer.removeBuffer(start, end).pipe(Object(ignoreElements["a" /* ignoreElements */])());
      }).concat([clock$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (lastTick) {
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])(stream_events_generators.needsDecipherabilityFlush(lastTick)), Object(defer["a" /* defer */])(function () {
          var lastPosition = lastTick.currentTime + lastTick.wantedTimeOffset;
          var newInitialPeriod = manifest.getPeriodForTime(lastPosition);

          if (newInitialPeriod == null) {
            throw new media_error["a" /* default */]("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
          }

          return launchConsecutiveStreamsForPeriod(newInitialPeriod);
        }));
      }))]));
    }));
    return Object(merge["a" /* merge */])(restartStreamsWhenOutOfBounds$, handleDecipherabilityUpdate$, launchConsecutiveStreamsForPeriod(basePeriod));
  }
  /**
   * Create lazily consecutive PeriodStreams:
   *
   * It first creates the PeriodStream for `basePeriod` and - once it becomes
   * full - automatically creates the next chronological one.
   * This process repeats until the PeriodStream linked to the last Period is
   * full.
   *
   * If an "old" PeriodStream becomes active again, it destroys all PeriodStream
   * coming after it (from the last chronological one to the first).
   *
   * To clean-up PeriodStreams, each one of them are also automatically
   * destroyed once the clock anounce a time superior or equal to the end of
   * the concerned Period.
   *
   * A "periodStreamReady" event is sent each times a new PeriodStream is
   * created. The first one (for `basePeriod`) should be sent synchronously on
   * subscription.
   *
   * A "periodStreamCleared" event is sent each times a PeriodStream is
   * destroyed.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Observable} destroy$ - Emit when/if all created Streams from this
   * point should be destroyed.
   * @returns {Observable}
   */


  function manageConsecutivePeriodStreams(bufferType, basePeriod, destroy$) {
    log["a" /* default */].info("SO: Creating new Stream for", bufferType, basePeriod); // Emits the Period of the next Period Stream when it can be created.

    var createNextPeriodStream$ = new Subject["a" /* Subject */](); // Emits when the Streams for the next Periods should be destroyed, if
    // created.

    var destroyNextStreams$ = new Subject["a" /* Subject */](); // Emits when the current position goes over the end of the current Stream.

    var endOfCurrentStream$ = clock$.pipe(Object(filter["a" /* filter */])(function (_ref6) {
      var currentTime = _ref6.currentTime,
          wantedTimeOffset = _ref6.wantedTimeOffset;
      return basePeriod.end != null && currentTime + wantedTimeOffset >= basePeriod.end;
    })); // Create Period Stream for the next Period.

    var nextPeriodStream$ = createNextPeriodStream$.pipe(exhaustMap(function (nextPeriod) {
      return manageConsecutivePeriodStreams(bufferType, nextPeriod, destroyNextStreams$);
    })); // Allows to destroy each created Stream, from the newest to the oldest,
    // once destroy$ emits.

    var destroyAll$ = destroy$.pipe(Object(take["a" /* take */])(1), Object(tap["a" /* tap */])(function () {
      // first complete createNextStream$ to allow completion of the
      // nextPeriodStream$ observable once every further Streams have been
      // cleared.
      createNextPeriodStream$.complete(); // emit destruction signal to the next Stream first

      destroyNextStreams$.next();
      destroyNextStreams$.complete(); // we do not need it anymore
    }), Object(share["a" /* share */])() // share side-effects
    ); // Will emit when the current Stream should be destroyed.

    var killCurrentStream$ = Object(merge["a" /* merge */])(endOfCurrentStream$, destroyAll$);
    var periodStream$ = stream_period({
      abrManager: abrManager,
      bufferType: bufferType,
      clock$: clock$,
      content: {
        manifest: manifest,
        period: basePeriod
      },
      garbageCollectors: garbageCollectors,
      segmentFetcherCreator: segmentFetcherCreator,
      sourceBuffersStore: sourceBuffersStore,
      options: options,
      wantedBufferAhead$: wantedBufferAhead$
    }).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      var type = evt.type;

      if (type === "full-stream") {
        var nextPeriod = manifest.getPeriodAfter(basePeriod);

        if (nextPeriod == null) {
          return Object(of["a" /* of */])(stream_events_generators.streamComplete(bufferType));
        } else {
          // current Stream is full, create the next one if not
          createNextPeriodStream$.next(nextPeriod);
        }
      } else if (type === "active-stream") {
        // current Stream is active, destroy next Stream if created
        destroyNextStreams$.next();
      }

      return Object(of["a" /* of */])(evt);
    }), Object(share["a" /* share */])()); // Stream for the current Period.

    var currentStream$ = Object(concat["a" /* concat */])(periodStream$.pipe(Object(takeUntil["a" /* takeUntil */])(killCurrentStream$)), Object(of["a" /* of */])(stream_events_generators.periodStreamCleared(bufferType, basePeriod)).pipe(Object(tap["a" /* tap */])(function () {
      log["a" /* default */].info("SO: Destroying Stream for", bufferType, basePeriod);
    })));
    return Object(merge["a" /* merge */])(currentStream$, nextPeriodStream$, destroyAll$.pipe(Object(ignoreElements["a" /* ignoreElements */])()));
  }
}
// CONCATENATED MODULE: ./src/core/stream/orchestrator/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var orchestrator = (StreamOrchestrator);
// CONCATENATED MODULE: ./src/core/stream/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var core_stream = (orchestrator);
// CONCATENATED MODULE: ./src/core/init/create_stream_clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create clock Observable for the `Stream` part of the code.
 * @param {Observable} initClock$
 * @param {Object} streamClockArgument
 * @returns {Observable}
 */

function createStreamClock(initClock$, _ref) {
  var autoPlay = _ref.autoPlay,
      initialPlay$ = _ref.initialPlay$,
      initialSeek$ = _ref.initialSeek$,
      manifest = _ref.manifest,
      speed$ = _ref.speed$,
      startTime = _ref.startTime;
  var initialPlayPerformed = false;
  var initialSeekPerformed = false;
  var updateIsPaused$ = initialPlay$.pipe(Object(tap["a" /* tap */])(function () {
    initialPlayPerformed = true;
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var updateTimeOffset$ = initialSeek$.pipe(Object(tap["a" /* tap */])(function () {
    initialSeekPerformed = true;
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var clock$ = Object(combineLatest["a" /* combineLatest */])([initClock$, speed$]).pipe(Object(map["a" /* map */])(function (_ref2) {
    var tick = _ref2[0],
        speed = _ref2[1];
    var isLive = manifest.isLive;
    return {
      currentTime: tick.currentTime,
      duration: tick.duration,
      isPaused: initialPlayPerformed ? tick.paused : !autoPlay,
      liveGap: isLive ? manifest.getMaximumPosition() - tick.currentTime : Infinity,
      readyState: tick.readyState,
      speed: speed,
      stalled: tick.stalled,
      // wantedTimeOffset is an offset to add to the timing's current time to have
      // the "real" wanted position.
      // For now, this is seen when the media element has not yet seeked to its
      // initial position, the currentTime will most probably be 0 where the
      // effective starting position will be _startTime_.
      // Thus we initially set a wantedTimeOffset equal to startTime.
      wantedTimeOffset: initialSeekPerformed ? 0 : startTime - tick.currentTime
    };
  }));
  return Object(merge["a" /* merge */])(updateIsPaused$, updateTimeOffset$, clock$);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(188);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = __webpack_require__(117);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return Object(empty["b" /* empty */])();
        }
        else {
            return source.lift(new takeLast_TakeLastOperator(count));
        }
    };
}
var takeLast_TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError["a" /* ArgumentOutOfRangeError */];
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var takeLast_TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=takeLast.js.map

// CONCATENATED MODULE: ./src/core/init/end_of_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var onRemoveSourceBuffers$ = compat["a" /* events */].onRemoveSourceBuffers$,
    end_of_stream_onSourceOpen$ = compat["a" /* events */].onSourceOpen$,
    onUpdate$ = compat["a" /* events */].onUpdate$;
/**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */

function getUpdatingSourceBuffers(sourceBuffers) {
  var updatingSourceBuffers = [];

  for (var i = 0; i < sourceBuffers.length; i++) {
    var SourceBuffer = sourceBuffers[i];

    if (SourceBuffer.updating) {
      updatingSourceBuffers.push(SourceBuffer);
    }
  }

  return updatingSourceBuffers;
}
/**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */


function triggerEndOfStream(mediaSource) {
  return Object(defer["a" /* defer */])(function () {
    log["a" /* default */].debug("Init: Trying to call endOfStream");

    if (mediaSource.readyState !== "open") {
      log["a" /* default */].debug("Init: MediaSource not open, cancel endOfStream");
      return Object(of["a" /* of */])(null);
    }

    var sourceBuffers = mediaSource.sourceBuffers;
    var updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);

    if (updatingSourceBuffers.length === 0) {
      log["a" /* default */].info("Init: Triggering end of stream");
      mediaSource.endOfStream();
      return Object(of["a" /* of */])(null);
    }

    log["a" /* default */].debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
    var updatedSourceBuffers$ = updatingSourceBuffers.map(function (sourceBuffer) {
      return onUpdate$(sourceBuffer).pipe(Object(take["a" /* take */])(1));
    });
    return Object(race["a" /* race */])(merge["a" /* merge */].apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), onRemoveSourceBuffers$(sourceBuffers).pipe(Object(take["a" /* take */])(1))).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return triggerEndOfStream(mediaSource);
    }));
  });
}
/**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

function maintainEndOfStream(mediaSource) {
  return end_of_stream_onSourceOpen$(mediaSource).pipe(Object(startWith["a" /* startWith */])(null), Object(switchMap["a" /* switchMap */])(function () {
    return triggerEndOfStream(mediaSource);
  }));
}
// EXTERNAL MODULE: ./src/compat/is_playback_stuck.ts
var is_playback_stuck = __webpack_require__(174);

// CONCATENATED MODULE: ./src/core/init/get_discontinuities.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var BUFFER_DISCONTINUITY_THRESHOLD = config["a" /* default */].BUFFER_DISCONTINUITY_THRESHOLD;
/**
 * Perform various checks about discontinuities during playback.
 * @param {Observable} clock$
 * @param {Object} manifest
 * @returns {Observable}
 */

function getDiscontinuities(clock$, manifest) {
  return clock$.pipe(Object(filter["a" /* filter */])(function (_ref) {
    var stalled = _ref.stalled;
    return stalled !== null;
  }), Object(map["a" /* map */])(function (tick) {
    var buffered = tick.buffered,
        currentTime = tick.currentTime,
        currentRange = tick.currentRange,
        state = tick.state,
        stalled = tick.stalled;
    var nextBufferRangeGap = Object(ranges["e" /* getNextRangeGap */])(buffered, currentTime); // 1: Is it a browser bug? -> force seek at the same current time

    if (Object(is_playback_stuck["a" /* default */])(currentTime, currentRange, state, stalled !== null)) {
      log["a" /* default */].warn("Init: After freeze seek", currentTime, currentRange);
      return [currentTime, currentTime]; // 2. Is it a short discontinuity in buffer ? -> Seek at the beginning of the
      //                                               next range
      //
      // Discontinuity check in case we are close a buffered range but still
      // calculate a stalled state. This is useful for some
      // implementation that might drop an injected segment, or in
      // case of small discontinuity in the content.
    } else if (nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {
      var seekTo = currentTime + nextBufferRangeGap + 1 / 60;
      return [currentTime, seekTo];
    } // 3. Is it a discontinuity between periods ? -> Seek at the beginning of the
    //                                               next period


    var currentPeriod = manifest.getPeriodForTime(currentTime);

    if (currentPeriod != null) {
      var nextPeriod = manifest.getPeriodAfter(currentPeriod);

      if (currentPeriod != null && currentPeriod.end != null && nextPeriod != null && currentTime > currentPeriod.end - 1 && currentTime <= nextPeriod.start && nextPeriod.start - currentPeriod.end === 0) {
        return [currentPeriod.end, nextPeriod.start];
      }
    }
  }), Object(filter["a" /* filter */])(function (x) {
    return x !== undefined;
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
// EXTERNAL MODULE: ./src/core/init/get_stalled_events.ts
var get_stalled_events = __webpack_require__(137);

// CONCATENATED MODULE: ./src/core/init/handle_discontinuity.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Handle discontinuity against current time and stall status
 * @param {number} seekTo
 * @param {boolean} isStalled
 */

function handleDiscontinuity(seekTo, mediaElement) {
  if (seekTo < mediaElement.currentTime) {
    return;
  }

  log["a" /* default */].warn("Init: discontinuity seek", mediaElement.currentTime, seekTo);
  mediaElement.currentTime = seekTo;
}
// EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts
var initial_seek_and_play = __webpack_require__(132);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/pairwise.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var pairwise_PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=pairwise.js.map

// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/are_same_stream_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Compare 2 events.
 * As the payload of two events may be the same, but the JS objects may not
 * have the same references, it may be difficult to compare them.
 * If two events start and end at the same moment, and possess the same id,
 * we consider the two to be the same.
 * /!\ However, the DASH-if spec does not say that the event payload
 * may be the same if these conditions are met. Thus, there are high chances
 * that it may be the case.
 * TODO See if we can compare payloads
 * @param {Object} evt1
 * @param {Object} evt2
 * @returns {Boolean}
 */
function areSameStreamEvents(evt1, evt2) {
  return evt1.id === evt2.id && evt1.start === evt2.start && evt1.end === evt2.end;
}

/* harmony default export */ var are_same_stream_events = (areSameStreamEvents);
// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/refresh_scheduled_events_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Refresh local scheduled events list
 * @param {Array.<Object>} oldScheduledEvents
 * @param {Object} manifest
 * @returns {Array.<Object>}
 */

function refreshScheduledEventsList(oldScheduledEvents, manifest) {
  var scheduledEvents = [];
  var periods = manifest.periods;

  for (var i = 0; i < periods.length; i++) {
    var period = periods[i];
    var streamEvents = period.streamEvents;
    streamEvents.forEach(function (_ref) {
      var start = _ref.start,
          end = _ref.end,
          id = _ref.id,
          data = _ref.data;

      for (var j = 0; j < oldScheduledEvents.length; j++) {
        var currentScheduledEvent = oldScheduledEvents[j];

        if (are_same_stream_events(currentScheduledEvent, {
          id: id,
          start: start,
          end: end
        })) {
          scheduledEvents.push(currentScheduledEvent);
          return;
        }
      }

      if (end === undefined) {
        var newScheduledEvent = {
          start: start,
          id: id,
          data: data,
          publicEvent: {
            start: start,
            data: data
          }
        };
        scheduledEvents.push(newScheduledEvent);
      } else {
        var _newScheduledEvent = {
          start: start,
          end: end,
          id: id,
          data: data,
          publicEvent: {
            start: start,
            end: end,
            data: data
          }
        };
        scheduledEvents.push(_newScheduledEvent);
      }
    });
  }

  return scheduledEvents;
}

/* harmony default export */ var refresh_scheduled_events_list = (refreshScheduledEventsList);
// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/stream_events_emitter.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var STREAM_EVENT_EMITTER_POLL_INTERVAL = config["a" /* default */].STREAM_EVENT_EMITTER_POLL_INTERVAL;
/**
 * Tells if a stream event has a duration
 * @param {Object} evt
 * @returns {Boolean}
 */

function isFiniteStreamEvent(evt) {
  return evt.end !== undefined;
}
/**
 * Get events from manifest and emit each time an event has to be emitted
 * @param {Object} manifest
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function streamEventsEmitter(manifest, mediaElement, clock$) {
  var eventsBeingPlayed = new WeakMap();
  var lastScheduledEvents = [];
  var scheduledEvents$ = Object(event_emitter["b" /* fromEvent */])(manifest, "manifestUpdate").pipe(Object(startWith["a" /* startWith */])(null), Object(scan["a" /* scan */])(function (oldScheduledEvents) {
    return refresh_scheduled_events_list(oldScheduledEvents, manifest);
  }, []));
  /**
   * Examine playback situation from clock ticks to emit stream events and
   * prepare set onExit callbacks if needed.
   * @param {Array.<Object>} scheduledEvents
   * @param {Object} oldTick
   * @param {Object} newTick
   * @returns {Observable}
   */

  function emitStreamEvents$(scheduledEvents, oldClockTick, newClockTick) {
    var previousTime = oldClockTick.currentTime;
    var isSeeking = newClockTick.isSeeking,
        currentTime = newClockTick.currentTime;
    var eventsToSend = [];
    var eventsToExit = [];

    for (var i = 0; i < scheduledEvents.length; i++) {
      var event = scheduledEvents[i];
      var start = event.start;
      var end = isFiniteStreamEvent(event) ? event.end : undefined;
      var isBeingPlayed = eventsBeingPlayed.has(event);

      if (isBeingPlayed) {
        if (start > currentTime || end !== undefined && currentTime >= end) {
          if (isFiniteStreamEvent(event)) {
            eventsToExit.push(event.publicEvent);
          }

          eventsBeingPlayed["delete"](event);
        }
      } else if (start <= currentTime && end !== undefined && currentTime < end) {
        eventsToSend.push({
          type: "stream-event",
          value: event.publicEvent
        });
        eventsBeingPlayed.set(event, true);
      } else if (previousTime < start && currentTime >= (end !== null && end !== void 0 ? end : start)) {
        if (isSeeking) {
          eventsToSend.push({
            type: "stream-event-skip",
            value: event.publicEvent
          });
        } else {
          eventsToSend.push({
            type: "stream-event",
            value: event.publicEvent
          });

          if (isFiniteStreamEvent(event)) {
            eventsToExit.push(event.publicEvent);
          }
        }
      }
    }

    return Object(concat["a" /* concat */])(eventsToSend.length > 0 ? of["a" /* of */].apply(void 0, eventsToSend) : empty["a" /* EMPTY */], eventsToExit.length > 0 ? of["a" /* of */].apply(void 0, eventsToExit).pipe(Object(tap["a" /* tap */])(function (evt) {
      if (typeof evt.onExit === "function") {
        evt.onExit();
      }
    }), Object(ignoreElements["a" /* ignoreElements */])()) : empty["a" /* EMPTY */]);
  }
  /**
   * This pipe allows to control wether the polling should occur, if there
   * are scheduledEvents, or not.
   */


  return scheduledEvents$.pipe(Object(tap["a" /* tap */])(function (scheduledEvents) {
    return lastScheduledEvents = scheduledEvents;
  }), Object(map["a" /* map */])(function (evt) {
    return evt.length > 0;
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(), Object(switchMap["a" /* switchMap */])(function (hasEvents) {
    if (!hasEvents) {
      return empty["a" /* EMPTY */];
    }

    return Object(combineLatest["a" /* combineLatest */])([Object(observable_interval["a" /* interval */])(STREAM_EVENT_EMITTER_POLL_INTERVAL).pipe(Object(startWith["a" /* startWith */])(null)), clock$]).pipe(Object(map["a" /* map */])(function (_ref) {
      var _ = _ref[0],
          clockTick = _ref[1];
      var seeking = clockTick.seeking;
      return {
        isSeeking: seeking,
        currentTime: mediaElement.currentTime
      };
    }), pairwise(), Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
      var oldTick = _ref2[0],
          newTick = _ref2[1];
      return emitStreamEvents$(lastScheduledEvents, oldTick, newTick);
    }));
  }));
}

/* harmony default export */ var stream_events_emitter = (streamEventsEmitter);
// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var init_stream_events_emitter = (stream_events_emitter);
// EXTERNAL MODULE: ./src/core/init/update_playback_rate.ts
var update_playback_rate = __webpack_require__(136);

// CONCATENATED MODULE: ./src/core/init/load_on_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















/**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} args
 * @returns {Observable}
 */

function createMediaSourceLoader(_ref) {
  var mediaElement = _ref.mediaElement,
      manifest = _ref.manifest,
      clock$ = _ref.clock$,
      speed$ = _ref.speed$,
      bufferOptions = _ref.bufferOptions,
      abrManager = _ref.abrManager,
      segmentFetcherCreator = _ref.segmentFetcherCreator;

  /**
   * Load the content on the given MediaSource.
   * @param {MediaSource} mediaSource
   * @param {number} initialTime
   * @param {boolean} autoPlay
   */
  return function loadContentOnMediaSource(mediaSource, initialTime, autoPlay) {
    // TODO Update the duration if it evolves?
    var duration = manifest.isLive ? Infinity : manifest.getMaximumPosition();
    setDurationToMediaSource(mediaSource, duration);
    var initialPeriod = manifest.getPeriodForTime(initialTime);

    if (initialPeriod == null) {
      throw new media_error["a" /* default */]("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.");
    } // Creates SourceBuffersStore allowing to create and keep track of a
    // single SourceBuffer per type.


    var sourceBuffersStore = new source_buffers(mediaElement, mediaSource);

    var _seekAndLoadOnMediaEv = Object(initial_seek_and_play["a" /* default */])({
      clock$: clock$,
      mediaElement: mediaElement,
      startTime: initialTime,
      mustAutoPlay: autoPlay,
      isDirectfile: false
    }),
        seek$ = _seekAndLoadOnMediaEv.seek$,
        load$ = _seekAndLoadOnMediaEv.load$;

    var initialPlay$ = load$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt !== "not-loaded-metadata";
    }));
    var streamEvents$ = initialPlay$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return init_stream_events_emitter(manifest, mediaElement, clock$);
    }));
    var streamClock$ = createStreamClock(clock$, {
      autoPlay: autoPlay,
      initialPlay$: initialPlay$,
      initialSeek$: seek$,
      manifest: manifest,
      speed$: speed$,
      startTime: initialTime
    }); // Will be used to cancel any endOfStream tries when the contents resume

    var cancelEndOfStream$ = new Subject["a" /* Subject */](); // Creates Observable which will manage every Stream for the given Content.

    var streams$ = core_stream({
      manifest: manifest,
      initialPeriod: initialPeriod
    }, streamClock$, abrManager, sourceBuffersStore, segmentFetcherCreator, bufferOptions).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      switch (evt.type) {
        case "end-of-stream":
          log["a" /* default */].debug("Init: end-of-stream order received.");
          return maintainEndOfStream(mediaSource).pipe(Object(ignoreElements["a" /* ignoreElements */])(), Object(takeUntil["a" /* takeUntil */])(cancelEndOfStream$));

        case "resume-stream":
          log["a" /* default */].debug("Init: resume-stream order received.");
          cancelEndOfStream$.next(null);
          return empty["a" /* EMPTY */];

        case "discontinuity-encountered":
          var _evt$value = evt.value,
              bufferType = _evt$value.bufferType,
              gap = _evt$value.gap;

          if (source_buffers.isNative(bufferType)) {
            handleDiscontinuity(gap[1], mediaElement);
          }

          return empty["a" /* EMPTY */];

        default:
          return Object(of["a" /* of */])(evt);
      }
    })); // update the speed set by the user on the media element while pausing a
    // little longer while the buffer is empty.

    var playbackRate$ = Object(update_playback_rate["a" /* default */])(mediaElement, speed$, clock$, {
      pauseWhenStalled: true
    }).pipe(Object(map["a" /* map */])(events_generators["a" /* default */].speedChanged)); // Create Stalling Manager, an observable which will try to get out of
    // various infinite stalling issues

    var stalled$ = Object(get_stalled_events["a" /* default */])(clock$).pipe(Object(map["a" /* map */])(events_generators["a" /* default */].stalled));
    var handledDiscontinuities$ = getDiscontinuities(clock$, manifest).pipe(Object(tap["a" /* tap */])(function (gap) {
      var seekTo = gap[1];
      handleDiscontinuity(seekTo, mediaElement);
    }), Object(ignoreElements["a" /* ignoreElements */])());
    var loadedEvent$ = load$.pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt === "autoplay-blocked") {
        var error = new media_error["a" /* default */]("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " + "your browser does not allow it.");
        return Object(of["a" /* of */])(events_generators["a" /* default */].warning(error), events_generators["a" /* default */].loaded(sourceBuffersStore));
      } else if (evt === "not-loaded-metadata") {
        var _error = new media_error["a" /* default */]("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " + "falsely announced having loaded the content.");

        return Object(of["a" /* of */])(events_generators["a" /* default */].warning(_error));
      }

      log["a" /* default */].debug("Init: The current content is loaded.");
      return Object(of["a" /* of */])(events_generators["a" /* default */].loaded(sourceBuffersStore));
    }));
    return Object(merge["a" /* merge */])(handledDiscontinuities$, loadedEvent$, playbackRate$, stalled$, streams$, streamEvents$).pipe(finalize(function () {
      // clean-up every created SourceBuffers
      sourceBuffersStore.disposeAll();
    }));
  };
}
// CONCATENATED MODULE: ./src/core/init/manifest_update_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY = config["a" /* default */].FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY,
    MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE = config["a" /* default */].MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE,
    MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE = config["a" /* default */].MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE;
/**
 * Refresh the Manifest at the right time.
 * @param {Object} manifestUpdateSchedulerArguments
 * @returns {Observable}
 */

function manifestUpdateScheduler(_ref) {
  var fetchManifest = _ref.fetchManifest,
      initialManifest = _ref.initialManifest,
      manifestUpdateUrl = _ref.manifestUpdateUrl,
      minimumManifestUpdateInterval = _ref.minimumManifestUpdateInterval,
      scheduleRefresh$ = _ref.scheduleRefresh$;
  // The Manifest always keeps the same Manifest
  var manifest = initialManifest.manifest;
  /** Number of consecutive times the parsing has been done in `unsafeMode`. */

  var consecutiveUnsafeMode = 0;

  function handleManifestRefresh$(manifestInfos) {
    var sendingTime = manifestInfos.sendingTime,
        parsingTime = manifestInfos.parsingTime,
        updatingTime = manifestInfos.updatingTime;
    /**
     * Total time taken to fully update the last Manifest.
     * Note: this time also includes possible requests done by the parsers.
     */

    var totalUpdateTime = parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0); // Only perform parsing in `unsafeMode` when the last full parsing took a
    // lot of time and do not go higher than the maximum consecutive time.

    var unsafeModeEnabled = consecutiveUnsafeMode > 0 ? consecutiveUnsafeMode < MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE : totalUpdateTime >= MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE;
    var internalRefresh$ = scheduleRefresh$.pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
      var completeRefresh = _ref2.completeRefresh,
          delay = _ref2.delay,
          canUseUnsafeMode = _ref2.canUseUnsafeMode;
      var unsafeMode = canUseUnsafeMode && unsafeModeEnabled;
      return startManualRefreshTimer(delay !== null && delay !== void 0 ? delay : 0, minimumManifestUpdateInterval, sendingTime).pipe(Object(mapTo["a" /* mapTo */])({
        completeRefresh: completeRefresh,
        unsafeMode: unsafeMode
      }));
    }));
    var timeSinceRequest = sendingTime == null ? 0 : performance.now() - sendingTime;
    var minInterval = Math.max(minimumManifestUpdateInterval - timeSinceRequest, 0);
    var autoRefresh$;

    if (manifest.lifetime === undefined || manifest.lifetime < 0) {
      autoRefresh$ = empty["a" /* EMPTY */];
    } else {
      var autoRefreshInterval = manifest.lifetime * 1000 - timeSinceRequest;

      if (manifest.lifetime < 3 && totalUpdateTime >= 100) {
        var defaultDelay = (3 - manifest.lifetime) * 1000 + autoRefreshInterval;
        var newInterval = Math.max(defaultDelay, Math.max(autoRefreshInterval, 0) + totalUpdateTime);
        log["a" /* default */].info("MUS: Manifest update rythm is too frequent. Postponing next request.", autoRefreshInterval, newInterval);
        autoRefreshInterval = newInterval;
      } else if (totalUpdateTime >= manifest.lifetime * 1000 / 10) {
        var _newInterval = Math.max(autoRefreshInterval, 0) + totalUpdateTime;

        log["a" /* default */].info("MUS: Manifest took too long to parse. Postponing next request", autoRefreshInterval, _newInterval);
        autoRefreshInterval = _newInterval;
      }

      autoRefresh$ = Object(timer["a" /* timer */])(Math.max(autoRefreshInterval, minInterval)).pipe(Object(mapTo["a" /* mapTo */])({
        completeRefresh: false,
        unsafeMode: unsafeModeEnabled
      }));
    }

    var expired$ = manifest.expired === null ? empty["a" /* EMPTY */] : Object(timer["a" /* timer */])(minInterval).pipe(Object(mergeMapTo["a" /* mergeMapTo */])(Object(from["a" /* from */])(manifest.expired)), Object(mapTo["a" /* mapTo */])({
      completeRefresh: true,
      unsafeMode: unsafeModeEnabled
    })); // Emit when the manifest should be refreshed. Either when:
    //   - A Stream asks for it to be refreshed
    //   - its lifetime expired.

    return Object(merge["a" /* merge */])(autoRefresh$, internalRefresh$, expired$).pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (_ref3) {
      var completeRefresh = _ref3.completeRefresh,
          unsafeMode = _ref3.unsafeMode;
      return refreshManifest({
        completeRefresh: completeRefresh,
        unsafeMode: unsafeMode
      });
    }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "warning") {
        return Object(of["a" /* of */])(evt);
      }

      return handleManifestRefresh$(evt);
    }));
  }

  return Object(defer["a" /* defer */])(function () {
    return handleManifestRefresh$(initialManifest);
  });
  /**
   * Refresh the Manifest.
   * Perform a full update if a partial update failed.
   * @param {boolean} completeRefresh
   * @returns {Observable}
   */

  function refreshManifest(_ref4) {
    var completeRefresh = _ref4.completeRefresh,
        unsafeMode = _ref4.unsafeMode;
    var fullRefresh = completeRefresh || manifestUpdateUrl === undefined;
    var refreshURL = fullRefresh ? manifest.getUrl() : manifestUpdateUrl;
    var externalClockOffset = manifest.clockOffset;

    if (unsafeMode) {
      consecutiveUnsafeMode += 1;
      log["a" /* default */].info("Init: Refreshing the Manifest in \"unsafeMode\" for the " + String(consecutiveUnsafeMode) + " consecutive time.");
    } else if (consecutiveUnsafeMode > 0) {
      log["a" /* default */].info("Init: Not parsing the Manifest in \"unsafeMode\" anymore after " + String(consecutiveUnsafeMode) + " consecutive times.");
      consecutiveUnsafeMode = 0;
    }

    return fetchManifest(refreshURL, {
      externalClockOffset: externalClockOffset,
      previousManifest: manifest,
      unsafeMode: unsafeMode
    }).pipe(Object(mergeMap["a" /* mergeMap */])(function (value) {
      if (value.type === "warning") {
        return Object(of["a" /* of */])(value);
      }

      var newManifest = value.manifest,
          newSendingTime = value.sendingTime,
          receivedTime = value.receivedTime,
          parsingTime = value.parsingTime;
      var updateTimeStart = performance.now();

      if (fullRefresh) {
        manifest.replace(newManifest);
      } else {
        try {
          manifest.update(newManifest);
        } catch (e) {
          var message = e instanceof Error ? e.message : "unknown error";
          log["a" /* default */].warn("MUS: Attempt to update Manifest failed: " + message, "Re-downloading the Manifest fully");
          return startManualRefreshTimer(FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY, minimumManifestUpdateInterval, newSendingTime).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
            return refreshManifest({
              completeRefresh: true,
              unsafeMode: false
            });
          }));
        }
      }

      return Object(of["a" /* of */])({
        type: "parsed",
        manifest: manifest,
        sendingTime: newSendingTime,
        receivedTime: receivedTime,
        parsingTime: parsingTime,
        updatingTime: performance.now() - updateTimeStart
      });
    }));
  }
}
/**
 * Launch a timer Observable which will emit when it is time to refresh the
 * Manifest.
 * The timer's delay is calculated from:
 *   - a target delay (`wantedDelay`), which is the minimum time we want to wait
 *     in the best scenario
 *   - the minimum set possible interval between manifest updates
 *     (`minimumManifestUpdateInterval`)
 *   - the time at which was done the last Manifest refresh
 *     (`lastManifestRequestTime`)
 * @param {number} wantedDelay
 * @param {number} minimumManifestUpdateInterval
 * @param {number|undefined} lastManifestRequestTime
 * @returns {Observable}
 */

function startManualRefreshTimer(wantedDelay, minimumManifestUpdateInterval, lastManifestRequestTime) {
  return Object(defer["a" /* defer */])(function () {
    // The value allows to set a delay relatively to the last Manifest refresh
    // (to avoid asking for it too often).
    var timeSinceLastRefresh = lastManifestRequestTime == null ? 0 : performance.now() - lastManifestRequestTime;

    var _minInterval = Math.max(minimumManifestUpdateInterval - timeSinceLastRefresh, 0);

    return Object(timer["a" /* timer */])(Math.max(wantedDelay - timeSinceLastRefresh, _minInterval));
  });
}
// EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
var throw_on_media_error = __webpack_require__(135);

// CONCATENATED MODULE: ./src/core/init/initialize_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















var OUT_OF_SYNC_MANIFEST_REFRESH_DELAY = config["a" /* default */].OUT_OF_SYNC_MANIFEST_REFRESH_DELAY;
/**
 * Begin content playback.
 *
 * Returns an Observable emitting notifications about the content lifecycle.
 * On subscription, it will perform every necessary tasks so the content can
 * play. Among them:
 *
 *   - Creates a MediaSource on the given `mediaElement` and attach to it the
 *     necessary SourceBuffer instances.
 *
 *   - download the content's Manifest and handle its refresh logic
 *
 *   - Perform EME management if needed
 *
 *   - ask for the choice of the wanted Adaptation through events (e.g. to
 *     choose a language)
 *
 *   - requests and push the right segments (according to the Adaptation choice,
 *     the current position, the network conditions etc.)
 *
 * This Observable will throw in the case where a fatal error (i.e. which has
 * stopped content playback) is encountered, with the corresponding error as a
 * payload.
 *
 * This Observable will never complete, it will always run until it is
 * unsubscribed from.
 * Unsubscription will stop playback and reset the corresponding state.
 *
 * @param {Object} args
 * @returns {Observable}
 */

function InitializeOnMediaSource(_ref) {
  var adaptiveOptions = _ref.adaptiveOptions,
      autoPlay = _ref.autoPlay,
      bufferOptions = _ref.bufferOptions,
      clock$ = _ref.clock$,
      keySystems = _ref.keySystems,
      lowLatencyMode = _ref.lowLatencyMode,
      manifestUpdateUrl = _ref.manifestUpdateUrl,
      mediaElement = _ref.mediaElement,
      minimumManifestUpdateInterval = _ref.minimumManifestUpdateInterval,
      networkConfig = _ref.networkConfig,
      speed$ = _ref.speed$,
      startAt = _ref.startAt,
      textTrackOptions = _ref.textTrackOptions,
      transportPipelines = _ref.transportPipelines,
      url = _ref.url;
  var offlineRetry = networkConfig.offlineRetry,
      segmentRetry = networkConfig.segmentRetry,
      manifestRetry = networkConfig.manifestRetry;
  var manifestFetcher = fetchers_manifest(transportPipelines, {
    lowLatencyMode: lowLatencyMode,
    maxRetryRegular: manifestRetry,
    maxRetryOffline: offlineRetry
  });
  /**
   * Fetch and parse the manifest from the URL given.
   * Throttled to avoid doing multiple simultaneous requests.
   */

  var fetchManifest = throttle(function (manifestURL, options) {
    return manifestFetcher.fetch(manifestURL).pipe(Object(mergeMap["a" /* mergeMap */])(function (response) {
      return response.type === "warning" ? Object(of["a" /* of */])(response) : // bubble-up warnings
      response.parse(options);
    }), Object(share["a" /* share */])());
  });
  /** Interface used to download segments. */

  var segmentFetcherCreator = new fetchers_segment(transportPipelines, {
    lowLatencyMode: lowLatencyMode,
    maxRetryOffline: offlineRetry,
    maxRetryRegular: segmentRetry
  });
  /** Choose the right "Representation" for a given "Adaptation". */

  var abrManager = new abr(adaptiveOptions);
  /**
   * Create and open a new MediaSource object on the given media element on
   * subscription.
   * The MediaSource will be closed on unsubscription.
   */

  var openMediaSource$ = openMediaSource(mediaElement).pipe(Object(shareReplay["a" /* shareReplay */])({
    refCount: true
  }));
  /** Send content protection data to the `EMEManager`. */

  var protectedSegments$ = new Subject["a" /* Subject */]();
  /** Create `EMEManager`, an observable which will handle content DRM. */

  var emeManager$ = Object(create_eme_manager["a" /* default */])(mediaElement, keySystems, protectedSegments$).pipe( // Because multiple Observables here depend on this Observable as a source,
  // we prefer deferring Subscription until those Observables are themselves
  // all subscribed to.
  // This is needed because `emeManager$` might send events synchronously
  // on subscription. In that case, it might communicate those events directly
  // after the first Subscription is done, making the next subscription miss
  // out on those events, even if that second subscription is done
  // synchronously after the first one.
  // By calling `deferSubscriptions`, we ensure that subscription to
  // `emeManager$` effectively starts after a very short delay, thus
  // ensuring that no such race condition can occur.
  Object(defer_subscriptions["a" /* default */])(), Object(share["a" /* share */])());
  /**
   * Translate errors coming from the media element into RxPlayer errors
   * through a throwing Observable.
   */

  var mediaError$ = Object(throw_on_media_error["a" /* default */])(mediaElement);
  /** Do the first Manifest request. */

  var initialManifestRequest$ = fetchManifest(url, {
    previousManifest: null,
    unsafeMode: false
  }).pipe( // Defer subscription and share for the same reasons than `openMediaSource$`
  Object(defer_subscriptions["a" /* default */])(), Object(share["a" /* share */])());
  var initialManifestRequestWarnings$ = initialManifestRequest$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "warning";
  }));
  var initialManifest$ = initialManifestRequest$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "parsed";
  }));
  /**
   * Wait for the MediaKeys to have been created before
   * opening MediaSource, and ask EME to attach MediaKeys.
   */

  var prepareMediaSource$ = emeManager$.pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
    switch (evt.type) {
      case "eme-disabled":
      case "attached-media-keys":
        return Object(of["a" /* of */])(undefined);

      case "created-media-keys":
        return openMediaSource$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
          evt.value.attachMediaKeys$.next();

          if (evt.value.mediaKeysInfos.keySystemOptions.disableMediaKeysAttachmentLock === true) {
            return Object(of["a" /* of */])(undefined);
          } // wait for "attached-media-keys"


          return empty["a" /* EMPTY */];
        }));

      default:
        return empty["a" /* EMPTY */];
    }
  }), Object(take["a" /* take */])(1), exhaustMap(function () {
    return openMediaSource$;
  }));
  /** Load and play the content asked. */

  var loadContent$ = Object(combineLatest["a" /* combineLatest */])([initialManifest$, prepareMediaSource$]).pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
    var parsedManifest = _ref2[0],
        initialMediaSource = _ref2[1];
    var manifest = parsedManifest.manifest;
    log["a" /* default */].debug("Init: Calculating initial time");
    var initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
    log["a" /* default */].debug("Init: Initial time calculated:", initialTime);
    var mediaSourceLoader = createMediaSourceLoader({
      abrManager: abrManager,
      bufferOptions: Object(object_assign["a" /* default */])({
        textTrackOptions: textTrackOptions
      }, bufferOptions),
      clock$: clock$,
      manifest: manifest,
      mediaElement: mediaElement,
      segmentFetcherCreator: segmentFetcherCreator,
      speed$: speed$
    }); // handle initial load and reloads

    var recursiveLoad$ = recursivelyLoadOnMediaSource(initialMediaSource, initialTime, autoPlay); // Emit when we want to manually update the manifest.

    var scheduleRefresh$ = new Subject["a" /* Subject */]();
    var manifestUpdate$ = manifestUpdateScheduler({
      fetchManifest: fetchManifest,
      initialManifest: parsedManifest,
      manifestUpdateUrl: manifestUpdateUrl,
      minimumManifestUpdateInterval: minimumManifestUpdateInterval,
      scheduleRefresh$: scheduleRefresh$
    });
    var manifestEvents$ = Object(merge["a" /* merge */])(Object(event_emitter["b" /* fromEvent */])(manifest, "manifestUpdate").pipe(Object(mapTo["a" /* mapTo */])(events_generators["a" /* default */].manifestUpdate())), Object(event_emitter["b" /* fromEvent */])(manifest, "decipherabilityUpdate").pipe(Object(map["a" /* map */])(events_generators["a" /* default */].decipherabilityUpdate)));
    var setUndecipherableRepresentations$ = emeManager$.pipe(Object(tap["a" /* tap */])(function (evt) {
      if (evt.type === "blacklist-keys") {
        log["a" /* default */].info("Init: blacklisting Representations based on keyIDs");
        manifest.addUndecipherableKIDs(evt.value);
      } else if (evt.type === "blacklist-protection-data") {
        log["a" /* default */].info("Init: blacklisting Representations based on protection data.");
        manifest.addUndecipherableProtectionData(evt.value.type, evt.value.data);
      }
    }));
    return Object(merge["a" /* merge */])(manifestEvents$, manifestUpdate$, setUndecipherableRepresentations$, recursiveLoad$).pipe(Object(startWith["a" /* startWith */])(events_generators["a" /* default */].manifestReady(manifest)), finalize(function () {
      scheduleRefresh$.complete();
    }));
    /**
     * Load the content defined by the Manifest in the mediaSource given at the
     * given position and playing status.
     * This function recursively re-call itself when a MediaSource reload is
     * wanted.
     * @param {MediaSource} mediaSource
     * @param {number} position
     * @param {boolean} shouldPlay
     * @returns {Observable}
     */

    function recursivelyLoadOnMediaSource(mediaSource, position, shouldPlay) {
      var reloadMediaSource$ = new Subject["a" /* Subject */]();
      var mediaSourceLoader$ = mediaSourceLoader(mediaSource, position, shouldPlay).pipe(Object(tap["a" /* tap */])(function (evt) {
        switch (evt.type) {
          case "needs-manifest-refresh":
            scheduleRefresh$.next({
              completeRefresh: false,
              canUseUnsafeMode: true
            });
            break;

          case "manifest-might-be-out-of-sync":
            scheduleRefresh$.next({
              completeRefresh: true,
              canUseUnsafeMode: false,
              delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY
            });
            break;

          case "needs-media-source-reload":
            reloadMediaSource$.next(evt.value);
            break;

          case "needs-decipherability-flush":
            var keySystem = Object(get_current_key_system["a" /* default */])(mediaElement);

            if (Object(should_reload_media_source_on_decipherability_update["a" /* default */])(keySystem)) {
              reloadMediaSource$.next(evt.value);
              return;
            } // simple seek close to the current position
            // to flush the buffers


            var currentTime = evt.value.currentTime;

            if (currentTime + 0.001 < evt.value.duration) {
              mediaElement.currentTime += 0.001;
            } else {
              mediaElement.currentTime = currentTime;
            }

            break;

          case "protected-segment":
            protectedSegments$.next(evt.value);
            break;
        }
      }));
      var currentLoad$ = mediaSourceLoader$.pipe(Object(takeUntil["a" /* takeUntil */])(reloadMediaSource$));
      var handleReloads$ = reloadMediaSource$.pipe(Object(switchMap["a" /* switchMap */])(function (_ref3) {
        var currentTime = _ref3.currentTime,
            isPaused = _ref3.isPaused;
        return openMediaSource(mediaElement).pipe(Object(mergeMap["a" /* mergeMap */])(function (newMS) {
          return recursivelyLoadOnMediaSource(newMS, currentTime, !isPaused);
        }), Object(startWith["a" /* startWith */])(events_generators["a" /* default */].reloadingMediaSource()));
      }));
      return Object(merge["a" /* merge */])(handleReloads$, currentLoad$);
    }
  }));
  return Object(merge["a" /* merge */])(initialManifestRequestWarnings$, loadContent$, mediaError$, emeManager$);
}
// CONCATENATED MODULE: ./src/core/init/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var init = (InitializeOnMediaSource);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(127);

// CONCATENATED MODULE: ./src/core/api/clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass information about the current state of the
 * media element to sub-parts of the player.
 */






var SAMPLING_INTERVAL_MEDIASOURCE = config["a" /* default */].SAMPLING_INTERVAL_MEDIASOURCE,
    SAMPLING_INTERVAL_LOW_LATENCY = config["a" /* default */].SAMPLING_INTERVAL_LOW_LATENCY,
    SAMPLING_INTERVAL_NO_MEDIASOURCE = config["a" /* default */].SAMPLING_INTERVAL_NO_MEDIASOURCE,
    RESUME_GAP_AFTER_SEEKING = config["a" /* default */].RESUME_GAP_AFTER_SEEKING,
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config["a" /* default */].RESUME_GAP_AFTER_NOT_ENOUGH_DATA,
    RESUME_GAP_AFTER_BUFFERING = config["a" /* default */].RESUME_GAP_AFTER_BUFFERING,
    STALL_GAP = config["a" /* default */].STALL_GAP;
/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */

var SCANNED_MEDIA_ELEMENTS_EVENTS = ["canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "ratechange"];
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @param {Boolean} lowLatencyMode
 * @returns {Number}
 */

function getResumeGap(stalled, lowLatencyMode) {
  if (stalled === null) {
    return 0;
  }

  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";

  switch (stalled.reason) {
    case "seeking":
      return RESUME_GAP_AFTER_SEEKING[suffix];

    case "not-ready":
      return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];

    case "buffering":
      return RESUME_GAP_AFTER_BUFFERING[suffix];
  }
}
/**
 * @param {Object} currentRange
 * @param {Number} duration
 * @param {Boolean} lowLatencyMode
 * @returns {Boolean}
 */


function hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode) {
  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
  return currentRange !== null && duration - currentRange.end <= STALL_GAP[suffix];
}
/**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} currentState
 * @returns {Object}
 */


function getMediaInfos(mediaElement, currentState) {
  var buffered = mediaElement.buffered,
      currentTime = mediaElement.currentTime,
      duration = mediaElement.duration,
      ended = mediaElement.ended,
      paused = mediaElement.paused,
      playbackRate = mediaElement.playbackRate,
      readyState = mediaElement.readyState,
      seeking = mediaElement.seeking;
  return {
    bufferGap: Object(ranges["d" /* getLeftSizeOfRange */])(buffered, currentTime),
    buffered: buffered,
    currentRange: Object(ranges["g" /* getRange */])(buffered, currentTime),
    currentTime: currentTime,
    duration: duration,
    ended: ended,
    paused: paused,
    playbackRate: playbackRate,
    readyState: readyState,
    seeking: seeking,
    state: currentState
  };
}
/**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Object} options
 * @returns {Object|null}
 */


function getStalledStatus(prevTimings, currentTimings, _ref) {
  var withMediaSource = _ref.withMediaSource,
      lowLatencyMode = _ref.lowLatencyMode;
  var currentState = currentTimings.state,
      currentTime = currentTimings.currentTime,
      bufferGap = currentTimings.bufferGap,
      currentRange = currentTimings.currentRange,
      duration = currentTimings.duration,
      paused = currentTimings.paused,
      readyState = currentTimings.readyState,
      ended = currentTimings.ended;
  var prevStalled = prevTimings.stalled,
      prevState = prevTimings.state,
      prevTime = prevTimings.currentTime;
  var fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode);
  var canStall = readyState >= 1 && currentState !== "loadedmetadata" && prevStalled === null && !(fullyLoaded || ended);
  var shouldStall;
  var shouldUnstall;

  if (withMediaSource) {
    if (canStall && (bufferGap <= (lowLatencyMode ? STALL_GAP.LOW_LATENCY : STALL_GAP.DEFAULT) || bufferGap === Infinity || readyState === 1)) {
      shouldStall = true;
    } else if (prevStalled !== null && readyState > 1 && (bufferGap < Infinity && bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended)) {
      shouldUnstall = true;
    }
  } // when using a direct file, the media will stall and unstall on its
  // own, so we only try to detect when the media timestamp has not changed
  // between two consecutive timeupdates
  else {
      if (canStall && (!paused && currentState === "timeupdate" && prevState === "timeupdate" && currentTime === prevTime || currentState === "seeking" && bufferGap === Infinity)) {
        shouldStall = true;
      } else if (prevStalled !== null && (currentState !== "seeking" && currentTime !== prevTime || currentState === "canplay" || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended))) {
        shouldUnstall = true;
      }
    }

  if (shouldUnstall === true) {
    return null;
  } else if (shouldStall === true || prevStalled !== null) {
    var reason;

    if (currentState === "seeking" || currentTimings.seeking || prevStalled !== null && prevStalled.reason === "seeking") {
      reason = "seeking";
    } else if (readyState === 1) {
      reason = "not-ready";
    } else {
      reason = "buffering";
    }

    if (prevStalled !== null && prevStalled.reason === reason) {
      return prevStalled;
    }

    return {
      reason: reason,
      timestamp: performance.now()
    };
  }

  return null;
}
/**
 * Timings observable.
 *
 * This Observable samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this Observable also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */


function createClock(mediaElement, options) {
  return Object(defer["a" /* defer */])(function () {
    var lastTimings = Object(object_assign["a" /* default */])(getMediaInfos(mediaElement, "init"), {
      stalled: null
    });

    function getCurrentClockTick(state) {
      var mediaTimings = getMediaInfos(mediaElement, state);
      var stalledState = getStalledStatus(lastTimings, mediaTimings, options); // /!\ Mutate mediaTimings

      return Object(object_assign["a" /* default */])(mediaTimings, {
        stalled: stalledState
      });
    }

    var eventObs = SCANNED_MEDIA_ELEMENTS_EVENTS.map(function (eventName) {
      return Object(fromEvent["a" /* fromEvent */])(mediaElement, eventName).pipe(Object(mapTo["a" /* mapTo */])(eventName));
    });
    var interval = options.lowLatencyMode ? SAMPLING_INTERVAL_LOW_LATENCY : options.withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE;
    var interval$ = Object(observable_interval["a" /* interval */])(interval).pipe(Object(mapTo["a" /* mapTo */])("timeupdate"));
    return merge["a" /* merge */].apply(void 0, [interval$].concat(eventObs)).pipe(Object(map["a" /* map */])(function (state) {
      lastTimings = getCurrentClockTick(state);

      if (log["a" /* default */].getLevel() === "DEBUG") {
        log["a" /* default */].debug("API: current playback timeline:\n" + prettyPrintBuffered(lastTimings.buffered, lastTimings.currentTime), "\n" + state);
      }

      return lastTimings;
    }), Object(startWith["a" /* startWith */])(lastTimings));
  }).pipe(Object(multicast["a" /* multicast */])(function () {
    return new ReplaySubject["a" /* ReplaySubject */](1);
  }), // Always emit the last
  Object(refCount["a" /* refCount */])());
}
/**
 * Pretty print a TimeRanges Object, to see the current content of it in a
 * one-liner string.
 *
 * @example
 * This function is called by giving it directly the TimeRanges, such as:
 * ```js
 * prettyPrintBuffered(document.getElementsByTagName("video")[0].buffered);
 * ```
 *
 * Let's consider this possible return:
 *
 * ```
 * 0.00|==29.95==|29.95 ~30.05~ 60.00|==29.86==|89.86
 *          ^14
 * ```
 * This means that our video element has 29.95 seconds of buffer between 0 and
 * 29.95 seconds.
 * Then 30.05 seconds where no buffer is found.
 * Then 29.86 seconds of buffer between 60.00 and 89.86 seconds.
 *
 * A caret on the second line indicates the current time we're at.
 * The number coming after it is the current time.
 * @param {TimeRanges} buffered
 * @param {number} currentTime
 * @returns {string}
 */


function prettyPrintBuffered(buffered, currentTime) {
  var str = "";
  var currentTimeStr = "";

  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i);
    var end = buffered.end(i);
    var fixedStart = start.toFixed(2);
    var fixedEnd = end.toFixed(2);
    var fixedDuration = (end - start).toFixed(2);
    var newIntervalStr = fixedStart + "|==" + fixedDuration + "==|" + fixedEnd;
    str += newIntervalStr;

    if (currentTimeStr.length === 0 && end > currentTime) {
      var padBefore = str.length - Math.floor(newIntervalStr.length / 2);
      currentTimeStr = " ".repeat(padBefore) + ("^" + currentTime);
    }

    if (i < buffered.length - 1) {
      var nextStart = buffered.start(i + 1);
      var fixedDiff = (nextStart - end).toFixed(2);
      var holeStr = " ~" + fixedDiff + "~ ";
      str += holeStr;

      if (currentTimeStr.length === 0 && currentTime < nextStart) {
        var _padBefore = str.length - Math.floor(holeStr.length / 2);

        currentTimeStr = " ".repeat(_padBefore) + ("^" + currentTime);
      }
    }
  }

  if (currentTimeStr.length === 0) {
    currentTimeStr = " ".repeat(str.length) + ("^" + currentTime);
  }

  return str + "\n" + currentTimeStr;
}

/* harmony default export */ var api_clock = (createClock);
// CONCATENATED MODULE: ./src/core/api/emit_seek_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns Observable which will emit:
 *   - `"seeking"` when we are seeking in the given mediaElement
 *   - `"seeked"` when a seek is considered as finished by the given clock$
 *     Observable.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} clock$
 * @returns {Observable}
 */

function emitSeekEvents(mediaElement, clock$) {
  return Object(defer["a" /* defer */])(function () {
    if (mediaElement === null) {
      return empty["a" /* EMPTY */];
    }

    var isSeeking$ = Object(fromEvent["a" /* fromEvent */])(mediaElement, "seeking").pipe(Object(mapTo["a" /* mapTo */])("seeking"));
    var hasSeeked$ = Object(fromEvent["a" /* fromEvent */])(mediaElement, "seeked").pipe(Object(switchMapTo["a" /* switchMapTo */])(clock$.pipe(Object(mergeMap["a" /* mergeMap */])(function (tick) {
      return tick.stalled === null || tick.stalled.reason !== "seeking" ? Object(of["a" /* of */])("seeked") : empty["a" /* EMPTY */];
    }), Object(take["a" /* take */])(1))));
    var seekingEvents$ = Object(merge["a" /* merge */])(isSeeking$, hasSeeked$);
    return mediaElement.seeking ? seekingEvents$.pipe(Object(startWith["a" /* startWith */])("seeking")) : seekingEvents$;
  });
}
// CONCATENATED MODULE: ./src/core/api/get_player_state.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FORCED_ENDED_THRESHOLD = config["a" /* default */].FORCED_ENDED_THRESHOLD;
/** Player state dictionnary. */

var PLAYER_STATES = {
  STOPPED: "STOPPED",
  LOADED: "LOADED",
  LOADING: "LOADING",
  PLAYING: "PLAYING",
  PAUSED: "PAUSED",
  ENDED: "ENDED",
  BUFFERING: "BUFFERING",
  SEEKING: "SEEKING",
  RELOADING: "RELOADING"
};
/**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */

function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
  if (mediaElement.ended) {
    return PLAYER_STATES.ENDED;
  }

  if (stalledStatus !== null) {
    // On some old browsers (e.g. Chrome 54), the browser does not
    // emit an 'ended' event in some conditions. Detect if we
    // reached the end by comparing the current position and the
    // duration instead.
    var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);

    if (FORCED_ENDED_THRESHOLD != null && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
      return PLAYER_STATES.ENDED;
    }

    return stalledStatus.reason === "seeking" ? PLAYER_STATES.SEEKING : PLAYER_STATES.BUFFERING;
  }

  return isPlaying ? PLAYER_STATES.PLAYING : PLAYER_STATES.PAUSED;
}
// EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
var normalize = __webpack_require__(107);

// CONCATENATED MODULE: ./src/core/api/option_parsers.ts
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */






var DEFAULT_AUTO_PLAY = config["a" /* default */].DEFAULT_AUTO_PLAY,
    DEFAULT_INITIAL_BITRATES = config["a" /* default */].DEFAULT_INITIAL_BITRATES,
    DEFAULT_LIMIT_VIDEO_WIDTH = config["a" /* default */].DEFAULT_LIMIT_VIDEO_WIDTH,
    DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = config["a" /* default */].DEFAULT_MANUAL_BITRATE_SWITCHING_MODE,
    DEFAULT_MAX_BITRATES = config["a" /* default */].DEFAULT_MAX_BITRATES,
    DEFAULT_MAX_BUFFER_AHEAD = config["a" /* default */].DEFAULT_MAX_BUFFER_AHEAD,
    DEFAULT_MAX_BUFFER_BEHIND = config["a" /* default */].DEFAULT_MAX_BUFFER_BEHIND,
    DEFAULT_SHOW_NATIVE_SUBTITLE = config["a" /* default */].DEFAULT_SHOW_NATIVE_SUBTITLE,
    DEFAULT_STOP_AT_END = config["a" /* default */].DEFAULT_STOP_AT_END,
    DEFAULT_TEXT_TRACK_MODE = config["a" /* default */].DEFAULT_TEXT_TRACK_MODE,
    DEFAULT_THROTTLE_WHEN_HIDDEN = config["a" /* default */].DEFAULT_THROTTLE_WHEN_HIDDEN,
    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN = config["a" /* default */].DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN,
    DEFAULT_WANTED_BUFFER_AHEAD = config["a" /* default */].DEFAULT_WANTED_BUFFER_AHEAD;
/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */

function parseConstructorOptions(options) {
  var maxBufferAhead;
  var maxBufferBehind;
  var wantedBufferAhead;
  var limitVideoWidth;
  var throttleWhenHidden;
  var throttleVideoBitrateWhenHidden;
  var preferredAudioTracks;
  var preferredTextTracks;
  var preferredVideoTracks;
  var videoElement;
  var initialVideoBitrate;
  var initialAudioBitrate;
  var maxAudioBitrate;
  var maxVideoBitrate;
  var stopAtEnd;

  if (Object(is_null_or_undefined["a" /* default */])(options.maxBufferAhead)) {
    maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
  } else {
    maxBufferAhead = Number(options.maxBufferAhead);

    if (isNaN(maxBufferAhead)) {
      throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
    }
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.maxBufferBehind)) {
    maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
  } else {
    maxBufferBehind = Number(options.maxBufferBehind);

    if (isNaN(maxBufferBehind)) {
      throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
    }
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.wantedBufferAhead)) {
    wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
  } else {
    wantedBufferAhead = Number(options.wantedBufferAhead);

    if (isNaN(wantedBufferAhead)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  limitVideoWidth = Object(is_null_or_undefined["a" /* default */])(options.limitVideoWidth) ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;

  if (!Object(is_null_or_undefined["a" /* default */])(options.throttleWhenHidden)) {
    Object(warn_once["a" /* default */])("`throttleWhenHidden` API is deprecated. Consider using " + "`throttleVideoBitrateWhenHidden` instead.");
    throttleWhenHidden = !!options.throttleWhenHidden;
  } else {
    throttleWhenHidden = DEFAULT_THROTTLE_WHEN_HIDDEN;
  } // `throttleWhenHidden` and `throttleVideoBitrateWhenHidden` can be in conflict
  // Do not activate the latter if the former is


  if (throttleWhenHidden) {
    throttleVideoBitrateWhenHidden = false;
  } else {
    throttleVideoBitrateWhenHidden = Object(is_null_or_undefined["a" /* default */])(options.throttleVideoBitrateWhenHidden) ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN : !!options.throttleVideoBitrateWhenHidden;
  }

  if (options.preferredTextTracks !== undefined) {
    if (!Array.isArray(options.preferredTextTracks)) {
      Object(warn_once["a" /* default */])("Invalid `preferredTextTracks` option, it should be an Array");
      preferredTextTracks = [];
    } else {
      preferredTextTracks = options.preferredTextTracks;
    }
  } else {
    preferredTextTracks = [];
  }

  if (options.preferredAudioTracks !== undefined) {
    if (!Array.isArray(options.preferredAudioTracks)) {
      Object(warn_once["a" /* default */])("Invalid `preferredAudioTracks` option, it should be an Array");
      preferredAudioTracks = [];
    } else {
      preferredAudioTracks = options.preferredAudioTracks;
    }
  } else {
    preferredAudioTracks = [];
  }

  if (options.preferredVideoTracks !== undefined) {
    if (!Array.isArray(options.preferredVideoTracks)) {
      Object(warn_once["a" /* default */])("Invalid `preferredVideoTracks` option, it should be an Array");
      preferredVideoTracks = [];
    } else {
      preferredVideoTracks = options.preferredVideoTracks;
    }
  } else {
    preferredVideoTracks = [];
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.videoElement)) {
    videoElement = document.createElement("video");
  } else if (options.videoElement instanceof HTMLMediaElement) {
    videoElement = options.videoElement;
  } else {
    /* tslint:disable:max-line-length */
    throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
    /* tslint:enable:max-line-length */
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.initialVideoBitrate)) {
    initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
  } else {
    initialVideoBitrate = Number(options.initialVideoBitrate);

    if (isNaN(initialVideoBitrate)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.initialAudioBitrate)) {
    initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
  } else {
    initialAudioBitrate = Number(options.initialAudioBitrate);

    if (isNaN(initialAudioBitrate)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.maxVideoBitrate)) {
    maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
  } else {
    maxVideoBitrate = Number(options.maxVideoBitrate);

    if (isNaN(maxVideoBitrate)) {
      throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
    }
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.maxAudioBitrate)) {
    maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
  } else {
    maxAudioBitrate = Number(options.maxAudioBitrate);

    if (isNaN(maxAudioBitrate)) {
      throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
    }
  }

  stopAtEnd = Object(is_null_or_undefined["a" /* default */])(options.stopAtEnd) ? DEFAULT_STOP_AT_END : !!options.stopAtEnd;
  return {
    maxBufferAhead: maxBufferAhead,
    maxBufferBehind: maxBufferBehind,
    limitVideoWidth: limitVideoWidth,
    videoElement: videoElement,
    wantedBufferAhead: wantedBufferAhead,
    throttleWhenHidden: throttleWhenHidden,
    throttleVideoBitrateWhenHidden: throttleVideoBitrateWhenHidden,
    preferredAudioTracks: preferredAudioTracks,
    preferredTextTracks: preferredTextTracks,
    preferredVideoTracks: preferredVideoTracks,
    initialAudioBitrate: initialAudioBitrate,
    initialVideoBitrate: initialVideoBitrate,
    maxAudioBitrate: maxAudioBitrate,
    maxVideoBitrate: maxVideoBitrate,
    stopAtEnd: stopAtEnd
  };
}
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */


function parseLoadVideoOptions(options) {
  var _a, _b, _c, _d, _e;

  var url;
  var transport;
  var keySystems;
  var textTrackMode;
  var textTrackElement;
  var startAt;

  if (Object(is_null_or_undefined["a" /* default */])(options)) {
    throw new Error("No option set on loadVideo");
  }

  if (!Object(is_null_or_undefined["a" /* default */])(options.url)) {
    url = String(options.url);
  } else if (Object(is_null_or_undefined["a" /* default */])((_a = options.transportOptions) === null || _a === void 0 ? void 0 : _a.manifestLoader)) {
    throw new Error("No url set on loadVideo");
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.transport)) {
    throw new Error("No transport set on loadVideo");
  } else {
    transport = String(options.transport);
  }

  var autoPlay = Object(is_null_or_undefined["a" /* default */])(options.autoPlay) ? DEFAULT_AUTO_PLAY : !!options.autoPlay;

  if (Object(is_null_or_undefined["a" /* default */])(options.keySystems)) {
    keySystems = [];
  } else {
    keySystems = Array.isArray(options.keySystems) ? options.keySystems : [options.keySystems];

    for (var _iterator = _createForOfIteratorHelperLoose(keySystems), _step; !(_step = _iterator()).done;) {
      var keySystem = _step.value;

      if (typeof keySystem.type !== "string" || typeof keySystem.getLicense !== "function") {
        throw new Error("Invalid key system given: Missing type string or " + "getLicense callback");
      }
    }
  }

  var lowLatencyMode = options.lowLatencyMode === undefined ? false : !!options.lowLatencyMode;
  var transportOptsArg = typeof options.transportOptions === "object" && options.transportOptions !== null ? options.transportOptions : {};
  var manifestUpdateUrl = (_b = options.transportOptions) === null || _b === void 0 ? void 0 : _b.manifestUpdateUrl;
  var minimumManifestUpdateInterval = (_d = (_c = options.transportOptions) === null || _c === void 0 ? void 0 : _c.minimumManifestUpdateInterval) !== null && _d !== void 0 ? _d : 0;
  var transportOptions = Object(object_assign["a" /* default */])({}, transportOptsArg, {
    /* tslint:disable deprecation */
    supplementaryImageTracks: [],
    supplementaryTextTracks: [],

    /* tslint:enable deprecation */
    lowLatencyMode: lowLatencyMode
  }); // remove already parsed data to simplify the `transportOptions` object

  delete transportOptions.manifestUpdateUrl;
  delete transportOptions.minimumManifestUpdateInterval;

  if (options.supplementaryTextTracks !== undefined) {
    Object(warn_once["a" /* default */])("The `supplementaryTextTracks` loadVideo option is deprecated.\n" + "Please use the `TextTrackRenderer` tool instead.");
    var supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [options.supplementaryTextTracks];

    for (var _iterator2 = _createForOfIteratorHelperLoose(supplementaryTextTracks), _step2; !(_step2 = _iterator2()).done;) {
      var supplementaryTextTrack = _step2.value;

      if (typeof supplementaryTextTrack.language !== "string" || typeof supplementaryTextTrack.mimeType !== "string" || typeof supplementaryTextTrack.url !== "string") {
        throw new Error("Invalid supplementary text track given. " + "Missing either language, mimetype or url");
      }
    }

    transportOptions.supplementaryTextTracks = supplementaryTextTracks;
  }

  if (options.supplementaryImageTracks !== undefined) {
    Object(warn_once["a" /* default */])("The `supplementaryImageTracks` loadVideo option is deprecated.\n" + "Please use the `parseBifThumbnails` tool instead.");
    var supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [options.supplementaryImageTracks];

    for (var _iterator3 = _createForOfIteratorHelperLoose(supplementaryImageTracks), _step3; !(_step3 = _iterator3()).done;) {
      var supplementaryImageTrack = _step3.value;

      if (typeof supplementaryImageTrack.mimeType !== "string" || typeof supplementaryImageTrack.url !== "string") {
        throw new Error("Invalid supplementary image track given. " + "Missing either mimetype or url");
      }
    }

    transportOptions.supplementaryImageTracks = supplementaryImageTracks;
  }

  if (Object(is_null_or_undefined["a" /* default */])(options.textTrackMode)) {
    textTrackMode = DEFAULT_TEXT_TRACK_MODE;
  } else {
    if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
      throw new Error("Invalid textTrackMode.");
    }

    textTrackMode = options.textTrackMode;
  }

  if (!Object(is_null_or_undefined["a" /* default */])(options.defaultAudioTrack)) {
    Object(warn_once["a" /* default */])("The `defaultAudioTrack` loadVideo option is deprecated.\n" + "Please use the `preferredAudioTracks` constructor option or the" + "`setPreferredAudioTracks` method instead");
  }

  var defaultAudioTrack = Object(normalize["b" /* normalizeAudioTrack */])(options.defaultAudioTrack);

  if (!Object(is_null_or_undefined["a" /* default */])(options.defaultTextTrack)) {
    Object(warn_once["a" /* default */])("The `defaultTextTrack` loadVideo option is deprecated.\n" + "Please use the `preferredTextTracks` constructor option or the" + "`setPreferredTextTracks` method instead");
  }

  var defaultTextTrack = Object(normalize["c" /* normalizeTextTrack */])(options.defaultTextTrack);
  var hideNativeSubtitle = !DEFAULT_SHOW_NATIVE_SUBTITLE;

  if (!Object(is_null_or_undefined["a" /* default */])(options.hideNativeSubtitle)) {
    Object(warn_once["a" /* default */])("The `hideNativeSubtitle` loadVideo option is deprecated");
    hideNativeSubtitle = !!options.hideNativeSubtitle;
  }

  var manualBitrateSwitchingMode = (_e = options.manualBitrateSwitchingMode) !== null && _e !== void 0 ? _e : DEFAULT_MANUAL_BITRATE_SWITCHING_MODE;

  if (textTrackMode === "html") {
    // TODO Better way to express that in TypeScript?
    if (Object(is_null_or_undefined["a" /* default */])(options.textTrackElement)) {
      throw new Error("You have to provide a textTrackElement " + "in \"html\" textTrackMode.");
    } else if (!(options.textTrackElement instanceof HTMLElement)) {
      throw new Error("textTrackElement should be an HTMLElement.");
    } else {
      textTrackElement = options.textTrackElement;
    }
  } else if (!Object(is_null_or_undefined["a" /* default */])(options.textTrackElement)) {
    log["a" /* default */].warn("API: You have set a textTrackElement without being in " + "an \"html\" textTrackMode. It will be ignored.");
  }

  if (!Object(is_null_or_undefined["a" /* default */])(options.startAt)) {
    // TODO Better way to express that in TypeScript?
    if (options.startAt.wallClockTime instanceof Date) {
      var wallClockTime = options.startAt.wallClockTime.getTime() / 1000;
      startAt = Object(object_assign["a" /* default */])({}, options.startAt, {
        wallClockTime: wallClockTime
      });
    } else {
      startAt = options.startAt;
    }
  }

  var networkConfig = Object(is_null_or_undefined["a" /* default */])(options.networkConfig) ? {} : {
    manifestRetry: options.networkConfig.manifestRetry,
    offlineRetry: options.networkConfig.offlineRetry,
    segmentRetry: options.networkConfig.segmentRetry
  }; // TODO without cast

  /* tslint:disable no-object-literal-type-assertion */

  return {
    autoPlay: autoPlay,
    defaultAudioTrack: defaultAudioTrack,
    defaultTextTrack: defaultTextTrack,
    hideNativeSubtitle: hideNativeSubtitle,
    keySystems: keySystems,
    lowLatencyMode: lowLatencyMode,
    manualBitrateSwitchingMode: manualBitrateSwitchingMode,
    manifestUpdateUrl: manifestUpdateUrl,
    minimumManifestUpdateInterval: minimumManifestUpdateInterval,
    networkConfig: networkConfig,
    startAt: startAt,
    textTrackElement: textTrackElement,
    textTrackMode: textTrackMode,
    transport: transport,
    transportOptions: transportOptions,
    url: url
  };
  /* tslint:enable no-object-literal-type-assertion */
}


// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(57);

// CONCATENATED MODULE: ./src/core/api/track_choice_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Transform an array of IAudioTrackPreference into an array of
 * INormalizedPreferredAudioTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>}
 * @returns {Array.<Object|null>}
 */

function normalizeAudioTracks(tracks) {
  return tracks.map(function (t) {
    return t == null ? t : {
      normalized: t.language === undefined ? undefined : Object(languages["a" /* default */])(t.language),
      audioDescription: t.audioDescription,
      codec: t.codec
    };
  });
}
/**
 * Transform an array of ITextTrackPreference into an array of
 * INormalizedPreferredTextTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>} tracks
 * @returns {Array.<Object|null>}
 */


function normalizeTextTracks(tracks) {
  return tracks.map(function (t) {
    return t == null ? t : {
      normalized: Object(languages["a" /* default */])(t.language),
      closedCaption: t.closedCaption
    };
  });
}
/**
 * Manage audio and text tracks for all active periods.
 * Choose the audio and text tracks for each period and record this choice.
 * @class TrackChoiceManager
 */


var track_choice_manager_TrackChoiceManager = /*#__PURE__*/function () {
  function TrackChoiceManager() {
    this._periods = new sorted_list_SortedList(function (a, b) {
      return a.period.start - b.period.start;
    });
    this._audioChoiceMemory = new WeakMap();
    this._textChoiceMemory = new WeakMap();
    this._videoChoiceMemory = new WeakMap();
    this._preferredAudioTracks = [];
    this._preferredTextTracks = [];
    this._preferredVideoTracks = [];
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} preferredAudioTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */


  var _proto = TrackChoiceManager.prototype;

  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
    this._preferredAudioTracks = preferredAudioTracks;

    if (shouldApply) {
      this._applyAudioPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} preferredTextTracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Periods. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredTextTracks = function setPreferredTextTracks(preferredTextTracks, shouldApply) {
    this._preferredTextTracks = preferredTextTracks;

    if (shouldApply) {
      this._applyTextPreferences();
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
    this._preferredVideoTracks = preferredVideoTracks;

    if (shouldApply) {
      this._applyVideoPreferences();
    }
  }
  /**
   * Add Subject to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   * @param {Subject.<Object|null>} adaptation$ - A subject through which the
   * choice will be given
   */
  ;

  _proto.addPeriod = function addPeriod(bufferType, period, adaptation$) {
    var periodItem = getPeriodItem(this._periods, period);
    var adaptations = period.getPlayableAdaptations(bufferType);

    if (periodItem != null) {
      if (periodItem[bufferType] != null) {
        log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " already added for period", period);
        return;
      } else {
        periodItem[bufferType] = {
          adaptations: adaptations,
          adaptation$: adaptation$
        };
      }
    } else {
      var _this$_periods$add;

      this._periods.add((_this$_periods$add = {
        period: period
      }, _this$_periods$add[bufferType] = {
        adaptations: adaptations,
        adaptation$: adaptation$
      }, _this$_periods$add));
    }
  }
  /**
   * Remove Subject to choose an "audio", "video" or "text" Adaptation for a
   * Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.removePeriod = function removePeriod(bufferType, period) {
    var periodIndex = findPeriodIndex(this._periods, period);

    if (periodIndex == null) {
      log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " not found for period", period);
      return;
    }

    var periodItem = this._periods.get(periodIndex);

    if (periodItem[bufferType] == null) {
      log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " already removed for period", period);
      return;
    }

    delete periodItem[bufferType];

    if (periodItem.audio == null && periodItem.text == null && periodItem.video == null) {
      this._periods.removeElement(periodItem);
    }
  };

  _proto.resetPeriods = function resetPeriods() {
    while (this._periods.length() > 0) {
      this._periods.pop();
    }
  }
  /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */
  ;

  _proto.update = function update() {
    this._resetChosenAudioTracks();

    this._resetChosenTextTracks();

    this._resetChosenVideoTracks();
  }
  /**
   * Emit initial audio Adaptation through the given Subject based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var audioAdaptations = period.getPlayableAdaptations("audio");

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    if (chosenAudioAdaptation === null) {
      // If the Period was previously without audio, keep it that way
      audioInfos.adaptation$.next(null);
    } else if (chosenAudioAdaptation === undefined || !Object(array_includes["a" /* default */])(audioAdaptations, chosenAudioAdaptation)) {
      // Find the optimal audio Adaptation
      var preferredAudioTracks = this._preferredAudioTracks;
      var normalizedPref = normalizeAudioTracks(preferredAudioTracks);
      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);

      this._audioChoiceMemory.set(period, optimalAdaptation);

      audioInfos.adaptation$.next(optimalAdaptation);
    } else {
      audioInfos.adaptation$.next(chosenAudioAdaptation); // set last one
    }
  }
  /**
   * Emit initial text Adaptation through the given Subject based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialTextTrack = function setInitialTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var textAdaptations = period.getPlayableAdaptations("text");

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === null) {
      // If the Period was previously without text, keep it that way
      textInfos.adaptation$.next(null);
    } else if (chosenTextAdaptation === undefined || !Object(array_includes["a" /* default */])(textAdaptations, chosenTextAdaptation)) {
      // Find the optimal text Adaptation
      var preferredTextTracks = this._preferredTextTracks;
      var normalizedPref = normalizeTextTracks(preferredTextTracks);
      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);

      this._textChoiceMemory.set(period, optimalAdaptation);

      textInfos.adaptation$.next(optimalAdaptation);
    } else {
      textInfos.adaptation$.next(chosenTextAdaptation); // set last one
    }
  }
  /**
   * Emit initial video Adaptation through the given Subject based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var videoAdaptations = period.getPlayableAdaptations("video");

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation === null) {
      // If the Period was previously without video, keep it that way
      videoInfos.adaptation$.next(null);
    } else if (chosenVideoAdaptation === undefined || !Object(array_includes["a" /* default */])(videoAdaptations, chosenVideoAdaptation)) {
      var preferredVideoTracks = this._preferredVideoTracks;
      var optimalAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);

      this._videoChoiceMemory.set(period, optimalAdaptation);

      videoInfos.adaptation$.next(optimalAdaptation);
    } else {
      videoInfos.adaptation$.next(chosenVideoAdaptation); // set last one
    }
  }
  /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */
  ;

  _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(audioInfos.adaptations, function (_ref) {
      var id = _ref.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Audio Track not found.");
    }

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    if (chosenAudioAdaptation === wantedAdaptation) {
      return;
    }

    this._audioChoiceMemory.set(period, wantedAdaptation);

    audioInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Set text track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */
  ;

  _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(textInfos.adaptations, function (_ref2) {
      var id = _ref2.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Text Track not found.");
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === wantedAdaptation) {
      return;
    }

    this._textChoiceMemory.set(period, wantedAdaptation);

    textInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Set video track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */
  ;

  _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      throw new Error("LanguageManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(videoInfos.adaptations, function (_ref3) {
      var id = _ref3.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Video Track not found.");
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation === wantedAdaptation) {
      return;
    }

    this._videoChoiceMemory.set(period, wantedAdaptation);

    videoInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */
  ;

  _proto.disableTextTrack = function disableTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === null) {
      return;
    }

    this._textChoiceMemory.set(period, null);

    textInfos.adaptation$.next(null);
  }
  /**
   * Disable the current video track for a given period.
   * @param {Object} period
   * @throws Error - Throws if the period given has not been added
   */
  ;

  _proto.disableVideoTrack = function disableVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem === null || periodItem === void 0 ? void 0 : periodItem.video;

    if (videoInfos === undefined) {
      throw new Error("TrackManager: Given Period not found.");
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation === null) {
      return;
    }

    this._videoChoiceMemory.set(period, null);

    videoInfos.adaptation$.next(null);
  }
  /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The audio track chosen for this Period
   */
  ;

  _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      return null;
    }

    var chosenTrack = this._audioChoiceMemory.get(period);

    if (chosenTrack == null) {
      return null;
    }

    var audioTrack = {
      language: Object(take_first_set["a" /* default */])(chosenTrack.language, ""),
      normalized: Object(take_first_set["a" /* default */])(chosenTrack.normalizedLanguage, ""),
      audioDescription: chosenTrack.isAudioDescription === true,
      id: chosenTrack.id,
      representations: chosenTrack.representations.map(parseAudioRepresentation)
    };

    if (chosenTrack.isDub === true) {
      audioTrack.dub = true;
    }

    return audioTrack;
  }
  /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The text track chosen for this Period
   */
  ;

  _proto.getChosenTextTrack = function getChosenTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      return null;
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation == null) {
      return null;
    }

    return {
      language: Object(take_first_set["a" /* default */])(chosenTextAdaptation.language, ""),
      normalized: Object(take_first_set["a" /* default */])(chosenTextAdaptation.normalizedLanguage, ""),
      closedCaption: chosenTextAdaptation.isClosedCaption === true,
      id: chosenTextAdaptation.id
    };
  }
  /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The video track chosen for this Period
   */
  ;

  _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      return null;
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation == null) {
      return null;
    }

    var videoTrack = {
      id: chosenVideoAdaptation.id,
      representations: chosenVideoAdaptation.representations.map(parseVideoRepresentation)
    };

    if (chosenVideoAdaptation.isSignInterpreted === true) {
      videoTrack.signInterpreted = true;
    }

    return videoTrack;
  }
  /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      return [];
    }

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    var currentId = chosenAudioAdaptation != null ? chosenAudioAdaptation.id : null;
    return audioInfos.adaptations.map(function (adaptation) {
      var formatted = {
        language: Object(take_first_set["a" /* default */])(adaptation.language, ""),
        normalized: Object(take_first_set["a" /* default */])(adaptation.normalizedLanguage, ""),
        audioDescription: adaptation.isAudioDescription === true,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id,
        representations: adaptation.representations.map(parseAudioRepresentation)
      };

      if (adaptation.isDub === true) {
        formatted.dub = true;
      }

      return formatted;
    });
  }
  /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      return [];
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    var currentId = chosenTextAdaptation != null ? chosenTextAdaptation.id : null;
    return textInfos.adaptations.map(function (adaptation) {
      return {
        language: Object(take_first_set["a" /* default */])(adaptation.language, ""),
        normalized: Object(take_first_set["a" /* default */])(adaptation.normalizedLanguage, ""),
        closedCaption: adaptation.isClosedCaption === true,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id
      };
    });
  }
  /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      return [];
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    var currentId = chosenVideoAdaptation != null ? chosenVideoAdaptation.id : null;
    return videoInfos.adaptations.map(function (adaptation) {
      var formatted = {
        id: adaptation.id,
        active: currentId === null ? false : currentId === adaptation.id,
        representations: adaptation.representations.map(parseVideoRepresentation)
      };

      if (adaptation.isSignInterpreted === true) {
        formatted.signInterpreted = true;
      }

      return formatted;
    });
  }
  /**
   * Reset all audio tracks choices to corresponds to the current preferences.
   */
  ;

  _proto._applyAudioPreferences = function _applyAudioPreferences() {
    // Remove all memorized choices and start over
    this._audioChoiceMemory = new WeakMap();

    this._resetChosenAudioTracks();
  }
  /**
   * Reset all text tracks choices to corresponds to the current preferences.
   */
  ;

  _proto._applyTextPreferences = function _applyTextPreferences() {
    // Remove all memorized choices and start over
    this._textChoiceMemory = new WeakMap();

    this._resetChosenTextTracks();
  }
  /**
   * Reset all video tracks choices to corresponds to the current preferences.
   */
  ;

  _proto._applyVideoPreferences = function _applyVideoPreferences() {
    // Remove all memorized choices and start over
    this._videoChoiceMemory = new WeakMap();

    this._resetChosenVideoTracks();
  }
  /**
   * Choose again the best audio tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._audioChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the audio preferences.
   */
  ;

  _proto._resetChosenAudioTracks = function _resetChosenAudioTracks() {
    var _this = this;

    var preferredAudioTracks = this._preferredAudioTracks;
    var normalizedPref = normalizeAudioTracks(preferredAudioTracks);

    var recursiveUpdateAudioTrack = function recursiveUpdateAudioTrack(index) {
      if (index >= _this._periods.length()) {
        // we did all audio Periods, exit
        return;
      }

      var periodItem = _this._periods.get(index);

      if (periodItem.audio == null) {
        // No audio choice for this period, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          audioItem = periodItem.audio;
      var audioAdaptations = period.getPlayableAdaptations("audio");

      var chosenAudioAdaptation = _this._audioChoiceMemory.get(period);

      if (chosenAudioAdaptation === null || chosenAudioAdaptation !== undefined && Object(array_includes["a" /* default */])(audioAdaptations, chosenAudioAdaptation)) {
        // Already best audio for this Period, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }

      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);

      _this._audioChoiceMemory.set(period, optimalAdaptation);

      audioItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateAudioTrack(0);
    };

    recursiveUpdateAudioTrack(0);
  }
  /**
   * Choose again the best text tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._textChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the text preferences.
   */
  ;

  _proto._resetChosenTextTracks = function _resetChosenTextTracks() {
    var _this2 = this;

    var preferredTextTracks = this._preferredTextTracks;
    var normalizedPref = normalizeTextTracks(preferredTextTracks);

    var recursiveUpdateTextTrack = function recursiveUpdateTextTrack(index) {
      if (index >= _this2._periods.length()) {
        // we did all text Periods, exit
        return;
      }

      var periodItem = _this2._periods.get(index);

      if (periodItem.text == null) {
        // No text choice for this period, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          textItem = periodItem.text;
      var textAdaptations = period.getPlayableAdaptations("text");

      var chosenTextAdaptation = _this2._textChoiceMemory.get(period);

      if (chosenTextAdaptation === null || chosenTextAdaptation !== undefined && Object(array_includes["a" /* default */])(textAdaptations, chosenTextAdaptation)) {
        // Already best text for this Period, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }

      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);

      _this2._textChoiceMemory.set(period, optimalAdaptation);

      textItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateTextTrack(0);
    };

    recursiveUpdateTextTrack(0);
  }
  /**
   * Choose again the best video tracks for all current Periods.
   * This is based on two things:
   *   1. what was the track previously chosen for that Period (by checking
   *      `this._videoChoiceMemory`).
   *   2. If no track were previously chosen or if it is not available anymore
   *      we check the video preferences.
   */
  ;

  _proto._resetChosenVideoTracks = function _resetChosenVideoTracks() {
    var _this3 = this;

    var preferredVideoTracks = this._preferredVideoTracks;

    var recursiveUpdateVideoTrack = function recursiveUpdateVideoTrack(index) {
      if (index >= _this3._periods.length()) {
        // we did all video Periods, exit
        return;
      }

      var periodItem = _this3._periods.get(index);

      if (periodItem.video == null) {
        // No video choice for this period, check next one
        recursiveUpdateVideoTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          videoItem = periodItem.video;
      var videoAdaptations = period.getPlayableAdaptations("video");

      var chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);

      if (chosenVideoAdaptation === null || chosenVideoAdaptation !== undefined && Object(array_includes["a" /* default */])(videoAdaptations, chosenVideoAdaptation)) {
        // Already best video for this Period, check next one
        recursiveUpdateVideoTrack(index + 1);
        return;
      }

      var optimalAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);

      _this3._videoChoiceMemory.set(period, optimalAdaptation);

      videoItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateVideoTrack(0);
    };

    recursiveUpdateVideoTrack(0);
  };

  return TrackChoiceManager;
}();
/**
 * Create a function allowing to compare audio Adaptations with a given
 * `preferredAudioTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredAudioTrack - The audio track preference you want to
 * compare audio Adaptations to.
 * @returns {Function} - Function taking in argument an audio Adaptation and
 * returning `true` if it matches the `preferredAudioTrack` preference (and
 * `false` otherwise.
 */




function createAudioPreferenceMatcher(preferredAudioTrack) {
  /**
   * Compares an audio Adaptation to the given `preferredAudioTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} audioAdaptation
   * @returns {boolean}
   */
  return function matchAudioPreference(audioAdaptation) {
    var _a;

    if (preferredAudioTrack.normalized !== undefined) {
      var language = (_a = audioAdaptation.normalizedLanguage) !== null && _a !== void 0 ? _a : "";

      if (language !== preferredAudioTrack.normalized) {
        return false;
      }
    }

    if (preferredAudioTrack.audioDescription !== undefined) {
      if (preferredAudioTrack.audioDescription) {
        if (audioAdaptation.isAudioDescription !== true) {
          return false;
        }
      } else if (audioAdaptation.isAudioDescription === true) {
        return false;
      }
    }

    if (preferredAudioTrack.codec === undefined) {
      return true;
    }

    var regxp = preferredAudioTrack.codec.test;

    var codecTestingFn = function codecTestingFn(rep) {
      return rep.codec !== undefined && regxp.test(rep.codec);
    };

    if (preferredAudioTrack.codec.all) {
      return audioAdaptation.representations.every(codecTestingFn);
    }

    return audioAdaptation.representations.some(codecTestingFn);
  };
}
/**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @param {Array.<Object|null>} preferredAudioTracks
 * @returns {Adaptation|null}
 */


function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
  if (audioAdaptations.length === 0) {
    return null;
  }

  for (var i = 0; i < preferredAudioTracks.length; i++) {
    var preferredAudioTrack = preferredAudioTracks[i];

    if (preferredAudioTrack === null) {
      return null;
    }

    var matchPreferredAudio = createAudioPreferenceMatcher(preferredAudioTrack);
    var foundAdaptation = Object(array_find["a" /* default */])(audioAdaptations, matchPreferredAudio);

    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  } // no optimal adaptation, just return the first one


  return audioAdaptations[0];
}
/**
 * Create a function allowing to compare text Adaptations with a given
 * `preferredTextTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredTextTrack - The text track preference you want to
 * compare text Adaptations to.
 * @returns {Function} - Function taking in argument a text Adaptation and
 * returning `true` if it matches the `preferredTextTrack` preference (and
 * `false` otherwise.
 */


function createTextPreferenceMatcher(preferredTextTrack) {
  /**
   * Compares a text Adaptation to the given `preferredTextTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} textAdaptation
   * @returns {boolean}
   */
  return function matchTextPreference(textAdaptation) {
    return Object(take_first_set["a" /* default */])(textAdaptation.normalizedLanguage, "") === preferredTextTrack.normalized && (preferredTextTrack.closedCaption ? textAdaptation.isClosedCaption === true : textAdaptation.isClosedCaption !== true);
  };
}
/**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Object>} textAdaptations
 * @param {Array.<Object|null>} preferredTextTracks
 * @returns {Adaptation|null}
 */


function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
  if (textAdaptations.length === 0) {
    return null;
  }

  for (var i = 0; i < preferredTextTracks.length; i++) {
    var preferredTextTrack = preferredTextTracks[i];

    if (preferredTextTrack === null) {
      return null;
    }

    var matchPreferredText = createTextPreferenceMatcher(preferredTextTrack);
    var foundAdaptation = Object(array_find["a" /* default */])(textAdaptations, matchPreferredText);

    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  } // no optimal adaptation


  return null;
}
/**
 * Create a function allowing to compare video Adaptations with a given
 * `preferredVideoTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredVideoTrack - The video track preference you want to
 * compare video Adaptations to.
 * @returns {Function} - Function taking in argument a video Adaptation and
 * returning `true` if it matches the `preferredVideoTrack` preference (and
 * `false` otherwise.
 */


function createVideoPreferenceMatcher(preferredVideoTrack) {
  /**
   * Compares a video Adaptation to the given `preferredVideoTrack` preference.
   * Returns `true` if it matches, false otherwise.
   * @param {Object} videoAdaptation
   * @returns {boolean}
   */
  return function matchVideoPreference(videoAdaptation) {
    if (preferredVideoTrack.signInterpreted !== undefined && preferredVideoTrack.signInterpreted !== videoAdaptation.isSignInterpreted) {
      return false;
    }

    if (preferredVideoTrack.codec === undefined) {
      return true;
    }

    var regxp = preferredVideoTrack.codec.test;

    var codecTestingFn = function codecTestingFn(rep) {
      return rep.codec !== undefined && regxp.test(rep.codec);
    };

    if (preferredVideoTrack.codec.all) {
      return videoAdaptation.representations.every(codecTestingFn);
    }

    return videoAdaptation.representations.some(codecTestingFn);
  };
}
/**
 * Find an optimal video adaptation given their list and the array of preferred
 * video tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal video adaptation is no video adaptation.
 * @param {Array.<Adaptation>} videoAdaptations
 * @param {Array.<Object|null>} preferredvideoTracks
 * @returns {Adaptation|null}
 */


function findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks) {
  if (videoAdaptations.length === 0) {
    return null;
  }

  for (var i = 0; i < preferredVideoTracks.length; i++) {
    var preferredVideoTrack = preferredVideoTracks[i];

    if (preferredVideoTrack === null) {
      return null;
    }

    var matchPreferredVideo = createVideoPreferenceMatcher(preferredVideoTrack);
    var foundAdaptation = Object(array_find["a" /* default */])(videoAdaptations, matchPreferredVideo);

    if (foundAdaptation !== undefined) {
      return foundAdaptation;
    }
  } // no optimal adaptation, just return the first one


  return videoAdaptations[0];
}
/**
 * Returns the index of the given `period` in the given `periods`
 * SortedList.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {number|undefined}
 */


function findPeriodIndex(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);

    if (periodI.period.id === period.id) {
      return i;
    }
  }
}
/**
 * Returns element in the given `periods` SortedList that corresponds to the
 * `period` given.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {Object|undefined}
 */


function getPeriodItem(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);

    if (periodI.period.id === period.id) {
      return periodI;
    }
  }
}
/**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */


function parseVideoRepresentation(_ref4) {
  var id = _ref4.id,
      bitrate = _ref4.bitrate,
      frameRate = _ref4.frameRate,
      width = _ref4.width,
      height = _ref4.height,
      codec = _ref4.codec;
  return {
    id: id,
    bitrate: bitrate,
    frameRate: frameRate,
    width: width,
    height: height,
    codec: codec
  };
}
/**
 * Parse audio Representation into a ITMAudioRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */


function parseAudioRepresentation(_ref5) {
  var id = _ref5.id,
      bitrate = _ref5.bitrate,
      codec = _ref5.codec;
  return {
    id: id,
    bitrate: bitrate,
    codec: codec
  };
}
// CONCATENATED MODULE: ./src/core/api/public_api.ts



/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */






















var DEFAULT_UNMUTED_VOLUME = config["a" /* default */].DEFAULT_UNMUTED_VOLUME;
var isActive = compat["a" /* events */].isActive,
    isVideoVisible = compat["a" /* events */].isVideoVisible,
    onEnded$ = compat["a" /* events */].onEnded$,
    onFullscreenChange$ = compat["a" /* events */].onFullscreenChange$,
    onPlayPause$ = compat["a" /* events */].onPlayPause$,
    onPictureInPictureEvent$ = compat["a" /* events */].onPictureInPictureEvent$,
    onSeeking$ = compat["a" /* events */].onSeeking$,
    onTextTrackChanges$ = compat["a" /* events */].onTextTrackChanges$,
    videoWidth$ = compat["a" /* events */].videoWidth$;
/**
 * @class Player
 * @extends EventEmitter
 */

var public_api_Player = /*#__PURE__*/function (_EventEmitter) {
  inheritsLoose_default()(Player, _EventEmitter);

  /**
   * @constructor
   * @param {Object} options
   */
  function Player(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _EventEmitter.call(this) || this;

    var _parseConstructorOpti = parseConstructorOptions(options),
        initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate,
        initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate,
        limitVideoWidth = _parseConstructorOpti.limitVideoWidth,
        maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate,
        maxBufferAhead = _parseConstructorOpti.maxBufferAhead,
        maxBufferBehind = _parseConstructorOpti.maxBufferBehind,
        maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate,
        preferredAudioTracks = _parseConstructorOpti.preferredAudioTracks,
        preferredTextTracks = _parseConstructorOpti.preferredTextTracks,
        preferredVideoTracks = _parseConstructorOpti.preferredVideoTracks,
        throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden,
        throttleVideoBitrateWhenHidden = _parseConstructorOpti.throttleVideoBitrateWhenHidden,
        videoElement = _parseConstructorOpti.videoElement,
        wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead,
        stopAtEnd = _parseConstructorOpti.stopAtEnd; // Workaround to support Firefox autoplay on FF 42.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624


    videoElement.preload = "auto";
    _this.version =
    /*PLAYER_VERSION*/
    "3.21.1";
    _this.log = log["a" /* default */];
    _this.state = "STOPPED";
    _this.videoElement = videoElement;
    _this._priv_destroy$ = new Subject["a" /* Subject */]();
    _this._priv_pictureInPictureEvent$ = new ReplaySubject["a" /* ReplaySubject */](1);
    onPictureInPictureEvent$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$)).subscribe(_this._priv_pictureInPictureEvent$);
    /** @deprecated */

    onFullscreenChange$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$))
    /* tslint:disable deprecation */
    .subscribe(function () {
      return _this.trigger("fullscreenChange", _this.isFullscreen());
    });
    /* tslint:enable deprecation */

    /** @deprecated */

    onTextTrackChanges$(videoElement.textTracks).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$), Object(map["a" /* map */])(function (evt) {
      var target = evt.target;
      var arr = [];

      for (var i = 0; i < target.length; i++) {
        var textTrack = target[i];
        arr.push(textTrack);
      }

      return arr;
    }), // We can have two consecutive textTrackChanges with the exact same
    // payload when we perform multiple texttrack operations before the event
    // loop is freed.
    // In that case we only want to fire one time the observable.
    Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (textTracksA, textTracksB) {
      if (textTracksA.length !== textTracksB.length) {
        return false;
      }

      for (var i = 0; i < textTracksA.length; i++) {
        if (textTracksA[i] !== textTracksB[i]) {
          return false;
        }
      }

      return true;
    })).subscribe(function (x) {
      return _this._priv_onNativeTextTracksNext(x);
    });
    _this._priv_playing$ = new ReplaySubject["a" /* ReplaySubject */](1);
    _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate);
    _this._priv_stopCurrentContent$ = new Subject["a" /* Subject */]();
    _this._priv_contentLock$ = new BehaviorSubject_BehaviorSubject(false);
    _this._priv_bufferOptions = {
      wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
      maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
      maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
    };
    _this._priv_bitrateInfos = {
      lastBitrates: {
        audio: initialAudioBitrate,
        video: initialVideoBitrate
      },
      maxAutoBitrates: {
        audio: new BehaviorSubject_BehaviorSubject(maxAudioBitrate),
        video: new BehaviorSubject_BehaviorSubject(maxVideoBitrate)
      },
      manualBitrates: {
        audio: new BehaviorSubject_BehaviorSubject(-1),
        video: new BehaviorSubject_BehaviorSubject(-1)
      }
    };
    _this._priv_throttleWhenHidden = throttleWhenHidden;
    _this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;
    _this._priv_limitVideoWidth = limitVideoWidth;
    _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
    _this._priv_trackChoiceManager = null;
    _this._priv_mediaElementTrackChoiceManager = null;
    _this._priv_currentError = null;
    _this._priv_contentInfos = null;
    _this._priv_contentEventsMemory = {};
    _this._priv_stopAtEnd = stopAtEnd;

    _this._priv_setPlayerState(PLAYER_STATES.STOPPED);

    _this._priv_preferredAudioTracks = preferredAudioTracks;
    _this._priv_preferredTextTracks = preferredTextTracks;
    _this._priv_preferredVideoTracks = preferredVideoTracks;
    return _this;
  }
  /** All possible Error types emitted by the RxPlayer. */


  var _proto = Player.prototype;

  /**
   * Stop the playback for the current content.
   */
  _proto.stop = function stop() {
    if (this.state !== PLAYER_STATES.STOPPED) {
      this._priv_stopCurrentContent$.next();

      this._priv_cleanUpCurrentContentState();

      this._priv_setPlayerState(PLAYER_STATES.STOPPED);
    }
  }
  /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */
  ;

  _proto.dispose = function dispose() {
    // free resources linked to the loaded content
    this.stop();

    if (this.videoElement !== null) {
      // free resources used for EME management
      Object(dispose_eme["a" /* default */])(this.videoElement);
    } // free Observables linked to the Player instance


    this._priv_destroy$.next();

    this._priv_destroy$.complete(); // Complete all subjects


    this._priv_stopCurrentContent$.complete();

    this._priv_playing$.complete();

    this._priv_speed$.complete();

    this._priv_contentLock$.complete();

    this._priv_bufferOptions.wantedBufferAhead$.complete();

    this._priv_bufferOptions.maxBufferAhead$.complete();

    this._priv_bufferOptions.maxBufferBehind$.complete();

    this._priv_pictureInPictureEvent$.complete();

    this._priv_bitrateInfos.manualBitrates.video.complete();

    this._priv_bitrateInfos.manualBitrates.audio.complete();

    this._priv_bitrateInfos.maxAutoBitrates.video.complete();

    this._priv_bitrateInfos.maxAutoBitrates.audio.complete(); // un-attach video element


    this.videoElement = null;
  }
  /**
   * Load a new video.
   * @param {Object} opts
   */
  ;

  _proto.loadVideo = function loadVideo(opts) {
    var _this2 = this;

    var _a, _b, _c;

    var options = parseLoadVideoOptions(opts);
    log["a" /* default */].info("API: Calling loadvideo", options);
    var autoPlay = options.autoPlay,
        defaultAudioTrack = options.defaultAudioTrack,
        defaultTextTrack = options.defaultTextTrack,
        keySystems = options.keySystems,
        lowLatencyMode = options.lowLatencyMode,
        manualBitrateSwitchingMode = options.manualBitrateSwitchingMode,
        manifestUpdateUrl = options.manifestUpdateUrl,
        minimumManifestUpdateInterval = options.minimumManifestUpdateInterval,
        networkConfig = options.networkConfig,
        startAt = options.startAt,
        transport = options.transport,
        transportOptions = options.transportOptions,
        url = options.url; // Perform multiple checks on the given options

    if (this.videoElement === null) {
      throw new Error("the attached video element is disposed");
    } // now that every checks have passed, stop previous content


    this.stop();
    var isDirectFile = transport === "directfile";
    this._priv_currentError = null;
    this._priv_contentInfos = {
      url: url,
      isDirectFile: isDirectFile,
      sourceBuffersStore: null,
      thumbnails: null,
      manifest: null,
      currentPeriod: null,
      activeAdaptations: null,
      activeRepresentations: null,
      initialAudioTrack: defaultAudioTrack,
      initialTextTrack: defaultTextTrack
    }; // inilialize `_priv_playing$` to false (meaning the content is not playing yet)

    this._priv_playing$.next(false);

    var videoElement = this.videoElement;
    /** Global "clock" used for content playback */

    var clock$ = api_clock(videoElement, {
      withMediaSource: !isDirectFile,
      lowLatencyMode: lowLatencyMode
    });
    /** Emit when the current content has been stopped. */

    var contentIsStopped$ = Object(merge["a" /* merge */])(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? onEnded$(videoElement) : empty["a" /* EMPTY */]).pipe(Object(take["a" /* take */])(1));
    /** Emit playback events. */

    var playback$;

    if (!isDirectFile) {
      var transportFn = features["a" /* default */].transports[transport];

      if (typeof transportFn !== "function") {
        throw new Error("transport \"" + transport + "\" not supported");
      }

      var transportPipelines = transportFn(transportOptions);
      /** Options used by the ABR Manager. */

      var adaptiveOptions = {
        initialBitrates: this._priv_bitrateInfos.lastBitrates,
        lowLatencyMode: lowLatencyMode,
        manualBitrates: this._priv_bitrateInfos.manualBitrates,
        maxAutoBitrates: this._priv_bitrateInfos.maxAutoBitrates,
        throttlers: {
          throttle: this._priv_throttleWhenHidden ? {
            video: isActive().pipe(Object(map["a" /* map */])(function (active) {
              return active ? Infinity : 0;
            }), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {},
          throttleBitrate: this._priv_throttleVideoBitrateWhenHidden ? {
            video: isVideoVisible(this._priv_pictureInPictureEvent$).pipe(Object(map["a" /* map */])(function (active) {
              return active ? Infinity : 0;
            }), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {},
          limitWidth: this._priv_limitVideoWidth ? {
            video: videoWidth$(videoElement, this._priv_pictureInPictureEvent$).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {}
        }
      };
      /** Options used by the TextTrack SourceBuffer. */

      var textTrackOptions = options.textTrackMode === "native" ? {
        textTrackMode: "native",
        hideNativeSubtitle: options.hideNativeSubtitle
      } : {
        textTrackMode: "html",
        textTrackElement: options.textTrackElement
      };
      var bufferOptions = Object(object_assign["a" /* default */])({
        manualBitrateSwitchingMode: manualBitrateSwitchingMode
      }, this._priv_bufferOptions); // We've every options set up. Start everything now

      var init$ = init({
        adaptiveOptions: adaptiveOptions,
        autoPlay: autoPlay,
        bufferOptions: bufferOptions,
        clock$: clock$,
        keySystems: keySystems,
        lowLatencyMode: lowLatencyMode,
        manifestUpdateUrl: manifestUpdateUrl,
        mediaElement: videoElement,
        minimumManifestUpdateInterval: minimumManifestUpdateInterval,
        networkConfig: networkConfig,
        transportPipelines: transportPipelines,
        speed$: this._priv_speed$,
        startAt: startAt,
        textTrackOptions: textTrackOptions,
        url: url
      }).pipe(Object(takeUntil["a" /* takeUntil */])(contentIsStopped$));
      playback$ = publish()(init$);
    } else {
      if (features["a" /* default */].directfile === null) {
        throw new Error("DirectFile feature not activated in your build.");
      }

      this._priv_mediaElementTrackChoiceManager = new features["a" /* default */].directfile.mediaElementTrackChoiceManager(this.videoElement);
      var preferredAudioTracks = defaultAudioTrack === undefined ? this._priv_preferredAudioTracks : [defaultAudioTrack];

      this._priv_mediaElementTrackChoiceManager.setPreferredAudioTracks(preferredAudioTracks, true);

      var preferredTextTracks = defaultTextTrack === undefined ? this._priv_preferredTextTracks : [defaultTextTrack];

      this._priv_mediaElementTrackChoiceManager.setPreferredTextTracks(preferredTextTracks, true);

      this._priv_mediaElementTrackChoiceManager.setPreferredVideoTracks(this._priv_preferredVideoTracks, true);

      this.trigger("availableAudioTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableAudioTracks());
      this.trigger("availableVideoTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableVideoTracks());
      this.trigger("availableTextTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableTextTracks());
      this.trigger("audioTrackChange", (_a = this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack()) !== null && _a !== void 0 ? _a : null);
      this.trigger("textTrackChange", (_b = this._priv_mediaElementTrackChoiceManager.getChosenTextTrack()) !== null && _b !== void 0 ? _b : null);
      this.trigger("videoTrackChange", (_c = this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack()) !== null && _c !== void 0 ? _c : null);

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableVideoTracksChange", function (val) {
        return _this2.trigger("availableVideoTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableAudioTracksChange", function (val) {
        return _this2.trigger("availableAudioTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableTextTracksChange", function (val) {
        return _this2.trigger("availableTextTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("audioTrackChange", function (val) {
        return _this2.trigger("audioTrackChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("videoTrackChange", function (val) {
        return _this2.trigger("videoTrackChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("textTrackChange", function (val) {
        return _this2.trigger("textTrackChange", val);
      });

      var directfileInit$ = features["a" /* default */].directfile.initDirectFile({
        autoPlay: autoPlay,
        clock$: clock$,
        keySystems: keySystems,
        mediaElement: videoElement,
        speed$: this._priv_speed$,
        startAt: startAt,
        url: url
      }).pipe(Object(takeUntil["a" /* takeUntil */])(contentIsStopped$));
      playback$ = publish()(directfileInit$);
    }
    /** Emit an object when the player "stalls" and null when it un-stalls */


    var stalled$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "stalled";
    }), Object(map["a" /* map */])(function (x) {
      return x.value;
    }));
    /** Emit when the content is considered "loaded". */

    var loaded$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "loaded";
    }), Object(share["a" /* share */])());
    /** Emit when we will "reload" the MediaSource. */

    var reloading$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "reloading-media-source";
    }), Object(share["a" /* share */])());
    /** Emit when the media element emits an "ended" event. */

    var endedEvent$ = onEnded$(videoElement);
    /** Emit when the media element emits a "seeking" event. */

    var seekingEvent$ = onSeeking$(videoElement);
    /** Emit state updates once the content is considered "loaded". */

    var loadedStateUpdates$ = Object(combineLatest["a" /* combineLatest */])([this._priv_playing$, stalled$.pipe(Object(startWith["a" /* startWith */])(null)), endedEvent$.pipe(Object(startWith["a" /* startWith */])(null)), seekingEvent$.pipe(Object(startWith["a" /* startWith */])(null))]).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$), Object(map["a" /* map */])(function (_ref) {
      var isPlaying = _ref[0],
          stalledStatus = _ref[1];
      return getLoadedContentState(videoElement, isPlaying, stalledStatus);
    }));
    /** Emit all player "state" updates. */

    var playerState$ = Object(concat["a" /* concat */])(Object(of["a" /* of */])(PLAYER_STATES.LOADING), // Begin with LOADING
    // LOADED as soon as the first "loaded" event is sent
    loaded$.pipe(Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(PLAYER_STATES.LOADED)), Object(merge["a" /* merge */])(loadedStateUpdates$.pipe( // From the first reload onward, we enter another dynamic (below)
    Object(takeUntil["a" /* takeUntil */])(reloading$), skipWhile(function (state) {
      return state === PLAYER_STATES.PAUSED;
    })), // when reloading
    reloading$.pipe(Object(switchMapTo["a" /* switchMapTo */])(loaded$.pipe(Object(take["a" /* take */])(1), // wait for the next loaded event
    Object(mergeMapTo["a" /* mergeMapTo */])(loadedStateUpdates$), // to update the state as usual
    Object(startWith["a" /* startWith */])(PLAYER_STATES.RELOADING) // Starts with "RELOADING" state
    ))))).pipe(Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
    var playbackSubscription;

    this._priv_stopCurrentContent$.pipe(Object(take["a" /* take */])(1)).subscribe(function () {
      if (playbackSubscription !== undefined) {
        playbackSubscription.unsubscribe();
      }
    }); // Link `_priv_onPlayPauseNext` Observable to "play"/"pause" events


    onPlayPause$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (e) {
      return _this2._priv_onPlayPauseNext(e.type === "play");
    }, noop["a" /* default */]); // Link "positionUpdate" events to the clock

    clock$.pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (x) {
      return _this2._priv_triggerPositionUpdate(x);
    }, noop["a" /* default */]); // Link "seeking" and "seeked" events (once the content is loaded)

    loaded$.pipe(Object(switchMapTo["a" /* switchMapTo */])(emitSeekEvents(this.videoElement, clock$)), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (evt) {
      log["a" /* default */].info("API: Triggering \"" + evt + "\" event");

      _this2.trigger(evt, null);
    }); // Handle state updates

    playerState$.pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (x) {
      return _this2._priv_setPlayerState(x);
    }, noop["a" /* default */]); // Link playback events to the corresponding callbacks

    playback$.subscribe(function (x) {
      return _this2._priv_onPlaybackEvent(x);
    }, function (err) {
      return _this2._priv_onPlaybackError(err);
    }, function () {
      return _this2._priv_onPlaybackFinished();
    }); // initialize the content only when the lock is inactive

    this._priv_contentLock$.pipe(Object(filter["a" /* filter */])(function (isLocked) {
      return !isLocked;
    }), Object(take["a" /* take */])(1), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function () {
      // start playback!
      playbackSubscription = playback$.connect();
    });
  }
  /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null} - The current Error (`null` when no error).
   */
  ;

  _proto.getError = function getError() {
    return this._priv_currentError;
  }
  /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @deprecated
   * @returns {Manifest|null} - The current Manifest (`null` when not known).
   */
  ;

  _proto.getManifest = function getManifest() {
    Object(warn_once["a" /* default */])("getManifest is deprecated." + " Please open an issue if you used this API.");

    if (this._priv_contentInfos === null) {
      return null;
    }

    return this._priv_contentInfos.manifest;
  }
  /**
   * Returns Adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @deprecated
   * @returns {Object|null} - The current Adaptation objects, per type (`null`
   * when none is known for now.
   */
  ;

  _proto.getCurrentAdaptations = function getCurrentAdaptations() {
    Object(warn_once["a" /* default */])("getCurrentAdaptations is deprecated." + " Please open an issue if you used this API.");

    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn.currentPeriod,
        activeAdaptations = _this$_priv_contentIn.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null || Object(is_null_or_undefined["a" /* default */])(activeAdaptations[currentPeriod.id])) {
      return null;
    }

    return activeAdaptations[currentPeriod.id];
  }
  /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @deprecated
   * @returns {Object|null} - The current Representation objects, per type
   * (`null` when none is known for now.
   */
  ;

  _proto.getCurrentRepresentations = function getCurrentRepresentations() {
    Object(warn_once["a" /* default */])("getCurrentRepresentations is deprecated." + " Please open an issue if you used this API.");
    return this._priv_getCurrentRepresentations();
  }
  /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when
   * disposed)
   */
  ;

  _proto.getVideoElement = function getVideoElement() {
    return this.videoElement;
  }
  /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack} - The native TextTrack attached (`null` when none)
   */
  ;

  _proto.getNativeTextTrack = function getNativeTextTrack() {
    Object(warn_once["a" /* default */])("getNativeTextTrack is deprecated." + " Please open an issue if you used this API.");

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    var textTracks = videoElement.textTracks;

    if (textTracks.length > 0) {
      return videoElement.textTracks[0];
    } else {
      return null;
    }
  }
  /**
   * Returns the player's current state.
   * @returns {string} - The current Player's state
   */
  ;

  _proto.getPlayerState = function getPlayerState() {
    return this.state;
  }
  /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.
   */
  ;

  _proto.isLive = function isLive() {
    if (this._priv_contentInfos === null) {
      return false;
    }

    var _this$_priv_contentIn2 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn2.isDirectFile,
        manifest = _this$_priv_contentIn2.manifest;

    if (isDirectFile || manifest === null) {
      return false;
    }

    return manifest.isLive;
  }
  /**
   * Returns the url of the content's manifest
   * @returns {string|undefined} - Current URL. `undefined` if not known or no
   * URL yet.
   */
  ;

  _proto.getUrl = function getUrl() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn3 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn3.isDirectFile,
        manifest = _this$_priv_contentIn3.manifest,
        url = _this$_priv_contentIn3.url;

    if (isDirectFile) {
      return url;
    }

    if (manifest !== null) {
      return manifest.getUrl();
    }

    return undefined;
  }
  /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */
  ;

  _proto.getVideoDuration = function getVideoDuration() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.duration;
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */
  ;

  _proto.getVideoBufferGap = function getVideoBufferGap() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["d" /* getLeftSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
  ;

  _proto.getVideoLoadedTime = function getVideoLoadedTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["h" /* getSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
  ;

  _proto.getVideoPlayedTime = function getVideoPlayedTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["f" /* getPlayedSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */
  ;

  _proto.getWallClockTime = function getWallClockTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (this._priv_contentInfos === null) {
      return this.videoElement.currentTime;
    }

    var _this$_priv_contentIn4 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn4.isDirectFile,
        manifest = _this$_priv_contentIn4.manifest;

    if (isDirectFile) {
      return this.videoElement.currentTime;
    }

    if (manifest !== null) {
      var currentTime = this.videoElement.currentTime;
      var ast = manifest.availabilityStartTime !== undefined ? manifest.availabilityStartTime : 0;
      return currentTime + ast;
    }

    return 0;
  }
  /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */
  ;

  _proto.getPosition = function getPosition() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.currentTime;
  }
  /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */
  ;

  _proto.getPlaybackRate = function getPlaybackRate() {
    return this._priv_speed$.getValue();
  }
  /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */
  ;

  _proto.setPlaybackRate = function setPlaybackRate(rate) {
    this._priv_speed$.next(rate);
  }
  /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */
  ;

  _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn5 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn5.currentPeriod,
        activeAdaptations = _this$_priv_contentIn5.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }

    var adaptations = activeAdaptations[currentPeriod.id];

    if (adaptations === undefined || Object(is_null_or_undefined["a" /* default */])(adaptations.video)) {
      return [];
    }

    return adaptations.video.getAvailableBitrates();
  }
  /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */
  ;

  _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn6 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn6.currentPeriod,
        activeAdaptations = _this$_priv_contentIn6.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }

    var adaptations = activeAdaptations[currentPeriod.id];

    if (adaptations === undefined || Object(is_null_or_undefined["a" /* default */])(adaptations.audio)) {
      return [];
    }

    return adaptations.audio.getAvailableBitrates();
  }
  /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
  ;

  _proto.getManualAudioBitrate = function getManualAudioBitrate() {
    return this._priv_bitrateInfos.manualBitrates.audio.getValue();
  }
  /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
  ;

  _proto.getManualVideoBitrate = function getManualVideoBitrate() {
    return this._priv_bitrateInfos.manualBitrates.video.getValue();
  }
  /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */
  ;

  _proto.getVideoBitrate = function getVideoBitrate() {
    var representations = this._priv_getCurrentRepresentations();

    if (representations === null || Object(is_null_or_undefined["a" /* default */])(representations.video)) {
      return undefined;
    }

    return representations.video.bitrate;
  }
  /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */
  ;

  _proto.getAudioBitrate = function getAudioBitrate() {
    var representations = this._priv_getCurrentRepresentations();

    if (representations === null || Object(is_null_or_undefined["a" /* default */])(representations.audio)) {
      return undefined;
    }

    return representations.audio.bitrate;
  }
  /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */
  ;

  _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
  }
  /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */
  ;

  _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
  }
  /**
   * Play/Resume the current video.
   * @returns {Promise}
   */
  ;

  _proto.play = function play() {
    var _this3 = this;

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var playPromise = this.videoElement.play();
    /* tslint:disable no-unbound-method */

    if (Object(is_null_or_undefined["a" /* default */])(playPromise) || typeof playPromise["catch"] !== "function") {
      /* tslint:enable no-unbound-method */
      return promise["a" /* default */].resolve();
    }

    return playPromise["catch"](function (error) {
      if (error.name === "NotAllowedError") {
        var warning = new media_error["a" /* default */]("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());

        _this3.trigger("warning", warning);
      }

      throw error;
    });
  }
  /**
   * Pause the current video.
   */
  ;

  _proto.pause = function pause() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    this.videoElement.pause();
  }
  /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */
  ;

  _proto.seekTo = function seekTo(time) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (this._priv_contentInfos === null) {
      throw new Error("player: no content loaded");
    }

    var _this$_priv_contentIn7 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn7.isDirectFile,
        manifest = _this$_priv_contentIn7.manifest;

    if (!isDirectFile && manifest === null) {
      throw new Error("player: the content did not load yet");
    }

    var positionWanted;

    if (typeof time === "number") {
      positionWanted = time;
    } else if (typeof time === "object") {
      var timeObj = time;
      var currentTs = this.videoElement.currentTime;

      if (!Object(is_null_or_undefined["a" /* default */])(timeObj.relative)) {
        positionWanted = currentTs + timeObj.relative;
      } else if (!Object(is_null_or_undefined["a" /* default */])(timeObj.position)) {
        positionWanted = timeObj.position;
      } else if (!Object(is_null_or_undefined["a" /* default */])(timeObj.wallClockTime)) {
        positionWanted = isDirectFile || manifest === null ? timeObj.wallClockTime : timeObj.wallClockTime - (manifest.availabilityStartTime !== undefined ? manifest.availabilityStartTime : 0);
      } else {
        throw new Error("invalid time object. You must set one of the " + "following properties: \"relative\", \"position\" or " + "\"wallClockTime\"");
      }
    }

    if (positionWanted === undefined) {
      throw new Error("invalid time given");
    }

    this.videoElement.currentTime = positionWanted;
    return positionWanted;
  }
  /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */
  ;

  _proto.isFullscreen = function isFullscreen() {
    Object(warn_once["a" /* default */])("isFullscreen is deprecated." + " Fullscreen management should now be managed by the application");
    return Object(fullscreen["b" /* isFullscreen */])();
  }
  /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */
  ;

  _proto.setFullscreen = function setFullscreen(goFull) {
    if (goFull === void 0) {
      goFull = true;
    }

    Object(warn_once["a" /* default */])("setFullscreen is deprecated." + " Fullscreen management should now be managed by the application");

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (goFull) {
      Object(fullscreen["c" /* requestFullscreen */])(this.videoElement);
    } else {
      Object(fullscreen["a" /* exitFullscreen */])();
    }
  }
  /**
   * Exit from full screen mode.
   * @deprecated
   */
  ;

  _proto.exitFullscreen = function exitFullscreen() {
    Object(warn_once["a" /* default */])("exitFullscreen is deprecated." + " Fullscreen management should now be managed by the application");

    Object(fullscreen["a" /* exitFullscreen */])();
  }
  /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */
  ;

  _proto.getVolume = function getVolume() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.volume;
  }
  /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */
  ;

  _proto.setVolume = function setVolume(volume) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;

    if (volume !== videoElement.volume) {
      videoElement.volume = volume;
      this.trigger("volumeChange", volume);
    }
  }
  /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */
  ;

  _proto.isMute = function isMute() {
    return this.getVolume() === 0;
  }
  /**
   * Set the volume to 0 and save current one for when unmuted.
   */
  ;

  _proto.mute = function mute() {
    this._priv_mutedMemory = this.getVolume();
    this.setVolume(0);
  }
  /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */
  ;

  _proto.unMute = function unMute() {
    var vol = this.getVolume();

    if (vol === 0) {
      this.setVolume(this._priv_mutedMemory === 0 ? DEFAULT_UNMUTED_VOLUME : this._priv_mutedMemory);
    }
  }
  /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
  ;

  _proto.setVideoBitrate = function setVideoBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.video.next(btr);
  }
  /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
  ;

  _proto.setAudioBitrate = function setAudioBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.audio.next(btr);
  }
  /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */
  ;

  _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
    this._priv_bitrateInfos.maxAutoBitrates.video.next(btr);
  }
  /**
   * Update the maximum audio bitrate the user can switch to.
   * @param {Number} btr
   */
  ;

  _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
    this._priv_bitrateInfos.maxAutoBitrates.audio.next(btr);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
  ;

  _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
    this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
  ;

  _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
    this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */
  ;

  _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
    this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
  ;

  _proto.getMaxBufferBehind = function getMaxBufferBehind() {
    return this._priv_bufferOptions.maxBufferBehind$.getValue();
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
  ;

  _proto.getMaxBufferAhead = function getMaxBufferAhead() {
    return this._priv_bufferOptions.maxBufferAhead$.getValue();
  }
  /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */
  ;

  _proto.getWantedBufferAhead = function getWantedBufferAhead() {
    return this._priv_bufferOptions.wantedBufferAhead$.getValue();
  }
  /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */
  ;

  _proto.getCurrentKeySystem = function getCurrentKeySystem() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return Object(get_current_key_system["a" /* default */])(this.videoElement);
  }
  /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn8 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn8.currentPeriod,
        isDirectFile = _this$_priv_contentIn8.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableAudioTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableAudioTracks(currentPeriod);
  }
  /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn9 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn9.currentPeriod,
        isDirectFile = _this$_priv_contentIn9.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableTextTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableTextTracks(currentPeriod);
  }
  /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn10 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn10.currentPeriod,
        isDirectFile = _this$_priv_contentIn10.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableVideoTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableVideoTracks(currentPeriod);
  }
  /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */
  ;

  _proto.getAudioTrack = function getAudioTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn11 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn11.currentPeriod,
        isDirectFile = _this$_priv_contentIn11.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenAudioTrack(currentPeriod);
  }
  /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */
  ;

  _proto.getTextTrack = function getTextTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn12 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn12.currentPeriod,
        isDirectFile = _this$_priv_contentIn12.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenTextTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenTextTrack(currentPeriod);
  }
  /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */
  ;

  _proto.getVideoTrack = function getVideoTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn13 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn13.currentPeriod,
        isDirectFile = _this$_priv_contentIn13.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenVideoTrack(currentPeriod);
  }
  /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no audio track.
   */
  ;

  _proto.setAudioTrack = function setAudioTrack(audioId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn14 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn14.currentPeriod,
        isDirectFile = _this$_priv_contentIn14.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setAudioTrackById(audioId);
        return;
      } catch (e) {
        throw new Error("player: unknown audio track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setAudioTrackByID(currentPeriod, audioId);
    } catch (e) {
      throw new Error("player: unknown audio track");
    }
  }
  /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no text track.
   */
  ;

  _proto.setTextTrack = function setTextTrack(textId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn15 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn15.currentPeriod,
        isDirectFile = _this$_priv_contentIn15.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setTextTrackById(textId);
        return;
      } catch (e) {
        throw new Error("player: unknown text track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setTextTrackByID(currentPeriod, textId);
    } catch (e) {
      throw new Error("player: unknown text track");
    }
  }
  /**
   * Disable subtitles for the current content.
   */
  ;

  _proto.disableTextTrack = function disableTextTrack() {
    var _a;

    if (this._priv_contentInfos === null) {
      return;
    }

    var _this$_priv_contentIn16 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn16.currentPeriod,
        isDirectFile = _this$_priv_contentIn16.isDirectFile;

    if (isDirectFile) {
      (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.disableTextTrack();
      return;
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return;
    }

    return this._priv_trackChoiceManager.disableTextTrack(currentPeriod);
  }
  /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no video track.
   */
  ;

  _proto.setVideoTrack = function setVideoTrack(videoId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn17 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn17.currentPeriod,
        isDirectFile = _this$_priv_contentIn17.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setVideoTrackById(videoId);
        return;
      } catch (e) {
        throw new Error("player: unknown video track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setVideoTrackByID(currentPeriod, videoId);
    } catch (e) {
      throw new Error("player: unknown video track");
    }
  }
  /**
   * Disable video track for the current content.
   */
  ;

  _proto.disableVideoTrack = function disableVideoTrack() {
    if (this._priv_contentInfos === null) {
      return;
    }

    var _this$_priv_contentIn18 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn18.currentPeriod,
        isDirectFile = _this$_priv_contentIn18.isDirectFile;

    if (isDirectFile && this._priv_mediaElementTrackChoiceManager !== null) {
      return this._priv_mediaElementTrackChoiceManager.disableVideoTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return;
    }

    return this._priv_trackChoiceManager.disableVideoTrack(currentPeriod);
  }
  /**
   * Returns the current list of preferred audio tracks, in preference order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPreferredAudioTracks = function getPreferredAudioTracks() {
    return this._priv_preferredAudioTracks;
  }
  /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPreferredTextTracks = function getPreferredTextTracks() {
    return this._priv_preferredTextTracks;
  }
  /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPreferredVideoTracks = function getPreferredVideoTracks() {
    return this._priv_preferredVideoTracks;
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }

    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredAudioTracks` argument. " + "Should have been an Array.");
    }

    this._priv_preferredAudioTracks = tracks;

    if (this._priv_trackChoiceManager !== null) {
      this._priv_trackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
    } else if (this._priv_mediaElementTrackChoiceManager !== null) {
      this._priv_mediaElementTrackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Periods. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredTextTracks = function setPreferredTextTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }

    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredTextTracks` argument. " + "Should have been an Array.");
    }

    this._priv_preferredTextTracks = tracks;

    if (this._priv_trackChoiceManager !== null) {
      this._priv_trackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
    } else if (this._priv_mediaElementTrackChoiceManager !== null) {
      this._priv_mediaElementTrackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
    }
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   * @param {boolean} shouldApply - `true` if those preferences should be
   * applied on the currently loaded Period. `false` if it should only
   * be applied to new content.
   */
  ;

  _proto.setPreferredVideoTracks = function setPreferredVideoTracks(tracks, shouldApply) {
    if (shouldApply === void 0) {
      shouldApply = false;
    }

    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredVideoTracks` argument. " + "Should have been an Array.");
    }

    this._priv_preferredVideoTracks = tracks;

    if (this._priv_trackChoiceManager !== null) {
      this._priv_trackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
    } else if (this._priv_mediaElementTrackChoiceManager !== null) {
      this._priv_mediaElementTrackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
    }
  }
  /**
   * @returns {Array.<Object>|null}
   * @deprecated
   */
  ;

  _proto.getImageTrackData = function getImageTrackData() {
    Object(warn_once["a" /* default */])("`getImageTrackData` is deprecated." + "Please use the `parseBifThumbnails` tool instead.");

    if (this._priv_contentInfos === null) {
      return null;
    }
    /* tslint:disable deprecation */


    return this._priv_contentInfos.thumbnails;
    /* tslint:enable deprecation */
  }
  /**
   * Get minimum seek-able position.
   * @returns {number}
   */
  ;

  _proto.getMinimumPosition = function getMinimumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    if (this._priv_contentInfos.isDirectFile) {
      return 0;
    }

    var manifest = this._priv_contentInfos.manifest;

    if (manifest !== null) {
      return manifest.getMinimumPosition();
    }

    return null;
  }
  /**
   * Get maximum seek-able position.
   * @returns {number}
   */
  ;

  _proto.getMaximumPosition = function getMaximumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn19 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn19.isDirectFile,
        manifest = _this$_priv_contentIn19.manifest;

    if (isDirectFile) {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }

      return this.videoElement.duration;
    }

    if (manifest !== null) {
      return manifest.getMaximumPosition();
    }

    return null;
  }
  /**
   * /!\ For demo use only! Do not touch!
   *
   * Returns every chunk buffered for a given buffer type.
   * Returns `null` if no SourceBuffer was created for this type of buffer.
   * @param {string} bufferType
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.__priv_getSourceBufferContent = function __priv_getSourceBufferContent(bufferType) {
    if (this._priv_contentInfos === null || this._priv_contentInfos.sourceBuffersStore === null) {
      return null;
    }

    var sourceBufferStatus = this._priv_contentInfos.sourceBuffersStore.getStatus(bufferType);

    return sourceBufferStatus.type === "initialized" ? sourceBufferStatus.value.getInventory() : null;
  }
  /**
   * Reset all state properties relative to a playing content.
   */
  ;

  _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
    var _this4 = this;

    var _a;

    log["a" /* default */].debug("Locking `contentLock` to clean-up the current content."); // lock playback of new contents while cleaning up is pending

    this._priv_contentLock$.next(true);

    this._priv_contentInfos = null;
    this._priv_trackChoiceManager = null;
    (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.dispose();
    this._priv_mediaElementTrackChoiceManager = null;
    this._priv_contentEventsMemory = {}; // EME cleaning

    var freeUpContentLock = function freeUpContentLock() {
      log["a" /* default */].debug("Unlocking `contentLock`. Next content can begin.");

      _this4._priv_contentLock$.next(false);
    };

    if (!Object(is_null_or_undefined["a" /* default */])(this.videoElement)) {
      Object(clear_eme_session["a" /* default */])(this.videoElement).subscribe(noop["a" /* default */], function (err) {
        log["a" /* default */].error("API: An error arised when trying to clean-up the EME session:" + (err instanceof Error ? err.toString() : "Unknown Error"));
        freeUpContentLock();
      }, function () {
        log["a" /* default */].debug("API: EME session cleaned-up with success!");
        freeUpContentLock();
      });
    } else {
      freeUpContentLock();
    }
  }
  /**
   * Triggered each time the playback Observable emits.
   *
   * React to various events.
   *
   * @param {Object} event - payload emitted
   */
  ;

  _proto._priv_onPlaybackEvent = function _priv_onPlaybackEvent(event) {
    switch (event.type) {
      case "stream-event":
        this.trigger("streamEvent", event.value);
        break;

      case "stream-event-skip":
        this.trigger("streamEventSkip", event.value);
        break;

      case "activePeriodChanged":
        this._priv_onActivePeriodChanged(event.value);

        break;

      case "periodStreamReady":
        this._priv_onPeriodStreamReady(event.value);

        break;

      case "periodStreamCleared":
        this._priv_onPeriodStreamCleared(event.value);

        break;

      case "reloading-media-source":
        this._priv_onReloadingMediaSource();

        break;

      case "representationChange":
        this._priv_onRepresentationChange(event.value);

        break;

      case "adaptationChange":
        this._priv_onAdaptationChange(event.value);

        break;

      case "bitrateEstimationChange":
        this._priv_onBitrateEstimationChange(event.value);

        break;

      case "manifestReady":
        this._priv_onManifestReady(event.value);

        break;

      case "warning":
        this._priv_onPlaybackWarning(event.value);

        break;

      case "loaded":
        if (this._priv_contentInfos === null) {
          log["a" /* default */].error("API: Loaded event while no content is loaded");
          return;
        }

        this._priv_contentInfos.sourceBuffersStore = event.value.sourceBuffersStore;
        break;

      case "decipherabilityUpdate":
        this.trigger("decipherabilityUpdate", event.value);
        break;

      case "added-segment":
        if (this._priv_contentInfos === null) {
          log["a" /* default */].error("API: Added segment while no content is loaded");
          return;
        } // Manage image tracks
        // @deprecated


        var _event$value = event.value,
            content = _event$value.content,
            segmentData = _event$value.segmentData;

        if (content.adaptation.type === "image") {
          if (!Object(is_null_or_undefined["a" /* default */])(segmentData) && segmentData.type === "bif") {
            var imageData = segmentData.data;
            /* tslint:disable deprecation */

            this._priv_contentInfos.thumbnails = imageData;
            this.trigger("imageTrackUpdate", {
              data: this._priv_contentInfos.thumbnails
            });
            /* tslint:enable deprecation */
          }
        }

    }
  }
  /**
   * Triggered when we received a fatal error.
   * Clean-up ressources and signal that the content has stopped on error.
   * @param {Error} error
   */
  ;

  _proto._priv_onPlaybackError = function _priv_onPlaybackError(error) {
    var formattedError = formatError(error, {
      defaultCode: "NONE",
      defaultReason: "An unknown error stopped content playback."
    });
    formattedError.fatal = true;

    this._priv_stopCurrentContent$.next();

    this._priv_cleanUpCurrentContentState();

    this._priv_currentError = formattedError;
    log["a" /* default */].error("API: The player stopped because of an error:", error);

    this._priv_setPlayerState(PLAYER_STATES.STOPPED); // TODO This condition is here because the eventual callback called when the
    // player state is updated can launch a new content, thus the error will not
    // be here anymore, in which case triggering the "error" event is unwanted.
    // This is very ugly though, and we should probable have a better solution


    if (this._priv_currentError === formattedError) {
      this.trigger("error", formattedError);
    }
  }
  /**
   * Triggered when the playback Observable completes.
   * Clean-up ressources and signal that the content has ended.
   */
  ;

  _proto._priv_onPlaybackFinished = function _priv_onPlaybackFinished() {
    log["a" /* default */].info("API: Previous playback finished. Stopping and cleaning-up...");

    this._priv_stopCurrentContent$.next();

    this._priv_cleanUpCurrentContentState();

    this._priv_setPlayerState(PLAYER_STATES.ENDED);
  }
  /**
   * Triggered when we received a warning event during playback.
   * Trigger the right API event.
   * @param {Error} error
   */
  ;

  _proto._priv_onPlaybackWarning = function _priv_onPlaybackWarning(error) {
    var formattedError = formatError(error, {
      defaultCode: "NONE",
      defaultReason: "An unknown error happened."
    });
    log["a" /* default */].warn("API: Sending warning:", formattedError);
    this.trigger("warning", formattedError);
  }
  /**
   * Triggered when the Manifest has been loaded for the current content.
   * Initialize various private properties and emit initial event.
   * @param {Object} value
   */
  ;

  _proto._priv_onManifestReady = function _priv_onManifestReady(_ref2) {
    var _this5 = this;

    var manifest = _ref2.manifest;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The manifest is loaded but no content is.");
      return;
    }

    this._priv_contentInfos.manifest = manifest;
    var _this$_priv_contentIn20 = this._priv_contentInfos,
        initialAudioTrack = _this$_priv_contentIn20.initialAudioTrack,
        initialTextTrack = _this$_priv_contentIn20.initialTextTrack;
    this._priv_trackChoiceManager = new track_choice_manager_TrackChoiceManager();
    var preferredAudioTracks = initialAudioTrack === undefined ? this._priv_preferredAudioTracks : [initialAudioTrack];

    this._priv_trackChoiceManager.setPreferredAudioTracks(preferredAudioTracks, true);

    var preferredTextTracks = initialTextTrack === undefined ? this._priv_preferredTextTracks : [initialTextTrack];

    this._priv_trackChoiceManager.setPreferredTextTracks(preferredTextTracks, true);

    this._priv_trackChoiceManager.setPreferredVideoTracks(this._priv_preferredVideoTracks, true);

    Object(event_emitter["b" /* fromEvent */])(manifest, "manifestUpdate").pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function () {
      // Update the tracks chosen if it changed
      if (_this5._priv_trackChoiceManager !== null) {
        _this5._priv_trackChoiceManager.update();
      }
    });
  }
  /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} value
   */
  ;

  _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref3) {
    var period = _ref3.period;

    var _a, _b, _c, _d, _e, _f;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The active period changed but no content is loaded");
      return;
    }

    this._priv_contentInfos.currentPeriod = period;

    if (this._priv_contentEventsMemory.periodChange !== period) {
      this._priv_contentEventsMemory.periodChange = period;
      this.trigger("periodChange", period);
    }

    this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
    this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
    this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks()); // Emit intial events for the Period

    if (this._priv_trackChoiceManager !== null) {
      var audioTrack = this._priv_trackChoiceManager.getChosenAudioTrack(period);

      var textTrack = this._priv_trackChoiceManager.getChosenTextTrack(period);

      var videoTrack = this._priv_trackChoiceManager.getChosenVideoTrack(period);

      this.trigger("audioTrackChange", audioTrack);
      this.trigger("textTrackChange", textTrack);
      this.trigger("videoTrackChange", videoTrack);
    } else {
      this.trigger("audioTrackChange", null);
      this.trigger("textTrackChange", null);
      this.trigger("videoTrackChange", null);
    }

    this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates());

    this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());

    var audioBitrate = (_c = (_b = (_a = this._priv_getCurrentRepresentations()) === null || _a === void 0 ? void 0 : _a.audio) === null || _b === void 0 ? void 0 : _b.bitrate) !== null && _c !== void 0 ? _c : -1;

    this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", audioBitrate);

    var videoBitrate = (_f = (_e = (_d = this._priv_getCurrentRepresentations()) === null || _d === void 0 ? void 0 : _d.video) === null || _e === void 0 ? void 0 : _e.bitrate) !== null && _f !== void 0 ? _f : -1;

    this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", videoBitrate);
  }
  /**
   * Triggered each times a new "PeriodStream" is ready.
   * Choose the right Adaptation for the Period and emit it.
   * @param {Object} value
   */
  ;

  _proto._priv_onPeriodStreamReady = function _priv_onPeriodStreamReady(value) {
    var type = value.type,
        period = value.period,
        adaptation$ = value.adaptation$;

    switch (type) {
      case "video":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new video period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialVideoTrack(period);
        }

        break;

      case "audio":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialAudioTrack(period);
        }

        break;

      case "text":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialTextTrack(period);
        }

        break;

      default:
        var adaptations = period.adaptations[type];

        if (!Object(is_null_or_undefined["a" /* default */])(adaptations) && adaptations.length > 0) {
          adaptation$.next(adaptations[0]);
        } else {
          adaptation$.next(null);
        }

        break;
    }
  }
  /**
   * Triggered each times we "remove" a PeriodStream.
   * @param {Object} value
   */
  ;

  _proto._priv_onPeriodStreamCleared = function _priv_onPeriodStreamCleared(value) {
    var type = value.type,
        period = value.period; // Clean-up track choice from TrackChoiceManager

    switch (type) {
      case "audio":
      case "text":
      case "video":
        if (this._priv_trackChoiceManager !== null) {
          this._priv_trackChoiceManager.removePeriod(type, period);
        }

        break;
    } // Clean-up stored Representation and Adaptation information


    if (this._priv_contentInfos === null) {
      return;
    }

    var _this$_priv_contentIn21 = this._priv_contentInfos,
        activeAdaptations = _this$_priv_contentIn21.activeAdaptations,
        activeRepresentations = _this$_priv_contentIn21.activeRepresentations;

    if (!Object(is_null_or_undefined["a" /* default */])(activeAdaptations) && !Object(is_null_or_undefined["a" /* default */])(activeAdaptations[period.id])) {
      var activePeriodAdaptations = activeAdaptations[period.id];
      delete activePeriodAdaptations[type];

      if (Object.keys(activePeriodAdaptations).length === 0) {
        delete activeAdaptations[period.id];
      }
    }

    if (!Object(is_null_or_undefined["a" /* default */])(activeRepresentations) && !Object(is_null_or_undefined["a" /* default */])(activeRepresentations[period.id])) {
      var activePeriodRepresentations = activeRepresentations[period.id];
      delete activePeriodRepresentations[type];

      if (Object.keys(activePeriodRepresentations).length === 0) {
        delete activeRepresentations[period.id];
      }
    }
  }
  /**
   * Triggered each time the content is re-loaded on the MediaSource.
   */
  ;

  _proto._priv_onReloadingMediaSource = function _priv_onReloadingMediaSource() {
    if (this._priv_contentInfos !== null) {
      this._priv_contentInfos.sourceBuffersStore = null;
    }

    if (this._priv_trackChoiceManager !== null) {
      this._priv_trackChoiceManager.resetPeriods();
    }
  }
  /**
   * Triggered each times a new Adaptation is considered for the current
   * content.
   * Store given Adaptation and emit it if from the current Period.
   * @param {Object} value
   */
  ;

  _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref4) {
    var type = _ref4.type,
        adaptation = _ref4.adaptation,
        period = _ref4.period;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The adaptations changed but no content is loaded");
      return;
    } // lazily create this._priv_contentInfos.activeAdaptations


    if (this._priv_contentInfos.activeAdaptations === null) {
      this._priv_contentInfos.activeAdaptations = {};
    }

    var _this$_priv_contentIn22 = this._priv_contentInfos,
        activeAdaptations = _this$_priv_contentIn22.activeAdaptations,
        currentPeriod = _this$_priv_contentIn22.currentPeriod;
    var activePeriodAdaptations = activeAdaptations[period.id];

    if (Object(is_null_or_undefined["a" /* default */])(activePeriodAdaptations)) {
      var _activeAdaptations$pe;

      activeAdaptations[period.id] = (_activeAdaptations$pe = {}, _activeAdaptations$pe[type] = adaptation, _activeAdaptations$pe);
    } else {
      activePeriodAdaptations[type] = adaptation;
    }

    if (this._priv_trackChoiceManager !== null && currentPeriod !== null && !Object(is_null_or_undefined["a" /* default */])(period) && period.id === currentPeriod.id) {
      switch (type) {
        case "audio":
          var audioTrack = this._priv_trackChoiceManager.getChosenAudioTrack(currentPeriod);

          this.trigger("audioTrackChange", audioTrack);
          var availableAudioBitrates = this.getAvailableAudioBitrates();

          this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", availableAudioBitrates);

          break;

        case "text":
          var textTrack = this._priv_trackChoiceManager.getChosenTextTrack(currentPeriod);

          this.trigger("textTrackChange", textTrack);
          break;

        case "video":
          var videoTrack = this._priv_trackChoiceManager.getChosenVideoTrack(currentPeriod);

          this.trigger("videoTrackChange", videoTrack);
          var availableVideoBitrates = this.getAvailableVideoBitrates();

          this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", availableVideoBitrates);

          break;
      }
    }
  }
  /**
   * Triggered each times a new Representation is considered during playback.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} obj
   */
  ;

  _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref5) {
    var type = _ref5.type,
        period = _ref5.period,
        representation = _ref5.representation;

    var _a;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The representations changed but no content is loaded");
      return;
    } // lazily create this._priv_contentInfos.activeRepresentations


    if (this._priv_contentInfos.activeRepresentations === null) {
      this._priv_contentInfos.activeRepresentations = {};
    }

    var _this$_priv_contentIn23 = this._priv_contentInfos,
        activeRepresentations = _this$_priv_contentIn23.activeRepresentations,
        currentPeriod = _this$_priv_contentIn23.currentPeriod;
    var activePeriodRepresentations = activeRepresentations[period.id];

    if (Object(is_null_or_undefined["a" /* default */])(activePeriodRepresentations)) {
      var _activeRepresentation;

      activeRepresentations[period.id] = (_activeRepresentation = {}, _activeRepresentation[type] = representation, _activeRepresentation);
    } else {
      activePeriodRepresentations[type] = representation;
    }

    var bitrate = (_a = representation === null || representation === void 0 ? void 0 : representation.bitrate) !== null && _a !== void 0 ? _a : -1;

    if (!Object(is_null_or_undefined["a" /* default */])(period) && currentPeriod !== null && currentPeriod.id === period.id) {
      if (type === "video") {
        this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", bitrate);
      } else if (type === "audio") {
        this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", bitrate);
      }
    }
  }
  /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   */
  ;

  _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref6) {
    var type = _ref6.type,
        bitrate = _ref6.bitrate;

    if (bitrate !== undefined) {
      this._priv_bitrateInfos.lastBitrates[type] = bitrate;
    }

    this.trigger("bitrateEstimationChange", {
      type: type,
      bitrate: bitrate
    });
  }
  /**
   * Triggered each time the videoElement alternates between play and pause.
   *
   * Emit the info through the right Subject.
   *
   * @param {Boolean} isPlaying
   */
  ;

  _proto._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    this._priv_playing$.next(isPlaying);
  }
  /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   */
  ;

  _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
    this.trigger("nativeTextTracksChange", tracks);
  }
  /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   */
  ;

  _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
    if (this.state !== newState) {
      this.state = newState;
      log["a" /* default */].info("API: playerStateChange event", newState);
      this.trigger("playerStateChange", newState);
    }
  }
  /**
   * Triggered each time a new clock tick object is emitted.
   *
   * Trigger the right Player Event
   *
   * @param {Object} clockTick
   */
  ;

  _proto._priv_triggerPositionUpdate = function _priv_triggerPositionUpdate(clockTick) {
    var _a;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].warn("API: Cannot perform time update: no content loaded.");
      return;
    }

    if (this.state === PLAYER_STATES.RELOADING) {
      return;
    }

    var _this$_priv_contentIn24 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn24.isDirectFile,
        manifest = _this$_priv_contentIn24.manifest;

    if (!isDirectFile && manifest === null || Object(is_null_or_undefined["a" /* default */])(clockTick)) {
      return;
    }

    var maximumPosition = manifest !== null ? manifest.getMaximumPosition() : undefined;
    var positionData = {
      position: clockTick.currentTime,
      duration: clockTick.duration,
      playbackRate: clockTick.playbackRate,
      maximumBufferTime: maximumPosition,
      // TODO fix higher up?
      bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
    };

    if (manifest !== null && maximumPosition !== undefined && manifest.isLive && clockTick.currentTime > 0) {
      var ast = (_a = manifest.availabilityStartTime) !== null && _a !== void 0 ? _a : 0;
      positionData.wallClockTime = clockTick.currentTime + ast;
      positionData.liveGap = maximumPosition - clockTick.currentTime;
    }

    this.trigger("positionUpdate", positionData);
  }
  /**
   * Trigger one of the "availableBitratesChange" event only if it changed from
   * the previously stored value.
   * @param {string} event
   * @param {Array.<number>} newVal
   */
  ;

  _proto._priv_triggerAvailableBitratesChangeEvent = function _priv_triggerAvailableBitratesChangeEvent(event, newVal) {
    var prevVal = this._priv_contentEventsMemory[event];

    if (prevVal === undefined || Object(are_arrays_of_numbers_equal["a" /* default */])(newVal, prevVal)) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  }
  /**
   * Trigger one of the "bitrateChange" event only if it changed from the
   * previously stored value.
   * @param {string} event
   * @param {number} newVal
   */
  ;

  _proto._priv_triggerCurrentBitrateChangeEvent = function _priv_triggerCurrentBitrateChangeEvent(event, newVal) {
    if (newVal !== this._priv_contentEventsMemory[event]) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  };

  _proto._priv_getCurrentRepresentations = function _priv_getCurrentRepresentations() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn25 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn25.currentPeriod,
        activeRepresentations = _this$_priv_contentIn25.activeRepresentations;

    if (currentPeriod === null || activeRepresentations === null || Object(is_null_or_undefined["a" /* default */])(activeRepresentations[currentPeriod.id])) {
      return null;
    }

    return activeRepresentations[currentPeriod.id];
  };

  createClass_default()(Player, null, [{
    key: "ErrorTypes",
    get: function get() {
      return error_codes["b" /* ErrorTypes */];
    }
    /** All possible Error codes emitted by the RxPlayer. */

  }, {
    key: "ErrorCodes",
    get: function get() {
      return error_codes["a" /* ErrorCodes */];
    }
    /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */

  }, {
    key: "LogLevel",
    get: function get() {
      return log["a" /* default */].getLevel();
    },
    set: function set(logLevel) {
      log["a" /* default */].setLevel(logLevel);
    }
  }]);

  return Player;
}(event_emitter["a" /* default */]);

public_api_Player.version =
/*PLAYER_VERSION*/
"3.21.1";
/* harmony default export */ var public_api = (public_api_Player);
// CONCATENATED MODULE: ./src/core/api/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var api = (public_api);
// CONCATENATED MODULE: ./src/features/initialize_features.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */

function initializeFeaturesObject() {
  /* tslint:disable no-unsafe-any */

  /* tslint:disable no-var-requires */
  if (true) {
    features["a" /* default */].emeManager = __webpack_require__(147)["default"];
  }
  /* tslint:enable no-var-requires */

  /* tslint:disable no-var-requires */


  if (true) {
    features["a" /* default */].imageBuffer = __webpack_require__(224)["default"];
    features["a" /* default */].imageParser = __webpack_require__(206)["default"];
  }
  /* tslint:enable no-var-requires */
  // Feature switching the Native TextTrack implementation


  var HAS_NATIVE_MODE =  true || false;
  /* tslint:disable no-var-requires */

  if (true) {
    features["a" /* default */].transports.smooth = __webpack_require__(217)["default"];
  }

  if (true) {
    features["a" /* default */].transports.dash = __webpack_require__(216)["default"];
  }

  if (false) {}

  if (true) {
    features["a" /* default */].transports.metaplaylist = __webpack_require__(220)["default"];
  }
  /* tslint:enable no-var-requires */

  /* tslint:disable no-var-requires */


  if (HAS_NATIVE_MODE) {
    features["a" /* default */].nativeTextTracksBuffer = __webpack_require__(222)["default"];

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.vtt = __webpack_require__(223)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.ttml = __webpack_require__(225)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.sami = __webpack_require__(209)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.srt = __webpack_require__(210)["default"];
    }
  }
  /* tslint:enable no-var-requires */
  // Feature switching the HTML TextTrack implementation


  var HAS_HTML_MODE =  true || false;
  /* tslint:disable no-var-requires */

  if (HAS_HTML_MODE) {
    features["a" /* default */].htmlTextTracksBuffer = __webpack_require__(221)["default"];

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.sami = __webpack_require__(211)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.ttml = __webpack_require__(218)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.srt = __webpack_require__(212)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.vtt = __webpack_require__(219)["default"];
    }
    /* tslint:enable no-var-requires */

  }
  /* tslint:disable no-var-requires */


  if (true) {
    var initDirectFile = __webpack_require__(213)["default"];

    var mediaElementTrackChoiceManager = __webpack_require__(214)["default"];

    features["a" /* default */].directfile = {
      initDirectFile: initDirectFile,
      mediaElementTrackChoiceManager: mediaElementTrackChoiceManager
    };
  }
  /* tslint:enable no-var-requires */

  /* tslint:enable no-unsafe-any */

}
// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */


 // set initial features according to environment variables

initializeFeaturesObject();

if (false) {}

/* harmony default export */ var src = __webpack_exports__["default"] = (api);

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/transports/utils/text_manifest_loader.ts
var text_manifest_loader = __webpack_require__(124);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(28);

// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(19);

// CONCATENATED MODULE: ./src/transports/dash/image_pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Object} args
 * @returns {Observable}
 */

function imageLoader(_ref) {
  var segment = _ref.segment,
      url = _ref.url;

  if (segment.isInit || url === null) {
    return Object(of["a" /* of */])({
      type: "data-created",
      value: {
        responseData: null
      }
    });
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    sendProgressEvents: true
  });
}
/**
 * @param {Object} args
 * @returns {Observable}
 */

function imageParser(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var segment = content.segment,
      period = content.period;
  var data = response.data,
      isChunked = response.isChunked;

  if (content.segment.isInit) {
    // image init segment has no use
    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: undefined
      }
    });
  }

  if (isChunked) {
    throw new Error("Image data should not be downloaded in chunks");
  }

  var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0); // TODO image Parsing should be more on the sourceBuffer side, no?

  if (data === null || features["a" /* default */].imageParser === null) {
    return Object(of["a" /* of */])({
      type: "parsed-segment",
      value: {
        chunkData: null,
        chunkInfos: segment.timescale > 0 ? {
          duration: segment.isInit ? 0 : segment.duration,
          time: segment.isInit ? -1 : segment.time,
          timescale: segment.timescale
        } : null,
        chunkOffset: chunkOffset,
        appendWindow: [period.start, period.end]
      }
    });
  }

  var bifObject = features["a" /* default */].imageParser(new Uint8Array(data));
  var thumbsData = bifObject.thumbs;
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: {
        data: thumbsData,
        start: 0,
        end: Number.MAX_VALUE,
        timescale: 1,
        type: "bif"
      },
      chunkInfos: {
        time: 0,
        duration: Number.MAX_VALUE,
        timescale: bifObject.timescale
      },
      chunkOffset: chunkOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(159);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(51);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(67);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(69);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/extract_minimum_availability_time_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From 0 to N baseURL elements takes the minimum availabilityTimeOffset
 * possible.
 *
 * `0` if no baseURL was given (which means `no delay added`: coherent with how
 * this value is used).
 *
 * Taking the minimum time allow to simplify its processing:
 * Instead of having multiple URL each with a different pool of available
 * segment at a given instant, let's always consider every URLs by aligning with
 * the one with the most segment.
 *
 * @param {Array.<Object>} baseURLs
 */
function extractMinimumAvailabilityTimeOffset(baseURLs) {
  return baseURLs.length === 0 ? 0 : baseURLs.reduce(function (acc, baseURL) {
    var _a;

    return Math.min((_a = baseURL.attributes.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0, acc);
  }, Infinity);
}
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_clock_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */

function getClockOffset(serverClock) {
  var httpOffset = Date.parse(serverClock) - performance.now();

  if (isNaN(httpOffset)) {
    log["a" /* default */].warn("DASH Parser: Invalid clock received: ", serverClock);
    return undefined;
  }

  return httpOffset;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_http_utc-timing_url.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */
function getHTTPUTCTimingURL(mpdIR) {
  var UTCTimingHTTP = mpdIR.children.utcTimings.filter(function (utcTiming) {
    return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" && utcTiming.value !== undefined;
  });
  return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : undefined;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_last_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns "last time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getLastPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;

  for (var i = 0; i < representations.length; i++) {
    var lastPosition = representations[i].index.getLastPosition();

    if (lastPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (lastPosition !== null) {
      min = min == null ? lastPosition : Math.min(min, lastPosition);
    }
  }

  if (min === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return min;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_maximum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */

function getMaximumPosition(manifest) {
  for (var i = manifest.periods.length - 1; i >= 0; i--) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var maximumAudioPosition = null;
      var maximumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod !== undefined) {
        var lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);

        if (lastPosition === undefined) {
          return undefined;
        }

        maximumAudioPosition = lastPosition;
      }

      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);

        if (_lastPosition === undefined) {
          return undefined;
        }

        maximumVideoPosition = _lastPosition;
      }

      if (firstAudioAdaptationFromPeriod !== undefined && maximumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && maximumVideoPosition === null) {
        log["a" /* default */].info("Parser utils: found Period with no segment. ", "Going to previous one to calculate last position");
        return undefined;
      }

      if (maximumVideoPosition !== null) {
        if (maximumAudioPosition !== null) {
          return Math.min(maximumAudioPosition, maximumVideoPosition);
        }

        return maximumVideoPosition;
      }

      if (maximumAudioPosition !== null) {
        return maximumAudioPosition;
      }
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_first_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns "first time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
function getFirstPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var max = null;

  for (var i = 0; i < representations.length; i++) {
    var firstPosition = representations[i].index.getFirstPosition();

    if (firstPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (firstPosition !== null) {
      max = max == null ? firstPosition : Math.max(max, firstPosition);
    }
  }

  if (max === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return max;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_minimum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */

function getMinimumPosition(manifest) {
  for (var i = 0; i <= manifest.periods.length - 1; i++) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var minimumAudioPosition = null;
      var minimumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod !== undefined) {
        var firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);

        if (firstPosition === undefined) {
          return undefined;
        }

        minimumAudioPosition = firstPosition;
      }

      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);

        if (_firstPosition === undefined) {
          return undefined;
        }

        minimumVideoPosition = _firstPosition;
      }

      if (firstAudioAdaptationFromPeriod !== undefined && minimumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && minimumVideoPosition === null) {
        log["a" /* default */].info("Parser utils: found Period with no segment. ", "Going to next one to calculate first position");
        return undefined;
      }

      if (minimumVideoPosition !== null) {
        if (minimumAudioPosition !== null) {
          return Math.max(minimumAudioPosition, minimumVideoPosition);
        }

        return minimumVideoPosition;
      }

      if (minimumAudioPosition !== null) {
        return minimumAudioPosition;
      }
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_minimum_and_maximum_positions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {Array.<number>}
 */

function getMinimumAndMaximumPosition(manifest) {
  if (manifest.periods.length === 0) {
    throw new Error("DASH Parser: no period available for a dynamic content");
  }

  return [getMinimumPosition(manifest), getMaximumPosition(manifest)];
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(37);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var wrapNativeSuper = __webpack_require__(38);
var wrapNativeSuper_default = /*#__PURE__*/__webpack_require__.n(wrapNativeSuper);

// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/utils.ts




/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// XML-Schema

/* tslint:disable:max-line-length */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>

/* tslint:enable:max-line-length */



var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
/**
 * Parse MPD boolean attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | Error | null>}
 */

function parseBoolean(val, displayName) {
  if (val === "true") {
    return [true, null];
  }

  if (val === "false") {
    return [false, null];
  }

  var error = new utils_MPDError("`" + displayName + "` property is not a boolean value but \"" + val + "\"");
  return [false, error];
}
/**
 * Parse MPD integer attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */


function parseMPDInteger(val, displayName) {
  var toInt = parseInt(val, 10);

  if (isNaN(toInt)) {
    var error = new utils_MPDError("`" + displayName + "` property is not an integer value but \"" + val + "\"");
    return [null, error];
  }

  return [toInt, null];
}
/**
 * Parse MPD float attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */


function parseMPDFloat(val, displayName) {
  var toInt = parseFloat(val);

  if (isNaN(toInt)) {
    var error = new utils_MPDError("`" + displayName + "` property is not an integer value but \"" + val + "\"");
    return [null, error];
  }

  return [toInt, null];
}
/**
 * Parse MPD attributes which are either integer or boolean values.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | number | Error | null>}
 */


function parseIntOrBoolean(val, displayName) {
  if (val === "true") {
    return [true, null];
  }

  if (val === "false") {
    return [false, null];
  }

  var toInt = parseInt(val, 10);

  if (isNaN(toInt)) {
    var error = new utils_MPDError("`" + displayName + "` property is not a boolean nor an integer but \"" + val + "\"");
    return [null, error];
  }

  return [toInt, null];
}
/**
 * Parse MPD date attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Date | null | Error>}
 */


function parseDateTime(val, displayName) {
  var parsed = Date.parse(val);

  if (isNaN(parsed)) {
    var error = new utils_MPDError("`" + displayName + "` is in an invalid date format: \"" + val + "\"");
    return [null, error];
  }

  return [new Date(Date.parse(val)).getTime() / 1000, null];
}
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */


function parseDuration(val, displayName) {
  if (!Object(is_non_empty_string["a" /* default */])(val)) {
    var error = new utils_MPDError("`" + displayName + "` property is empty");
    return [0, error];
  }

  var match = iso8601Duration.exec(val);

  if (match === null) {
    var _error = new utils_MPDError("`" + displayName + "` property has an unrecognized format \"" + val + "\"");

    return [null, _error];
  }

  var duration = parseFloat(Object(is_non_empty_string["a" /* default */])(match[2]) ? match[2] : "0") * 365 * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[4]) ? match[4] : "0") * 30 * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[6]) ? match[6] : "0") * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[8]) ? match[8] : "0") * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[10]) ? match[10] : "0") * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[12]) ? match[12] : "0");
  return [duration, null];
}
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Array.<Array.<number> | Error | null>}
 */


function parseByteRange(val, displayName) {
  var match = rangeRe.exec(val);

  if (match === null) {
    var error = new utils_MPDError("`" + displayName + "` property has an unrecognized format \"" + val + "\"");
    return [null, error];
  } else {
    return [[+match[1], +match[2]], null];
  }
}
/**
 * Parse MPD base64 attribute into an Uint8Array.
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Uint8Array | Error | null>}
 */


function parseBase64(val, displayName) {
  try {
    return [Object(base64["a" /* base64ToBytes */])(val), null];
  } catch (_) {
    var error = new utils_MPDError("`" + displayName + "` is not a valid base64 string: \"" + val + "\"");
    return [null, error];
  }
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseScheme(root) {
  var schemeIdUri;
  var value;

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;

      case "value":
        value = attribute.value;
        break;
    }
  }

  return {
    schemeIdUri: schemeIdUri,
    value: value
  };
}
/**
 * Create a function to factorize the MPD parsing logic.
 * @param {Object} dest - The destination object which will contain the parsed
 * values.
 * @param {Array.<Error>} warnings - An array which will contain every parsing
 * error encountered.
 * @return {Function}
 */


function ValueParser(dest, warnings) {
  /**
   * Parse a single value and add it to the `dest` objects.
   * If an error arised while parsing, add it at the end of the `warnings` array.
   * @param {string} objKey - The key which will be added to the `dest` object.
   * @param {string} val - The value found in the MPD which we should parse.
   * @param {Function} parsingFn - The parsing function adapted for this value.
   * @param {string} displayName - The name of the key as it appears in the MPD.
   * This is used only in error formatting,
   */
  return function (val, _ref) {
    var asKey = _ref.asKey,
        parser = _ref.parser,
        dashName = _ref.dashName;

    var _parser = parser(val, dashName),
        parsingResult = _parser[0],
        parsingError = _parser[1];

    if (parsingError !== null) {
      log["a" /* default */].warn(parsingError.message);
      warnings.push(parsingError);
    }

    if (parsingResult !== null) {
      dest[asKey] = parsingResult;
    }
  };
}
/**
 * Error arising when parsing the MPD.
 * @class MPDError
 * @extends Error
 */


var utils_MPDError = /*#__PURE__*/function (_Error) {
  inheritsLoose_default()(MPDError, _Error);

  /**
   * @param {string} message
   */
  function MPDError(message) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(assertThisInitialized_default()(_this), MPDError.prototype);
    _this.name = "MPDError";
    _this.message = message;
    return _this;
  }

  return MPDError;
}( /*#__PURE__*/wrapNativeSuper_default()(Error));


// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/BaseURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse an BaseURL element into an BaseURL intermediate
 * representation.
 * @param {Element} adaptationSetElement - The BaseURL root element.
 * @returns {Array.<Object|undefined>}
 */

function parseBaseURL(root) {
  var attributes = {};
  var value = root.textContent;
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);

  if (value === null || value.length === 0) {
    return [undefined, warnings];
  }

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "availabilityTimeOffset":
        if (attribute.value === "INF") {
          attributes.availabilityTimeOffset = Infinity;
        } else {
          parseValue(attribute.value, {
            asKey: "availabilityTimeOffset",
            parser: parseMPDInteger,
            dashName: "availabilityTimeOffset"
          });
        }

        break;
    }
  }

  return [{
    value: value,
    attributes: attributes
  }, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseContentComponent(root) {
  var ret = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        ret.id = attribute.value;
        break;

      case "lang":
        ret.language = attribute.value;
        break;

      case "contentType":
        ret.contentType = attribute.value;
        break;

      case "par":
        ret.par = attribute.value;
        break;
    }
  }

  return ret;
}
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(11);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {NodeList} contentProtectionChildren
 * @Returns {Object}
 */

function parseContentProtectionChildren(contentProtectionChildren) {
  var warnings = [];
  var cencPssh = [];

  for (var i = 0; i < contentProtectionChildren.length; i++) {
    if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = contentProtectionChildren[i];

      if (currentElement.nodeName === "cenc:pssh") {
        var content = currentElement.textContent;

        if (content !== null && content.length > 0) {
          var _parseBase = parseBase64(content, "cenc:pssh"),
              toUint8Array = _parseBase[0],
              error = _parseBase[1];

          if (error !== null) {
            log["a" /* default */].warn(error.message);
            warnings.push(error);
          }

          if (toUint8Array !== null) {
            cencPssh.push(toUint8Array);
          }
        }
      }
    }
  }

  return [{
    cencPssh: cencPssh
  }, warnings];
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseContentProtectionAttributes(root) {
  var ret = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        ret.schemeIdUri = attribute.value;
        break;

      case "value":
        ret.value = attribute.value;
        break;

      case "cenc:default_KID":
        ret.keyId = Object(string_parsing["c" /* hexToBytes */])(attribute.value.replace(/-/g, ""));
    }
  }

  return ret;
}
/**
 * @param {Element} contentProtectionElement
 * @returns {Object}
 */


function parseContentProtection(contentProtectionElement) {
  var _parseContentProtecti = parseContentProtectionChildren(contentProtectionElement.childNodes),
      children = _parseContentProtecti[0],
      childrenWarnings = _parseContentProtecti[1];

  var attributes = parseContentProtectionAttributes(contentProtectionElement);
  return [{
    children: children,
    attributes: attributes
  }, childrenWarnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */

function parseInitialization(root) {
  var parsedInitialization = {};
  var warnings = [];
  var parseValue = ValueParser(parsedInitialization, warnings);

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "range":
        parseValue(attribute.value, {
          asKey: "range",
          parser: parseByteRange,
          dashName: "range"
        });
        break;

      case "sourceURL":
        parsedInitialization.media = attribute.value;
        break;
    }
  }

  return [parsedInitialization, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse a SegmentBase element into a SegmentBase intermediate representation.
 * @param {Element} root - The SegmentBase root element.
 * @returns {Array}
 */

function parseSegmentBase(root) {
  var attributes = {};
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);
  var segmentBaseChildren = root.childNodes;

  for (var i = 0; i < segmentBaseChildren.length; i++) {
    if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentBaseChildren[i];

      if (currentNode.nodeName === "Initialization") {
        var _parseInitialization = parseInitialization(currentNode),
            initialization = _parseInitialization[0],
            initializationWarnings = _parseInitialization[1];

        attributes.initialization = initialization;
        warnings = warnings.concat(initializationWarnings);
      }
    }
  }

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attr = root.attributes[_i];

    switch (attr.name) {
      case "timescale":
        parseValue(attr.value, {
          asKey: "timescale",
          parser: parseMPDInteger,
          dashName: "timescale"
        });
        break;

      case "presentationTimeOffset":
        parseValue(attr.value, {
          asKey: "presentationTimeOffset",
          parser: parseMPDFloat,
          dashName: "presentationTimeOffset"
        });
        break;

      case "indexRange":
        parseValue(attr.value, {
          asKey: "indexRange",
          parser: parseByteRange,
          dashName: "indexRange"
        });
        break;

      case "indexRangeExact":
        parseValue(attr.value, {
          asKey: "indexRangeExact",
          parser: parseBoolean,
          dashName: "indexRangeExact"
        });
        break;

      case "availabilityTimeOffset":
        parseValue(attr.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDFloat,
          dashName: "availabilityTimeOffset"
        });
        break;

      case "availabilityTimeComplete":
        parseValue(attr.value, {
          asKey: "availabilityTimeComplete",
          parser: parseBoolean,
          dashName: "availabilityTimeComplete"
        });
        break;

      case "duration":
        parseValue(attr.value, {
          asKey: "duration",
          parser: parseMPDInteger,
          dashName: "duration"
        });
        break;

      case "startNumber":
        parseValue(attr.value, {
          asKey: "startNumber",
          parser: parseMPDInteger,
          dashName: "startNumber"
        });
        break;
    }
  }

  return [attributes, warnings];
}
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a SegmentURL element into a SegmentURL intermediate
 * representation.
 * @param {Element} root - The SegmentURL root element.
 * @returns {Array}
 */

function parseSegmentURL(root) {
  var parsedSegmentURL = {};
  var warnings = [];
  var parseValue = ValueParser(parsedSegmentURL, warnings);

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "media":
        parsedSegmentURL.media = attribute.value;
        break;

      case "indexRange":
        parseValue(attribute.value, {
          asKey: "indexRange",
          parser: parseByteRange,
          dashName: "indexRange"
        });
        break;

      case "index":
        parsedSegmentURL.index = attribute.value;
        break;

      case "mediaRange":
        parseValue(attribute.value, {
          asKey: "mediaRange",
          parser: parseByteRange,
          dashName: "mediaRange"
        });
        break;
    }
  }

  return [parsedSegmentURL, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Element} root
 * @returns {Array}
 */

function parseSegmentList(root) {
  var _parseSegmentBase = parseSegmentBase(root),
      base = _parseSegmentBase[0],
      baseWarnings = _parseSegmentBase[1];

  var warnings = baseWarnings;
  var list = [];
  var segmentListChildren = root.childNodes;

  for (var i = 0; i < segmentListChildren.length; i++) {
    if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentListChildren[i];

      if (currentNode.nodeName === "SegmentURL") {
        var _parseSegmentURL = parseSegmentURL(currentNode),
            segmentURL = _parseSegmentURL[0],
            segmentURLWarnings = _parseSegmentURL[1];

        list.push(segmentURL);
        warnings = warnings.concat(segmentURLWarnings);
      }
    }
  }

  var baseDuration = base.duration;

  if (baseDuration == null) {
    throw new Error("Invalid SegmentList: no duration");
  }

  var ret = Object(object_assign["a" /* default */])(base, {
    list: list,
    // Ugly but TS is too dumb there
    duration: baseDuration
  });
  return [ret, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} root
 * @returns {Function}
 */
function createSegmentTimelineParser(root) {
  var result = null;
  return function () {
    if (result === null) {
      var elements = root.getElementsByTagName("S");
      result = elements;
      return elements;
    }

    return result;
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Parse initialization attribute found in SegmentTemplateTemplate to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */

function parseInitializationAttribute(attrValue) {
  return {
    media: attrValue
  };
}
/**
 * Parse a SegmentTemplate element into a SegmentTemplate intermediate
 * representation.
 * @param {Element} root - The SegmentTemplate root element.
 * @returns {Array}
 */


function parseSegmentTemplate(root) {
  var _parseSegmentBase = parseSegmentBase(root),
      base = _parseSegmentBase[0],
      segmentBaseWarnings = _parseSegmentBase[1];

  var warnings = segmentBaseWarnings;
  var ret;
  var timelineParser; // First look for a possible SegmentTimeline

  for (var i = 0; i < root.childNodes.length; i++) {
    if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = root.childNodes[i];

      if (currentNode.nodeName === "SegmentTimeline") {
        timelineParser = createSegmentTimelineParser(currentNode);
      }
    }
  }

  ret = Object(object_assign["a" /* default */])({}, base, {
    duration: base.duration,
    timelineParser: timelineParser
  });
  var parseValue = ValueParser(ret, warnings);

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];

    switch (attribute.nodeName) {
      case "initialization":
        if (ret.initialization == null) {
          ret.initialization = parseInitializationAttribute(attribute.value);
        }

        break;

      case "index":
        ret.index = attribute.value;
        break;

      case "availabilityTimeOffset":
        if (attribute.value === "INF") {
          ret.availabilityTimeOffset = Infinity;
        }

        parseValue(attribute.value, {
          asKey: "availabilityTimeOffset",
          parser: parseMPDInteger,
          dashName: "availabilityTimeOffset"
        });
        break;

      case "media":
        ret.media = attribute.value;
        break;

      case "bitstreamSwitching":
        parseValue(attribute.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;
    }
  }

  return [ret, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */

function parseRepresentationChildren(representationChildren) {
  var children = {
    baseURLs: []
  };
  var warnings = [];

  for (var i = 0; i < representationChildren.length; i++) {
    if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = representationChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
              baseURLObj = _parseBaseURL[0],
              baseURLWarnings = _parseBaseURL[1];

          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }

          warnings = warnings.concat(baseURLWarnings);
          break;

        case "SegmentBase":
          var _parseSegmentBase = parseSegmentBase(currentElement),
              segmentBase = _parseSegmentBase[0],
              segmentBaseWarnings = _parseSegmentBase[1];

          children.segmentBase = segmentBase;

          if (segmentBaseWarnings.length > 0) {
            warnings = warnings.concat(segmentBaseWarnings);
          }

          break;

        case "SegmentList":
          var _parseSegmentList = parseSegmentList(currentElement),
              segmentList = _parseSegmentList[0],
              segmentListWarnings = _parseSegmentList[1];

          warnings = warnings.concat(segmentListWarnings);
          children.segmentList = segmentList;
          break;

        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
              segmentTemplate = _parseSegmentTemplate[0],
              segmentTemplateWarnings = _parseSegmentTemplate[1];

          warnings = warnings.concat(segmentTemplateWarnings);
          children.segmentTemplate = segmentTemplate;
          break;
      }
    }
  }

  return [children, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */


function parseRepresentationAttributes(representationElement) {
  var attributes = {};
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);

  for (var i = 0; i < representationElement.attributes.length; i++) {
    var attr = representationElement.attributes[i];

    switch (attr.name) {
      case "audioSamplingRate":
        attributes.audioSamplingRate = attr.value;
        break;

      case "bandwidth":
        parseValue(attr.value, {
          asKey: "bitrate",
          parser: parseMPDInteger,
          dashName: "bandwidth"
        });
        break;

      case "codecs":
        attributes.codecs = attr.value;
        break;

      case "codingDependency":
        parseValue(attr.value, {
          asKey: "codingDependency",
          parser: parseBoolean,
          dashName: "codingDependency"
        });
        break;

      case "frameRate":
        attributes.frameRate = attr.value;
        break;

      case "height":
        parseValue(attr.value, {
          asKey: "height",
          parser: parseMPDInteger,
          dashName: "height"
        });
        break;

      case "id":
        attributes.id = attr.value;
        break;

      case "maxPlayoutRate":
        parseValue(attr.value, {
          asKey: "maxPlayoutRate",
          parser: parseMPDFloat,
          dashName: "maxPlayoutRate"
        });
        break;

      case "maximumSAPPeriod":
        parseValue(attr.value, {
          asKey: "maximumSAPPeriod",
          parser: parseMPDFloat,
          dashName: "maximumSAPPeriod"
        });
        break;

      case "mimeType":
        attributes.mimeType = attr.value;
        break;

      case "profiles":
        attributes.profiles = attr.value;
        break;

      case "qualityRanking":
        parseValue(attr.value, {
          asKey: "qualityRanking",
          parser: parseMPDInteger,
          dashName: "qualityRanking"
        });
        break;

      case "segmentProfiles":
        attributes.segmentProfiles = attr.value;
        break;

      case "width":
        parseValue(attr.value, {
          asKey: "width",
          parser: parseMPDInteger,
          dashName: "width"
        });
        break;
    }
  }

  if (attributes.bitrate === undefined) {
    warnings.push(new utils_MPDError("No bitrate found on a Representation"));
  }

  return [attributes, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */


function createRepresentationIntermediateRepresentation(representationElement) {
  var _parseRepresentationC = parseRepresentationChildren(representationElement.childNodes),
      children = _parseRepresentationC[0],
      childrenWarnings = _parseRepresentationC[1];

  var _parseRepresentationA = parseRepresentationAttributes(representationElement),
      attributes = _parseRepresentationA[0],
      attrsWarnings = _parseRepresentationA[1];

  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse child nodes from an AdaptationSet.
 * @param {NodeList} adaptationSetChildren - The AdaptationSet child nodes.
 * @returns {Array.<Object>}
 */

function parseAdaptationSetChildren(adaptationSetChildren) {
  var children = {
    baseURLs: [],
    representations: []
  };
  var contentProtections = [];
  var warnings = [];

  for (var i = 0; i < adaptationSetChildren.length; i++) {
    if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = adaptationSetChildren[i];

      switch (currentElement.nodeName) {
        case "Accessibility":
          children.accessibility = parseScheme(currentElement);
          break;

        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
              baseURLObj = _parseBaseURL[0],
              baseURLWarnings = _parseBaseURL[1];

          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }

          if (baseURLWarnings.length > 0) {
            warnings = warnings.concat(baseURLWarnings);
          }

          break;

        case "ContentComponent":
          children.contentComponent = parseContentComponent(currentElement);
          break;

        case "EssentialProperty":
          if (children.essentialProperties == null) {
            children.essentialProperties = [parseScheme(currentElement)];
          } else {
            children.essentialProperties.push(parseScheme(currentElement));
          }

          break;

        case "Representation":
          var _createRepresentation = createRepresentationIntermediateRepresentation(currentElement),
              representation = _createRepresentation[0],
              representationWarnings = _createRepresentation[1];

          children.representations.push(representation);

          if (representationWarnings.length > 0) {
            warnings = warnings.concat(representationWarnings);
          }

          break;

        case "Role":
          if (children.roles == null) {
            children.roles = [parseScheme(currentElement)];
          } else {
            children.roles.push(parseScheme(currentElement));
          }

          break;

        case "SupplementalProperty":
          if (children.supplementalProperties == null) {
            children.supplementalProperties = [parseScheme(currentElement)];
          } else {
            children.supplementalProperties.push(parseScheme(currentElement));
          }

          break;

        case "SegmentBase":
          var _parseSegmentBase = parseSegmentBase(currentElement),
              segmentBase = _parseSegmentBase[0],
              segmentBaseWarnings = _parseSegmentBase[1];

          children.segmentBase = segmentBase;

          if (segmentBaseWarnings.length > 0) {
            warnings = warnings.concat(segmentBaseWarnings);
          }

          break;

        case "SegmentList":
          var _parseSegmentList = parseSegmentList(currentElement),
              segmentList = _parseSegmentList[0],
              segmentListWarnings = _parseSegmentList[1];

          children.segmentList = segmentList;

          if (segmentListWarnings.length > 0) {
            warnings = warnings.concat(segmentListWarnings);
          }

          break;

        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
              segmentTemplate = _parseSegmentTemplate[0],
              segmentTemplateWarnings = _parseSegmentTemplate[1];

          children.segmentTemplate = segmentTemplate;

          if (segmentTemplateWarnings.length > 0) {
            warnings = warnings.concat(segmentTemplateWarnings);
          }

          break;

        case "ContentProtection":
          var _parseContentProtecti = parseContentProtection(currentElement),
              contentProtection = _parseContentProtecti[0],
              contentProtectionWarnings = _parseContentProtecti[1];

          if (contentProtectionWarnings.length > 0) {
            warnings = warnings.concat(contentProtectionWarnings);
          }

          if (contentProtection !== undefined) {
            contentProtections.push(contentProtection);
          }

          break;
        // case "Rating":
        //   children.rating = currentElement;
        //   break;
        // case "Viewpoint":
        //   children.viewpoint = currentElement;
        //   break;
      }
    }
  }

  if (contentProtections.length > 0) {
    children.contentProtections = contentProtections;
  }

  return [children, warnings];
}
/**
 * Parse every attributes from an AdaptationSet root element into a simple JS
 * object.
 * @param {Element} root - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */


function parseAdaptationSetAttributes(root) {
  var parsedAdaptation = {};
  var warnings = [];
  var parseValue = ValueParser(parsedAdaptation, warnings);

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        parsedAdaptation.id = attribute.value;
        break;

      case "group":
        parseValue(attribute.value, {
          asKey: "group",
          parser: parseMPDInteger,
          dashName: "group"
        });
        break;

      case "lang":
        parsedAdaptation.language = attribute.value;
        break;

      case "contentType":
        parsedAdaptation.contentType = attribute.value;
        break;

      case "par":
        parsedAdaptation.par = attribute.value;
        break;

      case "minBandwidth":
        parseValue(attribute.value, {
          asKey: "minBitrate",
          parser: parseMPDInteger,
          dashName: "minBandwidth"
        });
        break;

      case "maxBandwidth":
        parseValue(attribute.value, {
          asKey: "maxBitrate",
          parser: parseMPDInteger,
          dashName: "maxBandwidth"
        });
        break;

      case "minWidth":
        parseValue(attribute.value, {
          asKey: "minWidth",
          parser: parseMPDInteger,
          dashName: "minWidth"
        });
        break;

      case "maxWidth":
        parseValue(attribute.value, {
          asKey: "maxWidth",
          parser: parseMPDInteger,
          dashName: "maxWidth"
        });
        break;

      case "minHeight":
        parseValue(attribute.value, {
          asKey: "minHeight",
          parser: parseMPDInteger,
          dashName: "minHeight"
        });
        break;

      case "maxHeight":
        parseValue(attribute.value, {
          asKey: "maxHeight",
          parser: parseMPDInteger,
          dashName: "maxHeight"
        });
        break;

      case "minFrameRate":
        {
          parsedAdaptation.minFrameRate = attribute.value;
        }
        break;

      case "maxFrameRate":
        parsedAdaptation.maxFrameRate = attribute.value;
        break;

      case "selectionPriority":
        parseValue(attribute.value, {
          asKey: "selectionPriority",
          parser: parseMPDInteger,
          dashName: "selectionPriority"
        });
        break;

      case "segmentAlignment":
        parseValue(attribute.value, {
          asKey: "segmentAlignment",
          parser: parseIntOrBoolean,
          dashName: "segmentAlignment"
        });
        break;

      case "subsegmentAlignment":
        parseValue(attribute.value, {
          asKey: "subsegmentAlignment",
          parser: parseIntOrBoolean,
          dashName: "subsegmentAlignment"
        });
        break;

      case "bitstreamSwitching":
        parseValue(attribute.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;

      case "audioSamplingRate":
        parsedAdaptation.audioSamplingRate = attribute.value;
        break;

      case "codecs":
        parsedAdaptation.codecs = attribute.value;
        break;

      case "codingDependency":
        parseValue(attribute.value, {
          asKey: "codingDependency",
          parser: parseBoolean,
          dashName: "codingDependency"
        });
        break;

      case "frameRate":
        parsedAdaptation.frameRate = attribute.value;
        break;

      case "height":
        parseValue(attribute.value, {
          asKey: "height",
          parser: parseMPDInteger,
          dashName: "height"
        });
        break;

      case "maxPlayoutRate":
        parseValue(attribute.value, {
          asKey: "maxPlayoutRate",
          parser: parseMPDFloat,
          dashName: "maxPlayoutRate"
        });
        break;

      case "maximumSAPPeriod":
        parseValue(attribute.value, {
          asKey: "maximumSAPPeriod",
          parser: parseMPDFloat,
          dashName: "maximumSAPPeriod"
        });
        break;

      case "mimeType":
        parsedAdaptation.mimeType = attribute.value;
        break;

      case "profiles":
        parsedAdaptation.profiles = attribute.value;
        break;

      case "segmentProfiles":
        parsedAdaptation.segmentProfiles = attribute.value;
        break;

      case "width":
        parseValue(attribute.value, {
          asKey: "width",
          parser: parseMPDInteger,
          dashName: "width"
        });
        break;
    }
  }

  return [parsedAdaptation, warnings];
}
/**
 * Parse an AdaptationSet element into an AdaptationSet intermediate
 * representation.
 * @param {Element} adaptationSetElement - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */


function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
  var childNodes = adaptationSetElement.childNodes;

  var _parseAdaptationSetCh = parseAdaptationSetChildren(childNodes),
      children = _parseAdaptationSetCh[0],
      childrenWarnings = _parseAdaptationSetCh[1];

  var _parseAdaptationSetAt = parseAdaptationSetAttributes(adaptationSetElement),
      attributes = _parseAdaptationSetAt[0],
      attrsWarnings = _parseAdaptationSetAt[1];

  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/EventStream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the EventStream node to extract Event nodes and their
 * content.
 * @param {Element} element
 */

function parseEventStream(element) {
  var _a;

  var streamEvents = [];
  var attributes = {
    timescale: 1
  };
  var warnings = [];
  var parseValue = ValueParser(attributes, warnings);

  for (var i = 0; i < element.attributes.length; i++) {
    var attribute = element.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        attributes.schemeId = attribute.value;
        break;

      case "timescale":
        parseValue(attribute.value, {
          asKey: "timescale",
          parser: parseMPDInteger,
          dashName: "timescale"
        });
        break;

      case "value":
        attributes.value = attribute.value;
        break;

      default:
        break;
    }
  }

  for (var k = 0; k < element.childNodes.length; k++) {
    var node = element.childNodes[k];
    var streamEvent = {
      id: undefined,
      eventPresentationTime: 0,
      duration: undefined,
      timescale: attributes.timescale,
      data: {
        type: "dash-event-stream",
        value: {
          schemeIdUri: (_a = attributes.schemeId) !== null && _a !== void 0 ? _a : "",
          timescale: attributes.timescale,
          element: node
        }
      }
    };
    var parseEventValue = ValueParser(streamEvent, warnings);

    if (node.nodeName === "Event" && node.nodeType === Node.ELEMENT_NODE) {
      var eventAttributes = node.attributes;

      for (var j = 0; j < eventAttributes.length; j++) {
        var _attribute = eventAttributes[j];

        switch (_attribute.name) {
          case "presentationTime":
            parseEventValue(_attribute.value, {
              asKey: "eventPresentationTime",
              parser: parseMPDInteger,
              dashName: "presentationTime"
            });
            break;

          case "duration":
            parseEventValue(_attribute.value, {
              asKey: "duration",
              parser: parseMPDInteger,
              dashName: "duration"
            });
            break;

          case "id":
            streamEvent.id = _attribute.value;
            break;

          default:
            break;
        }
      }

      streamEvents.push(streamEvent);
    }
  }

  return [streamEvents, warnings];
}

/* harmony default export */ var EventStream = (parseEventStream);
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {NodeList} periodChildren
 * @returns {Array}
 */

function parsePeriodChildren(periodChildren) {
  var baseURLs = [];
  var adaptations = [];
  var segmentTemplate;
  var warnings = [];
  var streamEvents = [];

  for (var i = 0; i < periodChildren.length; i++) {
    if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = periodChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentElement),
              baseURLObj = _parseBaseURL[0],
              baseURLWarnings = _parseBaseURL[1];

          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }

          warnings = warnings.concat(baseURLWarnings);
          break;

        case "AdaptationSet":
          var _createAdaptationSetI = createAdaptationSetIntermediateRepresentation(currentElement),
              adaptation = _createAdaptationSetI[0],
              adaptationWarnings = _createAdaptationSetI[1];

          adaptations.push(adaptation);
          warnings = warnings.concat(adaptationWarnings);
          break;

        case "EventStream":
          var _parseEventStream = EventStream(currentElement),
              newStreamEvents = _parseEventStream[0],
              eventStreamWarnings = _parseEventStream[1];

          streamEvents.push.apply(streamEvents, newStreamEvents);
          warnings = warnings.concat(eventStreamWarnings);
          break;

        case "SegmentTemplate":
          var _parseSegmentTemplate = parseSegmentTemplate(currentElement),
              parsedSegmentTemplate = _parseSegmentTemplate[0],
              segmentTemplateWarnings = _parseSegmentTemplate[1];

          segmentTemplate = parsedSegmentTemplate;

          if (segmentTemplateWarnings.length > 0) {
            warnings = warnings.concat(segmentTemplateWarnings);
          }

          break;
      }
    }
  }

  return [{
    baseURLs: baseURLs,
    adaptations: adaptations,
    streamEvents: streamEvents,
    segmentTemplate: segmentTemplate
  }, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */


function parsePeriodAttributes(periodElement) {
  var res = {};
  var warnings = [];
  var parseValue = ValueParser(res, warnings);

  for (var i = 0; i < periodElement.attributes.length; i++) {
    var attr = periodElement.attributes[i];

    switch (attr.name) {
      case "id":
        res.id = attr.value;
        break;

      case "start":
        parseValue(attr.value, {
          asKey: "start",
          parser: parseDuration,
          dashName: "start"
        });
        break;

      case "duration":
        parseValue(attr.value, {
          asKey: "duration",
          parser: parseDuration,
          dashName: "duration"
        });
        break;

      case "bitstreamSwitching":
        parseValue(attr.value, {
          asKey: "bitstreamSwitching",
          parser: parseBoolean,
          dashName: "bitstreamSwitching"
        });
        break;

      case "xlink:href":
        res.xlinkHref = attr.value;
        break;

      case "xlink:actuate":
        res.xlinkActuate = attr.value;
        break;
    }
  }

  return [res, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */


function createPeriodIntermediateRepresentation(periodElement) {
  var _parsePeriodChildren = parsePeriodChildren(periodElement.childNodes),
      children = _parsePeriodChildren[0],
      childrenWarnings = _parsePeriodChildren[1];

  var _parsePeriodAttribute = parsePeriodAttributes(periodElement),
      attributes = _parsePeriodAttribute[0],
      attrsWarnings = _parsePeriodAttribute[1];

  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Array.<Object>}
 */

function parseMPDChildren(mpdChildren) {
  var baseURLs = [];
  var locations = [];
  var periods = [];
  var utcTimings = [];
  var warnings = [];

  for (var i = 0; i < mpdChildren.length; i++) {
    if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = mpdChildren[i];

      switch (currentNode.nodeName) {
        case "BaseURL":
          var _parseBaseURL = parseBaseURL(currentNode),
              baseURLObj = _parseBaseURL[0],
              baseURLWarnings = _parseBaseURL[1];

          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }

          warnings = warnings.concat(baseURLWarnings);
          break;

        case "Location":
          locations.push(currentNode.textContent === null ? "" : currentNode.textContent);
          break;

        case "Period":
          var _createPeriodIntermed = createPeriodIntermediateRepresentation(currentNode),
              period = _createPeriodIntermed[0],
              periodWarnings = _createPeriodIntermed[1];

          periods.push(period);
          warnings = warnings.concat(periodWarnings);
          break;

        case "UTCTiming":
          var utcTiming = parseScheme(currentNode);
          utcTimings.push(utcTiming);
          break;
      }
    }
  }

  return [{
    baseURLs: baseURLs,
    locations: locations,
    periods: periods,
    utcTimings: utcTimings
  }, warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */


function parseMPDAttributes(root) {
  var res = {};
  var warnings = [];
  var parseValue = ValueParser(res, warnings);

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;

      case "profiles":
        res.profiles = attribute.value;
        break;

      case "type":
        res.type = attribute.value;
        break;

      case "availabilityStartTime":
        parseValue(attribute.value, {
          asKey: "availabilityStartTime",
          parser: parseDateTime,
          dashName: "availabilityStartTime"
        });
        break;

      case "availabilityEndTime":
        parseValue(attribute.value, {
          asKey: "availabilityEndTime",
          parser: parseDateTime,
          dashName: "availabilityEndTime"
        });
        break;

      case "publishTime":
        parseValue(attribute.value, {
          asKey: "publishTime",
          parser: parseDateTime,
          dashName: "publishTime"
        });
        break;

      case "mediaPresentationDuration":
        parseValue(attribute.value, {
          asKey: "duration",
          parser: parseDuration,
          dashName: "mediaPresentationDuration"
        });
        break;

      case "minimumUpdatePeriod":
        parseValue(attribute.value, {
          asKey: "minimumUpdatePeriod",
          parser: parseDuration,
          dashName: "minimumUpdatePeriod"
        });
        break;

      case "minBufferTime":
        parseValue(attribute.value, {
          asKey: "minBufferTime",
          parser: parseDuration,
          dashName: "minBufferTime"
        });
        break;

      case "timeShiftBufferDepth":
        parseValue(attribute.value, {
          asKey: "timeShiftBufferDepth",
          parser: parseDuration,
          dashName: "timeShiftBufferDepth"
        });
        break;

      case "suggestedPresentationDelay":
        parseValue(attribute.value, {
          asKey: "suggestedPresentationDelay",
          parser: parseDuration,
          dashName: "suggestedPresentationDelay"
        });
        break;

      case "maxSegmentDuration":
        parseValue(attribute.value, {
          asKey: "maxSegmentDuration",
          parser: parseDuration,
          dashName: "maxSegmentDuration"
        });
        break;

      case "maxSubsegmentDuration":
        parseValue(attribute.value, {
          asKey: "maxSubsegmentDuration",
          parser: parseDuration,
          dashName: "maxSubsegmentDuration"
        });
        break;
    }
  }

  return [res, warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */


function createMPDIntermediateRepresentation(root) {
  var _parseMPDChildren = parseMPDChildren(root.childNodes),
      children = _parseMPDChildren[0],
      childrenWarnings = _parseMPDChildren[1];

  var _parseMPDAttributes = parseMPDAttributes(root),
      attributes = _parseMPDAttributes[0],
      attrsWarnings = _parseMPDAttributes[1];

  var warnings = childrenWarnings.concat(attrsWarnings);
  return [{
    children: children,
    attributes: attributes
  }, warnings];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_availability_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the base time of the Manifest.
 * @param {Object} rootAttributes
 * @param {number|undefined}
 */
function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
  if (rootAttributes.type !== "dynamic") {
    return 0;
  }

  if (rootAttributes.availabilityStartTime == null) {
    return referenceDateTime == null ? 0 : referenceDateTime;
  }

  return rootAttributes.availabilityStartTime;
}
// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(99);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(64);

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(78);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/flatten_overlapping_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */

function flattenOverlappingPeriods(parsedPeriods) {
  if (parsedPeriods.length === 0) {
    return [];
  }

  var flattenedPeriods = [parsedPeriods[0]];

  for (var i = 1; i < parsedPeriods.length; i++) {
    var parsedPeriod = parsedPeriods[i];
    var lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];

    while (lastFlattenedPeriod.duration == null || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {
      log["a" /* default */].warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod);
      lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
      lastFlattenedPeriod.end = parsedPeriod.start;

      if (lastFlattenedPeriod.duration <= 0) {
        flattenedPeriods.pop();
        lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
      }
    }

    flattenedPeriods.push(parsedPeriod);
  }

  return flattenedPeriods;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_periods_time_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */
function getPeriodsTimeInformation(periodsIR, manifestInfos) {
  var periodsTimeInformation = [];
  periodsIR.forEach(function (currentPeriod, i) {
    var periodStart;

    if (currentPeriod.attributes.start != null) {
      periodStart = currentPeriod.attributes.start;
    } else {
      if (i === 0) {
        periodStart = !manifestInfos.isDynamic || manifestInfos.availabilityStartTime == null ? 0 : manifestInfos.availabilityStartTime;
      } else {
        // take time information from previous period
        var prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];

        if (prevPeriodInfos != null && prevPeriodInfos.periodEnd != null) {
          periodStart = prevPeriodInfos.periodEnd;
        } else {
          throw new Error("Missing start time when parsing periods.");
        }
      }
    }

    var periodDuration;
    var nextPeriod = periodsIR[i + 1];

    if (currentPeriod.attributes.duration != null) {
      periodDuration = currentPeriod.attributes.duration;
    } else if (i === periodsIR.length - 1) {
      periodDuration = manifestInfos.duration;
    } else if (nextPeriod.attributes.start != null) {
      periodDuration = nextPeriod.attributes.start - periodStart;
    }

    var periodEnd = periodDuration != null ? periodStart + periodDuration : undefined;
    periodsTimeInformation.push({
      periodStart: periodStart,
      periodDuration: periodDuration,
      periodEnd: periodEnd
    });
  });
  return periodsTimeInformation;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/manifest_bounds_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * That task can be an hard for dynamic DASH contents: it depends on a
 * `timeShiftBufferDepth` defined in the MPD and on the maximum possible
 * position.
 *
 * The latter can come from either a clock synchronization mechanism or the
 * indexing schemes (e.g. SegmentTemplate, SegmentTimeline etc.) of the last
 * Periods.
 * As such, it might only be known once a large chunk of the MPD has already
 * been parsed.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 *
 * @example
 * ```js
 * const manifestBoundsCalculator = new ManifestBoundsCalculator();
 *
 * // let's imagine a property `index` on a Representation which need to obtain
 * // the last position at any time
 * someRepresentation.index = new TemplateRepresentationIndex({
 *   // ...
 *   manifestBoundsCalculator // for now, `getLastPosition` will return `undefined`
 * });
 *
 * // ...
 * // Let's imagine a function which try to guess the last position based on a
 * // given parsed period
 * const lastPosition = getMaximumBound(somePeriod);
 * if (lastPosition != null) {
 *   const positionTime = performance.now() / 1000;
 *   manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
 *   // `getLastPosition` will now be correctly communicate the last position
 *   // (it returned `undefined` until then).
 * }
 * ```
 * @class ManifestBoundsCalculator
 */
var ManifestBoundsCalculator = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function ManifestBoundsCalculator(args) {
    this._isDynamic = args.isDynamic;
    this._timeShiftBufferDepth = !args.isDynamic || args.timeShiftBufferDepth === undefined ? null : args.timeShiftBufferDepth;
  }
  /**
   * Set the last position and the position time (the value of `performance.now()`
   * at the time that position was true converted into seconds).
   *
   * @example
   * Example if you trust `Date.now()` to give you a reliable offset:
   * ```js
   * const lastPosition = Date.now();
   * const positionTime = performance.now() / 1000;
   * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
   * ```
   *
   * @param {number} lastPosition
   * @param {number|undefined} positionTime
   */


  var _proto = ManifestBoundsCalculator.prototype;

  _proto.setLastPosition = function setLastPosition(lastPosition, positionTime) {
    this._lastPosition = lastPosition;
    this._positionTime = positionTime;
  }
  /**
   * Returns `true` if the last position and the position time
   * (for dynamic content only) have been comunicated.
   * `false` otherwise.
   * @returns {boolean}
   */
  ;

  _proto.lastPositionIsKnown = function lastPositionIsKnown() {
    if (this._isDynamic) {
      return this._positionTime != null && this._lastPosition != null;
    }

    return this._lastPosition != null;
  }
  /**
   * Get minimum bound of content.
   * @return {number|undefined}
   */
  ;

  _proto.getMinimumBound = function getMinimumBound() {
    if (!this._isDynamic || this._timeShiftBufferDepth === null) {
      return 0;
    }

    var maximumBound = this.getMaximumBound();

    if (maximumBound === undefined) {
      return undefined;
    }

    var minimumBound = maximumBound - this._timeShiftBufferDepth;
    return minimumBound;
  }
  /**
   * Calculate the current maximum bound by using both the calculated
   * last position and the timeshift buffer depth.
   * `undefined` if the last position has never been communicated.
   * @return {number|undefined}
   */
  ;

  _proto.getMaximumBound = function getMaximumBound() {
    if (this._isDynamic && this._positionTime != null && this._lastPosition != null) {
      return Math.max(this._lastPosition - this._positionTime + performance.now() / 1000, 0);
    }

    return this._lastPosition;
  };

  return ManifestBoundsCalculator;
}();


// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/infer_adaptation_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** Array grouping every possible type a parsed Adaptation can be. */

var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
/** Different `role`s a text Adaptation can be. */

var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Array.<Object>} representations
 * @param {string|null} adaptationMimeType
 * @param {string|null} adaptationCodecs
 * @param {Array.<Object>|null} adaptationRoles
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */

function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
  function fromMimeType(mimeType, roles) {
    var topLevel = mimeType.split("/")[0];

    if (Object(array_includes["a" /* default */])(KNOWN_ADAPTATION_TYPES, topLevel)) {
      return topLevel;
    }

    if (mimeType === "application/bif") {
      return "image";
    }

    if (mimeType === "application/ttml+xml") {
      return "text";
    } // manage DASH-IF mp4-embedded subtitles and metadata


    if (mimeType === "application/mp4") {
      if (roles != null) {
        if (Object(array_find["a" /* default */])(roles, function (role) {
          return role.schemeIdUri === "urn:mpeg:dash:role:2011" && Object(array_includes["a" /* default */])(SUPPORTED_TEXT_TYPES, role.value);
        }) != null) {
          return "text";
        }
      }

      return undefined;
    }
  }

  function fromCodecs(codecs) {
    switch (codecs.substring(0, 3)) {
      case "avc":
      case "hev":
      case "hvc":
      case "vp8":
      case "vp9":
      case "av1":
        return "video";

      case "vtt":
        return "text";

      case "bif":
        return "image";
    }

    switch (codecs.substring(0, 4)) {
      case "mp4a":
        return "audio";

      case "wvtt":
      case "stpp":
        return "text";
    }
  }

  if (adaptationMimeType !== null) {
    var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);

    if (typeFromMimeType !== undefined) {
      return typeFromMimeType;
    }
  }

  if (adaptationCodecs !== null) {
    var typeFromCodecs = fromCodecs(adaptationCodecs);

    if (typeFromCodecs !== undefined) {
      return typeFromCodecs;
    }
  }

  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];
    var _representation$attri = representation.attributes,
        mimeType = _representation$attri.mimeType,
        codecs = _representation$attri.codecs;

    if (mimeType !== undefined) {
      var _typeFromMimeType = fromMimeType(mimeType, adaptationRoles);

      if (_typeFromMimeType !== undefined) {
        return _typeFromMimeType;
      }
    }

    if (codecs !== undefined) {
      var _typeFromCodecs = fromCodecs(codecs);

      if (_typeFromCodecs !== undefined) {
        return _typeFromCodecs;
      }
    }
  }

  return undefined;
}
// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(20);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */
function get_init_segment_getInitSegment(index) {
  var _a;

  var initialization = index.initialization;
  return {
    id: "init",
    isInit: true,
    time: 0,
    duration: 0,
    range: initialization != null ? initialization.range : undefined,
    indexRange: index.indexRange,
    mediaURLs: (_a = initialization === null || initialization === void 0 ? void 0 : initialization.mediaURLs) !== null && _a !== void 0 ? _a : null,
    timescale: index.timescale,
    timestampOffset: -(index.indexTimeOffset / index.timescale)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */

function padLeftWithZeros(n, l) {
  var nToString = n.toString();

  if (nToString.length >= l) {
    return nToString;
  }

  var arr = new Array(l + 1).join("0") + nToString;
  return arr.slice(-l);
}
/**
 * @param {string|number} replacer
 * @returns {Function}
 */


function processFormatedToken(replacer) {
  return function (_match, _format, widthStr) {
    var width = Object(is_non_empty_string["a" /* default */])(widthStr) ? parseInt(widthStr, 10) : 1;
    return padLeftWithZeros(String(replacer), width);
  };
}
/**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */


function createIndexURLs(baseURLs, media, id, bitrate) {
  if (baseURLs.length === 0) {
    return media !== undefined ? [replaceRepresentationDASHTokens(media, id, bitrate)] : null;
  }

  return baseURLs.map(function (baseURL) {
    return replaceRepresentationDASHTokens(Object(resolve_url["a" /* default */])(baseURL, media), id, bitrate);
  });
}
/**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */

function replaceRepresentationDASHTokens(path, id, bitrate) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate === undefined ? 0 : bitrate));
  }
}
/**
 * Create function allowing to replace "tokens" in a given DASH segment URL
 * (e.g. $Time$, which has to be replaced by the segment's start time) by the
 * right information.
 * @param {number|undefined} time
 * @param {number|undefined} nb
 * @returns {Function}
 */

function createDashUrlDetokenizer(time, nb) {
  /**
   * Replace the tokens in the given `url` by the segment information defined
   * by the outer function.
   * @param {string} url
   * @returns {string}
   *
   * @throws Error - Throws if we do not have enough data to construct the URL
   */
  return function replaceTokensInUrl(url) {
    if (url.indexOf("$") === -1) {
      return url;
    } else {
      return url.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
        if (nb === undefined) {
          throw new Error("Segment number not defined in a $Number$ scheme");
        }

        return processFormatedToken(nb)(_x, _y, widthStr);
      }).replace(/\$Time(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
        if (time === undefined) {
          throw new Error("Segment time not defined in a $Time$ scheme");
        }

        return processFormatedToken(time)(_x, _y, widthStr);
      });
    }
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_segments_from_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */

function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
  var diff = wantedTime - segmentStartTime;
  return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
}
/**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @param {number|undefined} maximumTime
 * @returns {Array.<Object>}
 */


function getSegmentsFromTimeline(index, from, durationWanted, maximumTime) {
  var scaledUp = Object(index_helpers["e" /* toIndexTime */])(from, index);
  var scaledTo = Object(index_helpers["e" /* toIndexTime */])(from + durationWanted, index);
  var timeline = index.timeline,
      timescale = index.timescale,
      mediaURLs = index.mediaURLs,
      startNumber = index.startNumber;
  var currentNumber = startNumber != null ? startNumber : undefined;
  var segments = [];
  var timelineLength = timeline.length; // TODO(pierre): use @maxSegmentDuration if possible

  var maxEncounteredDuration = timeline.length > 0 && timeline[0].duration != null ? timeline[0].duration : 0;

  for (var i = 0; i < timelineLength; i++) {
    var timelineItem = timeline[i];
    var duration = timelineItem.duration,
        start = timelineItem.start,
        range = timelineItem.range;
    maxEncounteredDuration = Math.max(maxEncounteredDuration, duration);
    var repeat = Object(index_helpers["a" /* calculateRepeat */])(timelineItem, timeline[i + 1], maximumTime);
    var segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
    var segmentTime = start + segmentNumberInCurrentRange * duration;

    while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
      var segmentNumber = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
      var detokenizedURLs = mediaURLs === null ? null : mediaURLs.map(createDashUrlDetokenizer(segmentTime, segmentNumber));
      var segment = {
        id: String(segmentTime),
        time: segmentTime - index.indexTimeOffset,
        isInit: false,
        range: range,
        duration: duration,
        timescale: timescale,
        mediaURLs: detokenizedURLs,
        number: segmentNumber,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(segment); // update segment number and segment time for the next segment

      segmentNumberInCurrentRange++;
      segmentTime = start + segmentNumberInCurrentRange * duration;
    }

    if (segmentTime >= scaledTo) {
      // we reached ``scaledTo``, we're done
      return segments;
    }

    if (currentNumber != null) {
      currentNumber += repeat + 1;
    }
  }

  return segments;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */

function _addSegmentInfos(index, segmentInfos) {
  if (segmentInfos.timescale !== index.timescale) {
    var timescale = index.timescale;
    index.timeline.push({
      start: segmentInfos.time / segmentInfos.timescale * timescale,
      duration: segmentInfos.duration / segmentInfos.timescale * timescale,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  } else {
    index.timeline.push({
      start: segmentInfos.time,
      duration: segmentInfos.duration,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  }

  return true;
}

var base_BaseRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function BaseRepresentationIndex(index, context) {
    var _a, _b;

    var periodStart = context.periodStart,
        periodEnd = context.periodEnd,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var mediaURLs = createIndexURLs(representationBaseURLs, index.initialization !== undefined ? index.initialization.media : undefined, representationId, representationBitrate); // TODO If indexRange is either undefined or behind the initialization segment
    // the following logic will not work.
    // However taking the nth first bytes like `dash.js` does (where n = 1500) is
    // not straightforward as we would need to clean-up the segment after that.
    // The following logic corresponds to 100% of tested cases, so good enough for
    // now.

    var range = index.initialization !== undefined ? index.initialization.range : index.indexRange !== undefined ? [0, index.indexRange[0] - 1] : undefined;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: {
        mediaURLs: mediaURLs,
        range: range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: (_b = index.timeline) !== null && _b !== void 0 ? _b : [],
      timescale: timescale
    };
    this._scaledPeriodEnd = periodEnd == null ? undefined : Object(index_helpers["e" /* toIndexTime */])(periodEnd, this._index);
    this._isInitialized = this._index.timeline.length > 0;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = BaseRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(_up, _to) {
    return getSegmentsFromTimeline(this._index, _up, _to, this._scaledPeriodEnd);
  }
  /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * Returns first position in index.
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    var index = this._index;

    if (index.timeline.length === 0) {
      return null;
    }

    return Object(index_helpers["b" /* fromIndexTime */])(index.timeline[0].start, index);
  }
  /**
   * Returns last position in index.
   * @returns {Number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var timeline = this._index.timeline;

    if (timeline.length === 0) {
      return null;
    }

    var lastTimelineElement = timeline[timeline.length - 1];
    var lastTime = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null, this._scaledPeriodEnd);
    return Object(index_helpers["b" /* fromIndexTime */])(lastTime, this._index);
  }
  /**
   * Segments in a segmentBase scheme should stay available.
   * @returns {Boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * @param {Array.<Object>} nextSegments
   * @returns {Array.<Object>}
   */
  ;

  _proto._addSegments = function _addSegments(nextSegments) {
    for (var i = 0; i < nextSegments.length; i++) {
      _addSegmentInfos(this._index, nextSegments[i]);
    }

    if (!this._isInitialized && this._index.timeline.length > 0) {
      this._isInitialized = true;
    }
  }
  /**
   * Returns true as SegmentBase does not get updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * Returns true as SegmentBase does not get updated.
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return this._isInitialized;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
  };

  _proto._update = function _update() {
    log["a" /* default */].error("Base RepresentationIndex: Cannot update a SegmentList");
  };

  return BaseRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var list_ListRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function ListRepresentationIndex(index, context) {
    var _a;

    var periodStart = context.periodStart,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    this._periodStart = periodStart;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var list = index.list.map(function (lItem) {
      return {
        mediaURLs: createIndexURLs(representationBaseURLs, lItem.media, representationId, representationBitrate),
        mediaRange: lItem.mediaRange
      };
    });
    this._index = {
      list: list,
      timescale: timescale,
      duration: index.duration,
      indexTimeOffset: indexTimeOffset,
      indexRange: index.indexRange,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      }
    };
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = ListRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} fromTime
   * @param {Number} duration
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(fromTime, dur) {
    var index = this._index;
    var duration = index.duration,
        list = index.list,
        timescale = index.timescale;
    var fromTimeInPeriod = fromTime - this._periodStart;

    var _getTimescaledRange = Object(index_helpers["d" /* getTimescaledRange */])(fromTimeInPeriod, dur, timescale),
        up = _getTimescaledRange[0],
        to = _getTimescaledRange[1];

    var scaledStart = this._periodStart * timescale;
    var length = Math.min(list.length - 1, Math.floor(to / duration));
    var segments = [];
    var i = Math.floor(up / duration);

    while (i <= length) {
      var range = list[i].mediaRange;
      var mediaURLs = list[i].mediaURLs;
      var args = {
        id: String(i),
        time: i * duration + scaledStart,
        isInit: false,
        range: range,
        duration: duration,
        timescale: timescale,
        mediaURLs: mediaURLs,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(args);
      i++;
    }

    return segments;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} _fromTime
   * @param {Number} toTime
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
    var _this$_index = this._index,
        timescale = _this$_index.timescale,
        duration = _this$_index.duration,
        list = _this$_index.list;
    var scaledTo = toTime * timescale;
    var i = Math.floor(scaledTo / duration);
    return i < 0 || i >= list.length;
  }
  /**
   * Returns first position in this index, in seconds.
   * @returns {Number}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    return this._periodStart;
  }
  /**
   * Returns last position in this index, in seconds.
   * @returns {Number}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var index = this._index;
    var duration = index.duration,
        list = index.list;
    return list.length * duration / index.timescale + this._periodStart;
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * @param {Object} segment
   * @returns {Boolean}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    var index = this._index;
    var scaledStart = this._periodStart * index.timescale;
    var scaledSegmentStartInPeriod = segment.timescale !== index.timescale ? segment.time * index.timescale / segment.timescale + scaledStart : segment.time - scaledStart;
    var duration = index.duration;
    var segmentNb = scaledSegmentStartInPeriod / duration;
    return segmentNb > 0 && segmentNb % 1 === 0;
  }
  /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * SegmentList should not be updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update() {
    log["a" /* default */].error("List RepresentationIndex: Cannot update a SegmentList");
  };

  _proto._addSegments = function _addSegments() {
    if (false) {}
  };

  return ListRepresentationIndex;
}();


// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(179);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(123);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(121);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(122);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/convert_element_to_index_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */

function convertElementsToIndexSegment(item, previousItem, nextItem, timelineStart) {
  var start = item.start;
  var duration = item.duration;
  var repeatCount = item.repeatCount;

  if (start == null) {
    if (previousItem == null) {
      start = timelineStart;
    } else if (previousItem.duration != null) {
      start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);
    }
  }

  if ((duration == null || isNaN(duration)) && nextItem != null && nextItem.start != null && !isNaN(nextItem.start) && start != null && !isNaN(start)) {
    duration = nextItem.start - start;
  }

  if (start != null && !isNaN(start) && duration != null && !isNaN(duration) && (repeatCount == null || !isNaN(repeatCount))) {
    return {
      start: start,
      duration: duration,
      repeatCount: repeatCount === undefined ? 0 : repeatCount
    };
  }

  log["a" /* default */].warn("DASH: A \"S\" Element could not have been parsed.");
  return null;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/parse_s_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a given <S> element in the MPD into a JS Object.
 * @param {Element} root
 * @returns {Object}
 */

function parseSElement(root) {
  var parsedS = {};

  for (var j = 0; j < root.attributes.length; j++) {
    var attribute = root.attributes[j];

    switch (attribute.name) {
      case "t":
        var start = parseInt(attribute.value, 10);

        if (isNaN(start)) {
          log["a" /* default */].warn("DASH: invalid t (\"" + attribute.value + "\")");
        } else {
          parsedS.start = start;
        }

        break;

      case "d":
        var duration = parseInt(attribute.value, 10);

        if (isNaN(duration)) {
          log["a" /* default */].warn("DASH: invalid d (\"" + attribute.value + "\")");
        } else {
          parsedS.duration = duration;
        }

        break;

      case "r":
        var repeatCount = parseInt(attribute.value, 10);

        if (isNaN(repeatCount)) {
          log["a" /* default */].warn("DASH: invalid r (\"" + attribute.value + "\")");
        } else {
          parsedS.repeatCount = repeatCount;
        }

        break;
    }
  }

  return parsedS;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/construct_timeline_from_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Allows to generate the "timeline" for the "Timeline" RepresentationIndex.
 * Call this function when the timeline is unknown.
 * This function was added to only perform that task lazily, i.e. only when
 * first needed.
 * @param {HTMLCollection} elements - All S nodes constituting the corresponding
 * SegmentTimeline node.
 * @param {number} scaledPeriodStart - Absolute start of the concerned Period,
 * in the same scale than the segments found in `elements`.
 * @returns {Array.<Object>}
 */

function constructTimelineFromElements(elements, scaledPeriodStart) {
  var initialTimeline = [];

  for (var i = 0; i < elements.length; i++) {
    initialTimeline.push(parseSElement(elements[i]));
  }

  var timeline = [];

  for (var _i = 0; _i < initialTimeline.length; _i++) {
    var item = initialTimeline[_i];
    var previousItem = timeline[timeline.length - 1] === undefined ? null : timeline[timeline.length - 1];
    var nextItem = initialTimeline[_i + 1] === undefined ? null : initialTimeline[_i + 1];
    var timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem, scaledPeriodStart);

    if (timelineElement != null) {
      timeline.push(timelineElement);
    }
  }

  return timeline;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/find_first_common_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * By comparing two timelines for the same content at different points in time,
 * retrieve the index in both timelines of the first segment having the same
 * starting time.
 * Returns `null` if not found.
 * @param {Array.<Object>} prevTimeline
 * @param {HTMLCollection} newElements
 * @returns {Object|null}
 */
function findFirstCommonStartTime(prevTimeline, newElements) {
  if (prevTimeline.length === 0 || newElements.length === 0) {
    return null;
  }

  var prevInitialStart = prevTimeline[0].start;
  var newFirstTAttr = newElements[0].getAttribute("t");
  var newInitialStart = newFirstTAttr === null ? null : parseInt(newFirstTAttr, 10);

  if (newInitialStart === null || Number.isNaN(newInitialStart)) {
    return null;
  }

  if (prevInitialStart === newInitialStart) {
    return {
      prevSegmentsIdx: 0,
      newElementsIdx: 0,
      repeatNumberInPrevSegments: 0,
      repeatNumberInNewElements: 0
    };
  } else if (prevInitialStart < newInitialStart) {
    var prevElt = prevTimeline[0];
    var prevElementIndex = 0;

    while (true) {
      if (prevElt.repeatCount > 0) {
        var diff = newInitialStart - prevElt.start;

        if (diff % prevElt.duration === 0 && diff / prevElt.duration <= prevElt.repeatCount) {
          var repeatNumberInPrevSegments = diff / prevElt.duration;
          return {
            repeatNumberInPrevSegments: repeatNumberInPrevSegments,
            prevSegmentsIdx: prevElementIndex,
            newElementsIdx: 0,
            repeatNumberInNewElements: 0
          };
        }
      }

      prevElementIndex++;

      if (prevElementIndex >= prevTimeline.length) {
        return null;
      }

      prevElt = prevTimeline[prevElementIndex];

      if (prevElt.start === newInitialStart) {
        return {
          prevSegmentsIdx: prevElementIndex,
          newElementsIdx: 0,
          repeatNumberInPrevSegments: 0,
          repeatNumberInNewElements: 0
        };
      } else if (prevElt.start > newInitialStart) {
        return null;
      }
    }
  } else {
    var newElementsIdx = 0;
    var newElt = newElements[0];
    var currentTimeOffset = newInitialStart;

    while (true) {
      var dAttr = newElt.getAttribute("d");
      var duration = dAttr === null ? null : parseInt(dAttr, 10);

      if (duration === null || Number.isNaN(duration)) {
        return null;
      }

      var rAttr = newElt.getAttribute("r");
      var repeatCount = rAttr === null ? null : parseInt(rAttr, 10);

      if (repeatCount !== null) {
        if (Number.isNaN(repeatCount) || repeatCount < 0) {
          return null;
        }

        if (repeatCount > 0) {
          var _diff = prevInitialStart - currentTimeOffset;

          if (_diff % duration === 0 && _diff / duration <= repeatCount) {
            var repeatNumberInNewElements = _diff / duration;
            return {
              repeatNumberInPrevSegments: 0,
              repeatNumberInNewElements: repeatNumberInNewElements,
              prevSegmentsIdx: 0,
              newElementsIdx: newElementsIdx
            };
          }
        }

        currentTimeOffset += duration * (repeatCount + 1);
      } else {
        currentTimeOffset += duration;
      }

      newElementsIdx++;

      if (newElementsIdx >= newElements.length) {
        return null;
      }

      newElt = newElements[newElementsIdx];
      var tAttr = newElt.getAttribute("t");
      var time = tAttr === null ? null : parseInt(tAttr, 10);

      if (time !== null) {
        if (Number.isNaN(time)) {
          return null;
        }

        currentTimeOffset = time;
      }

      if (currentTimeOffset === prevInitialStart) {
        return {
          newElementsIdx: newElementsIdx,
          prevSegmentsIdx: 0,
          repeatNumberInPrevSegments: 0,
          repeatNumberInNewElements: 0
        };
      } else if (currentTimeOffset > newInitialStart) {
        return null;
      }
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/construct_timeline_from_previous_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function constructTimelineFromPreviousTimeline(newElements, prevTimeline, scaledPeriodStart) {
  var _a; // Find first index in both timeline where a common segment is found.


  var commonStartInfo = findFirstCommonStartTime(prevTimeline, newElements);

  if (commonStartInfo === null) {
    log["a" /* default */].warn("DASH: Cannot perform \"based\" update. Common segment not found.");
    return constructTimelineFromElements(newElements, scaledPeriodStart);
  }

  var prevSegmentsIdx = commonStartInfo.prevSegmentsIdx,
      newElementsIdx = commonStartInfo.newElementsIdx,
      repeatNumberInPrevSegments = commonStartInfo.repeatNumberInPrevSegments,
      repeatNumberInNewElements = commonStartInfo.repeatNumberInNewElements;
  /** Guess of the number of elements in common. */

  var numberCommonEltGuess = prevTimeline.length - prevSegmentsIdx;
  var lastCommonEltNewEltsIdx = numberCommonEltGuess + newElementsIdx - 1;

  if (lastCommonEltNewEltsIdx >= newElements.length) {
    log["a" /* default */].info("DASH: Cannot perform \"based\" update. New timeline too short");
    return constructTimelineFromElements(newElements, scaledPeriodStart);
  } // Remove elements which are not available anymore


  var newTimeline = prevTimeline.slice(prevSegmentsIdx);

  if (repeatNumberInPrevSegments > 0) {
    var commonEltInOldTimeline = newTimeline[0];
    commonEltInOldTimeline.start += commonEltInOldTimeline.duration * repeatNumberInPrevSegments;
    newTimeline[0].repeatCount -= repeatNumberInPrevSegments;
  }

  if (repeatNumberInNewElements > 0 && newElementsIdx !== 0) {
    log["a" /* default */].info("DASH: Cannot perform \"based\" update. " + "The new timeline has a different form.");
    return constructTimelineFromElements(newElements, scaledPeriodStart);
  }

  var prevLastElement = newTimeline[newTimeline.length - 1];
  var newCommonElt = parseSElement(newElements[lastCommonEltNewEltsIdx]);
  var newRepeatCountOffseted = ((_a = newCommonElt.repeatCount) !== null && _a !== void 0 ? _a : 0) - repeatNumberInNewElements;

  if (newCommonElt.duration !== prevLastElement.duration || prevLastElement.repeatCount > newRepeatCountOffseted) {
    log["a" /* default */].info("DASH: Cannot perform \"based\" update. " + "The new timeline has a different form at the beginning.");
    return constructTimelineFromElements(newElements, scaledPeriodStart);
  }

  if (newCommonElt.repeatCount !== undefined && newCommonElt.repeatCount > prevLastElement.repeatCount) {
    prevLastElement.repeatCount = newCommonElt.repeatCount;
  }

  var newEltsToPush = [];
  var items = [];

  for (var i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {
    items.push(parseSElement(newElements[i]));
  }

  for (var _i = 0; _i < items.length; _i++) {
    var item = items[_i];
    var previousItem = newEltsToPush[newEltsToPush.length - 1] === undefined ? prevLastElement : newEltsToPush[newEltsToPush.length - 1];
    var nextItem = items[_i + 1] === undefined ? null : items[_i + 1];
    var timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem, scaledPeriodStart);

    if (timelineElement !== null) {
      newEltsToPush.push(timelineElement);
    }
  }

  return newTimeline.concat(newEltsToPush);
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/timeline_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY = config["a" /* default */].MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY;
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */

function getSegmentIndex(timeline, start) {
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}

var timeline_representation_index_TimelineRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TimelineRepresentationIndex(index, timelineParser, context) {
    var _a;

    var manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate,
        periodStart = context.periodStart,
        periodEnd = context.periodEnd;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._lastUpdate = context.receivedTime == null ? performance.now() : context.receivedTime;
    this._unsafelyBaseOnPreviousIndex = null;

    if (context.unsafelyBaseOnPreviousRepresentation !== null && context.unsafelyBaseOnPreviousRepresentation.index instanceof TimelineRepresentationIndex) {
      // avoid too much nested references, to keep memory down
      context.unsafelyBaseOnPreviousRepresentation.index._unsafelyBaseOnPreviousIndex = null;
      this._unsafelyBaseOnPreviousIndex = context.unsafelyBaseOnPreviousRepresentation.index;
    }

    this._isDynamic = isDynamic;
    this._parseTimeline = timelineParser;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: null,
      timescale: timescale
    };
    this._scaledPeriodStart = Object(index_helpers["e" /* toIndexTime */])(periodStart, this._index);
    this._scaledPeriodEnd = periodEnd == null ? undefined : Object(index_helpers["e" /* toIndexTime */])(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = TimelineRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(from, duration) {
    this._refreshTimeline(); // clear timeline if needed


    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    } // destructuring to please TypeScript


    var _this$_index = this._index,
        mediaURLs = _this$_index.mediaURLs,
        startNumber = _this$_index.startNumber,
        timeline = _this$_index.timeline,
        timescale = _this$_index.timescale,
        indexTimeOffset = _this$_index.indexTimeOffset;
    return getSegmentsFromTimeline({
      mediaURLs: mediaURLs,
      startNumber: startNumber,
      timeline: timeline,
      timescale: timescale,
      indexTimeOffset: indexTimeOffset
    }, from, duration, this._scaledPeriodEnd);
  }
  /**
   * Returns true if the index should be refreshed.
   * @param {Number} _up
   * @param {Number} to
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    // DASH Manifest based on a SegmentTimeline should have minimumUpdatePeriod
    // attribute which should be sufficient to know when to refresh it.
    return false;
  }
  /**
   * Returns the starting time, in seconds, of the earliest segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var timeline = this._index.timeline;
    return timeline.length === 0 ? null : Object(index_helpers["b" /* fromIndexTime */])(timeline[0].start, this._index);
  }
  /**
   * Returns the ending time, in seconds, of the last segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var lastTime = TimelineRepresentationIndex.getIndexEnd(this._index.timeline, this._scaledPeriodStart);
    return lastTime === null ? null : Object(index_helpers["b" /* fromIndexTime */])(lastTime, this._index);
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * Returns false if it is not available anymore.
   * Returns undefined if we cannot know whether it is still available or not.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var _this$_index2 = this._index,
        timeline = _this$_index2.timeline,
        timescale = _this$_index2.timescale,
        indexTimeOffset = _this$_index2.indexTimeOffset;
    return Object(is_segment_still_available["a" /* default */])(segment, timeline, timescale, indexTimeOffset);
  }
  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var _this$_index3 = this._index,
        timeline = _this$_index3.timeline,
        timescale = _this$_index3.timescale;
    var scaledTime = Object(index_helpers["e" /* toIndexTime */])(_time, this._index);

    if (scaledTime <= 0) {
      return -1;
    }

    var segmentIndex = getSegmentIndex(this._index.timeline, scaledTime);

    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return -1;
    }

    var timelineItem = timeline[segmentIndex];

    if (timelineItem.duration === -1) {
      return -1;
    }

    var nextTimelineItem = timeline[segmentIndex + 1];

    if (nextTimelineItem == null) {
      return -1;
    }

    var rangeUp = timelineItem.start;
    var rangeTo = Object(index_helpers["c" /* getIndexSegmentEnd */])(timelineItem, nextTimelineItem, this._scaledPeriodEnd); // Every segments defined in range (from rangeUp to rangeTo) are
    // explicitely contiguous.
    // We want to check that the range end is before the next timeline item
    // start, and that scaled time is in this discontinuity.

    if (rangeTo < nextTimelineItem.start && scaledTime >= rangeUp && rangeTo - scaledTime < timescale) {
      return Object(index_helpers["b" /* fromIndexTime */])(nextTimelineItem.start, this._index);
    }

    return -1;
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isDynamic) {
      return false;
    }

    return error instanceof network_error["a" /* default */] && error.isHttpError(404);
  }
  /**
   * Replace this RepresentationIndex with one from a new version of the
   * Manifest.
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._parseTimeline = newIndex._parseTimeline;
    this._index = newIndex._index;
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  }
  /**
   * Update this RepresentationIndex with a shorter version of it coming from a
   * new version of the MPD.
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update(newIndex) {
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    if (newIndex._index.timeline === null) {
      newIndex._index.timeline = newIndex._getTimeline();
    }

    Object(update_segment_timeline["a" /* default */])(this._index.timeline, newIndex._index.timeline);
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
  };

  _proto._addSegments = function _addSegments() {
    if (false) {}
  }
  /**
   * Returns `true` if this RepresentationIndex currently contains its last
   * segment.
   * Returns `false` if it's still pending.
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    if (!this._isDynamic) {
      return true;
    }

    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var timeline = this._index.timeline;

    if (this._scaledPeriodEnd == null || timeline.length === 0) {
      return false;
    }

    var lastTimelineElement = timeline[timeline.length - 1];
    var lastTime = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null, this._scaledPeriodEnd); // We can never be truly sure if a SegmentTimeline-based index is finished
    // or not (1 / 60 for possible rounding errors)

    return lastTime + 1 / 60 >= this._scaledPeriodEnd;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to timeshifting.
   */
  ;

  _proto._refreshTimeline = function _refreshTimeline() {
    if (this._index.timeline === null) {
      this._index.timeline = this._getTimeline();
    }

    var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

    if (firstPosition == null) {
      return; // we don't know yet
    }

    var scaledFirstPosition = Object(index_helpers["e" /* toIndexTime */])(firstPosition, this._index);
    Object(clear_timeline_from_position["a" /* default */])(this._index.timeline, scaledFirstPosition);
  };

  TimelineRepresentationIndex.getIndexEnd = function getIndexEnd(timeline, scaledPeriodEnd) {
    if (timeline.length <= 0) {
      return null;
    }

    return Object(index_helpers["c" /* getIndexSegmentEnd */])(timeline[timeline.length - 1], null, scaledPeriodEnd);
  }
  /**
   * Allows to generate the "timeline" for this RepresentationIndex.
   * Call this function when the timeline is unknown.
   * This function was added to only perform that task lazily, i.e. only when
   * first needed.
   * After calling it, every now unneeded variable will be freed from memory.
   * This means that calling _getTimeline more than once will just return an
   * empty array.
   *
   * /!\ Please note that this structure should follow the exact same structure
   * than a SegmentTimeline element in the corresponding MPD.
   * This means:
   *   - It should have the same amount of elements in its array than there was
   *     `<S>` elements in the SegmentTimeline.
   *   - Each of those same elements should have the same start time, the same
   *     duration and the same repeat counter than what could be deduced from
   *     the SegmentTimeline.
   * This is needed to be able to run parsing optimization when refreshing the
   * MPD. Not doing so could lead to the RxPlayer not being able to play the
   * stream anymore.
   * @returns {Array.<Object>}
   */
  ;

  _proto._getTimeline = function _getTimeline() {
    if (this._parseTimeline === null) {
      if (this._index.timeline !== null) {
        return this._index.timeline;
      }

      log["a" /* default */].error("DASH: Timeline already lazily parsed.");
      return [];
    }

    var newElements = this._parseTimeline();

    this._parseTimeline = null; // Free memory

    if (this._unsafelyBaseOnPreviousIndex === null || newElements.length < MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY) {
      // Just completely parse the current timeline
      return constructTimelineFromElements(newElements, this._scaledPeriodStart);
    } // Construct previously parsed timeline if not already done


    var prevTimeline;

    if (this._unsafelyBaseOnPreviousIndex._index.timeline === null) {
      prevTimeline = this._unsafelyBaseOnPreviousIndex._getTimeline();
      this._unsafelyBaseOnPreviousIndex._index.timeline = prevTimeline;
    } else {
      prevTimeline = this._unsafelyBaseOnPreviousIndex._index.timeline;
    }

    this._unsafelyBaseOnPreviousIndex = null; // Free memory

    return constructTimelineFromPreviousTimeline(newElements, prevTimeline, this._scaledPeriodStart);
  };

  return TimelineRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var indexes_timeline = (timeline_representation_index_TimelineRepresentationIndex);
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/template.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * IRepresentationIndex implementation for DASH' SegmentTemplate without a
 * SegmentTimeline.
 * @class TemplateRepresentationIndex
 */

var template_TemplateRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TemplateRepresentationIndex(index, context) {
    var _a;

    var aggressiveMode = context.aggressiveMode,
        availabilityTimeOffset = context.availabilityTimeOffset,
        manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        periodEnd = context.periodEnd,
        periodStart = context.periodStart,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    var timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
    this._availabilityTimeOffset = availabilityTimeOffset;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._aggressiveMode = aggressiveMode;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;

    if (index.duration === undefined) {
      throw new Error("Invalid SegmentTemplate: no duration");
    }

    this._index = {
      duration: index.duration,
      timescale: timescale,
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      presentationTimeOffset: presentationTimeOffset,
      startNumber: index.startNumber
    };
    this._isDynamic = isDynamic;
    this._periodStart = periodStart;
    this._relativePeriodEnd = periodEnd == null ? undefined : periodEnd - periodStart;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = TemplateRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(fromTime, dur) {
    var index = this._index;
    var duration = index.duration,
        startNumber = index.startNumber,
        timescale = index.timescale,
        mediaURLs = index.mediaURLs;
    var scaledStart = this._periodStart * timescale;
    var scaledEnd = this._relativePeriodEnd == null ? undefined : this._relativePeriodEnd * timescale; // Convert the asked position to the right timescales, and consider them
    // relatively to the Period's start.

    var upFromPeriodStart = fromTime * timescale - scaledStart;
    var toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;

    var firstSegmentStart = this._getFirstSegmentStart();

    var lastSegmentStart = this._getLastSegmentStart();

    if (firstSegmentStart == null || lastSegmentStart == null) {
      return [];
    }

    var startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
    var lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);

    if (lastWantedStartPosition + duration <= startPosition) {
      return [];
    }

    var segments = []; // number corresponding to the Period's start

    var numberOffset = startNumber == null ? 1 : startNumber; // calcul initial time from Period start, where the first segment would have
    // the `0` number

    var numberIndexedToZero = Math.floor(startPosition / duration);

    for (var timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
      // To obtain the real number, adds the real number from the Period's start
      var realNumber = numberIndexedToZero + numberOffset;
      var realDuration = scaledEnd != null && timeFromPeriodStart + duration > scaledEnd ? scaledEnd - timeFromPeriodStart : duration;
      var realTime = timeFromPeriodStart + scaledStart;
      var manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;
      var detokenizedURLs = mediaURLs === null ? null : mediaURLs.map(createDashUrlDetokenizer(manifestTime, realNumber));
      var args = {
        id: String(realNumber),
        number: realNumber,
        time: realTime,
        isInit: false,
        duration: realDuration,
        timescale: timescale,
        mediaURLs: detokenizedURLs,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(args);
      numberIndexedToZero++;
    }

    return segments;
  }
  /**
   * Returns first possible position in the index, in seconds.
   * @returns {number|null|undefined}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    var firstSegmentStart = this._getFirstSegmentStart();

    if (firstSegmentStart == null) {
      return firstSegmentStart; // return undefined or null
    }

    return firstSegmentStart / this._index.timescale + this._periodStart;
  }
  /**
   * Returns last possible position in the index, in seconds.
   * @returns {number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var lastSegmentStart = this._getLastSegmentStart();

    if (lastSegmentStart == null) {
      // In that case (null or undefined), getLastPosition should reflect
      // the result of getLastSegmentStart, as the meaning is the same for
      // the two functions. So, we return the result of the latter.
      return lastSegmentStart;
    }

    var lastSegmentEnd = lastSegmentStart + this._index.duration;
    return lastSegmentEnd / this._index.timescale + this._periodStart;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * Returns `true` if the given segment should still be available as of now
   * (not removed since and still request-able).
   * Returns `false` if that's not the case.
   * Returns `undefined` if we do not know whether that's the case or not.
   * @param {Object} segment
   * @returns {boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    if (segment.timescale !== this._index.timescale) {
      return undefined;
    }

    var timescale = segment.timescale;
    var timeRelativeToPeriodStart = segment.time - this._periodStart * timescale;

    var firstSegmentStart = this._getFirstSegmentStart();

    var lastSegmentStart = this._getLastSegmentStart();

    if (firstSegmentStart === undefined || lastSegmentStart === undefined) {
      return undefined;
    }

    if (firstSegmentStart === null || lastSegmentStart === null) {
      return false;
    }

    if (timeRelativeToPeriodStart < firstSegmentStart) {
      return false;
    }

    if (timeRelativeToPeriodStart > lastSegmentStart || segment.duration !== this._index.duration) {
      return false;
    }

    return timeRelativeToPeriodStart / this._index.duration % 1 === 0;
  }
  /**
   * SegmentTemplate without a SegmentTimeline should not be updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    if (!this._isDynamic) {
      return true;
    }

    if (this._relativePeriodEnd == null) {
      return false;
    }

    var timescale = this._index.timescale;

    var lastSegmentStart = this._getLastSegmentStart(); // As last segment start is null if live time is before
    // current period, consider the index not to be finished.


    if (lastSegmentStart == null) {
      return false;
    }

    var lastSegmentEnd = lastSegmentStart + this._index.duration; // (1 / 60 for possible rounding errors)

    var roundingError = 1 / 60 * timescale;
    return lastSegmentEnd + roundingError >= this._relativePeriodEnd * timescale;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return true;
  }
  /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */
  ;

  _proto._addSegments = function _addSegments() {
    log["a" /* default */].warn("Tried to add Segments to a template RepresentationIndex");
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
    this._aggressiveMode = newIndex._aggressiveMode;
    this._isDynamic = newIndex._isDynamic;
    this._periodStart = newIndex._periodStart;
    this._relativePeriodEnd = newIndex._relativePeriodEnd;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update(newIndex) {
    // As segments are not declared individually, as long as this Representation
    // is present, we have every information we need
    this._replace(newIndex);
  }
  /**
   * Returns the timescaled start of the first segment that should be available,
   * relatively to the start of the Period.
   * @returns {number | null | undefined}
   */
  ;

  _proto._getFirstSegmentStart = function _getFirstSegmentStart() {
    if (!this._isDynamic) {
      return 0; // it is the start of the Period
    } // 1 - check that this index is already available


    if (this._relativePeriodEnd === 0 || this._relativePeriodEnd == null) {
      // /!\ The scaled max position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.
      var maximumBound = this._manifestBoundsCalculator.getMaximumBound();

      if (maximumBound !== undefined && maximumBound < this._periodStart) {
        // Maximum position is before this period.
        // No segment is yet available here
        return null;
      }
    }

    var _this$_index = this._index,
        duration = _this$_index.duration,
        timescale = _this$_index.timescale;

    var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

    if (firstPosition === undefined) {
      return undefined;
    }

    var segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
    var numberIndexedToZero = Math.floor(segmentTime / duration);
    return numberIndexedToZero * duration;
  }
  /**
   * Returns the timescaled start of the last segment that should be available,
   * relatively to the start of the Period.
   * Returns null if live time is before current period.
   * @returns {number|null|undefined}
   */
  ;

  _proto._getLastSegmentStart = function _getLastSegmentStart() {
    var _this$_index2 = this._index,
        duration = _this$_index2.duration,
        timescale = _this$_index2.timescale;

    if (this._isDynamic) {
      var lastPos = this._manifestBoundsCalculator.getMaximumBound();

      if (lastPos === undefined) {
        return undefined;
      }

      var agressiveModeOffset = this._aggressiveMode ? duration / timescale : 0;

      if (this._relativePeriodEnd != null && this._relativePeriodEnd < lastPos + agressiveModeOffset - this._periodStart) {
        var scaledRelativePeriodEnd = this._relativePeriodEnd * timescale;

        if (scaledRelativePeriodEnd < duration) {
          return null;
        }

        return (Math.floor(scaledRelativePeriodEnd / duration) - 1) * duration;
      } // /!\ The scaled last position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.


      var scaledLastPosition = (lastPos - this._periodStart) * timescale; // Maximum position is before this period.
      // No segment is yet available here

      if (scaledLastPosition < 0) {
        return null;
      }

      var availabilityTimeOffset = ((this._availabilityTimeOffset !== undefined ? this._availabilityTimeOffset : 0) + agressiveModeOffset) * timescale;
      var numberOfSegmentsAvailable = Math.floor((scaledLastPosition + availabilityTimeOffset) / duration);
      return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
    } else {
      var maximumTime = (this._relativePeriodEnd === undefined ? 0 : this._relativePeriodEnd) * timescale;
      var numberIndexedToZero = Math.ceil(maximumTime / duration) - 1;
      var regularLastSegmentStart = numberIndexedToZero * duration; // In some SegmentTemplate, we could think that there is one more
      // segment that there actually is due to a very little difference between
      // the period's duration and a multiple of a segment's duration.
      // Check that we're within a good margin

      var minimumDuration = MINIMUM_SEGMENT_SIZE * timescale;

      if (maximumTime - regularLastSegmentStart > minimumDuration || numberIndexedToZero === 0) {
        return regularLastSegmentStart;
      }

      return (numberIndexedToZero - 1) * duration;
    }
  };

  return TemplateRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/resolve_base_urls.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Array.<string>} currentBaseURLs
 * @param {Array.<Object>} newBaseURLs
 * @returns {Array.<string>}
 */

function resolveBaseURLs(currentBaseURLs, newBaseURLs) {
  var result = [];

  if (newBaseURLs.length === 0) {
    return currentBaseURLs;
  } else if (currentBaseURLs.length === 0) {
    for (var i = 0; i < newBaseURLs.length; i++) {
      if (!Object(array_includes["a" /* default */])(result, newBaseURLs[i].value)) {
        result.push(newBaseURLs[i].value);
      }
    }

    return result;
  } else {
    for (var _i = 0; _i < currentBaseURLs.length; _i++) {
      var rootURL = currentBaseURLs[_i];

      for (var j = 0; j < newBaseURLs.length; j++) {
        var newURL = Object(resolve_url["a" /* default */])(rootURL, newBaseURLs[j].value);

        if (!Object(array_includes["a" /* default */])(result, newURL)) {
          result.push(newURL);
        }
      }
    }
  }

  return result;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Parse the specific segment indexing information found in a representation
 * into a IRepresentationIndex implementation.
 * @param {Array.<Object>} representation
 * @param {Object} representationInfos
 * @returns {Array.<Object>}
 */

function parseRepresentationIndex(representation, representationInfos) {
  var _a, _b;

  var representationBaseURLs = resolveBaseURLs(representationInfos.baseURLs, representation.children.baseURLs);
  var aggressiveMode = representationInfos.aggressiveMode,
      availabilityTimeOffset = representationInfos.availabilityTimeOffset,
      manifestBoundsCalculator = representationInfos.manifestBoundsCalculator,
      isDynamic = representationInfos.isDynamic,
      periodEnd = representationInfos.end,
      periodStart = representationInfos.start,
      receivedTime = representationInfos.receivedTime,
      timeShiftBufferDepth = representationInfos.timeShiftBufferDepth,
      unsafelyBaseOnPreviousRepresentation = representationInfos.unsafelyBaseOnPreviousRepresentation;
  var context = {
    aggressiveMode: aggressiveMode,
    availabilityTimeOffset: availabilityTimeOffset,
    unsafelyBaseOnPreviousRepresentation: unsafelyBaseOnPreviousRepresentation,
    manifestBoundsCalculator: manifestBoundsCalculator,
    isDynamic: isDynamic,
    periodEnd: periodEnd,
    periodStart: periodStart,
    receivedTime: receivedTime,
    representationBaseURLs: representationBaseURLs,
    representationBitrate: representation.attributes.bitrate,
    representationId: representation.attributes.id,
    timeShiftBufferDepth: timeShiftBufferDepth
  };
  var representationIndex;

  if (representation.children.segmentBase !== undefined) {
    var segmentBase = representation.children.segmentBase;
    context.availabilityTimeOffset = representationInfos.availabilityTimeOffset + extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) + ((_a = segmentBase.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
    representationIndex = new base_BaseRepresentationIndex(segmentBase, context);
  } else if (representation.children.segmentList !== undefined) {
    var segmentList = representation.children.segmentList;
    representationIndex = new list_ListRepresentationIndex(segmentList, context);
  } else if (representation.children.segmentTemplate !== undefined || representationInfos.parentSegmentTemplates.length > 0) {
    var segmentTemplates = representationInfos.parentSegmentTemplates.slice();
    var childSegmentTemplate = representation.children.segmentTemplate;

    if (childSegmentTemplate !== undefined) {
      segmentTemplates.push(childSegmentTemplate);
    }

    var segmentTemplate = object_assign["a" /* default */].apply(void 0, [{}].concat(segmentTemplates));
    context.availabilityTimeOffset = representationInfos.availabilityTimeOffset + extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) + ((_b = segmentTemplate.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0);
    var timelineParser = segmentTemplate.timelineParser;
    representationIndex = timelineParser !== undefined ? new indexes_timeline(segmentTemplate, timelineParser, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
  } else {
    var adaptationChildren = representationInfos.adaptation.children;

    if (adaptationChildren.segmentBase !== undefined) {
      var _segmentBase = adaptationChildren.segmentBase;
      representationIndex = new base_BaseRepresentationIndex(_segmentBase, context);
    } else if (adaptationChildren.segmentList !== undefined) {
      var _segmentList = adaptationChildren.segmentList;
      representationIndex = new list_ListRepresentationIndex(_segmentList, context);
    } else {
      representationIndex = new template_TemplateRepresentationIndex({
        duration: Number.MAX_VALUE,
        timescale: 1,
        startNumber: 0,
        initialization: {
          media: ""
        },
        media: ""
      }, context);
    }
  }

  return representationIndex;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representations.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Process intermediate representations to create final parsed representations.
 * @param {Array.<Object>} representationsIR
 * @param {Object} adaptationInfos
 * @returns {Array.<Object>}
 */

function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
  var _a, _b;

  var parsedRepresentations = [];

  var _loop = function _loop(representationIdx) {
    var representation = representationsIR[representationIdx]; // Compute Representation ID

    var representationID = representation.attributes.id != null ? representation.attributes.id : String(representation.attributes.bitrate) + (representation.attributes.height != null ? "-" + representation.attributes.height : "") + (representation.attributes.width != null ? "-" + representation.attributes.width : "") + (representation.attributes.mimeType != null ? "-" + representation.attributes.mimeType : "") + (representation.attributes.codecs != null ? "-" + representation.attributes.codecs : ""); // Avoid duplicate IDs

    while (parsedRepresentations.some(function (r) {
      return r.id === representationID;
    })) {
      representationID += "-dup";
    } // Retrieve previous version of the Representation, if one.


    var unsafelyBaseOnPreviousRepresentation = (_b = (_a = adaptationInfos.unsafelyBaseOnPreviousAdaptation) === null || _a === void 0 ? void 0 : _a.getRepresentation(representationID)) !== null && _b !== void 0 ? _b : null;
    var representationInfos = Object(object_assign["a" /* default */])({}, adaptationInfos, {
      unsafelyBaseOnPreviousRepresentation: unsafelyBaseOnPreviousRepresentation,
      adaptation: adaptation
    });
    var representationIndex = parseRepresentationIndex(representation, representationInfos); // Find bitrate

    var representationBitrate = void 0;

    if (representation.attributes.bitrate == null) {
      log["a" /* default */].warn("DASH: No usable bitrate found in the Representation.");
      representationBitrate = 0;
    } else {
      representationBitrate = representation.attributes.bitrate;
    } // Construct Representation Base


    var parsedRepresentation = {
      bitrate: representationBitrate,
      index: representationIndex,
      id: representationID
    }; // Add optional attributes

    var codecs = void 0;

    if (representation.attributes.codecs != null) {
      codecs = representation.attributes.codecs;
    } else if (adaptation.attributes.codecs != null) {
      codecs = adaptation.attributes.codecs;
    }

    if (codecs != null) {
      codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
      parsedRepresentation.codecs = codecs;
    }

    if (representation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = representation.attributes.frameRate;
    } else if (adaptation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = adaptation.attributes.frameRate;
    }

    if (representation.attributes.height != null) {
      parsedRepresentation.height = representation.attributes.height;
    } else if (adaptation.attributes.height != null) {
      parsedRepresentation.height = adaptation.attributes.height;
    }

    if (representation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = representation.attributes.mimeType;
    } else if (adaptation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = adaptation.attributes.mimeType;
    }

    if (representation.attributes.width != null) {
      parsedRepresentation.width = representation.attributes.width;
    } else if (adaptation.attributes.width != null) {
      parsedRepresentation.width = adaptation.attributes.width;
    }

    if (adaptation.children.contentProtections != null) {
      var contentProtections = adaptation.children.contentProtections.reduce(function (acc, cp) {
        var systemId;

        if (cp.attributes.schemeIdUri !== undefined && cp.attributes.schemeIdUri.substring(0, 9) === "urn:uuid:") {
          systemId = cp.attributes.schemeIdUri.substring(9).replace(/-/g, "").toLowerCase();
        }

        if (cp.attributes.keyId !== undefined && cp.attributes.keyId.length > 0) {
          acc.keyIds.push({
            keyId: cp.attributes.keyId,
            systemId: systemId
          });
        }

        if (systemId !== undefined) {
          var cencPssh = cp.children.cencPssh;

          for (var i = 0; i < cencPssh.length; i++) {
            var data = cencPssh[i];

            if (acc.initData.cenc === undefined) {
              acc.initData.cenc = [];
            }

            acc.initData.cenc.push({
              systemId: systemId,
              data: data
            });
          }
        }

        return acc;
      }, {
        keyIds: [],
        initData: {}
      });

      if (Object.keys(contentProtections.initData).length > 0 || contentProtections.keyIds.length > 0) {
        parsedRepresentation.contentProtections = contentProtections;
      }
    }

    parsedRepresentations.push(parsedRepresentation);
  };

  for (var representationIdx = 0; representationIdx < representationsIR.length; representationIdx++) {
    _loop(representationIdx);
  }

  return parsedRepresentations;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_adaptation_sets.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */

function isVisuallyImpaired(accessibility) {
  if (accessibility == null) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "1";
}
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */


function isHardOfHearing(accessibility) {
  if (accessibility == null) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "2";
}
/**
 * Detect if the accessibility given defines an AdaptationSet containing a sign
 * language interpretation.
 * Based on DASH-IF 4.3.
 * @param {Object} accessibility
 * @returns {Boolean}
 */


function hasSignLanguageInterpretation(accessibility) {
  if (accessibility == null) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" && accessibility.value === "sign";
}
/**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */


function getAdaptationID(adaptation, infos) {
  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.id)) {
    return adaptation.attributes.id;
  }

  var idString = infos.type;

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.language)) {
    idString += "-" + adaptation.attributes.language;
  }

  if (infos.isClosedCaption === true) {
    idString += "-cc";
  }

  if (infos.isAudioDescription === true) {
    idString += "-ad";
  }

  if (infos.isSignInterpreted === true) {
    idString += "-si";
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.contentType)) {
    idString += "-" + adaptation.attributes.contentType;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.codecs)) {
    idString += "-" + adaptation.attributes.codecs;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.mimeType)) {
    idString += "-" + adaptation.attributes.mimeType;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.frameRate)) {
    idString += "-" + adaptation.attributes.frameRate;
  }

  return idString;
}
/**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */


function getAdaptationSetSwitchingIDs(adaptation) {
  if (adaptation.children.supplementalProperties != null) {
    var supplementalProperties = adaptation.children.supplementalProperties;

    for (var j = 0; j < supplementalProperties.length; j++) {
      var supplementalProperty = supplementalProperties[j];

      if (supplementalProperty.schemeIdUri === "urn:mpeg:dash:adaptation-set-switching:2016" && supplementalProperty.value != null) {
        return supplementalProperty.value.split(",").map(function (id) {
          return id.trim();
        }).filter(function (id) {
          return id;
        });
      }
    }
  }

  return [];
}
/**
 * Process AdaptationSets intermediate representations to return under its final
 * form.
 * Note that the AdaptationSets returned are sorted by priority (from the most
 * priority to the least one).
 * @param {Array.<Object>} adaptationsIR
 * @param {Object} periodInfos
 * @returns {Array.<Object>}
 */


function parseAdaptationSets(adaptationsIR, periodInfos) {
  var _a, _b, _c, _d;

  var parsedAdaptations = {};
  var adaptationSwitchingInfos = {};
  var parsedAdaptationsIDs = [];
  var videoMainAdaptation = null; // first sort AdaptationSets by absolute priority.

  adaptationsIR.sort(function (a, b) {
    var _a, _b;
    /* As of DASH-IF 4.3, `1` is the default value. */


    var priority1 = (_a = a.attributes.selectionPriority) !== null && _a !== void 0 ? _a : 1;
    var priority2 = (_b = b.attributes.selectionPriority) !== null && _b !== void 0 ? _b : 1;
    return priority2 - priority1;
  });

  for (var i = 0; i < adaptationsIR.length; i++) {
    var adaptation = adaptationsIR[i];
    var adaptationChildren = adaptation.children;
    var essentialProperties = adaptationChildren.essentialProperties,
        roles = adaptationChildren.roles;
    var isExclusivelyTrickModeTrack = Array.isArray(essentialProperties) && essentialProperties.some(function (ep) {
      return ep.schemeIdUri === "http://dashif.org/guidelines/trickmode";
    });

    if (isExclusivelyTrickModeTrack) {
      // We do not for the moment parse trickmode tracks
      continue;
    }

    var isMainAdaptation = Array.isArray(roles) && roles.some(function (role) {
      return role.value === "main";
    }) && roles.some(function (role) {
      return role.schemeIdUri === "urn:mpeg:dash:role:2011";
    });
    var representationsIR = adaptation.children.representations;
    var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(adaptation.children.baseURLs) + periodInfos.availabilityTimeOffset;
    var adaptationMimeType = adaptation.attributes.mimeType;
    var adaptationCodecs = adaptation.attributes.codecs;
    var type = inferAdaptationType(representationsIR, Object(is_non_empty_string["a" /* default */])(adaptationMimeType) ? adaptationMimeType : null, Object(is_non_empty_string["a" /* default */])(adaptationCodecs) ? adaptationCodecs : null, adaptationChildren.roles != null ? adaptationChildren.roles : null);

    if (type === undefined) {
      continue;
    }

    var originalID = adaptation.attributes.id;
    var newID = void 0;
    var adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);
    var parentSegmentTemplates = [];

    if (periodInfos.segmentTemplate !== undefined) {
      parentSegmentTemplates.push(periodInfos.segmentTemplate);
    }

    if (adaptation.children.segmentTemplate !== undefined) {
      parentSegmentTemplates.push(adaptation.children.segmentTemplate);
    }

    var adaptationInfos = {
      aggressiveMode: periodInfos.aggressiveMode,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: resolveBaseURLs(periodInfos.baseURLs, adaptationChildren.baseURLs),
      manifestBoundsCalculator: periodInfos.manifestBoundsCalculator,
      end: periodInfos.end,
      isDynamic: periodInfos.isDynamic,
      parentSegmentTemplates: parentSegmentTemplates,
      receivedTime: periodInfos.receivedTime,
      start: periodInfos.start,
      timeShiftBufferDepth: periodInfos.timeShiftBufferDepth,
      unsafelyBaseOnPreviousAdaptation: null
    };

    if (type === "video" && videoMainAdaptation !== null && isMainAdaptation) {
      var _videoMainAdaptation$;

      adaptationInfos.unsafelyBaseOnPreviousAdaptation = (_b = (_a = periodInfos.unsafelyBaseOnPreviousPeriod) === null || _a === void 0 ? void 0 : _a.getAdaptation(videoMainAdaptation.id)) !== null && _b !== void 0 ? _b : null;
      var representations = parseRepresentations(representationsIR, adaptation, adaptationInfos);

      (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, representations);

      newID = videoMainAdaptation.id;
    } else {
      var accessibility = adaptationChildren.accessibility;
      var isDub = void 0;

      if (roles !== undefined && roles.some(function (role) {
        return role.value === "dub";
      })) {
        isDub = true;
      }

      var isClosedCaption = type === "text" && accessibility != null && isHardOfHearing(accessibility) ? true : undefined;
      var isAudioDescription = type === "audio" && accessibility != null && isVisuallyImpaired(accessibility) ? true : undefined;
      var isSignInterpreted = type === "video" && accessibility != null && hasSignLanguageInterpretation(accessibility) ? true : undefined;
      var adaptationID = getAdaptationID(adaptation, {
        isAudioDescription: isAudioDescription,
        isClosedCaption: isClosedCaption,
        isSignInterpreted: isSignInterpreted,
        type: type
      }); // Avoid duplicate IDs

      while (Object(array_includes["a" /* default */])(parsedAdaptationsIDs, adaptationID)) {
        adaptationID += "-dup";
      }

      newID = adaptationID;
      parsedAdaptationsIDs.push(adaptationID);
      adaptationInfos.unsafelyBaseOnPreviousAdaptation = (_d = (_c = periodInfos.unsafelyBaseOnPreviousPeriod) === null || _c === void 0 ? void 0 : _c.getAdaptation(adaptationID)) !== null && _d !== void 0 ? _d : null;

      var _representations = parseRepresentations(representationsIR, adaptation, adaptationInfos);

      var parsedAdaptationSet = {
        id: adaptationID,
        representations: _representations,
        type: type
      };

      if (adaptation.attributes.language != null) {
        parsedAdaptationSet.language = adaptation.attributes.language;
      }

      if (isClosedCaption != null) {
        parsedAdaptationSet.closedCaption = isClosedCaption;
      }

      if (isAudioDescription != null) {
        parsedAdaptationSet.audioDescription = isAudioDescription;
      }

      if (isDub === true) {
        parsedAdaptationSet.isDub = true;
      }

      if (isSignInterpreted === true) {
        parsedAdaptationSet.isSignInterpreted = true;
      }

      var adaptationsOfTheSameType = parsedAdaptations[type];

      if (adaptationsOfTheSameType === undefined) {
        parsedAdaptations[type] = [parsedAdaptationSet];

        if (isMainAdaptation && type === "video") {
          videoMainAdaptation = parsedAdaptationSet;
        }
      } else {
        var mergedInto = null; // look if we have to merge this into another Adaptation

        var _loop = function _loop(k) {
          var id = adaptationSetSwitchingIDs[k];
          var switchingInfos = adaptationSwitchingInfos[id];

          if (switchingInfos != null && switchingInfos.newID !== newID && Object(array_includes["a" /* default */])(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
            var adaptationToMergeInto = Object(array_find["a" /* default */])(adaptationsOfTheSameType, function (a) {
              return a.id === id;
            });

            if (adaptationToMergeInto != null && adaptationToMergeInto.audioDescription === parsedAdaptationSet.audioDescription && adaptationToMergeInto.closedCaption === parsedAdaptationSet.closedCaption && adaptationToMergeInto.language === parsedAdaptationSet.language) {
              var _adaptationToMergeInt;

              log["a" /* default */].info("DASH Parser: merging \"switchable\" AdaptationSets", originalID, id);

              (_adaptationToMergeInt = adaptationToMergeInto.representations).push.apply(_adaptationToMergeInt, parsedAdaptationSet.representations);

              mergedInto = adaptationToMergeInto;
            }
          }
        };

        for (var k = 0; k < adaptationSetSwitchingIDs.length; k++) {
          _loop(k);
        }

        if (isMainAdaptation && type === "video") {
          if (mergedInto == null) {
            // put "main" adaptation as the first
            adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            videoMainAdaptation = parsedAdaptationSet;
          } else {
            // put the resulting adaptation first instead
            var indexOf = adaptationsOfTheSameType.indexOf(mergedInto);

            if (indexOf < 0) {
              adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            } else if (indexOf !== 0) {
              adaptationsOfTheSameType.splice(indexOf, 1);
              adaptationsOfTheSameType.unshift(mergedInto);
            }

            videoMainAdaptation = mergedInto;
          }
        } else if (mergedInto === null) {
          adaptationsOfTheSameType.push(parsedAdaptationSet);
        }
      }
    }

    if (originalID != null && adaptationSwitchingInfos[originalID] == null) {
      adaptationSwitchingInfos[originalID] = {
        newID: newID,
        adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
      };
    }
  }

  return parsedAdaptations;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var generatePeriodID = Object(id_generator["a" /* default */])();
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} contextInfos
 * @returns {Array.<Object>}
 */

function parsePeriods(periodsIR, contextInfos) {
  var _a, _b, _c;

  var parsedPeriods = [];
  var periodsTimeInformation = getPeriodsTimeInformation(periodsIR, contextInfos);

  if (periodsTimeInformation.length !== periodsIR.length) {
    throw new Error("MPD parsing error: the time information are incoherent.");
  }

  var isDynamic = contextInfos.isDynamic,
      timeShiftBufferDepth = contextInfos.timeShiftBufferDepth;
  var manifestBoundsCalculator = new ManifestBoundsCalculator({
    isDynamic: isDynamic,
    timeShiftBufferDepth: timeShiftBufferDepth
  });

  if (!isDynamic && contextInfos.duration != null) {
    manifestBoundsCalculator.setLastPosition(contextInfos.duration);
  } // We parse it in reverse because we might need to deduce the buffer depth from
  // the last Periods' indexes


  var _loop = function _loop(i) {
    var periodIR = periodsIR[i];
    var xlinkInfos = contextInfos.xlinkInfos.get(periodIR);
    var periodBaseURLs = resolveBaseURLs(contextInfos.baseURLs, periodIR.children.baseURLs);
    var _periodsTimeInformati = periodsTimeInformation[i],
        periodStart = _periodsTimeInformati.periodStart,
        periodDuration = _periodsTimeInformati.periodDuration,
        periodEnd = _periodsTimeInformati.periodEnd;
    var periodID = void 0;

    if (periodIR.attributes.id == null) {
      log["a" /* default */].warn("DASH: No usable id found in the Period. Generating one.");
      periodID = "gen-dash-period-" + generatePeriodID();
    } else {
      periodID = periodIR.attributes.id;
    } // Avoid duplicate IDs


    while (parsedPeriods.some(function (p) {
      return p.id === periodID;
    })) {
      periodID += "-dup";
    }

    var receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime : contextInfos.receivedTime;
    var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(periodIR.children.baseURLs) + contextInfos.availabilityTimeOffset;
    var unsafelyBaseOnPreviousPeriod = (_b = (_a = contextInfos.unsafelyBaseOnPreviousManifest) === null || _a === void 0 ? void 0 : _a.getPeriod(periodID)) !== null && _b !== void 0 ? _b : null;
    var periodInfos = {
      aggressiveMode: contextInfos.aggressiveMode,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: periodBaseURLs,
      manifestBoundsCalculator: manifestBoundsCalculator,
      end: periodEnd,
      isDynamic: isDynamic,
      receivedTime: receivedTime,
      segmentTemplate: periodIR.children.segmentTemplate,
      start: periodStart,
      timeShiftBufferDepth: timeShiftBufferDepth,
      unsafelyBaseOnPreviousPeriod: unsafelyBaseOnPreviousPeriod
    };
    var adaptations = parseAdaptationSets(periodIR.children.adaptations, periodInfos);
    var streamEvents = (_c = periodIR.children.streamEvents) === null || _c === void 0 ? void 0 : _c.map(function (event) {
      var _a;

      var start = ((_a = event.eventPresentationTime) !== null && _a !== void 0 ? _a : 0) / event.timescale + periodStart;
      var end = event.duration !== undefined ? start + event.duration / event.timescale : undefined;
      return {
        start: start,
        end: end,
        data: event.data,
        id: event.id
      };
    });
    var parsedPeriod = {
      id: periodID,
      start: periodStart,
      end: periodEnd,
      duration: periodDuration,
      adaptations: adaptations,
      streamEvents: streamEvents
    };
    parsedPeriods.unshift(parsedPeriod);

    if (!manifestBoundsCalculator.lastPositionIsKnown()) {
      var _lastPosition = getMaximumLastPosition(adaptations);

      if (!isDynamic) {
        if (typeof _lastPosition === "number") {
          manifestBoundsCalculator.setLastPosition(_lastPosition);
        }
      } else {
        if (typeof _lastPosition === "number") {
          var _positionTime = performance.now() / 1000;

          manifestBoundsCalculator.setLastPosition(_lastPosition, _positionTime);
        } else {
          var _guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, periodStart);

          if (_guessedLastPositionFromClock !== undefined) {
            var guessedLastPosition = _guessedLastPositionFromClock[0],
                guessedPositionTime = _guessedLastPositionFromClock[1];
            manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
          }
        }
      }
    }
  };

  for (var i = periodsIR.length - 1; i >= 0; i--) {
    _loop(i);
  }

  if (contextInfos.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
    // Guess a last time the last position
    var guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, 0);

    if (guessedLastPositionFromClock !== undefined) {
      var lastPosition = guessedLastPositionFromClock[0],
          positionTime = guessedLastPositionFromClock[1];
      manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
    }
  }

  return flattenOverlappingPeriods(parsedPeriods);
}
/**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "current" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the current time
 * is in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the current time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} contextInfos
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */

function guessLastPositionFromClock(contextInfos, minimumTime) {
  if (contextInfos.clockOffset != null) {
    var lastPosition = contextInfos.clockOffset / 1000 - contextInfos.availabilityStartTime;
    var positionTime = performance.now() / 1000;
    var timeInSec = positionTime + lastPosition;

    if (timeInSec >= minimumTime) {
      return [timeInSec, positionTime];
    }
  } else {
    var now = Date.now() / 1000;

    if (now >= minimumTime) {
      log["a" /* default */].warn("DASH Parser: no clock synchronization mechanism found." + " Using the system clock instead.");

      var _lastPosition2 = now - contextInfos.availabilityStartTime;

      var _positionTime2 = performance.now() / 1000;

      return [_lastPosition2, _positionTime2];
    }
  }

  return undefined;
}
/**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */


function getMaximumLastPosition(adaptationsPerType) {
  var maxEncounteredPosition = null;
  var allIndexAreEmpty = true;
  var adaptationsVal = Object(object_values["a" /* default */])(adaptationsPerType).filter(function (ada) {
    return ada != null;
  });
  var allAdaptations = Object(flat_map["a" /* default */])(adaptationsVal, function (adaptationsForType) {
    return adaptationsForType;
  });

  for (var adapIndex = 0; adapIndex < allAdaptations.length; adapIndex++) {
    var representations = allAdaptations[adapIndex].representations;

    for (var repIndex = 0; repIndex < representations.length; repIndex++) {
      var representation = representations[repIndex];
      var position = representation.index.getLastPosition();

      if (position !== null) {
        allIndexAreEmpty = false;

        if (typeof position === "number") {
          maxEncounteredPosition = maxEncounteredPosition == null ? position : Math.max(maxEncounteredPosition, position);
        }
      }
    }
  }

  if (maxEncounteredPosition != null) {
    return maxEncounteredPosition;
  } else if (allIndexAreEmpty) {
    return null;
  }

  return undefined;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_mpd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 = config["a" /* default */].DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0;
/**
 * @param {Element} root - The MPD root.
 * @param {Object} args
 * @returns {Object}
 */

function parseMPD(root, args) {
  // Transform whole MPD into a parsed JS object representation
  var _createMPDIntermediat = createMPDIntermediateRepresentation(root),
      mpdIR = _createMPDIntermediat[0],
      warnings = _createMPDIntermediat[1];

  return loadExternalRessourcesAndParse(mpdIR, args, warnings);
}
/**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {Array.<Object>} warnings
 * @returns {Object}
 */

function loadExternalRessourcesAndParse(mpdIR, args, warnings, hasLoadedClock) {
  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var xlinkInfos = new WeakMap();

  if (args.externalClockOffset == null) {
    var isDynamic = rootAttributes.type === "dynamic";
    var directTiming = Object(array_find["a" /* default */])(rootChildren.utcTimings, function (utcTiming) {
      return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" && utcTiming.value != null;
    });
    var clockOffsetFromDirectUTCTiming = directTiming != null && directTiming.value != null ? getClockOffset(directTiming.value) : undefined;
    var clockOffset = clockOffsetFromDirectUTCTiming != null && !isNaN(clockOffsetFromDirectUTCTiming) ? clockOffsetFromDirectUTCTiming : undefined;

    if (clockOffset != null) {
      args.externalClockOffset = clockOffset;
    } else if (isDynamic && hasLoadedClock !== true) {
      var UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);

      if (UTCTimingHTTPURL != null && UTCTimingHTTPURL.length > 0) {
        // TODO fetch UTCTiming and XLinks at the same time
        return {
          type: "needs-ressources",
          value: {
            ressources: [UTCTimingHTTPURL],
            "continue": function continueParsingMPD(loadedRessources) {
              if (loadedRessources.length !== 1) {
                throw new Error("DASH parser: wrong number of loaded ressources.");
              }

              clockOffset = getClockOffset(loadedRessources[0].responseData);
              args.externalClockOffset = clockOffset;
              return loadExternalRessourcesAndParse(mpdIR, args, warnings, true);
            }
          }
        };
      }
    }
  }

  var xlinksToLoad = [];

  for (var i = 0; i < rootChildren.periods.length; i++) {
    var _rootChildren$periods = rootChildren.periods[i].attributes,
        xlinkHref = _rootChildren$periods.xlinkHref,
        xlinkActuate = _rootChildren$periods.xlinkActuate;

    if (xlinkHref != null && xlinkActuate === "onLoad") {
      xlinksToLoad.push({
        index: i,
        ressource: xlinkHref
      });
    }
  }

  if (xlinksToLoad.length === 0) {
    return parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos);
  }

  return {
    type: "needs-ressources",
    value: {
      ressources: xlinksToLoad.map(function (_ref) {
        var ressource = _ref.ressource;
        return ressource;
      }),
      "continue": function continueParsingMPD(loadedRessources) {
        if (loadedRessources.length !== xlinksToLoad.length) {
          throw new Error("DASH parser: wrong number of loaded ressources.");
        } // Note: It is important to go from the last index to the first index in
        // the resulting array, as we will potentially add elements to the array


        for (var _i = loadedRessources.length - 1; _i >= 0; _i--) {
          var _rootChildren$periods2;

          var index = xlinksToLoad[_i].index;
          var _loadedRessources$_i = loadedRessources[_i],
              xlinkData = _loadedRessources$_i.responseData,
              receivedTime = _loadedRessources$_i.receivedTime,
              sendingTime = _loadedRessources$_i.sendingTime,
              url = _loadedRessources$_i.url;
          var wrappedData = "<root>" + xlinkData + "</root>";
          var dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");

          if (dataAsXML == null || dataAsXML.children.length === 0) {
            throw new Error("DASH parser: Invalid external ressources");
          }

          var periods = dataAsXML.children[0].children;
          var periodsIR = [];

          for (var j = 0; j < periods.length; j++) {
            if (periods[j].nodeType === Node.ELEMENT_NODE) {
              var _createPeriodIntermed = createPeriodIntermediateRepresentation(periods[j]),
                  periodIR = _createPeriodIntermed[0],
                  periodWarnings = _createPeriodIntermed[1];

              xlinkInfos.set(periodIR, {
                receivedTime: receivedTime,
                sendingTime: sendingTime,
                url: url
              });
              periodsIR.push(periodIR);

              if (periodWarnings.length > 0) {
                warnings.push.apply(warnings, periodWarnings);
              }
            }
          } // replace original "xlinked" periods by the real deal


          (_rootChildren$periods2 = rootChildren.periods).splice.apply(_rootChildren$periods2, [index, 1].concat(periodsIR));
        }

        return loadExternalRessourcesAndParse(mpdIR, args, warnings);
      }
    }
  };
}
/**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {Array.<Object>} warnings
 * @param {Object} xlinkInfos
 * @returns {Object}
 */


function parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos) {
  var _a, _b;

  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var isDynamic = rootAttributes.type === "dynamic";
  var baseURLs = resolveBaseURLs(args.url === undefined ? [] : [Object(resolve_url["b" /* normalizeBaseURL */])(args.url)], rootChildren.baseURLs);
  var availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime);
  var timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
  var clockOffset = args.externalClockOffset,
      unsafelyBaseOnPreviousManifest = args.unsafelyBaseOnPreviousManifest;
  var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(rootChildren.baseURLs);
  var manifestInfos = {
    aggressiveMode: args.aggressiveMode,
    availabilityStartTime: availabilityStartTime,
    availabilityTimeOffset: availabilityTimeOffset,
    baseURLs: baseURLs,
    clockOffset: clockOffset,
    duration: rootAttributes.duration,
    isDynamic: isDynamic,
    receivedTime: args.manifestReceivedTime,
    timeShiftBufferDepth: timeShiftBufferDepth,
    unsafelyBaseOnPreviousManifest: unsafelyBaseOnPreviousManifest,
    xlinkInfos: xlinkInfos
  };
  var parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);
  var mediaPresentationDuration = rootAttributes.duration;
  var parsedMPD = {
    availabilityStartTime: availabilityStartTime,
    clockOffset: args.externalClockOffset,
    isDynamic: isDynamic,
    isLive: isDynamic,
    periods: parsedPeriods,
    suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
    transportType: "dash",
    uris: args.url == null ? rootChildren.locations : [args.url].concat(rootChildren.locations)
  }; // -- add optional fields --

  if (rootAttributes.minimumUpdatePeriod !== undefined && rootAttributes.minimumUpdatePeriod >= 0) {
    parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod === 0 ? DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 : rootAttributes.minimumUpdatePeriod;
  }

  var _getMinimumAndMaximum = getMinimumAndMaximumPosition(parsedMPD),
      minTime = _getMinimumAndMaximum[0],
      maxTime = _getMinimumAndMaximum[1];

  var now = performance.now();

  if (!isDynamic) {
    if (minTime !== undefined) {
      parsedMPD.minimumTime = {
        isContinuous: false,
        value: minTime,
        time: now
      };
    } else if (((_a = parsedPeriods[0]) === null || _a === void 0 ? void 0 : _a.start) !== undefined) {
      parsedMPD.minimumTime = {
        isContinuous: false,
        value: parsedPeriods[0].start,
        time: now
      };
    }

    if (maxTime !== undefined) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: maxTime,
        time: now
      };
    } else if (mediaPresentationDuration !== undefined) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: mediaPresentationDuration,
        time: now
      };
    } else if (parsedPeriods[parsedPeriods.length - 1] !== undefined) {
      var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
      var end = (_b = lastPeriod.end) !== null && _b !== void 0 ? _b : lastPeriod.duration !== undefined ? lastPeriod.start + lastPeriod.duration : undefined;

      if (end !== undefined) {
        parsedMPD.maximumTime = {
          isContinuous: false,
          value: end,
          time: now
        };
      }
    }
  } else {
    if (minTime != null) {
      parsedMPD.minimumTime = {
        isContinuous: timeShiftBufferDepth != null,
        value: minTime,
        time: now
      };
    }

    if (maxTime != null) {
      parsedMPD.maximumTime = {
        isContinuous: true,
        value: maxTime,
        time: now
      };

      if (minTime == null) {
        parsedMPD.minimumTime = {
          isContinuous: true,
          value: maxTime,
          time: now
        };
      }
    }
  }

  return {
    type: "done",
    value: {
      parsed: parsedMPD,
      warnings: warnings
    }
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_from_document.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Object} args
 * @returns {Object} - parsed manifest
 */

function parseFromDocument(document, args) {
  var root = document.documentElement;

  if (root == null || root.nodeName !== "MPD") {
    throw new Error("DASH Parser: document root should be MPD");
  }

  return parseMPD(root, args);
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var dash = (parseFromDocument);
// EXTERNAL MODULE: ./src/transports/utils/return_parsed_manifest.ts
var return_parsed_manifest = __webpack_require__(126);

// CONCATENATED MODULE: ./src/transports/dash/manifest_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */

function requestStringResource(url) {
  return Object(request["a" /* default */])({
    url: url,
    responseType: "text"
  }).pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "data-loaded";
  }), Object(map["a" /* map */])(function (e) {
    return e.value;
  }));
}
/**
 * @param {Object} options
 * @returns {Function}
 */


function generateManifestParser(options) {
  var aggressiveMode = options.aggressiveMode,
      referenceDateTime = options.referenceDateTime;
  var serverTimeOffset = options.serverSyncInfos !== undefined ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : undefined;
  return function manifestParser(args) {
    var _a;

    var response = args.response,
        scheduleRequest = args.scheduleRequest;
    var argClockOffset = args.externalClockOffset;
    var loaderURL = args.url;
    var url = (_a = response.url) !== null && _a !== void 0 ? _a : loaderURL;
    var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : // TODO find a way to check if Document?
    response.responseData;
    var externalClockOffset = serverTimeOffset !== null && serverTimeOffset !== void 0 ? serverTimeOffset : argClockOffset;
    var unsafelyBaseOnPreviousManifest = args.unsafeMode ? args.previousManifest : null;
    var parsedManifest = dash(data, {
      aggressiveMode: aggressiveMode === true,
      unsafelyBaseOnPreviousManifest: unsafelyBaseOnPreviousManifest,
      url: url,
      referenceDateTime: referenceDateTime,
      externalClockOffset: externalClockOffset
    });
    return loadExternalResources(parsedManifest);

    function loadExternalResources(parserResponse) {
      if (parserResponse.type === "done") {
        var _parserResponse$value = parserResponse.value,
            warnings = _parserResponse$value.warnings,
            parsed = _parserResponse$value.parsed;
        var warningEvents = warnings.map(function (warning) {
          return {
            type: "warning",
            value: warning
          };
        });
        var manifest = new src_manifest["a" /* default */](parsed, options);
        return Object(concat["a" /* concat */])(of["a" /* of */].apply(void 0, warningEvents), Object(return_parsed_manifest["a" /* default */])(manifest, url));
      }

      var _parserResponse$value2 = parserResponse.value,
          ressources = _parserResponse$value2.ressources,
          continueParsing = _parserResponse$value2["continue"];
      var externalResources$ = ressources.map(function (resource) {
        return scheduleRequest(function () {
          return requestStringResource(resource);
        });
      });
      return Object(combineLatest["a" /* combineLatest */])(externalResources$).pipe(Object(mergeMap["a" /* mergeMap */])(function (loadedResources) {
        var resources = [];

        for (var i = 0; i < loadedResources.length; i++) {
          var resource = loadedResources[i];

          if (typeof resource.responseData !== "string") {
            throw new Error("External DASH resources should only be strings");
          } // Normally not needed but TypeScript is just dumb here


          resources.push(Object(object_assign["a" /* default */])(resource, {
            responseData: resource.responseData
          }));
        }

        return loadExternalResources(continueParsing(resources));
      }));
    }
  };
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/utils/request/fetch.ts
var fetch = __webpack_require__(96);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(21);

// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(50);

// CONCATENATED MODULE: ./src/transports/utils/is_webm_embedded_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} representation
 * @returns {boolean}
 */
function isWEBMEmbeddedTrack(representation) {
  return representation.mimeType === "video/webm" || representation.mimeType === "audio/webm";
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(158);

// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(101);

// CONCATENATED MODULE: ./src/transports/dash/add_segment_integrity_checks_to_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function addSegmentIntegrityChecks(segmentLoader) {
  return function (content) {
    return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (res) {
      if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null && typeof res.value.responseData !== "string" && !isWEBMEmbeddedTrack(content.representation)) {
        Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), content.segment.isInit);
      }
    }));
  };
}
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// CONCATENATED MODULE: ./src/transports/dash/init_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} content
 */

function initSegmentLoader(url, _ref) {
  var segment = _ref.segment;

  if (segment.range === undefined) {
    return Object(request["a" /* default */])({
      url: url,
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  if (segment.indexRange === undefined) {
    return Object(request["a" /* default */])({
      url: url,
      headers: {
        Range: Object(byte_range["a" /* default */])(segment.range)
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  } // range and indexRange are contiguous (99% of the cases)


  if (segment.range[1] + 1 === segment.indexRange[0]) {
    return Object(request["a" /* default */])({
      url: url,
      headers: {
        Range: Object(byte_range["a" /* default */])([segment.range[0], segment.indexRange[1]])
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  var rangeRequest$ = Object(request["a" /* default */])({
    url: url,
    headers: {
      Range: Object(byte_range["a" /* default */])(segment.range)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  var indexRequest$ = Object(request["a" /* default */])({
    url: url,
    headers: {
      Range: Object(byte_range["a" /* default */])(segment.indexRange)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  return Object(combineLatest["a" /* combineLatest */])([rangeRequest$, indexRequest$]).pipe(Object(map["a" /* map */])(function (_ref2) {
    var initData = _ref2[0],
        indexData = _ref2[1];
    var data = Object(byte_parsing["e" /* concat */])(new Uint8Array(initData.value.responseData), new Uint8Array(indexData.value.responseData));
    var sendingTime = Math.min(initData.value.sendingTime, indexData.value.sendingTime);
    var receivedTime = Math.max(initData.value.receivedTime, indexData.value.receivedTime);
    return {
      type: "data-loaded",
      value: {
        url: url,
        responseData: data,
        size: initData.value.size + indexData.value.size,
        duration: receivedTime - sendingTime,
        sendingTime: sendingTime,
        receivedTime: receivedTime
      }
    };
  }));
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(240);

// EXTERNAL MODULE: ./src/transports/utils/find_complete_box.ts
var find_complete_box = __webpack_require__(80);

// CONCATENATED MODULE: ./src/transports/dash/extract_complete_chunks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */

function extractCompleteChunks(buffer) {
  var _position = 0;
  var chunks = [];

  while (_position < buffer.length) {
    var currentBuffer = buffer.subarray(_position, Infinity);
    var moofIndex = Object(find_complete_box["a" /* default */])(currentBuffer, 0x6D6F6F66
    /* moof */
    );

    if (moofIndex < 0) {
      // no moof, not a segment.
      return [chunks, currentBuffer];
    }

    var moofLen = Object(byte_parsing["c" /* be4toi */])(buffer, moofIndex + _position);
    var moofEnd = _position + moofIndex + moofLen;

    if (moofEnd > buffer.length) {
      // not a complete moof segment
      return [chunks, currentBuffer];
    }

    var mdatIndex = Object(find_complete_box["a" /* default */])(currentBuffer, 0x6D646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      // no mdat, not a segment.
      return [chunks, currentBuffer];
    }

    var mdatLen = Object(byte_parsing["c" /* be4toi */])(buffer, mdatIndex + _position);
    var mdatEnd = _position + mdatIndex + mdatLen;

    if (mdatEnd > buffer.length) {
      // not a complete mdat segment
      return [chunks, currentBuffer];
    }

    var maxEnd = Math.max(moofEnd, mdatEnd);
    var chunk = buffer.subarray(_position, maxEnd);
    chunks.push(chunk);
    _position = maxEnd;
  }

  return [chunks, null];
}
// CONCATENATED MODULE: ./src/transports/dash/low_latency_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







function lowLatencySegmentLoader(url, args) {
  var segment = args.segment;
  var headers = segment.range !== undefined ? {
    Range: Object(byte_range["a" /* default */])(segment.range)
  } : undefined;
  return Object(fetch["a" /* default */])({
    url: url,
    headers: headers
  }).pipe(Object(scan["a" /* scan */])(function (acc, evt) {
    if (evt.type === "data-complete") {
      if (acc.partialChunk !== null) {
        log["a" /* default */].warn("DASH Pipelines: remaining chunk does not belong to any segment");
      }

      return {
        event: evt,
        completeChunks: [],
        partialChunk: null
      };
    }

    var data = new Uint8Array(evt.value.chunk);
    var concatenated = acc.partialChunk !== null ? Object(byte_parsing["e" /* concat */])(acc.partialChunk, data) : data;

    var _extractCompleteChunk = extractCompleteChunks(concatenated),
        completeChunks = _extractCompleteChunk[0],
        partialChunk = _extractCompleteChunk[1];

    return {
      event: evt,
      completeChunks: completeChunks,
      partialChunk: partialChunk
    };
  }, {
    event: null,
    completeChunks: [],
    partialChunk: null
  }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
    var emitted = [];

    for (var i = 0; i < evt.completeChunks.length; i++) {
      emitted.push({
        type: "data-chunk",
        value: {
          responseData: evt.completeChunks[i]
        }
      });
    }

    var event = evt.event;

    if (event !== null && event.type === "data-chunk") {
      var value = event.value;
      emitted.push({
        type: "progress",
        value: {
          duration: value.duration,
          size: value.size,
          totalSize: value.totalSize
        }
      });
    } else if (event !== null && event.type === "data-complete") {
      var _value = event.value;
      emitted.push({
        type: "data-chunk-complete",
        value: {
          duration: _value.duration,
          receivedTime: _value.receivedTime,
          sendingTime: _value.sendingTime,
          size: _value.size,
          url: _value.url
        }
      });
    }

    return of["a" /* of */].apply(void 0, emitted);
  }));
}
// CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */

function regularSegmentLoader(url, args, lowLatencyMode) {
  if (args.segment.isInit) {
    return initSegmentLoader(url, args);
  }

  var isWEBM = isWEBMEmbeddedTrack(args.representation);

  if (lowLatencyMode && !isWEBM) {
    if (Object(fetch["b" /* fetchIsSupported */])()) {
      return lowLatencySegmentLoader(url, args);
    } else {
      Object(warn_once["a" /* default */])("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
    }
  }

  var segment = args.segment;
  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    sendProgressEvents: true,
    headers: segment.range !== undefined ? {
      Range: Object(byte_range["a" /* default */])(segment.range)
    } : undefined
  });
}
/**
 * @param {Object} config
 * @returns {Function}
 */


function generateSegmentLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      customSegmentLoader = _ref.segmentLoader,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;
  return checkMediaSegmentIntegrity !== true ? segmentLoader : addSegmentIntegrityChecks(segmentLoader);
  /**
   * @param {Object} content
   * @returns {Observable}
   */

  function segmentLoader(content) {
    var url = content.url;

    if (url == null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (lowLatencyMode || customSegmentLoader === undefined) {
      return regularSegmentLoader(url, content, lowLatencyMode);
    }

    var args = {
      adaptation: content.adaptation,
      manifest: content.manifest,
      period: content.period,
      representation: content.representation,
      segment: content.segment,
      transport: "dash",
      url: url
    };
    return new Observable["a" /* Observable */](function (obs) {
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom segment loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom segment loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject(err) {
        if (err === void 0) {
          err = {};
        }

        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };

      var progress = function progress(_args) {
        if (!hasFallbacked) {
          obs.next({
            type: "progress",
            value: {
              duration: _args.duration,
              size: _args.size,
              totalSize: _args.totalSize
            }
          });
        }
      };
      /**
       * Callback triggered when the custom segment loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        var regular$ = regularSegmentLoader(url, content, lowLatencyMode); // HACK What is TypeScript/RxJS doing here??????

        /* tslint:disable deprecation */
        // @ts-ignore

        regular$.subscribe(obs);
        /* tslint:enable deprecation */
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        progress: progress,
        fallback: fallback
      };
      var abort = customSegmentLoader(args, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(239);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts
var take_pssh_out = __webpack_require__(238);

// CONCATENATED MODULE: ./src/parsers/containers/matroska/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SEGMENT_ID = 0x18538067;
var INFO_ID = 0x1549A966;
var TIMECODESCALE_ID = 0x2AD7B1;
var DURATION_ID = 0x4489;
var CUES_ID = 0x1C53BB6B;
var CUE_POINT_ID = 0xBB;
var CUE_TIME_ID = 0xB3;
var CUE_TRACK_POSITIONS_ID = 0xB7;
var CUE_CLUSTER_POSITIONS_ID = 0xF1;
/**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */

function findNextElement(elementID, parents, buffer, _ref) {
  var initialOffset = _ref[0],
      maxOffset = _ref[1];
  var currentOffset = initialOffset;

  while (currentOffset < maxOffset) {
    var parsedID = getEBMLID(buffer, currentOffset);

    if (parsedID == null) {
      return null;
    }

    var ebmlTagID = parsedID.value,
        ebmlTagLength = parsedID.length;
    var sizeOffset = currentOffset + ebmlTagLength;
    var parsedValue = getEBMLValue(buffer, sizeOffset);

    if (parsedValue == null) {
      return null;
    }

    var valueLengthLength = parsedValue.length,
        valueLength = parsedValue.value;
    var valueOffset = sizeOffset + valueLengthLength;
    var valueEndOffset = valueOffset + valueLength;

    if (ebmlTagID === elementID) {
      return [valueOffset, valueEndOffset];
    } else if (parents.length > 0) {
      for (var i = 0; i < parents.length; i++) {
        if (ebmlTagID === parents[i]) {
          var newParents = parents.slice(i + 1, parents.length);
          return findNextElement(elementID, newParents, buffer, [valueOffset, valueEndOffset]);
        }
      }
    }

    currentOffset = valueEndOffset;
  }

  return null;
}
/**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */


function getTimeCodeScale(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
  return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
}
/**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */

function getDuration(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];

  if (length === 4) {
    return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
  } else if (length === 8) {
    return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
  }

  return null;
}
/**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */


function getSegmentsFromCues(buffer, initialOffset) {
  var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [initialOffset, buffer.length]);

  if (segmentRange == null) {
    return null;
  }

  var segmentRangeStart = segmentRange[0],
      segmentRangeEnd = segmentRange[1];
  var timescale = getTimeCodeScale(buffer, segmentRangeStart);

  if (timescale == null) {
    return null;
  }

  var duration = getDuration(buffer, segmentRangeStart);

  if (duration == null) {
    return null;
  }

  var cuesRange = findNextElement(CUES_ID, [], buffer, [segmentRangeStart, segmentRangeEnd]);

  if (cuesRange == null) {
    return null;
  }

  var rawInfos = [];
  var currentOffset = cuesRange[0];

  while (currentOffset < cuesRange[1]) {
    var cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [currentOffset, cuesRange[1]]);

    if (cuePointRange == null) {
      break;
    }

    var cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueTimeRange == null) {
      return null;
    }

    var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);
    var cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueOffsetRange == null) {
      return null;
    }

    var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
    rawInfos.push({
      time: time,
      rangeStart: rangeStart
    });
    currentOffset = cuePointRange[1];
  }

  var segments = [];

  for (var i = 0; i < rawInfos.length; i++) {
    var currentSegment = rawInfos[i];

    if (i === rawInfos.length - 1) {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: i === 0 ? duration : duration - currentSegment.time,
        range: [currentSegment.rangeStart, Infinity]
      });
    } else {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: rawInfos[i + 1].time - currentSegment.time,
        range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1]
      });
    }
  }

  return segments;
}

function getLength(buffer, offset) {
  for (var length = 1; length <= 8; length++) {
    if (buffer[offset] >= Math.pow(2, 8 - length)) {
      return length;
    }
  }

  return undefined;
}

function getEBMLID(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log["a" /* default */].warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log["a" /* default */].warn("webm: impossible length");
    return null;
  }

  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}

function getEBMLValue(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log["a" /* default */].warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log["a" /* default */].warn("webm: impossible length");
    return null;
  }

  var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, (length - 1) * 8);

  for (var i = 1; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}
/**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_32Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat32(offset);
}
/**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_64Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat64(offset);
}

function bytesToNumber(buffer, offset, length) {
  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return value;
}
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// CONCATENATED MODULE: ./src/transports/utils/get_isobmff_timing_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {number|undefined} initTimescale
 * @returns {Object}
 */

function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {
  var startTime;
  var duration;
  var trunDuration = Object(utils["a" /* getDurationFromTrun */])(buffer);
  var timescale = initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale;
  var baseDecodeTime = Object(utils["d" /* getTrackFragmentDecodeTime */])(buffer);

  if (isChunked) {
    // when chunked, no mean to know the duration for now
    if (initTimescale === undefined) {
      return null;
    }

    if (baseDecodeTime === undefined) {
      return null;
    }

    return {
      time: baseDecodeTime,
      duration: trunDuration,
      timescale: initTimescale
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta; // Scaled start time and duration as announced in the segment data

  var segmentDuration;

  if (timescale === segment.timescale) {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / 4 : 0.25);
    segmentDuration = segment.duration;
  } else {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / segment.timescale * timescale / 4 : 0.25);
    segmentDuration = !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / segment.timescale * timescale : undefined;
  }

  if (baseDecodeTime !== undefined) {
    startTime = segment.timestampOffset !== undefined ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime;
  } else {
    return null;
  }

  if (trunDuration !== undefined && (segmentDuration === undefined || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
    duration = trunDuration;
  }

  return {
    timescale: timescale,
    time: startTime,
    duration: duration
  };
}
// CONCATENATED MODULE: ./src/transports/dash/segment_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * @param {Object} config
 * @returns {Function}
 */

function generateAudioVideoSegmentParser(_ref) {
  var __priv_patchLastSegmentInSidx = _ref.__priv_patchLastSegmentInSidx;
  return function audioVideoSegmentParser(_ref2) {
    var content = _ref2.content,
        response = _ref2.response,
        initTimescale = _ref2.initTimescale;
    var period = content.period,
        representation = content.representation,
        segment = content.segment;
    var data = response.data,
        isChunked = response.isChunked;
    var appendWindow = [period.start, period.end];

    if (data === null) {
      if (segment.isInit) {
        var _segmentProtections = representation.getProtectionsInitializationData();

        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: _segmentProtections,
            initTimescale: undefined
          }
        });
      }

      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: null,
          chunkInfos: null,
          chunkOffset: 0,
          appendWindow: appendWindow
        }
      });
    }

    var chunkData = data instanceof Uint8Array ? data : new Uint8Array(data);
    var isWEBM = isWEBMEmbeddedTrack(representation);

    if (!segment.isInit) {
      var chunkInfos = isWEBM ? null : // TODO extract time info from webm
      getISOBMFFTimingInfos(chunkData, isChunked, segment, initTimescale);
      var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0);
      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: chunkData,
          chunkInfos: chunkInfos,
          chunkOffset: chunkOffset,
          appendWindow: appendWindow
        }
      });
    } // we're handling an initialization segment


    var indexRange = segment.indexRange;
    var nextSegments;

    if (isWEBM) {
      nextSegments = getSegmentsFromCues(chunkData, 0);
    } else {
      nextSegments = Object(utils["c" /* getSegmentsFromSidx */])(chunkData, Array.isArray(indexRange) ? indexRange[0] : 0); // This is a very specific handling for streams we know have a very
      // specific problem at Canal+: The last reference gives a truncated
      // segment.
      // Sadly, people on the packaging side could not fix all legacy contents.
      // This is an easy-but-ugly fix for those.
      // TODO Cleaner way? I tried to always check the obtained segment after
      // a byte-range request but it leads to a lot of code.

      if (__priv_patchLastSegmentInSidx === true && nextSegments !== null && nextSegments.length > 0) {
        var lastSegment = nextSegments[nextSegments.length - 1];

        if (Array.isArray(lastSegment.range)) {
          lastSegment.range[1] = Infinity;
        }
      }
    }

    if (nextSegments !== null && nextSegments.length > 0) {
      representation.index._addSegments(nextSegments);
    }

    var timescale = isWEBM ? getTimeCodeScale(chunkData, 0) : Object(utils["b" /* getMDHDTimescale */])(chunkData);
    var parsedTimescale = Object(is_null_or_undefined["a" /* default */])(timescale) ? undefined : timescale;

    if (!isWEBM) {
      // TODO extract webm protection information
      var psshInfo = Object(take_pssh_out["a" /* default */])(chunkData);

      for (var i = 0; i < psshInfo.length; i++) {
        var _psshInfo$i = psshInfo[i],
            systemID = _psshInfo$i.systemID,
            psshData = _psshInfo$i.data;

        representation._addProtectionData("cenc", systemID, psshData);
      }
    }

    var segmentProtections = representation.getProtectionsInitializationData();
    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: chunkData,
        segmentProtections: segmentProtections,
        initTimescale: parsedTimescale
      }
    });
  };
}
// CONCATENATED MODULE: ./src/transports/utils/is_mp4_embedded_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTextTrack(representation) {
  return representation.mimeType === "application/mp4";
}
// CONCATENATED MODULE: ./src/transports/dash/text_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */

function generateTextTrackLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;
  return checkMediaSegmentIntegrity !== true ? textTrackLoader : addSegmentIntegrityChecks(textTrackLoader);
  /**
   * @param {Object} args
   * @returns {Observable}
   */

  function textTrackLoader(args) {
    var range = args.segment.range;
    var url = args.url;

    if (url === null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (args.segment.isInit) {
      return initSegmentLoader(url, args);
    }

    var isMP4Embedded = isMP4EmbeddedTextTrack(args.representation);

    if (lowLatencyMode && isMP4Embedded) {
      if (Object(fetch["b" /* fetchIsSupported */])()) {
        return lowLatencySegmentLoader(url, args);
      } else {
        Object(warn_once["a" /* default */])("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
      }
    } // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise


    var responseType = isMP4Embedded ? "arraybuffer" : "text";
    return Object(request["a" /* default */])({
      url: url,
      responseType: responseType,
      headers: Array.isArray(range) ? {
        Range: Object(byte_range["a" /* default */])(range)
      } : null,
      sendProgressEvents: true
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(143);

// CONCATENATED MODULE: ./src/transports/utils/parse_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Return plain text text track from the given ISOBMFF.
 * @param {Uint8Array} chunkBytes
 * @returns {string}
 */

function extractTextTrackFromISOBMFF(chunkBytes) {
  var mdat = Object(read["a" /* getMDAT */])(chunkBytes);
  return mdat === null ? "" : Object(string_parsing["g" /* utf8ToStr */])(mdat);
}
/**
 * Returns the a string expliciting the format of a text track when that text
 * track is embedded into a ISOBMFF file.
 * @param {Object} representation
 * @returns {string}
 */

function getISOBMFFTextTrackFormat(representation) {
  var codec = representation.codec;

  if (codec === undefined) {
    throw new Error("Cannot parse subtitles: unknown format");
  }

  switch (codec.toLowerCase()) {
    case "stpp": // stpp === TTML in MP4

    case "stpp.ttml.im1t":
      return "ttml";

    case "wvtt":
      // wvtt === WebVTT in MP4
      return "vtt";
  }

  throw new Error("The codec used for the subtitles " + ("\"" + codec + "\" is not managed yet."));
}
/**
 * Returns the a string expliciting the format of a text track in plain text.
 * @param {Object} representation
 * @returns {string}
 */

function getPlainTextTrackFormat(representation) {
  var _representation$mimeT = representation.mimeType,
      mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;

  switch (representation.mimeType) {
    case "application/ttml+xml":
      return "ttml";

    case "application/x-sami":
    case "application/smil":
      return "sami";

    case "text/vtt":
      return "vtt";
  }

  var _representation$codec = representation.codec,
      codec = _representation$codec === void 0 ? "" : _representation$codec;
  var codeLC = codec.toLowerCase();

  if (codeLC === "srt") {
    return "srt";
  }

  throw new Error("could not find a text-track parser for the type " + mimeType);
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getISOBMFFEmbeddedTextTrackData(_ref, chunkBytes, chunkInfos, isChunked) {
  var segment = _ref.segment,
      adaptation = _ref.adaptation,
      representation = _ref.representation;

  if (segment.isInit) {
    return null;
  }

  var startTime;
  var endTime;
  var timescale = 1;

  if (chunkInfos === null) {
    if (!isChunked) {
      log["a" /* default */].warn("Transport: Unavailable time data for current text track.");
    } else {
      startTime = segment.time;
      endTime = startTime + segment.duration;
      timescale = segment.timescale;
    }
  } else {
    startTime = chunkInfos.time;

    if (chunkInfos.duration !== undefined) {
      endTime = startTime + chunkInfos.duration;
    } else if (!isChunked) {
      endTime = startTime + segment.duration;
    }

    timescale = chunkInfos.timescale;
  }

  var type = getISOBMFFTextTrackFormat(representation);
  var textData = extractTextTrackFromISOBMFF(chunkBytes);
  return {
    data: textData,
    type: type,
    language: adaptation.language,
    start: startTime,
    end: endTime,
    timescale: timescale
  };
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getPlainTextTrackData(_ref2, textTrackData, isChunked) {
  var segment = _ref2.segment,
      adaptation = _ref2.adaptation,
      representation = _ref2.representation;

  if (segment.isInit) {
    return null;
  }

  var start;
  var end;
  var timescale = 1;

  if (!isChunked) {
    start = segment.time;
    end = start + segment.duration;
    timescale = segment.timescale;
  } else {
    log["a" /* default */].warn("Transport: Unavailable time data for current text track.");
  }

  var type = getPlainTextTrackFormat(representation);
  return {
    data: textTrackData,
    type: type,
    language: adaptation.language,
    start: start,
    end: end,
    timescale: timescale
  };
}
// CONCATENATED MODULE: ./src/transports/dash/text_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */

function parseISOBMFFEmbeddedTextTrack(_ref, __priv_patchLastSegmentInSidx) {
  var response = _ref.response,
      content = _ref.content,
      initTimescale = _ref.initTimescale;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var isInit = segment.isInit,
      indexRange = segment.indexRange;
  var data = response.data,
      isChunked = response.isChunked;
  var chunkBytes = typeof data === "string" ? Object(string_parsing["f" /* strToUtf8 */])(data) : data instanceof Uint8Array ? data : new Uint8Array(data);

  if (isInit) {
    var sidxSegments = Object(utils["c" /* getSegmentsFromSidx */])(chunkBytes, Array.isArray(indexRange) ? indexRange[0] : 0); // This is a very specific handling for streams we know have a very
    // specific problem at Canal+: The last reference gives a truncated
    // segment.
    // Sadly, people on the packaging side could not fix all legacy contents.
    // This is an easy-but-ugly fix for those.
    // TODO Cleaner way? I tried to always check the obtained segment after
    // a byte-range request but it leads to a lot of code.

    if (__priv_patchLastSegmentInSidx === true && sidxSegments !== null && sidxSegments.length > 0) {
      var lastSegment = sidxSegments[sidxSegments.length - 1];

      if (Array.isArray(lastSegment.range)) {
        lastSegment.range[1] = Infinity;
      }
    }

    var mdhdTimescale = Object(utils["b" /* getMDHDTimescale */])(chunkBytes);

    if (sidxSegments !== null && sidxSegments.length > 0) {
      representation.index._addSegments(sidxSegments);
    }

    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: mdhdTimescale
      }
    });
  }

  var chunkInfos = getISOBMFFTimingInfos(chunkBytes, isChunked, segment, initTimescale);
  var chunkData = getISOBMFFEmbeddedTextTrackData(content, chunkBytes, chunkInfos, isChunked);
  var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0);
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: chunkData,
      chunkInfos: chunkInfos,
      chunkOffset: chunkOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
/**
 * Parse TextTrack data in plain text form.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function parsePlainTextTrack(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var period = content.period,
      segment = content.segment;
  var _segment$timestampOff = segment.timestampOffset,
      timestampOffset = _segment$timestampOff === void 0 ? 0 : _segment$timestampOff;

  if (segment.isInit) {
    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: undefined
      }
    });
  }

  var data = response.data,
      isChunked = response.isChunked;
  var textTrackData;

  if (typeof data !== "string") {
    var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
    textTrackData = Object(string_parsing["g" /* utf8ToStr */])(bytesData);
  } else {
    textTrackData = data;
  }

  var chunkData = getPlainTextTrackData(content, textTrackData, isChunked);
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: chunkData,
      chunkInfos: null,
      chunkOffset: timestampOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
/**
 * @param {Object} config
 * @returns {Function}
 */


function generateTextTrackParser(_ref3) {
  var __priv_patchLastSegmentInSidx = _ref3.__priv_patchLastSegmentInSidx;

  /**
   * Parse TextTrack data.
   * @param {Object} infos
   * @returns {Observable.<Object>}
   */
  return function textTrackParser(_ref4) {
    var response = _ref4.response,
        content = _ref4.content,
        initTimescale = _ref4.initTimescale;
    var period = content.period,
        representation = content.representation,
        segment = content.segment;
    var _segment$timestampOff2 = segment.timestampOffset,
        timestampOffset = _segment$timestampOff2 === void 0 ? 0 : _segment$timestampOff2;
    var data = response.data,
        isChunked = response.isChunked;

    if (data === null) {
      // No data, just return empty infos
      if (segment.isInit) {
        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: [],
            initTimescale: undefined
          }
        });
      }

      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: null,
          chunkInfos: null,
          chunkOffset: timestampOffset,
          appendWindow: [period.start, period.end]
        }
      });
    }

    var isMP4 = isMP4EmbeddedTextTrack(representation);

    if (isMP4) {
      return parseISOBMFFEmbeddedTextTrack({
        response: {
          data: data,
          isChunked: isChunked
        },
        content: content,
        initTimescale: initTimescale
      }, __priv_patchLastSegmentInSidx);
    } else {
      return parsePlainTextTrack({
        response: {
          data: data,
          isChunked: isChunked
        },
        content: content
      });
    }
  };
}
// CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */

/* harmony default export */ var pipelines = (function (options) {
  var manifestLoader = Object(text_manifest_loader["a" /* default */])({
    customManifestLoader: options.manifestLoader
  });
  var manifestParser = generateManifestParser(options);
  var segmentLoader = generateSegmentLoader(options);
  var audioVideoSegmentParser = generateAudioVideoSegmentParser(options);
  var textTrackLoader = generateTextTrackLoader(options);
  var textTrackParser = generateTextTrackParser(options);
  return {
    manifest: {
      loader: manifestLoader,
      parser: manifestParser
    },
    audio: {
      loader: segmentLoader,
      parser: audioVideoSegmentParser
    },
    video: {
      loader: segmentLoader,
      parser: audioVideoSegmentParser
    },
    text: {
      loader: textTrackLoader,
      parser: textTrackParser
    },
    image: {
      loader: imageLoader,
      parser: imageParser
    }
  };
});
// CONCATENATED MODULE: ./src/transports/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_dash = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(158);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(67);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts
var take_pssh_out = __webpack_require__(238);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(143);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(53);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(69);

// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(19);

// CONCATENATED MODULE: ./src/parsers/manifest/utils/check_manifest_ids.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */

function checkManifestIDs(manifest) {
  var periodIDS = [];
  manifest.periods.forEach(function (period) {
    var periodID = period.id;

    if (Object(array_includes["a" /* default */])(periodIDS, periodID)) {
      log["a" /* default */].warn("Two periods with the same ID found. Updating.");
      var newID = periodID + "-dup";
      period.id = newID;
      checkManifestIDs(manifest);
      periodIDS.push(newID);
    } else {
      periodIDS.push(periodID);
    }

    var adaptations = period.adaptations;
    var adaptationIDs = [];
    Object.keys(adaptations).forEach(function (type) {
      var adaptationsForType = adaptations[type];

      if (adaptationsForType === undefined) {
        return;
      }

      adaptationsForType.forEach(function (adaptation) {
        var adaptationID = adaptation.id;

        if (Object(array_includes["a" /* default */])(adaptationIDs, adaptationID)) {
          log["a" /* default */].warn("Two adaptations with the same ID found. Updating.", adaptationID);

          var _newID = adaptationID + "-dup";

          adaptation.id = _newID;
          checkManifestIDs(manifest);
          adaptationIDs.push(_newID);
        } else {
          adaptationIDs.push(adaptationID);
        }

        var representationIDs = [];
        adaptation.representations.forEach(function (representation) {
          var representationID = representation.id;

          if (Object(array_includes["a" /* default */])(representationIDs, representationID)) {
            log["a" /* default */].warn("Two representations with the same ID found. Updating.", representationID);

            var _newID2 = representationID + "-dup";

            representation.id = _newID2;
            checkManifestIDs(manifest);
            representationIDs.push(_newID2);
          } else {
            representationIDs.push(representationID);
          }
        });
      });
    });
  });
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} codecPrivateData
 * @param {string|undefined} fourCC
 * @returns {string}
 */

function getAudioCodecs(codecPrivateData, fourCC) {
  var mpProfile;

  if (fourCC === "AACH") {
    mpProfile = 5; // High Efficiency AAC Profile
  } else {
    mpProfile = Object(is_non_empty_string["a" /* default */])(codecPrivateData) ? (parseInt(codecPrivateData.substring(0, 2), 16) & 0xF8) >> 3 : 2;
  }

  if (mpProfile === 0) {
    // Return default audio codec
    return "mp4a.40.2";
  }

  return "mp4a.40." + mpProfile;
}
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */

function getVideoCodecs(codecPrivateData) {
  // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
  var arr = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);

  if (arr === null || !Object(is_non_empty_string["a" /* default */])(arr[1])) {
    // Return default video codec
    return "avc1.4D401E";
  }

  return "avc1." + arr[1];
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */

function parseCNodes(nodes) {
  return nodes.reduce(function (timeline, node, i) {
    var dAttr = node.getAttribute("d");
    var tAttr = node.getAttribute("t");
    var rAttr = node.getAttribute("r");
    var repeatCount = rAttr !== null ? +rAttr - 1 : 0;
    var start = tAttr !== null ? +tAttr : undefined;
    var duration = dAttr !== null ? +dAttr : undefined;

    if (i === 0) {
      // first node
      start = start === undefined || isNaN(start) ? 0 : start;
    } else {
      // from second node to the end
      var prev = timeline[i - 1];

      if (start == null || isNaN(start)) {
        if (prev.duration == null || isNaN(prev.duration)) {
          throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
        }

        start = prev.start + prev.duration * (prev.repeatCount + 1);
      }
    }

    if (duration == null || isNaN(duration)) {
      var nextNode = nodes[i + 1];

      if (nextNode !== undefined) {
        var nextTAttr = nextNode.getAttribute("t");
        var nextStart = Object(is_non_empty_string["a" /* default */])(nextTAttr) ? +nextTAttr : null;

        if (nextStart === null) {
          throw new Error("Can't build index timeline from Smooth Manifest.");
        }

        duration = nextStart - start;
      } else {
        return timeline;
      }
    }

    timeline.push({
      duration: duration,
      start: start,
      repeatCount: repeatCount
    });
    return timeline;
  }, []);
}
// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(11);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
var playready = __webpack_require__(207);

// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */

function createWidevineKeySystem(keyIdBytes) {
  return [{
    systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
    privateData: Object(byte_parsing["e" /* concat */])([0x08, 0x01, 0x12, 0x10], keyIdBytes)
  }];
}
/**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */


function parseProtectionNode(protectionNode, keySystemCreator) {
  if (keySystemCreator === void 0) {
    keySystemCreator = createWidevineKeySystem;
  }

  if (protectionNode.firstElementChild === null || protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
    throw new Error("Protection should have ProtectionHeader child");
  }

  var header = protectionNode.firstElementChild;
  var privateData = Object(base64["a" /* base64ToBytes */])(header.textContent === null ? "" : header.textContent);
  var keyIdHex = Object(playready["a" /* getPlayReadyKIDFromPrivateData */])(privateData);
  var keyIdBytes = Object(string_parsing["c" /* hexToBytes */])(keyIdHex); // remove possible braces

  var systemIdAttr = header.getAttribute("SystemID");
  var systemId = (systemIdAttr !== null ? systemIdAttr : "").toLowerCase().replace(/\{|\}/g, "");
  return {
    keyId: keyIdBytes,
    keySystems: [{
      systemId: systemId,
      privateData: privateData
    }].concat(keySystemCreator(keyIdBytes))
  };
}
// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(179);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(123);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(20);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(121);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(122);

// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/add_segment_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */

function _addSegmentInfos(index, newSegment, currentSegment) {
  var timeline = index.timeline,
      timescale = index.timescale;
  var timelineLength = timeline.length;
  var last = timeline[timelineLength - 1];
  var scaledNewSegment = newSegment.timescale === timescale ? {
    time: newSegment.time,
    duration: newSegment.duration
  } : {
    time: newSegment.time / newSegment.timescale * timescale,
    duration: newSegment.duration / newSegment.timescale * timescale
  };
  var scaledCurrentTime;

  if (currentSegment.timescale !== 0) {
    scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale;
  } // in some circumstances, the new segment information are only duration
  // information that we could use to deduct the start of the next segment.
  // This is the case where the new segment are associated to a current
  // segment and have the same start.
  // However, we prefer to be sure of the duration of the new segments
  // before adding such segments.


  var shouldDeductNextSegment = scaledCurrentTime != null && scaledNewSegment.time === scaledCurrentTime;

  if (shouldDeductNextSegment) {
    return false;
  } else if (scaledNewSegment.time >= Object(index_helpers["c" /* getIndexSegmentEnd */])(last, null)) {
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    if (last.duration === scaledNewSegment.duration) {
      last.repeatCount++;
    } else {
      index.timeline.push({
        duration: scaledNewSegment.duration,
        start: scaledNewSegment.time,
        repeatCount: 0
      });
    }

    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */
function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
  return url.replace(/\{bitrate\}/g, String(bitrate)).replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] : "");
}
/**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */


function replaceSegmentSmoothTokens(url, time) {
  return url.replace(/\{start time\}/g, String(time));
}


// CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */

function getSegmentIndex(index, start) {
  var timeline = index.timeline;
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}
/**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */


function getSegmentNumber(start, up, duration) {
  var diff = up - start;
  return diff > 0 ? Math.floor(diff / duration) : 0;
} // interface ISmoothIndex {
//   presentationTimeOffset? : number;
//   timescale : number;
//   media? : string;
//   timeline : IIndexSegment[];
//   startNumber? : number;
// }

/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */


function normalizeRange(index, start, duration) {
  var timescale = index.timescale === undefined || index.timescale === 0 ? 1 : index.timescale;
  return {
    up: start * timescale,
    to: (start + duration) * timescale
  };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */


function calculateRepeat(segment, nextSegment) {
  var repeatCount = segment.repeatCount; // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  // TODO Also for SMOOTH????

  if (segment.duration != null && repeatCount < 0) {
    var repeatEnd = nextSegment !== undefined ? nextSegment.start : Infinity;
    repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
  }

  return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */


var representation_index_SmoothRepresentationIndex = /*#__PURE__*/function () {
  function SmoothRepresentationIndex(index, options) {
    var aggressiveMode = options.aggressiveMode,
        isLive = options.isLive,
        segmentPrivateInfos = options.segmentPrivateInfos;
    var estimatedReceivedTime = index.manifestReceivedTime == null ? performance.now() : index.manifestReceivedTime;
    this._index = index;
    this._indexValidityTime = estimatedReceivedTime;
    this._initSegmentInfos = {
      bitsPerSample: segmentPrivateInfos.bitsPerSample,
      channels: segmentPrivateInfos.channels,
      codecPrivateData: segmentPrivateInfos.codecPrivateData,
      packetSize: segmentPrivateInfos.packetSize,
      samplingRate: segmentPrivateInfos.samplingRate,
      protection: segmentPrivateInfos.protection
    };
    this._isAggressiveMode = aggressiveMode;
    this._isLive = isLive;

    if (index.timeline.length !== 0) {
      var lastItem = index.timeline[index.timeline.length - 1];
      var scaledEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastItem, null);
      this._initialScaledLastPosition = scaledEnd;

      if (index.isLive) {
        var scaledReceivedTime = estimatedReceivedTime / 1000 * index.timescale;
        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
      }
    }
  }
  /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */


  var _proto = SmoothRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return {
      id: "init",
      isInit: true,
      time: 0,
      duration: 0,
      timescale: this._index.timescale,
      privateInfos: {
        smoothInit: this._initSegmentInfos
      },
      mediaURLs: null
    };
  }
  /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(_up, _to) {
    this._refreshTimeline();

    var _normalizeRange = normalizeRange(this._index, _up, _to),
        up = _normalizeRange.up,
        to = _normalizeRange.to;

    var _this$_index = this._index,
        timeline = _this$_index.timeline,
        timescale = _this$_index.timescale,
        media = _this$_index.media;
    var isAggressive = this._isAggressiveMode;
    var currentNumber;
    var segments = [];
    var timelineLength = timeline.length;
    var maxPosition = this._scaledLiveGap == null ? undefined : performance.now() / 1000 * timescale - this._scaledLiveGap;

    for (var i = 0; i < timelineLength; i++) {
      var segmentRange = timeline[i];
      var duration = segmentRange.duration,
          start = segmentRange.start;
      var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
      var segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
      var segmentTime = start + segmentNumberInCurrentRange * duration;
      var timeToAddToCheckMaxPosition = isAggressive ? 0 : duration;

      while (segmentTime < to && segmentNumberInCurrentRange <= repeat && (maxPosition == null || segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {
        var time = segmentTime;
        var number = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
        var segment = {
          id: String(segmentTime),
          time: time,
          isInit: false,
          duration: duration,
          timescale: timescale,
          number: number,
          mediaURLs: [replaceSegmentSmoothTokens(media, time)]
        };
        segments.push(segment); // update segment number and segment time for the next segment

        segmentNumberInCurrentRange++;
        segmentTime = start + segmentNumberInCurrentRange * duration;
      }

      if (segmentTime >= to) {
        // we reached ``to``, we're done
        return segments;
      }

      if (currentNumber != null) {
        currentNumber += repeat + 1;
      }
    }

    return segments;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh(up, to) {
    this._refreshTimeline();

    if (!this._index.isLive) {
      return false;
    }

    var _this$_index2 = this._index,
        timeline = _this$_index2.timeline,
        timescale = _this$_index2.timescale;
    var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];

    if (lastSegmentInCurrentTimeline === undefined) {
      return false;
    }

    var repeat = lastSegmentInCurrentTimeline.repeatCount;
    var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;

    if (to * timescale < endOfLastSegmentInCurrentTimeline) {
      return false;
    }

    if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
      return true;
    } // ----


    var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;
    return up * timescale > startOfLastSegmentInCurrentTimeline;
  }
  /**
   * Returns first position available in the index.
   *
   * @param {Object} index
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    this._refreshTimeline();

    var index = this._index;

    if (index.timeline.length === 0) {
      return null;
    }

    return index.timeline[0].start / index.timescale;
  }
  /**
   * Returns last position available in the index.
   * @param {Object} index
   * @returns {Number}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    this._refreshTimeline();

    var index = this._index;

    if (this._scaledLiveGap == null) {
      var lastTimelineElement = index.timeline[index.timeline.length - 1];
      return Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null) / index.timescale;
    }

    for (var i = index.timeline.length - 1; i >= 0; i--) {
      var timelineElt = index.timeline[i];
      var timescaledNow = performance.now() / 1000 * index.timescale;
      var start = timelineElt.start,
          duration = timelineElt.duration,
          repeatCount = timelineElt.repeatCount;

      for (var j = repeatCount; j >= 0; j--) {
        var end = start + duration * (j + 1);
        var positionToReach = this._isAggressiveMode ? end - duration : end;

        if (positionToReach <= timescaledNow - this._scaledLiveGap) {
          return end / index.timescale;
        }
      }
    }

    return undefined;
  }
  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   *
   * @param {Number} timeSec
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity(timeSec) {
    this._refreshTimeline();

    var index = this._index;
    var timeline = index.timeline,
        _index$timescale = index.timescale,
        timescale = _index$timescale === void 0 ? 1 : _index$timescale;
    var timeTScaled = timeSec * timescale;

    if (timeTScaled <= 0) {
      return -1;
    }

    var segmentIndex = getSegmentIndex(index, timeTScaled);

    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return -1;
    }

    var range = timeline[segmentIndex];

    if (range.duration === -1) {
      return -1;
    }

    var rangeUp = range.start;
    var rangeTo = Object(index_helpers["c" /* getIndexSegmentEnd */])(range, null);
    var nextRange = timeline[segmentIndex + 1]; // when we are actually inside the found range and this range has
    // an explicit discontinuity with the next one

    if (rangeTo < nextRange.start && timeTScaled >= rangeUp && rangeTo - timeTScaled < timescale) {
      return nextRange.start / timescale;
    }

    return -1;
  };

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    this._refreshTimeline();

    var _this$_index3 = this._index,
        timeline = _this$_index3.timeline,
        timescale = _this$_index3.timescale;
    return Object(is_segment_still_available["a" /* default */])(segment, timeline, timescale, 0);
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isLive) {
      return false;
    }

    return error instanceof network_error["a" /* default */] && (error.isHttpError(404) || error.isHttpError(412));
  }
  /**
   * Replace this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more information about new segments and re-add
   * them if that's the case.
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    var oldTimeline = this._index.timeline;
    var newTimeline = newIndex._index.timeline;
    var oldTimescale = this._index.timescale;
    var newTimescale = newIndex._index.timescale;
    this._index = newIndex._index;
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;

    if (oldTimeline.length === 0 || newTimeline.length === 0 || oldTimescale !== newTimescale) {
      return; // don't take risk, if something is off, take the new one
    }

    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
    var lastNewTimelineElement = newTimeline[newTimeline.length - 1];
    var newEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastNewTimelineElement, null);

    if (Object(index_helpers["c" /* getIndexSegmentEnd */])(lastOldTimelineElement, null) <= newEnd) {
      return;
    }

    for (var i = 0; i < oldTimeline.length; i++) {
      var oldTimelineRange = oldTimeline[i];
      var oldEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(oldTimelineRange, null);

      if (oldEnd === newEnd) {
        // just add the supplementary segments
        this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1));
        return;
      }

      if (oldEnd > newEnd) {
        // adjust repeatCount + add supplementary segments
        if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
          return;
        }

        var rangeDuration = newEnd - oldTimelineRange.start;

        if (rangeDuration === 0) {
          log["a" /* default */].warn("Smooth Parser: a discontinuity detected in the previous manifest" + " has been resolved.");
          this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i));
          return;
        }

        if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
          return;
        }

        var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;
        var relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;

        if (relativeRepeat < 0) {
          return;
        }

        lastNewTimelineElement.repeatCount += relativeRepeat;
        var supplementarySegments = oldTimeline.slice(i + 1);
        this._index.timeline = this._index.timeline.concat(supplementarySegments);
        return;
      }
    }
  };

  _proto._update = function _update(newIndex) {
    Object(update_segment_timeline["a" /* default */])(this._index.timeline, newIndex._index.timeline);
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return !this._isLive;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return true;
  };

  _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
    this._refreshTimeline();

    for (var i = 0; i < nextSegments.length; i++) {
      _addSegmentInfos(this._index, nextSegments[i], currentSegment);
    }
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to the timeshift window
   */
  ;

  _proto._refreshTimeline = function _refreshTimeline() {
    // clean segments before time shift buffer depth
    if (this._initialScaledLastPosition == null) {
      return;
    }

    var index = this._index;
    var timeShiftBufferDepth = index.timeShiftBufferDepth;
    var timeSinceLastRealUpdate = (performance.now() - this._indexValidityTime) / 1000;
    var lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / index.timescale;

    if (timeShiftBufferDepth != null) {
      var minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * index.timescale;
      Object(clear_timeline_from_position["a" /* default */])(index.timeline, minimumPosition);
    }
  };

  return SmoothRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
  if (typeof val === "boolean") {
    return val;
  } else if (typeof val === "string") {
    return val.toUpperCase() === "TRUE";
  } else {
    return false;
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */
function reduceChildren(root, fn, init) {
  var node = root.firstElementChild;
  var accumulator = init;

  while (node !== null) {
    accumulator = fn(accumulator, node.nodeName, node);
    node = node.nextElementSibling;
  }

  return accumulator;
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */

var DEFAULT_AGGRESSIVE_MODE = false;
var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
var DEFAULT_MIME_TYPES = {
  audio: "audio/mp4",
  video: "video/mp4",
  text: "application/ttml+xml"
};
var MIME_TYPES = {
  AACL: "audio/mp4",
  AVC1: "video/mp4",
  H264: "video/mp4",
  TTML: "application/ttml+xml+mp4"
};
/**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */

function createSmoothStreamingParser(parserOptions) {
  if (parserOptions === void 0) {
    parserOptions = {};
  }

  var referenceDateTime = parserOptions.referenceDateTime === undefined ? Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000 : parserOptions.referenceDateTime;
  var minRepresentationBitrate = parserOptions.minRepresentationBitrate === undefined ? 0 : parserOptions.minRepresentationBitrate;
  var _parserOptions = parserOptions,
      serverSyncInfos = _parserOptions.serverSyncInfos;
  var serverTimeOffset = serverSyncInfos !== undefined ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : undefined;
  /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */

  function parseQualityLevel(q, streamType) {
    var customAttributes = reduceChildren(q, function (acc, qName, qNode) {
      if (qName === "CustomAttributes") {
        acc.push.apply(acc, reduceChildren(qNode, function (cAttrs, cName, cNode) {
          if (cName === "Attribute") {
            var name = cNode.getAttribute("Name");
            var value = cNode.getAttribute("Value");

            if (name !== null && value !== null) {
              cAttrs.push(name + "=" + value);
            }
          }

          return cAttrs;
        }, []));
      }

      return acc;
    }, []);
    /**
     * @param {string} name
     * @returns {string|undefined}
     */

    function getAttribute(name) {
      var attr = q.getAttribute(name);
      return attr == null ? undefined : attr;
    }

    switch (streamType) {
      case "audio":
        {
          var audiotag = getAttribute("AudioTag");
          var bitsPerSample = getAttribute("BitsPerSample");
          var channels = getAttribute("Channels");
          var codecPrivateData = getAttribute("CodecPrivateData");
          var fourCC = getAttribute("FourCC");
          var packetSize = getAttribute("PacketSize");
          var samplingRate = getAttribute("SamplingRate");
          var bitrateAttr = getAttribute("Bitrate");
          var bitrate = bitrateAttr === undefined ? 0 : isNaN(parseInt(bitrateAttr, 10)) ? 0 : parseInt(bitrateAttr, 10);

          if (fourCC !== undefined && MIME_TYPES[fourCC] === undefined || codecPrivateData === undefined) {
            log["a" /* default */].warn("Smooth parser: Unsupported audio codec. Ignoring quality level.");
            return null;
          }

          var codecs = getAudioCodecs(codecPrivateData, fourCC);
          return {
            audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
            bitrate: bitrate,
            bitsPerSample: bitsPerSample !== undefined ? parseInt(bitsPerSample, 10) : bitsPerSample,
            channels: channels !== undefined ? parseInt(channels, 10) : channels,
            codecPrivateData: codecPrivateData,
            codecs: codecs,
            customAttributes: customAttributes,
            mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
            packetSize: packetSize !== undefined ? parseInt(packetSize, 10) : packetSize,
            samplingRate: samplingRate !== undefined ? parseInt(samplingRate, 10) : samplingRate
          };
        }

      case "video":
        {
          var _codecPrivateData = getAttribute("CodecPrivateData");

          var _fourCC = getAttribute("FourCC");

          var width = getAttribute("MaxWidth");
          var height = getAttribute("MaxHeight");

          var _bitrateAttr = getAttribute("Bitrate");

          var _bitrate = _bitrateAttr === undefined ? 0 : isNaN(parseInt(_bitrateAttr, 10)) ? 0 : parseInt(_bitrateAttr, 10);

          if (_fourCC !== undefined && MIME_TYPES[_fourCC] === undefined || _codecPrivateData === undefined) {
            log["a" /* default */].warn("Smooth parser: Unsupported video codec. Ignoring quality level.");
            return null;
          }

          var _codecs = getVideoCodecs(_codecPrivateData);

          return {
            bitrate: _bitrate,
            customAttributes: customAttributes,
            mimeType: _fourCC !== undefined ? MIME_TYPES[_fourCC] : _fourCC,
            codecPrivateData: _codecPrivateData,
            codecs: _codecs,
            width: width !== undefined ? parseInt(width, 10) : undefined,
            height: height !== undefined ? parseInt(height, 10) : undefined
          };
        }

      case "text":
        {
          var _codecPrivateData2 = getAttribute("CodecPrivateData");

          var _fourCC2 = getAttribute("FourCC");

          var _bitrateAttr2 = getAttribute("Bitrate");

          var _bitrate2 = _bitrateAttr2 === undefined ? 0 : isNaN(parseInt(_bitrateAttr2, 10)) ? 0 : parseInt(_bitrateAttr2, 10);

          return {
            bitrate: _bitrate2,
            customAttributes: customAttributes,
            mimeType: _fourCC2 !== undefined ? MIME_TYPES[_fourCC2] : _fourCC2,
            codecPrivateData: Object(take_first_set["a" /* default */])(_codecPrivateData2, "")
          };
        }

      default:
        log["a" /* default */].error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
        return null;
    }
  }
  /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */


  function parseAdaptation(args) {
    var root = args.root,
        timescale = args.timescale,
        rootURL = args.rootURL,
        protections = args.protections,
        timeShiftBufferDepth = args.timeShiftBufferDepth,
        manifestReceivedTime = args.manifestReceivedTime,
        isLive = args.isLive;
    var timescaleAttr = root.getAttribute("Timescale");

    var _timescale = timescaleAttr === null ? timescale : isNaN(+timescaleAttr) ? timescale : +timescaleAttr;

    var typeAttribute = root.getAttribute("Type");

    if (typeAttribute === null) {
      throw new Error("StreamIndex without type.");
    }

    if (!Object(array_includes["a" /* default */])(KNOWN_ADAPTATION_TYPES, typeAttribute)) {
      log["a" /* default */].warn("Smooth Parser: Unrecognized adaptation type:", typeAttribute);
    }

    var adaptationType = typeAttribute;
    var subType = root.getAttribute("Subtype");
    var language = root.getAttribute("Language");
    var baseURLAttr = root.getAttribute("Url");
    var baseURL = baseURLAttr === null ? "" : baseURLAttr;

    if (false) {}

    var _reduceChildren = reduceChildren(root, function (res, _name, node) {
      switch (_name) {
        case "QualityLevel":
          var qualityLevel = parseQualityLevel(node, adaptationType);

          if (qualityLevel === null) {
            return res;
          } // filter out video qualityLevels with small bitrates


          if (adaptationType !== "video" || qualityLevel.bitrate > minRepresentationBitrate) {
            res.qualityLevels.push(qualityLevel);
          }

          break;

        case "c":
          res.cNodes.push(node);
          break;
      }

      return res;
    }, {
      qualityLevels: [],
      cNodes: []
    }),
        qualityLevels = _reduceChildren.qualityLevels,
        cNodes = _reduceChildren.cNodes;

    var index = {
      timeline: parseCNodes(cNodes),
      timescale: _timescale
    }; // we assume that all qualityLevels have the same
    // codec and mimeType

    Object(assert["b" /* default */])(qualityLevels.length !== 0, "Adaptation should have at least one playable representation.");
    var adaptationID = adaptationType + (Object(is_non_empty_string["a" /* default */])(language) ? "_" + language : "");
    var representations = qualityLevels.map(function (qualityLevel) {
      var path = Object(resolve_url["a" /* default */])(rootURL, baseURL);
      var repIndex = {
        timeline: index.timeline,
        timescale: index.timescale,
        media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate, qualityLevel.customAttributes),
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      };
      var mimeType = Object(is_non_empty_string["a" /* default */])(qualityLevel.mimeType) ? qualityLevel.mimeType : DEFAULT_MIME_TYPES[adaptationType];
      var codecs = qualityLevel.codecs;
      var id = adaptationID + "_" + (adaptationType != null ? adaptationType + "-" : "") + (mimeType != null ? mimeType + "-" : "") + (codecs != null ? codecs + "-" : "") + String(qualityLevel.bitrate);
      var keyIDs = [];
      var firstProtection;

      if (protections.length > 0) {
        firstProtection = protections[0];
        protections.forEach(function (protection) {
          var keyId = protection.keyId;
          protection.keySystems.forEach(function (keySystem) {
            keyIDs.push({
              keyId: keyId,
              systemId: keySystem.systemId
            });
          });
        });
      }

      var segmentPrivateInfos = {
        bitsPerSample: qualityLevel.bitsPerSample,
        channels: qualityLevel.channels,
        codecPrivateData: qualityLevel.codecPrivateData,
        packetSize: qualityLevel.packetSize,
        samplingRate: qualityLevel.samplingRate,
        // TODO set multiple protections here
        // instead of the first one
        protection: firstProtection != null ? {
          keyId: firstProtection.keyId,
          keySystems: firstProtection.keySystems
        } : undefined
      };
      var aggressiveMode = parserOptions.aggressiveMode == null ? DEFAULT_AGGRESSIVE_MODE : parserOptions.aggressiveMode;
      var reprIndex = new representation_index_SmoothRepresentationIndex(repIndex, {
        aggressiveMode: aggressiveMode,
        isLive: isLive,
        segmentPrivateInfos: segmentPrivateInfos
      });
      var representation = Object(object_assign["a" /* default */])({}, qualityLevel, {
        index: reprIndex,
        mimeType: mimeType,
        codecs: codecs,
        id: id
      });

      if (keyIDs.length > 0) {
        representation.contentProtections = {
          keyIds: keyIDs,
          initData: {}
        };
      }

      return representation;
    }); // TODO(pierre): real ad-insert support

    if (subType === "ADVT") {
      return null;
    }

    var parsedAdaptation = {
      id: adaptationID,
      type: adaptationType,
      representations: representations,
      language: language == null ? undefined : language
    };

    if (adaptationType === "text" && subType === "DESC") {
      parsedAdaptation.closedCaption = true;
    }

    return parsedAdaptation;
  }

  function parseFromDocument(doc, url, manifestReceivedTime) {
    var rootURL = Object(resolve_url["b" /* normalizeBaseURL */])(url == null ? "" : url);
    var root = doc.documentElement;

    if (root == null || root.nodeName !== "SmoothStreamingMedia") {
      throw new Error("document root should be SmoothStreamingMedia");
    }

    var majorVersionAttr = root.getAttribute("MajorVersion");
    var minorVersionAttr = root.getAttribute("MinorVersion");

    if (majorVersionAttr === null || minorVersionAttr === null || !/^[2]-[0-2]$/.test(majorVersionAttr + "-" + minorVersionAttr)) {
      throw new Error("Version should be 2.0, 2.1 or 2.2");
    }

    var timescaleAttr = root.getAttribute("Timescale");
    var timescale = !Object(is_non_empty_string["a" /* default */])(timescaleAttr) ? 10000000 : isNaN(+timescaleAttr) ? 10000000 : +timescaleAttr;

    var _reduceChildren2 = reduceChildren(root, function (res, name, node) {
      switch (name) {
        case "Protection":
          {
            res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
            break;
          }

        case "StreamIndex":
          res.adaptationNodes.push(node);
          break;
      }

      return res;
    }, {
      adaptationNodes: [],
      protections: []
    }),
        protections = _reduceChildren2.protections,
        adaptationNodes = _reduceChildren2.adaptationNodes;

    var initialAdaptations = {};
    var isLive = parseBoolean(root.getAttribute("IsLive"));
    var timeShiftBufferDepth;

    if (isLive) {
      var dvrWindowLength = root.getAttribute("DVRWindowLength");

      if (dvrWindowLength != null && !isNaN(+dvrWindowLength) && +dvrWindowLength !== 0) {
        timeShiftBufferDepth = +dvrWindowLength / timescale;
      }
    }

    var adaptations = adaptationNodes.reduce(function (acc, node) {
      var adaptation = parseAdaptation({
        root: node,
        rootURL: rootURL,
        timescale: timescale,
        protections: protections,
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      });

      if (adaptation === null) {
        return acc;
      }

      var type = adaptation.type;
      var adaps = acc[type];

      if (adaps === undefined) {
        acc[type] = [adaptation];
      } else {
        adaps.push(adaptation);
      }

      return acc;
    }, initialAdaptations);
    var suggestedPresentationDelay;
    var availabilityStartTime;
    var minimumTime;
    var maximumTime;
    var firstVideoAdaptation = adaptations.video !== undefined ? adaptations.video[0] : undefined;
    var firstAudioAdaptation = adaptations.audio !== undefined ? adaptations.audio[0] : undefined;
    var firstTimeReference;
    var lastTimeReference;

    if (firstVideoAdaptation !== undefined || firstAudioAdaptation !== undefined) {
      var firstTimeReferences = [];
      var lastTimeReferences = [];

      if (firstVideoAdaptation !== undefined) {
        var firstVideoRepresentation = firstVideoAdaptation.representations[0];

        if (firstVideoRepresentation !== undefined) {
          var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();
          var lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();

          if (firstVideoTimeReference != null) {
            firstTimeReferences.push(firstVideoTimeReference);
          }

          if (lastVideoTimeReference != null) {
            lastTimeReferences.push(lastVideoTimeReference);
          }
        }
      }

      if (firstAudioAdaptation !== undefined) {
        var firstAudioRepresentation = firstAudioAdaptation.representations[0];

        if (firstAudioRepresentation !== undefined) {
          var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();
          var lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();

          if (firstAudioTimeReference != null) {
            firstTimeReferences.push(firstAudioTimeReference);
          }

          if (lastAudioTimeReference != null) {
            lastTimeReferences.push(lastAudioTimeReference);
          }
        }
      }

      if (firstTimeReferences.length > 0) {
        firstTimeReference = Math.max.apply(Math, firstTimeReferences);
      }

      if (lastTimeReferences.length > 0) {
        lastTimeReference = Math.min.apply(Math, lastTimeReferences);
      }
    }

    var manifestDuration = root.getAttribute("Duration");
    var duration = manifestDuration != null && +manifestDuration !== 0 ? +manifestDuration / timescale : undefined;

    if (isLive) {
      suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;
      availabilityStartTime = referenceDateTime;
      var time = performance.now();
      maximumTime = {
        isContinuous: true,
        value: lastTimeReference != null ? lastTimeReference : Date.now() / 1000 - availabilityStartTime,
        time: time
      };

      if (timeShiftBufferDepth == null) {
        // infinite buffer
        minimumTime = {
          isContinuous: false,
          value: firstTimeReference != null ? firstTimeReference : availabilityStartTime,
          time: time
        };
      } else {
        minimumTime = {
          isContinuous: true,
          value: Math.min(maximumTime.value - timeShiftBufferDepth + 5, maximumTime.value),
          time: time
        };
      }
    } else {
      minimumTime = {
        isContinuous: false,
        value: firstTimeReference != null ? firstTimeReference : 0,
        time: performance.now()
      };

      if (lastTimeReference !== undefined) {
        maximumTime = {
          isContinuous: false,
          value: lastTimeReference,
          time: performance.now()
        };
      } else if (duration !== undefined) {
        maximumTime = {
          isContinuous: false,
          value: minimumTime.value + duration,
          time: performance.now()
        };
      }
    }

    var periodStart = isLive ? 0 : minimumTime.value;
    var periodEnd = isLive ? undefined : maximumTime === null || maximumTime === void 0 ? void 0 : maximumTime.value;
    var manifest = {
      availabilityStartTime: availabilityStartTime === undefined ? 0 : availabilityStartTime,
      clockOffset: serverTimeOffset,
      isLive: isLive,
      isDynamic: isLive,
      maximumTime: maximumTime,
      minimumTime: minimumTime,
      periods: [{
        adaptations: adaptations,
        duration: periodEnd !== undefined ? periodEnd - periodStart : duration,
        end: periodEnd,
        id: "gen-smooth-period-0",
        start: periodStart
      }],
      suggestedPresentationDelay: suggestedPresentationDelay,
      transportType: "smooth",
      uris: url == null ? [] : [url]
    };
    checkManifestIDs(manifest);
    return manifest;
  }

  return parseFromDocument;
}

/* harmony default export */ var create_parser = (createSmoothStreamingParser);
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var smooth = (create_parser);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(28);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(21);

// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(101);

// EXTERNAL MODULE: ./src/transports/utils/return_parsed_manifest.ts
var return_parsed_manifest = __webpack_require__(126);

// EXTERNAL MODULE: ./src/transports/utils/text_manifest_loader.ts
var text_manifest_loader = __webpack_require__(124);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(239);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(35);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */

function parseTfrf(traf) {
  var tfrf = Object(get_box["e" /* getUuidContent */])(traf, 0xD4807EF2, 0xCA394695, 0x8E5426CB, 0x9E46A79F);

  if (tfrf === undefined) {
    return [];
  }

  var frags = [];
  var version = tfrf[0];
  var fragCount = tfrf[4];

  for (var i = 0; i < fragCount; i++) {
    var duration = void 0;
    var time = void 0;

    if (version === 1) {
      time = Object(byte_parsing["d" /* be8toi */])(tfrf, i * 16 + 5);
      duration = Object(byte_parsing["d" /* be8toi */])(tfrf, i * 16 + 5 + 8);
    } else {
      time = Object(byte_parsing["c" /* be4toi */])(tfrf, i * 8 + 5);
      duration = Object(byte_parsing["c" /* be4toi */])(tfrf, i * 8 + 5 + 4);
    }

    frags.push({
      time: time,
      duration: duration
    });
  }

  return frags;
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */

function parseTfxd(traf) {
  var tfxd = Object(get_box["e" /* getUuidContent */])(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);

  if (tfxd === undefined) {
    return undefined;
  }

  return {
    duration: Object(byte_parsing["d" /* be8toi */])(tfxd, 12),
    time: Object(byte_parsing["d" /* be8toi */])(tfxd, 4)
  };
}
// CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */

function extractTimingsInfos(data, isChunked, segment, isLive) {
  var nextSegments = [];
  var chunkInfos;
  var tfxdSegment;
  var tfrfSegments;

  if (isLive) {
    var traf = Object(read["c" /* getTRAF */])(data);

    if (traf !== null) {
      tfrfSegments = parseTfrf(traf);
      tfxdSegment = parseTfxd(traf);
    } else {
      log["a" /* default */].warn("smooth: could not find traf atom");
    }
  }

  if (tfrfSegments !== undefined) {
    for (var i = 0; i < tfrfSegments.length; i++) {
      nextSegments.push({
        time: tfrfSegments[i].time,
        duration: tfrfSegments[i].duration,
        timescale: segment.timescale
      });
    }
  }

  if (tfxdSegment !== undefined) {
    chunkInfos = {
      time: tfxdSegment.time,
      duration: tfxdSegment.duration,
      timescale: segment.timescale
    };
    return {
      nextSegments: nextSegments,
      chunkInfos: chunkInfos
    };
  }

  if (isChunked) {
    return {
      nextSegments: nextSegments,
      chunkInfos: null
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration / 4);
  var trunDuration = Object(utils["a" /* getDurationFromTrun */])(data);

  if (trunDuration !== undefined && (Object(is_null_or_undefined["a" /* default */])(segment.duration) || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {
    chunkInfos = {
      time: segment.time,
      duration: trunDuration,
      timescale: segment.timescale
    };
  } else {
    chunkInfos = {
      time: segment.time,
      duration: segment.duration,
      timescale: segment.timescale
    };
  }

  return {
    nextSegments: nextSegments,
    chunkInfos: chunkInfos
  };
}
// EXTERNAL MODULE: ./src/compat/can_patch_isobmff.ts
var can_patch_isobmff = __webpack_require__(166);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/create_box.ts
var create_box = __webpack_require__(180);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */

function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
  return Object(create_box["a" /* createBox */])("avc1", Object(byte_parsing["e" /* concat */])(6, // 6 bytes reserved
  Object(byte_parsing["g" /* itobe2 */])(1), 16, // drefIdx + QuickTime reserved, zeroes
  Object(byte_parsing["g" /* itobe2 */])(width), // size 2 w
  Object(byte_parsing["g" /* itobe2 */])(height), // size 2 h
  Object(byte_parsing["g" /* itobe2 */])(hRes), 2, // reso 4 h
  Object(byte_parsing["g" /* itobe2 */])(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  Object(string_parsing["f" /* strToUtf8 */])(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  Object(byte_parsing["g" /* itobe2 */])(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc // avcc atom,
  ));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */


function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
  return Object(create_box["a" /* createBox */])("encv", Object(byte_parsing["e" /* concat */])(6, // 6 bytes reserved
  Object(byte_parsing["g" /* itobe2 */])(1), 16, // drefIdx + QuickTime reserved, zeroes
  Object(byte_parsing["g" /* itobe2 */])(width), // size 2 w
  Object(byte_parsing["g" /* itobe2 */])(height), // size 2 h
  Object(byte_parsing["g" /* itobe2 */])(hRes), 2, // reso 4 h
  Object(byte_parsing["g" /* itobe2 */])(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  Object(string_parsing["f" /* strToUtf8 */])(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  Object(byte_parsing["g" /* itobe2 */])(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc, // avcc atom,
  sinf));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */


function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
  return Object(create_box["a" /* createBox */])("mp4a", Object(byte_parsing["e" /* concat */])(6, Object(byte_parsing["g" /* itobe2 */])(drefIdx), 8, Object(byte_parsing["g" /* itobe2 */])(channelsCount), Object(byte_parsing["g" /* itobe2 */])(sampleSize), 2, Object(byte_parsing["g" /* itobe2 */])(packetSize), Object(byte_parsing["g" /* itobe2 */])(sampleRate), 2, esds));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */


function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
  return Object(create_box["a" /* createBox */])("enca", Object(byte_parsing["e" /* concat */])(6, Object(byte_parsing["g" /* itobe2 */])(drefIdx), 8, Object(byte_parsing["g" /* itobe2 */])(channelsCount), Object(byte_parsing["g" /* itobe2 */])(sampleSize), 2, Object(byte_parsing["g" /* itobe2 */])(packetSize), Object(byte_parsing["g" /* itobe2 */])(sampleRate), 2, esds, sinf));
}
/**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */


function createDREFBox(url) {
  // only one description here... FIXME
  return Object(create_box["a" /* createBox */])("dref", Object(byte_parsing["e" /* concat */])(7, [1], url));
}
/**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */


function createFTYPBox(majorBrand, brands) {
  return Object(create_box["a" /* createBox */])("ftyp", byte_parsing["e" /* concat */].apply(null, [Object(string_parsing["f" /* strToUtf8 */])(majorBrand), [0, 0, 0, 1]].concat(brands.map(string_parsing["f" /* strToUtf8 */]))));
}
/**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */


function createSCHMBox(schemeType, schemeVersion) {
  return Object(create_box["a" /* createBox */])("schm", Object(byte_parsing["e" /* concat */])(4, Object(string_parsing["f" /* strToUtf8 */])(schemeType), Object(byte_parsing["h" /* itobe4 */])(schemeVersion)));
}
/**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */


function createTfdtBox(decodeTime) {
  return Object(create_box["a" /* createBox */])("tfdt", Object(byte_parsing["e" /* concat */])([1, 0, 0, 0], Object(byte_parsing["i" /* itobe8 */])(decodeTime)));
}
/**
 * @returns {Uint8Array}
 */


function createVMHDBox() {
  var arr = new Uint8Array(12);
  arr[3] = 1; // QuickTime...

  return Object(create_box["a" /* createBox */])("vmhd", arr);
}
/**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createTREXBox(trackId) {
  // default sample desc idx = 1
  return Object(create_box["a" /* createBox */])("trex", Object(byte_parsing["e" /* concat */])(4, Object(byte_parsing["h" /* itobe4 */])(trackId), [0, 0, 0, 1], 12));
}
/**
 * @param {Number} length
 * @returns {Uint8Array}
 */


function createFreeBox(length) {
  return Object(create_box["a" /* createBox */])("free", new Uint8Array(length - 8));
}
/**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */


function createESDSBox(stream, codecPrivateData) {
  return Object(create_box["a" /* createBox */])("esds", Object(byte_parsing["e" /* concat */])(4, [0x03, 0x19], Object(byte_parsing["g" /* itobe2 */])(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], Object(string_parsing["c" /* hexToBytes */])(codecPrivateData), [0x06, 0x01, 0x02]));
}
/**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */


function createFRMABox(dataFormat) {
  return Object(create_box["a" /* createBox */])("frma", Object(string_parsing["f" /* strToUtf8 */])(dataFormat));
}
/**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */


function createAVCCBox(sps, pps, nalLen) {
  var nal = nalLen === 2 ? 0x1 : nalLen === 4 ? 0x3 : 0x0; // Deduce AVC Profile from SPS

  var h264Profile = sps[1];
  var h264CompatibleProfile = sps[2];
  var h264Level = sps[3];
  return Object(create_box["a" /* createBox */])("avcC", Object(byte_parsing["e" /* concat */])([1, h264Profile, h264CompatibleProfile, h264Level, 0x3F << 2 | nal, 0xE0 | 1], Object(byte_parsing["g" /* itobe2 */])(sps.length), sps, [1], Object(byte_parsing["g" /* itobe2 */])(pps.length), pps));
}
/**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */


function createHDLRBox(type) {
  var name;
  var handlerName;

  switch (type) {
    case "video":
      name = "vide";
      handlerName = "VideoHandler";
      break;

    case "audio":
      name = "soun";
      handlerName = "SoundHandler";
      break;

    default:
      name = "hint";
      handlerName = "";
      break;
  }

  return Object(create_box["a" /* createBox */])("hdlr", Object(byte_parsing["e" /* concat */])(8, Object(string_parsing["f" /* strToUtf8 */])(name), 12, Object(string_parsing["f" /* strToUtf8 */])(handlerName), 1 // handler name is C-style string (0 terminated)
  ));
}
/**
 * @param {number} timescale
 * @returns {Uint8Array}
 */


function createMDHDBox(timescale) {
  return Object(create_box["a" /* createBox */])("mdhd", Object(byte_parsing["e" /* concat */])(12, Object(byte_parsing["h" /* itobe4 */])(timescale), 8));
}
/**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createMVHDBox(timescale, trackId) {
  return Object(create_box["a" /* createBox */])("mvhd", Object(byte_parsing["e" /* concat */])(12, Object(byte_parsing["h" /* itobe4 */])(timescale), 4, [0, 1], 2, // we assume rate = 1;
  [1, 0], 10, // we assume volume = 100%;
  [0, 1], 14, // default matrix
  [0, 1], 14, // default matrix
  [64, 0, 0, 0], 26, Object(byte_parsing["g" /* itobe2 */])(trackId + 1) // next trackId (=trackId + 1);
  ));
}
/**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
 * @returns {Uint8Array}
 */


function createPSSHBox(systemId, privateData, keyIds) {
  if (privateData === void 0) {
    privateData = new Uint8Array(0);
  }

  if (keyIds === void 0) {
    keyIds = new Uint8Array(0);
  }

  var _systemId = systemId.replace(/-/g, "");

  if (_systemId.length !== 32) {
    throw new Error("HSS: wrong system id length");
  }

  var version;
  var kidList;
  var kidCount = keyIds.length;

  if (kidCount > 0) {
    version = 1;
    kidList = byte_parsing["e" /* concat */].apply(void 0, [Object(byte_parsing["h" /* itobe4 */])(kidCount)].concat(keyIds));
  } else {
    version = 0;
    kidList = [];
  }

  return Object(create_box["a" /* createBox */])("pssh", Object(byte_parsing["e" /* concat */])([version, 0, 0, 0], Object(string_parsing["c" /* hexToBytes */])(_systemId), kidList, Object(byte_parsing["h" /* itobe4 */])(privateData.length), privateData));
}
/**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */


function createSAIOBox(mfhd, tfhd, tfdt, trun) {
  return Object(create_box["a" /* createBox */])("saio", Object(byte_parsing["e" /* concat */])(4, [0, 0, 0, 1], // ??
  Object(byte_parsing["h" /* itobe4 */])(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
}
/**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */


function createSAIZBox(sencContent) {
  if (sencContent.length === 0) {
    return Object(create_box["a" /* createBox */])("saiz", new Uint8Array(0));
  }

  var flags = Object(byte_parsing["c" /* be4toi */])(sencContent, 0);
  var entries = Object(byte_parsing["c" /* be4toi */])(sencContent, 4);
  var arr = new Uint8Array(entries + 9);
  arr.set(Object(byte_parsing["h" /* itobe4 */])(entries), 5);
  var i = 9;
  var j = 8;
  var pairsCnt;
  var pairsLen;

  while (j < sencContent.length) {
    j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
    // if we have extradata for each entry

    if ((flags & 0x2) === 0x2) {
      pairsLen = 2;
      pairsCnt = Object(byte_parsing["a" /* be2toi */])(sencContent, j);
      j += pairsCnt * 6 + 2;
    } else {
      pairsCnt = 0;
      pairsLen = 0;
    }

    arr[i] = pairsCnt * 6 + 8 + pairsLen;
    i++;
  }

  return Object(create_box["a" /* createBox */])("saiz", arr);
}
/**
 * @returns {Uint8Array}
 */


function createSMHDBox() {
  return Object(create_box["a" /* createBox */])("smhd", new Uint8Array(8));
}
/**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */


function createSTSDBox(reps) {
  // only one description here... FIXME
  var arrBase = [7, [reps.length]];
  return Object(create_box["a" /* createBox */])("stsd", byte_parsing["e" /* concat */].apply(void 0, arrBase.concat(reps)));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createTKHDBox(width, height, trackId) {
  return Object(create_box["a" /* createBox */])("tkhd", Object(byte_parsing["e" /* concat */])(Object(byte_parsing["h" /* itobe4 */])(1 + 2 + 4), 8, // we assume track is enabled,
  // in media and in preview.
  Object(byte_parsing["h" /* itobe4 */])(trackId), 20, // we assume trackId = 1;
  [1, 0, 0, 0], // we assume volume = 100%;
  [0, 1, 0, 0], 12, // default matrix
  [0, 1, 0, 0], 12, // default matrix
  [64, 0, 0, 0], // ??
  Object(byte_parsing["g" /* itobe2 */])(width), 2, // width (TODO handle fixed)
  Object(byte_parsing["g" /* itobe2 */])(height), 2 // height (TODO handle fixed)
  ));
}
/**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */


function createTENCBox(algId, ivSize, keyId) {
  return Object(create_box["a" /* createBox */])("tenc", Object(byte_parsing["e" /* concat */])(6, [algId, ivSize], keyId));
}


// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
  var trafs = [tfhd, tfdt, trun];

  if (senc !== undefined) {
    trafs.push(Object(create_box["a" /* createBox */])("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun));
  }

  return Object(create_box["b" /* createBoxWithChildren */])("traf", trafs);
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update ISOBMFF Segment downloaded in Smooth Streaming so it is playable on
 * the browser.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */

function patchSegment(segment, decodeTime) {
  var oldMoofOffsets = Object(get_box["c" /* getBoxOffsets */])(segment, 0x6D6F6F66
  /* moof */
  );

  if (oldMoofOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var oldMoofContent = segment.subarray(oldMoofOffsets[1], oldMoofOffsets[2]);
  var mfhdBox = Object(get_box["a" /* getBox */])(oldMoofContent, 0x6D666864
  /* mfhd */
  );
  var trafContent = Object(get_box["b" /* getBoxContent */])(oldMoofContent, 0x74726166
  /* traf */
  );

  if (trafContent === null || mfhdBox === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var tfhdOffsets = Object(get_box["c" /* getBoxOffsets */])(trafContent, 0x74666864
  /* tfhd */
  );
  var oldTrunOffsets = Object(get_box["c" /* getBoxOffsets */])(trafContent, 0x7472756E
  /* trun */
  );

  if (tfhdOffsets === null || oldTrunOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var tfhdBox = trafContent.subarray(tfhdOffsets[0], tfhdOffsets[2]);
  var oldTrunBox = trafContent.subarray(oldTrunOffsets[0], oldTrunOffsets[2]); // force trackId=1 since trackIds are not always reliable...

  tfhdBox.set([0, 0, 0, 1], tfhdOffsets[1] - tfhdOffsets[0] + 4
  /* version + flags */
  );
  var tfdtBox = createTfdtBox(decodeTime);
  var newTrunBox = updateTrunDataOffset(oldTrunBox, oldTrunOffsets[1] - oldTrunOffsets[0]);
  var sencContent = Object(get_box["e" /* getUuidContent */])(trafContent, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
  var newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
  var newMoof = Object(create_box["b" /* createBoxWithChildren */])("moof", [mfhdBox, newTrafBox]);
  var newMoofOffsets = Object(get_box["c" /* getBoxOffsets */])(newMoof, 0x6D6F6F66
  /* moof */
  );
  var newTrafOffsets = Object(get_box["c" /* getBoxOffsets */])(newTrafBox, 0x74726166
  /* traf */
  );
  var newTrunOffsets = Object(get_box["c" /* getBoxOffsets */])(newTrunBox, 0x7472756E
  /* trun */
  );

  if (newMoofOffsets === null || newTrafOffsets === null || newTrunOffsets === null) {
    throw new Error("Smooth: Invalid moof, trun or traf generation");
  }
  /** index of the `data_offset` property from the trun box in the whole "moof". */


  var indexOfTrunDataOffsetInMoof =
  /* new moof size + name */
  +(newMoofOffsets[1] - newMoofOffsets[0]) + mfhdBox.length + (
  /* new traf size + name */
  newTrafOffsets[1] - newTrafOffsets[0]) + tfhdBox.length + tfdtBox.length + (
  /* new trun size + name */
  newTrunOffsets[1] - newTrunOffsets[0]) + 8
  /* trun version + flags + `sample_count` */
  ;
  var oldMoofLength = oldMoofOffsets[2] - oldMoofOffsets[0];
  var newMoofSizeDiff = newMoof.length - oldMoofLength;
  var oldMdatOffset = Object(get_box["c" /* getBoxOffsets */])(segment, 0x6D646174
  /* "mdat" */
  );

  if (oldMdatOffset === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  if (Object(can_patch_isobmff["a" /* default */])() && (newMoofSizeDiff === 0 || newMoofSizeDiff <= -8)) {
    // patch trun data_offset
    var mdatContentOffset = oldMdatOffset[1];
    newMoof.set(Object(byte_parsing["h" /* itobe4 */])(mdatContentOffset), indexOfTrunDataOffsetInMoof);
    segment.set(newMoof, oldMoofOffsets[0]); // add "free" box for the remaining space

    if (newMoofSizeDiff <= -8) {
      segment.set(createFreeBox(-newMoofSizeDiff), newMoof.length);
    }

    return segment;
  } else {
    // patch trun data_offset
    var _mdatContentOffset = oldMdatOffset[1] + newMoofSizeDiff;

    newMoof.set(Object(byte_parsing["h" /* itobe4 */])(_mdatContentOffset), indexOfTrunDataOffsetInMoof);
    var newSegment = new Uint8Array(segment.length + newMoofSizeDiff);
    var beforeMoof = segment.subarray(0, oldMoofOffsets[0]);
    var afterMoof = segment.subarray(oldMoofOffsets[2], segment.length);
    newSegment.set(beforeMoof, 0);
    newSegment.set(newMoof, beforeMoof.length);
    newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
    return newSegment;
  }
}
/**
 * Update `trun` box given or create a new one from it to add a data offset
 * flag and the corresponding space to set a data offset.
 * Do not do anything if the flag is already set.
 *
 * Note that the `oldTrunBox` given should not be mutated by this function but
 * the returned value CAN point to the exact same `Uint8Array`.
 *
 * @param {Uint8Array} oldTrunBox - The whole original trun box
 * @param {number} initialDataOffset - Offset at which the first value of the
 * "trun" box (the "version") is set.
 * @returns {Uint8Array}
 */

function updateTrunDataOffset(oldTrunBox, initialDataOffset) {
  var trunHasDataOffset = (oldTrunBox[initialDataOffset + 3
  /* last flag */
  ] & 0x01) > 0;

  if (trunHasDataOffset) {
    return oldTrunBox;
  } // If no data_offset is present, we create another "trun" with one


  var newTrunBox = new Uint8Array(oldTrunBox.length + 4); // copy size + name + version=1 + flags=3 + sample_count=4

  newTrunBox.set(oldTrunBox.subarray(0, initialDataOffset + 8), 0); // add data_offset flag

  newTrunBox[initialDataOffset + 3] = newTrunBox[initialDataOffset + 3] | 0x01;
  newTrunBox.set([0, 0, 0, 0], initialDataOffset + 8); // add data offset
  // add the rest

  newTrunBox.set(oldTrunBox.subarray(initialDataOffset + 8, oldTrunBox.length), initialDataOffset + 12);
  return Object(utils["e" /* updateBoxLength */])(newTrunBox); // update the trun box's length
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(50);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */

function createMOOVBox(mvhd, mvex, trak, pssList) {
  var children = [mvhd, mvex, trak];
  pssList.forEach(function (pss) {
    var pssh = createPSSHBox(pss.systemId, pss.privateData, pss.keyIds);
    children.push(pssh);
  });
  return Object(create_box["b" /* createBoxWithChildren */])("moov", children);
}
/**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */


function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
  var stbl = Object(create_box["b" /* createBoxWithChildren */])("stbl", [stsd, Object(create_box["a" /* createBox */])("stts", new Uint8Array(0x08)), Object(create_box["a" /* createBox */])("stsc", new Uint8Array(0x08)), Object(create_box["a" /* createBox */])("stsz", new Uint8Array(0x0C)), Object(create_box["a" /* createBox */])("stco", new Uint8Array(0x08))]);
  var url = Object(create_box["a" /* createBox */])("url ", new Uint8Array([0, 0, 0, 1]));
  var dref = createDREFBox(url);
  var dinf = Object(create_box["b" /* createBoxWithChildren */])("dinf", [dref]);
  var minf = Object(create_box["b" /* createBoxWithChildren */])("minf", [mhd, dinf, stbl]);
  var hdlr = createHDLRBox(type);
  var mdhd = createMDHDBox(timescale); // this one is really important

  var mdia = Object(create_box["b" /* createBoxWithChildren */])("mdia", [mdhd, hdlr, minf]);
  var tkhd = createTKHDBox(width, height, 1);
  var trak = Object(create_box["b" /* createBoxWithChildren */])("trak", [tkhd, mdia]);
  var trex = createTREXBox(1);
  var mvex = Object(create_box["b" /* createBoxWithChildren */])("mvex", [trex]);
  var mvhd = createMVHDBox(timescale, 1); // in fact, we don't give a sh** about
  // this value :O

  var moov = createMOOVBox(mvhd, mvex, trak, pssList);
  var ftyp = createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
  return Object(byte_parsing["e" /* concat */])(ftyp, moov);
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */

function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
  var _pssList = pssList === undefined ? [] : pssList;

  var _codecPrivateData$spl = codecPrivateData.split("00000001"),
      spsHex = _codecPrivateData$spl[1],
      ppsHex = _codecPrivateData$spl[2];

  if (spsHex === undefined || ppsHex === undefined) {
    throw new Error("Smooth: unsupported codec private data.");
  }

  var sps = Object(string_parsing["c" /* hexToBytes */])(spsHex);
  var pps = Object(string_parsing["c" /* hexToBytes */])(ppsHex); // TODO NAL length is forced to 4

  var avcc = createAVCCBox(sps, pps, nalLength);
  var stsd;

  if (_pssList.length === 0 || keyId === undefined) {
    var avc1 = createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
    stsd = createSTSDBox([avc1]);
  } else {
    var tenc = createTENCBox(1, 8, keyId);
    var schi = Object(create_box["b" /* createBoxWithChildren */])("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("avc1");
    var sinf = Object(create_box["b" /* createBoxWithChildren */])("sinf", [frma, schm, schi]);
    var encv = createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
    stsd = createSTSDBox([encv]);
  }

  return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height, _pssList);
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */

var SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */

function getAacesHeader(type, frequency, chans) {
  var freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...

  var val;
  val = (type & 0x3F) << 0x4;
  val = (val | freq & 0x1F) << 0x4;
  val = (val | chans & 0x1F) << 0x3;
  return Object(string_parsing["a" /* bytesToHex */])(Object(byte_parsing["g" /* itobe2 */])(val));
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */

function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
  if (pssList === void 0) {
    pssList = [];
  }

  var _codecPrivateData = codecPrivateData.length === 0 ? getAacesHeader(2, sampleRate, channelsCount) : codecPrivateData;

  var esds = createESDSBox(1, _codecPrivateData);

  var stsd = function () {
    if (pssList.length === 0 || keyId === undefined) {
      var mp4a = createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);
      return createSTSDBox([mp4a]);
    }

    var tenc = createTENCBox(1, 8, keyId);
    var schi = Object(create_box["b" /* createBoxWithChildren */])("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("mp4a");
    var sinf = Object(create_box["b" /* createBoxWithChildren */])("sinf", [frma, schm, schi]);
    var enca = createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
    return createSTSDBox([enca]);
  }();

  return createInitSegment(timescale, "audio", stsd, createSMHDBox(), 0, 0, pssList);
}
// CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */

function regularSegmentLoader(_ref) {
  var url = _ref.url,
      segment = _ref.segment;
  var headers;
  var range = segment.range;

  if (Array.isArray(range)) {
    headers = {
      Range: Object(byte_range["a" /* default */])(range)
    };
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    headers: headers,
    sendProgressEvents: true
  });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */


var segment_loader_generateSegmentLoader = function generateSegmentLoader(customSegmentLoader) {
  return function (_ref2) {
    var segment = _ref2.segment,
        representation = _ref2.representation,
        adaptation = _ref2.adaptation,
        period = _ref2.period,
        manifest = _ref2.manifest,
        url = _ref2.url;

    if (segment.isInit) {
      if (segment.privateInfos === undefined || segment.privateInfos.smoothInit === undefined) {
        throw new Error("Smooth: Invalid segment format");
      }

      var smoothInitPrivateInfos = segment.privateInfos.smoothInit;
      var responseData;
      var codecPrivateData = smoothInitPrivateInfos.codecPrivateData,
          _smoothInitPrivateInf = smoothInitPrivateInfos.protection,
          protection = _smoothInitPrivateInf === void 0 ? {
        keyId: undefined,
        keySystems: undefined
      } : _smoothInitPrivateInf;

      if (codecPrivateData === undefined) {
        throw new Error("Smooth: no codec private data.");
      }

      switch (adaptation.type) {
        case "video":
          {
            var _representation$width = representation.width,
                width = _representation$width === void 0 ? 0 : _representation$width,
                _representation$heigh = representation.height,
                height = _representation$heigh === void 0 ? 0 : _representation$heigh;
            responseData = createVideoInitSegment(segment.timescale, width, height, 72, 72, 4, // vRes, hRes, nal
            codecPrivateData, protection.keyId, protection.keySystems);
            break;
          }

        case "audio":
          {
            var _smoothInitPrivateInf2 = smoothInitPrivateInfos.channels,
                channels = _smoothInitPrivateInf2 === void 0 ? 0 : _smoothInitPrivateInf2,
                _smoothInitPrivateInf3 = smoothInitPrivateInfos.bitsPerSample,
                bitsPerSample = _smoothInitPrivateInf3 === void 0 ? 0 : _smoothInitPrivateInf3,
                _smoothInitPrivateInf4 = smoothInitPrivateInfos.packetSize,
                packetSize = _smoothInitPrivateInf4 === void 0 ? 0 : _smoothInitPrivateInf4,
                _smoothInitPrivateInf5 = smoothInitPrivateInfos.samplingRate,
                samplingRate = _smoothInitPrivateInf5 === void 0 ? 0 : _smoothInitPrivateInf5;
            responseData = createAudioInitSegment(segment.timescale, channels, bitsPerSample, packetSize, samplingRate, codecPrivateData, protection.keyId, protection.keySystems);
            break;
          }

        default:
          if (false) {}

          responseData = new Uint8Array(0);
      }

      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: responseData
        }
      });
    } else if (url === null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    } else {
      var args = {
        adaptation: adaptation,
        manifest: manifest,
        period: period,
        representation: representation,
        segment: segment,
        transport: "smooth",
        url: url
      };

      if (typeof customSegmentLoader !== "function") {
        return regularSegmentLoader(args);
      }

      return new Observable["a" /* Observable */](function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */

        var resolve = function resolve(_args) {
          if (!hasFallbacked) {
            hasFinished = true;
            obs.next({
              type: "data-loaded",
              value: {
                responseData: _args.data,
                size: _args.size,
                duration: _args.duration
              }
            });
            obs.complete();
          }
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */


        var reject = function reject(err) {
          if (err === void 0) {
            err = {};
          }

          if (!hasFallbacked) {
            hasFinished = true;
            obs.error(err);
          }
        };

        var progress = function progress(_args) {
          if (!hasFallbacked) {
            obs.next({
              type: "progress",
              value: {
                duration: _args.duration,
                size: _args.size,
                totalSize: _args.totalSize
              }
            });
          }
        };

        var fallback = function fallback() {
          hasFallbacked = true; // HACK What is TypeScript/RxJS doing here??????

          /* tslint:disable deprecation */
          // @ts-ignore

          regularSegmentLoader(args).subscribe(obs);
          /* tslint:enable deprecation */
        };

        var callbacks = {
          reject: reject,
          resolve: resolve,
          fallback: fallback,
          progress: progress
        };
        var abort = customSegmentLoader(args, callbacks);
        return function () {
          if (!hasFinished && !hasFallbacked && typeof abort === "function") {
            abort();
          }
        };
      });
    }
  };
};

/* harmony default export */ var segment_loader = (segment_loader_generateSegmentLoader);
// CONCATENATED MODULE: ./src/transports/smooth/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ISM_REG = /(\.isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
/**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */

function extractISML(doc) {
  return doc.getElementsByTagName("media")[0].getAttribute("src");
}
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */


function extractToken(url) {
  var tokenMatch = url.match(TOKEN_REG);

  if (tokenMatch !== null) {
    var match = tokenMatch[1];

    if (match !== undefined) {
      return match;
    }
  }

  return "";
}
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */


function replaceToken(url, token) {
  if (Object(is_non_empty_string["a" /* default */])(token)) {
    return url.replace(TOKEN_REG, "?token=" + token);
  } else {
    return url.replace(TOKEN_REG, "");
  }
}
/**
 * @param {string} url
 * @returns {string}
 */


function resolveManifest(url) {
  if (ISM_REG.test(url)) {
    Object(warn_once["a" /* default */])("Giving a isml URL to loadVideo is deprecated." + " Please give the Manifest URL directly");
    return url.replace(ISM_REG, "$1/manifest$2");
  }

  return url;
}


// CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */

function addNextSegments(adaptation, nextSegments, dlSegment) {
  log["a" /* default */].debug("Smooth Parser: update segments information.");
  var representations = adaptation.representations;

  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];

    representation.index._addSegments(nextSegments, dlSegment);
  }
}

/* harmony default export */ var pipelines = (function (options) {
  var smoothManifestParser = smooth(options);
  var segmentLoader = segment_loader(options.segmentLoader);
  var manifestLoaderOptions = {
    customManifestLoader: options.manifestLoader
  };
  var manifestLoader = Object(text_manifest_loader["a" /* default */])(manifestLoaderOptions);
  var manifestPipeline = {
    resolver: function resolver(_ref) {
      var url = _ref.url;

      if (url === undefined) {
        return Object(of["a" /* of */])({
          url: undefined
        });
      } // TODO Remove WSX logic


      var resolving;

      if (WSX_REG.test(url)) {
        Object(warn_once["a" /* default */])("Giving WSX URL to loadVideo is deprecated." + " You should only give Manifest URLs.");
        resolving = Object(request["a" /* default */])({
          url: replaceToken(url, ""),
          responseType: "document"
        }).pipe(Object(map["a" /* map */])(function (_ref2) {
          var value = _ref2.value;
          var extractedURL = extractISML(value.responseData);

          if (extractedURL === null || extractedURL.length === 0) {
            throw new Error("Invalid ISML");
          }

          return extractedURL;
        }));
      } else {
        resolving = Object(of["a" /* of */])(url);
      }

      var token = extractToken(url);
      return resolving.pipe(Object(map["a" /* map */])(function (_url) {
        return {
          url: replaceToken(resolveManifest(_url), token)
        };
      }));
    },
    loader: manifestLoader,
    parser: function parser(_ref3) {
      var response = _ref3.response,
          reqURL = _ref3.url;
      var url = response.url === undefined ? reqURL : response.url;
      var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData; // TODO find a way to check if Document?

      var manifestReceivedTime = response.receivedTime;
      var parserResult = smoothManifestParser(data, url, manifestReceivedTime);
      var manifest = new src_manifest["a" /* default */](parserResult, {
        representationFilter: options.representationFilter,
        supplementaryImageTracks: options.supplementaryImageTracks,
        supplementaryTextTracks: options.supplementaryTextTracks
      });
      return Object(return_parsed_manifest["a" /* default */])(manifest, url);
    }
  };
  var segmentPipeline = {
    loader: function loader(content) {
      if (content.segment.isInit || options.checkMediaSegmentIntegrity !== true) {
        return segmentLoader(content);
      }

      return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (res) {
        if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null) {
          Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), content.segment.isInit);
        }
      }));
    },
    parser: function parser(_ref4) {
      var content = _ref4.content,
          response = _ref4.response;
      var segment = content.segment,
          representation = content.representation,
          adaptation = content.adaptation,
          manifest = content.manifest;
      var data = response.data,
          isChunked = response.isChunked;

      if (data === null) {
        if (segment.isInit) {
          var segmentProtections = representation.getProtectionsInitializationData();
          return Object(of["a" /* of */])({
            type: "parsed-init-segment",
            value: {
              initializationData: null,
              segmentProtections: segmentProtections,
              initTimescale: undefined
            }
          });
        }

        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data);

      if (segment.isInit) {
        var psshInfo = Object(take_pssh_out["a" /* default */])(responseBuffer);

        if (psshInfo.length > 0) {
          for (var i = 0; i < psshInfo.length; i++) {
            var _psshInfo$i = psshInfo[i],
                systemID = _psshInfo$i.systemID,
                psshData = _psshInfo$i.data;

            representation._addProtectionData("cenc", systemID, psshData);
          }
        }

        var _segmentProtections = representation.getProtectionsInitializationData();

        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: data,
            segmentProtections: _segmentProtections,
            // smooth init segments are crafted by hand.
            // Their timescale is the one from the manifest.
            initTimescale: segment.timescale
          }
        });
      }

      var _extractTimingsInfos = extractTimingsInfos(responseBuffer, isChunked, segment, manifest.isLive),
          nextSegments = _extractTimingsInfos.nextSegments,
          chunkInfos = _extractTimingsInfos.chunkInfos;

      if (chunkInfos === null) {
        throw new Error("Smooth Segment without time information");
      }

      var chunkData = patchSegment(responseBuffer, chunkInfos.time);

      if (nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: chunkData,
          chunkInfos: chunkInfos,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  var textTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          representation = _ref5.representation,
          url = _ref5.url;

      if (segment.isInit || url === null) {
        return Object(of["a" /* of */])({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      var isMP4 = isMP4EmbeddedTrack(representation);

      if (!isMP4 || options.checkMediaSegmentIntegrity !== true) {
        return Object(request["a" /* default */])({
          url: url,
          responseType: isMP4 ? "arraybuffer" : "text",
          sendProgressEvents: true
        });
      }

      return Object(request["a" /* default */])({
        url: url,
        responseType: "arraybuffer",
        sendProgressEvents: true
      }).pipe(Object(tap["a" /* tap */])(function (res) {
        if (res.type === "data-loaded") {
          Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), segment.isInit);
        }
      }));
    },
    parser: function parser(_ref6) {
      var content = _ref6.content,
          response = _ref6.response;
      var manifest = content.manifest,
          adaptation = content.adaptation,
          representation = content.representation,
          segment = content.segment;
      var language = adaptation.language;
      var _representation$mimeT = representation.mimeType,
          mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT,
          _representation$codec = representation.codec,
          codec = _representation$codec === void 0 ? "" : _representation$codec;
      var data = response.data,
          isChunked = response.isChunked;

      if (segment.isInit) {
        // text init segment has no use in HSS
        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: [],
            initTimescale: undefined
          }
        });
      }

      if (data === null) {
        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var nextSegments;
      var chunkInfos = null;
      var isMP4 = mimeType.indexOf("mp4") >= 0;

      var _sdStart;

      var _sdEnd;

      var _sdTimescale = 1;

      var _sdData;

      var _sdType;

      if (isMP4) {
        var chunkBytes;

        if (typeof data === "string") {
          chunkBytes = Object(string_parsing["f" /* strToUtf8 */])(data);
        } else {
          chunkBytes = data instanceof Uint8Array ? data : new Uint8Array(data);
        }

        var timings = extractTimingsInfos(chunkBytes, isChunked, segment, manifest.isLive);
        nextSegments = timings.nextSegments;
        chunkInfos = timings.chunkInfos;

        if (chunkInfos === null) {
          if (isChunked) {
            log["a" /* default */].warn("Smooth: Unavailable time data for current text track.");
          } else {
            _sdStart = segment.time;
            _sdEnd = _sdStart + segment.duration;
            _sdTimescale = segment.timescale;
          }
        } else {
          _sdStart = chunkInfos.time;
          _sdEnd = !Object(is_null_or_undefined["a" /* default */])(chunkInfos.duration) ? chunkInfos.time + chunkInfos.duration : undefined;
          _sdTimescale = chunkInfos.timescale;
        }

        var lcCodec = codec.toLowerCase();

        if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp" || lcCodec === "stpp.ttml.im1t") {
          _sdType = "ttml";
        } else if (lcCodec === "wvtt") {
          _sdType = "vtt";
        } else {
          throw new Error("could not find a text-track parser for the type " + mimeType);
        }

        var mdat = Object(read["a" /* getMDAT */])(chunkBytes);
        _sdData = mdat === null ? "" : Object(string_parsing["g" /* utf8ToStr */])(mdat);
      } else {
        var chunkString;

        if (typeof data !== "string") {
          var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
          chunkString = Object(string_parsing["g" /* utf8ToStr */])(bytesData);
        } else {
          chunkString = data;
        }

        var segmentTime = segment.time; // vod is simple WebVTT or TTML text

        _sdStart = segmentTime;
        _sdEnd = segmentTime + segment.duration;
        _sdTimescale = segment.timescale;

        switch (mimeType) {
          case "application/x-sami":
          case "application/smil":
            // TODO SMIL should be its own format, no?
            _sdType = "sami";
            break;

          case "application/ttml+xml":
            _sdType = "ttml";
            break;

          case "text/vtt":
            _sdType = "vtt";
            break;
        }

        if (_sdType === undefined) {
          var _lcCodec = codec.toLowerCase();

          if (_lcCodec === "srt") {
            _sdType = "srt";
          } else {
            throw new Error("could not find a text-track parser for the type " + mimeType);
          }
        }

        _sdData = chunkString;
      }

      if (chunkInfos !== null && Array.isArray(nextSegments) && nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      var chunkOffset = _sdStart === undefined ? 0 : _sdStart / _sdTimescale;
      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: {
            type: _sdType,
            data: _sdData,
            language: language,
            timescale: _sdTimescale,
            start: _sdStart,
            end: _sdEnd
          },
          chunkInfos: chunkInfos,
          chunkOffset: chunkOffset,
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  var imageTrackPipeline = {
    loader: function loader(_ref7) {
      var segment = _ref7.segment,
          url = _ref7.url;

      if (segment.isInit || url === null) {
        // image do not need an init segment. Passthrough directly to the parser
        return Object(of["a" /* of */])({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      return Object(request["a" /* default */])({
        url: url,
        responseType: "arraybuffer",
        sendProgressEvents: true
      });
    },
    parser: function parser(_ref8) {
      var response = _ref8.response,
          content = _ref8.content;
      var data = response.data,
          isChunked = response.isChunked;

      if (content.segment.isInit) {
        // image init segment has no use
        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: [],
            initTimescale: undefined
          }
        });
      }

      if (isChunked) {
        throw new Error("Image data should not be downloaded in chunks");
      } // TODO image Parsing should be more on the sourceBuffer side, no?


      if (data === null || features["a" /* default */].imageParser === null) {
        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var bifObject = features["a" /* default */].imageParser(new Uint8Array(data));
      var thumbsData = bifObject.thumbs;
      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: {
            data: thumbsData,
            start: 0,
            end: Number.MAX_VALUE,
            timescale: 1,
            type: "bif"
          },
          chunkInfos: {
            time: 0,
            duration: Number.MAX_VALUE,
            timescale: bifObject.timescale
          },
          chunkOffset: 0,
          segmentProtections: [],
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  return {
    manifest: manifestPipeline,
    audio: segmentPipeline,
    video: segmentPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */

function isMP4EmbeddedTrack(representation) {
  return typeof representation.mimeType === "string" && representation.mimeType.indexOf("mp4") >= 0;
}
// CONCATENATED MODULE: ./src/transports/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_smooth = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
var get_parameters = __webpack_require__(130);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(89);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts + 1 modules
var get_styling = __webpack_require__(41);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/nodes.ts
var nodes = __webpack_require__(66);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
var resolve_styles_inheritance = __webpack_require__(131);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(141);

// EXTERNAL MODULE: ./src/compat/add_class_name.ts
var add_class_name = __webpack_require__(170);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(17);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_extent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:extent` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} extent
 */

function applyExtent(element, extent) {
  var trimmedExtent = extent.trim();

  if (trimmedExtent === "auto") {
    return;
  }

  var splittedExtent = trimmedExtent.split(" ");

  if (splittedExtent.length !== 2) {
    return;
  }

  var firstExtent = regexps["c" /* REGXP_LENGTH */].exec(splittedExtent[0]);
  var secondExtent = regexps["c" /* REGXP_LENGTH */].exec(splittedExtent[1]);

  if (firstExtent !== null && secondExtent !== null) {
    if (firstExtent[2] === "px" || firstExtent[2] === "%" || firstExtent[2] === "em") {
      element.style.width = firstExtent[1] + firstExtent[2];
    } else if (firstExtent[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-width", firstExtent[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled extent unit:", firstExtent[2]);
    }

    if (secondExtent[2] === "px" || secondExtent[2] === "%" || secondExtent[2] === "em") {
      element.style.height = secondExtent[1] + secondExtent[2];
    } else if (secondExtent[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-height", secondExtent[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled extent unit:", secondExtent[2]);
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_font_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:fontSize` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} fontSize
 */

function applyFontSize(element, fontSize) {
  var trimmedFontSize = fontSize.trim();
  var splittedFontSize = trimmedFontSize.split(" ");

  if (splittedFontSize.length === 0) {
    return;
  }

  var firstFontSize = regexps["c" /* REGXP_LENGTH */].exec(splittedFontSize[0]);

  if (firstFontSize === null) {
    return;
  }

  if (firstFontSize[2] === "px" || firstFontSize[2] === "%" || firstFontSize[2] === "em") {
    element.style.fontSize = firstFontSize[1] + firstFontSize[2];
  } else if (firstFontSize[2] === "c") {
    element.style.position = "relative";
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", firstFontSize[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled fontSize unit:", firstFontSize[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_line_height.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} lineHeight
 */

function applyLineHeight(element, lineHeight) {
  var trimmedLineHeight = lineHeight.trim();

  if (trimmedLineHeight === "auto") {
    return;
  }

  var firstLineHeight = regexps["c" /* REGXP_LENGTH */].exec(trimmedLineHeight[0]);

  if (firstLineHeight === null) {
    return;
  }

  if (firstLineHeight[2] === "px" || firstLineHeight[2] === "%" || firstLineHeight[2] === "em") {
    element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];
  } else if (firstLineHeight[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-line-height", firstLineHeight[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled lineHeight unit:", firstLineHeight[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_origin.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} origin
 */

function applyOrigin(element, origin) {
  var trimmedOrigin = origin.trim();

  if (trimmedOrigin === "auto") {
    return;
  }

  var splittedOrigin = trimmedOrigin.split(" ");

  if (splittedOrigin.length !== 2) {
    return;
  }

  var firstOrigin = regexps["c" /* REGXP_LENGTH */].exec(splittedOrigin[0]);
  var secondOrigin = regexps["c" /* REGXP_LENGTH */].exec(splittedOrigin[1]);

  if (firstOrigin !== null && secondOrigin !== null) {
    if (firstOrigin[2] === "px" || firstOrigin[2] === "%" || firstOrigin[2] === "em") {
      element.style.left = firstOrigin[1] + firstOrigin[2];
    } else if (firstOrigin[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-left", firstOrigin[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled origin unit:", firstOrigin[2]);
    }

    if (secondOrigin[2] === "px" || secondOrigin[2] === "%" || secondOrigin[2] === "em") {
      element.style.top = secondOrigin[1] + secondOrigin[2];
    } else if (secondOrigin[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-top", secondOrigin[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled origin unit:", secondOrigin[2]);
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} padding
 */

function applyPadding(element, padding) {
  var trimmedPadding = padding.trim();
  var splittedPadding = trimmedPadding.split(" ");

  if (splittedPadding.length < 1) {
    return;
  }

  var firstPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[0]);

  if (firstPadding === null) {
    return;
  }

  if (firstPadding[2] === "px" || firstPadding[2] === "%" || firstPadding[2] === "em") {
    var firstPaddingValue = firstPadding[1] + firstPadding[2];

    if (splittedPadding.length === 1) {
      element.style.padding = firstPaddingValue;
    } else if (splittedPadding.length === 2) {
      element.style.paddingTop = firstPaddingValue;
      element.style.paddingBottom = firstPaddingValue;
    } else {
      element.style.paddingTop = firstPaddingValue;
    }
  } else if (firstPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");

    if (splittedPadding.length === 1) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
      element.setAttribute("data-proportional-padding-left", firstPadding[1]);
      element.setAttribute("data-proportional-padding-right", firstPadding[1]);
    } else if (splittedPadding.length === 2) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
    }
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", firstPadding[2]);
  }

  if (splittedPadding.length === 1) {
    return;
  }

  var secondPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[1]);

  if (secondPadding === null) {
    return;
  }

  if (secondPadding[2] === "px" || secondPadding[2] === "%" || secondPadding[2] === "em") {
    var secondPaddingValue = secondPadding[1] + secondPadding[2];

    if (splittedPadding.length < 4) {
      element.style.paddingLeft = secondPaddingValue;
      element.style.paddingRight = secondPaddingValue;
    } else {
      element.style.paddingRight = secondPaddingValue;
    }
  } else if (secondPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");

    if (splittedPadding.length < 4) {
      element.setAttribute("data-proportional-padding-left", secondPadding[1]);
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    }
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", secondPadding[2]);
  }

  if (splittedPadding.length === 2) {
    return;
  }

  var thirdPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[2]);

  if (thirdPadding === null) {
    return;
  }

  if (thirdPadding[2] === "px" || thirdPadding[2] === "%" || thirdPadding[2] === "em") {
    var thirdPaddingValue = thirdPadding[1] + thirdPadding[2];
    element.style.paddingBottom = thirdPaddingValue;
  } else if (thirdPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-padding-bottom", thirdPadding[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", thirdPadding[2]);
  }

  if (splittedPadding.length === 3) {
    return;
  }

  var fourthPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[3]);

  if (fourthPadding === null) {
    return;
  }

  if (fourthPadding[2] === "px" || fourthPadding[2] === "%" || fourthPadding[2] === "em") {
    var fourthPaddingValue = fourthPadding[1] + fourthPadding[2];
    element.style.paddingLeft = fourthPaddingValue;
  } else if (fourthPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-padding-left", fourthPadding[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", fourthPadding[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
  return "-1px -1px " + thickness + " " + color + "," + ("1px -1px " + thickness + " " + color + ",") + ("-1px 1px " + thickness + " " + color + ",") + ("1px 1px " + thickness + " " + color);
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */

function ttmlColorToCSSColor(color) {
  // TODO check all possible color fomats
  var regRes;
  regRes = regexps["b" /* REGXP_8_HEX_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1], 16)) + "," + String(parseInt(regRes[2], 16)) + "," + String(parseInt(regRes[3], 16)) + "," + String(parseInt(regRes[4], 16) / 255) + ")";
  }

  regRes = regexps["a" /* REGXP_4_HEX_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1] + regRes[1], 16)) + "," + String(parseInt(regRes[2] + regRes[2], 16)) + "," + String(parseInt(regRes[3] + regRes[3], 16)) + "," + String(parseInt(regRes[4] + regRes[4], 16) / 255) + ")";
  }

  regRes = regexps["f" /* REGXP_RGB_COLOR */].exec(color);

  if (regRes != null) {
    return "rgb(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + ")";
  }

  regRes = regexps["e" /* REGXP_RGBA_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + "," + String(+regRes[4] / 255) + ")";
  }

  return color;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











 // Styling which can be applied to <span> from any level upper.
// Added here as an optimization

var SPAN_LEVEL_ATTRIBUTES = ["color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption"]; // TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)

/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */

function applyTextStyle(element, style, shouldTrimWhiteSpace) {
  // applies to span
  var color = style.color;

  if (Object(is_non_empty_string["a" /* default */])(color)) {
    element.style.color = ttmlColorToCSSColor(color);
  } // applies to body, div, p, region, span


  var backgroundColor = style.backgroundColor;

  if (Object(is_non_empty_string["a" /* default */])(backgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
  } // applies to span


  var textOutline = style.textOutline;

  if (Object(is_non_empty_string["a" /* default */])(textOutline)) {
    var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
    var len = outlineData.length;

    if (len === 3) {
      var outlineColor = ttmlColorToCSSColor(outlineData[0]);
      var thickness = outlineData[1];
      element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
    } else if (Object(is_non_empty_string["a" /* default */])(color) && len === 1) {
      var _thickness = outlineData[0];
      element.style.textShadow = generateCSSTextOutline(color, _thickness);
    } else if (len === 2) {
      var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
      var isFirstArgANumber = /^[0-9]/.test(outlineData[0]); // XOR-ing to be sure we get what we have

      if (isFirstArgAColor !== isFirstArgANumber) {
        if (isFirstArgAColor) {
          var _outlineColor = ttmlColorToCSSColor(outlineData[0]);

          var _thickness2 = outlineData[1];
          element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
        } else if (Object(is_non_empty_string["a" /* default */])(color)) {
          var _thickness3 = outlineData[0];
          element.style.textShadow = generateCSSTextOutline(color, _thickness3);
        }
      }
    }
  } // applies to span


  var textDecoration = style.textDecoration;

  if (Object(is_non_empty_string["a" /* default */])(textDecoration)) {
    switch (textDecoration) {
      case "noUnderline":
      case "noLineThrough":
      case "noOverline":
        element.style.textDecoration = "none";
        break;

      case "lineThrough":
        element.style.textDecoration = "line-through";
        break;

      default:
        element.style.textDecoration = textDecoration;
        break;
    }
  } // applies to span


  var fontFamily = style.fontFamily;

  if (Object(is_non_empty_string["a" /* default */])(fontFamily)) {
    switch (fontFamily) {
      case "proportionalSansSerif":
        element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
        break;
      // TODO monospace or sans-serif or font with both?

      case "monospaceSansSerif":
      case "sansSerif":
        element.style.fontFamily = "sans-serif";
        break;

      case "monospaceSerif":
      case "default":
        element.style.fontFamily = "Courier New, Liberation Mono, monospace";
        break;
      // TODO font with both?

      case "proportionalSerif":
        element.style.fontFamily = "serif";
        break;

      default:
        element.style.fontFamily = fontFamily;
    }
  } // applies to span


  var fontStyle = style.fontStyle;

  if (Object(is_non_empty_string["a" /* default */])(fontStyle)) {
    element.style.fontStyle = fontStyle;
  } // applies to span


  var fontWeight = style.fontWeight;

  if (Object(is_non_empty_string["a" /* default */])(fontWeight)) {
    element.style.fontWeight = fontWeight;
  } // applies to span


  var fontSize = style.fontSize;

  if (Object(is_non_empty_string["a" /* default */])(fontSize)) {
    applyFontSize(element, fontSize);
  } else {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", "1");
  } // applies to p, span


  var direction = style.direction;

  if (Object(is_non_empty_string["a" /* default */])(direction)) {
    element.style.direction = direction;
  } // applies to p, span


  var unicodeBidi = style.unicodeBidi;

  if (Object(is_non_empty_string["a" /* default */])(unicodeBidi)) {
    switch (unicodeBidi) {
      case "bidiOverride":
        element.style.unicodeBidi = "bidi-override";
        break;

      case "embed":
        element.style.unicodeBidi = "embed";
        break;

      default:
        element.style.unicodeBidi = "normal";
    }
  } // applies to body, div, p, region, span


  var visibility = style.visibility;

  if (Object(is_non_empty_string["a" /* default */])(visibility)) {
    element.style.visibility = visibility;
  } // applies to body, div, p, region, span


  var display = style.display;

  if (display === "none") {
    element.style.display = "none";
  } // applies to body, div, p, region, span


  var wrapOption = style.wrapOption;
  element.style.whiteSpace = wrapOption === "noWrap" ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */


function applyGeneralStyle(element, style) {
  element.style.position = "absolute"; // applies to tt, region

  var extent = style.extent;

  if (Object(is_non_empty_string["a" /* default */])(extent)) {
    applyExtent(element, extent);
  } // applies to region


  var writingMode = style.writingMode;

  if (Object(is_non_empty_string["a" /* default */])(writingMode)) {// TODO
  } // applies to region


  var overflow = style.overflow;
  element.style.overflow = Object(is_non_empty_string["a" /* default */])(overflow) ? overflow : "hidden"; // applies to region

  var padding = style.padding;

  if (Object(is_non_empty_string["a" /* default */])(padding)) {
    applyPadding(element, padding);
  } // applies to region


  var origin = style.origin;

  if (Object(is_non_empty_string["a" /* default */])(origin)) {
    applyOrigin(element, origin);
  } // applies to region


  var displayAlign = style.displayAlign;
  element.style.display = "flex";
  element.style.flexDirection = "column";

  if (Object(is_non_empty_string["a" /* default */])(displayAlign)) {
    switch (displayAlign) {
      case "before":
        element.style.justifyContent = "flex-start";
        break;

      case "center":
        element.style.justifyContent = "center";
        break;

      case "after":
        element.style.justifyContent = "flex-end";
        break;
    }
  } // applies to region


  var opacity = style.opacity;

  if (Object(is_non_empty_string["a" /* default */])(opacity)) {
    element.style.opacity = opacity;
  } // applies to body, div, p, region, span


  var visibility = style.visibility;

  if (Object(is_non_empty_string["a" /* default */])(visibility)) {
    element.style.visibility = visibility;
  } // applies to body, div, p, region, span


  var display = style.display;

  if (display === "none") {
    element.style.display = "none";
  }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */


function applyPStyle(element, style) {
  element.style.margin = "0px"; // applies to body, div, p, region, span

  var paragraphBackgroundColor = style.backgroundColor;

  if (Object(is_non_empty_string["a" /* default */])(paragraphBackgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
  } // applies to p


  var lineHeight = style.lineHeight;

  if (Object(is_non_empty_string["a" /* default */])(lineHeight)) {
    applyLineHeight(element, lineHeight);
  } // applies to p


  var textAlign = style.textAlign;

  if (Object(is_non_empty_string["a" /* default */])(textAlign)) {
    switch (textAlign) {
      case "center":
        element.style.textAlign = "center";
        break;

      case "left":
      case "start":
        // TODO check what start means (difference with left, writing direction?)
        element.style.textAlign = "left";
        break;

      case "right":
      case "end":
        // TODO check what end means (difference with right, writing direction?)
        element.style.textAlign = "right";
        break;
    }
  }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */


function createTextElement(el, style, shouldTrimWhiteSpace) {
  var textElement = document.createElement("span");
  var textContent = el.textContent === null ? "" : el.textContent;

  if (shouldTrimWhiteSpace) {
    // 1. Trim leading and trailing whitespace.
    // 2. Collapse multiple spaces into one.
    var trimmed = textContent.trim();
    trimmed = trimmed.replace(/\s+/g, " ");
    textContent = trimmed;
  }

  textElement.innerHTML = textContent;
  textElement.className = "rxp-texttrack-span";
  applyTextStyle(textElement, style, shouldTrimWhiteSpace);
  return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */


function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
  function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var elements = [];

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var _getStylingAttributes = Object(get_styling["a" /* getStylingAttributes */])(["backgroundColor"], spans, styles, regions),
            backgroundColor = _getStylingAttributes.backgroundColor;

        if (Object(is_non_empty_string["a" /* default */])(backgroundColor)) {
          style.backgroundColor = backgroundColor;
        } else {
          delete style.backgroundColor;
        }

        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
        elements.push(el);
      } else if (currentNode.nodeName === "br") {
        var br = document.createElement("BR");
        elements.push(br);
      } else if (currentNode.nodeName === "span" && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnSpan = Object(is_non_empty_string["a" /* default */])(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent; // compute the new applyable style

        var newStyle = Object(object_assign["a" /* default */])({}, style, Object(get_styling["a" /* getStylingAttributes */])(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
        elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans), shouldTrimWhiteSpaceOnSpan));
      }
    }

    return elements;
  }

  return loop(paragraph, Object(object_assign["a" /* default */])({}, paragraphStyle), [], shouldTrimWhiteSpace);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {HTMLElement}
 */


function createElement(paragraph, body, regions, styles, paragraphStyle, _ref) {
  var cellResolution = _ref.cellResolution,
      shouldTrimWhiteSpace = _ref.shouldTrimWhiteSpace;
  var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
  var parentElement = document.createElement("DIV");
  parentElement.className = "rxp-texttrack-region";
  parentElement.setAttribute("data-resolution-columns", String(cellResolution.columns));
  parentElement.setAttribute("data-resolution-rows", String(cellResolution.rows));
  applyGeneralStyle(parentElement, paragraphStyle);

  if (body !== null) {
    // applies to body, div, p, region, span
    var _getStylingAttributes2 = Object(get_styling["a" /* getStylingAttributes */])(["backgroundColor"], [].concat(divs, [body]), styles, regions),
        bodyBackgroundColor = _getStylingAttributes2.bodyBackgroundColor;

    if (Object(is_non_empty_string["a" /* default */])(bodyBackgroundColor)) {
      parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
    }
  }

  var pElement = document.createElement("p");
  pElement.className = "rxp-texttrack-p";
  applyPStyle(pElement, paragraphStyle);
  var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);

  for (var i = 0; i < textContent.length; i++) {
    pElement.appendChild(textContent[i]);
  } // NOTE:
  // The following code is for the inclusion of div elements. This has no
  // advantage for now, and might only with future evolutions.
  // (This is only an indication of what the base of the code could look like).
  // if (divs.length) {
  //   let container = parentElement;
  //   for (let i = divs.length - 1; i >= 0; i--) {
  //     // TODO manage style at div level?
  //     // They are: visibility, display and backgroundColor
  //     // All these do not have any difference if applied to the <p> element
  //     // instead of the div.
  //     // The advantage might only be for multiple <p> elements dispatched
  //     // in multiple div Which we do not manage anyway for now.
  //     const divEl = document.createElement("DIV");
  //     divEl.className = "rxp-texttrack-div";
  //     container.appendChild(divEl);
  //     container = divEl;
  //   }
  //   container.appendChild(pElement);
  //   parentElement.appendChild(container);
  // } else {
  //   parentElement.appendChild(pElement);
  // }


  parentElement.appendChild(pElement);
  return parentElement;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Element} paragraph
 * @param {Number} timeOffset
 * @param {Array.<Object>} idStyles
 * @param {Array.<Object>} regionStyles
 * @param {Element} body
 * @param {Object} paragraphStyle
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {Object|null}
 */

function parseCue(paragraph, timeOffset, idStyles, regionStyles, body, paragraphStyle, ttParams, shouldTrimWhiteSpace) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }

  var cellResolution = ttParams.cellResolution;

  var _getTimeDelimiters = Object(get_time_delimiters["a" /* default */])(paragraph, ttParams),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var element = createElement(paragraph, body, regionStyles, idStyles, paragraphStyle, {
    cellResolution: cellResolution,
    shouldTrimWhiteSpace: shouldTrimWhiteSpace
  });
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    element: element
  };
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var STYLE_ATTRIBUTES = ["backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode"];
/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */

function parseTTMLStringToDIV(str, timeOffset) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml !== null && xml !== undefined) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];

    if (tt === undefined) {
      throw new Error("invalid XML");
    }

    var body = Object(nodes["a" /* getBodyNode */])(tt);
    var styleNodes = Object(nodes["c" /* getStyleNodes */])(tt);
    var regionNodes = Object(nodes["b" /* getRegionNodes */])(tt);
    var paragraphNodes = Object(nodes["d" /* getTextNodes */])(tt);
    var ttParams = Object(get_parameters["a" /* default */])(tt); // construct idStyles array based on the xml as an optimization

    var idStyles = [];

    for (var i = 0; i <= styleNodes.length - 1; i++) {
      var styleNode = styleNodes[i];

      if (styleNode instanceof Element) {
        var styleID = styleNode.getAttribute("xml:id");

        if (styleID !== null) {
          var subStyles = styleNode.getAttribute("style");
          var extendsStyles = subStyles === null ? [] : subStyles.split(" ");
          idStyles.push({
            id: styleID,
            style: Object(get_styling["b" /* getStylingFromElement */])(styleNode),
            extendsStyles: extendsStyles
          });
        }
      }
    }

    Object(resolve_styles_inheritance["a" /* default */])(idStyles); // construct regionStyles array based on the xml as an optimization

    var regionStyles = [];

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      var regionNode = regionNodes[_i];

      if (regionNode instanceof Element) {
        var regionID = regionNode.getAttribute("xml:id");

        if (regionID !== null) {
          (function () {
            var regionStyle = Object(get_styling["b" /* getStylingFromElement */])(regionNode);
            var associatedStyleID = regionNode.getAttribute("style");

            if (Object(is_non_empty_string["a" /* default */])(associatedStyleID)) {
              var style = Object(array_find["a" /* default */])(idStyles, function (x) {
                return x.id === associatedStyleID;
              });

              if (style !== undefined) {
                regionStyle = Object(object_assign["a" /* default */])({}, style.style, regionStyle);
              }
            }

            regionStyles.push({
              id: regionID,
              style: regionStyle,
              // already handled
              extendsStyles: []
            });
          })();
        }
      }
    } // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.
    // TODO Compute corresponding CSS style here (as soon as we now the TTML
    // style) to speed up the process even
    // more.


    var bodyStyle = body !== null ? Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [body], idStyles, regionStyles) : Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [], idStyles, regionStyles);
    var bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : undefined;
    var shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || ttParams.spaceStyle === "default";

    for (var _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
      var paragraph = paragraphNodes[_i2];

      if (paragraph instanceof Element) {
        var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
        var paragraphStyle = Object(object_assign["a" /* default */])({}, bodyStyle, Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [paragraph].concat(divs), idStyles, regionStyles));
        var paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnParagraph = Object(is_non_empty_string["a" /* default */])(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
        var cue = parseCue(paragraph, timeOffset, idStyles, regionStyles, body, paragraphStyle, ttParams, shouldTrimWhiteSpaceOnParagraph);

        if (cue !== null) {
          ret.push(cue);
        }
      }
    }
  }

  return ret;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (parseTTMLStringToDIV);

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(128);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(70);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */

function getStyleBlocks(linified, headerOffset) {
  var styleBlocks = [];

  for (var i = headerOffset; i < linified.length; i++) {
    //
    if (Object(utils["d" /* isStartOfStyleBlock */])(linified, i)) {
      var startOfStyleBlock = i;
      i++; // continue incrementing i until either:
      //   - empty line
      //   - end of file

      while (Object(is_non_empty_string["a" /* default */])(linified[i])) {
        i++;
      }

      var styleBlock = linified.slice(startOfStyleBlock, i);
      styleBlocks.push(styleBlock);
    } else if (Object(is_non_empty_string["a" /* default */])(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (Object(is_non_empty_string["a" /* default */])(linified[i])) {
        i++;
      }
    }
  }

  return styleBlocks;
}
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(140);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
/**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */
var colorMap = {
  white: "#ffffff",
  lime: "#00ff00",
  cyan: "#00ffff",
  red: "#ff0000",
  yellow: "#ffff00",
  magenta: "#ff00ff",
  blue: "#0000ff",
  black: "#000000"
};
function createDefaultStyleElements() {
  return Object.keys(colorMap).reduce(function (result, key) {
    result[key] = "color: " + colorMap[key] + ";";
    result["bg_" + key] = "background-color: " + colorMap[key] + ";";
    return result;
  }, {});
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse style element from WebVTT.
 * @param {Array.<Array.<string>>} styleBlocks
 * @return {Object}
 */

function parseStyleBlocks(styleBlocks) {
  var classes = createDefaultStyleElements();
  var global = "";
  styleBlocks.forEach(function (styleBlock) {
    if (styleBlock.length >= 2) {
      for (var index = 1; index < styleBlock.length; index++) {
        var line = styleBlock[index];

        if (Array.isArray(line.match(/::cue {/))) {
          line = styleBlock[++index];

          while (Object(is_non_empty_string["a" /* default */])(line) && !(Array.isArray(line.match(/}/)) || line.length === 0)) {
            global += line;
            line = styleBlock[++index];
          }
        } else {
          (function () {
            var classNames = [];
            var cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/);

            while (Object(is_non_empty_string["a" /* default */])(line) && Array.isArray(cueClassLine)) {
              classNames.push(cueClassLine[1]);
              line = styleBlock[++index];
              cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/);
            }

            var styleContent = "";

            while (Object(is_non_empty_string["a" /* default */])(line) && !(Array.isArray(line.match(/}/)) || line.length === 0)) {
              styleContent += line;
              line = styleBlock[++index];
            }

            classNames.forEach(function (className) {
              var styleElement = classes[className];

              if (styleElement === undefined) {
                classes[className] = styleContent;
              } else {
                classes[className] += styleContent;
              }
            });
          })();
        }
      }
    }
  });
  return {
    classes: classes,
    global: global
  };
}
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */

function createStyledElement(baseNode, styleElements) {
  var HTMLTags = ["u", "i", "b"];
  var authorizedNodeNames = ["u", "i", "b", "c", "#text"];
  var mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
  var nodeWithStyle;

  if (Object(array_includes["a" /* default */])(authorizedNodeNames, mainNodeName)) {
    if (mainNodeName === "#text") {
      var linifiedText = baseNode.wholeText.split("\n");
      nodeWithStyle = document.createElement("span");

      for (var i = 0; i < linifiedText.length; i++) {
        if (i > 0) {
          nodeWithStyle.appendChild(document.createElement("br"));
        }

        if (linifiedText[i].length > 0) {
          var textNode = document.createTextNode(linifiedText[i]);
          nodeWithStyle.appendChild(textNode);
        }
      }
    } else {
      var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
      var styleContents = [];
      nodeClasses.forEach(function (nodeClass) {
        if (Object(is_non_empty_string["a" /* default */])(styleElements[nodeClass])) {
          styleContents.push(styleElements[nodeClass]);
        }
      });

      if (styleContents.length !== 0) {
        // If style must be applied
        var attr = document.createAttribute("style");
        styleContents.forEach(function (styleContent) {
          attr.value += styleContent;
        });
        var nameClass = Object(array_includes["a" /* default */])(HTMLTags, mainNodeName) ? mainNodeName : "span";
        nodeWithStyle = document.createElement(nameClass);
        nodeWithStyle.setAttributeNode(attr);
      } else {
        // If style mustn't be applied. Rebuild element with tag name
        var elementTag = !Object(array_includes["a" /* default */])(HTMLTags, mainNodeName) ? "span" : mainNodeName;
        nodeWithStyle = document.createElement(elementTag);
      }

      for (var j = 0; j < baseNode.childNodes.length; j++) {
        var child = createStyledElement(baseNode.childNodes[j], styleElements);
        nodeWithStyle.appendChild(child);
      }
    }
  } else {
    nodeWithStyle = document.createElement("span");

    for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
      var _child = createStyledElement(baseNode.childNodes[_j], styleElements);

      nodeWithStyle.appendChild(_child);
    }
  }

  return nodeWithStyle;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */

function convertPayloadToHTML(text, styleElements) {
  var filteredText = text // Remove timestamp tags
  .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "") // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
  .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
  var parsedWebVTT = new DOMParser().parseFromString(filteredText, "text/html");
  var nodes = parsedWebVTT.body.childNodes;
  var styledElements = [];

  for (var i = 0; i < nodes.length; i++) {
    styledElements.push(createStyledElement(nodes[i], styleElements));
  }

  return styledElements;
}
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(78);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_style_attribute.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a DOM attribute reflecting given cue settings
 * @param {Partial<Record<string, string>>} settings
 * @returns {Attr}
 */

function createStyleAttribute(settings) {
  var pAttr = document.createAttribute("style");
  pAttr.value = create_style_attribute_getAttrValue(settings);
  return pAttr;
}

var create_style_attribute_getAttrValue = function getAttrValue(settings) {
  var hasSettings = settings !== undefined && Object(object_values["a" /* default */])(settings).length !== 0;

  if (!hasSettings) {
    return "text-align:center";
  }

  var xPositioning = getPositioningX(settings);
  var yPositioning = getPositioningY(settings);
  return "position: absolute;" + "margin: 0;" + ("transform: translate(" + xPositioning.offset + "%," + yPositioning.offset + "%);") + ("width: " + getSizePercentage(settings.size) + "%;") + ("left: " + xPositioning.position + "%;") + ("top: " + (yPositioning.position !== null ? yPositioning.position + "%" : "auto") + ";") + ("text-align: " + getAlignValue(settings.align) + ";");
};

var PositionAlignment;

(function (PositionAlignment) {
  PositionAlignment["LINE_LEFT"] = "line-left";
  PositionAlignment["CENTER"] = "center";
  PositionAlignment["LINE_RIGHT"] = "line-right";
})(PositionAlignment || (PositionAlignment = {}));

var Align;

(function (Align) {
  Align["LEFT"] = "left";
  Align["CENTER"] = "center";
  Align["RIGHT"] = "right";
})(Align || (Align = {}));

var LineAlignment;

(function (LineAlignment) {
  LineAlignment["START"] = "start";
  LineAlignment["CENTER"] = "center";
  LineAlignment["END"] = "end";
})(LineAlignment || (LineAlignment = {}));

var getPositioningX = function getPositioningX(settings) {
  return {
    position: getXPositionPercentage(settings),
    offset: getXOffsetPercentage(settings)
  };
};

var getXPositionPercentage = function getXPositionPercentage(settings) {
  var _alignMap;

  var positionPercentage = getPercentageValue(settings.position);

  if (positionPercentage !== null) {
    return positionPercentage;
  }

  var align = getAlignValue(settings.align);
  var alignMap = (_alignMap = {}, _alignMap[Align.LEFT] = 0, _alignMap[Align.CENTER] = 50, _alignMap[Align.RIGHT] = 100, _alignMap);
  return alignMap[align];
};

var getXOffsetPercentage = function getXOffsetPercentage(settings) {
  var _positionAlignmentMap, _alignMap2;

  var getPositionAlignment = function getPositionAlignment(positionSetting) {
    var positionRegex = /,(line-left|line-right|center)/;
    var matches = positionRegex.exec(positionSetting);

    if (!Array.isArray(matches) || matches.length < 2) {
      return null;
    }

    return matches[1];
  };

  var positionAlignmentMap = (_positionAlignmentMap = {}, _positionAlignmentMap[PositionAlignment.LINE_LEFT] = 0, _positionAlignmentMap[PositionAlignment.CENTER] = -50, _positionAlignmentMap[PositionAlignment.LINE_RIGHT] = -100, _positionAlignmentMap);
  var positionAlignment = settings.position !== undefined ? getPositionAlignment(settings.position) : null;

  if (positionAlignment !== null) {
    return positionAlignmentMap[positionAlignment];
  }

  var alignMap = (_alignMap2 = {}, _alignMap2[Align.LEFT] = 0, _alignMap2[Align.CENTER] = -50, _alignMap2[Align.RIGHT] = -100, _alignMap2);
  var align = settings.align !== undefined ? getAlignValue(settings.align) : Align.CENTER;
  return alignMap[align];
};

var getPositioningY = function getPositioningY(settings) {
  return {
    position: getYPositionPercentage(settings.line),
    offset: getYOffsetPercentage(settings.line)
  };
};

var getYPositionPercentage = function getYPositionPercentage(lineSetting) {
  return getPercentageValue(lineSetting);
};

var getYOffsetPercentage = function getYOffsetPercentage(lineSetting) {
  var _lineAlignmentMap;

  var getLineAlignment = function getLineAlignment(line) {
    var positionRegex = /,(start|center|end)/;
    var matches = positionRegex.exec(line);

    if (!Array.isArray(matches) || matches.length < 2) {
      return null;
    }

    return matches[1];
  };

  var lineAlignmentMap = (_lineAlignmentMap = {}, _lineAlignmentMap[LineAlignment.START] = 0, _lineAlignmentMap[LineAlignment.CENTER] = -50, _lineAlignmentMap[LineAlignment.END] = -100, _lineAlignmentMap);

  if (lineSetting === undefined) {
    return lineAlignmentMap[LineAlignment.START];
  }

  var lineAlignment = getLineAlignment(lineSetting);
  return lineAlignment !== null ? lineAlignmentMap[lineAlignment] : lineAlignmentMap[LineAlignment.START];
};

var getAlignValue = function getAlignValue(alignSetting) {
  switch (alignSetting) {
    case "left":
    case "start":
      return "left";

    case "right":
    case "end":
      return "right";

    default:
      return "center";
  }
};

var getSizePercentage = function getSizePercentage(sizeSetting) {
  var defaultSize = 100;
  return getPercentageValueOrDefault(sizeSetting, defaultSize);
};

var getPercentageValueOrDefault = function getPercentageValueOrDefault(percentageString, defaultValue) {
  var value = getPercentageValue(percentageString);
  return value !== null ? value : defaultValue;
};

var getPercentageValue = function getPercentageValue(percentageString) {
  if (percentageString === undefined) {
    return null;
  }

  var percentageValueRegex = /^([\d.]+)%/;
  var matches = percentageValueRegex.exec(percentageString);

  if (!Array.isArray(matches) || matches.length < 2) {
    return null;
  }

  return parseInt(matches[1], 10);
};
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */

function toHTML(cueObj, styling) {
  var start = cueObj.start,
      end = cueObj.end,
      settings = cueObj.settings,
      header = cueObj.header,
      payload = cueObj.payload;
  var region = document.createElement("div");
  var regionAttr = document.createAttribute("style");
  regionAttr.value = "width:100%;" + "height:100%;" + "display:flex;" + "flex-direction:column;" + "justify-content:flex-end;" + "align-items:center;";
  region.setAttributeNode(regionAttr); // Get content, format and apply style.

  var pElement = document.createElement("p");
  var pAttr = createStyleAttribute(settings);
  pElement.setAttributeNode(pAttr);
  var spanElement = document.createElement("span");
  var attr = document.createAttribute("style"); // set color and background-color default values, as indicated in:
  // https://www.w3.org/TR/webvtt1/#applying-css-properties

  attr.value = "background-color:rgba(0,0,0,0.8);" + "color:white;";
  spanElement.setAttributeNode(attr);
  var global = styling.global,
      classes = styling.classes;
  var localStyle = Object(is_non_empty_string["a" /* default */])(header) ? classes[header] : undefined;
  var styles = [global, localStyle].filter(function (s) {
    return s !== undefined;
  }).join("");
  attr.value += styles;
  spanElement.setAttributeNode(attr);
  convertPayloadToHTML(payload.join("\n"), classes).forEach(function (element) {
    spanElement.appendChild(element);
  });
  region.appendChild(pElement);
  pElement.appendChild(spanElement);
  return {
    start: start,
    end: end,
    element: region
  };
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */

function parseWebVTT(text, timeOffset) {
  var newLineChar = /\r\n|\n|\r/g; // CRLF|LF|CR

  var linified = text.split(newLineChar);
  var cuesArray = [];

  if (linified[0].match(/^WEBVTT( |\t|\n|\r|$)/) === null) {
    throw new Error("Can't parse WebVTT: Invalid File.");
  }

  var firstLineAfterHeader = Object(utils["b" /* getFirstLineAfterHeader */])(linified);
  var styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);
  var cueBlocks = Object(get_cue_blocks["a" /* default */])(linified, firstLineAfterHeader);
  var styles = parseStyleBlocks(styleBlocks);

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(parse_cue_block["a" /* default */])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var htmlCue = toHTML(cueObject, styles);
      cuesArray.push(htmlCue);
    }
  }

  return cuesArray;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (parseWebVTT);

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(232);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(159);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(192);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(67);

// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 1 modules
var manifest_adaptation = __webpack_require__(74);

// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(237);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(64);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The MetaRepresentationIndex is wrapper for all kind of RepresentationIndex (from
 * dash, smooth, etc)
 *
 * It wraps methods from original RepresentationIndex, while taking into account
 * the time offset introduced by the MetaPlaylist content.
 *
 * It makes a bridge between the MetaPlaylist timeline, and the original
 * timeline of content. (e.g. the segment whose "meta" time is 1500, is actually a
 * segment whose original time is 200, played with an offset of 1300)
 * @class MetaRepresentationIndex
 */

var representation_index_MetaRepresentationIndex = /*#__PURE__*/function () {
  /**
   * Create a new `MetaRepresentationIndex`.
   * @param {Object} wrappedIndex - "Real" RepresentationIndex implementation of
   * the concerned Representation.
   * @param {Array.<number|undefined>} contentBounds - Start time and end time
   * the Representation will be played between, in seconds.
   * @param {string} transport - Transport for the "real" RepresentationIndex
   * (e.g. "dash" or "smooth").
   * @param {Object} baseContentInfos - Various information about the "real"
   * Representation.
   */
  function MetaRepresentationIndex(wrappedIndex, contentBounds, transport, baseContentInfos) {
    this._wrappedIndex = wrappedIndex;
    this._timeOffset = contentBounds[0];
    this._contentEnd = contentBounds[1];
    this._transport = transport;
    this._baseContentInfos = baseContentInfos;
  }
  /**
   * Returns information about the initialization segment.
   */


  var _proto = MetaRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    var segment = this._wrappedIndex.getInitSegment();

    if (segment === null) {
      return null;
    }

    if (segment.privateInfos === undefined) {
      segment.privateInfos = {};
    }

    segment.privateInfos.metaplaylistInfos = {
      transportType: this._transport,
      baseContent: this._baseContentInfos,
      contentStart: this._timeOffset,
      contentEnd: this._contentEnd
    };
    return segment;
  }
  /**
   * Returns information about the segments asked.
   * @param {number} up - Starting time wanted, in seconds.
   * @param {Number} duration - Amount of time wanted, in seconds
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(up, duration) {
    var _this = this;

    return this._wrappedIndex.getSegments(up - this._timeOffset, duration).map(function (segment) {
      if (segment.privateInfos === undefined) {
        segment.privateInfos = {};
      }

      segment.privateInfos.metaplaylistInfos = {
        transportType: _this._transport,
        baseContent: _this._baseContentInfos,
        contentStart: _this._timeOffset,
        contentEnd: _this._contentEnd
      };
      segment.time += _this._timeOffset * segment.timescale;
      return segment;
    });
  }
  /**
   * Whether this RepresentationIndex should be refreshed now.
   * Returns `false` as MetaPlaylist contents do not support underlying live
   * contents yet.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * Returns first possible position the first segment plays at, in seconds.
   * `undefined` if we do not know this value.
   * @return {Number|undefined}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    var wrappedFirstPosition = this._wrappedIndex.getFirstPosition();

    return wrappedFirstPosition != null ? wrappedFirstPosition + this._timeOffset : undefined;
  }
  /**
   * Returns last possible position the last segment plays at, in seconds.
   * `undefined` if we do not know this value.
   * @return {Number|undefined}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var wrappedLastPosition = this._wrappedIndex.getLastPosition();

    return wrappedLastPosition != null ? wrappedLastPosition + this._timeOffset : undefined;
  }
  /**
   * Returns `false` if that segment is not currently available in the Manifest
   * (e.g. it corresponds to a segment which is before the current buffer
   * depth).
   * @param {Object} segment
   * @returns {boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    var offset = this._timeOffset * segment.timescale;
    var updatedSegment = Object(object_assign["a" /* default */])({}, segment, {
      time: segment.time - offset
    });
    return this._wrappedIndex.isSegmentStillAvailable(updatedSegment);
  }
  /**
   * @param {Error} error
   * @param {Object} segment
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error, segment) {
    return this._wrappedIndex.canBeOutOfSyncError(error, segment);
  }
  /**
   *
   * @param {Number} time
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity(time) {
    return this._wrappedIndex.checkDiscontinuity(time - this._timeOffset);
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return this._wrappedIndex.isFinished();
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return this._wrappedIndex.isInitialized();
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    if (!(newIndex instanceof MetaRepresentationIndex)) {
      throw new Error("A MetaPlaylist can only be replaced with another MetaPlaylist");
    }

    this._wrappedIndex._replace(newIndex._wrappedIndex);
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update(newIndex) {
    if (!(newIndex instanceof MetaRepresentationIndex)) {
      throw new Error("A MetaPlaylist can only be updated with another MetaPlaylist");
    }

    this._wrappedIndex._update(newIndex._wrappedIndex);
  }
  /**
   * @param {Array.<Object>} nextSegments
   * @param {Object} currentSegment
   */
  ;

  _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
    return this._wrappedIndex._addSegments(nextSegments, currentSegment);
  };

  return MetaRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/metaplaylist_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse playlist string to JSON.
 * Returns an array of contents.
 * @param {string} data
 * @param {string} url
 * @returns {Object}
 */

function parseMetaPlaylist(data, parserOptions) {
  var parsedData;

  if (typeof data === "object" && data != null) {
    parsedData = data;
  } else if (typeof data === "string") {
    try {
      parsedData = JSON.parse(data);
    } catch (error) {
      throw new Error("MPL Parser: Bad MetaPlaylist file. Expected JSON.");
    }
  } else {
    throw new Error("MPL Parser: Parser input must be either a string " + "or the MetaPlaylist data directly.");
  }

  var _parsedData = parsedData,
      contents = _parsedData.contents,
      version = _parsedData.version,
      type = _parsedData.type;

  if (type !== "MPL") {
    throw new Error("MPL Parser: Bad MetaPlaylist. " + "The `type` property is not set to `MPL`");
  }

  if (version !== "0.1") {
    throw new Error("MPL Parser: Bad MetaPlaylist version");
  } // quick checks


  if (contents == null || contents.length === 0) {
    throw new Error("MPL Parser: No content found.");
  }

  var ressources = [];

  for (var i = 0; i < contents.length; i++) {
    var content = contents[i];

    if (content.url == null || content.startTime == null || content.endTime == null || content.transport == null) {
      throw new Error("MPL Parser: Malformed content.");
    }

    ressources.push({
      url: content.url,
      transportType: content.transport
    });
  }

  var metaPlaylist = parsedData;
  return {
    type: "needs-manifest-loader",
    value: {
      ressources: ressources,
      "continue": function parseWholeMPL(loadedRessources) {
        var parsedManifest = createManifest(metaPlaylist, loadedRessources, parserOptions);
        return {
          type: "done",
          value: parsedManifest
        };
      }
    }
  };
}
/**
 * From several parsed manifests, generate a single bigger manifest.
 * Each content presents a start and end time, so that periods
 * boudaries could be adapted.
 * @param {Object} mplData
 * @param {Array<Object>} manifest
 * @param {string} url
 * @returns {Object}
 */

function createManifest(mplData, manifests, parserOptions) {
  var url = parserOptions.url,
      serverSyncInfos = parserOptions.serverSyncInfos;
  var clockOffset = serverSyncInfos !== undefined ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : undefined;
  var generateAdaptationID = Object(id_generator["a" /* default */])();
  var generateRepresentationID = Object(id_generator["a" /* default */])();
  var contents = mplData.contents;
  var minimumTime = contents.length > 0 ? contents[0].startTime : 0;
  var maximumTime = contents.length > 0 ? contents[contents.length - 1].endTime : 0;
  var isDynamic = mplData.dynamic === true;
  var firstStart = null;
  var lastEnd = null;
  var periods = [];

  var _loop = function _loop(iMan) {
    var content = contents[iMan];
    firstStart = firstStart !== null ? Math.min(firstStart, content.startTime) : content.startTime;
    lastEnd = lastEnd !== null ? Math.max(lastEnd, content.endTime) : content.endTime;
    var currentManifest = manifests[iMan];

    if (currentManifest.periods.length <= 0) {
      return "continue";
    }

    var contentOffset = content.startTime - currentManifest.periods[0].start;
    var contentEnd = content.endTime;
    var manifestPeriods = [];

    var _loop2 = function _loop2(iPer) {
      var currentPeriod = currentManifest.periods[iPer];
      var adaptations = manifest_adaptation["a" /* SUPPORTED_ADAPTATIONS_TYPE */].reduce(function (acc, type) {
        var currentAdaptations = currentPeriod.adaptations[type];

        if (currentAdaptations == null) {
          return acc;
        }

        var adaptationsForCurrentType = [];

        for (var iAda = 0; iAda < currentAdaptations.length; iAda++) {
          var currentAdaptation = currentAdaptations[iAda];
          var representations = [];

          for (var iRep = 0; iRep < currentAdaptation.representations.length; iRep++) {
            var currentRepresentation = currentAdaptation.representations[iRep];
            var contentInfos = {
              manifest: currentManifest,
              period: currentPeriod,
              adaptation: currentAdaptation,
              representation: currentRepresentation
            };
            var newIndex = new representation_index_MetaRepresentationIndex(currentRepresentation.index, [contentOffset, contentEnd], content.transport, contentInfos);
            representations.push({
              bitrate: currentRepresentation.bitrate,
              index: newIndex,
              id: currentRepresentation.id,
              height: currentRepresentation.height,
              width: currentRepresentation.width,
              mimeType: currentRepresentation.mimeType,
              frameRate: currentRepresentation.frameRate,
              codecs: currentRepresentation.codec,
              contentProtections: currentRepresentation.contentProtections
            });
          }

          adaptationsForCurrentType.push({
            id: currentAdaptation.id,
            representations: representations,
            type: currentAdaptation.type,
            audioDescription: currentAdaptation.isAudioDescription,
            closedCaption: currentAdaptation.isClosedCaption,
            isDub: currentAdaptation.isDub,
            language: currentAdaptation.language,
            isSignInterpreted: currentAdaptation.isSignInterpreted
          });
          acc[type] = adaptationsForCurrentType;
        }

        return acc;
      }, {}); // TODO only first period?

      var textTracks = content.textTracks === undefined ? [] : content.textTracks;
      var newTextAdaptations = textTracks.map(function (track) {
        var adaptationID = "gen-text-ada-" + generateAdaptationID();
        var representationID = "gen-text-rep-" + generateRepresentationID();
        return {
          id: adaptationID,
          type: "text",
          language: track.language,
          closedCaption: track.closedCaption,
          manuallyAdded: true,
          representations: [{
            bitrate: 0,
            id: representationID,
            mimeType: track.mimeType,
            codecs: track.codecs,
            index: new representation_index_static["a" /* default */]({
              media: track.url
            })
          }]
        };
      }, []);

      if (newTextAdaptations.length > 0) {
        if (adaptations.text == null) {
          adaptations.text = newTextAdaptations;
        } else {
          var _adaptations$text;

          (_adaptations$text = adaptations.text).push.apply(_adaptations$text, newTextAdaptations);
        }
      }

      var newPeriod = {
        id: formatId(currentManifest.id) + "_" + formatId(currentPeriod.id),
        adaptations: adaptations,
        duration: currentPeriod.duration,
        start: contentOffset + currentPeriod.start
      };
      manifestPeriods.push(newPeriod);
    };

    for (var iPer = 0; iPer < currentManifest.periods.length; iPer++) {
      _loop2(iPer);
    }

    for (var i = manifestPeriods.length - 1; i >= 0; i--) {
      var period = manifestPeriods[i];

      if (period.start >= content.endTime) {
        manifestPeriods.splice(i, 1);
      } else if (period.duration != null) {
        if (period.start + period.duration > content.endTime) {
          period.duration = content.endTime - period.start;
        }
      } else if (i === manifestPeriods.length - 1) {
        period.duration = content.endTime - period.start;
      }
    }

    periods.push.apply(periods, manifestPeriods);
  };

  for (var iMan = 0; iMan < contents.length; iMan++) {
    var _ret = _loop(iMan);

    if (_ret === "continue") continue;
  }

  var time = performance.now();
  var manifest = {
    availabilityStartTime: 0,
    clockOffset: clockOffset,
    suggestedPresentationDelay: 10,
    periods: periods,
    transportType: "metaplaylist",
    isLive: isDynamic,
    isDynamic: isDynamic,
    uris: url == null ? [] : [url],
    maximumTime: {
      isContinuous: false,
      value: maximumTime,
      time: time
    },
    minimumTime: {
      isContinuous: false,
      value: minimumTime,
      time: time
    },
    lifetime: mplData.pollInterval
  };
  return manifest;
}

function formatId(str) {
  return str.replace(/_/g, "\_");
}
// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var metaplaylist = (parseMetaPlaylist);
// EXTERNAL MODULE: ./src/utils/defer_subscriptions.ts + 6 modules
var defer_subscriptions = __webpack_require__(56);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(28);

// EXTERNAL MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
var call_custom_manifest_loader = __webpack_require__(125);

// CONCATENATED MODULE: ./src/transports/metaplaylist/manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */

function regularManifestLoader(_ref) {
  var url = _ref.url;

  if (url === undefined) {
    throw new Error("Cannot perform HTTP(s) request. URL not known");
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "text"
  });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */


function generateManifestLoader(options) {
  var customManifestLoader = options.customManifestLoader;

  if (typeof customManifestLoader !== "function") {
    return regularManifestLoader;
  }

  return Object(call_custom_manifest_loader["a" /* default */])(customManifestLoader, regularManifestLoader);
}
// CONCATENATED MODULE: ./src/transports/metaplaylist/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */

function getContent(segment, offset) {
  var _a;

  if (((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.metaplaylistInfos) === undefined) {
    throw new Error("MetaPlaylist: missing private infos");
  }

  var _segment$privateInfos = segment.privateInfos.metaplaylistInfos.baseContent,
      manifest = _segment$privateInfos.manifest,
      period = _segment$privateInfos.period,
      adaptation = _segment$privateInfos.adaptation,
      representation = _segment$privateInfos.representation;
  var newTime = segment.time < 0 ? segment.time : segment.time - offset * segment.timescale;
  var offsetedSegment = Object(object_assign["a" /* default */])({}, segment, {
    time: newTime
  });
  return {
    manifest: manifest,
    period: period,
    adaptation: adaptation,
    representation: representation,
    segment: offsetedSegment
  };
}
/**
 * Prepare any wrapped segment loader's arguments.
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */


function getLoaderArguments(segment, url, offset) {
  var content = getContent(segment, offset);
  return Object(object_assign["a" /* default */])({
    url: url
  }, content);
}
/**
 * Prepare any wrapped segment parser's arguments.
 * @param {Object} arguments
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */


function getParserArguments(_ref, segment, offset) {
  var initTimescale = _ref.initTimescale,
      response = _ref.response;
  return {
    initTimescale: initTimescale,
    response: response,
    content: getContent(segment, offset)
  };
}
/**
 * @param {Object} transports
 * @param {string} transportName
 * @param {Object} options
 * @returns {Object}
 */


function getTransportPipelines(transports, transportName, options) {
  var initialTransport = transports[transportName];

  if (initialTransport !== undefined) {
    return initialTransport;
  }

  var feature = features["a" /* default */].transports[transportName];

  if (feature === undefined) {
    throw new Error("MetaPlaylist: Unknown transport " + transportName + ".");
  }

  var transport = feature(options);
  transports[transportName] = transport;
  return transport;
}
/**
 * @param {Object} segment
 * @returns {Object}
 */


function getMetaPlaylistPrivateInfos(segment) {
  var privateInfos = segment.privateInfos;

  if ((privateInfos === null || privateInfos === void 0 ? void 0 : privateInfos.metaplaylistInfos) === undefined) {
    throw new Error("MetaPlaylist: Undefined transport for content for metaplaylist.");
  }

  return privateInfos.metaplaylistInfos;
}

/* harmony default export */ var pipelines = (function (options) {
  var transports = {};
  var manifestLoader = generateManifestLoader({
    customManifestLoader: options.manifestLoader
  }); // remove some options that we might not want to apply to the
  // other streaming protocols used here

  var otherTransportOptions = Object(object_assign["a" /* default */])({}, options, {
    manifestLoader: undefined,
    supplementaryTextTracks: [],
    supplementaryImageTracks: []
  });
  var manifestPipeline = {
    loader: manifestLoader,
    parser: function parser(_ref2) {
      var response = _ref2.response,
          loaderURL = _ref2.url,
          previousManifest = _ref2.previousManifest,
          scheduleRequest = _ref2.scheduleRequest,
          unsafeMode = _ref2.unsafeMode,
          externalClockOffset = _ref2.externalClockOffset;
      var url = response.url === undefined ? loaderURL : response.url;
      var responseData = response.responseData;
      var parserOptions = {
        url: url,
        serverSyncInfos: options.serverSyncInfos
      };
      return handleParsedResult(metaplaylist(responseData, parserOptions));

      function handleParsedResult(parsedResult) {
        if (parsedResult.type === "done") {
          var manifest = new src_manifest["a" /* default */](parsedResult.value, options);
          return Object(of["a" /* of */])({
            type: "parsed",
            value: {
              manifest: manifest
            }
          });
        }

        var loaders$ = parsedResult.value.ressources.map(function (ressource) {
          var transport = getTransportPipelines(transports, ressource.transportType, otherTransportOptions);
          var request$ = scheduleRequest(function () {
            return transport.manifest.loader({
              url: ressource.url
            }).pipe(Object(filter["a" /* filter */])(function (e) {
              return e.type === "data-loaded";
            }), Object(map["a" /* map */])(function (e) {
              return e.value;
            }));
          });
          return request$.pipe(Object(mergeMap["a" /* mergeMap */])(function (responseValue) {
            return transport.manifest.parser({
              response: responseValue,
              url: ressource.url,
              scheduleRequest: scheduleRequest,
              previousManifest: previousManifest,
              unsafeMode: unsafeMode,
              externalClockOffset: externalClockOffset
            });
          })).pipe(Object(defer_subscriptions["a" /* default */])(), Object(share["a" /* share */])());
        });
        var warnings$ = loaders$.map(function (loader) {
          return loader.pipe(Object(filter["a" /* filter */])(function (evt) {
            return evt.type === "warning";
          }));
        });
        var responses$ = loaders$.map(function (loader) {
          return loader.pipe(Object(filter["a" /* filter */])(function (evt) {
            return evt.type === "parsed";
          }));
        });
        return merge["a" /* merge */].apply(void 0, [Object(combineLatest["a" /* combineLatest */])(responses$).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
          var loadedRessources = evt.map(function (e) {
            return e.value.manifest;
          });
          return handleParsedResult(parsedResult.value["continue"](loadedRessources));
        }))].concat(warnings$));
      }
    }
  };
  /**
   * @param {Object} segment
   * @param {Object} transports
   * @returns {Object}
   */

  function getTransportPipelinesFromSegment(segment) {
    var _getMetaPlaylistPriva = getMetaPlaylistPrivateInfos(segment),
        transportType = _getMetaPlaylistPriva.transportType;

    return getTransportPipelines(transports, transportType, otherTransportOptions);
  }
  /**
   * @param {number} contentOffset
   * @param {number} scaledContentOffset
   * @param {number|undefined} contentEnd
   * @param {Object} segmentResponse
   * @returns {Object}
   */


  function offsetTimeInfos(contentOffset, scaledContentOffset, contentEnd, segmentResponse) {
    var offsetedSegmentOffset = segmentResponse.chunkOffset + contentOffset;

    if (Object(is_null_or_undefined["a" /* default */])(segmentResponse.chunkData)) {
      return {
        chunkInfos: segmentResponse.chunkInfos,
        chunkOffset: offsetedSegmentOffset,
        appendWindow: [undefined, undefined]
      };
    } // clone chunkInfos


    var chunkInfos = segmentResponse.chunkInfos,
        appendWindow = segmentResponse.appendWindow;
    var offsetedChunkInfos = chunkInfos === null ? null : Object(object_assign["a" /* default */])({}, chunkInfos);

    if (offsetedChunkInfos !== null && offsetedChunkInfos.time > -1) {
      offsetedChunkInfos.time += scaledContentOffset;
    }

    var offsetedWindowStart = appendWindow[0] !== undefined ? Math.max(appendWindow[0] + contentOffset, contentOffset) : contentOffset;
    var offsetedWindowEnd;

    if (appendWindow[1] !== undefined) {
      offsetedWindowEnd = contentEnd !== undefined ? Math.min(appendWindow[1] + contentOffset, contentEnd) : appendWindow[1] + contentOffset;
    } else if (contentEnd !== undefined) {
      offsetedWindowEnd = contentEnd;
    }

    return {
      chunkInfos: offsetedChunkInfos,
      chunkOffset: offsetedSegmentOffset,
      appendWindow: [offsetedWindowStart, offsetedWindowEnd]
    };
  }

  var audioPipeline = {
    loader: function loader(_ref3) {
      var segment = _ref3.segment,
          period = _ref3.period,
          url = _ref3.url;

      var _getTransportPipeline = getTransportPipelinesFromSegment(segment),
          audio = _getTransportPipeline.audio;

      return audio.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva2 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva2.contentStart,
          contentEnd = _getMetaPlaylistPriva2.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline2 = getTransportPipelinesFromSegment(segment),
          audio = _getTransportPipeline2.audio;

      return audio.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var videoPipeline = {
    loader: function loader(_ref4) {
      var segment = _ref4.segment,
          period = _ref4.period,
          url = _ref4.url;

      var _getTransportPipeline3 = getTransportPipelinesFromSegment(segment),
          video = _getTransportPipeline3.video;

      return video.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva3 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva3.contentStart,
          contentEnd = _getMetaPlaylistPriva3.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline4 = getTransportPipelinesFromSegment(segment),
          video = _getTransportPipeline4.video;

      return video.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var textTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          period = _ref5.period,
          url = _ref5.url;

      var _getTransportPipeline5 = getTransportPipelinesFromSegment(segment),
          text = _getTransportPipeline5.text;

      return text.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva4 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva4.contentStart,
          contentEnd = _getMetaPlaylistPriva4.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline6 = getTransportPipelinesFromSegment(segment),
          text = _getTransportPipeline6.text;

      return text.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var imageTrackPipeline = {
    loader: function loader(_ref6) {
      var segment = _ref6.segment,
          period = _ref6.period,
          url = _ref6.url;

      var _getTransportPipeline7 = getTransportPipelinesFromSegment(segment),
          image = _getTransportPipeline7.image;

      return image.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva5 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva5.contentStart,
          contentEnd = _getMetaPlaylistPriva5.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline8 = getTransportPipelinesFromSegment(segment),
          image = _getTransportPipeline8.image;

      return image.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  return {
    manifest: manifestPipeline,
    audio: audioPipeline,
    video: videoPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});
// CONCATENATED MODULE: ./src/transports/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_metaplaylist = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var interval = __webpack_require__(227);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(184);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(241);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(185);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(233);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(9);

// EXTERNAL MODULE: ./src/compat/on_height_width_change.ts
var on_height_width_change = __webpack_require__(169);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(4);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(91);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */

function parseTextTrackToElements(type, data, timestampOffset, language) {
  log["a" /* default */].debug("HTSB: Finding parser for html text tracks:", type);
  var parser = features["a" /* default */].htmlTextTracksParsers[type];

  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }

  log["a" /* default */].debug("HTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log["a" /* default */].debug("HTTB: Parsed successfully!", parsed);
  return parsed;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * SourceBuffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the SourceBuffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the SourceBuffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */

function areNearlyEqual(a, b) {
  return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}
/**
 * Get all cues which have data before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */

function getCuesBefore(cues, time) {
  for (var i = cues.length - 1; i >= 0; i--) {
    var cue = cues[i];

    if (cue.start < time) {
      return cues.slice(0, i + 1);
    }
  }

  return [];
}
/**
 * Get all cues which have data after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */

function getCuesAfter(cues, time) {
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];

    if (cue.end > time) {
      return cues.slice(i, cues.length);
    }
  }

  return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */

function removeCuesInfosBetween(cuesInfos, start, end) {
  var endCuesInfos1 = Math.max(cuesInfos.start, start);
  var cues1 = getCuesBefore(cuesInfos.cues, start);
  var cuesInfos1 = {
    start: cuesInfos.start,
    end: endCuesInfos1,
    cues: cues1
  };
  var startCuesInfos2 = Math.min(end, cuesInfos.end);
  var cues2 = getCuesAfter(cuesInfos.cues, end);
  var cuesInfos2 = {
    start: startCuesInfos2,
    end: cuesInfos.end,
    cues: cues2
  };
  return [cuesInfos1, cuesInfos2];
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/text_track_cues_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextTrackCuesStore
 */

var text_track_cues_store_TextTrackCuesStore = /*#__PURE__*/function () {
  function TextTrackCuesStore() {
    this._cuesBuffer = [];
  }
  /**
   * Get corresponding cue(s) for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */


  var _proto = TextTrackCuesStore.prototype;

  _proto.get = function get(time) {
    var cuesBuffer = this._cuesBuffer;
    var ret = []; // begins at the end as most of the time the player will ask for the last
    // CuesGroup

    for (var i = cuesBuffer.length - 1; i >= 0; i--) {
      var segment = cuesBuffer[i];

      if (time < segment.end && time >= segment.start) {
        var cues = segment.cues;

        for (var j = 0; j < cues.length; j++) {
          if (time >= cues[j].start && time < cues[j].end) {
            ret.push(cues[j].element);
          }
        }

        return ret;
      }
    }

    return [];
  }
  /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.remove = function remove(from, _to) {
    if (false) {}

    var to = Math.max(from, _to);
    var cuesBuffer = this._cuesBuffer;

    for (var i = 0; i < cuesBuffer.length; i++) {
      if (cuesBuffer[i].end > from) {
        // this cuesInfos is concerned by the remove
        var startCuesInfos = cuesBuffer[i];

        if (startCuesInfos.start >= to) {
          // our cuesInfos is strictly after this interval, we have nothing to do
          return;
        }

        if (startCuesInfos.end >= to) {
          // our cuesInfos ends after `to`, we have to keep the end of it
          if (from <= startCuesInfos.start) {
            // from -> to only remove the start of startCuesInfos
            startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);
            startCuesInfos.start = to;
          } else {
            // from -> to is in the middle part of startCuesInfos
            var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to),
                cuesInfos1 = _removeCuesInfosBetwe[0],
                cuesInfos2 = _removeCuesInfosBetwe[1];

            this._cuesBuffer[i] = cuesInfos1;
            cuesBuffer.splice(i + 1, 0, cuesInfos2);
          } // No cuesInfos can be concerned after this one, we can quit


          return;
        } // Else remove all part after `from`


        if (startCuesInfos.start >= from) {
          // all the segment is concerned
          cuesBuffer.splice(i, 1);
          i--; // one less element, we have to decrement the loop
        } else {
          // only the end is concerned
          startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
          startCuesInfos.end = Math.max(from, startCuesInfos.start);
        }
      }
    }
  }
  /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */
  ;

  _proto.insert = function insert(cues, start, end) {
    var cuesBuffer = this._cuesBuffer;
    var cuesInfosToInsert = {
      start: start,
      end: end,
      cues: cues
    };
    /**
     * Called when we found the index of the next cue relative to the cue we
     * want to insert (that is a cue starting after its start or at the same
     * time but ending strictly after its end).
     * Will insert the cue at the right place and update the next cue
     * accordingly.
     * @param {number} indexOfNextCue
     */

    function onIndexOfNextCueFound(indexOfNextCue) {
      var nextCue = cuesBuffer[indexOfNextCue];

      if (nextCue === undefined || // no cue
      areNearlyEqual(cuesInfosToInsert.end, nextCue.end)) // samey end
        {
          //   ours:            |AAAAA|
          //   the current one: |BBBBB|
          //   Result:          |AAAAA|
          cuesBuffer[indexOfNextCue] = cuesInfosToInsert;
        } else if (nextCue.start >= cuesInfosToInsert.end) {
        // Either
        //   ours:            |AAAAA|
        //   the current one:         |BBBBBB|
        //   Result:          |AAAAA| |BBBBBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:       |BBBBBB|
        //   Result:          |AAAAA|BBBBBB|
        // Add ours before
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      } else {
        // Either
        //   ours:            |AAAAA|
        //   the current one: |BBBBBBBB|
        //   Result:          |AAAAABBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:    |BBBBB|
        //   Result:          |AAAAABBB|
        nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);
        nextCue.start = cuesInfosToInsert.end;
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      }
    }

    for (var i = 0; i < cuesBuffer.length; i++) {
      var cuesInfos = cuesBuffer[i];

      if (start < cuesInfos.end) {
        if (areNearlyEqual(start, cuesInfos.start)) {
          if (areNearlyEqual(end, cuesInfos.end)) {
            // exact same segment
            //   ours:            |AAAAA|
            //   the current one: |BBBBB|
            //   Result:          |AAAAA|
            // Which means:
            //   1. replace the current cue with ours
            cuesBuffer[i] = cuesInfosToInsert;
            return;
          } else if (end < cuesInfos.end) {
            // our cue overlaps with the current one:
            //   ours:            |AAAAA|
            //   the current one: |BBBBBBBB|
            //   Result:          |AAAAABBB|
            // Which means:
            //   1. remove some cues at the start of the current one
            //   2. update start of current one
            //   3. add ours before the current one
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } // our cue goes beyond the current one:
          //   ours:            |AAAAAAA|
          //   the current one: |BBBB|...
          //   Result:          |AAAAAAA|
          // Here we have to delete any cuesInfos which end before ours end,
          // and see about the following one.


          do {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          } while (cuesInfos !== undefined && end > cuesInfos.end);

          onIndexOfNextCueFound(i);
          return;
        } else if (start < cuesInfos.start) {
          if (end < cuesInfos.start) {
            // our cue goes strictly before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:           |BBBB|
            //   Result:          |AAAAAAA| |BBBB|
            // Which means:
            //   - add ours before the current one
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.start)) {
            // our cue goes just before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:         |BBBB|
            //   Result:          |AAAAAAA|BBBB|
            // Which means:
            //   - update start time of the current one to be sure
            //   - add ours before the current one
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.end)) {
            //   ours:            |AAAAAAA|
            //   the current one:    |BBBB|
            //   Result:          |AAAAAAA|
            // Replace
            cuesBuffer.splice(i, 1, cuesInfosToInsert);
            return;
          } else if (end < cuesInfos.end) {
            //   ours:            |AAAAAAA|
            //   the current one:     |BBBBB|
            //   Result:          |AAAAAAABB|
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } //   ours:            |AAAAAAA|
          //   the current one:   |BBB|...
          //   Result:          |AAAAAAA|...


          do {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          } while (cuesInfos !== undefined && end > cuesInfos.end);

          onIndexOfNextCueFound(i);
          return;
        } // else -> start > cuesInfos.start


        if (areNearlyEqual(cuesInfos.end, end)) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBB|
          //   Result:          |BBAAAAAA|
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
          return;
        } else if (cuesInfos.end > end) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBBBBB|
          //   Result:          |BBAAAAAABBB|
          var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end),
              cuesInfos1 = _removeCuesInfosBetwe2[0],
              cuesInfos2 = _removeCuesInfosBetwe2[1];

          this._cuesBuffer[i] = cuesInfos1;
          cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
          cuesBuffer.splice(i + 2, 0, cuesInfos2);
          return;
        } else {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBB|...
          //   Result:          |BBAAAAAA|...
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesInfos = cuesBuffer[i + 1];

          while (cuesInfos !== undefined && end > cuesInfos.end) {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          }

          onIndexOfNextCueFound(i);
          return;
        }
      }
    } // no cues group has the end after our current start.
    // These cues should be the last one


    cuesBuffer.push(cuesInfosToInsert);
  };

  return TextTrackCuesStore;
}();


// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/update_proportional_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Update size of element which are proportional to the current text track
 * element.
 * Returns `true` if at least a single styling information is proportional,
 * `false` otherwise.
 * @param {number} currentHeight
 * @param {number} currentWidth
 * @param {Object} resolution
 * @param {HTMLElement} textTrackElement
 * @returns {boolean}
 */
function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {
  var cellUnit = [currentWidth / resolution.columns, currentHeight / resolution.rows];
  var proportElts = textTrackElement.getElementsByClassName("proportional-style");

  for (var eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {
    var elt = proportElts[eltIdx];

    if (elt instanceof HTMLElement) {
      var fontSizeVal = elt.getAttribute("data-proportional-font-size");

      if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {
        elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + "px";
      }

      var widthVal = elt.getAttribute("data-proportional-width");

      if (widthVal !== null && !isNaN(+widthVal)) {
        elt.style.width = String(+widthVal * cellUnit[0]) + "px";
      }

      var heightVal = elt.getAttribute("data-proportional-height");

      if (heightVal !== null && !isNaN(+heightVal)) {
        elt.style.height = String(+heightVal * cellUnit[1]) + "px";
      }

      var lineHeightVal = elt.getAttribute("data-proportional-line-height");

      if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {
        elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + "px";
      }

      var leftVal = elt.getAttribute("data-proportional-left");

      if (leftVal !== null && !isNaN(+leftVal)) {
        elt.style.left = String(+leftVal * cellUnit[0]) + "px";
      }

      var topVal = elt.getAttribute("data-proportional-top");

      if (topVal !== null && !isNaN(+topVal)) {
        elt.style.top = String(+topVal * cellUnit[1]) + "px";
      }

      var paddingTopVal = elt.getAttribute("data-proportional-padding-top");

      if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {
        elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + "px";
      }

      var paddingBottomVal = elt.getAttribute("data-proportional-padding-bottom");

      if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {
        elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + "px";
      }

      var paddingLeftVal = elt.getAttribute("data-proportional-padding-left");

      if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {
        elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + "px";
      }

      var paddingRightVal = elt.getAttribute("data-proportional-padding-right");

      if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {
        elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + "px";
      }
    }
  }

  return proportElts.length > 0;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/html_text_source_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var onEnded$ = compat["a" /* events */].onEnded$,
    onSeeked$ = compat["a" /* events */].onSeeked$,
    onSeeking$ = compat["a" /* events */].onSeeking$;
var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config["a" /* default */].MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL,
    TEXT_TRACK_SIZE_CHECKS_INTERVAL = config["a" /* default */].TEXT_TRACK_SIZE_CHECKS_INTERVAL;
/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */

function generateClock(videoElement) {
  var seeking$ = onSeeking$(videoElement);
  var seeked$ = onSeeked$(videoElement);
  var ended$ = onEnded$(videoElement);
  var manualRefresh$ = Object(merge["a" /* merge */])(seeked$, ended$);
  var autoRefresh$ = Object(interval["a" /* interval */])(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(startWith["a" /* startWith */])(null));
  return manualRefresh$.pipe(Object(startWith["a" /* startWith */])(null), Object(switchMapTo["a" /* switchMapTo */])(Object(concat["a" /* concat */])(autoRefresh$.pipe(Object(mapTo["a" /* mapTo */])(true), Object(takeUntil["a" /* takeUntil */])(seeking$)), Object(of["a" /* of */])(false))));
}
/**
 * @param {Element} element
 * @param {Element} child
 */


function safelyRemoveChild(element, child) {
  try {
    element.removeChild(child);
  } catch (_error) {
    log["a" /* default */].warn("HTSB: Can't remove text track: not in the element.");
  }
}
/**
 * @param {HTMLElement} element
 * @returns {Object|null}
 */


function getElementResolution(element) {
  var strRows = element.getAttribute("data-resolution-rows");
  var strColumns = element.getAttribute("data-resolution-columns");

  if (strRows === null || strColumns === null) {
    return null;
  }

  var rows = parseInt(strRows, 10);
  var columns = parseInt(strColumns, 10);

  if (rows === null || columns === null) {
    return null;
  }

  return {
    rows: rows,
    columns: columns
  };
}
/**
 * SourceBuffer to display TextTracks in the given HTML element.
 * @class HTMLTextSourceBuffer
 */


var html_text_source_buffer_HTMLTextSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  inheritsLoose_default()(HTMLTextSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
  function HTMLTextSourceBuffer(videoElement, textTrackElement) {
    var _this;

    log["a" /* default */].debug("HTSB: Creating html text track SourceBuffer");
    _this = _AbstractSourceBuffer.call(this) || this;
    _this._videoElement = videoElement;
    _this._textTrackElement = textTrackElement;
    _this._clearSizeUpdates$ = new Subject["a" /* Subject */]();
    _this._destroy$ = new Subject["a" /* Subject */]();
    _this._buffer = new text_track_cues_store_TextTrackCuesStore();
    _this._currentCues = []; // update text tracks

    generateClock(_this._videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._destroy$)).subscribe(function (shouldDisplay) {
      if (!shouldDisplay) {
        _this._disableCurrentCues();

        return;
      } // to spread the time error, we divide the regular chosen interval.


      var time = Math.max(_this._videoElement.currentTime + MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1000 / 2, 0);

      var cues = _this._buffer.get(time);

      if (cues.length === 0) {
        _this._disableCurrentCues();
      } else {
        _this._displayCues(cues);
      }
    });
    return _this;
  }
  /**
   * Append text tracks.
   * @param {Object} data
   */


  var _proto = HTMLTextSourceBuffer.prototype;

  _proto._append = function _append(data) {
    log["a" /* default */].debug("HTSB: Appending new html text tracks", data);
    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;
    var startTime = timescaledStart != null ? timescaledStart / timescale : undefined;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;
    var cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language);

    if (this.appendWindowStart !== 0 && this.appendWindowEnd !== Infinity) {
      // Removing before window start
      var i = 0;

      while (i < cues.length && cues[i].end <= this.appendWindowStart) {
        i++;
      }

      cues.splice(0, i);
      i = 0;

      while (i < cues.length && cues[i].start < this.appendWindowStart) {
        cues[i].start = this.appendWindowStart;
        i++;
      } // Removing after window end


      i = cues.length - 1;

      while (i >= 0 && cues[i].start >= this.appendWindowEnd) {
        i--;
      }

      cues.splice(i, cues.length);
      i = cues.length - 1;

      while (i >= 0 && cues[i].end > this.appendWindowEnd) {
        cues[i].end = this.appendWindowEnd;
        i--;
      }
    }

    var start;

    if (startTime != null) {
      start = Math.max(this.appendWindowStart, startTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("HTSB: Current text tracks have no cues nor start time. Aborting");
        return;
      }

      log["a" /* default */].warn("HTSB: No start time given. Guessing from cues.");
      start = cues[0].start;
    }

    var end;

    if (endTime != null) {
      end = Math.min(this.appendWindowEnd, endTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("HTSB: Current text tracks have no cues nor end time. Aborting");
        return;
      }

      log["a" /* default */].warn("HTSB: No end time given. Guessing from cues.");
      end = cues[cues.length - 1].end;
    }

    if (end <= start) {
      log["a" /* default */].warn("HTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
      return;
    }

    this._buffer.insert(cues, start, end);

    this.buffered.insert(start, end);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].debug("HTSB: Removing html text track data", from, to);

    this._buffer.remove(from, to);

    this.buffered.remove(from, to);
  }
  /**
   * Free up ressources from this sourceBuffer
   */
  ;

  _proto._abort = function _abort() {
    log["a" /* default */].debug("HTSB: Aborting html text track SourceBuffer");

    this._disableCurrentCues();

    this._remove(0, Infinity);

    this._destroy$.next();

    this._destroy$.complete();
  }
  /**
   * Remove the current cue from being displayed.
   */
  ;

  _proto._disableCurrentCues = function _disableCurrentCues() {
    this._clearSizeUpdates$.next();

    if (this._currentCues.length > 0) {
      for (var i = 0; i < this._currentCues.length; i++) {
        safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
      }

      this._currentCues = [];
    }
  }
  /**
   * Display a new Cue. If one was already present, it will be replaced.
   * @param {HTMLElement} element
   */
  ;

  _proto._displayCues = function _displayCues(elements) {
    var _this2 = this;

    var nothingChanged = this._currentCues.length === elements.length && this._currentCues.every(function (current, index) {
      return current.element === elements[index];
    });

    if (nothingChanged) {
      return;
    } // Remove and re-display everything
    // TODO More intelligent handling


    this._clearSizeUpdates$.next();

    for (var i = 0; i < this._currentCues.length; i++) {
      safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
    }

    this._currentCues = [];

    for (var _i = 0; _i < elements.length; _i++) {
      var element = elements[_i];
      var resolution = getElementResolution(element);

      this._currentCues.push({
        element: element,
        resolution: resolution
      });

      this._textTrackElement.appendChild(element);
    }

    if (this._currentCues.some(function (cue) {
      return cue.resolution !== null;
    })) {
      // update propertionally-sized elements periodically
      Object(on_height_width_change["a" /* default */])(this._textTrackElement, TEXT_TRACK_SIZE_CHECKS_INTERVAL).pipe(Object(takeUntil["a" /* takeUntil */])(this._clearSizeUpdates$), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe(function (_ref) {
        var height = _ref.height,
            width = _ref.width;

        for (var _i2 = 0; _i2 < _this2._currentCues.length; _i2++) {
          var _this2$_currentCues$_ = _this2._currentCues[_i2],
              _resolution = _this2$_currentCues$_.resolution,
              _element = _this2$_currentCues$_.element;

          if (_resolution !== null) {
            updateProportionalElements(height, width, _resolution, _element);
          }
        }
      });
    }
  };

  return HTMLTextSourceBuffer;
}(abstract_source_buffer["a" /* default */]);


// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (html_text_source_buffer_HTMLTextSourceBuffer);

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./src/compat/add_text_track.ts
var add_text_track = __webpack_require__(167);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(24);

// CONCATENATED MODULE: ./src/compat/remove_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */

function isActiveCue(track, cue) {
  var activeCues = track.activeCues;

  if (activeCues === null) {
    return false;
  }

  for (var i = 0; i < activeCues.length; i++) {
    if (activeCues[i] === cue) {
      return true;
    }
  }

  return false;
}
/**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */


function removeCue(track, cue) {
  // On Firefox, cue doesn't dissapear when it is removed from track. Track
  // should be hidden, and shown again after removing cue, in order to
  // definitely clean the cue.
  if (browser_detection["b" /* isFirefox */] && isActiveCue(track, cue)) {
    var trackMode = track.mode;
    track.mode = "hidden";

    try {
      track.removeCue(cue);
    } catch (err) {
      log["a" /* default */].warn("Compat: Could not remove cue from text track.");
    }

    track.mode = trackMode;
    return;
  }

  try {
    track.removeCue(cue);
  } catch (err) {
    log["a" /* default */].warn("Compat: Could not remove cue from text track.");
  }
}
// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(91);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(14);

// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */

function parseTextTrackToCues(type, data, timestampOffset, language) {
  log["a" /* default */].debug("NTSB: Finding parser for native text tracks:", type);
  var parser = features["a" /* default */].nativeTextTracksParsers[type];

  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }

  log["a" /* default */].debug("NTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log["a" /* default */].debug("NTSB: Parsed successfully!", parsed);
  return parsed;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/native_text_source_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * SourceBuffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextSourceBuffer
 * @extends AbstractSourceBuffer
 */

var native_text_source_buffer_NativeTextSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  inheritsLoose_default()(NativeTextSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
  function NativeTextSourceBuffer(videoElement, hideNativeSubtitle) {
    var _this;

    log["a" /* default */].debug("NTSB: Creating native text track SourceBuffer");
    _this = _AbstractSourceBuffer.call(this) || this;

    var _addTextTrack = Object(add_text_track["a" /* default */])(videoElement, hideNativeSubtitle),
        track = _addTextTrack.track,
        trackElement = _addTextTrack.trackElement;

    _this._videoElement = videoElement;
    _this._track = track;
    _this._trackElement = trackElement;
    return _this;
  }
  /**
   * Append text tracks.
   * @param {Object} data
   */


  var _proto = NativeTextSourceBuffer.prototype;

  _proto._append = function _append(data) {
    log["a" /* default */].debug("NTSB: Appending new native text tracks", data);
    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;
    var startTime = timescaledStart != null ? timescaledStart / timescale : undefined;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;
    var cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);

    if (this.appendWindowStart !== 0 && this.appendWindowEnd !== Infinity) {
      // Removing before window start
      var i = 0;

      while (i < cues.length && cues[i].endTime <= this.appendWindowStart) {
        i++;
      }

      cues.splice(0, i);
      i = 0;

      while (i < cues.length && cues[i].startTime < this.appendWindowStart) {
        cues[i].startTime = this.appendWindowStart;
        i++;
      } // Removing after window end


      i = cues.length - 1;

      while (i >= 0 && cues[i].startTime >= this.appendWindowEnd) {
        i--;
      }

      cues.splice(i, cues.length);
      i = cues.length - 1;

      while (i >= 0 && cues[i].endTime > this.appendWindowEnd) {
        cues[i].endTime = this.appendWindowEnd;
        i--;
      }
    }

    var start;

    if (startTime != null) {
      start = Math.max(this.appendWindowStart, startTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("NTSB: Current text tracks have no cues nor start time. Aborting");
        return;
      }

      log["a" /* default */].warn("NTSB: No start time given. Guessing from cues.");
      start = cues[0].startTime;
    }

    var end;

    if (endTime != null) {
      end = Math.min(this.appendWindowEnd, endTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("NTSB: Current text tracks have no cues nor end time. Aborting");
        return;
      }

      log["a" /* default */].warn("NTSB: No end time given. Guessing from cues.");
      end = cues[cues.length - 1].endTime;
    }

    if (end <= start) {
      log["a" /* default */].warn("NTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
      return;
    }

    if (cues.length <= 0) {
      this.buffered.insert(start, end);
      return;
    }

    var firstCue = cues[0]; // NOTE(compat): cleanup all current cues if the newly added
    // ones are in the past. this is supposed to fix an issue on
    // IE/Edge.
    // TODO Move to compat

    var currentCues = this._track.cues;

    if (currentCues !== null && currentCues.length > 0) {
      if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
        this._remove(firstCue.startTime, +Infinity);
      }
    }

    for (var _i = 0; _i < cues.length; _i++) {
      this._track.addCue(cues[_i]);
    }

    this.buffered.insert(start, end);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].debug("NTSB: Removing native text track data", from, to);
    var track = this._track;
    var cues = track.cues;

    if (cues != null) {
      for (var i = cues.length - 1; i >= 0; i--) {
        var cue = cues[i];
        var startTime = cue.startTime,
            endTime = cue.endTime;

        if (startTime >= from && startTime <= to && endTime <= to) {
          removeCue(track, cue);
        }
      }
    }

    this.buffered.remove(from, to);
  };

  _proto._abort = function _abort() {
    log["a" /* default */].debug("NTSB: Aborting native text track SourceBuffer");

    this._remove(0, Infinity);

    var _trackElement = this._trackElement,
        _videoElement = this._videoElement;

    if (_trackElement !== undefined && _videoElement != null && _videoElement.hasChildNodes()) {
      try {
        _videoElement.removeChild(_trackElement);
      } catch (e) {
        log["a" /* default */].warn("NTSB: Can't remove track element from the video");
      }
    }

    if (this._track != null) {
      this._track.mode = "disabled";
    }

    if (this._trackElement != null) {
      this._trackElement.innerHTML = "";
    }
  };

  return NativeTextSourceBuffer;
}(abstract_source_buffer["a" /* default */]);


// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var text_native = __webpack_exports__["default"] = (native_text_source_buffer_NativeTextSourceBuffer);

/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(168);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(128);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(140);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(70);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(13);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */

function setSettingsOnCue(settings, cue) {
  if (Object(is_non_empty_string["a" /* default */])(settings.vertical) && (settings.vertical === "rl" || settings.vertical === "lr")) {
    cue.vertical = settings.vertical;
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.line)) {
    // Capture groups:
    //   1 -> percentage position
    //   2 -> optional decimals from percentage position
    //   3 -> optional follow-up of the string indicating alignment value
    //   4 -> alignment value
    var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
    var percentageMatches = settings.line.match(percentagePosition);

    if (Array.isArray(percentageMatches)) {
      cue.line = Number(percentageMatches[1]);
      cue.snapToLines = false;

      if (Object(array_includes["a" /* default */])(["start", "center", "end"], percentageMatches[4])) {
        cue.lineAlign = percentageMatches[4];
      }
    } else {
      // Capture groups:
      //   1 -> line number
      //   2 -> optional follow-up of the string indicating alignment value
      //   3 -> alignment value
      var linePosition = /^(-?\d+)(,([a-z]+))?/;
      var lineMatches = settings.line.match(linePosition);

      if (Array.isArray(lineMatches)) {
        cue.line = Number(lineMatches[1]);
        cue.snapToLines = true;

        if (Object(array_includes["a" /* default */])(["start", "center", "end"], lineMatches[3])) {
          cue.lineAlign = lineMatches[3];
        }
      }
    }
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.position)) {
    var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
    var positionArr = positionRegex.exec(settings.position);

    if (Array.isArray(positionArr) && positionArr.length >= 2) {
      var position = parseInt(positionArr[1], 10);

      if (!isNaN(position)) {
        cue.position = position;

        if (positionArr[2] !== undefined) {
          cue.positionAlign = positionArr[2];
        }
      }
    }
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.size)) {
    cue.size = settings.size;
  }

  if (typeof settings.align === "string" && Object(array_includes["a" /* default */])(["start", "center", "end", "left"], settings.align)) {
    cue.align = settings.align;
  }
}
// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(129);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */

function toNativeCue(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var text = payload.join("\n");
  return Object(make_vtt_cue["a" /* default */])(start, end, text);
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */





 // Simple VTT to ICompatVTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.

/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */

function parseVTTStringToVTTCues(vttStr, timeOffset) {
  // WEBVTT authorize CRLF, LF or CR as line terminators
  var lines = vttStr.split(/\r\n|\n|\r/);

  if (!/^WEBVTT($| |\t)/.test(lines[0])) {
    throw new Error("Can't parse WebVTT: Invalid file.");
  }

  var firstLineAfterHeader = Object(utils["b" /* getFirstLineAfterHeader */])(lines);
  var cueBlocks = Object(get_cue_blocks["a" /* default */])(lines, firstLineAfterHeader);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(parse_cue_block["a" /* default */])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var nativeCue = toNativeCue(cueObject);

      if (nativeCue != null) {
        if (Object(is_vtt_cue["a" /* default */])(nativeCue)) {
          setSettingsOnCue(cueObject.settings, nativeCue);
        }

        cues.push(nativeCue);
      }
    }
  }

  return cues;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var webvtt_native = __webpack_exports__["default"] = (parseVTTStringToVTTCues);

/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inheritsLoose.js
var inheritsLoose = __webpack_require__(16);
var inheritsLoose_default = /*#__PURE__*/__webpack_require__.n(inheritsLoose);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(91);

// CONCATENATED MODULE: ./src/custom_source_buffers/image/image_source_buffer.ts


/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


/**
 * Image SourceBuffer implementation.
 * @class ImageSourceBuffer
 */

var image_source_buffer_ImageSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  inheritsLoose_default()(ImageSourceBuffer, _AbstractSourceBuffer);

  function ImageSourceBuffer() {
    return _AbstractSourceBuffer.apply(this, arguments) || this;
  }

  var _proto = ImageSourceBuffer.prototype;

  /**
   * @param {Object} data
   */
  _proto._append = function _append(data) {
    log["a" /* default */].debug("ImageSourceBuffer: appending new data.");
    var start = data.start,
        end = data.end,
        timescale = data.timescale;
    var timescaledStart = start / timescale;
    var timescaledEnd = end == null ? Number.MAX_VALUE : end / timescale;
    var startTime = Math.max(this.appendWindowStart, timescaledStart);
    var endTime = Math.min(this.appendWindowEnd, timescaledEnd);
    this.buffered.insert(startTime, endTime);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].info("ImageSourceBuffer: ignored image data remove order", from, to); // Logic removed as it caused more problems than it resolved:
    // Image thumbnails are always downloaded as a single BIF file, meaning that
    // any removing might necessitate to re-load the whole file in the future
    // which seems pointless.
    // In any case, image handling through the regular RxPlayer APIs has been
    // completely deprecated now for several reasons, and should disappear in
    // the next major version.
  };

  _proto._abort = function _abort() {
    log["a" /* default */].debug("ImageSourceBuffer: aborting image SourceBuffer");

    this._remove(0, Infinity);
  };

  return ImageSourceBuffer;
}(abstract_source_buffer["a" /* default */]);

/* harmony default export */ var image_source_buffer = (image_source_buffer_ImageSourceBuffer);
// CONCATENATED MODULE: ./src/custom_source_buffers/image/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var custom_source_buffers_image = __webpack_exports__["default"] = (image_source_buffer);

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(129);

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(168);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(15);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(8);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
var get_parameters = __webpack_require__(130);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(89);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts + 1 modules
var get_styling = __webpack_require__(41);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(141);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/nodes.ts
var nodes = __webpack_require__(66);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(17);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
var resolve_styles_inheritance = __webpack_require__(131);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_ttml_to_vtt.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Style attributes currently used.
 */

var WANTED_STYLE_ATTRIBUTES = ["extent", "writingMode", "origin", "align"];
var TEXT_ALIGN_TO_LIGN_ALIGN = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
/**
 * @type {Object}
 */

var TEXT_ALIGN_TO_POSITION_ALIGN = {
  left: "line-left",
  center: "center",
  right: "line-right"
};
/**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */

function parseTTMLStringToVTT(str, timeOffset) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml !== null && xml !== undefined) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];

    if (tt === undefined) {
      throw new Error("invalid XML");
    }

    var body = Object(nodes["a" /* getBodyNode */])(tt);
    var styleNodes = Object(nodes["c" /* getStyleNodes */])(tt);
    var regionNodes = Object(nodes["b" /* getRegionNodes */])(tt);
    var paragraphNodes = Object(nodes["d" /* getTextNodes */])(tt);
    var params = Object(get_parameters["a" /* default */])(tt); // construct styles array based on the xml as an optimization

    var styles = [];

    for (var i = 0; i <= styleNodes.length - 1; i++) {
      // TODO styles referencing other styles
      var styleNode = styleNodes[i];

      if (styleNode instanceof Element) {
        var styleID = styleNode.getAttribute("xml:id");

        if (styleID != null) {
          var subStyles = styleNode.getAttribute("style");
          var extendsStyles = subStyles === null ? [] : subStyles.split(" ");
          styles.push({
            id: styleID,
            style: Object(get_styling["b" /* getStylingFromElement */])(styleNode),
            extendsStyles: extendsStyles
          });
        }
      }
    }

    Object(resolve_styles_inheritance["a" /* default */])(styles); // construct regions array based on the xml as an optimization

    var regions = [];

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      var regionNode = regionNodes[_i];

      if (regionNode instanceof Element) {
        var regionID = regionNode.getAttribute("xml:id");

        if (regionID != null) {
          (function () {
            var regionStyle = Object(get_styling["b" /* getStylingFromElement */])(regionNode);
            var associatedStyle = regionNode.getAttribute("style");

            if (Object(is_non_empty_string["a" /* default */])(associatedStyle)) {
              var style = Object(array_find["a" /* default */])(styles, function (x) {
                return x.id === associatedStyle;
              });

              if (style !== undefined) {
                regionStyle = Object(object_assign["a" /* default */])({}, style.style, regionStyle);
              }
            }

            regions.push({
              id: regionID,
              style: regionStyle,
              // already handled
              extendsStyles: []
            });
          })();
        }
      }
    } // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.


    var bodyStyle = body !== null ? Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [body], styles, regions) : Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [], styles, regions);
    var bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : undefined;
    var shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || params.spaceStyle === "default";

    for (var _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
      var paragraph = paragraphNodes[_i2];

      if (paragraph instanceof Element) {
        var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
        var paragraphStyle = Object(object_assign["a" /* default */])({}, bodyStyle, Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
        var paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnParagraph = Object(is_non_empty_string["a" /* default */])(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
        var cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params, shouldTrimWhiteSpaceOnParagraph);

        if (cue !== null) {
          ret.push(cue);
        }
      }
    }
  }

  return ret;
}
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {TextTrackCue|null}
 */


function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params, shouldTrimWhiteSpace) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }

  var _getTimeDelimiters = Object(get_time_delimiters["a" /* default */])(paragraph, params),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var text = generateTextContent(paragraph, shouldTrimWhiteSpace);
  var cue = Object(make_vtt_cue["a" /* default */])(start + offset, end + offset, text);

  if (cue === null) {
    return null;
  }

  if (Object(is_vtt_cue["a" /* default */])(cue)) {
    addStyle(cue, paragraphStyle);
  }

  return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */


function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
  function loop(node, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var text = "";

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var textContent = currentNode.textContent;

        if (textContent === null) {
          textContent = "";
        }

        if (shouldTrimWhiteSpaceFromParent) {
          // 1. Trim leading and trailing whitespace.
          // 2. Collapse multiple spaces into one.
          var trimmed = textContent.trim();
          trimmed = trimmed.replace(/\s+/g, " ");
          textContent = trimmed;
        } // DOM Parser turns HTML escape caracters into caracters,
        // that may be misinterpreted by VTTCue API (typically, less-than sign
        // and greater-than sign can be interpreted as HTML tags signs).
        // Original escaped caracters must be conserved.


        var escapedTextContent = textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
        text += escapedTextContent;
      } else if (currentNode.nodeName === "br") {
        text += "\n";
      } else if (currentNode.nodeName === "span" && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceForSpan = Object(is_non_empty_string["a" /* default */])(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent;
        text += loop(currentNode, shouldTrimWhiteSpaceForSpan);
      }
    }

    return text;
  }

  return loop(paragraph, shouldTrimWhiteSpaceForParagraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */


function addStyle(cue, style) {
  var extent = style.extent;

  if (Object(is_non_empty_string["a" /* default */])(extent)) {
    var results = regexps["d" /* REGXP_PERCENT_VALUES */].exec(extent);

    if (results != null) {
      // Use width value of the extent attribute for size.
      // Height value is ignored.
      cue.size = Number(results[1]);
    }
  }

  var writingMode = style.writingMode; // let isVerticalText = true;

  switch (writingMode) {
    case "tb":
    case "tblr":
      cue.vertical = "lr";
      break;

    case "tbrl":
      cue.vertical = "rl";
      break;

    default:
      // isVerticalText = false;
      break;
  }

  var origin = style.origin;

  if (Object(is_non_empty_string["a" /* default */])(origin)) {
    var _results = regexps["d" /* REGXP_PERCENT_VALUES */].exec(origin);

    if (_results != null) {// for vertical text use first coordinate of tts:origin
      // to represent line of the cue and second - for position.
      // Otherwise (horizontal), use them the other way around.
      // if (isVerticalText) {
      // TODO check and uncomment
      // cue.position = Number(results[2]);
      // cue.line = Number(results[1]);
      // } else {
      // TODO check and uncomment
      // cue.position = Number(results[1]);
      // cue.line = Number(results[2]);
      // }
      // A boolean indicating whether the line is an integer
      // number of lines (using the line dimensions of the first
      // line of the cue), or whether it is a percentage of the
      // dimension of the video. The flag is set to true when lines
      // are counted, and false otherwise.
      // TODO check and uncomment
      // cue.snapToLines = false;
    }
  }

  var align = style.align;

  if (Object(is_non_empty_string["a" /* default */])(align)) {
    cue.align = align;

    if (align === "center") {
      if (cue.align !== "center") {
        // Workaround for a Chrome bug http://crbug.com/663797
        // Chrome does not support align = "center"
        cue.align = "middle";
      }

      cue.position = "auto";
    }

    var positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align];
    cue.positionAlign = positionAlign === undefined ? "" : positionAlign;
    var lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align];
    cue.lineAlign = lineAlign === undefined ? "" : lineAlign;
  }
}

/* harmony default export */ var parse_ttml_to_vtt = (parseTTMLStringToVTT);
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var ttml_native = __webpack_exports__["default"] = (parse_ttml_to_vtt);

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fromEvent; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




var toString = /*@__PURE__*/ (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__[/* isFunction */ "a"])(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__[/* map */ "a"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "a"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interval; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map


/***/ }),
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return combineLatest; });
/* unused harmony export CombineLatestOperator */
/* unused harmony export CombineLatestSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = undefined;
    var scheduler = undefined;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__[/* isArray */ "a"])(observables[0])) {
        observables = observables[0];
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__[/* fromArray */ "a"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());

var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__[/* subscribeToResult */ "a"])(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* OuterSubscriber */ "a"]));

//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return takeUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* innerSubscribe */ "c"])(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* SimpleInnerSubscriber */ "a"](takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__[/* SimpleOuterSubscriber */ "b"]));
//# sourceMappingURL=takeUntil.js.map


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closeSession$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(188);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(189);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(187);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Close session and returns and observable that emits when
 * the session is closed.
 * @param {MediaKeySession|Object} session
 * @returns {Observable}
 */

function closeSession$(session) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* race */ "a"])(Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(session.close()), // If the session is not closed after 1000ms, try
  // to call another method on session to guess if
  // session is closed or not.
  Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* timer */ "a"])(1000).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* mergeMap */ "a"])(function () {
    var tryToUpdateSession$ = Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(session.update(new Uint8Array(1)));
    return tryToUpdateSession$.pipe( // Update has resolved, so we can't know if session is closed
    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function () {
      throw new Error("Compat: Couldn't know if session is " + "closed");
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* catchError */ "a"])(function (err) {
      // The caught error can tell if session is closed
      // (Chrome may throw this error)
      if (err instanceof Error && err.message === "The session is already closed.") {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(null);
      } // The `closed` promise may resolve, even if `close()` result has not
      // (it may happen on Firefox). Wait for it and timeout after 1 second.


      var sessionIsClosed$ = Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(session.closed);
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* race */ "a"])(sessionIsClosed$, Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* timer */ "a"])(1000).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function () {
        throw new Error("Compat: Couldn't know if session is " + "closed");
      })));
    }));
  })));
}

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInitData; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(118);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the SourceBuffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Uint8Array} - Initialization data, "cleaned"
 */

function cleanEncryptedEvent(initData) {
  var resInitData = new Uint8Array();
  var encounteredPSSHs = [];
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_3__[/* PSSH_TO_INTEGER */ "a"]) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var currentPSSH = initData.subarray(offset, offset + len);

    if (isPSSHAlreadyEncountered(encounteredPSSHs, currentPSSH)) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Duplicated PSSH found in initialization data, removing it.");
    } else {
      resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "e"])(resInitData, currentPSSH);
      encounteredPSSHs.push(initData);
    }

    offset += len;
  }

  if (offset !== initData.length) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
    return initData;
  }

  return resInitData;
}
/**
 * Returns `true` if the given PSSH has already been stored in the
 * `encounteredPSSHs` cache given.
 * Returns `false` otherwise.
 * @param {Array.<Object>} encounteredPSSHs
 * @param {Uint8Array} pssh
 * @returns {boolean}
 */


function isPSSHAlreadyEncountered(encounteredPSSHs, pssh) {
  for (var i = 0; i < encounteredPSSHs.length; i++) {
    var item = encounteredPSSHs[i];

    if (Object(_utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(pssh, item)) {
      return true;
    }
  }

  return false;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */


function getInitData(encryptedEvent) {
  var initData = encryptedEvent.initData,
      initDataType = encryptedEvent.initDataType;

  if (initData == null) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: No init data found on media encrypted event.");
    return {
      initData: initData,
      initDataType: initDataType
    };
  }

  var initDataBytes = new Uint8Array(initData);
  return {
    initData: cleanEncryptedEvent(initDataBytes),
    initDataType: encryptedEvent.initDataType
  };
}

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export patchInitData */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateKeyRequest; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(118);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Modify "initialization data" sent to a `generateKeyRequest` EME call to
 * improve the player's browser compatibility:
 *
 *   1. some browsers/CDM have problems when the CENC PSSH box is the first
 *      encountered PSSH box in the initialization data (for the moment just
 *      Edge was noted with this behavior).
 *      We found however that it works on every browser when the CENC pssh
 *      box(es) is/are the last box(es) encountered.
 *
 *      To that end, we move CENC pssh boxes at the end of the initialization
 *      data in this function.
 *
 *   2. Some poorly encoded/packaged contents communicate both a CENC with a
 *      pssh version of 0 and one with a version of 1. We found out that this is
 *      not always well handled on some devices/browsers (on Edge and some other
 *      embedded devices that shall remain nameless for now!).
 *
 *      Here this function will filter out CENC pssh with a version different to
 *      1 when one(s) with a version of 1 is/are already present.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */

function patchInitData(initData) {
  _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Compat: Trying to move CENC PSSH from init data at the end of it.");
  var foundCencV1 = false;
  var concatenatedCencs = new Uint8Array();
  var resInitData = new Uint8Array();
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* be4toi */ "c"])(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_5__[/* PSSH_TO_INTEGER */ "a"]) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* be4toi */ "c"])(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var currentPSSH = initData.subarray(offset, offset + len); // yep

    if (initData[offset + 12] === 0x10 && initData[offset + 13] === 0x77 && initData[offset + 14] === 0xEF && initData[offset + 15] === 0xEC && initData[offset + 16] === 0xC0 && initData[offset + 17] === 0xB2 && initData[offset + 18] === 0x4D && initData[offset + 19] === 0x02 && initData[offset + 20] === 0xAC && initData[offset + 21] === 0xE3 && initData[offset + 22] === 0x3C && initData[offset + 23] === 0x1E && initData[offset + 24] === 0x52 && initData[offset + 25] === 0xE2 && initData[offset + 26] === 0xFB && initData[offset + 27] === 0x4B) {
      var cencOffsets = Object(_parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_2__[/* getNextBoxOffsets */ "d"])(currentPSSH);
      var version = cencOffsets === null ? undefined : currentPSSH[cencOffsets[1]];
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Compat: CENC PSSH found with version", version);

      if (version === undefined) {
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: could not read version of CENC PSSH");
      } else if (foundCencV1 === (version === 1)) {
        // Either `concatenatedCencs` only contains v1 or does not contain any
        concatenatedCencs = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* concat */ "e"])(concatenatedCencs, currentPSSH);
      } else if (version === 1) {
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: cenc version 1 encountered, " + "removing every other cenc pssh box.");
        concatenatedCencs = currentPSSH;
        foundCencV1 = true;
      } else {
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: filtering out cenc pssh box with wrong version", version);
      }
    } else {
      resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* concat */ "e"])(resInitData, currentPSSH);
    }

    offset += len;
  }

  if (offset !== initData.length) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }

  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_3__[/* concat */ "e"])(resInitData, concatenatedCencs);
}
/**
 * Generate a request from session.
 * @param {MediaKeySession}session - MediaKeySession on which the request will
 * be done.
 * @param {Uint8Array}initData - Initialization data given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} initDataType - Initialization data type given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} sessionType - Type of session you want to generate. Consult
 * EME Specification for more information on session types.
 * @returns {Observable} - Emit when done. Errors if fails.
 */

function generateKeyRequest(session, initData, initDataType) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].debug("Compat: Calling generateRequest on the MediaKeySession");
    var patchedInit;

    try {
      patchedInit = patchInitData(initData);
    } catch (_e) {
      patchedInit = initData;
    }

    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(session.generateRequest(initDataType == null ? "" : initDataType, patchedInit));
  });
}

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StaticRepresentationIndex; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */

var StaticRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} infos
   */
  function StaticRepresentationIndex(infos) {
    this._mediaURLs = infos.media;
  }
  /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */


  var _proto = StaticRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return null;
  }
  /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments() {
    return [{
      id: "0",
      isInit: false,
      number: 0,
      time: 0,
      duration: Number.MAX_VALUE,
      timescale: 1,
      mediaURLs: [this._mediaURLs]
    }];
  }
  /**
   * Returns first position in index.
   * @returns {undefined}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    return;
    /* tslint:enable return-undefined */
  }
  /**
   * Returns last position in index.
   * @returns {undefined}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    return;
  }
  /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * Returns true as a static file should never need lose availability.
   * @returns {Boolean}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isInitialized = function isInitialized() {
    return true;
  };

  _proto._addSegments = function _addSegments() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried add Segments to a static RepresentationIndex");
  };

  _proto._replace = function _replace() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried to replace a static RepresentationIndex");
  };

  _proto._update = function _update() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried to update a static RepresentationIndex");
  };

  return StaticRepresentationIndex;
}();



/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return takePSSHOut; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Replace every PSSH box from an ISOBMFF segment by FREE boxes and returns the
 * removed PSSH in an array.
 * Useful to manually manage encryption while avoiding the round-trip with the
 * browser's encrypted event.
 * @param {Uint8Array} data - the ISOBMFF segment
 * @returns {Array.<Uint8Array>} - The extracted PSSH boxes. In the order they
 * are encountered.
 */

function takePSSHOut(data) {
  var i = 0;
  var moov = Object(_get_box__WEBPACK_IMPORTED_MODULE_2__[/* getBoxContent */ "b"])(data, 0x6D6F6F76
  /* moov */
  );

  if (moov === null) {
    return [];
  }

  var psshBoxes = [];

  while (i < moov.length) {
    var psshOffsets = void 0;

    try {
      psshOffsets = Object(_get_box__WEBPACK_IMPORTED_MODULE_2__[/* getBoxOffsets */ "c"])(moov, 0x70737368
      /* pssh */
      );
    } catch (e) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("ISOBMFF:", e);
      return psshBoxes;
    }

    if (psshOffsets == null) {
      return psshBoxes;
    }

    var pssh = moov.slice(psshOffsets[0], psshOffsets[2]);
    var systemID = getSystemID(pssh, psshOffsets[1] - psshOffsets[0]);

    if (systemID !== null) {
      psshBoxes.push({
        systemID: systemID,
        data: pssh
      });
    } // replace by `free` box.


    moov[psshOffsets[0] + 4] = 0x66;
    moov[psshOffsets[0] + 5] = 0x72;
    moov[psshOffsets[0] + 6] = 0x65;
    moov[psshOffsets[0] + 7] = 0x65;
    i = psshOffsets[2];
  }

  return psshBoxes;
}
/**
 * Parse systemID from a "pssh" box into an hexadecimal string.
 * @param {Uint8Array} buff - The pssh box
 * @param {number} initialDataOffset - offset of the first byte after the size
 * and name in this pssh box.
 * @returns {string|null}
 */

function getSystemID(buff, initialDataOffset) {
  if (buff[initialDataOffset] > 1) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("ISOBMFF: un-handled PSSH version");
    return null;
  }

  var offset = initialDataOffset + 4;
  /* version + flags */

  if (offset + 16 > buff.length) {
    return null;
  }

  var systemIDBytes = buff.slice(offset, offset + 16);
  return Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__[/* bytesToHex */ "a"])(systemIDBytes);
}

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMDHDTimescale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTrackFragmentDecodeTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDurationFromTrun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getSegmentsFromSidx; });
/* unused harmony export patchPssh */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return updateBoxLength; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _create_box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(180);
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
/* harmony import */ var _read__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(143);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse the sidx part (segment index) of an ISOBMFF buffer and construct a
 * corresponding Array of available segments.
 *
 * Returns `null` if not found.
 * @param {Uint8Array} buf
 * @param {Number} sidxOffsetInWholeSegment
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 */

function getSegmentsFromSidx(buf, sidxOffsetInWholeSegment) {
  var sidxOffsets = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxOffsets */ "c"])(buf, 0x73696478
  /* "sidx" */
  );

  if (sidxOffsets === null) {
    return null;
  }

  var offset = sidxOffsetInWholeSegment;
  var boxSize = sidxOffsets[2] - sidxOffsets[0];
  var cursor = sidxOffsets[1];
  /* version(8) */

  /* flags(24) */

  /* reference_ID(32); */

  /* timescale(32); */

  var version = buf[cursor];
  cursor += 4 + 4;
  var timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, cursor);
  cursor += 4;
  /* earliest_presentation_time(32 / 64) */

  /* first_offset(32 / 64) */

  var time;

  if (version === 0) {
    time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, cursor);
    cursor += 4;
    offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, cursor) + boxSize;
    cursor += 4;
  } else if (version === 1) {
    time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(buf, cursor);
    cursor += 8;
    offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(buf, cursor) + boxSize;
    cursor += 8;
  } else {
    return null;
  }

  var segments = [];
  /* reserved(16) */

  /* reference_count(16) */

  cursor += 2;
  var count = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be2toi */ "a"])(buf, cursor);
  cursor += 2;

  while (--count >= 0) {
    /* reference_type(1) */

    /* reference_size(31) */

    /* segment_duration(32) */

    /* sap..(32) */
    var refChunk = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, cursor);
    cursor += 4;
    var refType = (refChunk & 0x80000000) >>> 31;
    var refSize = refChunk & 0x7FFFFFFF; // when set to 1 indicates that the reference is to a sidx, else to media

    if (refType === 1) {
      throw new Error("sidx with reference_type `1` not yet implemented");
    }

    var duration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, cursor);
    cursor += 4; // let sapChunk = be4toi(buf, cursor + 8);

    cursor += 4; // TODO(pierre): handle sap
    // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
    // let sapType = (sapChunk & 0x70000000) >>> 28;
    // let sapDelta = sapChunk & 0x0FFFFFFF;

    segments.push({
      time: time,
      duration: duration,
      count: 0,
      timescale: timescale,
      range: [offset, offset + refSize - 1]
    });
    time += duration;
    offset += refSize;
  }

  return segments;
}
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 *
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time.
 * `undefined` if not found.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */


function getTrackFragmentDecodeTime(buffer) {
  var traf = Object(_read__WEBPACK_IMPORTED_MODULE_6__[/* getTRAF */ "c"])(buffer);

  if (traf === null) {
    return undefined;
  }

  var tfdt = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxContent */ "b"])(traf, 0x74666474
  /* tfdt */
  );

  if (tfdt === null) {
    return undefined;
  }

  var version = tfdt[0];
  return version === 1 ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be8toi */ "d"])(tfdt, 4) : version === 0 ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(tfdt, 4) : undefined;
}
/**
 * Returns the "default sample duration" which is the default value for duration
 * of samples found in a "traf" ISOBMFF box.
 *
 * Returns `undefined` if no "default sample duration" has been found.
 * @param {Uint8Array} traf
 * @returns {number|undefined}
 */


function getDefaultDurationFromTFHDInTRAF(traf) {
  var tfhd = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxContent */ "b"])(traf, 0x74666864
  /* tfhd */
  );

  if (tfhd === null) {
    return undefined;
  }

  var cursor =
  /* version */
  1;
  var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be3toi */ "b"])(tfhd, cursor);
  cursor += 3;
  var hasBaseDataOffset = (flags & 0x000001) > 0;
  var hasSampleDescriptionIndex = (flags & 0x000002) > 0;
  var hasDefaultSampleDuration = (flags & 0x000008) > 0;

  if (!hasDefaultSampleDuration) {
    return undefined;
  }

  cursor += 4;

  if (hasBaseDataOffset) {
    cursor += 8;
  }

  if (hasSampleDescriptionIndex) {
    cursor += 4;
  }

  var defaultDuration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(tfhd, cursor);
  return defaultDuration;
}
/**
 * Calculate segment duration approximation by additioning the duration from
 * every samples in a trun ISOBMFF box.
 *
 * Returns `undefined` if we could not parse the duration.
 * @param {Uint8Array} buffer
 * @returns {number | undefined}
 */


function getDurationFromTrun(buffer) {
  var traf = Object(_read__WEBPACK_IMPORTED_MODULE_6__[/* getTRAF */ "c"])(buffer);

  if (traf === null) {
    return undefined;
  }

  var trun = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxContent */ "b"])(traf, 0x7472756E
  /* trun */
  );

  if (trun === null) {
    return undefined;
  }

  var cursor = 0;
  var version = trun[cursor];
  cursor += 1;

  if (version > 1) {
    return undefined;
  }

  var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be3toi */ "b"])(trun, cursor);
  cursor += 3;
  var hasSampleDuration = (flags & 0x000100) > 0;
  var defaultDuration = 0;

  if (!hasSampleDuration) {
    defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);

    if (defaultDuration === undefined) {
      return undefined;
    }
  }

  var hasDataOffset = (flags & 0x000001) > 0;
  var hasFirstSampleFlags = (flags & 0x000004) > 0;
  var hasSampleSize = (flags & 0x000200) > 0;
  var hasSampleFlags = (flags & 0x000400) > 0;
  var hasSampleCompositionOffset = (flags & 0x000800) > 0;
  var sampleCounts = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(trun, cursor);
  cursor += 4;

  if (hasDataOffset) {
    cursor += 4;
  }

  if (hasFirstSampleFlags) {
    cursor += 4;
  }

  var i = sampleCounts;
  var duration = 0;

  while (i-- > 0) {
    if (hasSampleDuration) {
      duration += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(trun, cursor);
      cursor += 4;
    } else {
      duration += defaultDuration;
    }

    if (hasSampleSize) {
      cursor += 4;
    }

    if (hasSampleFlags) {
      cursor += 4;
    }

    if (hasSampleCompositionOffset) {
      cursor += 4;
    }
  }

  return duration;
}
/**
 * Get timescale information from a movie header box. Found in init segments.
 * `undefined` if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */


function getMDHDTimescale(buffer) {
  var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_6__[/* getMDIA */ "b"])(buffer);

  if (mdia === null) {
    return undefined;
  }

  var mdhd = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxContent */ "b"])(mdia, 0x6D646864
  /* "mdhd" */
  );

  if (mdhd === null) {
    return undefined;
  }

  var cursor = 0;
  var version = mdhd[cursor];
  cursor += 4;
  return version === 1 ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(mdhd, cursor + 16) : version === 0 ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(mdhd, cursor + 8) : undefined;
}
/**
 * Creates a PSSH box with the given systemId and data.
 * @param {Array.<Object>} psshInfo
 * @returns {Uint8Array}
 */


function createPssh(_ref) {
  var systemId = _ref.systemId,
      privateData = _ref.privateData;

  var _systemId = systemId.replace(/-/g, "");

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"])(_systemId.length === 32);
  return Object(_create_box__WEBPACK_IMPORTED_MODULE_4__[/* createBox */ "a"])("pssh", Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* concat */ "e"])(4, // 4 initial zeroed bytes
  Object(_utils_string_parsing__WEBPACK_IMPORTED_MODULE_2__[/* hexToBytes */ "c"])(_systemId), Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe4 */ "h"])(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the psshList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} psshList
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */


function patchPssh(buf, psshList) {
  if (psshList == null || psshList.length === 0) {
    return buf;
  }

  var moovOffsets = Object(_get_box__WEBPACK_IMPORTED_MODULE_5__[/* getBoxOffsets */ "c"])(buf, 0x6D6F6F76
  /* = "moov" */
  );

  if (moovOffsets === null) {
    return buf;
  }

  var moov = buf.subarray(moovOffsets[0], moovOffsets[2]);
  var moovArr = [moov];

  for (var i = 0; i < psshList.length; i++) {
    moovArr.push(createPssh(psshList[i]));
  }

  var newmoov = updateBoxLength(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* concat */ "e"].apply(void 0, moovArr));
  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* concat */ "e"])(buf.subarray(0, moovOffsets[0]), newmoov, buf.subarray(moovOffsets[2]));
}
/**
 * Returns a new version of the given box with the size updated
 * so it reflects its actual size.
 *
 * You can use this function after modifying a ISOBMFF box so its size is
 * updated.
 *
 * /!\ Please consider that this function might mutate the given Uint8Array
 * in place or might create a new one, depending on the current conditions.
 * @param {Uint8Array} buf - The ISOBMFF box
 * @returns {Uint8Array}
 */


function updateBoxLength(buf) {
  var newLen = buf.length;

  if (newLen < 4) {
    throw new Error("Cannot update box length: box too short");
  }

  var oldSize = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(buf, 0);

  if (oldSize === 0) {
    if (newLen > _constants__WEBPACK_IMPORTED_MODULE_3__[/* MAX_32_BIT_INT */ "a"]) {
      var newBox = new Uint8Array(newLen + 8);
      newBox.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe4 */ "h"])(1), 0);
      newBox.set(buf.subarray(4, 8), 4);
      newBox.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe8 */ "i"])(newLen + 8), 8);
      newBox.set(buf.subarray(8, newLen), 16);
      return newBox;
    } else {
      buf.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe4 */ "h"])(newLen), 0);
      return buf;
    }
  } else if (oldSize === 1) {
    if (newLen < 16) {
      throw new Error("Cannot update box length: box too short");
    }

    buf.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe8 */ "i"])(newLen), 8);
    return buf;
  } else if (newLen <= _constants__WEBPACK_IMPORTED_MODULE_3__[/* MAX_32_BIT_INT */ "a"]) {
    buf.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe4 */ "h"])(newLen), 0);
    return buf;
  } else {
    var _newBox = new Uint8Array(newLen + 8);

    _newBox.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe4 */ "h"])(1), 0);

    _newBox.set(buf.subarray(4, 8), 4);

    _newBox.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* itobe8 */ "i"])(newLen + 8), 8);

    _newBox.set(buf.subarray(8, newLen), 16);

    return _newBox;
  }
}



/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return scan; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=scan.js.map


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return switchMapTo; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(142);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__[/* switchMap */ "a"])(function () { return innerObservable; }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__[/* switchMap */ "a"])(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map


/***/ })
/******/ ])["default"];
});